TYPE "UDT_ModuleState"
TITLE = UDT_ModuleState
VERSION : 0.1
//User-defined structure of module states.
   STRUCT
      Configured { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Module configured
      Exist { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Module exist
      Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Module has error
   END_STRUCT;

END_TYPE

TYPE "UDT_DeviceState"
TITLE = UDT_DeviceState
VERSION : 0.1
//User-defined structure of device states.
   STRUCT
      Configure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Device configured in TIA Portal hardware
      Exist { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Device physically connected
      Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Device has an error
      ProfinetNumber : UInt;   // Profinet slave number
      HW_ID : UInt;   // Device's HW_ID
      PNDeviceName : String;   // Device's project name
   END_STRUCT;

END_TYPE

TYPE "UDT_GINDHL"
VERSION : 0.1
   STRUCT
      ObjectID : String[10];   // Object ID
      VID : String[16];   // Virtual Item Identifier (VID)
      PieceID : String[40];   // Piece ID barcodes
      SortStrategy : String[1];   // Sort Strategy 1 - Highest priority available , 2 - Nearest
      ParcelReject { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Parcel reject
      Destination : Array[1..6] of Struct   // Destination
         ID : UInt;   // ID
         SortCommandActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sort command
         ParcelSorted { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parcel sorted
         Rejected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parcel rejected
         Reason : Int;   // Reason
      END_STRUCT;
      ParcelLocation : Struct   // Parcel Location
         Current : UInt;   // Current
         Last : UInt;   // Last
         Sort : UInt;   // Sort
      END_STRUCT;
      MFCMessage : Struct   // MFC Sort messages
         Sent : Struct   // Messages sent from the PLC to the MFC system
            SortResult { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Sort Result
            VIDResponse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message VID Response
            ScanReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Scan Reset
            XrayResult { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Xray result
            ParcelRegInfo { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Xray registration info
         END_STRUCT;
         Received : Struct   // Messages received from the MFC system to the PLC
            RejectParcel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Reject Parcel
            Destination { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Destination
            DestinationResent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Destination Resent
            TemporaryParcelIdentifier { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Temporary Parcel Identifier
            XrayRegistrationInfo { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         END_STRUCT;
      END_STRUCT;
      Xray : Struct   // Xray data structure
         RoutingCode : String[2];   // Routing code
         Group : String[1];   // The group field is used to identify the group of the operator decisions came from in a
         Level : String[1];   // Level field is used to identify which level the operator decision came from in a
         Result : String[1];   // Results can be indicated with the following:A = Accept, R = Reject, U = Unavailable (Timeout), Z = High Threat
         BagIDMessage : Struct   // Message from PLC to Xray
            MessagePrepared { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message is prepared and ready to send
            WrongMessageStructure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message has wrong structure
            Sent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message sent by PLC to Xray
            SentTime : String;   // Time when message sent by PLC to Xray
            NotSent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message was not sent from the PLC
            Received { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message received by Xray
            TimeReceived : String;   // Time when message received by Xray
            NotReceived { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message did not reach Xray
         END_STRUCT;
         DecisionMessage : Struct   // Message from Xray to PLC
            Received { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message received by PLC
            ReceivedTime : String;   // The message received by PLC
            NotReceivedOnTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message did not reach PLC
         END_STRUCT;
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_GINFedEx"
VERSION : 0.1
   STRUCT
      Timestamp : String[17];   // Local time timestamp
      TimeZoneDesignator : String[5];   // Time zone designator
      PackageEntrancePoint : String[14];   // Entrance point, where LLC starts tracking the parcel.
      PackageEntranceState : String[1];   // Entrance state
      PackageExitPoint : String[14];   // Exit point name, where LLC reports the last known tracking point.
      PackageExitState : String[1];   // Exit point state when LLC reports the last known tracking point.
      PalletType : String[2];   // Pallet code for different type of pallets on the market
      Mask : String[1];   // Flag to indicate that a pallet has been mask.
      CellNumber : String[4];   // Tray/Cell number (for loop sorters) or generated by LLC (on line sorters).
      CellsOccupied : String[1];   // Cells occupied by the piece for loop sorters.
      ImageID : String[6];   // Image ID number created by the ADC system.
      ScanUnitType : String[1];   // Scan unit type
      ADCSystemID : String[15];   // Number assigned by the ADC system
      PackageID : String[15];   // Number assigned by the LLC system
      LLCSystemID : String[15];
      HLCPackageID : String[10];   // Unique number for the specific package during it stays in HLC system.
      HLCResultCode : String[16];   // Result code based on processing of the scan event messages.
      ShipmentID : String[6];   // Consignment id of the parcel.
      WeightStatus : String[1];   // Status to indicate if the parcel/pallet has weight on the system.
      ActualDestination : String[6];   // Location code value that describes the actual disposition of the package.
      Destination1 : String[6];   // Location code value that describes where the package should go (Diverter Number).
      Destination2 : String[6];   // Location code value that describes where the package should go (Diverter Number).
      Destination3 : String[6];   // Location code value that describes where the package should go (Diverter Number).
      Destination4 : String[6];   // Location code value that describes where the package should go (Diverter Number).
      Destination5 : String[6];   // Location code value that describes where the package should go (Diverter Number).
      CutOffTimeDestination1 : String[5];   // Cut Off Time in Local Time.
      CutOffTimeDestination2 : String[5];   // Cut Off Time in Local Time.
      CutOffTimeDestination3 : String[5];   // Cut Off Time in Local Time.
      CutOffTimeDestination4 : String[5];   // Cut Off Time in Local Time.
      CutOffTimeDestination5 : String[5];   // Cut Off Time in Local Time.
      ReasonCode1 : String[8];   // Management Code value that describes the result of attempting to route the package to the Destination
      ReasonCode2 : String[8];   // Management Code value that describes the result of attempting to route the package to the Destination
      ReasonCode3 : String[8];   // Management Code value that describes the result of attempting to route the package to the Destination
      ReasonCode4 : String[8];   // Management Code value that describes the result of attempting to route the package to the Destination
      ReasonCode5 : String[8];   // Management Code value that describes the result of attempting to route the package to the Destination
      HLCDataText : String[20];   // Free text for future use.
      Customs : String[1];   // Need to be checked by customs
      DIMSystemID : String[15];   // Identifier of dimensioning system.
      DIMStatus : String[5];   // Basic diagnostic information from the dimensioning system at the moment of the measurement.
      PackageDimLength : String[6];   // Length dimension of package in resolution of dim system.
      PackageDimWidth : String[6];   // Width dimension of package in resolution of dim system.
      PackageDimHeight : String[6];   // Height dimension of package in resolution of dim system.
      DIMUOM : String[2];   // Unit of measure of the package dimensions.
      DimLFTstatusCode : String[8];   // Dimension LFT status code.
      DimConfidence : String[2];   // The level of assurance for the correct dimensions.
      DimensionSource : String[1];   // For combined camera/laser dim acquisition devices. It indicates type of capturing mode
      AlibiDims : String[25];   // Alibi for Dimensions
      SCLSystemID : String[15];   // Identifier of weight scale.
      SCLStatus : String[5];   // Basic diagnostic information from the weight scale system.
      SCLWT : String[6];   // Scale weight of package in resolution of scale system.
      SCLWTUOM : String[2];   // Unit of measurement for Weight
      SCLLFTStatusCode : String[2];   // Scale LFT status code.
      AlibiWeight : String[25];   // Alibi for Weight
      ReasonCode : String[1];   // This code should be used when the SI message has some defect.
      Stackable : String[1];   // If stackable recognition is enabled, Y or N
      Stickerstype : String[2];   // When optical recognition is used to sort
      FlyingDocument : String[1];   // Status to confirm if the document/flyer is prone to fly off the sorter.
      ModeofOperation : String[1];   // Camera Tunnel operational mode format:
      CameraHeadstatus : String[2];   // Diagnostic information on camera/laser heads performing barcode reads.
      PackageDataTruncated : String[1];   // Y = Full length of barcode data exceeds 9999 bytes, data truncated
      TotalBarcodeDataLength : String[4];   // Length of all barcode data that was sent in bytes;
      Barcode1Identification : String[3];   // Barcode identifier code.
      Barcode1status : String[2];   // Barcode confidence factor
      Barcode1datalength : String[4];   // String length of barcode data in bytes; inclusive of this field. Use 0054 as a fixed value
      Barcode1data : String[50];   // Highest priority barcode
      Barcode2Identification : String[3];   // Barcode identifier code.
      Barcode2status : String[2];   // Barcode confidence factor
      Barcode2datalength : String[4];   // String length of barcode data in bytes; inclusive of this field. Use 0054 as a fixed value
      Barcode2data : String[50];   // Highest priority barcode
      Barcode3Identification : String[3];   // Barcode identifier code.
      Barcode3status : String[2];   // Barcode confidence factor
      Barcode3datalength : String[4];   // String length of barcode data in bytes; inclusive of this field. Use 0054 as a fixed value
      Barcode3data : String[50];   // Highest priority barcode
      BarcodeIdentification : String[3];   // Barcode identifier code.
      Barcodestatus : String[2];   // Barcode confidence factor
      Barcodedatalength : String[4];   // String length of barcode data in bytes
      Barcodedata : String[50];   // Sortation barcode
      CustomerID : DInt;   // 6 digits SequentialID (NNNNNN)
      AreaNumber : String[2];   // Package Sequence ID "Area Number"
      PurgeEnabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Purge enabled for parcel: destination overwritten with Purge destination
   END_STRUCT;

END_TYPE

TYPE "UDT_GINStandard"
VERSION : 0.1
   STRUCT
      Destination : Array[0..20] of DInt;   // Destination
      Identification : Struct   // Barcode identification
         GoodRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Barcode read was succesful
         NoRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Barcode read was unsuccesful
         MultiRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Multiple Barcodes were detected
         Barcode : Array[0..10] of Char;   // Barcode values
      END_STRUCT;
      GinAssigned { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // GIN is assigned to package
      Lost { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Lost in tracking
      Length : Int;   // Length in mm
      Width : Int;   // Width in mm
      Height : Int;   // Height in mm
      Weight : DInt;   // Weight in g
      PkgTooLong { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is too long
      PkgTooSmall { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is too small
      PkgTooHigh { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is too high
      PkgOverWeight { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is over weight
      TrailingGap : Int;   // Trailing gap size in cm between the package
      LeadingGap : Int;   // Leading gap size in cm between the package
      NrOfRecirculations : Int;   // Number of recirculations
      DestReqSend { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Destination request sent to high level
      DestRcv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Destination received from high level
      SortStatus : Struct   // Sort status of the package
         DivertDestination : Int;   // Destination to which the package is diverted
         GoodDivert { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package diverted
         FailedDivert { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package failed to divert
         NoDivert : Bool := TRUE;   // Divert is not activated
         NoDivertCause : Struct   // Cause for no divert
            ChuteJam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Chute is jammed
            ChuteFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Chute is full
            NoRTR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Downstream conveyor is not ready to receive
            DestDisabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Destination is disabled
            TrayDisabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Tray is disabled
            SorterNotAtSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sorter is not at speed
            LeadingGapError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Gap size with downstream parcel is not enough
            TrailingGapError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Gap size with upstream parcel is not enough
            PkgTooHigh { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is too high to divert
            PkgTooLong { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is too long to divert
            DestNotReachable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sort destionation is not reachable
            InvalidDest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sort destination is invalid
            DestTooLate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Destination too late
            NoDestRcv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Destination not received from high level
         END_STRUCT;
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_ProfinetDevice"
TITLE = UDT_ProfinetDevice
VERSION : 0.1
//User-defined structure of profinet device state.
   STRUCT
      DeviceState : "UDT_DeviceState";   // Device state
      Module { S7_SetPoint := 'False'} : Array[0..31] of "UDT_ModuleState";   // Modules
   END_STRUCT;

END_TYPE

TYPE "UDT_GINWCS"
VERSION : 0.1
   STRUCT
      ActionTaken : String;   // Location code value that describes the actual disposition of the package
      Destination1 : String[20];   // Location code value that describes where the package should go (Diverter Number)
      Destination2 : String[20];   // Location code value that describes where the package should go (Diverter Number)
      Destination3 : String[20];   // Location code value that describes where the package should go (Diverter Number)
      Destination4 : String[20];   // Location code value that describes where the package should go (Diverter Number)
      Destination5 : String[20];   // Location code value that describes where the package should go (Diverter Number)
      ReasonCode : String[2];   // Management Code value that describes the result of attempting to route the package to the Destination
      Barcode1 : String;   // Barcode identifier code
      Barcode2 : String;
      Barcode3 : String;
      Barcode4 : String;
   END_STRUCT;

END_TYPE

TYPE "UDT_GINWES"
VERSION : 0.1
   STRUCT
      Barcode : String[40];
   END_STRUCT;

END_TYPE

TYPE "UDT_GINUPS"
VERSION : 0.1
   STRUCT
      TRKNUM : String[18];   // Tracking number
      PKGUID : String[32];   // Package ID
      MSGID : String[32];   // Message ID
      Length : Int;   // Camera Length in mm
      Width : Int;   // Camera Width in mm
      Height : Int;   // Camera Height in mm
      Weight : DInt;   // Weight in g
      IDCreated { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 1, Bit 0 - PLCID created or TrayID Read
      DimDataRcv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 1, Bit 1 - Package Dimensional Data Received via Camera Scan Data Message
      PkgWrongInduct { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 1, Bit 2 - Package Did NOT Induct Properly (Non-Tray Systems)
      IDCalcFromCamID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 2, Bit 0 - PLCID/TrayID Calculated From CamID
      UnknownParcelID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 2, Bit 4 - Unknown Parcel ID
      UndefinedProblem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 2, Bit 5 - Un-Defined Problem
      UnrecognizedCmd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 2, Bit 6 - Un-recognized command
      SorterInMainteneceMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 2, Bit 7 - Sorter in Maintenance/Commissioning Mode
      DestUserSusp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 3, Bit 3 - Destination User Suspended
      SorterNotSynch { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 3, Bit 6 - Sorter NOT Synchronized (Tilt Tray Systems)
      PkgDetAtVerCheckPoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 4, Bit 0 - Package Detected at Verification Check Point
      ChuteFullAftrAlterDest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 4, Bit 7 - Preferred chute full after passed alternate destination
      ChuteNotAvailAfterAlterDest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 5, Bit 0 - Preferred chute not available after passed alternate destination
      PLCRedirected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 5, Bit 2 - PLC Redirected
      ThreatParcel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Threat parcel
   END_STRUCT;

END_TYPE

DATA_BLOCK "DB_Memory"
TITLE = DB_Memory
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
VERSION : 3.0
NON_RETAIN
   VAR 
      ClockByte { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // System clock byte
      Clock_10Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 10 Hz system clock bit
      Clock_5Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 5 Hz system clock bit
      "Clock_2.5Hz" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 2.5 Hz system clock bit
      Clock_2Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 2 Hz system clock bit
      "Clock_1.25Hz" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1.25 Hz system clock bit
      Clock_1Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 Hz system clock bit
      "Clock_0.625Hz" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0.625 Hz system clock bit
      "Clock_0.5Hz" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0.5 Hz system clock bit
      SystemByte { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // System byte
      OSClockByte { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // One shot of clock pulse
      "OS_0.1sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 0.1 sec
      "OS_0.2sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 0.2 sec
      "OS_0.4sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 0.4 sec
      "OS_0.5sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 0.5 sec
      "OS_0.8sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 0.8 sec
      OS_1sec { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 1 sec
      "OS_1.6sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 1.6 sec
      OS_2sec { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 2 sec
      PrevCycleTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Previous PLC cycle Time
      RuntimeMem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Runtime memory
      FirstScan { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // First scan bit
      DiagStatusUpdate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Diagnostic status update
      AlwaysTrue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Always True bit
      AlwaysFalse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Always False bit
      CommissioningFalse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Commissioning always false
      CommissioningTrue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Commissioning always true
      ReconnectCommand { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reconnect command
      ScanMainRack { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Trigger to check main rack confiuration
      ScanProfinet { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Scan profinet bit
      Simulation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Simulation
      PN1OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet ok
      "Local~PROFINET_IO-System" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IO System
      "Local~PROFINET_IO-System_1" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 1
      "Local~PROFINET_IO-System_2" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 2
      "Local~PROFINET_IO-System_3" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 3
      "Local~PROFINET_IO-System_4" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 4
      "Local~PROFINET_IO-System_5" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 5
      "Local~PROFINET_IO-System_6" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 6
      "Local~PROFINET_IO-System_7" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 7
      "Local~PROFINET_IO-System_8" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 8
      "Local~PROFINET_IO-System_9" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 9
   END_VAR


BEGIN

END_DATA_BLOCK

TYPE "UDT_GIN"
VERSION : 0.1
   STRUCT
      General { S7_SetPoint := 'False'} : "UDT_GINStandard";
      FedEx { S7_SetPoint := 'False'} : "UDT_GINFedEx";
      UPS { S7_SetPoint := 'False'} : "UDT_GINUPS";
      DHL { S7_SetPoint := 'False'} : "UDT_GINDHL";
      WCS { S7_SetPoint := 'False'} : "UDT_GINWCS";
      WES { S7_SetPoint := 'False'} : "UDT_GINWES";
   END_STRUCT;

END_TYPE

TYPE "UDT_FifoStatus"
TITLE = UDT_FifoStatus
VERSION : 0.1
//
//User-defined structure of FC_Fifo function status.
//Version History:
//Date              | Version   | Author         | Remark
//24/05/2019  | 0.1           | K.Pokorski   | first release MHSE TIA 15.1
//24/05/2019  | 0.2           | K.Pokorski   | first release MHSE TIA 15.1
//
   STRUCT
      InvalidMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid mode selected
      InvalidMaxNrOfEntries { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid maximum number of entries or buffer is not an array
      InvalidTotalEntriesStored { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid total number of entries
      InvalidNextEntryToWrite { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid number of next entry to write
      InvalidNextEntryToRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid number of next entry to read
      InvalidDataType { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message and buffer element data type inconsistent
      FifoPreFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 90 % of FIFO data buffer capacity reached
      FifoFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO data buffer full
   END_STRUCT;

END_TYPE

TYPE "UDT_ProfinetNetwork"
TITLE = UDT_ProfinetNetwork
VERSION : 0.1
//User-defined structure of profinet network state.
   STRUCT
      DeviceStatus : Array[0..512] of "UDT_ProfinetDevice";   // Profinet device status
   END_STRUCT;

END_TYPE

TYPE "UDT_FifoHeader"
TITLE = UDT_FifoHeader
VERSION : 0.1
//User-defined structure of FIFO register header information.
   STRUCT
      Status : Struct   // Status bits
         Empty { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO Empty
         Prefull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO Prefull
         Full { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO Full
      END_STRUCT;
      NextEntryToRead : Int;   // Next FIFO entry to read
      NextEntryToWrite : Int;   // Next FIFO entry to write
      MaxNrOfEntries : Int;   // Maximum number of FIFO entries
      TotalEntriesStored : Int;   // Total number of FIFO entries
   END_STRUCT;

END_TYPE

FUNCTION "FC_GetNrOfArrayEl" : Int
TITLE = FC_GetNrOfArrayEl
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 19
// END_ATTRIBUTES
//Function to get the number of array elements.
   VAR_INPUT 
      iv_Array : Variant;   // Input array
   END_VAR

   VAR_TEMP 
      ti_NrOfArrayEl : Int;   // Number of array elements
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	27/08/2019  | 2.1       | K.Pokorski    | Comments adjusted
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – Number of an array elements
	    
	    IF IS_ARRAY(#iv_Array)                                                  // Input variable is an array
	    THEN
	        
	        #ti_NrOfArrayEl := UDINT_TO_INT(CountOfElements(#iv_Array));
	        
	        // Reset array length if the input variable isn't an array
	    ELSE
	        
	        #ti_NrOfArrayEl := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 – Return output
	    
	    #FC_GetNrOfArrayEl := #ti_NrOfArrayEl;
	    
	END_REGION
	
END_FUNCTION

TYPE "UDT_CommonStatus"
TITLE = UDT_CommonStatus
VERSION : 0.1
//User-defined structure of common statuses.
   STRUCT
      SafetyStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Emergancy stop
      Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // An error is active
      Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // A warning is active
      ManualRun { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Running in manual mode
      Manual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // In manual mode
      Halted { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Halted
      Dieback { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // In dieback
      Stopped { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stopped
      Running { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Running
      EnergySave { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // In energy saving mode
      AutoON { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Automatic started
   END_STRUCT;

END_TYPE

TYPE "UDT_EventStatistic"
TITLE = UDT_EventStatistic
VERSION : 0.1
//User-defined structure of event statistic data.
   STRUCT
      NumberOfTimes : DInt;   // Number of times the event occurred since last reset
      LastEventSeconds : DInt;   // Number of seconds of the current or last event
      TotalEventSeconds : DInt;   // Total number of seconds the event occurred since last reset
   END_STRUCT;

END_TYPE

DATA_BLOCK "DB_Time"
TITLE = DB_Time
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
NON_RETAIN
//Data block to store date and time data.
   VAR 
      ActualTimeDTL {InstructionName := 'DTL'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DTL;   // Actual date and time in DTL
      ActualTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Actual date and time in String
      Timestamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[17];   // Actual date and time in String
      DaylightSaving { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
   END_VAR


BEGIN

END_DATA_BLOCK

TYPE "UDT_EquipmentControl"
TITLE = UDT_EquipmentControl
VERSION : 0.1
//User-defined structure of equipment control commands.
   STRUCT
      Command : Struct   // Control command
         Start { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start conveyor
         Stop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stop conveyor
         Reset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Faults reset
         ResetData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Statistics reset
         ManualMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual mode required
         DisableManualMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disable manual mode
         AutomaticOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // System is started in automatic mode
         StopRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      END_STRUCT;
      Report { S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Conveyors state
      Request : Struct   // Request from equipment
         RestartRequired { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Restart required from system control
         SignalingRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Beeper required
         InhibitStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_VfdKebaSystemSpeedAxisConfiguration"
VERSION : 0.1
   STRUCT
      BeltSpeedCorrection : Int := 100;   // Belt speed correction [%]
      Acceleration : UInt;   // VFD ramp up time for monitoring starting [mm/s2]
      Deceleration : UInt;   // VFD ramp up time for monitoring stopping [mm/s2]
      SpeedSetpointWindow : Int := 5;   // VFD speed setpoint window (tolerance) [mm/s]
      DirectionReversal : Bool;   // If true, direction will be swapped
      InterlockFwd : Bool := TRUE;   // False when turning in forward direction is not possible / allowed
      InterlockRvs : Bool := TRUE;   // False when turning in reverse direction is not possible / allowed
   END_STRUCT;

END_TYPE

TYPE "UDT_PNDevice"
VERSION : 0.1
   STRUCT
      PNNetworknumber : Int := 1;   // Number of the profinet network where device exist
      PNDeviceNumber : Int := 0;   // Profinet number of the device
      PNDeviceFound { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Device found in Profinet structure
   END_STRUCT;

END_TYPE

DATA_BLOCK "DB_ProfinetDiagnostic"
TITLE = DB_ProfinetDiagnostic
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
NON_RETAIN
//Data block to store profinet network diagnostic data.
   VAR 
      ProfinetNetworks { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Array[1..10] of "UDT_ProfinetNetwork";
   END_VAR


BEGIN

END_DATA_BLOCK

FUNCTION_BLOCK "FB_TimerOnOffDelay"
TITLE = FB_TimerOnOffDelay
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 32
// END_ATTRIBUTES
//Function block to generate on/off signal delay.
   VAR_INPUT 
      iudi_OnDelayTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // On delay time [ms]
      iudi_OffDelayTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Off delay time [ms]
      ix_SignalToDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Input signal to be delayed
      ix_Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;   // Timer Enable
   END_VAR

   VAR_OUTPUT 
      qlr_ActualTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Actual time
      qx_DelayedSignal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Delayed signal output
   END_VAR

   VAR 
      s_R_TRIG_Signal {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Siemens "R_Trig" - to prepare the rising edge trigger on "ix_SignalToDelay" signal
      s_F_TRIG_Signal {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Siemens "F_Trig" - to prepare the falling edge trigger on "ix_SignalToDelay" signal
   END_VAR
   VAR RETAIN
      slr_ActualDelayTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Actual delay time [ms]
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	26/08/2019  | 2.1       | M.Kurpiers    | Comments adjusted
	04/11/2019  | 2.2       | L.Klar        | Prevoius cycle scan changed from memory to DB variable
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION Step 1 – Input signal edge detection 
	    
	    #s_R_TRIG_Signal(CLK := #ix_SignalToDelay);
	    
	    
	    #s_F_TRIG_Signal(CLK := #ix_SignalToDelay);
	    
	END_REGION
	
	REGION Step 2 – Actual delay time initialization
	    
	    IF (#s_R_TRIG_Signal.Q OR #s_F_TRIG_Signal.Q)           // Input signal changed        
	    THEN
	        
	        #slr_ActualDelayTime := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION Step 3 – On/Off delay time calculation
	    
	    
	    IF (#ix_SignalToDelay                                       // Signal to be delayed is active
	        AND #ix_Enable)                                         // Ttimer enabled                   
	    THEN
	        
	        // Timer on
	        IF (#slr_ActualDelayTime >= #iudi_OnDelayTime)
	        THEN
	            
	            #qx_DelayedSignal := TRUE;
	            
	        ELSE
	            
	            #slr_ActualDelayTime += "DB_Memory".PrevCycleTime;
	            
	        END_IF;
	        
	    END_IF;
	    
	    // Timer off
	    IF (NOT #ix_SignalToDelay                                   // Signal to delay is not active
	        AND #ix_Enable)                                         // Timer is enabled                  
	    THEN
	        
	        IF (#slr_ActualDelayTime >= #iudi_OffDelayTime)
	        THEN
	            
	            #qx_DelayedSignal := FALSE;
	            
	        ELSE
	            
	            #slr_ActualDelayTime += "DB_Memory".PrevCycleTime;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION Step 4 – Actual time
	    
	    #qlr_ActualTime := #slr_ActualDelayTime;
	    
	END_REGION
END_FUNCTION_BLOCK

TYPE "UDT_FedExFacility"
VERSION : 0.1
   STRUCT
      FacilityID : String := '';   // Generated during configuration. It is a fixed value for all systems.
      SystemID : String;   // System ID of the system making the request.
      System : Struct   // System information
         LOC : String;
         TYP : String;
         Number : String;
      END_STRUCT;
      VersionID : String;   // Interface document version.
      TimeZoneDesignator : String;   // Time Zone Designator
      SS : UDInt;   // Maximum frequency of the messages
   END_STRUCT;

END_TYPE

TYPE "UDT_VfdKebaSystemPositioningAxisConfiguration"
VERSION : 0.1
   STRUCT
      PositionWindow : Int;   // Position window (tolerance) [degree]
      PositionMax : Int;   // Maximum allowed position [degree]
      PositionMin : Int;   // Minimum allowed position [degree]
      VFDSpeed : Int;   // Speed to run in automatic mode [degree/s]
      Position : Array[0..10] of Int;   // Positions in degree's to move to as requested
   END_STRUCT;

END_TYPE

TYPE "UDT_StopRollerConfiguration"
VERSION : 0.1
   STRUCT
      BrakePuls : UDInt;   // Time [ms] brake is up in brake function
      BrakePause : UDInt;   // Time [ms] brake is down in brake function
      BrakePauseLong : UDInt;   // Long time [ms] brake is down in brake function
      PECBrakeOnDelay : UDInt;   // On delay time PEC brake signal
      PECBrakeOffDelay : UDInt;   // Off delay time PEC brake signal
      PECStopOnDelay : UDInt;   // On delay time PEC stop signal
      PECStopOffDelay : UDInt;   // Off delay time PEC stop signal
      StopFunctionOnDelay : UDInt;   // On delay time stop function
      StopFunctionOffDelay : UDInt;   // Off delay time stop function
      FailSafe { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate output to release
   END_STRUCT;

END_TYPE

TYPE "UDT_PneumaticBrakeConfiguration"
VERSION : 0.1
   STRUCT
      BrakePuls : UDInt;   // Time [ms] brake is up in brake function
      BrakePause : UDInt;   // Time [ms] brake is down in brake function
      BrakeCycles : Int;   // Number of brake cycles
      BrakeInterval : UDInt;   // Time [ms] between brake cycles
      PECBrakeOnDelay : UDInt;   // On delay time PEC brake signal
      PECBrakeOffDelay : UDInt;   // Off delay time PEC brake signal
      PECStopOnDelay : UDInt;   // On delay time PEC stop signal
      PECStopOffDelay : UDInt;   // Off delay time PEC stop signal
      StopFunctionOnDelay : UDInt;   // On delay time stop function
      StopFunctionOffDelay : UDInt;   // Off delay time stop function
      FailSafe { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate output to release
      Slave { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stopper is slave
   END_STRUCT;

END_TYPE

FUNCTION "FC_Fifo" : Void
TITLE = FC_Fifo
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 17
// END_ATTRIBUTES
//Function for controlling FIFO register.
   VAR_INPUT 
      ic_Mode : Char;   // Mode selector: "W" - Write; "R" - Read; "C" - Clear (Reset) "S" - Status
   END_VAR

   VAR_OUTPUT 
      qUDT_Status : "UDT_FifoStatus";   // FIFO status structure
      qx_Error : Bool;   // Collective error output
      qx_Warning : Bool;   // Collective warning output
   END_VAR

   VAR_IN_OUT 
      iqv_Data : Variant;   // Data
      iqUDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqv_DataBuffer : Variant;   // FIFO data buffer
   END_VAR

   VAR_TEMP 
      tUDT_Status : "UDT_FifoStatus";   // Status structure
      ti_MoveBLKErrorCode : Int;   // Move_BLK_Variant function return
      tx_HeaderValid : Bool;   // Header valid
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	14/06/2019  | 0.2       | A.Nowak       | Replacement of instruction if for direct write into variable - Region 3 , 4.1 , 4.2 , 4.3 , 4.4 , 8.1  , 8.2 
	17/07/2019  | 0.3       | L.Klar        | Status handling changed
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	23/08/2019  | 2.1       | K.Pokorski    | Comments corrected
	27/08/2019  | 2.2       | M.Kurpiers    | Comments adjusted
	27/09/2019  | 2.3       | K.Pokorski    | Variant input included
	01/10/2019  | 2.4       | A.Nowak       | Correct comments and rename regions
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – Diagnostic bits initialization
	    
	    // Clear FIFO statuses
	    #tUDT_Status.FifoFull := FALSE;
	    #tUDT_Status.FifoPreFull := FALSE;
	    
	END_REGION
	
	REGION 2 – Array's information
	    
	    // If buffer elements type is invalid, set the error 
	    #tUDT_Status.InvalidDataType := NOT (TypeOf(#iqv_Data) = TypeOfElements(#iqv_DataBuffer));
	    
	END_REGION
	
	REGION 3 – Mode validation
	    
	    // Set the mode invalid if selected mode isn't one of the following: W- Write, R - Read, C - Clear, S - Status
	    #tUDT_Status.InvalidMode := #ic_Mode <> 'W'
	    AND #ic_Mode <> 'R'
	    AND #ic_Mode <> 'C'
	    AND #ic_Mode <> 'S';
	    
	END_REGION
	
	REGION 4 – The header settings checking
	    
	    // The correct mode has been selected and data type is valid
	    IF (NOT #tUDT_Status.InvalidMode
	        AND NOT #tUDT_Status.InvalidDataType)
	    THEN
	        
	        REGION 4.1 – The number of maximum FIFO entries validation 
	            
	            // Write the number of array's elements to FIFO header
	            #iqUDT_FifoHeader.MaxNrOfEntries := "FC_GetNrOfArrayEl"(#iqv_DataBuffer);
	            
	            // Set the invalid maximum number of entries error 
	            #tUDT_Status.InvalidMaxNrOfEntries := #iqUDT_FifoHeader.MaxNrOfEntries <= 0;
	            
	        END_REGION
	        
	        REGION 4.2 – The number of total FIFO entries validation
	            
	            // Set the invalid total number of entries error 
	            #tUDT_Status.InvalidTotalEntriesStored := #iqUDT_FifoHeader.TotalEntriesStored < 0        // The total number of entries is lower than 0
	            OR #iqUDT_FifoHeader.TotalEntriesStored > #iqUDT_FifoHeader.MaxNrOfEntries;               // The total number of entries is greater than the maximum number of entries
	            
	        END_REGION
	        
	        REGION 4.3 – The number of the next entry to write 
	            
	            // Set the invalid next entry to write
	            #tUDT_Status.InvalidNextEntryToWrite := #iqUDT_FifoHeader.NextEntryToWrite < 0            // The number of next entry to write is lower than 0  
	            OR #iqUDT_FifoHeader.NextEntryToWrite >= #iqUDT_FifoHeader.MaxNrOfEntries;                // The number of next entry to write is greater or equal to the maximum number of entries 
	            
	        END_REGION
	        
	        REGION 4.4 – The number of the next entry to read 
	            
	            // Set the invalid next entry to read
	            #tUDT_Status.InvalidNextEntryToRead := #iqUDT_FifoHeader.NextEntryToRead < 0              // The number of next entry to read is lower than 0 
	            OR #iqUDT_FifoHeader.NextEntryToRead >= #iqUDT_FifoHeader.MaxNrOfEntries;                 // The number of next entry to read is greater or equal to the maximum nr of entries 
	            
	        END_REGION
	        
	        REGION 4.5 – FIFO header validation summary
	            
	            // Create collective header error
	            #tx_HeaderValid := NOT #tUDT_Status.InvalidMaxNrOfEntries
	            AND NOT #tUDT_Status.InvalidTotalEntriesStored
	            AND NOT #tUDT_Status.InvalidNextEntryToWrite
	            AND NOT #tUDT_Status.InvalidNextEntryToRead;
	            
	        END_REGION
	        
	    END_IF;
	    
	END_REGION
	
	REGION 5 – Writing the data into the FIFO buffer
	    
	    IF (#ic_Mode = 'W'                                                                          // Write mode selected                                                               
	        AND #tx_HeaderValid                                                                     // FIFO header valid 
	        AND NOT #tUDT_Status.InvalidDataType)                                                  // Buffer data type valid
	    THEN
	        
	        
	        IF (#iqUDT_FifoHeader.TotalEntriesStored < #iqUDT_FifoHeader.MaxNrOfEntries)          // Checking total number of stored entries                
	        THEN
	            
	            // Move input data to FIFO data buffer  
	            #ti_MoveBLKErrorCode := MOVE_BLK_VARIANT(SRC := #iqv_Data,
	                                                     COUNT := 1,
	                                                     SRC_INDEX := 0,
	                                                     DEST_INDEX := #iqUDT_FifoHeader.NextEntryToWrite,
	                                                     DEST => #iqv_DataBuffer);
	            
	            // Increment the number of the next entry to write 
	            #iqUDT_FifoHeader.NextEntryToWrite += 1;
	            
	            // Increment the total number of stored entries 
	            #iqUDT_FifoHeader.TotalEntriesStored += 1;
	            
	            
	            IF (#iqUDT_FifoHeader.NextEntryToWrite >= #iqUDT_FifoHeader.MaxNrOfEntries)       // Check the number of the next entry to write                             
	            THEN
	                
	                #iqUDT_FifoHeader.NextEntryToWrite := 0;
	                
	            END_IF;
	            
	        ELSE
	            
	            #tUDT_Status.FifoFull := TRUE;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 6 – Reading the data from the FIFO data buffer
	    
	    IF (#ic_Mode = 'R'                                                                  // Read mode selected    
	        AND #tx_HeaderValid                                                             // FIFO header valid 
	        AND NOT #tUDT_Status.InvalidDataType)                                           // Buffer data type valid                                                
	    THEN
	        
	        IF (#iqUDT_FifoHeader.TotalEntriesStored > 0)                                   // Checking total number of stored entries                                                     
	        THEN
	            
	            // Move the FIFO data to the data output
	            #ti_MoveBLKErrorCode := MOVE_BLK_VARIANT(SRC := #iqv_DataBuffer,
	                                                     COUNT := 1,
	                                                     SRC_INDEX := #iqUDT_FifoHeader.NextEntryToRead,
	                                                     DEST_INDEX := 0,
	                                                     DEST => #iqv_Data);
	            
	            // Increment the number of the next entry to read
	            #iqUDT_FifoHeader.NextEntryToRead += 1;
	            
	            // Decrement the total number of stored entries
	            #iqUDT_FifoHeader.TotalEntriesStored -= 1;
	            
	            IF (#iqUDT_FifoHeader.NextEntryToRead >= #iqUDT_FifoHeader.MaxNrOfEntries)  // Check the number of the next entry to read                 
	            THEN
	                
	                #iqUDT_FifoHeader.NextEntryToRead := 0;
	                
	            END_IF;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 7 – Clearing the FIFO header
	    
	    IF (#ic_Mode = 'C'                      // Clear mode selected  
	        AND #tx_HeaderValid)                // FIFO header valid                         
	    THEN
	        
	        #iqUDT_FifoHeader.TotalEntriesStored := 0;
	        #iqUDT_FifoHeader.NextEntryToWrite := 0;
	        #iqUDT_FifoHeader.NextEntryToRead := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 8 – FIFO management status update
	    
	    IF (#tx_HeaderValid)                   // The header is valid                                     
	    THEN
	        
	        REGION 8.1 – FIFO Empty
	            
	            // Set the FIFO empty status bit
	            #iqUDT_FifoHeader.Status.Empty := #iqUDT_FifoHeader.TotalEntriesStored = 0;
	            
	        END_REGION
	        
	        REGION 8.2 – FIFO Full
	            
	            // Set the FIFO full status bit 
	            #iqUDT_FifoHeader.Status.Full := #iqUDT_FifoHeader.TotalEntriesStored = #iqUDT_FifoHeader.MaxNrOfEntries;
	            
	        END_REGION
	        
	        REGION 8.3 – FIFO Pre-full
	            
	            IF (#iqUDT_FifoHeader.TotalEntriesStored >= 0.9 * #iqUDT_FifoHeader.MaxNrOfEntries)       // Checking if the number of total stored entries is greater or equal to 90% of the max number of entries     
	            THEN
	                
	                // Set the FIFO pre-full status 
	                #iqUDT_FifoHeader.Status.Prefull := TRUE;
	                #tUDT_Status.FifoPreFull := TRUE;
	                
	            ELSE
	                
	                #iqUDT_FifoHeader.Status.Prefull := FALSE;
	                
	            END_IF;
	            
	        END_REGION
	        
	    END_IF;
	    
	END_REGION
	
	REGION 9 – Status
	    
	    REGION 9.1 – Common status update
	        
	        // Collective error output
	        #qx_Error := NOT #tx_HeaderValid
	        OR #tUDT_Status.InvalidMode
	        OR #tUDT_Status.FifoFull
	        OR #tUDT_Status.InvalidDataType;
	        
	        // Collective warning output              
	        #qx_Warning := #tUDT_Status.FifoPreFull;
	        
	    END_REGION
	    
	    REGION 9.2 – Status update
	        
	        // Update the outer status structure with internal status structure
	        #qUDT_Status := #tUDT_Status;
	        
	    END_REGION
	    
	END_REGION
END_FUNCTION

DATA_BLOCK "DB_GIN"
TITLE = DB_GIN
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
NON_RETAIN
//Data block to store parcels informations.
   VAR 
      GIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Array[1..1] of "UDT_GIN";   // GIN informations - for project remove unneeded customers and extend array bound range to 9999
   END_VAR


BEGIN

END_DATA_BLOCK

TYPE "UDT_Message"
TITLE = UDT_Message
VERSION : 0.1
//User-defined structure of the message characters array.
   STRUCT
      Character : Array[0..499] of Char;   // Message character
   END_STRUCT;

END_TYPE

TYPE "UDT_FedExMessageHeader"
VERSION : 0.1
   STRUCT
      STX : Char;
      MessageLength : String[4];
      MessageType : String[2];
   END_STRUCT;

END_TYPE

TYPE "UDT_FedExCustomerID"
VERSION : 0.1
   STRUCT
      CustomerIDMemory { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Customer ID memory
      CustomerIDReference { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..999999] of Int;   // Customer ID reference array
   END_STRUCT;

END_TYPE

TYPE "UDT_Chute3BrakeStatus"
VERSION : 0.1
   STRUCT
      Status { S7_SetPoint := 'True'} : Int;   // Status number
      Specific : Struct   // Chute specific status structure
         ChuteJam : Bool;   // Jam on chute
         ChuteFull : Bool;   // Chute is full
         ChuteHalfFull : Bool;   // Chute is half full
         DisableFromHMI : Bool;   // Disabled from HMI
         DisableFromHLC : Bool;   // Disabled from HLC
         BrakeFaultTop : Bool;   // Top brake bar  is faulty
         BrakeFaultMiddle : Bool;   // Middle brake bar is faulty
         BrakeFaultBottom : Bool;   // Bottom brake bar is faulty
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_FedExMessagePS"
VERSION : 0.1
   STRUCT
      SystemID : String[15];   // Identifier of the system.
      ParameterID : String[4];   // Parameter code to identify which parameter value is being set
      ParameterValue : String[82];   // New value for the specified parameter
      Timestamp : String[17];   // Local Time Timestamp
      TimeZoneDesignator : String[5];   // Time Zone Designator
   END_STRUCT;

END_TYPE

TYPE "UDT_FedExMessageCD"
VERSION : 0.1
   STRUCT
      CommandCode : String[3];   // Generated during configuration.It is a fixed value for all systems
      CommandValue : String[82];   // System ID of the system making the request.
      Timestamp : String[17];   // Local time timestamp
      TimeZoneDesignator : String[5];   // Time zone designator
   END_STRUCT;

END_TYPE

TYPE "UDT_FedExMessageDaRa"
VERSION : 0.1
   STRUCT
      LLCSystemID : String[15];   // Identifier of Low-Level controls
      PackageID : String[15];   // Number assigned by the LLC system
      HLCPackageID : String[10];   // Unique number for the specific package during it stays in HLC system.
      CellNumber : String[4];   // Tray/Cell number (for loop sorters) or generated by LLC (on line sorters).
      Destination1 : String[6];   // Location code value that describes where the package should go (Diverter Number).
      CutOffTimeDestination1 : String[5];   // Cut Off Time in Local Time.
      Destination2 : String[6];   // Location code value that describes where the package should go (Diverter Number).
      CutOffTimeDestination2 : String[5];   // Cut Off Time in Local Time.
      Destination3 : String[6];   // Location code value that describes where the package should go (Diverter Number).
      CutOffTimeDestination3 : String[5];   // Cut Off Time in Local Time.
      Destination4 : String[6];   // Location code value that describes where the package should go (Diverter Number).
      CutOffTimeDestination4 : String[5];   // Cut Off Time in Local Time.
      Destination5 : String[6];   // Location code value that describes where the package should go (Diverter Number).
      CutOffTimeDestination5 : String[5];   // Cut Off Time in Local Time.
      HLCDataText : String[20];   // Free text for future use.
      Barcodedata : String[50];   // Sortation barcode
      HLCResultCode : String[16];   // Result code based on processing of the scan event messages.
      Timestamp : String[17];   // Local time timestamp
      TimeZoneDesignator : String[5];   // Time zone designator
   END_STRUCT;

END_TYPE

TYPE "UDT_Chute3BrakesConfiguration"
VERSION : 0.1
   STRUCT
      BrakeConfiguration1 { S7_SetPoint := 'False'} : "UDT_PneumaticBrakeConfiguration";   // First brake configuration
      BrakeConfiguration2 { S7_SetPoint := 'False'} : "UDT_PneumaticBrakeConfiguration";   // Secound brake configuration
      StopperConfiguration { S7_SetPoint := 'False'} : "UDT_StopRollerConfiguration";   // Stopper configuration
      PECFullOnDelay : UDInt;   // On delay time PEC full signal
      PECFullOffDelay : UDInt;   // Off delay time PEC full signal
      PECHalfFullOnDelay : UDInt;   // On delay time PEC half full signal
      PECHalfFullOffDelay : UDInt;   // Off delay time PEC half full signal
      PECMiddleOnDelay : UDInt;   // On delay time PEC middle signal
      PECMiddleOffDelay : UDInt;   // Off delay time PEC middle signal
      LongBrakePauseOnDelay : UDInt;   // On delay time from common stop PEC signals
      NumberOfTheEquipment : String[3];   // Number of the equipment 001-999
      "Device ID" : String[6];   // ID of the Device Type
      DEPCOD : String[6];   // Depot Code
      LOConEquipment : String[6];   // Location of the equipment
   END_STRUCT;

END_TYPE

FUNCTION "FC_GetDevicePN" : Void
TITLE = FC_GetDevicePN
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 18
// END_ATTRIBUTES
   VAR_INPUT 
      is_PNDeviceName : String;   // Name of the device
      ix_SimulationModeActive : Bool;   // True = Simulation mode active
   END_VAR

   VAR_IN_OUT 
      iqUDT_PND : "UDT_PNDevice";   // Device found in Profinet structure
   END_VAR

   VAR_TEMP 
      ti_NrOfConfiguredPNNetworks : Int;   // Number of networks configured in project
      ti_NrOfDevices : Int;   // Nr of devices is networks
      ti_LcPNNetworkNumber : Int;   // Loop counter to find PN network number
      ti_LcPNDeviceNumber : Int;   // Loop counter to find PN device number
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	16/09/2019  | 2.3       | F.Baten       | Cut out of 'FB_RIO'
	29/09/2019  | 2.4       | K.Pokorski    | Network seach started from 1 instead 0
	30/09/2019  | 2.5       | K.Pokorski    | Chagne prefixes of temporary varaibles from 'si' to 'ti'
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Get Device Profinet number
	    // if simulation is disabled 
	    IF NOT #ix_SimulationModeActive
	    THEN
	        // And the profinet device is not found yet
	        IF (#is_PNDeviceName <> "DB_ProfinetDiagnostic".ProfinetNetworks[#iqUDT_PND.PNNetworknumber].DeviceStatus[#iqUDT_PND.PNDeviceNumber].DeviceState.PNDeviceName)
	            OR #iqUDT_PND.PNDeviceFound = FALSE
	        THEN
	            #iqUDT_PND.PNDeviceFound := FALSE;
	            
	            // check how many profinet networks are configured
	            #ti_NrOfConfiguredPNNetworks := "FC_GetNrOfArrayEl"("DB_ProfinetDiagnostic".ProfinetNetworks);
	            
	            FOR #ti_LcPNNetworkNumber := 1 TO (#ti_NrOfConfiguredPNNetworks) DO
	                
	                #iqUDT_PND.PNNetworknumber := #ti_LcPNNetworkNumber;
	                
	                // and check how many devices are configured per network
	                #ti_NrOfDevices := "FC_GetNrOfArrayEl"("DB_ProfinetDiagnostic".ProfinetNetworks[#iqUDT_PND.PNNetworknumber].DeviceStatus);
	                
	                // check for each of the devices in the networks if the PN device name is similair to the configured device name
	                FOR #ti_LcPNDeviceNumber := 0 TO (#ti_NrOfDevices - 1) DO
	                    
	                    #iqUDT_PND.PNDeviceNumber := #ti_LcPNDeviceNumber;
	                    
	                    // set device found when a match is found for the device name in the PN network
	                    IF (#is_PNDeviceName = "DB_ProfinetDiagnostic".ProfinetNetworks[#iqUDT_PND.PNNetworknumber].DeviceStatus[#iqUDT_PND.PNDeviceNumber].DeviceState.PNDeviceName
	                        AND #is_PNDeviceName <> '')
	                    THEN
	                        
	                        #iqUDT_PND.PNDeviceFound := TRUE;
	                        EXIT;
	                        
	                    END_IF;
	                END_FOR;
	                
	                // exit loop when device name is matching
	                IF #iqUDT_PND.PNDeviceFound
	                THEN
	                    
	                    EXIT;
	                    
	                END_IF;
	            END_FOR;
	        END_IF;
	    END_IF;
	    
	END_REGION
END_FUNCTION

FUNCTION "FC_GetPNPortStatus" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 20
// END_ATTRIBUTES
   VAR_INPUT 
      ii_NumberOfPorts : Int;   //  Number of ports in device
      iUDT_DevicePNInfo : "UDT_PNDevice";   //  PN device info structure
   END_VAR

   VAR_OUTPUT 
      qa_PortFault : Array[1..8] of Bool;   //  When TRUE then specific port has a fault
   END_VAR

   VAR_TEMP 
      tp_GetDiagInfo {InstructionName := 'DIS'; LibVersion := '1.0'} : DIS;   //  Diagnostic structure
      tp_DeviceGeoAddr {InstructionName := 'GEOADDR'; LibVersion := '1.0'} : GEOADDR;   //  Device pointer structre
      ta_PortFault : Array[1..8] of Bool;   //  When TRUE then port has a fault
      ti_Geo2LogStatus : Int;   //  GEO2LOG status code
      ti_GetDiagStatus : Int;   //  Get_Diag status code
      ti_Log2GeoStatus : Int;   //  LOG2GEO status code
      ti_Loopcounter : Int;   //  Loop counter
      tui_cnt : UInt;   //  Not used
      tdi_PortLaddr : HW_ANY;   //  HW identifier
      ti_PortFault : Bool;   //  At least one port is faulty
      tx_ConfigurationError : Bool;   //  Configuration error occurred
   END_VAR

   VAR CONSTANT 
      ci_Area : UInt := 1;   //     Area ID of IO Profinet devices
      ci_HWTYPE : UInt := 5;
      ci_PortSlot : UInt := 0;
      ci_PortSubslot : Word := 16#8000;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	03/11/2020  | 3.0       | K.Pokorski    | first release MHS TIA 15.1
	17/12/2020  | 3.1       | K.Pokorski    | Run operation only during error
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Check configuration
	    
	    #tx_ConfigurationError := #ii_NumberOfPorts < 1
	    OR #ii_NumberOfPorts > 8
	    OR NOT #iUDT_DevicePNInfo.PNDeviceFound;
	    
	END_REGION
	
	REGION 2 - Read profinet network number
	    
	    // Using LOG2GEO profinet network address is read
	    #ti_Log2GeoStatus := LOG2GEO(LADDR := "DB_ProfinetDiagnostic".ProfinetNetworks[#iUDT_DevicePNInfo.PNNetworknumber].DeviceStatus[#iUDT_DevicePNInfo.PNDeviceNumber].DeviceState.HW_ID,
	                                 GEOADDR := #tp_DeviceGeoAddr);
	    
	END_REGION
	
	REGION 3 - Preparation the device pointer
	    
	    // HWTYPE = 5 - Submodule
	    #tp_DeviceGeoAddr.HWTYPE := #ci_HWTYPE;
	    // AREA = 1 - PROFINET IO
	    #tp_DeviceGeoAddr.AREA := #ci_Area;
	    // SLOT = 0 - Ports are on slot 0 
	    #tp_DeviceGeoAddr.SLOT := #ci_PortSlot;
	    // STATION - Profinet number
	    #tp_DeviceGeoAddr.STATION := "DB_ProfinetDiagnostic".ProfinetNetworks[#iUDT_DevicePNInfo.PNNetworknumber].DeviceStatus[#iUDT_DevicePNInfo.PNDeviceNumber].DeviceState.ProfinetNumber;
	    
	END_REGION
	
	REGION 4 - Checking the port status
	    // If device report error and is available on the PN network
	    IF "DB_ProfinetDiagnostic".ProfinetNetworks[#iUDT_DevicePNInfo.PNNetworknumber].DeviceStatus[#iUDT_DevicePNInfo.PNDeviceNumber].DeviceState.Error
	        AND "DB_ProfinetDiagnostic".ProfinetNetworks[#iUDT_DevicePNInfo.PNNetworknumber].DeviceStatus[#iUDT_DevicePNInfo.PNDeviceNumber].DeviceState.Exist
	        AND NOT #tx_ConfigurationError
	    THEN
	        
	        // Loop through all profinet ports
	        FOR #ti_Loopcounter := 1 TO #ii_NumberOfPorts DO
	            // Reset auxiliary port fault bit 
	            #ta_PortFault[#ti_Loopcounter] := FALSE;
	            // SUBSLOT = 16#8000 plus port number (TIA structure to refer to port)
	            #tp_DeviceGeoAddr.SUBSLOT := INT_TO_UINT(WORD_TO_INT(#ci_PortSubslot) + (#ti_Loopcounter));
	            // Using GEO2LOG port address is read
	            #ti_Geo2LogStatus := GEO2LOG(GEOADDR := #tp_DeviceGeoAddr, LADDR => #tdi_PortLaddr);
	            // Using GET_DIAG port status is read
	            #ti_GetDiagStatus := GET_DIAG(MODE := 1, LADDR := #tdi_PortLaddr, CNT_DIAG => #tui_cnt, DIAG := #tp_GetDiagInfo);
	            
	            // Set port fault if all operations do not report any error and port is faulty
	            IF #ti_GetDiagStatus = 0
	                AND #ti_Geo2LogStatus = 0
	                AND #ti_Log2GeoStatus = 0
	                AND #tp_GetDiagInfo.OwnState = 4
	            THEN
	                #ta_PortFault[#ti_Loopcounter] := TRUE;
	            END_IF;
	        END_FOR;
	        // Reset module status if error occurred
	    ELSIF #tx_ConfigurationError
	    THEN
	        FOR #ti_Loopcounter := 1 TO 8 DO
	            #ta_PortFault[#ti_Loopcounter] := FALSE;
	        END_FOR;
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Write output
	    
	    #qa_PortFault := #ta_PortFault;
	    
	END_REGION
	
	
END_FUNCTION

TYPE "UDT_Connection"
TITLE = UDT_Connection
VERSION : 0.1
//User-defined structure of connection parameters.
   STRUCT
      ActiveEstablished : Bool := FALSE;   // 0 – Passive connection establishment; 1 – Active connection establishment
      Interface_ID : HW_ANY := 64;   // Interface ID of CPU Ethernet interface
      ID : CONN_OUC;   // Unique ID as system reference for the connection
      IP : Array[1..4] of Int;   // IP address
      Port : UInt;   // Port number of the communication partner
      ConTimeout : DInt;   // Maximum waiting time for response from the communication partner [ms]
   END_STRUCT;

END_TYPE

TYPE "UDT_FedExDestinations"
VERSION : 0.1
   STRUCT
      PhysicalDestination : DInt;
      Destination : Array[0..5] of DInt;   // Destination code to compare to to go to position
   END_STRUCT;

END_TYPE

TYPE "UDT_FedExHeartbeatStatistics"
TITLE = UDT_HeartbeatStatistics
VERSION : 0.1
//User-defined structure of FB_Heartbeat function block statistics.
   STRUCT
      ConLost : UDInt;   // Statistics of connection lost
      MsgNotSent : UDInt;   // Statistics of not send messages when it was requested
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_FedExCustomerID"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 64
// END_ATTRIBUTES
   VAR_INPUT 
      ii_Gin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Gin number
   END_VAR

   VAR_IN_OUT 
      iqUDT_CustomerID : "UDT_FedExCustomerID";   // Customer ID structure
   END_VAR

   VAR 
      si_OldGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Old GIN number
   END_VAR

   VAR_TEMP 
      tx_InvalidGIN : Bool;   // Invalid GIN number
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	30/06/2022  | 0.1       | K.Pokorski    | first release MHS TIA 16
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - GIN validation
	    
	    // GIN validation
	    #tx_InvalidGIN :=
	    #ii_Gin < 1
	    OR #ii_Gin > 9999;
	    
	END_REGION
	
	REGION 2 - Save Customer ID and GIN number
	    
	    IF NOT #tx_InvalidGIN
	    THEN
	        
	        IF #ii_Gin <> #si_OldGIN
	            AND "DB_GIN".GIN[#ii_Gin].FedEx.CustomerID = 0
	        THEN
	            
	            #iqUDT_CustomerID.CustomerIDMemory += 1;
	            IF #iqUDT_CustomerID.CustomerIDMemory > 999999 THEN
	                
	                #iqUDT_CustomerID.CustomerIDMemory := 1;
	                
	            END_IF;
	            
	            
	            #iqUDT_CustomerID.CustomerIDReference[#iqUDT_CustomerID.CustomerIDMemory] := #ii_Gin;
	            "DB_GIN".GIN[#ii_Gin].FedEx.CustomerID := #iqUDT_CustomerID.CustomerIDMemory;
	            
	            
	            #si_OldGIN := #ii_Gin;
	            
	        END_IF;
	    END_IF;
	END_REGION
	
	
END_FUNCTION_BLOCK

TYPE "UDT_FedexLoginStatus"
VERSION : 0.1
   STRUCT
      Accepted : Bool;
      Rejected : Bool;
   END_STRUCT;

END_TYPE

TYPE "UDT_ConveyorCommonConfiguration"
VERSION : 0.1
   STRUCT
      Length : DInt;   // Conveyor length [mm]
      LengthCorrection : DInt;   // Length correction [mm]
   END_STRUCT;

END_TYPE

DATA_BLOCK "DB_ExternalGIN"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
   VAR 
      UnexpectedSI { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_GIN";
   END_VAR


BEGIN

END_DATA_BLOCK

TYPE "UDT_FedExMessageSI"
VERSION : 0.1
   STRUCT
      Header { S7_SetPoint := 'False'} : "UDT_FedExMessageHeader";
      ADCSystemID : String[15];   // Identifier of Automated Data Capture system.
      ScanUnitType : String[1];   // Scan Unit Type
      ImageID : String[6];   // Image ID number (000001 to 999999), token for the parcel created by the ADCsystem.
      PackageID : String[15];   // Number assigned by the LLC system or ADC system
      HLCPackageID : String[10];   // Unique number for the specific package during it stays in HLC system.
      DIMSystemID : String[15];   // Identifier of dimensioning system
      DimStatus : String[5];
      PackageDimLength : String[6];   // Length dimension of package in resolution of dim system.
      PackageDimWidth : String[6];   // Width dimension of package in resolution of dim system.
      PackageDimHeight : String[6];   // Height dimension of package in resolution of dim system.
      DIMUOM : String[2];   // Unit of measure of the package dimensions.
      DimLFTstatusCode : String[8];   // Dimension LFT status code.
      AlibiDims : String[25];   // Alibi for Dimensions
      SCLSystemID : String[15];   // Identifier of weight scale.
      SCLStatus : String[5];   // Basic diagnostic information from the weight scale system.
      SCLWT : String[6];   // Scale weight of package in resolution of scale system.
      SCLWTUOM : String[2];   // Unit of measurement for Weight
      SCLLFTStatusCode : String[2];   // Scale LFT status code.
      AlibiWeight : String[25];   // Alibi for Weight
      Stackable : String[1];   // If stackable recognition is enabled, Y or N
      Timestamp : String[17];   // Local time timestamp
      TimeZoneDesignator : String[5];   // Time zone designator
      Barcode1Identification : String[3];   // Barcode identifier code.
      Barcode1status : String[2];   // Barcode confidence factor
      Barcode1datalength : String[4];   // String length of barcode data in bytes; inclusive of this field. Use 0054 as a fixed value
      Barcode1data : String[50];   // Highest priority barcode
      Barcode2Identification : String[3];   // Barcode identifier code.
      Barcode2status : String[2];   // Barcode confidence factor
      Barcode2datalength : String[4];   // String length of barcode data in bytes; inclusive of this field. Use 0054 as a fixed value
      Barcode2data : String[50];   // Highest priority barcode
      Barcode3Identification : String[3];   // Barcode identifier code.
      Barcode3status : String[2];   // Barcode confidence factor
      Barcode3datalength : String[4];   // String length of barcode data in bytes; inclusive of this field. Use 0054 as a fixed value
      Barcode3data : String[50];   // Highest priority barcode
      TotalBarcodeDataLength : String[4];   // Length of all barcode data that was sent in bytes;
      PackageDataTruncated : String[1];   // Y = Full length of barcode data exceeds 9999 bytes, data truncated
      CameraHeadstatus : String[2];   // Diagnostic information on camera/laser heads performing barcode reads.
   END_STRUCT;

END_TYPE

TYPE "UDT_FedExMessageLoginResponse"
VERSION : 0.1
   STRUCT
      Header { S7_SetPoint := 'False'} : "UDT_FedExMessageHeader";
      FacilityID : String[8];   // Generated during configuration.It is a fixed value for all systems
      SystemID : String[15];   // System ID of the system making the request.
      VersionID : String[6];   // Interface document version.
      ConnectionStatus : String[1];   // Y=Succes, N=Failure
      LocalHost : String[32];   // IP Address of the existing connection. If this is the first connection, IP Address or Hostname of the connecting host.
   END_STRUCT;

END_TYPE

TYPE "UDT_FedExMessageWS"
VERSION : 0.1
   STRUCT
      Header { S7_SetPoint := 'False'} : "UDT_FedExMessageHeader";
      SCLSystemID : String[15];   // Identifier of weight scale.
      PackageID : String[15];   // Number assigned by the LLC system
      SCLWT : String[6];   // Scale weight of package in resolution of scale system.
      SCLWTUOM : String[2];   // Unit of measurement for Weight
      SCLLFTStatusCode : String[2];   // Scale LFT status code.
      AlibiWeight : String[25];   // Alibi for Weight
      Timestamp : String[17];   // Local time timestamp
      TimeZoneDesignator : String[5];   // Time zone designator
   END_STRUCT;

END_TYPE

TYPE "UDT_TCPIPReceiveStatistics"
TITLE = UDT_TCPIPReceiveStatistics
VERSION : 0.1
//User-defined structure of FB_TCPIPReceive function block statistics.
   STRUCT
      InvalidMsg : UInt;   // Invalid message received
   END_STRUCT;

END_TYPE

TYPE "UDT_VfdKebaSystemStatistics"
VERSION : 0.1
   STRUCT
      PNSlaveNotOnline : "UDT_EventStatistic";   // Statistics of Profinet slave not online
      PNSlaveError : "UDT_EventStatistic";   // Statistics of a Profinet slave error
      Ax1InternalError : "UDT_EventStatistic";   // Statistics of an axis 1 internal error
      Ax2InternalError : "UDT_EventStatistic";   // Statistics of an axis 2 internal error
      CommunicationError : "UDT_EventStatistic";   // Statistics of a communication error
      Ax1Running : "UDT_EventStatistic";   // Statistics for axis 1 running time
      Ax2Running : "UDT_EventStatistic";   // Statistics for axis 2 running time
   END_STRUCT;

END_TYPE

TYPE "UDT_FedExCommands"
VERSION : 0.1
   STRUCT
      StartSort : Struct   // Sent to LLC to designate the Sort has started. – Functionality to include reset of LLC Application buffers from previous sort
         NewMessage : Bool;   // New message received from UDS
         StartSort : Bool;   // Sent to LLC to designate the Sort has started. – Functionality to include reset of LLC Application buffers from previous sort
      END_STRUCT;
      EndSort : Struct   // Sent to LLC to designate the Sort has stopped. This message should not clear LLC counters. To be used in future cases.
         NewMessage : Bool;   // New message received from UDS
         EndSort : Bool;   // Sent to LLC to designate the Sort has stopped. This message should not clear LLC counters. To be used in future cases.
      END_STRUCT;
      UploadChuteStatus : Struct   // Sent to LLC so HLC can receive an update of all the current chute status. This information is required to work in optimal conditions when chute grouping has been enabled.
         NewMessage : Bool;   // New message received from UDS
      END_STRUCT;
      UploadAllStatus : Struct   // Sent to LLC so HLC can receive an update of the current equipment status.
         NewMessage : Bool;   // New message received from UDS
      END_STRUCT;
      BlockDivertSmalls : Struct   // Divert Block sent to the LLC when a bag is determined Full by the HLC, when a bag must be closed at the beginning of a sort, and to prevent miss-sorts during assignment changes. (Automated Smalls Only)
         NewMessage : Bool;   // New message received from UDS
         SorterNumber : String[5];   // Sorter number
         DivertNumber : String[6];   // Diverter number
      END_STRUCT;
      UnblockDivertSmalls : Struct   // Divert Unblock sent to the LLC when a bag is determined Full by the HLC, when a bag must be closed at the beginning of a sort, and to prevent miss-sorts during assignment changes. (Automated Smalls Only)
         NewMessage : Bool;   // New message received from UDS
         SorterNumber : String[5];   // Sorter number
         DivertNumber : String[6];   // Diverter number
      END_STRUCT;
      EnablePurge : Struct   // Purge Enable command including up to five chutes sent to the LLC when an Operator enables Purge on the HLC.
         NewMessage : Bool;   // New message received from UDS
         PLC : String[6];   // PLC Number
         Chute : Array[1..5] of String;   // Chute number
      END_STRUCT;
      DisablePurge : Struct   // Purge disable command including up to five chutes sent to the LLC when an Operator enables Purge on the HLC.
         NewMessage : Bool;   // New message received from UDS
         PLC : String[6];   // PLC Number
         Chute : Array[1..5] of String[6];   // Chute number
      END_STRUCT;
      ChuteLamp : Struct   // Lamp on the chutes control from HLC
         NewMessage : Bool;   // New message received from UDS
         ChuteNumber : String[6];   // Chute number to control lamp.
         Mode : String[1];   // 0=Off, 1=On, 2=Slow blink, 3=Blink, 4=Fast blink
         Color : String[9];   // 1= Red, 2=Green, 3=Orange
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_PolisorterInterface"
TITLE = UDT_VSUInterface
VERSION : 0.1
//User-defined structure of VSU interface parameters.
   STRUCT
      Decisionpoint : Int;   // Point in tracking where the destination is found on the Polisorter conveyor [cm]
      RequestedPosition : Int;   // Position requested by destination block
      PositionSetpoint : Int;   // Position number (as configured) to go to by positioning device
      PositionActual : Int;   // Position number the positioning device is actually on
      SwitchingTime : UInt;   // Time it takes to go from one position to the next [ms]
      PNDeviceOk : Bool;   // Device ok
      Automatic : Bool;   // Automatic mode request
      RunEnabled : Bool;   // Running of the positioning device is enabled
      GoReference : Bool;   // Activate reference run
      Referenced : Bool;   // Positioning device is referenced
      Manual : Bool;   // Manual mode request
      Reference_command : Bool;   // Refference command
      JogLeft : Bool;   // Jog request to move equipment left
      JogRight : Bool;   // Jog request to move equipment right
      Ready : Bool;   // Positioning block is running and error free
      MotorRunning : Bool;   // Motor is running
      Positioning : Bool;   // Positioning device is moving to its position
      ResetStatistics : Bool;   // Reset statistics
      InternalErrorVFD : Bool;   // Positioning device internal error
      InternalWarningVFD : Bool;   // Positioning device has a warning
      InternalErrorReset : Bool;   // Reset internal faults
      RequestDieBackUpstream : Bool;   // External request die back to the upstream conveyor of the Polisorter
      ExternalHold : Bool;   // External request to stop the conveyor
      MaintenanceMode : Bool;   // Maitenance mode enabled
      BypassMode : Bool;   // Bypass mode enable
   END_STRUCT;

END_TYPE

TYPE "UDT_XBSChuteInterfaceSend"
VERSION : 0.1
   STRUCT
      ReadyToReceive : Bool;   // Chute is ready to receive
      Running : Bool;   // Downstream line is running
      Fault : Bool;   // Fault on the downstream line
      Warning : Bool;   // Warning on the downstream line
      HalfFull : Bool;   // Chute is half full
      Full : Bool;   // Chute is Full
   END_STRUCT;

END_TYPE

TYPE "UDT_Chute3BrakeStatistics"
VERSION : 0.1
   STRUCT
      ChuteFull : "UDT_EventStatistic";   // Chute full statistics
      ChuteJam : "UDT_EventStatistic";   // Chute jam statistics
      ChuteHalfFull : "UDT_EventStatistic";   // Chute half full statistics
      DisableFromHMI : "UDT_EventStatistic";   // Disable from HMI statistics
      DisableFromHLC : "UDT_EventStatistic";   // Disable from HLC statistics
   END_STRUCT;

END_TYPE

TYPE "UDT_ConveyorHandshake"
TITLE = UDT_ConveyorHandshake
VERSION : 0.1
//User-defined structure of conveyor handshake variables.
   STRUCT
      GIN : Int;   // General identification number
      NrOfPosToShift : Int;   // Number of positions to shift
      DownstreamDisplacement : Int;   // Displacement from downstream [cm]
      RTS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor ready to send
      RTR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor ready to receive
      TIP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Transfer in progress
      ResetEnergySave { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset energy save mode
      CascadeStartUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Cascade startup
      ReqStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request stop
   END_STRUCT;

END_TYPE

TYPE "UDT_Chute3BrakeCommand"
VERSION : 0.1
   STRUCT
      DisableFromHMI : Bool;   // Disable from HMI
      DisableFromHLC : Bool;   // Disable from HLC
   END_STRUCT;

END_TYPE

FUNCTION "FC_FedExDecodeHeader" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 36
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_FifoMsg : "UDT_Message";   // Buffer for FIFO's message
   END_VAR

   VAR_OUTPUT 
      qUDT_MSGHeader : "UDT_FedExMessageHeader";   // Messade header structure
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	27/10/2021  | 0.1       | J.Krawczuk    | first release MHS TIA 15.1
	18/11/2021  | 0.2       | M.Piela       | Interface changes
	*)
	
	REGION - 1 Header decode
	    
	    #qUDT_MSGHeader.STX := #iUDT_FifoMsg.Character[0];
	    
	    Chars_TO_Strg(Chars := #iUDT_FifoMsg.Character,
	                  pChars := 1,
	                  Cnt := 0,
	                  Strg => #qUDT_MSGHeader.MessageLength);
	    
	    Chars_TO_Strg(Chars := #iUDT_FifoMsg.Character,
	                  pChars := 5,
	                  Cnt := 0,
	                  Strg => #qUDT_MSGHeader.MessageType);
	    
	END_REGION
	
	
	
END_FUNCTION

TYPE "UDT_ConveyorInterface"
TITLE = UDT_ConveyorInterface
VERSION : 0.1
//User-defined structure of conveyor interface variables.
   STRUCT
      Displacement : Int;   // Displacement per PLC scan [cm] either from position (if available) or speed and time
      SpeedSetpoint : Int;   // Conveyor speed setpoint [mm/s]
      ActualSpeed : Int;   // Conveyors actual speed [mm/s]
      DeltaPosition : Int;   // Read from Conveyor Servo Position [mm] after 1 PLC cycle
      RunFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Run forward request
      RunRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Run reverse request
      InternalErrorEncoder { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Encoder has an error
      InternalErrorVFD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // VFD has an error
      InternalErrorTracking { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Tracking has an error
      InternalErrorPEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PEC has an error
      InternalWarningVFD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // VFD has a warning
      InternalWarningTracking { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Tracking has a warning
      InternalErrorReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset internal errors
      ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Configuration error is active
      VFDRunning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor is running
      VFDatSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor at speed setpoint
      Disconnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // VFD disconnected
      ManualModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Covneyor is in manual mode
      ResetStatistics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset statistics
      HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Hardware for the Equipment is available and healthy
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_StopRoller"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 229
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_StopRollerConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_StopRollerConfiguration";   // Stop roller configuration structure
      ix_Pressure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when pressure buildup starts
      ix_PECBrake { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when the brake photoye is not blocked
      ix_PECStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when the stop photoye is not blocked
      ix_DownstreamStopActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when the downstream stop is active
      ix_SafetyOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when safety is ok
      ix_BrakePauseLong { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when receiving a delayed signal to increase brake pause
   END_VAR

   VAR_OUTPUT 
      qx_Valve { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when valve is activated
      qx_StopActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when stop is activated to upstream
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
   END_VAR

   VAR 
      s_PECBreakTimerOnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Function block to generate on/off signal delay on the brake PEC
      s_PECStopTimerOnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Function block to generate on/off signal delay on the Stop PEC
      s_PECPressureTimerOnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Function block to generate on/off signal delay on the pressure PEC
      s_StopFunctionTimerOnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Function block to generate on/off signal delay on the downstream stop active
      slr_StepTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Step timer
      si_BrakeFunction { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Brake function step
      sx_PECBrakeFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PEC filtered signal
      sx_PECStopFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PEC filtered signal
      sx_PECPressureFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PEC filtered signal
      sx_DownstreamStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Downstream is stopped
      sx_StopFunctionActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stop function is activated
      sx_StopRoller { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Roller is stop
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	23/06/2021  | 0.0       | F. Baten      | first release TIA 15.1
	20/10/2021  | 0.1       | M. Piela      | Activate valve when system is stoped. Stylistic correction
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	 *)
	
	REGION 1 - Timers
	    
	    // Filtering brake photo eye signal
	    #s_PECBreakTimerOnOffDelay(iudi_OnDelayTime := #iUDT_StopRollerConfiguration.PECBrakeOnDelay,
	                               iudi_OffDelayTime := #iUDT_StopRollerConfiguration.PECBrakeOffDelay,
	                               ix_SignalToDelay := #ix_PECBrake,
	                               ix_Enable := TRUE,
	                               qx_DelayedSignal => #sx_PECBrakeFiltered);
	    
	    // Filtering stop photo eye signal
	    #s_PECStopTimerOnOffDelay(iudi_OnDelayTime := #iUDT_StopRollerConfiguration.PECStopOnDelay,
	                              iudi_OffDelayTime := #iUDT_StopRollerConfiguration.PECStopOffDelay,
	                              ix_SignalToDelay := #ix_PECStop,
	                              ix_Enable := TRUE,
	                              qx_DelayedSignal => #sx_PECStopFiltered);
	    
	    // Filtering downstream stop photo eye signal
	    #s_StopFunctionTimerOnOffDelay(iudi_OnDelayTime := #iUDT_StopRollerConfiguration.StopFunctionOnDelay,
	                                   iudi_OffDelayTime := #iUDT_StopRollerConfiguration.StopFunctionOffDelay,
	                                   ix_SignalToDelay := #ix_DownstreamStopActive,
	                                   ix_Enable := TRUE,
	                                   qx_DelayedSignal => #sx_DownstreamStop);
	    // Sequence Timer
	    IF #slr_StepTimer > 0
	    THEN
	        #slr_StepTimer -= "DB_Memory".PrevCycleTime;
	        IF #slr_StepTimer < 0
	        THEN
	            #slr_StepTimer := 0;
	        END_IF;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Stop roller
	    
	    // Stop roller comes up when outfeed is not active and will fill up until last PEC is occupied.
	    // Sequence
	    // UP
	    IF (#si_BrakeFunction = 0) AND (#slr_StepTimer = 0)
	    THEN
	        #sx_StopRoller := True;
	        #slr_StepTimer := #iUDT_StopRollerConfiguration.BrakePuls;
	        #si_BrakeFunction := 1;
	    END_IF;
	    
	    // Down
	    IF (#si_BrakeFunction = 1) AND (#slr_StepTimer = 0) AND #ix_SafetyOk
	        AND ((#ix_DownstreamStopActive AND #sx_PECStopFiltered AND NOT #sx_PECBrakeFiltered)
	        OR (NOT #ix_DownstreamStopActive AND NOT #sx_PECBrakeFiltered))
	        
	    THEN
	        #sx_StopRoller := False;
	        
	        IF #ix_BrakePauseLong
	        THEN
	            #slr_StepTimer := #iUDT_StopRollerConfiguration.BrakePauseLong;
	        ELSE
	            #slr_StepTimer := #iUDT_StopRollerConfiguration.BrakePause;
	        END_IF;
	        
	        #si_BrakeFunction := 0;
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Stop roller valve
	    
	    IF #sx_StopFunctionActive AND #sx_PECStopFiltered
	    THEN
	        #sx_StopFunctionActive := FALSE;
	    END_IF;
	    
	    IF #ix_DownstreamStopActive //#sx_PECBrakeFiltered
	    THEN
	        #sx_StopFunctionActive := TRUE;
	    END_IF;
	    
	    IF #iUDT_StopRollerConfiguration.FailSafe
	    THEN
	        #qx_Valve := NOT (#sx_StopRoller OR NOT #ix_SafetyOk) OR #iqUDT_EquipmentControl.Command.Stop;
	    ELSE
	        #qx_Valve := #sx_StopRoller AND #ix_SafetyOk OR #iqUDT_EquipmentControl.Command.Stop;
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Stop active
	    
	    #qx_StopActive := #sx_StopFunctionActive AND NOT #sx_PECStopFiltered AND NOT #sx_PECBrakeFiltered;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_FedExLoginResponse"
TITLE = FB_IDFWD
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : UPS_SpecificCommunication
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 77
// END_ATTRIBUTES
//Function block to prepare and send the UPS IDFWD message. 
   VAR_INPUT 
      iUDT_Facility { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FedExFacility";   // System configuration
      is_LastHost { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // IP Address of the existing connection. If this isthe first connection, IP Address or Hostname
      ix_ConnectionStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1- Success, 0- Failure
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective error output
   END_VAR

   VAR_IN_OUT 
      iqUDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqa_FifoData : Array[*] of "UDT_Message";   // FIFO data
   END_VAR

   VAR 
      s_R_TRIG_LoginRequest {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // R_TRIG send login responde messge
      s_UDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Message";   // Message character array
      sa_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";   //  FIFO Status structure
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //  FIFO error
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //  FIFO warning
         InvalidSystemIDLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Invalid designated system parameter input
         InvalidFacialityIDLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Invalid GIN
         InvalidMsgArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Invalid message array size
      END_STRUCT;
      ss_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Message character string
      ss_ConnectionStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Connection status. Y- Sucess, N- Failure
      ss_LastHost { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Last host IP adress
      ss_VersionID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Version ID
      sui_MsgArrayElNr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Number of written message characters
      si_MaxMsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum message length
      si_MsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // String character message length
      si_FacialityIDLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Faciality ID length
      si_SystemIDLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // System ID length
      si_VersionIDLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Version ID length
      si_i { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Loop counter
      si_LastHostLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Last host field length
      si_j { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Loop counter
   END_VAR

   VAR CONSTANT 
      cc_NULL : Char := '$00';   // NULL sign
      cc_STX : Char := '$02';   // Message type
      cc_ETX : Char := '$03';   // End of the text
      cs_MessageLength : String := '0066';   // Start of the text
      cs_MessageType : String := 'LR';   // Legth of the message
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	30/06/2021  | 1.0       | J.Krawczuk    | first release MHS TIA 16.0
	16/11/2021  | 1.2       | M.Piela       | Updating regions numbering and interface changes
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #sa_Status.FIFOStatus,
	              qx_Error => #sa_Status.FIFOError,
	              qx_Warning => #sa_Status.FIFOWarning,
	              iqv_Data := #s_UDT_MessageArray,
	              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	              iqv_DataBuffer := #iqa_FifoData);
	    
	END_REGION
	
	REGION 2 – Configuration check and create error
	    
	    #si_FacialityIDLen := LEN(#iUDT_Facility.FacilityID);
	    #si_SystemIDLen := LEN(#iUDT_Facility.SystemID);
	    
	    #sa_Status.InvalidSystemIDLen := #si_SystemIDLen <> 15;
	    #sa_Status.InvalidFacialityIDLen := #si_FacialityIDLen <> 6;
	    
	END_REGION
	
	REGION 3 – Message preparation
	    
	    
	    IF (NOT #iqUDT_FifoHeader.Status.Full)                         // FIFO isn't full
	    THEN
	        IF (NOT #sa_Status.FIFOError                                // No FIFO errors
	            AND NOT #sa_Status.InvalidSystemIDLen                   // Length of system ID field is ok   
	            AND NOT #sa_Status.InvalidFacialityIDLen)               // Length of faciality ID field is ok
	            
	        THEN
	            REGION 3.1 – Message preparation
	                
	                IF #ix_ConnectionStatus                             //Creating connection status
	                THEN
	                    #ss_ConnectionStatus := 'Y';
	                    
	                ELSE
	                    #ss_ConnectionStatus := 'N';
	                    
	                END_IF;
	                
	                #ss_LastHost := '';                                 // Initializing Last host field
	                #ss_LastHost := #is_LastHost;
	                #si_LastHostLen := LEN(#ss_LastHost);
	                
	                // Filling up rest of the field with spaces
	                FOR #si_i := 1 TO 32 - #si_LastHostLen DO
	                    
	                    #ss_LastHost := CONCAT(IN1 := #ss_LastHost,
	                                           IN2 := ' ');
	                    
	                END_FOR;
	                
	                #ss_VersionID := '';                                // Initializing Version ID field
	                #ss_VersionID := #iUDT_Facility.VersionID;
	                #si_VersionIDLen := LEN(#ss_VersionID);
	                
	                // Filling up rest of the field with space
	                FOR #si_j := 1 TO 6 - #si_VersionIDLen DO
	                    
	                    #ss_VersionID := CONCAT(IN1 := #ss_VersionID,
	                                            IN2 := ' ');
	                    
	                END_FOR;
	                
	                // Message preparation
	                
	                // Login Response message composing according to the structure
	                #ss_Message := CONCAT(IN1 := #cc_STX,                               // Start of the message (STX) '$02'
	                                      IN2 := #cs_MessageLength,                     // Message length 
	                                      IN3 := #cs_MessageType,                       // Message type
	                                      IN4 := #iUDT_Facility.FacilityID,           // Facility ID 
	                                      IN5 := #iUDT_Facility.SystemID,             // System ID 
	                                      IN6 := #ss_VersionID,                         // Used version ID 
	                                      IN7 := #ss_ConnectionStatus,                  // Connection status
	                                      IN8 := #ss_LastHost,                          // Last connected host IP adress 
	                                      IN9 := #cc_ETX);                              // End of the message (ETX) '$03"
	                
	            END_REGION
	            
	            REGION 3.2 – Maximum number of the message characters
	                
	                #si_MaxMsgLen := "FC_GetNrOfArrayEl"(iv_Array := #s_UDT_MessageArray.Character);
	                
	            END_REGION
	            
	            REGION 3.3 – Length of the complete message
	                
	                #si_MsgLen := LEN(#ss_Message);
	                
	            END_REGION
	            
	            REGION 3.4 –  Message array size validation
	                
	                #sa_Status.InvalidMsgArraySize := #si_MsgLen > #si_MaxMsgLen;
	                
	            END_REGION
	            
	            REGION 3.5 –  Message character string conversion to a message array of characters
	                
	                IF (NOT #sa_Status.InvalidMsgArraySize)                 // Message character array size is valid 
	                THEN
	                    
	                    Strg_TO_Chars(Strg := #ss_Message,
	                                  pChars := 0,
	                                  Cnt => #sui_MsgArrayElNr,
	                                  Chars := #s_UDT_MessageArray.Character);
	                    
	                END_IF;
	                
	            END_REGION
	            
	            REGION 3.6 – Clearing remaining characters in the message character array
	                
	                IF (NOT #sa_Status.InvalidMsgArraySize)                 // Message character array size is valid 
	                THEN
	                    
	                    // Filling up not used message character array elements with ' ' 
	                    FILL_BLK(IN := #cc_NULL,
	                             COUNT := UINT_TO_ULINT(INT_TO_UINT(#si_MaxMsgLen) - #sui_MsgArrayElNr),
	                             OUT => #s_UDT_MessageArray.Character[#sui_MsgArrayElNr]);
	                    
	                END_IF;
	                
	            END_REGION
	            
	            
	            REGION 3.7 – Message write into a FIFO register
	                
	                IF (NOT #sa_Status.InvalidMsgArraySize)      // Message character array size is valid 
	                THEN
	                    
	                    // Mode 'W' - Write FIFO record
	                    "FC_Fifo"(ic_Mode := 'W',
	                              qUDT_Status => #sa_Status.FIFOStatus,
	                              qx_Error => #sa_Status.FIFOError,
	                              qx_Warning => #sa_Status.FIFOWarning,
	                              iqv_Data := #s_UDT_MessageArray,
	                              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                              iqv_DataBuffer := #iqa_FifoData);
	                    
	                END_IF;
	                
	            END_REGION
	            
	        END_IF;
	        
	        // In case of FIFO full, the FIFO full error bit and FIFO collective error bit are set
	    ELSE
	        #sa_Status.FIFOError := TRUE;
	        #sa_Status.FIFOStatus.FifoFull := TRUE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 – Status
	    
	    // Parametrization collective error output
	    #qx_Error :=
	    #sa_Status.InvalidSystemIDLen                               // Invalid System ID string length 
	    OR #sa_Status.InvalidFacialityIDLen                         // Invalid Faciality ID lenght
	    OR #sa_Status.InvalidMsgArraySize                           // Invalid message array size 
	    OR #sa_Status.FIFOError;                                    // FIFO error
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_FedExEquipmentStatusMessage"
TITLE = FB_Heartbeat
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : UPS_SpecificCommunication
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 72
// END_ATTRIBUTES
//Function block to send and monitor the UPS heartbeat message.
   VAR_INPUT 
      iUDT_Facility { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FedExFacility";   // System configuration
      is_LOConEquipment { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[3];   // Location of the equipment
      is_DEPCOD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[6];   // Depot Code
      is_TYPofEquipment { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[3];   // Type of equipment
      is_NumberOfTheEquipment { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[3];   // Number of the equipment 001-999
      is_DeviceType { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[6];   // Type of Device
      is_DeviceID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[6];   // ID of the Device Type
      is_StatusCode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[3];   // Status code values
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Error
   END_VAR

   VAR_IN_OUT 
      iqUDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqa_FifoData : Array[*] of "UDT_Message";   // FIFO data
   END_VAR

   VAR 
      sUDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Message";   // Message character array
      sa_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";   // FIFO status structure
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO data buffer full
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO error
         InvalidGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Invalid GIN
         InvalidMessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Invalid PLC ID or TRAY ID
         InvalidMsgArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat timeout lower than zero or lower than heartbeat time interval
      END_STRUCT;
      ss_LLCSystemID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[15];   // Identifier of Low-Level controls
      ss_DeviceID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[6];
      ss_DeviceType { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[6];
      ss_StatusCode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[3];
      ss_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Message character string
      sui_MsgArrayElNr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Invalid message array size
      si_MaxMsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum message length
      si_MsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // String character message length
      si_LostMsg { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Number of lost messages
      si_DeviceIDLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_DeviceTypeLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_StatusCodeLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_LenFillLoop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Loop couter
      sx_MsgLost { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message lost
   END_VAR

   VAR CONSTANT 
      cc_NULL : Char := '$00';   // NULL sign
      cc_STX : Char := '$02';   // Start of the text
      cc_ETX : Char := '$03';   // End of the text
      cs_Length : String := '0058';   // Legth of the message
      cs_MessageType : String := 'ES';   // Message type
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	29/06/2021  | 1.0       | F.Baten       | first release MHS TIA 16.4
	10/11/2021  | 1.2       | M.Piela       | Updating regions numbering, interface changes
	10/11/2021  | 1.3       | M.Piela       | Device ID, Device Type and Status Code conversion 
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #sa_Status.FIFOStatus,
	              qx_Error => #sa_Status.FIFOError,
	              qx_Warning => #sa_Status.FIFOWarning,
	              iqv_Data := #sUDT_MessageArray,
	              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	              iqv_DataBuffer := #iqa_FifoData);
	END_REGION
	
	REGION 2 – Message preparation
	    
	    IF NOT #iqUDT_FifoHeader.Status.Full                 // FIFO isn't full
	    THEN
	        
	        REGION 2.1 - LLC System ID
	            #ss_LLCSystemID := CONCAT(IN1 := #is_DEPCOD,
	                                      IN2 := #is_LOConEquipment,
	                                      IN3 := #is_TYPofEquipment,
	                                      IN4 := #is_NumberOfTheEquipment);
	        END_REGION
	        
	        REGION 2.2. Device Type
	            
	            #ss_DeviceType := #is_DeviceType;
	            #si_DeviceTypeLen := LEN(#ss_DeviceType);
	            
	            IF #si_DeviceTypeLen < 6
	            THEN
	                FOR #si_LenFillLoop := #si_DeviceTypeLen TO 6 DO
	                    #ss_DeviceType := CONCAT(IN1 := #ss_DeviceType,
	                                             IN2 := ' ');
	                END_FOR;
	                
	            END_IF;
	            
	        END_REGION
	        
	        REGION 2.3. Device ID
	            
	            #ss_DeviceID := #is_DeviceID;
	            #si_DeviceIDLen := LEN(#ss_DeviceID);
	            
	            IF #si_DeviceIDLen < 6
	            THEN
	                FOR #si_LenFillLoop := #si_DeviceIDLen TO 6 DO
	                    #ss_DeviceID := CONCAT(IN1 := #ss_DeviceID,
	                                           IN2 := ' ');
	                END_FOR;
	                
	            END_IF;
	            
	        END_REGION
	        
	        REGION 2.4. Status Code
	            
	            #ss_StatusCode := #is_StatusCode;
	            #si_StatusCodeLen := LEN(#ss_StatusCode);
	            
	            IF #si_StatusCodeLen < 3
	            THEN
	                FOR #si_LenFillLoop := #si_StatusCodeLen TO 3 DO
	                    #ss_StatusCode := CONCAT(IN1 := #ss_StatusCode,
	                                             IN2 := ' ');
	                END_FOR;
	                
	            END_IF;
	            
	        END_REGION
	        
	        IF NOT #sa_Status.FIFOError                   // No FIFO error
	        THEN
	            REGION 2.5 – Message preparation
	                // Message composing according to the structure: STX,Body ,ETX
	                #ss_Message := CONCAT(IN1 := #cc_STX,
	                                      IN2 := #cs_Length,
	                                      IN3 := #cs_MessageType,
	                                      IN4 := #ss_LLCSystemID,
	                                      IN5 := #ss_DeviceType,
	                                      IN6 := #ss_DeviceID,
	                                      IN7 := #ss_StatusCode,
	                                      IN8 := "DB_Time".Timestamp,
	                                      IN9 := #iUDT_Facility.TimeZoneDesignator,
	                                      IN10 := #cc_ETX);
	                
	            END_REGION
	            
	            REGION 2.6 – Maximum number of the message characters
	                
	                #si_MaxMsgLen := "FC_GetNrOfArrayEl"(iv_Array := #sUDT_MessageArray.Character);
	                
	            END_REGION
	            
	            REGION 2.7 – Length of the complete message
	                
	                #si_MsgLen := LEN(#ss_Message);
	                // Message length validation
	                #sa_Status.InvalidMessageLength := #si_MsgLen - 2 <> STRING_TO_INT(#cs_Length);
	                
	            END_REGION
	            
	            REGION 2.8 –  Message array size validation
	                
	                #sa_Status.InvalidMsgArraySize := #si_MsgLen > #si_MaxMsgLen;
	                
	            END_REGION
	            
	            REGION 2.9 –  Message character string conversion to a message array of characters
	                
	                IF (NOT #sa_Status.InvalidMsgArraySize)     // Message character array size is valid 
	                THEN
	                    
	                    Strg_TO_Chars(Strg := #ss_Message,
	                                  pChars := 0,
	                                  Cnt => #sui_MsgArrayElNr,
	                                  Chars := #sUDT_MessageArray.Character);
	                    
	                END_IF;
	                
	            END_REGION
	            
	            REGION 2.10 – Clearing remaining characters in the message character array
	                
	                IF (NOT #sa_Status.InvalidMsgArraySize)     // Message character array size is valid 
	                THEN
	                    
	                    // Filling up not used message character array elements with '$00' (ASCII - 16#00)
	                    FILL_BLK(IN := #cc_NULL,
	                             COUNT := UINT_TO_ULINT(INT_TO_UINT(#si_MaxMsgLen) - #sui_MsgArrayElNr),
	                             OUT => #sUDT_MessageArray.Character[#sui_MsgArrayElNr]);
	                    
	                END_IF;
	                
	            END_REGION
	            
	            REGION 2.11 – Message write into a FIFO register
	                
	                IF NOT #sa_Status.InvalidMsgArraySize      // Message character array size is valid 
	                THEN
	                    
	                    // Mode 'W' - Write FIFO record
	                    "FC_Fifo"(ic_Mode := 'W',
	                              qUDT_Status => #sa_Status.FIFOStatus,
	                              qx_Error => #sa_Status.FIFOError,
	                              qx_Warning => #sa_Status.FIFOWarning,
	                              iqv_Data := #sUDT_MessageArray,
	                              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                              iqv_DataBuffer := #iqa_FifoData);
	                END_IF;
	                
	            END_REGION
	            
	        END_IF;
	        
	        // In case of FIFO full, the FIFO full error bit and FIFO collective error bit are set
	    ELSE
	        
	        #sa_Status.FIFOError := TRUE;
	        #sa_Status.FIFOStatus.FifoFull := TRUE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Writing output
	    
	    #qx_Error := #sa_Status.InvalidMessageLength        // Invalid message length
	    OR #sa_Status.InvalidMsgArraySize                   // Invalid message array size 
	    OR #sa_Status.FIFOError;                            // FIFO error
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION "FC_Statistics" : Void
TITLE = FC_Statistics
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 26
// END_ATTRIBUTES
//Function to calculate statistics.
   VAR_INPUT 
      ix_Reset : Bool;   // Reset statistics data
      ix_Activate : Bool;   // Activete statistics counters
      ix_RTrigActivate : Bool;   // Activation rise trigger
   END_VAR

   VAR_IN_OUT 
      iqUDT_Statistics : "UDT_EventStatistic";   // Statistic structure
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | C. Leite      | first release MHS TIA 15.1
	17/07/2019  | 0.2       | A.Nowak       | Add comments
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	27/08/2019  | 2.1       | M.Kurpiers    | Comments adjusted
	04/11/2019  | 2.2       | L.Klar        | 1 second pulse changed from memory bit to DB variable
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Number of events
	    
	    IF (#ix_RTrigActivate)      // Event occured                                
	    THEN
	        
	        // Increment the number of times the event occurred and clear the time of the current or last event
	        #iqUDT_Statistics.NumberOfTimes += 1;
	        #iqUDT_Statistics.LastEventSeconds := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Event time
	    
	    // 1 shot every 1 sec and activate statistic counter 
	    IF ("DB_Memory".OS_1sec AND #ix_Activate)
	    THEN
	        
	        // Increment the time of the current or last event and the time of all events that occured
	        #iqUDT_Statistics.LastEventSeconds += 1;
	        #iqUDT_Statistics.TotalEventSeconds += 1;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Data reset
	    
	    
	    IF (#ix_Reset)                                            // Reset statistics data                                          
	    THEN
	        
	        IF (NOT #ix_Activate)                                 // Statistic counter isn't activate                                
	        THEN
	            
	            // Clear statistics data
	            #iqUDT_Statistics.NumberOfTimes := 0;
	            #iqUDT_Statistics.LastEventSeconds := 0;
	            #iqUDT_Statistics.TotalEventSeconds := 0;
	            
	        ELSE
	            
	            // Write 1 to the number of times the event occurred and clear times  
	            #iqUDT_Statistics.NumberOfTimes := 1;
	            #iqUDT_Statistics.LastEventSeconds := 0;
	            #iqUDT_Statistics.TotalEventSeconds := 0;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
END_FUNCTION

FUNCTION_BLOCK "FB_PneumaticBrakeUnit"
TITLE = FB_PneumaticBrakeUnit
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'F.Baten'
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 223
// END_ATTRIBUTES
//Function to control a pneumatic brake contol
   VAR_INPUT 
      iUDT_PneumaticBreakConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PneumaticBrakeConfiguration";   // Pneumatic brake configuration structure
      ix_PECBrake { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when the brake photoye is not blocked
      ix_PECStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when the stop photoye is not blocked
      ix_PECdownstream { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when the photoye downstream is not blocked
      ix_DownstreamStopActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when the downstream stop is active
      ix_MasterValve { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when master valve is on
      ix_SafetyOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when safety is ok
   END_VAR

   VAR_OUTPUT 
      qx_Valve { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when valve is activated
      qx_StopActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when stop is activated to upstream
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
   END_VAR

   VAR 
      s_PECBreakTimerOnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Filtering end of section photo eye signal
      s_PECStopTimerOnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Filtering end of section photo eye signal
      s_StopFunctionTimerOnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Filtering end of section photo eye signal
      s_StopReleaseOnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sR_TRIG_PECStop {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger PEC jam
      slr_StepTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Step timer
      slr_BrakeInterval { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Brake interval
      si_BrakeFunction { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Brake function step
      si_BrakeCycles { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Number of cyles
      sx_Cycle { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Cycle
      sx_PECBrakeFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PEC signal filtered
      sx_PECStopFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PEC signal filtered
      sx_DownstreamStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Downstream is stopped
      sx_StopFunctionActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stop function is activated
      sx_BrakePulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Brake pulse 1 is active
      sx_BrakeAssemblyValve { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Brake assembly valve
      sx_NoCycles { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // No cycles
      sx_Enable_release { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR CONSTANT 
      ci_ReleaseStopBreakTimeOnDelay : UInt := 10000;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	23/06/2021  | 0.0       | F. Baten      | first release TIA 15.1
	20/10/2021  | 0.1       | M. Piela      | Add equipment control. Stylistic correction
	25/06/2021  | 0.2       | M. Kurpiers   | Add stop break release
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	 *)
	
	REGION 1 - Timers
	    
	    // Filtering brake photo eye signal
	    #s_PECBreakTimerOnOffDelay(iudi_OnDelayTime := #iUDT_PneumaticBreakConfiguration.PECBrakeOnDelay,
	                               iudi_OffDelayTime := #iUDT_PneumaticBreakConfiguration.PECBrakeOffDelay,
	                               ix_SignalToDelay := #ix_PECBrake,
	                               ix_Enable := TRUE,
	                               qx_DelayedSignal => #sx_PECBrakeFiltered);
	    
	    // Filtering stop photo eye signal
	    #s_PECStopTimerOnOffDelay(iudi_OnDelayTime := #iUDT_PneumaticBreakConfiguration.PECStopOnDelay,
	                              iudi_OffDelayTime := #iUDT_PneumaticBreakConfiguration.PECStopOffDelay,
	                              ix_SignalToDelay := #ix_PECStop,
	                              ix_Enable := TRUE,
	                              qx_DelayedSignal => #sx_PECStopFiltered);
	    
	    // Filtering downstream stop photo eye signal
	    #s_StopFunctionTimerOnOffDelay(iudi_OnDelayTime := #iUDT_PneumaticBreakConfiguration.StopFunctionOnDelay,
	                                   iudi_OffDelayTime := #iUDT_PneumaticBreakConfiguration.StopFunctionOffDelay,
	                                   ix_SignalToDelay := #ix_DownstreamStopActive,
	                                   ix_Enable := TRUE,
	                                   qx_DelayedSignal => #sx_DownstreamStop);
	    
	    #s_StopReleaseOnOffDelay(iudi_OnDelayTime := #ci_ReleaseStopBreakTimeOnDelay,
	                             iudi_OffDelayTime := 0,
	                             ix_SignalToDelay := #ix_PECdownstream AND NOT #ix_PECBrake,
	                             ix_Enable := TRUE,
	                             qx_DelayedSignal => #sx_Enable_release);
	    
	    // Sequence Timer
	    IF #slr_StepTimer > 0
	    THEN
	        #slr_StepTimer -= "DB_Memory".PrevCycleTime;
	        IF #slr_StepTimer < 0
	        THEN
	            #slr_StepTimer := 0;
	        END_IF;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Brake function
	    // Braking of the parcel is activated when first parcel arrives in brake PEC and stop function is not active.
	    // Now the brake is raised configured number of times with the configured brakepuls time and the configured delay. this is done every time again with the configured
	    // interval time as long as the PEC brake is occupied.
	    
	    #sR_TRIG_PECStop(CLK := #ix_PECStop);
	    // Restart sequence
	    IF #sR_TRIG_PECStop.Q AND NOT #sx_PECStopFiltered
	    THEN
	        #si_BrakeFunction := 1;
	    END_IF;
	    
	    IF #sx_NoCycles AND #ix_PECBrake THEN
	        #sx_NoCycles := FALSE;
	    END_IF;
	    
	    IF #iUDT_PneumaticBreakConfiguration.BrakeCycles = 1
	    THEN
	        #slr_BrakeInterval := #iUDT_PneumaticBreakConfiguration.BrakePause;
	    ELSE
	        #slr_BrakeInterval := #iUDT_PneumaticBreakConfiguration.BrakeInterval;
	    END_IF;
	    // Sequence
	    IF #si_BrakeFunction = 1 AND #slr_StepTimer = 0 AND (NOT #ix_PECBrake OR #sx_BrakePulse)
	    THEN
	        #sx_BrakePulse := TRUE;
	        #slr_StepTimer := #iUDT_PneumaticBreakConfiguration.BrakePuls;
	        #si_BrakeFunction := 2;
	        #sx_Cycle := TRUE;
	    END_IF;
	    
	    IF (#si_BrakeFunction = 2 OR #sx_Enable_release) AND #slr_StepTimer = 0 AND #ix_SafetyOk
	    THEN
	        #sx_BrakePulse := False;
	        #si_BrakeCycles += 1;
	        IF #iUDT_PneumaticBreakConfiguration.BrakeCycles > 0
	        THEN
	            IF #si_BrakeCycles >= #iUDT_PneumaticBreakConfiguration.BrakeCycles
	            THEN
	                #si_BrakeCycles := 0;
	                #slr_StepTimer := #slr_BrakeInterval;
	                #si_BrakeFunction := 3;
	                #sx_Cycle := TRUE;
	            ELSE
	                #slr_StepTimer := #iUDT_PneumaticBreakConfiguration.BrakePause;
	                #si_BrakeFunction := 1;
	                #sx_Cycle := TRUE;
	            END_IF;
	        ELSE
	            #sx_NoCycles := TRUE;
	            #si_BrakeCycles := 0;
	            #si_BrakeFunction := 4;
	        END_IF;
	    END_IF;
	    // Waiting time between interval
	    IF (#si_BrakeFunction = 3 AND #slr_StepTimer = 0) OR #sx_StopFunctionActive
	    THEN
	        #si_BrakeFunction := 1;
	    END_IF;
	    // Wait for pec to clear, one puls only
	    IF (#si_BrakeFunction = 4 AND NOT #sx_NoCycles) OR #sx_StopFunctionActive
	    THEN
	        #si_BrakeFunction := 1;
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Brake valve
	    
	    REGION 3.1 - Brake assembly valve function
	        
	        IF #sx_StopFunctionActive AND NOT #sx_DownstreamStop
	        THEN
	            #sx_StopFunctionActive := FALSE;
	        END_IF;
	        
	        IF #sx_DownstreamStop AND NOT #sx_PECStopFiltered AND NOT #sx_PECBrakeFiltered
	        THEN
	            #sx_StopFunctionActive := TRUE;
	        END_IF;
	        
	        #sx_BrakeAssemblyValve := (#sx_StopFunctionActive
	        AND ((#iUDT_PneumaticBreakConfiguration.Slave AND #ix_MasterValve)
	        OR NOT #iUDT_PneumaticBreakConfiguration.Slave))
	        OR (NOT #sx_StopFunctionActive
	        AND #sx_BrakePulse);
	        
	    END_REGION
	    
	    REGION 3.2 Valve activation
	        
	        IF #iUDT_PneumaticBreakConfiguration.FailSafe
	        THEN
	            #qx_Valve := NOT (#sx_BrakeAssemblyValve OR NOT #ix_SafetyOk);
	        ELSE
	            #qx_Valve := #sx_BrakeAssemblyValve AND #ix_SafetyOk;
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 4 - Stop Active
	    
	    #qx_StopActive := #sx_StopFunctionActive AND NOT #sx_PECStopFiltered AND NOT #sx_PECBrakeFiltered;
	    
	END_REGION
END_FUNCTION_BLOCK

TYPE "UDT_VfdKebaSystemPO"
VERSION : 0.1
   STRUCT
      ToMCAliveCount : Int;   // Motion controller is communicating
      ToMCActiveOpMode : Int;   // Operational mode request: 0 = No Operation; 1 = Auto; 2 = Manual
      ToMCControl1 : Struct   // System control 1
         Start : Bool;   // System control - Start system in auto mode
         LocalSafetyReset : Bool;   // System control - Local safety reset
         Abort : Bool;   // System control - Abort command to interrupt every movement programmed
         Spare_3 : Bool;   // System control - Spare
         Spare_4 : Bool;   // System control - Spare
         Bypass : Bool;   // System control - bypass mode
         Spare_6 : Bool;   // System control - Spare
         StressTest : Bool;   // System control - Start system in stress test mode
         Reset : Bool;   // System control - Alarm reset
         ServoON : Bool;   // System control - Power-On enable
         HomingReq : Bool;   // System control - After the poer-on in homing mode the system perform an homing
         Spare_11 : Bool;   // System control - Spare
         Spare_12 : Bool;   // System control - Spare
         Spare_13 : Bool;   // System control - Spare
         Spare_14 : Bool;   // System control - Spare
         Spare_15 : Bool;   // System control - Spare
      END_STRUCT;
      ToMCControl2 : Struct   // System control 2
         Spare_0 : Bool;   // System control - Spare
         Spare_1 : Bool;   // System control - Spare
         Ax_BeltRunFwd : Bool;   // System control - Spare
         Ax_BeltRunBkwd : Bool;   // System control - Spare
         Spare_4 : Bool;   // System control - Spare
         Spare_5 : Bool;   // System control - Spare
         Spare_6 : Bool;   // System control - Spare
         Spare_7 : Bool;   // System control - Spare
         Spare_8 : Bool;   // System control - Spare
         Spare_9 : Bool;   // System control - Spare
         Spare_10 : Bool;   // System control - Spare
         Spare_11 : Bool;   // System control - Spare
         Spare_12 : Bool;   // System control - Spare
         Spare_13 : Bool;   // System control - Spare
         Ax1_PosRight : Bool;   // System control - Motor 1 Section 1 - command for positioningon the right
         Ax1_PosLeft : Bool;   // System control - Motor 1 Section 1 - command for positioningon the left
      END_STRUCT;
      "ToMCAx[1]" : Struct   // Axis 1 control word
         Jog_Fwd : Bool;   // Axis selected control - jog forward
         Jog_Bkwd : Bool;   // Axis selected control - jog backward
         Abort : Bool;   // Axis selected control - abort eachmovement programmed
         Spare_3 : Bool;   // Axis selected control - Spare
         Spare_4 : Bool;   // Axis selected control - Fault
         Spare_5 : Bool;   // Axis selected control - Spare
         Spare_6 : Bool;   // Axis selected control - Spare
         ZeroDirectReq : Bool;   // Axis selected control - request to perform a recording of actual position with value 0 (use only and exlusively with the conveyor in midlle position)
         Reset : Bool;   // Axis selected control - reset
         Servo_ON : Bool;   // Axis selected control - power and servo On (only for axis selected, the other axes are disabled with Servo-Off)
         Homing : Bool;   // Axis selected control - request to perform an homing procedure
         PosAbs : Bool;   // Axis selected control -  request to perform an absolute positioning
         Spare_12 : Bool;   // Axis selected control - Spare
         Stop : Bool;   // Axis selected control - stop
         QuickStop : Bool;   // Axis selected control - stop for emergency
         spare_15 : Bool;   // Axis selected control - Spare
      END_STRUCT;
      "ToMCAx[1]SpeedSetpoint" : Int;   // Speed setpoint [degree/s*10]
      "ToMCAx[1]Spare2" : Int;   // Axis 1 control - Spare
      "ToMCAx[1]Spare3" : Int;   // Axis 1 control - Spare
      "ToMCAx[1]PositionSetpointRight" : Int;   // Axis 1 control - Position setpoint right [degree*10]
      "ToMCAx[1]PositionSetpointLeft" : Int;   // Axis 1 control - Position setpoint left [degree*10]
      "ToMCAx[2]" : Struct   // Axis 2 control word
         Jog_Fwd : Bool;   // Axis selected control - jog forward
         Jog_Bkwd : Bool;   // Axis selected control - jog backward
         Abort : Bool;   // Axis selected control - abort eachmovement programmed
         Spare_3 : Bool;   // Axis selected control - Spare
         Spare_4 : Bool;   // Axis selected control - Fault
         Spare_5 : Bool;   // Axis selected control - Spare
         Spare_6 : Bool;   // Axis selected control - Spare
         ZeroDirectReq : Bool;   // Axis selected control - request to perform a recording of actual position with value 0 (use only and exlusively with the conveyor in midlle position)
         Reset : Bool;   // Axis selected control - reset
         Servo_ON : Bool;   // Axis selected control - power and servo On (only for axis selected, the other axes are disabled with Servo-Off)
         Homing : Bool;   // Axis selected control - request to perform an homing procedure
         PosAbs : Bool;   // Axis selected control -  request to perform an absolute positioning
         Spare_12 : Bool;   // Axis selected control - Spare
         Stop : Bool;   // Axis selected control - stop
         QuickStop : Bool;   // Axis selected control - stop for emergency
         Direction : Bool;   // Axis selected control - Rotation direction
      END_STRUCT;
      "ToMCAx[2]SpeedSetpoint" : Int;   // Axis 2 Speed setpoint [mm/s*10]
      "ToMCAx[2]Acceleration" : Int;   // Axis 2 Acceleration [mm/s2]
      "ToMCAx[2]Deceleration" : Int;   // Axis 2 Deceleration [mm/s2]
      "ToMCAx[2]Adjustment" : Int;   // Axis 2 Speed control adjustment
      "ToMCAx[2]PositionSetpoint" : Int;   // Axis 2 control - Position setpoint for absolute or relative positioning
   END_STRUCT;

END_TYPE

FUNCTION "FC_EquipmentReport" : Void
TITLE = FC_Equipment_Report
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 16
// END_ATTRIBUTES
//Function to generate equipment report.
   VAR_INPUT 
      iUDT_Status : "UDT_CommonStatus";   // Status structure
   END_VAR

   VAR_IN_OUT 
      iqUDT_Control : "UDT_EquipmentControl";   // Equipment control
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | F.Baten       | first release MHS TIA 15.1
	17/06/2019  | 0.3       | L.Klar        | Manual mode added to "UDT_EquipmentControl"
	17/07/2019  | 0.4       | A.Nowak       | Add all statuses and comments
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	27/08/2019  | 2.1       | K.Pokorski    | Comments adjusted
	16/09/2019  | 2.2       | K.Pokorski    | Equipment error free condition added to "Restart required" status
	06/10/2019  | 2.3       | S. Deukar     | Updated accoring to new UDT equipment report
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	05/02/2024  | 3.1       | L.Klar        | Auto On extention added 
	13/03/2024  | 4.0       | S. Nieswiec   | Added to baseline
	*)
	
	REGION 1 - Equipment report update
	    
	    // Extension of stopped equipment report with the stopped status
	    #iqUDT_Control.Report.Stopped := #iUDT_Status.Stopped
	    OR #iqUDT_Control.Report.Stopped;
	    
	    // Extension of started equipment report with the started status
	    #iqUDT_Control.Report.Running := #iUDT_Status.Running
	    OR #iqUDT_Control.Report.Running;
	    
	    // Extension of energy save equipment report with the energy save status
	    #iqUDT_Control.Report.EnergySave := #iUDT_Status.EnergySave
	    OR #iqUDT_Control.Report.EnergySave;
	    
	    // Extension of warning equipment report with the warning status
	    #iqUDT_Control.Report.Warning := #iUDT_Status.Warning
	    OR #iqUDT_Control.Report.Warning;
	    
	    // Extension of manual mode equipment report with the manual mode status
	    #iqUDT_Control.Report.Manual := #iUDT_Status.Manual
	    OR #iqUDT_Control.Report.Manual;
	    
	    // Extension of error equipment report with the error status
	    #iqUDT_Control.Report.Error := #iUDT_Status.Error
	    OR #iqUDT_Control.Report.Error;
	    
	    // Extension of safety stop equipment report with the safety stop status
	    #iqUDT_Control.Report.SafetyStop := #iUDT_Status.SafetyStop
	    OR #iqUDT_Control.Report.SafetyStop;
	    
	    // Extension of Auto On equipment report with the Auto On status
	    #iqUDT_Control.Report.AutoON := #iUDT_Status.AutoON
	    OR #iqUDT_Control.Report.AutoON;
	    
	    // Extension of restart required equipment report with the restart required and no equipment error statuses
	    #iqUDT_Control.Request.RestartRequired := #iUDT_Status.Stopped
	    AND NOT #iUDT_Status.Error
	    OR #iqUDT_Control.Request.RestartRequired;
	    
	END_REGION
END_FUNCTION

DATA_BLOCK "DB_HMIStatusConfiguration"
TITLE = DB_HMIStatusConfiguration
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
VERSION : 3.0
NON_RETAIN
   VAR 
      FireAlarm : Int;   // Fire alarm active
      SafetyStop : Int;   // Safety stop error status
      Error : Int;   // Error status
      Warning : Int;   // Warning status
      ManualRun : Int;   // Manual run status
      Manual : Int;   // Manual status
      Halted : Int;   // Halted status
      Dieback : Int;   // Die back status
      Stopped : Int;   // Stopped status
      Running : Int;   // Running status
      EnergySave : Int;   // Energy save status
      CommunicationError : Int;   // Communication error status
      CBError : Int;   // CB error status
      ProfinetError : Int;   // Profinet error status
      HardwareError : Int;   // Hardware error status
      VFDNotHealthy : Int;   // VFD noth healthy status
      VFDError : Int;   // VFD error status
      PECJam : Int;   // PEC jam status
      ChuteFull : Int;   // Chute full status
      EncoderError : Int;   // Encoder error status
      TrackingError : Int;   // Tracking error status
      DimensionError : Int;   // Dimension error status
      OperationalError : Int;   // Operational error status
      AutoON : Int;   // Automatic is on
      ChuteHalfFull : Int;   // Disable by operator
      DisableByManagement : Int;   // Disable by management
      GateOpen : Int;   // Manual operated gate is open
      GateClosed : Int;   // Manual operated gate is closed
      GateClosedAndNoOperatorPresent : Int;   // Manual operated gate is closed and no operator is present
      PositionChangeOngoing : Int;   // Lifting device or arm diverter changing position
      BufferMode : Int;   // BufferMode Active
      ContinuousMode : Int;   // ContinuousMode Active
      LabbelingMode : Int;   // LabbelingMode Active
   END_VAR


BEGIN
   FireAlarm := 1;
   SafetyStop := 3;
   Error := 5;
   Warning := 7;
   ManualRun := 9;
   Manual := 11;
   Halted := 13;
   Dieback := 15;
   Stopped := 17;
   Running := 19;
   EnergySave := 21;
   CommunicationError := 23;
   CBError := 25;
   ProfinetError := 27;
   HardwareError := 29;
   VFDNotHealthy := 31;
   VFDError := 33;
   PECJam := 35;
   ChuteFull := 37;
   EncoderError := 39;
   TrackingError := 41;
   DimensionError := 43;
   OperationalError := 45;
   AutoON := 47;
   ChuteHalfFull := 49;
   DisableByManagement := 51;
   GateOpen := 53;
   GateClosed := 55;
   GateClosedAndNoOperatorPresent := 57;
   PositionChangeOngoing := 59;
   BufferMode := 61;
   ContinuousMode := 63;
   LabbelingMode := 65;

END_DATA_BLOCK

TYPE "UDT_VfdKebaSystemStatus"
VERSION : 0.1
   STRUCT
      AX1ErrorCode : Int;   // Axis 1 error code (Rotation)
      AX2ErrorCode : Int;   // Axis 2 error code (Belt)
      PNSlaveNotOnline : Bool := FALSE;   // Profinet slave is not on line
      PNSlaveError : Bool := FALSE;   // Profinet slave has an error
      Axis1InternalError : Bool := FALSE;   // Axis 1 internal error is active, see error code
      Axis2InternalError : Bool := FALSE;   // Axis 2 internal error is active, see error code
      CommunicationError : Bool := FALSE;   // Communication error
      PositioningTimeWarning : Bool := FALSE;   // Exceeded time to reach position
      PNSlaveWarning : Bool := FALSE;   // Profinet slave has a warning
      MaintenanceWarning : Bool := FALSE;   // Maintenance mode active (local control enabled)
      HomingActiveWarning : Bool := FALSE;   // Homing mode activated
      StressTestActiveWarning : Bool := FALSE;   // Stress test mode activated
      MaintenanceManualActiveWarning : Bool := FALSE;   // Manual mode in maintenance activated
   END_STRUCT;

END_TYPE

TYPE "UDT_VfdKebaSystemPI"
VERSION : 0.1
   STRUCT
      FromMCAliveCount : Int;   // Motion controller is communicating
      FromMCActiveOpMode : Int;   // Operational mode active: 0 = No Operation; 1 = Auto; 2 = Manual; 10 = Maintenance; 12 = Maintenance manual; 13 = Homing; 14 = stress test activated
      FromMCStatus1 : Struct   // System status 1
         Running : Bool;   // System status - Running
         LocalSafetyResetRequired : Bool;   // System status - Local safety reset required
         Aborted : Bool;   // System status - Current procedure or command aborted
         STO_OK : Bool;   // System status - STO on drive module 1 and 2 activated
         ECAT_error : Bool;   // System status - Ethercat fault
         PN_error : Bool;   // System status - Profinet fault
         Bypass : Bool;   // System status - Bypass mode active
         StressTestOn : Bool;   // System status - Stress test active
         ControlUnitReady : Bool;   // System status - Control unit ready for operation
         Servo_active : Bool;   // System status - Motors powered and servo active
         Homing : Bool;   // System status - Homing procedure in progress
         Homed : Bool;   // System status - Homing performed
         Fault : Bool;   // System status - Fault active
         Spare_13 : Bool;   // System status - Spare
         Ready : Bool;   // System status - Ready for operation
         Spare_15 : Bool;   // System status - Spare
      END_STRUCT;
      FromMCStatus2 : Struct   // System status 2
         SafetySwitch_1_Engaged : Bool;   // System status - Infeeding photoeye engaged signal
         SafetySwitch_2_Engaged : Bool;   // System status - Safety switch 1 engaged signal
         SafetySwitch_3_Engaged : Bool;   // System status - Safety switch 2 engaged signal
         Outfeeding_Photoeye_Engaged : Bool;   // System status - Outfeeding photoeye engaged signal
         Infeeding_Photoeye_Engaged : Bool;   // System status - Spare
         LimitSwitch_RH_Engaged : Bool;   // System status - Limit switch RH egaged signal
         LimitSwitch_LH_Engaged : Bool;   // System status - Limit switch LH egaged signal
         HomeSwitch_Engaged : Bool;   // System status - Home switch egaged signal
         Spare_8 : Bool;   // System status - Spare
         Spare_9 : Bool;   // System status - Spare
         Spare_10 : Bool;   // System status - Spare
         Spare_11 : Bool;   // System status - Spare
         Spare_12 : Bool;   // System status - Spare
         Spare_13 : Bool;   // System status - Spare
         Ax1_PositionedRight : Bool;   // System status - Motor 1 Section 1 - positioned on the right
         Ax1_PositionedLeft : Bool;   // System status - Motor 1 Section 1 - positioned on the left
      END_STRUCT;
      "FromMCAx[1]" : Struct   // Axis 1 status word
         Fwd_Running : Bool;   // Axis selected status - Motor in forward running
         Bkwd_Running : Bool;   // Axis selected status - Motor in backward running
         Aborted : Bool;   // Axis selected status - current procedure or command aborted
         STO_Ok : Bool;   // Axis selected status - Safe torque OFF ok
         Fault : Bool;   // Axis selected status - Fault
         Bypass : Bool;   // Axis selected status - Axis bypassed
         Spare_6 : Bool;   // Axis selected status - Spare
         ZeroDone : Bool;   // Axis selected status - 0 performed on actual position
         Ready : Bool;   // Axis selected status - ready for operation
         Servo_active : Bool;   // Axis selected status - servo mode active
         Homing : Bool;   // Axis selected status - homing procedure in progress
         Homed : Bool;   // Axis selected status - homing performed
         Positioning : Bool;   // Axis selected status - positioning in progress
         Positioned : Bool;   // Axis selected status - positioned
         Standstill : Bool;   // Axis selected status - motor stopped
         Spare_15 : Bool;   // Axis selected status - Spare
      END_STRUCT;
      "FromMCAx[1]ErrorCode" : Int;   // Axis 1 status - Error code
      "FromMCAx[1]ActualSpeed" : Int;   // Axis 1 status - Actual speed [degrees*10/s]
      "FromMCAx[1]ActualCurrent" : Int;   // Axis 1 status - Actual current [A*100]
      "FromMCAx[1]ActualTorque" : Int;   // Axis 1 status - Actual torque [%*100]
      "FromMCAx[1]ActualPosition" : Int;   // Axis 1 status - Actual position [degrees*100]
      "FromMCAx[2]" : Struct   // Axis 2 status word
         Fwd_Running : Bool;   // Axis selected status - Motor in forward running
         Bkwd_Running : Bool;   // Axis selected status - Motor in backward running
         Aborted : Bool;   // Axis selected status - current procedure or command aborted
         STO_Ok : Bool;   // Axis selected status - Safe torque OFF ok
         Fault : Bool;   // Axis selected status - Fault
         Spare_5 : Bool;   // Axis selected status - Spare
         Spare_6 : Bool;   // Axis selected status - Spare
         ZeroDone : Bool;   // Axis selected status - 0 performed on actual position
         Ready : Bool;   // Axis selected status - ready for operation
         Servo_active : Bool;   // Axis selected status - servo mode active
         Homing : Bool;   // Axis selected status - homing procedure in progress
         Homed : Bool;   // Axis selected status - homing performed
         Positioning : Bool;   // Axis selected status - positioning in progress
         Positioned : Bool;   // Axis selected status - positioned
         Standstill : Bool;   // Axis selected status - motor stopped
         Spare_15 : Bool;   // Axis selected status - Spare
      END_STRUCT;
      "FromMCAx[2]ErrorCode" : Int;   // Axis 2 status - Error code
      "FromMCAx[2]ActualSpeed" : Int;   // Axis 2 status - Actual speed [mm/s*10]
      "FromMCAx[2]ActualCurrent" : Int;   // Axis 2 status - Actual current [A*100]
      "FromMCAx[2]ActualTorque" : Int;   // Axis 2 status - Actual torque [%*100]
      "FromMCAx[2]ActualPosition" : Int;   // Axis 2 status - Actual position [degrees*100]
   END_STRUCT;

END_TYPE

TYPE "UDT_VfdKebaSystemConfiguration"
VERSION : 0.1
   STRUCT
      VFDPNDeviceName : String;   // VFD's device name
      PositioningAxis { S7_SetPoint := 'False'} : "UDT_VfdKebaSystemPositioningAxisConfiguration";   // Positioning axis configuration
      SpeedAxis { S7_SetPoint := 'False'} : "UDT_VfdKebaSystemSpeedAxisConfiguration";   // Speed axis configuration
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_VfdKebaSystem"
TITLE = FB_VFD_SEW_MOVI-C_Positioning
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 86
// END_ATTRIBUTES
//Control SEW Servo VFD with multiple positions
   VAR_INPUT 
      iUDT_VFDConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdKebaSystemConfiguration";   // Configuration structure
      iUDT_VFDInputs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdKebaSystemPI";   // VFD inputs structure
      ix_MainPowerOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when main power is ok
      ix_SimulationModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Simulation On
      ix_SafetyReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Safety reset
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdKebaSystemStatus";   // HMI status structure
      qUDT_VFDOutputs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdKebaSystemPO";   // VFD outputs structure
   END_VAR

   VAR_IN_OUT 
      iqUDT_PolisorterInterface : "UDT_PolisorterInterface";   // Polisorter interface structure
      iqUDT_ConveyorInterface : "UDT_ConveyorInterface";   // Polisorter conveyor interface structure
      iqUDT_VFDStatistics : "UDT_VfdKebaSystemStatistics";   // VFD statistics
   END_VAR

   VAR 
      sUDT_PNDevice { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PNDevice";   //  PN device info structure
      sUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdKebaSystemStatus";   // Status struture
      sa_PNPortsStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..8] of Bool;   // TRUE when specific port has an error
      sFB_TimerOnOffDelayCheckSupply { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // MHS "TimerOnOffDelay" - to delay time for VFD supply contactor
      sFB_TimerOnOffDelayAliveCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // MHS "TimerOnOffDelay" - to delay time for communication feedback
      sFB_TimerOnOffDelayPositioning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // MHS "TimerOnOffDelay" - to delay time for positioning error
      sFB_TimerOnOffDelay_PostionRequestDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // MHS "TimerOnOffDelay" - to delay time for position request
      sFB_TimerOnOffDelay_SafetyResetPulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // MHS "TimerOnOffDelay" - to delay time for safety reset
      sFB_TimerOnOffDelay_Reset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // MHS "TimerOnOffDelay" - to delay time for reset
      sF_TRIG_LST {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge positioning feedback
      sR_TRIG_ManInPos {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge manual travel into position
      sR_TRIG_PNSlaveNotOnline {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for trigger Profinet slave not online statistics
      sR_TRIG_PNSlaveError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for trigger Profinet slave error statistics
      sR_TRIG_Ax1_InternalError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for trigger axis 1 Internal VFD Error statistics
      sR_TRIG_Ax2_InternalError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for trigger axis 2 Internal VFD Error statistics
      sR_TRIG_CommunicationError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for trigger communication error statistics
      sR_TRIG_Ax1_Running {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for starting of the axis 1 running signal
      sR_TRIG_Ax2_Running {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for starting of the axis 2 running signal
      sr_Ax1ActualCurrent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Axis 1 actual current [A]
      sr_Ax1ActualTorque { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Axis 1 actual torque [Nm]
      sr_Ax2ActualCurrent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Axis 2 actual current [A]
      sr_Ax2ActualTorque { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Axis 2 actual torque [Nm]
      sdi_ActualPositionValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Axis 1 actual position [degree]
      sr_Ax1ActualSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Axis 1 actual speed  [degree/s]
      sr_Ax2ActualSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Axis 2 actual speed  [mm/s]
      si_LastSwitchtime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // The actual time it took the last switch-over
      si_AliveCountToKEBA { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_OldSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Old speed setpoint for manual mode speed change during movement
      si_AliveCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Handshake to movikit
      sx_Ax1_ErrorActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Axis 1 error active
      sx_Ax2_ErrorActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Axis 2 error active
      sx_Ax1_WarningActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Axis 1 warning active
      sx_PNDeviceHealthy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PN Device is healthy, no errors
      sx_AliveCountFeedback { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Movikit feedback delay
      sx_HardwareAvailable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // All hardware is on line and available
      sx_PowerOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // All Power (in and external) is ok
      sx_PositioningFeedback { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Positioning feedback delay
      sx_Ax1_Ready { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Axis 1 control is ready to operate
      sx_Ax2_Ready { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Axis 2 control is ready to operate
      sx_ManualPositionStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // A configured position is reached in manual mode
      sx_ManualPosHold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Hold in position
      sx_ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Commissioning: configuration of parameters is wrong
      sx_ResetPulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset pulse
      sx_SpeedChange { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Speed change for manual mode speed change during movement
   END_VAR

   VAR CONSTANT 
      ci_NumberOfProfinetPorts : Int := 2;   // Number of Profinet ports in device
      ci_NoMode : Int := 0;   // Operation mode: No mode
      ci_AutoMode : Int := 1;   // Operation mode: Auto mode
      ci_ManualMode : Int := 2;   // Operation mode: Manual mode
      ci_Maintenance : Int := 10;   // Operation mode: Maintenace mode
      ci_MaintenanceManualMode : Int := 12;   // Operation mode: Maintenace manual mode
      ci_MaintenanceHoming : Int := 13;   // Operation mode: Maintenace homing mode
      ci_MaintenanceStressTest : Int := 14;   // Operation mode: Maintenace stress test  mode
      ci_RotationManualSpeedLinit : Int := 12;   // Rotation speed limit for manual mode
   END_VAR


BEGIN
	(* 
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	26/10/2021  | 0.1       | L.Klar        | first release MHS TIA 16
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Get Device Profinet information
	    
	    "FC_GetDevicePN"(is_PNDeviceName := #iUDT_VFDConfiguration.VFDPNDeviceName,
	                     ix_SimulationModeActive := #ix_SimulationModeActive,
	                     iqUDT_PND := #sUDT_PNDevice);
	    
	    
	    "FC_GetPNPortStatus"(ii_NumberOfPorts := #ci_NumberOfProfinetPorts,
	                         iUDT_DevicePNInfo := #sUDT_PNDevice,
	                         qa_PortFault => #sa_PNPortsStatus);
	    
	END_REGION
	
	REGION 2 - Reset errors
	    
	    // Reset pulse
	    #sFB_TimerOnOffDelay_Reset(iudi_OffDelayTime := 200,
	                               ix_SignalToDelay := #iqUDT_PolisorterInterface.InternalErrorReset OR #iqUDT_ConveyorInterface.InternalErrorReset,
	                               qx_DelayedSignal => #sx_ResetPulse);
	    
	    // Internal errors reset
	    IF #sx_ResetPulse
	        
	    THEN
	        #sUDT_HMIStatus.PNSlaveNotOnline := FALSE;
	        #sUDT_HMIStatus.PNSlaveError := FALSE;
	        #sUDT_HMIStatus.PositioningTimeWarning := FALSE;
	        #sUDT_HMIStatus.Axis1InternalError := FALSE;
	        #sUDT_HMIStatus.PNSlaveWarning := FALSE;
	        #sUDT_HMIStatus.CommunicationError := FALSE;
	        
	    END_IF;
	    
	    // KEBA reset outputs
	    #qUDT_VFDOutputs.ToMCControl1.Reset := #sx_ResetPulse;
	    #qUDT_VFDOutputs."ToMCAx[1]".Reset := #sx_ResetPulse;
	    #qUDT_VFDOutputs."ToMCAx[2]".Reset := #sx_ResetPulse;
	    
	    // Safety reset pulse
	    #sFB_TimerOnOffDelay_SafetyResetPulse(iudi_OffDelayTime := 100,
	                                          ix_SignalToDelay := #ix_SafetyReset,
	                                          qx_DelayedSignal => #qUDT_VFDOutputs.ToMCControl1.LocalSafetyReset);
	    
	END_REGION
	
	REGION 3 - Check Hardware
	    
	    REGION 3.1 - Power OK
	        // Hardware will be available after delay so the device has time for initialisation
	        #sFB_TimerOnOffDelayCheckSupply(iudi_OnDelayTime := 2000,
	                                        ix_SignalToDelay := #ix_MainPowerOk);
	        
	        #sx_PowerOK := #sFB_TimerOnOffDelayCheckSupply.qx_DelayedSignal;
	    END_REGION
	    
	    REGION 3.2 - PN Healthy Check
	        
	        IF NOT "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.Exist
	            AND NOT #ix_SimulationModeActive
	            AND #sx_PowerOK
	        THEN
	            #sUDT_HMIStatus.PNSlaveNotOnline := TRUE;
	        END_IF;
	        
	        // Check if PN ports are healthy 
	        IF #sa_PNPortsStatus[1] XOR #sa_PNPortsStatus[2] THEN
	            #sUDT_HMIStatus.PNSlaveWarning := TRUE;
	        END_IF;
	        
	        IF "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.Error
	            AND NOT #ix_SimulationModeActive
	            AND #sx_PowerOK
	            AND NOT #sUDT_HMIStatus.PNSlaveWarning
	            
	        THEN
	            #sUDT_HMIStatus.PNSlaveError := TRUE;
	        END_IF;
	        
	        #sx_PNDeviceHealthy := NOT #sUDT_HMIStatus.PNSlaveNotOnline
	        AND NOT #sUDT_HMIStatus.PNSlaveError
	        AND #sx_PowerOK
	        AND #sUDT_PNDevice.PNDeviceFound;
	        
	    END_REGION
	    
	    REGION 3.3 - Hardware is available 
	        
	        #sx_HardwareAvailable := #sx_PowerOK
	        AND #sx_PNDeviceHealthy
	        OR #ix_SimulationModeActive;
	        
	    END_REGION
	    
	    REGION 3.4 - Check communication Alive Count
	        
	        // Alive count check
	        #sx_AliveCountFeedback := #si_AliveCount = #iUDT_VFDInputs.FromMCAliveCount;
	        
	        #sFB_TimerOnOffDelayAliveCount(iudi_OnDelayTime := 2000,
	                                       ix_SignalToDelay := #sx_AliveCountFeedback);
	        
	        IF (#sFB_TimerOnOffDelayAliveCount.qx_DelayedSignal)
	            AND #sx_HardwareAvailable
	        THEN
	            #sUDT_HMIStatus.CommunicationError := TRUE;
	        END_IF;
	        
	        #si_AliveCount := #iUDT_VFDInputs.FromMCAliveCount;
	        
	        // Alive count for KEBA
	        IF "DB_Memory"."OS_0.1sec"
	        THEN
	            #qUDT_VFDOutputs.ToMCAliveCount := #si_AliveCountToKEBA;
	            #si_AliveCountToKEBA += 1;
	            
	            IF #si_AliveCountToKEBA > 9999
	            THEN
	                #si_AliveCountToKEBA := 0;
	            END_IF;
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 4 - Handle input data
	    
	    REGION 4.1 - Move to status
	        
	        // Axis 1
	        #sr_Ax1ActualTorque := INT_TO_REAL(#iUDT_VFDInputs."FromMCAx[1]ActualTorque" / 100);
	        #sr_Ax1ActualCurrent := INT_TO_REAL(#iUDT_VFDInputs."FromMCAx[1]ActualCurrent" / 100);
	        #sr_Ax1ActualSpeed := #iUDT_VFDInputs."FromMCAx[1]ActualSpeed" / 10;
	        
	        // Axis 2
	        #sr_Ax2ActualTorque := INT_TO_REAL(#iUDT_VFDInputs."FromMCAx[2]ActualTorque" / 100);
	        #sr_Ax2ActualCurrent := INT_TO_REAL(#iUDT_VFDInputs."FromMCAx[2]ActualCurrent" / 100);
	        #sr_Ax2ActualSpeed := #iUDT_VFDInputs."FromMCAx[2]ActualSpeed" / 10;
	        
	    END_REGION
	    
	    REGION 4.2 - Actual positon value
	        
	        #sdi_ActualPositionValue := #iUDT_VFDInputs."FromMCAx[1]ActualPosition" / 100;
	        
	        IF #sdi_ActualPositionValue <= (#iUDT_VFDConfiguration.PositioningAxis.Position[#iqUDT_PolisorterInterface.PositionSetpoint] + #iUDT_VFDConfiguration.PositioningAxis.PositionWindow)
	            AND #sdi_ActualPositionValue >= (#iUDT_VFDConfiguration.PositioningAxis.Position[#iqUDT_PolisorterInterface.PositionSetpoint] - #iUDT_VFDConfiguration.PositioningAxis.PositionWindow)
	            
	        THEN
	            #iqUDT_PolisorterInterface.PositionActual := #iqUDT_PolisorterInterface.PositionSetpoint;
	        ELSE
	            #iqUDT_PolisorterInterface.PositionActual := 0;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 4.3 - Manual position
	        
	        // Logic to stop at a predefined position when jogging. After the stop, the movement can restarted by pressing the jog button again
	        IF #iUDT_VFDInputs.FromMCActiveOpMode = #ci_ManualMode
	        THEN
	            #sx_ManualPositionStop :=
	            (#sdi_ActualPositionValue <= (#iUDT_VFDConfiguration.PositioningAxis.Position[1] + #iUDT_VFDConfiguration.PositioningAxis.PositionWindow)
	            AND #sdi_ActualPositionValue >= (#iUDT_VFDConfiguration.PositioningAxis.Position[1] - #iUDT_VFDConfiguration.PositioningAxis.PositionWindow))
	            OR (#sdi_ActualPositionValue <= (#iUDT_VFDConfiguration.PositioningAxis.Position[2] + #iUDT_VFDConfiguration.PositioningAxis.PositionWindow)
	            AND #sdi_ActualPositionValue >= (#iUDT_VFDConfiguration.PositioningAxis.Position[2] - #iUDT_VFDConfiguration.PositioningAxis.PositionWindow))
	            OR (#sdi_ActualPositionValue <= (#iUDT_VFDConfiguration.PositioningAxis.Position[3] + #iUDT_VFDConfiguration.PositioningAxis.PositionWindow)
	            AND #sdi_ActualPositionValue >= (#iUDT_VFDConfiguration.PositioningAxis.Position[3] - #iUDT_VFDConfiguration.PositioningAxis.PositionWindow))
	            OR (#sdi_ActualPositionValue <= (#iUDT_VFDConfiguration.PositioningAxis.Position[4] + #iUDT_VFDConfiguration.PositioningAxis.PositionWindow)
	            AND #sdi_ActualPositionValue >= (#iUDT_VFDConfiguration.PositioningAxis.Position[4] - #iUDT_VFDConfiguration.PositioningAxis.PositionWindow))
	            OR (#sdi_ActualPositionValue <= (#iUDT_VFDConfiguration.PositioningAxis.Position[5] + #iUDT_VFDConfiguration.PositioningAxis.PositionWindow)
	            AND #sdi_ActualPositionValue >= (#iUDT_VFDConfiguration.PositioningAxis.Position[5] - #iUDT_VFDConfiguration.PositioningAxis.PositionWindow))
	            OR (#sdi_ActualPositionValue <= (#iUDT_VFDConfiguration.PositioningAxis.Position[6] + #iUDT_VFDConfiguration.PositioningAxis.PositionWindow)
	            AND #sdi_ActualPositionValue >= (#iUDT_VFDConfiguration.PositioningAxis.Position[6] - #iUDT_VFDConfiguration.PositioningAxis.PositionWindow))
	            OR (#sdi_ActualPositionValue <= (#iUDT_VFDConfiguration.PositioningAxis.Position[7] + #iUDT_VFDConfiguration.PositioningAxis.PositionWindow)
	            AND #sdi_ActualPositionValue >= (#iUDT_VFDConfiguration.PositioningAxis.Position[7] - #iUDT_VFDConfiguration.PositioningAxis.PositionWindow))
	            OR (#sdi_ActualPositionValue <= (#iUDT_VFDConfiguration.PositioningAxis.Position[8] + #iUDT_VFDConfiguration.PositioningAxis.PositionWindow)
	            AND #sdi_ActualPositionValue >= (#iUDT_VFDConfiguration.PositioningAxis.Position[8] - #iUDT_VFDConfiguration.PositioningAxis.PositionWindow))
	            OR (#sdi_ActualPositionValue <= (#iUDT_VFDConfiguration.PositioningAxis.Position[9] + #iUDT_VFDConfiguration.PositioningAxis.PositionWindow)
	            AND #sdi_ActualPositionValue >= (#iUDT_VFDConfiguration.PositioningAxis.Position[9] - #iUDT_VFDConfiguration.PositioningAxis.PositionWindow))
	            OR (#sdi_ActualPositionValue <= (#iUDT_VFDConfiguration.PositioningAxis.Position[10] + #iUDT_VFDConfiguration.PositioningAxis.PositionWindow)
	            AND #sdi_ActualPositionValue >= (#iUDT_VFDConfiguration.PositioningAxis.Position[10] - #iUDT_VFDConfiguration.PositioningAxis.PositionWindow));
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 5 - Errors and warnings
	    
	    REGION 5.1 - VFD internal error 
	        
	        // Axis 1
	        #sUDT_HMIStatus.Axis1InternalError := #iUDT_VFDInputs."FromMCAx[1]".Fault;
	        #sUDT_HMIStatus.AX1ErrorCode := #iUDT_VFDInputs."FromMCAx[1]ErrorCode";
	        
	        IF NOT #iUDT_VFDInputs."FromMCAx[1]".Fault
	        THEN
	            #sUDT_HMIStatus.AX1ErrorCode := 0;
	        END_IF;
	        
	        // Axis 2
	        #sUDT_HMIStatus.Axis2InternalError := #iUDT_VFDInputs."FromMCAx[2]".Fault;
	        #sUDT_HMIStatus.AX2ErrorCode := #iUDT_VFDInputs."FromMCAx[2]ErrorCode";
	        
	        IF NOT #iUDT_VFDInputs."FromMCAx[2]".Fault
	        THEN
	            #sUDT_HMIStatus.AX2ErrorCode := 0;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 5.2 - Positioning warning
	        
	        // This timer checks if the speed of the VFD is ok.
	        // The VFD should reach is next destination in the given time
	        
	        #sx_PositioningFeedback := #iqUDT_PolisorterInterface.PositionActual <> #iqUDT_PolisorterInterface.PositionSetpoint
	        AND #iqUDT_PolisorterInterface.Automatic;
	        
	        #sF_TRIG_LST(CLK := #sx_PositioningFeedback);
	        
	        IF #sF_TRIG_LST.Q
	        THEN
	            #si_LastSwitchtime := LREAL_TO_INT(#sFB_TimerOnOffDelayPositioning.qlr_ActualTime);
	        END_IF;
	        
	        #sFB_TimerOnOffDelayPositioning(iudi_OnDelayTime := (#iqUDT_PolisorterInterface.SwitchingTime + 100),
	                                        ix_SignalToDelay := #sx_PositioningFeedback);
	        
	        IF #sFB_TimerOnOffDelayPositioning.qx_DelayedSignal
	        THEN
	            #sUDT_HMIStatus.PositioningTimeWarning := TRUE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 5.3 - Common Error
	        
	        // Axis 1 VFD error active
	        #sx_Ax1_ErrorActive := #sUDT_HMIStatus.Axis1InternalError
	        OR #sUDT_HMIStatus.CommunicationError;
	        
	        // Axis 1 VFD error active
	        #sx_Ax2_ErrorActive := #sUDT_HMIStatus.Axis2InternalError
	        OR #sUDT_HMIStatus.CommunicationError;
	        
	    END_REGION
	    
	    REGION 5.4 - Configuration Error
	        
	        //  Check if no faulty setup is active
	        //  This is the responcebility of the commisioning engineer 
	        IF #iUDT_VFDConfiguration.PositioningAxis.PositionMax > #iUDT_VFDConfiguration.PositioningAxis.PositionMin
	            AND #iUDT_VFDConfiguration.PositioningAxis.PositionMax > 0
	            AND #iUDT_VFDConfiguration.PositioningAxis.VFDSpeed > 0
	            AND #iUDT_VFDConfiguration.SpeedAxis.Acceleration > 0
	            AND #iUDT_VFDConfiguration.SpeedAxis.Deceleration > 0
	            AND "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.Configure
	        THEN
	            #sx_ConfigurationError := FALSE;
	        ELSE
	            #sx_ConfigurationError := TRUE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 5.5 - Common warning
	        
	        // Set VFD warning active
	        #sx_Ax1_WarningActive := #sUDT_HMIStatus.PositioningTimeWarning;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 6 - Check conditions to set VFD Ready signals
	    
	    REGION 6.1 - Internal VFD ready
	        
	        // Axis 1
	        #sx_Ax1_Ready := #sx_HardwareAvailable
	        AND (#iUDT_VFDInputs."FromMCAx[1]".Ready
	        OR #iUDT_VFDInputs.FromMCStatus1.Running)
	        AND NOT #sx_Ax1_ErrorActive
	        AND NOT #sx_ConfigurationError
	        AND (#iUDT_VFDInputs."FromMCAx[1]".STO_Ok OR #iUDT_VFDInputs."FromMCAx[1]".Bypass);
	        
	        // Axis 2
	        #sx_Ax2_Ready := #sx_HardwareAvailable
	        AND (#iUDT_VFDInputs."FromMCAx[2]".Ready
	        OR #iUDT_VFDInputs.FromMCStatus1.Running)
	        AND NOT #sx_Ax1_ErrorActive
	        AND NOT #sx_ConfigurationError
	        AND #iUDT_VFDInputs."FromMCAx[2]".STO_Ok;
	        
	    END_REGION
	    
	    REGION 6.2 - External VFD ready (to control)
	        
	        #iqUDT_PolisorterInterface.Ready :=
	        (#iqUDT_PolisorterInterface.Automatic
	        AND NOT #iqUDT_PolisorterInterface.Manual
	        AND #iUDT_VFDInputs.FromMCStatus1.Homed
	        AND #iUDT_VFDInputs.FromMCActiveOpMode = #ci_AutoMode)
	        OR
	        (NOT #iqUDT_PolisorterInterface.Automatic
	        AND #iqUDT_PolisorterInterface.Manual
	        AND #iUDT_VFDInputs.FromMCActiveOpMode = #ci_ManualMode)
	        AND
	        #iqUDT_PolisorterInterface.RunEnabled;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 7 - Set VFD control data 
	    
	    REGION 7.1 - Initialize variables
	        
	        // Operating mode
	        #qUDT_VFDOutputs.ToMCActiveOpMode := #ci_NoMode;
	        
	        // Axis 1
	        #qUDT_VFDOutputs."ToMCAx[1]SpeedSetpoint" := 0;
	        #qUDT_VFDOutputs.ToMCControl1.ServoON := FALSE;
	        #qUDT_VFDOutputs.ToMCControl1.Start := FALSE;
	        
	        #qUDT_VFDOutputs."ToMCAx[1]".Servo_ON := FALSE;
	        #qUDT_VFDOutputs."ToMCAx[1]".Jog_Fwd := FALSE;
	        #qUDT_VFDOutputs."ToMCAx[1]".Jog_Bkwd := FALSE;
	        
	        // Axis 2
	        #qUDT_VFDOutputs."ToMCAx[2]".Servo_ON := FALSE;
	        #qUDT_VFDOutputs.ToMCControl2.Ax_BeltRunFwd := FALSE;
	        #qUDT_VFDOutputs.ToMCControl2.Ax_BeltRunBkwd := FALSE;
	        #qUDT_VFDOutputs."ToMCAx[2]SpeedSetpoint" := 0;
	        
	        #qUDT_VFDOutputs."ToMCAx[2]".Servo_ON := FALSE;
	        #qUDT_VFDOutputs."ToMCAx[2]".Jog_Fwd := FALSE;
	        #qUDT_VFDOutputs."ToMCAx[2]".Jog_Bkwd := FALSE;
	        
	        #qUDT_VFDOutputs."ToMCAx[2]SpeedSetpoint" := 0;
	        #qUDT_VFDOutputs."ToMCAx[2]Acceleration" := 0;
	        #qUDT_VFDOutputs."ToMCAx[2]Deceleration" := 0;
	        
	    END_REGION
	    
	    REGION 7.2 - Manual mode - jogging
	        
	        IF #sx_Ax1_Ready
	            AND #iqUDT_PolisorterInterface.Manual
	            AND NOT #iqUDT_PolisorterInterface.Automatic
	            AND #iqUDT_PolisorterInterface.RunEnabled
	            AND NOT #iUDT_VFDInputs."FromMCAx[1]".Bypass
	            
	        THEN
	            
	            // Speed setpoint (saturated to 12 degree/s)
	            IF #iUDT_VFDConfiguration.PositioningAxis.VFDSpeed > #ci_RotationManualSpeedLinit THEN
	                #qUDT_VFDOutputs."ToMCAx[1]SpeedSetpoint" := 12 * 10;
	            ELSE
	                #qUDT_VFDOutputs."ToMCAx[1]SpeedSetpoint" := #iUDT_VFDConfiguration.PositioningAxis.VFDSpeed * 10;
	            END_IF;
	            
	            #qUDT_VFDOutputs.ToMCActiveOpMode := #ci_ManualMode;
	            
	            // Servo On
	            #qUDT_VFDOutputs."ToMCAx[1]".Servo_ON := #iUDT_VFDInputs.FromMCActiveOpMode = #ci_ManualMode
	            AND #iUDT_VFDInputs."FromMCAx[1]".Ready;
	            
	            // Manual commands
	            IF #iUDT_VFDInputs.FromMCActiveOpMode = #ci_ManualMode
	                AND #iUDT_VFDInputs."FromMCAx[1]".Servo_active
	            THEN
	                
	                // On position while jogging: stop, when button is released and pressed again continue to travel
	                #sR_TRIG_ManInPos(CLK := #sx_ManualPositionStop);
	                
	                #sx_ManualPosHold := (#sx_ManualPosHold
	                OR #sR_TRIG_ManInPos.Q)
	                AND (#iqUDT_PolisorterInterface.JogLeft
	                OR #iqUDT_PolisorterInterface.JogRight)
	                AND #iqUDT_PolisorterInterface.Ready;
	                
	                // Jog commands
	                
	                IF #iqUDT_PolisorterInterface.Ready
	                    AND #iqUDT_PolisorterInterface.JogLeft
	                    AND NOT #iqUDT_PolisorterInterface.JogRight
	                    AND NOT #sx_ManualPosHold
	                THEN
	                    #qUDT_VFDOutputs."ToMCAx[1]".Jog_Fwd := TRUE;
	                    #qUDT_VFDOutputs."ToMCAx[1]".Jog_Bkwd := FALSE;
	                ELSIF
	                    #iqUDT_PolisorterInterface.Ready
	                    AND NOT #iqUDT_PolisorterInterface.JogLeft
	                    AND #iqUDT_PolisorterInterface.JogRight
	                    AND NOT #sx_ManualPosHold
	                THEN
	                    #qUDT_VFDOutputs."ToMCAx[1]".Jog_Fwd := FALSE;
	                    #qUDT_VFDOutputs."ToMCAx[1]".Jog_Bkwd := TRUE;
	                ELSE
	                    #qUDT_VFDOutputs."ToMCAx[1]".Jog_Fwd := FALSE;
	                    #qUDT_VFDOutputs."ToMCAx[1]".Jog_Bkwd := FALSE;
	                    
	                END_IF;
	                
	            END_IF;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 7.3 - Automatic mode - for positioning
	        
	        
	        IF #sx_Ax1_Ready
	            AND (#iUDT_VFDInputs."FromMCAx[1]".STO_Ok OR #iUDT_VFDInputs."FromMCAx[1]".Bypass)
	            AND #iqUDT_PolisorterInterface.Automatic
	            AND NOT #iqUDT_PolisorterInterface.Manual
	            AND #iqUDT_PolisorterInterface.RunEnabled
	            AND #iqUDT_PolisorterInterface.Referenced
	        THEN
	            
	            // Auto mode start
	            #qUDT_VFDOutputs.ToMCActiveOpMode := #ci_AutoMode;
	            
	            // Servo ON
	            #qUDT_VFDOutputs.ToMCControl1.ServoON := #iUDT_VFDInputs.FromMCActiveOpMode = #ci_AutoMode
	            AND #iUDT_VFDInputs."FromMCAx[1]".Ready;
	            
	            // Servo is active
	            IF #iUDT_VFDInputs.FromMCStatus1.Servo_active AND NOT #iUDT_VFDInputs."FromMCAx[1]".Bypass
	            THEN
	                
	                // Start auto mode
	                #qUDT_VFDOutputs.ToMCControl1.Start := TRUE;
	                
	                // Speed setpoint
	                #qUDT_VFDOutputs."ToMCAx[1]SpeedSetpoint" := #iUDT_VFDConfiguration.PositioningAxis.VFDSpeed * 10;
	                
	                // Initilialize positions setpoints
	                // #q_UDT_VFDOutputs."To_MC_Ax[1]PositionSetpointRight" := 0;
	                // #q_UDT_VFDOutputs."To_MC_Ax[1]PositionSetpointLeft" := 0;
	                
	                // Position command delay
	                #sFB_TimerOnOffDelay_PostionRequestDelay(iudi_OnDelayTime := 100,
	                                                         ix_SignalToDelay := #iUDT_VFDInputs."FromMCAx[1]".Positioned AND #iUDT_VFDInputs."FromMCAx[1]".Standstill);
	                
	                IF #sFB_TimerOnOffDelay_PostionRequestDelay.qx_DelayedSignal THEN
	                    // Position setpoint
	                    CASE #iqUDT_PolisorterInterface.PositionSetpoint OF
	                        1:
	                            #qUDT_VFDOutputs.ToMCControl2.Ax1_PosLeft := TRUE;
	                            #qUDT_VFDOutputs.ToMCControl2.Ax1_PosRight := FALSE;
	                            #qUDT_VFDOutputs."ToMCAx[1]PositionSetpointLeft" := #iUDT_VFDConfiguration.PositioningAxis.Position[#iqUDT_PolisorterInterface.PositionSetpoint] * 10;
	                            #qUDT_VFDOutputs."ToMCAx[1]PositionSetpointRight" := 0;
	                        2:
	                            #qUDT_VFDOutputs.ToMCControl2.Ax1_PosLeft := FALSE;
	                            #qUDT_VFDOutputs.ToMCControl2.Ax1_PosRight := FALSE;
	                            #qUDT_VFDOutputs."ToMCAx[1]PositionSetpointLeft" := 0;
	                            #qUDT_VFDOutputs."ToMCAx[1]PositionSetpointRight" := 0;
	                        3:
	                            #qUDT_VFDOutputs.ToMCControl2.Ax1_PosLeft := FALSE;
	                            #qUDT_VFDOutputs.ToMCControl2.Ax1_PosRight := TRUE;
	                            #qUDT_VFDOutputs."ToMCAx[1]PositionSetpointRight" := #iUDT_VFDConfiguration.PositioningAxis.Position[#iqUDT_PolisorterInterface.PositionSetpoint] * 10;
	                            #qUDT_VFDOutputs."ToMCAx[1]PositionSetpointLeft" := 0;
	                    END_CASE;
	                END_IF;
	            END_IF;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 7.4 - Conveyor control
	        
	        IF #sx_Ax2_Ready
	        THEN
	            
	            // Speed change during manual mode (command needs to be reenabled to aplly new speed setpoint)
	            IF #iqUDT_ConveyorInterface.SpeedSetpoint <> #si_OldSpeed THEN
	                #si_OldSpeed := #iqUDT_ConveyorInterface.SpeedSetpoint;
	                #sx_SpeedChange := TRUE;
	            END_IF;
	            
	            // Rotation direction
	            #qUDT_VFDOutputs."ToMCAx[2]".Direction := #iUDT_VFDConfiguration.SpeedAxis.DirectionReversal;
	            // Speed setpoint
	            #qUDT_VFDOutputs."ToMCAx[2]SpeedSetpoint" := #iqUDT_ConveyorInterface.SpeedSetpoint * 10;
	            // Speed correction
	            #qUDT_VFDOutputs."ToMCAx[2]Adjustment" := #iUDT_VFDConfiguration.SpeedAxis.BeltSpeedCorrection;
	            
	            // Accelaeratio, deceleration
	            #qUDT_VFDOutputs."ToMCAx[2]Acceleration" := UINT_TO_INT(#iUDT_VFDConfiguration.SpeedAxis.Acceleration * 10);
	            #qUDT_VFDOutputs."ToMCAx[2]Deceleration" := UINT_TO_INT(#iUDT_VFDConfiguration.SpeedAxis.Deceleration * 10);
	            
	            // Manual mode enable
	            IF #iqUDT_ConveyorInterface.ManualModeActive
	            THEN
	                #qUDT_VFDOutputs.ToMCActiveOpMode := #ci_ManualMode;
	            END_IF;
	            
	            // Servo ON
	            IF #iUDT_VFDInputs.FromMCActiveOpMode = #ci_ManualMode
	                AND #iUDT_VFDInputs."FromMCAx[2]".Ready
	            THEN
	                #qUDT_VFDOutputs."ToMCAx[2]".Servo_ON := TRUE;
	            END_IF;
	            
	            // Servo active
	            IF #iUDT_VFDInputs."FromMCAx[2]".Servo_active
	            THEN
	                
	                IF #iUDT_VFDInputs.FromMCActiveOpMode = #ci_ManualMode
	                THEN
	                    // In manual mode jog outpus are used
	                    #qUDT_VFDOutputs."ToMCAx[2]".Jog_Fwd := NOT #sx_SpeedChange AND #iUDT_VFDConfiguration.SpeedAxis.InterlockFwd AND #iqUDT_ConveyorInterface.RunFwd;
	                    #qUDT_VFDOutputs."ToMCAx[2]".Jog_Bkwd := NOT #sx_SpeedChange AND #iUDT_VFDConfiguration.SpeedAxis.InterlockRvs AND #iqUDT_ConveyorInterface.RunRvs;
	                ELSE
	                    // In auto mode system command are used
	                    #qUDT_VFDOutputs.ToMCControl2.Ax_BeltRunFwd := #iUDT_VFDConfiguration.SpeedAxis.InterlockFwd AND #iqUDT_ConveyorInterface.RunFwd;
	                    #qUDT_VFDOutputs.ToMCControl2.Ax_BeltRunBkwd := #iUDT_VFDConfiguration.SpeedAxis.InterlockRvs AND #iqUDT_ConveyorInterface.RunRvs;
	                END_IF;
	            END_IF;
	        END_IF;
	        
	        // Speed change reset
	        #sx_SpeedChange := FALSE;
	        
	    END_REGION
	    
	    REGION 7.4 - Bypasss mode
	        
	        #qUDT_VFDOutputs.ToMCControl1.Bypass := #iqUDT_PolisorterInterface.BypassMode;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 8 - Maintenance Mode
	    
	    #iqUDT_PolisorterInterface.MaintenanceMode := #sx_HardwareAvailable
	    AND #iUDT_VFDInputs.FromMCActiveOpMode >= 10;
	    
	    #sUDT_HMIStatus.MaintenanceWarning := #iqUDT_PolisorterInterface.MaintenanceMode;
	    
	    #sUDT_HMIStatus.MaintenanceManualActiveWarning := #sx_HardwareAvailable
	    AND #iUDT_VFDInputs.FromMCActiveOpMode = #ci_MaintenanceManualMode;
	    
	    #sUDT_HMIStatus.HomingActiveWarning := #sx_HardwareAvailable
	    AND #iUDT_VFDInputs.FromMCActiveOpMode = #ci_MaintenanceHoming;
	    
	    #sUDT_HMIStatus.StressTestActiveWarning := #sx_HardwareAvailable
	    AND #iUDT_VFDInputs.FromMCActiveOpMode = #ci_MaintenanceStressTest;
	    
	END_REGION
	
	REGION 9 - Statistics
	    
	    // Profinet slave not online errors statistics
	    
	    #sR_TRIG_PNSlaveNotOnline(CLK := #sUDT_HMIStatus.PNSlaveNotOnline);
	    
	    IF #iqUDT_PolisorterInterface.ResetStatistics OR
	        #sUDT_HMIStatus.PNSlaveNotOnline
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_PolisorterInterface.ResetStatistics,
	                        ix_Activate := #sUDT_HMIStatus.PNSlaveNotOnline,
	                        ix_RTrigActivate := #sR_TRIG_PNSlaveNotOnline.Q,
	                        iqUDT_Statistics := #iqUDT_VFDStatistics.PNSlaveNotOnline);
	    END_IF;
	    
	    // Profinet slave errors statistics
	    
	    #sR_TRIG_PNSlaveError(CLK := #sUDT_HMIStatus.PNSlaveError);
	    IF #iqUDT_PolisorterInterface.ResetStatistics OR
	        #sUDT_HMIStatus.PNSlaveError
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_PolisorterInterface.ResetStatistics,
	                        ix_Activate := #sUDT_HMIStatus.PNSlaveError,
	                        ix_RTrigActivate := #sR_TRIG_PNSlaveError.Q,
	                        iqUDT_Statistics := #iqUDT_VFDStatistics.PNSlaveError);
	        
	    END_IF;
	    
	    // Axis 1 internal error statistics
	    
	    #sR_TRIG_Ax1_InternalError(CLK := #sUDT_HMIStatus.Axis1InternalError);
	    
	    IF #iqUDT_PolisorterInterface.ResetStatistics OR
	        #sUDT_HMIStatus.Axis1InternalError
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_PolisorterInterface.ResetStatistics,
	                        ix_Activate := #sUDT_HMIStatus.Axis1InternalError,
	                        ix_RTrigActivate := #sR_TRIG_Ax1_InternalError.Q,
	                        iqUDT_Statistics := #iqUDT_VFDStatistics.Ax1InternalError);
	        
	    END_IF;
	    
	    // Axis 2 internal error statistics
	    
	    #sR_TRIG_Ax2_InternalError(CLK := #sUDT_HMIStatus.Axis2InternalError);
	    
	    IF #iqUDT_PolisorterInterface.ResetStatistics OR
	        #sUDT_HMIStatus.Axis2InternalError
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_PolisorterInterface.ResetStatistics,
	                        ix_Activate := #sUDT_HMIStatus.Axis2InternalError,
	                        ix_RTrigActivate := #sR_TRIG_Ax2_InternalError.Q,
	                        iqUDT_Statistics := #iqUDT_VFDStatistics.Ax2InternalError);
	        
	    END_IF;
	    
	    // Communication error statistics
	    
	    #sR_TRIG_CommunicationError(CLK := #sUDT_HMIStatus.CommunicationError);
	    
	    IF #iqUDT_PolisorterInterface.ResetStatistics OR
	        #sUDT_HMIStatus.CommunicationError
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_PolisorterInterface.ResetStatistics,
	                        ix_Activate := #sUDT_HMIStatus.CommunicationError,
	                        ix_RTrigActivate := #sR_TRIG_CommunicationError.Q,
	                        iqUDT_Statistics := #iqUDT_VFDStatistics.CommunicationError);
	        
	    END_IF;
	    
	    // Axis 1 running statistics
	    
	    #sR_TRIG_Ax1_Running(CLK := #iUDT_VFDInputs.FromMCStatus1.Running);
	    
	    IF #iqUDT_PolisorterInterface.ResetStatistics OR
	        #iUDT_VFDInputs.FromMCStatus1.Running
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_PolisorterInterface.ResetStatistics,
	                        ix_Activate := #iUDT_VFDInputs.FromMCStatus1.Running,
	                        ix_RTrigActivate := #sR_TRIG_Ax1_Running.Q,
	                        iqUDT_Statistics := #iqUDT_VFDStatistics.Ax1Running);
	        
	    END_IF;
	    
	    // Axis 2 running statistics
	    
	    #sR_TRIG_Ax2_Running(CLK := #iqUDT_ConveyorInterface.VFDRunning);
	    
	    IF #iqUDT_PolisorterInterface.ResetStatistics OR
	        #iqUDT_ConveyorInterface.VFDRunning
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_PolisorterInterface.ResetStatistics,
	                        ix_Activate := #iqUDT_ConveyorInterface.VFDRunning,
	                        ix_RTrigActivate := #sR_TRIG_Ax2_Running.Q,
	                        iqUDT_Statistics := #iqUDT_VFDStatistics.Ax2Running);
	        
	    END_IF;
	    
	END_REGION
	
	REGION 10 - Status
	    
	    #qUDT_HMIStatus := #sUDT_HMIStatus;
	    
	END_REGION
	
	REGION 11 - Write interface outputs
	    
	    // Axis 1 internal Error
	    #iqUDT_PolisorterInterface.InternalErrorVFD := #sx_Ax1_ErrorActive;
	    
	    // Axis 1 internal Warning
	    #iqUDT_PolisorterInterface.InternalWarningVFD := #sx_Ax1_WarningActive;
	    
	    // Axis 1 motor running
	    #iqUDT_PolisorterInterface.MotorRunning := #iUDT_VFDInputs.FromMCStatus1.Running;
	    
	    // Axis 1 referenced
	    #iqUDT_PolisorterInterface.Referenced := #iUDT_VFDInputs.FromMCStatus1.Homed;
	    
	    // Axis 1 positioning 
	    #iqUDT_PolisorterInterface.Positioning := #iUDT_VFDInputs."FromMCAx[1]".Positioning
	    AND NOT #iUDT_VFDInputs."FromMCAx[1]".Standstill
	    AND NOT #iUDT_VFDInputs."FromMCAx[1]".Positioned;
	    
	    // Axis 2 actual speed
	    #iqUDT_ConveyorInterface.ActualSpeed := REAL_TO_INT(#sr_Ax2ActualSpeed);
	    
	    // Axis 2 internal Error
	    #iqUDT_ConveyorInterface.InternalErrorVFD := #iUDT_VFDInputs."FromMCAx[2]".Fault;
	    
	    // Axis 2 motor running
	    #iqUDT_ConveyorInterface.VFDRunning := #sr_Ax2ActualSpeed > 0;
	    
	    // Axis 2 at speed
	    #iqUDT_ConveyorInterface.VFDatSpeed := #sr_Ax2ActualSpeed < #iqUDT_ConveyorInterface.SpeedSetpoint + #iUDT_VFDConfiguration.SpeedAxis.SpeedSetpointWindow
	    AND #sr_Ax2ActualSpeed > #iqUDT_ConveyorInterface.SpeedSetpoint - #iUDT_VFDConfiguration.SpeedAxis.SpeedSetpointWindow;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_FedExDecodeUDS"
TITLE = FB_Decode
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : UPS_SpecificCommunication
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 238
// END_ATTRIBUTES
//Function block to decode UPS messages.
   VAR_INPUT 
      iUDT_FacilitySystem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FedExFacility";   // UDS System configuration
      iUDT_FacilityPLC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FedExFacility";   // LLC System configuration
      is_LastHost { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Last connected UDS SystemID
   END_VAR

   VAR_IN_OUT 
      iqUDT_FifoRcvHeader : "UDT_FifoHeader";   // FIFO receive header
      iqs_FifoRcvData : Array[*] of "UDT_Message";   // FIFO receive data
      iqUDT_FifoMedPriorityHLC : "UDT_FifoHeader";   // FIFO UDS send Header
      iqa_FifoMedPriorityHLC : Array[*] of "UDT_Message";   // FIFO UDS send data
      iqUDT_HLCCommands : "UDT_FedExCommands";   // Commands from UDS
      iqUDT_DA : Struct   // Destination assignment message
         NewMessage : Bool;   // New message received from UDS
         Data : "UDT_FedExMessageDaRa";   // Destination assignment message body
      END_STRUCT;
      iqUDT_RA : Struct   // Destination re-assignment message
         NewMessage : Bool;   // New message received from UDS
         Data : "UDT_FedExMessageDaRa";   // Destination re-assignment message body
      END_STRUCT;
      iqUDT_CD : Struct   // Command message
         NewMessage : Bool;   // New message received from UDS
         Data : "UDT_FedExMessageCD";   // Command message body
      END_STRUCT;
      iqUDT_PS : Struct   // Parameters set message
         NewMessage : Bool;   // New message received from UDS
         Data : "UDT_FedExMessagePS";   // Parameters set message body
      END_STRUCT;
      iqUDT_CustomerIDReference : "UDT_FedExCustomerID";
      iqx_SendHB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send heartbeat request
      iqx_ResetListeningTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset listening time in Heartbeat block
      iq_LoginOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Login in UDS ok
   END_VAR

   VAR 
      sFB_FedExLoginResponse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_FedExLoginResponse";   // Login request send
      sUDT_Facillity { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FedExFacility";   // System configuration
      sUDT_MSGHeader { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FedExMessageHeader";   // Message header
      sUDT_FifoMsg { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Message";   // Buffer for fifos message
      sa_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFORcvStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";   // Receive FIFO status structure
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO error
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO warning
         InvalidCommandCode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid command code
         InvalidType { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // Invalid message type
         InvalidParameterID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalig parameter ID
         InvalidLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Received message length is different than programmed
      END_STRUCT;
      st_TimeToSet {InstructionName := 'DTL'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DTL;   // Time received from HLC used to set time in the PLC
      ss_NNNNNN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[6];   // GIN number extracted from Package ID
      ss_SS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[2];   // Maximum frequency of the messages
      ss_SorterNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Sorter number
      ss_DiverterNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Diverter number
      si_GIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Gin number converted from string to int
      si_ChuteNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Chute number to enable/disable purge
      si_SS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum frequency of the messages
      si_i { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Loop counter
      si_PositionOfSpace { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Position of spaces used to remove spaces
      si_MessageLegth { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Received message length
      si_ComValueLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Command value length
      si_SpacePositionComValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Position of spaces used to remove spaces
      si_WriteTimeStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // WR_LOC_T Status
      si_CustomerID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      sx_FacialityCheck { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // When TRUE received faciality configuration is the same as configured in the PLC
      sx_LogOffRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Log off request from UDS
   END_VAR

   VAR_TEMP 
      tx_MsgRead : Bool;   // Message read from FIFO
   END_VAR

   VAR CONSTANT 
      cs_DA : String := 'DA';   // Destination assignment message type
      cs_RA : String := 'RA';   // Destination re-assignment message type
      cs_HB : String := 'HB';   // Heartbeat message type
      cs_LI : String := 'LI';   // Login request message type
      cs_LS : String := 'LS';   // Log-off message type
      cs_CD : String := 'CD';   // Command message type
      cs_PS : String := 'PS';   // Parameter set message type
      ci_SizeDAMessage : Int := 213;   // Destination assignment message length
      ci_SizeRAMessage : Int := 213;   // Destination re-assignment message length
      ci_SizeLIMessage : Int := 35;   // Login request message length
      ci_SizeCDMessage : Int := 113;   // Command message length
      ci_SizePSMessage : Int := 129;   // Parameter set message length
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	22/07/2021  | 1.0       | J.Krawczuk    | first release MHS TIA 15.1
	11/04/2022  | 1.1       | K.Pokorski    | Review 
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #sa_Status.FIFORcvStatus,
	              qx_Error => #sa_Status.FIFOError,
	              qx_Warning => #sa_Status.FIFOWarning,
	              iqv_Data := #sUDT_FifoMsg,
	              iqUDT_FifoHeader := #iqUDT_FifoRcvHeader,
	              iqv_DataBuffer := #iqs_FifoRcvData);
	    
	    IF (NOT #iqUDT_FifoRcvHeader.Status.Empty                             // FIFO not empty 
	        AND NOT #sa_Status.FIFOError)                                      // No FIFO error 
	    THEN
	        
	        // Mode 'R' - Read FIFO record
	        "FC_Fifo"(ic_Mode := 'R',
	                  qUDT_Status => #sa_Status.FIFORcvStatus,
	                  qx_Error => #sa_Status.FIFOError,
	                  qx_Warning => #sa_Status.FIFOWarning,
	                  iqv_Data := #sUDT_FifoMsg,
	                  iqUDT_FifoHeader := #iqUDT_FifoRcvHeader,
	                  iqv_DataBuffer := #iqs_FifoRcvData);
	        
	        // Message read bit set and position initialize 
	        #tx_MsgRead := TRUE;
	        
	        // FIFO empty or FIFO error occured
	    ELSE
	        
	        #tx_MsgRead := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 – Decoding header
	    
	    IF #tx_MsgRead      // New message
	    THEN
	        // Header decode
	        "FC_FedExDecodeHeader"(iUDT_FifoMsg := #sUDT_FifoMsg,
	                               qUDT_MSGHeader => #sUDT_MSGHeader);
	    END_IF;
	END_REGION
	
	REGION 3 - Decoding body
	    
	    IF #tx_MsgRead                                                              // New message
	    THEN
	        #si_MessageLegth := STRING_TO_INT(#sUDT_MSGHeader.MessageLength);      // Convert message length to integer
	        #sa_Status.InvalidType := FALSE;                                        // Invalid type status initialize
	        
	        // Login request message
	        IF #sUDT_MSGHeader.MessageType = #cs_LI
	        THEN
	            
	            // Received message length validation
	            IF #si_MessageLegth = #ci_SizeLIMessage
	            THEN
	                
	                // Faciality ID
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 7,
	                              Cnt := 6,
	                              Strg => #sUDT_Facillity.FacilityID);
	                
	                // System ID
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 13,
	                              Cnt := 15,
	                              Strg => #sUDT_Facillity.SystemID);
	                
	                // Version ID
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 28,
	                              Cnt := 6,
	                              Strg => #sUDT_Facillity.VersionID);
	                
	                // Maximum message frequency
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 34,
	                              Cnt := 2,
	                              Strg => #ss_SS);
	                
	                // Maximum message frequency conversion to integer
	                #si_SS := STRING_TO_INT(#ss_SS);
	                
	                // For loop to remove spaces from Version ID 
	                FOR #si_i := 1 TO 6 DO
	                    
	                    #si_PositionOfSpace := 0;
	                    #si_PositionOfSpace := FIND(IN1 := #sUDT_Facillity.VersionID, IN2 := ' ');
	                    
	                    IF #si_PositionOfSpace > 0
	                    THEN
	                        #sUDT_Facillity.VersionID := DELETE(IN := #sUDT_Facillity.VersionID, L := 1, P := #si_PositionOfSpace);
	                        
	                    END_IF;
	                    
	                END_FOR;
	                
	                // Checking if received facility configuration matches configuration in the PLC
	                #sx_FacialityCheck := #iUDT_FacilitySystem.FacilityID = #sUDT_Facillity.FacilityID
	                AND #iUDT_FacilitySystem.SystemID = #sUDT_Facillity.SystemID
	                AND #iUDT_FacilitySystem.VersionID = #sUDT_Facillity.VersionID
	                AND #iUDT_FacilitySystem.SS = #si_SS;
	                
	                // Login response message send
	                #sFB_FedExLoginResponse(iUDT_Facility := #iUDT_FacilityPLC,
	                                        is_LastHost := #is_LastHost,
	                                        ix_ConnectionStatus := #sx_FacialityCheck,
	                                        iqUDT_FifoHeader := #iqUDT_FifoMedPriorityHLC,
	                                        iqa_FifoData := #iqa_FifoMedPriorityHLC);
	                
	                #iqx_ResetListeningTimer := TRUE;
	                #iq_LoginOK := #sx_FacialityCheck;
	            ELSE
	                
	                // In case when received message length is different than programmed set error
	                #sa_Status.InvalidLength := TRUE;
	                
	            END_IF;
	            
	            // Log-off request message
	        ELSIF #sUDT_MSGHeader.MessageType = #cs_LS
	        THEN
	            #sx_LogOffRequest := TRUE;
	            
	            // Destination assignment message
	        ELSIF #sUDT_MSGHeader.MessageType = #cs_DA
	        THEN
	            
	            // Received message length validation
	            IF #si_MessageLegth = #ci_SizeDAMessage
	            THEN
	                
	                // LLC system ID 
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 7,
	                              Cnt := 15,
	                              Strg => #iqUDT_DA.Data.LLCSystemID);
	                
	                // Package ID 
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 22,
	                              Cnt := 15,
	                              Strg => #iqUDT_DA.Data.PackageID);
	                
	                // High level package ID
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 37,
	                              Cnt := 10,
	                              Strg => #iqUDT_DA.Data.HLCPackageID);
	                
	                // Cell number
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 47,
	                              Cnt := 4,
	                              Strg => #iqUDT_DA.Data.CellNumber);
	                
	                // Destination 1 
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 51,
	                              Cnt := 6,
	                              Strg => #iqUDT_DA.Data.Destination1);
	                
	                // Cut off time destination 1 
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 57,
	                              Cnt := 5,
	                              Strg => #iqUDT_DA.Data.CutOffTimeDestination1);
	                
	                // Destination 2
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 62,
	                              Cnt := 6,
	                              Strg => #iqUDT_DA.Data.Destination2);
	                
	                // Cut off time destination 2
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 68,
	                              Cnt := 5,
	                              Strg => #iqUDT_DA.Data.CutOffTimeDestination2);
	                
	                // Destination 3 
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 73,
	                              Cnt := 6,
	                              Strg => #iqUDT_DA.Data.Destination3);
	                
	                // Cut off time destination 3
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 79,
	                              Cnt := 5,
	                              Strg => #iqUDT_DA.Data.CutOffTimeDestination3);
	                
	                // Destination 4
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 84,
	                              Cnt := 6,
	                              Strg => #iqUDT_DA.Data.Destination4);
	                
	                // Cut off time destination 4
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 90,
	                              Cnt := 5,
	                              Strg => #iqUDT_DA.Data.CutOffTimeDestination4);
	                
	                // Destination 5
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 95,
	                              Cnt := 6,
	                              Strg => #iqUDT_DA.Data.Destination5);
	                
	                // Cut off time destination 5
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 101,
	                              Cnt := 5,
	                              Strg => #iqUDT_DA.Data.CutOffTimeDestination5);
	                
	                // High level data text
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 106,
	                              Cnt := 20,
	                              Strg => #iqUDT_DA.Data.HLCDataText);
	                
	                // Barcode data
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 126,
	                              Cnt := 50,
	                              Strg => #iqUDT_DA.Data.Barcodedata);
	                
	                // Result code
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 176,
	                              Cnt := 16,
	                              Strg => #iqUDT_DA.Data.HLCResultCode);
	                
	                // Timestamp
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 192,
	                              Cnt := 17,
	                              Strg => #iqUDT_DA.Data.Timestamp);
	                
	                // Time zone designator
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 209,
	                              Cnt := 5,
	                              Strg => #iqUDT_DA.Data.TimeZoneDesignator);
	                
	                // Convert 'NNNNNN' part in package ID to GIN number and store data in GIN database
	                #ss_NNNNNN := RIGHT(IN := #iqUDT_DA.Data.PackageID, L := 6);
	                STRG_VAL(IN := #ss_NNNNNN,
	                         FORMAT := 16#0,
	                         P := 1,
	                         OUT => #si_CustomerID);
	                
	                IF #si_CustomerID > 1 AND #si_CustomerID < 999999 THEN
	                    #si_GIN := #iqUDT_CustomerIDReference.CustomerIDReference[#si_CustomerID];
	                END_IF;
	                
	                // Write data from destination assignment message to GIN array 
	                IF #si_GIN > 0
	                    AND #si_GIN <= 9999
	                THEN
	                    
	                    "DB_GIN".GIN[#si_GIN].FedEx.LLCSystemID := #iqUDT_DA.Data.LLCSystemID;
	                    "DB_GIN".GIN[#si_GIN].FedEx.PackageID := #iqUDT_DA.Data.PackageID;
	                    "DB_GIN".GIN[#si_GIN].FedEx.HLCPackageID := #iqUDT_DA.Data.HLCPackageID;
	                    "DB_GIN".GIN[#si_GIN].FedEx.CellNumber := #iqUDT_DA.Data.CellNumber;
	                    "DB_GIN".GIN[#si_GIN].FedEx.Destination1 := #iqUDT_DA.Data.Destination1;
	                    "DB_GIN".GIN[#si_GIN].FedEx.CutOffTimeDestination1 := #iqUDT_DA.Data.CutOffTimeDestination1;
	                    "DB_GIN".GIN[#si_GIN].FedEx.Destination2 := #iqUDT_DA.Data.Destination2;
	                    "DB_GIN".GIN[#si_GIN].FedEx.CutOffTimeDestination2 := #iqUDT_DA.Data.CutOffTimeDestination2;
	                    "DB_GIN".GIN[#si_GIN].FedEx.Destination3 := #iqUDT_DA.Data.Destination3;
	                    "DB_GIN".GIN[#si_GIN].FedEx.CutOffTimeDestination3 := #iqUDT_DA.Data.CutOffTimeDestination3;
	                    "DB_GIN".GIN[#si_GIN].FedEx.Destination4 := #iqUDT_DA.Data.Destination4;
	                    "DB_GIN".GIN[#si_GIN].FedEx.CutOffTimeDestination4 := #iqUDT_DA.Data.CutOffTimeDestination4;
	                    "DB_GIN".GIN[#si_GIN].FedEx.Destination5 := #iqUDT_DA.Data.Destination5;
	                    "DB_GIN".GIN[#si_GIN].FedEx.CutOffTimeDestination5 := #iqUDT_DA.Data.CutOffTimeDestination5;
	                    "DB_GIN".GIN[#si_GIN].FedEx.HLCDataText := #iqUDT_DA.Data.HLCDataText;
	                    "DB_GIN".GIN[#si_GIN].FedEx.Barcodedata := #iqUDT_DA.Data.Barcodedata;
	                    "DB_GIN".GIN[#si_GIN].FedEx.HLCResultCode := #iqUDT_DA.Data.HLCResultCode;
	                    "DB_GIN".GIN[#si_GIN].FedEx.Timestamp := #iqUDT_DA.Data.Timestamp;
	                    "DB_GIN".GIN[#si_GIN].FedEx.TimeZoneDesignator := #iqUDT_DA.Data.TimeZoneDesignator;
	                    
	                    "DB_GIN".GIN[#si_GIN].General.Destination[0] := STRING_TO_DINT(#iqUDT_DA.Data.Destination1);
	                    "DB_GIN".GIN[#si_GIN].General.Destination[1] := STRING_TO_DINT(#iqUDT_DA.Data.Destination2);
	                    "DB_GIN".GIN[#si_GIN].General.Destination[2] := STRING_TO_DINT(#iqUDT_DA.Data.Destination3);
	                    "DB_GIN".GIN[#si_GIN].General.Destination[3] := STRING_TO_DINT(#iqUDT_DA.Data.Destination4);
	                    "DB_GIN".GIN[#si_GIN].General.Destination[4] := STRING_TO_DINT(#iqUDT_DA.Data.Destination5);
	                    
	                    #iqUDT_DA.NewMessage := TRUE;
	                    #iqx_ResetListeningTimer := TRUE;
	                    
	                END_IF;
	            ELSE
	                // In case when received message length is different than programmed set error
	                #sa_Status.InvalidLength := TRUE;
	                
	            END_IF;
	            
	            // Destination re-assignment message
	        ELSIF #sUDT_MSGHeader.MessageType = #cs_RA
	        THEN
	            
	            // Received message length validation
	            IF #si_MessageLegth = #ci_SizeRAMessage
	            THEN
	                
	                // LLC system ID
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 7,
	                              Cnt := 15,
	                              Strg => #iqUDT_RA.Data.LLCSystemID);
	                
	                // Package ID 
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 22,
	                              Cnt := 15,
	                              Strg => #iqUDT_RA.Data.PackageID);
	                
	                // High level package ID
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 37,
	                              Cnt := 10,
	                              Strg => #iqUDT_RA.Data.HLCPackageID);
	                
	                // Cell number
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 47,
	                              Cnt := 4,
	                              Strg => #iqUDT_RA.Data.CellNumber);
	                
	                // Destination 1 
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 51,
	                              Cnt := 6,
	                              Strg => #iqUDT_RA.Data.Destination1);
	                
	                // Cut off time destination 1
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 57,
	                              Cnt := 5,
	                              Strg => #iqUDT_RA.Data.CutOffTimeDestination1);
	                
	                // Destination 2
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 62,
	                              Cnt := 6,
	                              Strg => #iqUDT_RA.Data.Destination2);
	                
	                // Cut off time destination 2
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 68,
	                              Cnt := 5,
	                              Strg => #iqUDT_RA.Data.CutOffTimeDestination2);
	                
	                // Destination 3
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 73,
	                              Cnt := 6,
	                              Strg => #iqUDT_RA.Data.Destination3);
	                
	                // Cut off time destination 3
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 79,
	                              Cnt := 5,
	                              Strg => #iqUDT_RA.Data.CutOffTimeDestination3);
	                
	                // Destination 4
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 84,
	                              Cnt := 6,
	                              Strg => #iqUDT_RA.Data.Destination4);
	                
	                // Cut off time destination 4
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 90,
	                              Cnt := 5,
	                              Strg => #iqUDT_RA.Data.CutOffTimeDestination4);
	                
	                // Destination 5
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 95,
	                              Cnt := 6,
	                              Strg => #iqUDT_RA.Data.Destination5);
	                
	                // Cut off time destination 5
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 101,
	                              Cnt := 5,
	                              Strg => #iqUDT_RA.Data.CutOffTimeDestination5);
	                
	                // High level data text
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 106,
	                              Cnt := 20,
	                              Strg => #iqUDT_RA.Data.HLCDataText);
	                
	                // Barcode data
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 126,
	                              Cnt := 50,
	                              Strg => #iqUDT_RA.Data.Barcodedata);
	                
	                // Result code
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 176,
	                              Cnt := 16,
	                              Strg => #iqUDT_RA.Data.HLCResultCode);
	                
	                // Timestamp
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 192,
	                              Cnt := 17,
	                              Strg => #iqUDT_RA.Data.Timestamp);
	                
	                // Time zone designator
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 209,
	                              Cnt := 5,
	                              Strg => #iqUDT_RA.Data.TimeZoneDesignator);
	                
	                // Convert 'NNNNNN' part in package ID to GIN number and store data in GIN database
	                #ss_NNNNNN := RIGHT(IN := #iqUDT_RA.Data.PackageID, L := 6);
	                STRG_VAL(IN := #ss_NNNNNN,
	                         FORMAT := 16#0,
	                         P := 1,
	                         OUT => #si_CustomerID);
	                
	                IF #si_CustomerID > 1 AND #si_CustomerID < 999999 THEN
	                    #si_GIN := #iqUDT_CustomerIDReference.CustomerIDReference[#si_CustomerID];
	                END_IF;
	                
	                // Write data from destination assignment message to GIN array 
	                IF #si_GIN > 0
	                    AND #si_GIN <= 9999
	                THEN
	                    "DB_GIN".GIN[#si_GIN].FedEx.LLCSystemID := #iqUDT_RA.Data.LLCSystemID;
	                    "DB_GIN".GIN[#si_GIN].FedEx.PackageID := #iqUDT_RA.Data.PackageID;
	                    "DB_GIN".GIN[#si_GIN].FedEx.HLCPackageID := #iqUDT_RA.Data.HLCPackageID;
	                    "DB_GIN".GIN[#si_GIN].FedEx.CellNumber := #iqUDT_RA.Data.CellNumber;
	                    "DB_GIN".GIN[#si_GIN].FedEx.Destination1 := #iqUDT_RA.Data.Destination1;
	                    "DB_GIN".GIN[#si_GIN].FedEx.CutOffTimeDestination1 := #iqUDT_RA.Data.CutOffTimeDestination1;
	                    "DB_GIN".GIN[#si_GIN].FedEx.Destination2 := #iqUDT_RA.Data.Destination2;
	                    "DB_GIN".GIN[#si_GIN].FedEx.CutOffTimeDestination2 := #iqUDT_RA.Data.CutOffTimeDestination2;
	                    "DB_GIN".GIN[#si_GIN].FedEx.Destination3 := #iqUDT_RA.Data.Destination3;
	                    "DB_GIN".GIN[#si_GIN].FedEx.CutOffTimeDestination3 := #iqUDT_RA.Data.CutOffTimeDestination3;
	                    "DB_GIN".GIN[#si_GIN].FedEx.Destination4 := #iqUDT_RA.Data.Destination4;
	                    "DB_GIN".GIN[#si_GIN].FedEx.CutOffTimeDestination4 := #iqUDT_RA.Data.CutOffTimeDestination4;
	                    "DB_GIN".GIN[#si_GIN].FedEx.Destination5 := #iqUDT_RA.Data.Destination5;
	                    "DB_GIN".GIN[#si_GIN].FedEx.CutOffTimeDestination5 := #iqUDT_RA.Data.CutOffTimeDestination5;
	                    "DB_GIN".GIN[#si_GIN].FedEx.HLCDataText := #iqUDT_RA.Data.HLCDataText;
	                    "DB_GIN".GIN[#si_GIN].FedEx.Barcodedata := #iqUDT_RA.Data.Barcodedata;
	                    "DB_GIN".GIN[#si_GIN].FedEx.HLCResultCode := #iqUDT_RA.Data.HLCResultCode;
	                    "DB_GIN".GIN[#si_GIN].FedEx.Timestamp := #iqUDT_RA.Data.Timestamp;
	                    "DB_GIN".GIN[#si_GIN].FedEx.TimeZoneDesignator := #iqUDT_RA.Data.TimeZoneDesignator;
	                    
	                    "DB_GIN".GIN[#si_GIN].General.Destination[0] := STRING_TO_DINT(#iqUDT_RA.Data.Destination1);
	                    "DB_GIN".GIN[#si_GIN].General.Destination[1] := STRING_TO_DINT(#iqUDT_RA.Data.Destination2);
	                    "DB_GIN".GIN[#si_GIN].General.Destination[2] := STRING_TO_DINT(#iqUDT_RA.Data.Destination3);
	                    "DB_GIN".GIN[#si_GIN].General.Destination[3] := STRING_TO_DINT(#iqUDT_RA.Data.Destination4);
	                    "DB_GIN".GIN[#si_GIN].General.Destination[4] := STRING_TO_DINT(#iqUDT_RA.Data.Destination5);
	                    
	                    #iqUDT_RA.NewMessage := TRUE;
	                    #iqx_ResetListeningTimer := TRUE;
	                    
	                END_IF;
	                
	            ELSE
	                // In case when received message length is different than programmed set error
	                #sa_Status.InvalidLength := TRUE;
	                
	            END_IF;
	            
	            // Command message    
	        ELSIF #sUDT_MSGHeader.MessageType = #cs_CD
	        THEN
	            // Received message length validation
	            IF #si_MessageLegth = #ci_SizeCDMessage
	            THEN
	                // Invalid command code initialization
	                #sa_Status.InvalidCommandCode := FALSE;
	                
	                // Command code
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 7,
	                              Cnt := 3,
	                              Strg => #iqUDT_CD.Data.CommandCode);
	                
	                // Command value
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 10,
	                              Cnt := 82,
	                              Strg => #iqUDT_CD.Data.CommandValue);
	                
	                // Timestamp
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 92,
	                              Cnt := 17,
	                              Strg => #iqUDT_CD.Data.Timestamp);
	                
	                // Time zone designator
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 109,
	                              Cnt := 5,
	                              Strg => #iqUDT_CD.Data.TimeZoneDesignator);
	                
	                #iqUDT_CD.NewMessage := TRUE;
	                #iqx_ResetListeningTimer := TRUE;
	                
	                // Start of sort command
	                IF #iqUDT_CD.Data.CommandCode = '001'
	                THEN
	                    #iqUDT_HLCCommands.StartSort.StartSort := TRUE;
	                    #iqUDT_HLCCommands.EndSort.EndSort := FALSE;
	                    #iqUDT_HLCCommands.StartSort.NewMessage := TRUE;
	                    
	                    // End of sort command
	                ELSIF #iqUDT_CD.Data.CommandCode = '002'
	                THEN
	                    #iqUDT_HLCCommands.StartSort.StartSort := FALSE;
	                    #iqUDT_HLCCommands.EndSort.EndSort := TRUE;
	                    #iqUDT_HLCCommands.EndSort.NewMessage := TRUE;
	                    // Upload chute status command
	                ELSIF #iqUDT_CD.Data.CommandCode = '003'
	                THEN
	                    #iqUDT_HLCCommands.UploadChuteStatus.NewMessage := TRUE;
	                    
	                    // Upload all equipment status command
	                ELSIF #iqUDT_CD.Data.CommandCode = '004'
	                THEN
	                    #iqUDT_HLCCommands.UploadAllStatus.NewMessage := TRUE;
	                    
	                    // Block diverter automated smalls
	                ELSIF #iqUDT_CD.Data.CommandCode = '005'
	                THEN
	                    #ss_SorterNumber := MID(IN := #iqUDT_CD.Data.CommandValue, L := 5, P := 3);
	                    #ss_DiverterNumber := MID(IN := #iqUDT_CD.Data.CommandValue, L := 6, P := 8);
	                    #iqUDT_HLCCommands.BlockDivertSmalls.SorterNumber := (#ss_SorterNumber);
	                    #iqUDT_HLCCommands.BlockDivertSmalls.DivertNumber := (#ss_DiverterNumber);
	                    
	                    // Unblock diverter automated smalls
	                ELSIF #iqUDT_CD.Data.CommandCode = '006'
	                THEN
	                    
	                    #ss_SorterNumber := MID(IN := #iqUDT_CD.Data.CommandValue, L := 5, P := 3);
	                    #ss_DiverterNumber := MID(IN := #iqUDT_CD.Data.CommandValue, L := 6, P := 8);
	                    #iqUDT_HLCCommands.UnblockDivertSmalls.SorterNumber := (#ss_SorterNumber);
	                    #iqUDT_HLCCommands.UnblockDivertSmalls.DivertNumber := (#ss_DiverterNumber);
	                    
	                    // Chute purge enable
	                ELSIF #iqUDT_CD.Data.CommandCode = '007'
	                THEN
	                    
	                    // Removing spaces from caommand value
	                    FOR #si_i := 1 TO 82 DO
	                        
	                        #si_SpacePositionComValue := FIND(IN1 := #iqUDT_CD.Data.CommandValue, IN2 := ' ');
	                        IF #si_SpacePositionComValue <> 0
	                        THEN
	                            #iqUDT_CD.Data.CommandValue := DELETE(IN := #iqUDT_CD.Data.CommandValue, L := 1, P := #si_SpacePositionComValue);
	                            
	                        END_IF;
	                        
	                    END_FOR;
	                    
	                    #iqUDT_HLCCommands.EnablePurge.PLC := LEFT(IN := #iqUDT_CD.Data.CommandValue, L := 6);
	                    #iqUDT_CD.Data.CommandValue := DELETE(IN := #iqUDT_CD.Data.CommandValue, L := 6, P := 1);
	                    #si_ComValueLen := LEN(#iqUDT_CD.Data.CommandValue);
	                    
	                    // Extracting up to 5 chute numbers to enable purge
	                    IF #si_ComValueLen MOD 6 = 0 AND #si_ComValueLen <= 30
	                    THEN
	                        
	                        #si_ChuteNumber := 0;
	                        
	                        FOR #si_i := (#si_ComValueLen / 6) TO 1 BY -1 DO
	                            
	                            #si_ChuteNumber += 1;
	                            
	                            #iqUDT_HLCCommands.EnablePurge.Chute[#si_ChuteNumber] := (LEFT(IN := #iqUDT_CD.Data.CommandValue, L := 6));
	                            #iqUDT_CD.Data.CommandValue := DELETE(IN := #iqUDT_CD.Data.CommandValue, L := 6, P := 1);
	                            
	                        END_FOR;
	                        
	                    END_IF;
	                    
	                    // Chute purge disable    
	                ELSIF #iqUDT_CD.Data.CommandCode = '008'
	                THEN
	                    // Removing spaces from caommand value
	                    FOR #si_i := 1 TO 82 DO
	                        
	                        #si_SpacePositionComValue := FIND(IN1 := #iqUDT_CD.Data.CommandValue, IN2 := ' ');
	                        IF #si_SpacePositionComValue <> 0
	                        THEN
	                            #iqUDT_CD.Data.CommandValue := DELETE(IN := #iqUDT_CD.Data.CommandValue, L := 1, P := #si_SpacePositionComValue);
	                            
	                        END_IF;
	                        
	                    END_FOR;
	                    
	                    #iqUDT_HLCCommands.DisablePurge.PLC := LEFT(IN := #iqUDT_CD.Data.CommandValue, L := 6);
	                    #iqUDT_CD.Data.CommandValue := DELETE(IN := #iqUDT_CD.Data.CommandValue, L := 6, P := 1);
	                    #si_ComValueLen := LEN(#iqUDT_CD.Data.CommandValue);
	                    
	                    // Extracting up to 5 chute numbers to disable purge
	                    IF #si_ComValueLen MOD 6 = 0
	                    THEN
	                        
	                        #si_ChuteNumber := 0;
	                        
	                        FOR #si_i := (#si_ComValueLen / 6) - 1 TO 1 BY -1 DO
	                            
	                            #si_ChuteNumber += 1;
	                            
	                            #iqUDT_HLCCommands.DisablePurge.Chute[#si_ChuteNumber] := (LEFT(IN := #iqUDT_CD.Data.CommandValue, L := 6));
	                            #iqUDT_CD.Data.CommandValue := DELETE(IN := #iqUDT_CD.Data.CommandValue, L := 6, P := 1);
	                            
	                        END_FOR;
	                        
	                    END_IF;
	                    
	                    // Lamp control
	                ELSIF #iqUDT_CD.Data.CommandCode = '009'
	                THEN
	                    
	                    #iqUDT_HLCCommands.ChuteLamp.ChuteNumber := (LEFT(IN := #iqUDT_CD.Data.CommandValue, L := 6));
	                    #iqUDT_HLCCommands.ChuteLamp.Mode := (MID(IN := #iqUDT_CD.Data.CommandValue, L := 1, P := 7));
	                    #iqUDT_HLCCommands.ChuteLamp.Color := (MID(IN := #iqUDT_CD.Data.CommandValue, L := 9, P := 8));
	                    
	                ELSE
	                    // In case when received command is different than programmed set error
	                    #sa_Status.InvalidCommandCode := TRUE;
	                    
	                END_IF;
	                
	                //    #q_UDT_HLCCommands := #s_UDT_HLCCommands;
	                
	            ELSE
	                // In case when received message length is different than programmed set error
	                #sa_Status.InvalidLength := TRUE;
	                
	            END_IF;
	            
	            // Parameter set message    
	        ELSIF #sUDT_MSGHeader.MessageType = #cs_PS
	        THEN
	            
	            // Received message length validation
	            IF #si_MessageLegth = #ci_SizePSMessage
	            THEN
	                
	                // System ID
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 7,
	                              Cnt := 15,
	                              Strg => #iqUDT_PS.Data.SystemID);
	                
	                // Parameter ID
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 22,
	                              Cnt := 4,
	                              Strg => #iqUDT_PS.Data.ParameterID);
	                
	                // Parameter value
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 26,
	                              Cnt := 82,
	                              Strg => #iqUDT_PS.Data.ParameterValue);
	                
	                // Timestamp
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 108,
	                              Cnt := 17,
	                              Strg => #iqUDT_PS.Data.Timestamp);
	                
	                // Time zone designator
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 125,
	                              Cnt := 5,
	                              Strg => #iqUDT_PS.Data.TimeZoneDesignator);
	                
	                #iqUDT_PS.NewMessage := TRUE;
	                #iqx_ResetListeningTimer := TRUE;
	                
	                // Set time parameter
	                IF #iqUDT_PS.Data.ParameterID = 'TIME'
	                THEN
	                    // Invalid parameter ID initialization
	                    #sa_Status.InvalidParameterID := FALSE;
	                    
	                    // Converting received date and time to DTL format
	                    #st_TimeToSet.YEAR := STRING_TO_UINT(LEFT(IN := #iqUDT_PS.Data.ParameterValue, L := 4));
	                    #st_TimeToSet.MONTH := STRING_TO_USINT(MID(IN := #iqUDT_PS.Data.ParameterValue, L := 2, P := 5));
	                    #st_TimeToSet.DAY := STRING_TO_USINT(MID(IN := #iqUDT_PS.Data.ParameterValue, L := 2, P := 7));
	                    #st_TimeToSet.HOUR := STRING_TO_USINT(MID(IN := #iqUDT_PS.Data.ParameterValue, L := 2, P := 9));
	                    #st_TimeToSet.MINUTE := STRING_TO_USINT(MID(IN := #iqUDT_PS.Data.ParameterValue, L := 2, P := 11));
	                    #st_TimeToSet.SECOND := STRING_TO_USINT(MID(IN := #iqUDT_PS.Data.ParameterValue, L := 2, P := 13));
	                    #st_TimeToSet.NANOSECOND := 0;
	                    
	                    // Set time in the PLC
	                    #si_WriteTimeStatus := WR_LOC_T(LOCTIME := #st_TimeToSet, DST := FALSE);
	                    
	                ELSE
	                    // In case when received parameter ID is different than programmed set error
	                    #sa_Status.InvalidParameterID := TRUE;
	                    
	                END_IF;
	                
	            ELSE
	                // In case when received message length is different than programmed set error
	                #sa_Status.InvalidLength := TRUE;
	                
	            END_IF;
	            
	            // Heartbeat message
	        ELSIF #sUDT_MSGHeader.MessageType = #cs_HB
	        THEN
	            
	            #iqx_SendHB := TRUE;
	            
	            
	        ELSE
	            // In case when received message type is different than programmed set error
	            #sa_Status.InvalidType := TRUE;
	            
	        END_IF;
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_FedExDestinationLookupMessage"
TITLE = FB_Heartbeat
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : UPS_SpecificCommunication
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 67
// END_ATTRIBUTES
//Function block to send and monitor the UPS heartbeat message.
   VAR_INPUT 
      iUDT_Facility { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FedExFacility";   // System configuration
      is_LOConEquipment { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[3];   // Location of the equipment
      is_DEPCOD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[6];   // Depot Code
      is_TYPofEquipment { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[3];   // Type of equipment
      is_NumberOfTheEquipment { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[3];   // Number of the equipment 001-999
      is_TrayCellNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[3];   // Tray/Cell number (for loop sorters) or generated by LLC (on line sorters).
      is_SorterNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[2];   // Sorter number
      is_InductionNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[2];   // Induction number
      is_AreaNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[2];   // Area number
      ii_Gin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // GIN number
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Error
   END_VAR

   VAR_IN_OUT 
      iqUDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqa_FifoData : Array[*] of "UDT_Message";   // FIFO data
      iqx_UnexpectedDLReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR 
      sUDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Message";   // Message character array
      sa_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";   // FIFO status structure
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO data buffer full
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO error
         InvalidGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Invalid GIN
         InvalidMessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Calculated message length is different than required
         InvalidMsgArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Length of the message is bigger than length of message array
      END_STRUCT;
      sa_Statistics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Statistics structure
         NotSentWrongMsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // COMISSIONING PURPOSE Messages not sent because built message length does not match with required message length
      END_STRUCT;
      ss_LLCSystemID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[15];   // Identifier of Low-Level controls
      ss_SequencialID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[6];   // Identifier of Low-Level controls
      ss_MessageP1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Message character string part 1
      ss_MessageP2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Message character string part 2
      ss_PackageID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[15];   // Identifier of Low-Level controls
      ss_Gap { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[3];   // Gap converted to string
      sui_MsgArrayElNr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Invalid message array size
      sui_ArrayOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Offset for writing in the array
      si_OldGin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Previous Gin
      si_StringLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length of string used in loops to pad string with spaces or 0
      si_LenFillLoop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Loop couter
      si_MaxMsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum message length
      si_MsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // String character message length
      sx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR CONSTANT 
      cc_NULL : Char := '$00';   // NULL sign
      cc_STX : Char := '$02';   // Start of the text
      cc_ETX : Char := '$03';   // End of the text
      cs_Length : String := '0407';   // Legth of the message
      cs_MessageType : String := 'DL';   // Message type
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	29/06/2021  | 1.0       | F.Baten       | first release MHS TIA 16.0
	04/08/2021  | 1.1       | J.Krawczuk    | Updating comments, changing message length
	10/11/2021  | 1.2       | M.Piela       | Updating regions numbering and interface changes
	05/04/2022  | 1.3       | K.Pokorski    | Review
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #sa_Status.FIFOStatus,
	              qx_Error => #sa_Status.FIFOError,
	              qx_Warning => #sa_Status.FIFOWarning,
	              iqv_Data := #sUDT_MessageArray,
	              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	              iqv_DataBuffer := #iqa_FifoData);
	END_REGION
	
	REGION 2 - GIN validation
	    
	    // GIN validation
	    #sa_Status.InvalidGIN :=
	    #ii_Gin < 1
	    OR #ii_Gin > 9999;
	    
	END_REGION
	
	REGION 3 – Message preparation
	    IF NOT #iqUDT_FifoHeader.Status.Full                       // FIFO isn't full
	        AND NOT #sa_Status.InvalidGIN
	        AND #ii_Gin <> #si_OldGin
	    THEN
	        
	        REGION 3.1 - Sequential  ID
	            // ss_SequencialID character string clearing
	            #ss_SequencialID := '';
	            // ss_SequencialID integer input conversion to a character string
	            VAL_STRG(IN := "DB_GIN".GIN[#ii_Gin].FedEx.CustomerID,
	                     SIZE := 0,
	                     PREC := 0,
	                     FORMAT := 0,
	                     P := 1,
	                     OUT => #ss_SequencialID);
	            // Length of the ss_SequencialID character string 
	            #si_StringLen := LEN(#ss_SequencialID);
	            
	            // ss_SequencialID character string leading zeros addition
	            IF (#si_StringLen < 6)
	            THEN
	                FOR #si_LenFillLoop := 1 TO 6 - #si_StringLen DO
	                    #ss_SequencialID := CONCAT(IN1 := '0',
	                                               IN2 := #ss_SequencialID);
	                END_FOR;
	            END_IF;
	        END_REGION
	        
	        REGION 3.2 LLC System ID
	            // Build LLC Syatem ID  
	            #ss_LLCSystemID := CONCAT(IN1 := #is_DEPCOD,
	                                      IN2 := #is_LOConEquipment,
	                                      IN3 := #is_TYPofEquipment,
	                                      IN4 := #is_NumberOfTheEquipment);
	            
	        END_REGION
	        
	        REGION 3.3 - Package ID
	            // Build Package ID  
	            #ss_PackageID := CONCAT(IN1 := #is_TrayCellNumber,
	                                    IN2 := #is_SorterNumber,
	                                    IN3 := #is_InductionNumber,
	                                    IN4 := #is_AreaNumber,
	                                    IN5 := #ss_SequencialID);
	        END_REGION
	        
	        REGION 3.4 - Gap
	            // Gap character string clearing
	            #ss_Gap := '';
	            
	            IF ("DB_GIN".GIN[#ii_Gin].General.LeadingGap > 999)
	            THEN
	                #ss_Gap := '999';
	            ELSE
	                
	                // Gap integer input conversion to a character string
	                VAL_STRG(IN := "DB_GIN".GIN[#ii_Gin].General.LeadingGap,
	                         SIZE := 0,
	                         PREC := 0,
	                         FORMAT := 0,
	                         P := 1,
	                         OUT => #ss_Gap);
	                // Length of the gap character string 
	                #si_StringLen := LEN(#ss_Gap);
	                // Gap character string leading zeros addition
	                IF (#si_StringLen < 3)
	                THEN
	                    FOR #si_LenFillLoop := 1 TO 3 - #si_StringLen DO
	                        #ss_Gap := CONCAT(IN1 := '0',
	                                          IN2 := #ss_Gap);
	                    END_FOR;
	                    
	                END_IF;
	                
	            END_IF;
	            
	            
	        END_REGION
	        
	        IF NOT #sa_Status.FIFOError                   // No FIFO error
	        THEN
	            REGION 3.5 – Message preparation
	                
	                // Message composing according to the structure: STX,message body,ETX
	                #ss_MessageP1 := CONCAT(IN1 := #cc_STX,
	                                        IN2 := #cs_Length,
	                                        IN3 := #cs_MessageType,
	                                        IN4 := #ss_LLCSystemID,
	                                        IN5 := "DB_GIN".GIN[#ii_Gin].FedEx.ADCSystemID,
	                                        IN6 := "DB_GIN".GIN[#ii_Gin].FedEx.ImageID,
	                                        IN7 := #ss_PackageID,
	                                        IN8 := "DB_GIN".GIN[#ii_Gin].FedEx.HLCPackageID,
	                                        IN9 := "DB_GIN".GIN[#ii_Gin].FedEx.DIMSystemID,
	                                        IN10 := "DB_GIN".GIN[#ii_Gin].FedEx.DIMStatus,
	                                        IN11 := "DB_GIN".GIN[#ii_Gin].FedEx.PackageDimLength,
	                                        IN12 := "DB_GIN".GIN[#ii_Gin].FedEx.PackageDimWidth,
	                                        IN13 := "DB_GIN".GIN[#ii_Gin].FedEx.PackageDimHeight,
	                                        IN14 := #ss_Gap,
	                                        IN15 := "DB_GIN".GIN[#ii_Gin].FedEx.DIMUOM,
	                                        IN16 := "DB_GIN".GIN[#ii_Gin].FedEx.DimLFTstatusCode,
	                                        IN17 := "DB_GIN".GIN[#ii_Gin].FedEx.AlibiDims,
	                                        IN18 := "DB_GIN".GIN[#ii_Gin].FedEx.SCLSystemID,
	                                        IN19 := "DB_GIN".GIN[#ii_Gin].FedEx.SCLStatus,
	                                        IN20 := "DB_GIN".GIN[#ii_Gin].FedEx.SCLWT,
	                                        IN21 := "DB_GIN".GIN[#ii_Gin].FedEx.SCLWTUOM,
	                                        IN22 := "DB_GIN".GIN[#ii_Gin].FedEx.SCLLFTStatusCode,
	                                        IN23 := "DB_GIN".GIN[#ii_Gin].FedEx.AlibiWeight,
	                                        IN24 := "DB_GIN".GIN[#ii_Gin].FedEx.CellNumber,
	                                        IN25 := "DB_GIN".GIN[#ii_Gin].FedEx.CellsOccupied,
	                                        IN26 := "DB_Time".Timestamp,
	                                        IN27 := #iUDT_Facility.TimeZoneDesignator);
	                
	                #ss_MessageP2 := CONCAT(IN1 := "DB_GIN".GIN[#ii_Gin].FedEx.PackageDataTruncated,
	                                        IN2 := "DB_GIN".GIN[#ii_Gin].FedEx.TotalBarcodeDataLength,
	                                        IN3 := "DB_GIN".GIN[#ii_Gin].FedEx.Barcode1Identification,
	                                        IN4 := "DB_GIN".GIN[#ii_Gin].FedEx.Barcode1status,
	                                        IN5 := "DB_GIN".GIN[#ii_Gin].FedEx.Barcode1datalength,
	                                        IN6 := "DB_GIN".GIN[#ii_Gin].FedEx.Barcode1data,
	                                        IN7 := "DB_GIN".GIN[#ii_Gin].FedEx.Barcode2Identification,
	                                        IN8 := "DB_GIN".GIN[#ii_Gin].FedEx.Barcode2status,
	                                        IN9 := "DB_GIN".GIN[#ii_Gin].FedEx.Barcode2datalength,
	                                        IN10 := "DB_GIN".GIN[#ii_Gin].FedEx.Barcode2data,
	                                        IN11 := "DB_GIN".GIN[#ii_Gin].FedEx.Barcode3Identification,
	                                        IN12 := "DB_GIN".GIN[#ii_Gin].FedEx.Barcode3status,
	                                        IN13 := "DB_GIN".GIN[#ii_Gin].FedEx.Barcode3datalength,
	                                        IN14 := "DB_GIN".GIN[#ii_Gin].FedEx.Barcode3data,
	                                        IN15 := #cc_ETX);
	                
	            END_REGION
	            
	            REGION 3.6 – Maximum number of the message characters
	                
	                #si_MaxMsgLen := "FC_GetNrOfArrayEl"(iv_Array := #sUDT_MessageArray.Character);
	                
	            END_REGION
	            
	            REGION 3.7 – Length of the complete message
	                
	                #si_MsgLen := LEN(#ss_MessageP1) + LEN(#ss_MessageP2);
	                
	                // Message length validation
	                #sa_Status.InvalidMessageLength := #si_MsgLen - 2 <> STRING_TO_INT(#cs_Length);
	                
	            END_REGION
	            
	            REGION 3.8 –  Message array size validation
	                
	                #sa_Status.InvalidMsgArraySize := #si_MsgLen > #si_MaxMsgLen;
	                
	            END_REGION
	            
	            REGION 3.9 –  Message character string conversion to a message array of characters
	                
	                IF (NOT #sa_Status.InvalidMsgArraySize)     // Message character array size is valid 
	                THEN
	                    
	                    Strg_TO_Chars(Strg := #ss_MessageP1,
	                                  pChars := 0,
	                                  Cnt => #sui_ArrayOffset,
	                                  Chars := #sUDT_MessageArray.Character);
	                    
	                    Strg_TO_Chars(Strg := #ss_MessageP2,
	                                  pChars := #sui_ArrayOffset,
	                                  Cnt => #sui_MsgArrayElNr,
	                                  Chars := #sUDT_MessageArray.Character);
	                    
	                END_IF;
	                
	            END_REGION
	            
	            REGION 3.10 – Clearing remaining characters in the message character array
	                
	                IF (NOT #sa_Status.InvalidMsgArraySize)     // Message character array size is valid 
	                THEN
	                    
	                    // Filling up not used message character array elements with '$00' (ASCII - 16#00)
	                    FILL_BLK(IN := #cc_NULL,                                                                             // Fill not used message char array elements with '$00' 
	                             COUNT := UINT_TO_ULINT(INT_TO_UINT(#si_MaxMsgLen) - #sui_MsgArrayElNr - #sui_ArrayOffset),
	                             OUT => #sUDT_MessageArray.Character[#sui_MsgArrayElNr + #sui_ArrayOffset]);
	                    
	                END_IF;
	                
	            END_REGION
	            
	            REGION 3.11 – Message write into a FIFO register
	                
	                IF NOT #sa_Status.InvalidMsgArraySize           // Message character array size is valid 
	                    AND NOT #sa_Status.InvalidMessageLength     // Message length is valid
	                THEN
	                    
	                    // Mode 'W' - Write FIFO record
	                    "FC_Fifo"(ic_Mode := 'W',
	                              qUDT_Status => #sa_Status.FIFOStatus,
	                              qx_Error => #sa_Status.FIFOError,
	                              qx_Warning => #sa_Status.FIFOWarning,
	                              iqv_Data := #sUDT_MessageArray,
	                              
	                              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                              iqv_DataBuffer := #iqa_FifoData);
	                    
	                ELSE
	                    // Increase counter messages not sent because of wrong message length 
	                    #sa_Statistics.NotSentWrongMsgLen += 1;
	                    
	                END_IF;
	                
	            END_REGION
	            #si_OldGin := #ii_Gin;
	            
	            
	        END_IF;
	        
	        // In case of FIFO full, the FIFO full error bit and FIFO collective error bit are set
	    ELSE
	        #sa_Status.FIFOError := TRUE;
	        #sa_Status.FIFOStatus.FifoFull := TRUE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Writing outputs
	    
	    #sx_Error := #sa_Status.InvalidMessageLength        // Invalid message length
	    OR #sa_Status.InvalidGIN                            // Invalid GIN 
	    OR #sa_Status.InvalidMsgArraySize                   // Invalid message array size 
	    OR #sa_Status.FIFOError;                            // FIFO error
	    
	END_REGION
	
	REGION 5 Unexpected DL Request
	    
	    IF #iqx_UnexpectedDLReq THEN
	        REGION 5.1 – FIFO header status update
	            
	            // Mode 'S' - FIFO register status update
	            "FC_Fifo"(ic_Mode := 'S',
	                      qUDT_Status => #sa_Status.FIFOStatus,
	                      qx_Error => #sa_Status.FIFOError,
	                      qx_Warning => #sa_Status.FIFOWarning,
	                      iqv_Data := #sUDT_MessageArray,
	                      iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                      iqv_DataBuffer := #iqa_FifoData);
	        END_REGION
	        
	        REGION 5.2 – Message preparation
	            IF NOT #iqUDT_FifoHeader.Status.Full                       // FIFO isn't full
	            THEN
	                
	                REGION Sequential  ID
	                    // ss_SequencialID character string clearing
	                    #ss_SequencialID := '';
	                    // ss_SequencialID integer input conversion to a character string
	                    VAL_STRG(IN := "DB_ExternalGIN".UnexpectedSI.FedEx.CustomerID,
	                             SIZE := 0,
	                             PREC := 0,
	                             FORMAT := 0,
	                             P := 1,
	                             OUT => #ss_SequencialID);
	                    // Length of the ss_SequencialID character string 
	                    #si_StringLen := LEN(#ss_SequencialID);
	                    
	                    // ss_SequencialID character string leading zeros addition
	                    IF (#si_StringLen < 6)
	                    THEN
	                        FOR #si_LenFillLoop := 1 TO 6 - #si_StringLen DO
	                            #ss_SequencialID := CONCAT(IN1 := '0',
	                                                       IN2 := #ss_SequencialID);
	                        END_FOR;
	                    END_IF;
	                END_REGION
	                
	                REGION LLC System ID
	                    // Build LLC Syatem ID  
	                    #ss_LLCSystemID := CONCAT(IN1 := #is_DEPCOD,
	                                              IN2 := #is_LOConEquipment,
	                                              IN3 := #is_TYPofEquipment,
	                                              IN4 := #is_NumberOfTheEquipment);
	                    
	                END_REGION
	                
	                REGION Package ID
	                    // Build Package ID  
	                    #ss_PackageID := CONCAT(IN1 := #is_TrayCellNumber,
	                                            IN2 := #is_SorterNumber,
	                                            IN3 := #is_InductionNumber,
	                                            IN4 := #is_AreaNumber,
	                                            IN5 := #ss_SequencialID);
	                END_REGION
	                
	                REGION Gap
	                    
	                    #ss_Gap := '000';
	                    
	                END_REGION
	                
	                IF NOT #sa_Status.FIFOError                   // No FIFO error
	                THEN
	                    REGION Message preparation
	                        
	                        #ss_MessageP1 := CONCAT(IN1 := #cc_STX,
	                                                IN2 := #cs_Length,
	                                                IN3 := #cs_MessageType,
	                                                IN4 := #ss_LLCSystemID,
	                                                IN5 := "DB_ExternalGIN".UnexpectedSI.FedEx.ADCSystemID,
	                                                IN6 := "DB_ExternalGIN".UnexpectedSI.FedEx.ImageID,
	                                                IN7 := "DB_ExternalGIN".UnexpectedSI.FedEx.PackageID,
	                                                IN8 := "DB_ExternalGIN".UnexpectedSI.FedEx.HLCPackageID,
	                                                IN9 := "DB_ExternalGIN".UnexpectedSI.FedEx.DIMSystemID,
	                                                IN10 := "DB_ExternalGIN".UnexpectedSI.FedEx.DIMStatus,
	                                                IN11 := "DB_ExternalGIN".UnexpectedSI.FedEx.PackageDimLength,
	                                                IN12 := "DB_ExternalGIN".UnexpectedSI.FedEx.PackageDimWidth,
	                                                IN13 := "DB_ExternalGIN".UnexpectedSI.FedEx.PackageDimHeight,
	                                                IN14 := #ss_Gap,
	                                                IN15 := "DB_ExternalGIN".UnexpectedSI.FedEx.DIMUOM,
	                                                IN16 := "DB_ExternalGIN".UnexpectedSI.FedEx.DimLFTstatusCode,
	                                                IN17 := "DB_ExternalGIN".UnexpectedSI.FedEx.AlibiDims,
	                                                IN18 := "DB_ExternalGIN".UnexpectedSI.FedEx.SCLSystemID,
	                                                IN19 := "DB_ExternalGIN".UnexpectedSI.FedEx.SCLStatus,
	                                                IN20 := "DB_ExternalGIN".UnexpectedSI.FedEx.SCLWT,
	                                                IN21 := "DB_ExternalGIN".UnexpectedSI.FedEx.SCLWTUOM,
	                                                IN22 := "DB_ExternalGIN".UnexpectedSI.FedEx.SCLLFTStatusCode,
	                                                IN23 := "DB_ExternalGIN".UnexpectedSI.FedEx.AlibiWeight,
	                                                IN24 := "DB_ExternalGIN".UnexpectedSI.FedEx.CellNumber,
	                                                IN25 := "DB_ExternalGIN".UnexpectedSI.FedEx.CellsOccupied,
	                                                IN26 := "DB_Time".Timestamp,
	                                                IN27 := #iUDT_Facility.TimeZoneDesignator);
	                        
	                        #ss_MessageP2 := CONCAT(IN1 := "DB_ExternalGIN".UnexpectedSI.FedEx.PackageDataTruncated,
	                                                IN2 := "DB_ExternalGIN".UnexpectedSI.FedEx.TotalBarcodeDataLength,
	                                                IN3 := "DB_ExternalGIN".UnexpectedSI.FedEx.Barcode1Identification,
	                                                IN4 := "DB_ExternalGIN".UnexpectedSI.FedEx.Barcode1status,
	                                                IN5 := "DB_ExternalGIN".UnexpectedSI.FedEx.Barcode1datalength,
	                                                IN6 := "DB_ExternalGIN".UnexpectedSI.FedEx.Barcode1data,
	                                                IN7 := "DB_ExternalGIN".UnexpectedSI.FedEx.Barcode2Identification,
	                                                IN8 := "DB_ExternalGIN".UnexpectedSI.FedEx.Barcode2status,
	                                                IN9 := "DB_ExternalGIN".UnexpectedSI.FedEx.Barcode2datalength,
	                                                IN10 := "DB_ExternalGIN".UnexpectedSI.FedEx.Barcode2data,
	                                                IN11 := "DB_ExternalGIN".UnexpectedSI.FedEx.Barcode3Identification,
	                                                IN12 := "DB_ExternalGIN".UnexpectedSI.FedEx.Barcode3status,
	                                                IN13 := "DB_ExternalGIN".UnexpectedSI.FedEx.Barcode3datalength,
	                                                IN14 := "DB_ExternalGIN".UnexpectedSI.FedEx.Barcode3data,
	                                                IN15 := #cc_ETX);
	                        
	                    END_REGION
	                    
	                    REGION Maximum number of the message characters
	                        
	                        #si_MaxMsgLen := "FC_GetNrOfArrayEl"(iv_Array := #sUDT_MessageArray.Character);
	                        
	                    END_REGION
	                    
	                    REGION Length of the complete message
	                        
	                        #si_MsgLen := LEN(#ss_MessageP1) + LEN(#ss_MessageP2);
	                        
	                        // Message length validation
	                        #sa_Status.InvalidMessageLength := #si_MsgLen - 2 <> STRING_TO_INT(#cs_Length);
	                        
	                    END_REGION
	                    
	                    REGION Message array size validation
	                        
	                        #sa_Status.InvalidMsgArraySize := #si_MsgLen > #si_MaxMsgLen;
	                        
	                    END_REGION
	                    
	                    REGION Message character string conversion to a message array of characters
	                        
	                        IF (NOT #sa_Status.InvalidMsgArraySize)     // Message character array size is valid 
	                        THEN
	                            
	                            Strg_TO_Chars(Strg := #ss_MessageP1,
	                                          pChars := 0,
	                                          Cnt => #sui_ArrayOffset,
	                                          Chars := #sUDT_MessageArray.Character);
	                            
	                            Strg_TO_Chars(Strg := #ss_MessageP2,
	                                          pChars := #sui_ArrayOffset,
	                                          Cnt => #sui_MsgArrayElNr,
	                                          Chars := #sUDT_MessageArray.Character);
	                            
	                        END_IF;
	                        
	                    END_REGION
	                    
	                    REGION Clearing remaining characters in the message character array
	                        
	                        IF (NOT #sa_Status.InvalidMsgArraySize)     // Message character array size is valid 
	                        THEN
	                            
	                            // Filling up not used message character array elements with '$00' (ASCII - 16#00)
	                            FILL_BLK(IN := #cc_NULL,                                                                             // Fill not used message char array elements with '$00' 
	                                     COUNT := UINT_TO_ULINT(INT_TO_UINT(#si_MaxMsgLen) - #sui_MsgArrayElNr - #sui_ArrayOffset),
	                                     OUT => #sUDT_MessageArray.Character[#sui_MsgArrayElNr + #sui_ArrayOffset]);
	                            
	                        END_IF;
	                        
	                    END_REGION
	                    
	                    REGION Message write into a FIFO register
	                        
	                        IF NOT #sa_Status.InvalidMsgArraySize           // Message character array size is valid 
	                            AND NOT #sa_Status.InvalidMessageLength     // Message length is valid
	                        THEN
	                            
	                            // Mode 'W' - Write FIFO record
	                            "FC_Fifo"(ic_Mode := 'W',
	                                      qUDT_Status => #sa_Status.FIFOStatus,
	                                      qx_Error => #sa_Status.FIFOError,
	                                      qx_Warning => #sa_Status.FIFOWarning,
	                                      iqv_Data := #sUDT_MessageArray,
	                                      iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                                      iqv_DataBuffer := #iqa_FifoData);
	                            
	                        ELSE
	                            // Increase counter messages not sent because of wrong message length 
	                            #sa_Statistics.NotSentWrongMsgLen += 1;
	                            
	                        END_IF;
	                        
	                    END_REGION
	                    #iqx_UnexpectedDLReq := FALSE;
	                    
	                END_IF;
	                
	                // In case of FIFO full, the FIFO full error bit and FIFO collective error bit are set
	            ELSE
	                #sa_Status.FIFOError := TRUE;
	                #sa_Status.FIFOStatus.FifoFull := TRUE;
	                
	            END_IF;
	            
	        END_REGION
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Writing outputs
	    
	    #qx_Error := #sa_Status.InvalidMessageLength        // Invalid message length
	    OR #sa_Status.InvalidGIN                            // Invalid GIN 
	    OR #sa_Status.InvalidMsgArraySize                   // Invalid message array size 
	    OR #sa_Status.FIFOError                             // FIFO error
	    OR #sx_Error;
	    
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_FedExDivertVerificationMessage"
TITLE = FB_Heartbeat
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : UPS_SpecificCommunication
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 68
// END_ATTRIBUTES
//Function block to send and monitor the UPS heartbeat message.
   VAR_INPUT 
      iUDT_Facility { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FedExFacility";   // System configuration
      is_LOConEquipment { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[3];   // Location of the equipment
      is_DEPCOD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[6];   // Depot Code
      is_TYPofEquipment { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[3];   // Type of equipment
      is_NumberOfTheEquipment { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[3];   // Number of the equipment 001-999
      is_TrayCellNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[3];   // Tray/Cell number (for loop sorters) or generated by LLC (on line sorters).
      is_SorterNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[2];   // Sorter number
      is_InductionNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[2];   // Induction number
      is_AreaNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[2];   // Area number
      ii_Gin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // GIN number
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Error
   END_VAR

   VAR_IN_OUT 
      iqUDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqa_FifoData : Array[*] of "UDT_Message";   // FIFO data
   END_VAR

   VAR 
      sUDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Message";   // Message character array
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";   // FIFO status structure
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO data buffer full
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO error
         InvalidGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Invalid GIN
         InvalidMessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Calculated message length is different than required
         InvalidMsgArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Length of the message is bigger than length of message array
      END_STRUCT;
      ss_Statistics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Statistics structure
         NotSentWrongMsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // COMISSIONING PURPOSE Messages not sent because built message length does not match with required message length
      END_STRUCT;
      ss_LLCSystemID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[15];   // Identifier of Low-Level controls
      ss_SequencialID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[6];   // Identifier of Low-Level controls
      ss_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Message character string
      ss_PackageID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[15];   // Identifier of Low-Level controls
      ss_Recirculation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[2];   // Converted to string
      sui_MsgArrayElNr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Invalid message array size
      sui_ArrayOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Offset for writing in the array
      si_OldGin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Previous Gin
      si_StringLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length of string used in loops to pad string with spaces or 0
      si_LenFillLoop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Loop couter
      si_MaxMsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum message length
      si_MsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // String character message length
   END_VAR

   VAR_TEMP 
      tw_HTA_RET_VAL : Word;
   END_VAR

   VAR CONSTANT 
      cc_NULL : Char := '$00';   // NULL sign
      cc_STX : Char := '$02';   // Start of the text
      cc_ETX : String := '$03';   // End of the text
      cs_Length : String := '0180';   // Legth of the message
      cs_MessageType : String := 'DV';   // Message type
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	29/06/2021  | 1.0       | F.Baten       | first release MHS TIA 16.0
	10/11/2021  | 1.2       | M.Piela       | Updating regions numbering
	05/04/2022  | 1.3       | K.Pokorski    | Review
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOStatus,
	              qx_Error => #ss_Status.FIFOError,
	              qx_Warning => #ss_Status.FIFOWarning,
	              iqv_Data := #sUDT_MessageArray,
	              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	              iqv_DataBuffer := #iqa_FifoData);
	END_REGION
	
	REGION 2 - GIN validation
	    
	    // GIN validation
	    #ss_Status.InvalidGIN :=
	    #ii_Gin < 1
	    OR #ii_Gin > 9999;
	    
	END_REGION
	
	REGION 3 – Message preparation
	    
	    IF NOT #iqUDT_FifoHeader.Status.Full               // FIFO isn't full
	    THEN
	        IF #ii_Gin <> #si_OldGin                            // New gin is different than old 
	            AND NOT #ss_Status.InvalidGIN                   // Gin is valid 
	        THEN
	            REGION 3.1 - Sequencial ID
	                // ss_SequencialID character string clearing
	                #ss_SequencialID := '';
	                // ss_SequencialID integer input conversion to a character string
	                VAL_STRG(IN := "DB_GIN".GIN[#ii_Gin].FedEx.CustomerID,
	                         SIZE := 0,
	                         PREC := 0,
	                         FORMAT := 0,
	                         P := 1,
	                         OUT => #ss_SequencialID);
	                // Length of the ss_SequencialID character string 
	                #si_StringLen := LEN(#ss_SequencialID);
	                
	                // ss_SequencialID character string leading zeros addition
	                IF (#si_StringLen < 6)
	                THEN
	                    FOR #si_LenFillLoop := 1 TO 6 - #si_StringLen DO
	                        #ss_SequencialID := CONCAT(IN1 := '0',
	                                                   IN2 := #ss_SequencialID);
	                    END_FOR;
	                END_IF;
	            END_REGION
	            
	            REGION 3.2 LLC Syatem ID
	                // Build LLC Syatem ID  
	                #ss_LLCSystemID := CONCAT(IN1 := #is_DEPCOD,
	                                          IN2 := #is_LOConEquipment,
	                                          IN3 := #is_TYPofEquipment,
	                                          IN4 := #is_NumberOfTheEquipment);
	                
	            END_REGION
	            
	            REGION 3.3 - Package ID
	                // Build Package ID  
	                #ss_PackageID := CONCAT(IN1 := #is_TrayCellNumber,
	                                        IN2 := #is_SorterNumber,
	                                        IN3 := #is_InductionNumber,
	                                        IN4 := #is_AreaNumber,
	                                        IN5 := #ss_SequencialID);
	            END_REGION
	            
	            REGION 3.4 - Number of recirculation
	                // Character string clearing
	                #ss_Recirculation := '';
	                // integer input conversion to a character string
	                VAL_STRG(IN := "DB_GIN".GIN[#ii_Gin].General.NrOfRecirculations,
	                         SIZE := 0,
	                         PREC := 0,
	                         FORMAT := 0,
	                         P := 1,
	                         OUT => #ss_Recirculation);
	                // Length of the gap character string 
	                #si_StringLen := LEN(#ss_Recirculation);
	                // Gap character string leading zeros addition
	                IF (#si_StringLen < 2)
	                THEN
	                    #ss_Recirculation := CONCAT(IN1 := '0',
	                                                IN2 := #ss_Recirculation);
	                END_IF;
	                
	            END_REGION
	            
	            REGION 3.5 – Message preparation
	                // Message composing according to the structure: STX,message body,ETX
	                #ss_Message := CONCAT(IN1 := #cc_STX,
	                                      IN2 := #cs_Length,
	                                      IN3 := #cs_MessageType,
	                                      IN4 := #ss_LLCSystemID,
	                                      IN5 := #ss_PackageID,
	                                      IN6 := "DB_GIN".GIN[#ii_Gin].FedEx.HLCPackageID,
	                                      IN7 := "DB_GIN".GIN[#ii_Gin].FedEx.CellNumber,
	                                      IN8 := "DB_GIN".GIN[#ii_Gin].FedEx.ActualDestination,
	                                      IN9 := "DB_GIN".GIN[#ii_Gin].FedEx.PackageEntrancePoint,
	                                      IN10 := "DB_GIN".GIN[#ii_Gin].FedEx.PackageEntranceState,
	                                      IN11 := "DB_GIN".GIN[#ii_Gin].FedEx.PackageExitPoint,
	                                      IN12 := "DB_GIN".GIN[#ii_Gin].FedEx.PackageExitState,
	                                      IN13 := "DB_GIN".GIN[#ii_Gin].FedEx.Destination1,
	                                      IN14 := "DB_GIN".GIN[#ii_Gin].FedEx.ReasonCode1,
	                                      IN15 := "DB_GIN".GIN[#ii_Gin].FedEx.Destination2,
	                                      IN16 := "DB_GIN".GIN[#ii_Gin].FedEx.ReasonCode2,
	                                      IN17 := "DB_GIN".GIN[#ii_Gin].FedEx.Destination3,
	                                      IN18 := "DB_GIN".GIN[#ii_Gin].FedEx.ReasonCode3,
	                                      IN19 := "DB_GIN".GIN[#ii_Gin].FedEx.Destination4,
	                                      IN20 := "DB_GIN".GIN[#ii_Gin].FedEx.ReasonCode4,
	                                      IN21 := "DB_GIN".GIN[#ii_Gin].FedEx.Destination5,
	                                      IN22 := "DB_GIN".GIN[#ii_Gin].FedEx.ReasonCode5,
	                                      IN23 := #ss_Recirculation,
	                                      IN24 := "DB_Time".Timestamp,
	                                      IN25 := #iUDT_Facility.TimeZoneDesignator,
	                                      IN26 := #cc_ETX);
	            END_REGION
	            
	            REGION 3.6 – Maximum number of the message characters
	                
	                #si_MaxMsgLen := "FC_GetNrOfArrayEl"(iv_Array := #sUDT_MessageArray.Character);
	                
	            END_REGION
	            
	            REGION 3.7 – Length of the complete message
	                
	                #si_MsgLen := LEN(#ss_Message);
	                
	                // Message length validation
	                #ss_Status.InvalidMessageLength := #si_MsgLen - 2 <> STRING_TO_INT(#cs_Length);
	                
	            END_REGION
	            
	            REGION 3.8 –  Message array size validation
	                
	                #ss_Status.InvalidMsgArraySize := #si_MsgLen > #si_MaxMsgLen;
	                
	            END_REGION
	            
	            REGION 3.9 –  Message character string conversion to a message array of characters
	                
	                IF (NOT #ss_Status.InvalidMsgArraySize)     // Message character array size is valid 
	                THEN
	                    
	                    Strg_TO_Chars(Strg := #ss_Message,
	                                  pChars := 0,
	                                  Cnt => #sui_MsgArrayElNr,
	                                  Chars := #sUDT_MessageArray.Character);
	                END_IF;
	                
	            END_REGION
	            
	            REGION 3.10 – Clearing remaining characters in the message character array
	                
	                IF (NOT #ss_Status.InvalidMsgArraySize)     // Message character array size is valid 
	                THEN
	                    
	                    // Filling up not used message character array elements with '$00' (ASCII - 16#00)
	                    FILL_BLK(IN := #cc_NULL,                                                                             // Fill not used message char array elements with '$00' 
	                             COUNT := UINT_TO_ULINT(INT_TO_UINT(#si_MaxMsgLen) - #sui_MsgArrayElNr - #sui_ArrayOffset),
	                             OUT => #sUDT_MessageArray.Character[#sui_MsgArrayElNr + #sui_ArrayOffset]);
	                    
	                END_IF;
	                
	            END_REGION
	            
	            REGION 3.11 – Message write into a FIFO register
	                
	                IF NOT #ss_Status.InvalidMsgArraySize               // Message character array size is valid 
	                    AND NOT #ss_Status.InvalidMessageLength         //Message length is valid
	                THEN
	                    
	                    // Mode 'W' - Write FIFO record
	                    "FC_Fifo"(ic_Mode := 'W',
	                              qUDT_Status => #ss_Status.FIFOStatus,
	                              qx_Error => #ss_Status.FIFOError,
	                              qx_Warning => #ss_Status.FIFOWarning,
	                              iqv_Data := #sUDT_MessageArray,
	                              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                              iqv_DataBuffer := #iqa_FifoData);
	                ELSE
	                    // Increase counter messages not sent because of wrong message length 
	                    #ss_Statistics.NotSentWrongMsgLen += 1;
	                    
	                END_IF;
	                
	            END_REGION
	            #si_OldGin := #ii_Gin;
	        END_IF;
	        
	        // In case of FIFO full, the FIFO full error bit and FIFO collective error bit are set
	    ELSE
	        #ss_Status.FIFOError := TRUE;
	        #ss_Status.FIFOStatus.FifoFull := TRUE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Writing outputs
	    
	    #qx_Error := #ss_Status.InvalidMessageLength        // Invalid message length
	    OR #ss_Status.InvalidGIN                            // Invalid GIN 
	    OR #ss_Status.InvalidMsgArraySize                   // Invalid message array size 
	    OR #ss_Status.FIFOError;                            // FIFO error
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_FedExDVLost"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 69
// END_ATTRIBUTES
   VAR_INPUT 
      is_PackageExitPoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[14];
      is_RejectChute { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[6];
   END_VAR

   VAR_IN_OUT 
      iqa_FifoLostGinData : Array[*] of Int;   // Fifo data
      iqUDT_FifoLostGinHeader : "UDT_FifoHeader";   // Fifo header
      iqi_GINDVMessageLost { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // GIN number
   END_VAR

   VAR 
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Fifo status
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoStatus";
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         InvalidGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         InvalidMessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         InvalidMsgArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      END_STRUCT;
   END_VAR

   VAR_TEMP 
      ti_GIN : Int;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	26/04/2022  | 1.0       | K. Pokorski   | first release MHS TIA 16.0
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	13/03/2024  | 4.1       | S. Nieświec   | 4.1 Release TIA 18
	*)
	REGION 1 - Read fifo status
	    
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOStatus,
	              qx_Error => #ss_Status.FIFOError,
	              qx_Warning => #ss_Status.FIFOWarning,
	              iqv_Data := #ti_GIN,
	              iqUDT_FifoHeader := #iqUDT_FifoLostGinHeader,
	              iqv_DataBuffer := #iqa_FifoLostGinData);
	END_REGION
	
	REGION 2 - Read first lost GIN
	    
	    IF (NOT #iqUDT_FifoLostGinHeader.Status.Empty                             // FIFO not empty 
	        AND NOT #ss_Status.FIFOError)                                      // No FIFO error 
	    THEN
	        
	        // Mode 'R' - Read FIFO record
	        "FC_Fifo"(ic_Mode := 'R',
	                  qUDT_Status => #ss_Status.FIFOStatus,
	                  qx_Error => #ss_Status.FIFOError,
	                  qx_Warning => #ss_Status.FIFOWarning,
	                  iqv_Data := #ti_GIN,
	                  iqUDT_FifoHeader := #iqUDT_FifoLostGinHeader,
	                  iqv_DataBuffer := #iqa_FifoLostGinData);
	        
	        "DB_GIN".GIN[#ti_GIN].General.Lost := TRUE;
	        "DB_GIN".GIN[#ti_GIN].FedEx.ReasonCode1 := '00000800';
	        "DB_GIN".GIN[#ti_GIN].FedEx.PackageExitPoint := #is_PackageExitPoint;
	        "DB_GIN".GIN[#ti_GIN].FedEx.PackageExitState := '2';
	        "DB_GIN".GIN[#ti_GIN].FedEx.ActualDestination := #is_RejectChute;
	        #iqi_GINDVMessageLost := #ti_GIN;
	        
	    END_IF;
	END_REGION
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_FedExDXMessage"
TITLE = FB_Heartbeat
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : UPS_SpecificCommunication
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 70
// END_ATTRIBUTES
//Function block to send and monitor the UPS heartbeat message.
   VAR_INPUT 
      iUDT_Facility { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FedExFacility";   // System configuration
      is_LOConEquipment { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[3];   // Location of the equipment
      is_DEPCOD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[6];   // Depot Code
      is_TYPofEquipment { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[3];   // Type of equipment
      is_NumberOfTheEquipment { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[3];   // Number of the equipment 001-999
      is_TrayCellNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[3];   // Tray/Cell number (for loop sorters) or generated by LLC (on line sorters).
      is_SorterNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[2];   // Sorter number
      is_InductionNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[2];   // Induction number
      is_AreaNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[2];   // Area number
      ii_Gin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // GIN number
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Error
   END_VAR

   VAR_IN_OUT 
      iqUDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqa_FifoData : Array[*] of "UDT_Message";   // FIFO data
      iqx_Unexpected_DX_Req { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR 
      sUDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Message";   // Message character array
      sa_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";   // FIFO status structure
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO data buffer full
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO error
         InvalidGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Invalid GIN
         InvalidMessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Calculated message length is different than required
         InvalidMsgArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat timeout lower than zero or lower than heartbeat time interval
      END_STRUCT;
      sa_Statistics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Statistics structure
         NotSentWrongMsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // COMISSIONING PURPOSE Messages not sent because built message length does not match with required message length
      END_STRUCT;
      ss_LLCSystemID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[15];   // Identifier of Low-Level controls
      ss_SequencialID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[6];   // Identifier of Low-Level controls
      ss_MessageP1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Message character string part 1
      ss_MessageP2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Message character string part 2
      ss_PackageID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[15];   // Identifier of Low-Level controls
      ss_Gap { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[3];   // Gap converted to string
      sui_MsgArrayElNr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Invalid message array size
      sui_ArrayOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Offset for writing in the array
      si_OldGin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Previous Gin
      si_StringLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length of string used in loops to pad string with spaces or 0
      si_LenFillLoop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Loop couter
      si_MaxMsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum message length
      si_MsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // String character message length
      sx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR CONSTANT 
      cc_NULL : Char := '$00';   // NULL sign
      cc_STX : Char := '$02';   // Start of the text
      cc_ETX : Char := '$03';   // End of the text
      cs_Length : String := '0275';   // Legth of the message
      cs_MessageType : String := 'DX';   // Message type
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	29/06/2021  | 1.0       | F.Baten       | first release MHS TIA 16.0
	10/11/2021  | 1.2       | M.Piela       | Updating regions numbering
	05/04/2022  | 1.3       | K.Pokorski    | Review
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #sa_Status.FIFOStatus,
	              qx_Error => #sa_Status.FIFOError,
	              qx_Warning => #sa_Status.FIFOWarning,
	              iqv_Data := #sUDT_MessageArray,
	              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	              iqv_DataBuffer := #iqa_FifoData);
	END_REGION
	
	REGION 2 - GIN validation
	    
	    // GIN validation
	    #sa_Status.InvalidGIN :=
	    #ii_Gin < 1
	    OR #ii_Gin > 9999;
	    
	END_REGION
	
	REGION 3 – Message preparation
	    
	    IF NOT #iqUDT_FifoHeader.Status.Full       // FIFO isn't full
	        AND NOT #sa_Status.InvalidGIN
	        AND #ii_Gin <> #si_OldGin
	    THEN
	        REGION 3.1 - Sequencial ID
	            // ss_SequencialID character string clearing
	            #ss_SequencialID := '';
	            // ss_SequencialID integer input conversion to a character string
	            VAL_STRG(IN := "DB_GIN".GIN[#ii_Gin].FedEx.CustomerID,
	                     SIZE := 0,
	                     PREC := 0,
	                     FORMAT := 0,
	                     P := 1,
	                     OUT => #ss_SequencialID);
	            // Length of the ss_SequencialID character string 
	            #si_StringLen := LEN(#ss_SequencialID);
	            
	            // ss_SequencialID character string leading zeros addition
	            IF (#si_StringLen < 6)
	            THEN
	                FOR #si_LenFillLoop := 1 TO 6 - #si_StringLen DO
	                    #ss_SequencialID := CONCAT(IN1 := '0',
	                                               IN2 := #ss_SequencialID);
	                END_FOR;
	            END_IF;
	        END_REGION
	        
	        REGION 3.2 LLC Syatem ID
	            // Build LLC Syatem ID  
	            #ss_LLCSystemID := CONCAT(IN1 := #is_DEPCOD,
	                                      IN2 := #is_LOConEquipment,
	                                      IN3 := #is_TYPofEquipment,
	                                      IN4 := #is_NumberOfTheEquipment);
	            
	        END_REGION
	        
	        REGION 3.3 - Package ID
	            // Build Package ID  
	            #ss_PackageID := CONCAT(IN1 := #is_TrayCellNumber,
	                                    IN2 := #is_SorterNumber,
	                                    IN3 := #is_InductionNumber,
	                                    IN4 := #is_AreaNumber,
	                                    IN5 := #ss_SequencialID);
	        END_REGION
	        
	        REGION 3.4 - Gap
	            
	            // Gap character string clearing
	            #ss_Gap := '';
	            
	            IF ("DB_GIN".GIN[#ii_Gin].General.LeadingGap > 999)
	            THEN
	                #ss_Gap := '999';
	            ELSE
	                
	                // Gap integer input conversion to a character string
	                VAL_STRG(IN := "DB_GIN".GIN[#ii_Gin].General.LeadingGap,
	                         SIZE := 0,
	                         PREC := 0,
	                         FORMAT := 0,
	                         P := 1,
	                         OUT => #ss_Gap);
	                // Length of the gap character string 
	                #si_StringLen := LEN(#ss_Gap);
	                // Gap character string leading zeros addition
	                IF (#si_StringLen < 3)
	                THEN
	                    FOR #si_LenFillLoop := 1 TO 3 - #si_StringLen DO
	                        #ss_Gap := CONCAT(IN1 := '0',
	                                          IN2 := #ss_Gap);
	                    END_FOR;
	                END_IF;
	                
	            END_IF;
	            
	        END_REGION
	        
	        REGION 3.5 – Message preparation
	            
	            // Message composing according to the structure: STX,message body,ETX
	            #ss_MessageP1 := CONCAT(IN1 := #cc_STX,
	                                    IN2 := #cs_Length,
	                                    IN3 := #cs_MessageType,
	                                    IN4 := #ss_LLCSystemID,
	                                    IN5 := "DB_GIN".GIN[#ii_Gin].FedEx.ADCSystemID,
	                                    IN6 := "DB_GIN".GIN[#ii_Gin].FedEx.ImageID,
	                                    IN7 := #ss_PackageID,
	                                    IN8 := "DB_GIN".GIN[#ii_Gin].FedEx.HLCPackageID,
	                                    IN9 := "DB_GIN".GIN[#ii_Gin].FedEx.DIMSystemID,
	                                    IN10 := "DB_GIN".GIN[#ii_Gin].FedEx.DIMStatus,
	                                    IN11 := "DB_GIN".GIN[#ii_Gin].FedEx.PackageDimLength,
	                                    IN12 := "DB_GIN".GIN[#ii_Gin].FedEx.PackageDimWidth,
	                                    IN13 := "DB_GIN".GIN[#ii_Gin].FedEx.PackageDimHeight,
	                                    IN14 := #ss_Gap,
	                                    IN15 := "DB_GIN".GIN[#ii_Gin].FedEx.DIMUOM,
	                                    IN16 := "DB_GIN".GIN[#ii_Gin].FedEx.DimLFTstatusCode,
	                                    IN17 := "DB_GIN".GIN[#ii_Gin].FedEx.AlibiDims,
	                                    IN18 := "DB_GIN".GIN[#ii_Gin].FedEx.SCLSystemID,
	                                    IN19 := "DB_GIN".GIN[#ii_Gin].FedEx.SCLWT,
	                                    IN20 := "DB_GIN".GIN[#ii_Gin].FedEx.SCLWTUOM,
	                                    IN21 := "DB_GIN".GIN[#ii_Gin].FedEx.SCLLFTStatusCode,
	                                    IN22 := "DB_GIN".GIN[#ii_Gin].FedEx.AlibiWeight,
	                                    IN23 := "DB_GIN".GIN[#ii_Gin].FedEx.ReasonCode,
	                                    IN24 := "DB_Time".Timestamp,
	                                    IN25 := #iUDT_Facility.TimeZoneDesignator);
	            
	            #ss_MessageP2 := CONCAT(IN1 := "DB_GIN".GIN[#ii_Gin].FedEx.Barcode1Identification,
	                                    IN2 := "DB_GIN".GIN[#ii_Gin].FedEx.Barcode1status,
	                                    IN3 := "DB_GIN".GIN[#ii_Gin].FedEx.Barcode1datalength,
	                                    IN4 := "DB_GIN".GIN[#ii_Gin].FedEx.Barcode1data,
	                                    IN5 := #cc_ETX);
	            
	        END_REGION
	        
	        REGION 3.6 – Maximum number of the message characters
	            
	            #si_MaxMsgLen := "FC_GetNrOfArrayEl"(iv_Array := #sUDT_MessageArray.Character);
	            
	        END_REGION
	        
	        REGION 3.7 – Length of the complete message
	            
	            #si_MsgLen := LEN(#ss_MessageP1) + LEN(#ss_MessageP2);
	            // Message length validation
	            #sa_Status.InvalidMessageLength := #si_MsgLen - 2 <> STRING_TO_INT(#cs_Length);
	            
	        END_REGION
	        
	        REGION 3.8 –  Message array size validation
	            
	            #sa_Status.InvalidMsgArraySize := #si_MsgLen > #si_MaxMsgLen;
	            
	        END_REGION
	        
	        REGION 3.9 –  Message character string conversion to a message array of characters
	            
	            IF (NOT #sa_Status.InvalidMsgArraySize)     // Message character array size is valid 
	            THEN
	                
	                Strg_TO_Chars(Strg := #ss_MessageP1,
	                              pChars := 0,
	                              Cnt => #sui_ArrayOffset,
	                              Chars := #sUDT_MessageArray.Character);
	                
	                Strg_TO_Chars(Strg := #ss_MessageP2,
	                              pChars := #sui_ArrayOffset,
	                              Cnt => #sui_MsgArrayElNr,
	                              Chars := #sUDT_MessageArray.Character);
	                
	            END_IF;
	            
	        END_REGION
	        
	        REGION 3.10 – Clearing remaining characters in the message character array
	            
	            IF (NOT #sa_Status.InvalidMsgArraySize)     // Message character array size is valid 
	            THEN
	                
	                // Filling up not used message character array elements with '$00' (ASCII - 16#00)
	                FILL_BLK(IN := #cc_NULL,                                                                             // Fill not used message char array elements with '$00' 
	                         COUNT := UINT_TO_ULINT(INT_TO_UINT(#si_MaxMsgLen) - #sui_MsgArrayElNr - #sui_ArrayOffset),
	                         OUT => #sUDT_MessageArray.Character[#sui_MsgArrayElNr + #sui_ArrayOffset]);
	                
	            END_IF;
	            
	        END_REGION
	        
	        REGION 3.11 – Message write into a FIFO register
	            
	            IF NOT #sa_Status.InvalidMsgArraySize               // Message character array size is valid 
	                AND NOT #sa_Status.InvalidMessageLength         //Message length is valid 
	            THEN
	                
	                // Mode 'W' - Write FIFO record
	                "FC_Fifo"(ic_Mode := 'W',
	                          qUDT_Status => #sa_Status.FIFOStatus,
	                          qx_Error => #sa_Status.FIFOError,
	                          qx_Warning => #sa_Status.FIFOWarning,
	                          iqv_Data := #sUDT_MessageArray,
	                          iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                          iqv_DataBuffer := #iqa_FifoData);
	            ELSE
	                // Increase counter messages not sent because of wrong message length 
	                #sa_Statistics.NotSentWrongMsgLen += 1;
	                
	            END_IF;
	            
	            #si_OldGin := #ii_Gin;
	        END_REGION
	        
	        
	        // In case of FIFO full, the FIFO full error bit and FIFO collective error bit are set
	    ELSE
	        #sa_Status.FIFOError := TRUE;
	        #sa_Status.FIFOStatus.FifoFull := TRUE;
	    END_IF;
	    
	    
	    
	END_REGION
	
	REGION 4 - Writing outputs
	    
	    #sx_Error := #sa_Status.InvalidMessageLength        // Invalid message length
	    OR #sa_Status.InvalidGIN                            // Invalid GIN 
	    OR #sa_Status.InvalidMsgArraySize                   // Invalid message array size 
	    OR #sa_Status.FIFOError;                            // FIFO error
	    
	END_REGION
	
	
	
	REGION 5 Unexpected DX Request
	    
	    IF #iqx_Unexpected_DX_Req THEN
	        
	        REGION 5.1 – FIFO header status update
	            
	            // Mode 'S' - FIFO register status update
	            "FC_Fifo"(ic_Mode := 'S',
	                      qUDT_Status => #sa_Status.FIFOStatus,
	                      qx_Error => #sa_Status.FIFOError,
	                      qx_Warning => #sa_Status.FIFOWarning,
	                      iqv_Data := #sUDT_MessageArray,
	                      iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                      iqv_DataBuffer := #iqa_FifoData);
	        END_REGION
	        
	        REGION 5.2 – Message preparation
	            
	            IF NOT #iqUDT_FifoHeader.Status.Full       // FIFO isn't full
	            THEN
	                REGION Sequencial ID
	                    // ss_SequencialID character string clearing
	                    #ss_SequencialID := '';
	                    // ss_SequencialID integer input conversion to a character string
	                    VAL_STRG(IN := "DB_ExternalGIN".UnexpectedSI.FedEx.CustomerID,
	                             SIZE := 0,
	                             PREC := 0,
	                             FORMAT := 0,
	                             P := 1,
	                             OUT => #ss_SequencialID);
	                    // Length of the ss_SequencialID character string 
	                    #si_StringLen := LEN(#ss_SequencialID);
	                    
	                    // ss_SequencialID character string leading zeros addition
	                    IF (#si_StringLen < 6)
	                    THEN
	                        FOR #si_LenFillLoop := 1 TO 6 - #si_StringLen DO
	                            #ss_SequencialID := CONCAT(IN1 := '0',
	                                                       IN2 := #ss_SequencialID);
	                        END_FOR;
	                    END_IF;
	                END_REGION
	                
	                REGION LLC Syatem ID
	                    // Build LLC Syatem ID  
	                    #ss_LLCSystemID := CONCAT(IN1 := #is_DEPCOD,
	                                              IN2 := #is_LOConEquipment,
	                                              IN3 := #is_TYPofEquipment,
	                                              IN4 := #is_NumberOfTheEquipment);
	                    
	                END_REGION
	                
	                REGION Package ID
	                    // Build Package ID  
	                    #ss_PackageID := CONCAT(IN1 := #is_TrayCellNumber,
	                                            IN2 := #is_SorterNumber,
	                                            IN3 := #is_InductionNumber,
	                                            IN4 := #is_AreaNumber,
	                                            IN5 := #ss_SequencialID);
	                END_REGION
	                
	                REGION Gap
	                    
	                    #ss_Gap := '000';
	                    
	                END_REGION
	                
	                REGION 3.5 – Message preparation
	                    
	                    // Message composing according to the structure: STX,message body,ETX
	                    #ss_MessageP1 := CONCAT(IN1 := #cc_STX,
	                                            IN2 := #cs_Length,
	                                            IN3 := #cs_MessageType,
	                                            IN4 := #ss_LLCSystemID,
	                                            IN5 := "DB_ExternalGIN".UnexpectedSI.FedEx.ADCSystemID,
	                                            IN6 := "DB_ExternalGIN".UnexpectedSI.FedEx.ImageID,
	                                            IN7 := "DB_ExternalGIN".UnexpectedSI.FedEx.PackageID,
	                                            IN8 := "DB_ExternalGIN".UnexpectedSI.FedEx.HLCPackageID,
	                                            IN9 := "DB_ExternalGIN".UnexpectedSI.FedEx.DIMSystemID,
	                                            IN10 := "DB_ExternalGIN".UnexpectedSI.FedEx.DIMStatus,
	                                            IN11 := "DB_ExternalGIN".UnexpectedSI.FedEx.PackageDimLength,
	                                            IN12 := "DB_ExternalGIN".UnexpectedSI.FedEx.PackageDimWidth,
	                                            IN13 := "DB_ExternalGIN".UnexpectedSI.FedEx.PackageDimHeight,
	                                            IN14 := #ss_Gap,
	                                            IN15 := "DB_ExternalGIN".UnexpectedSI.FedEx.DIMUOM,
	                                            IN16 := "DB_ExternalGIN".UnexpectedSI.FedEx.DimLFTstatusCode,
	                                            IN17 := "DB_ExternalGIN".UnexpectedSI.FedEx.AlibiDims,
	                                            IN18 := "DB_ExternalGIN".UnexpectedSI.FedEx.SCLSystemID,
	                                            IN19 := "DB_ExternalGIN".UnexpectedSI.FedEx.SCLWT,
	                                            IN20 := "DB_ExternalGIN".UnexpectedSI.FedEx.SCLWTUOM,
	                                            IN21 := "DB_ExternalGIN".UnexpectedSI.FedEx.SCLLFTStatusCode,
	                                            IN22 := "DB_ExternalGIN".UnexpectedSI.FedEx.AlibiWeight,
	                                            IN23 := "DB_ExternalGIN".UnexpectedSI.FedEx.ReasonCode,
	                                            IN24 := "DB_Time".Timestamp,
	                                            IN25 := #iUDT_Facility.TimeZoneDesignator);
	                    
	                    #ss_MessageP2 := CONCAT(IN1 := "DB_ExternalGIN".UnexpectedSI.FedEx.Barcode1Identification,
	                                            IN2 := "DB_ExternalGIN".UnexpectedSI.FedEx.Barcode1status,
	                                            IN3 := "DB_ExternalGIN".UnexpectedSI.FedEx.Barcode1datalength,
	                                            IN4 := "DB_ExternalGIN".UnexpectedSI.FedEx.Barcode1data,
	                                            IN5 := #cc_ETX);
	                    
	                END_REGION
	                
	                REGION 3.6 – Maximum number of the message characters
	                    
	                    #si_MaxMsgLen := "FC_GetNrOfArrayEl"(iv_Array := #sUDT_MessageArray.Character);
	                    
	                END_REGION
	                
	                REGION 3.7 – Length of the complete message
	                    
	                    #si_MsgLen := LEN(#ss_MessageP1) + LEN(#ss_MessageP2);
	                    // Message length validation
	                    #sa_Status.InvalidMessageLength := #si_MsgLen - 2 <> STRING_TO_INT(#cs_Length);
	                    
	                END_REGION
	                
	                REGION 3.8 –  Message array size validation
	                    
	                    #sa_Status.InvalidMsgArraySize := #si_MsgLen > #si_MaxMsgLen;
	                    
	                END_REGION
	                
	                REGION 3.9 –  Message character string conversion to a message array of characters
	                    
	                    IF (NOT #sa_Status.InvalidMsgArraySize)     // Message character array size is valid 
	                    THEN
	                        
	                        Strg_TO_Chars(Strg := #ss_MessageP1,
	                                      pChars := 0,
	                                      Cnt => #sui_ArrayOffset,
	                                      Chars := #sUDT_MessageArray.Character);
	                        
	                        Strg_TO_Chars(Strg := #ss_MessageP2,
	                                      pChars := #sui_ArrayOffset,
	                                      Cnt => #sui_MsgArrayElNr,
	                                      Chars := #sUDT_MessageArray.Character);
	                        
	                    END_IF;
	                    
	                END_REGION
	                
	                REGION 3.10 – Clearing remaining characters in the message character array
	                    
	                    IF (NOT #sa_Status.InvalidMsgArraySize)     // Message character array size is valid 
	                    THEN
	                        
	                        // Filling up not used message character array elements with '$00' (ASCII - 16#00)
	                        FILL_BLK(IN := #cc_NULL,                                                                             // Fill not used message char array elements with '$00' 
	                                 COUNT := UINT_TO_ULINT(INT_TO_UINT(#si_MaxMsgLen) - #sui_MsgArrayElNr - #sui_ArrayOffset),
	                                 OUT => #sUDT_MessageArray.Character[#sui_MsgArrayElNr + #sui_ArrayOffset]);
	                        
	                    END_IF;
	                    
	                END_REGION
	                
	                REGION 3.11 – Message write into a FIFO register
	                    
	                    IF NOT #sa_Status.InvalidMsgArraySize               // Message character array size is valid 
	                        AND NOT #sa_Status.InvalidMessageLength         //Message length is valid 
	                    THEN
	                        
	                        // Mode 'W' - Write FIFO record
	                        "FC_Fifo"(ic_Mode := 'W',
	                                  qUDT_Status => #sa_Status.FIFOStatus,
	                                  qx_Error => #sa_Status.FIFOError,
	                                  qx_Warning => #sa_Status.FIFOWarning,
	                                  iqv_Data := #sUDT_MessageArray,
	                                  iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                                  iqv_DataBuffer := #iqa_FifoData);
	                    ELSE
	                        // Increase counter messages not sent because of wrong message length 
	                        #sa_Statistics.NotSentWrongMsgLen += 1;
	                        
	                    END_IF;
	                    
	                END_REGION
	                #iqx_Unexpected_DX_Req := FALSE;
	                
	                
	                // In case of FIFO full, the FIFO full error bit and FIFO collective error bit are set
	            ELSE
	                #sa_Status.FIFOError := TRUE;
	                #sa_Status.FIFOStatus.FifoFull := TRUE;
	            END_IF;
	            
	        END_REGION
	    END_IF;
	END_REGION
	
	
	
	REGION 6 - Writing outputs
	    
	    #qx_Error := #sa_Status.InvalidMessageLength        // Invalid message length
	    OR #sa_Status.InvalidGIN                            // Invalid GIN 
	    OR #sa_Status.InvalidMsgArraySize                   // Invalid message array size 
	    OR #sa_Status.FIFOError                             // FIFO error
	    OR #sx_Error;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_FedExEntrancePoint"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 71
// END_ATTRIBUTES
   VAR_INPUT 
      is_PackageEntrancePoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;
      is_PackageEntranceState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;
      ii_Gin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
   END_VAR

   VAR 
      si_OldGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_StringLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_LenFillLoop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
   END_VAR

   VAR_TEMP 
      tx_InvalidGIN : Bool;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	30/06/2022  | 0.1       | K. Pokorski   | first release MHS TIA 16
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - GIN validation
	    
	    // GIN validation
	    #tx_InvalidGIN := (#ii_Gin < 1) OR (#ii_Gin > 9999);
	    
	    IF #ii_Gin <> #si_OldGIN AND NOT #tx_InvalidGIN
	    THEN
	        
	        "DB_GIN".GIN[#ii_Gin].FedEx.PackageEntrancePoint := #is_PackageEntrancePoint;
	        "DB_GIN".GIN[#ii_Gin].FedEx.PackageEntranceState := #is_PackageEntranceState;
	        
	        #si_StringLen := LEN("DB_GIN".GIN[#ii_Gin].FedEx.PackageEntrancePoint);
	        
	        IF (#si_StringLen < 14)
	        THEN
	            FOR #si_LenFillLoop := 1 TO 14 - #si_StringLen DO
	                
	                "DB_GIN".GIN[#ii_Gin].FedEx.PackageEntrancePoint := CONCAT(IN1 := "DB_GIN".GIN[#ii_Gin].FedEx.PackageEntrancePoint,
	                                                                           IN2 := ' ');
	            END_FOR;
	        END_IF;
	        
	        #si_OldGIN := #ii_Gin;
	        
	    END_IF;
	    
	    
	END_REGION
	
	
	
	
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_FedExGetPositionPolisorter"
TITLE = FB_GetPosition
{ S7_Optimized_Access := 'TRUE' }
FAMILY : MHS
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 73
// END_ATTRIBUTES
//Function to find the position based on the GIN in the tracking. 
   VAR_INPUT 
      idi_ConveyorLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Conveyor length [mm]
      idi_WaitDistanceCorrection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := 10000;   // Distance how much parcel tail can stick out of the conveyor [mm]
   END_VAR

   VAR_IN_OUT 
      iqs_DBDestination : Array[*] of "UDT_FedExDestinations";   // Array with destination data for parcel
      iqUDT_PolisorterInterface : "UDT_PolisorterInterface";   // Interface beween VSU and VFD
      iqUDT_ConveyorInterface : "UDT_ConveyorInterface";   // Polisorter conveyor interface structure
      iqs_TrackingData : Array[*] of Int;   // Tracking data
   END_VAR

   VAR 
      si_Gin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // GIN
      si_PreviousGin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Old GIN memeory
      si_RequestedDestination { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // The destination for this GIN
      si_RequestedPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Requested position
      si_LC_Positions { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Loopcounter positions
      si_LC_Destinations { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Loopcounter destinations
      si_NrPositons { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Number of positions in the search area
      si_NrDestinations { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Number of destinations per position
      sx_NewGinFound { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Memory to start searching
      sdi_WaitDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Calculated wait distance [cm]
      sdi_ParcelLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Parcel length [cm]
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2019             MHS                                                     |
	|  All Rights Reserved         Larenweg 90                                             |
	|                              5234 KC 's-Hertogenbosch,                               |
	|                              Netherlands                                             |
	|                                                                                      |     
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	
	26/01/2022  | 0.1       | L.Klar        | Initial version
	13/03/2024  | 4.1       | S. Nieświec   | 4.1 Release TIA 18
	02/05/2024  | 4.2       | J.Majer      | Datatype conversions changed from automatic to explicit, to accomodate IEC 61131-3 standard
	*)
	
	REGION 1 - Determine size of search area 
	    
	    #si_NrPositons := "FC_GetNrOfArrayEl"(#iqs_DBDestination);
	    #si_NrDestinations := "FC_GetNrOfArrayEl"(#iqs_DBDestination[1].Destination);
	    
	END_REGION
	
	REGION 2 - Get GIN from tracking DB  
	    
	    // There is a value in the tracking data on the decision point which is not '0' or equal to the previous GIN
	    IF (#iqs_TrackingData[#iqUDT_PolisorterInterface.Decisionpoint] <> 0) AND (#iqs_TrackingData[#iqUDT_PolisorterInterface.Decisionpoint] <> #si_PreviousGin)
	    THEN
	        #si_Gin := #iqs_TrackingData[#iqUDT_PolisorterInterface.Decisionpoint];
	        #sx_NewGinFound := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Wait distance 
	    
	    IF #sdi_WaitDistance > 0 THEN
	        #sdi_WaitDistance -= #iqUDT_ConveyorInterface.Displacement;
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Get destination from GIN DB
	    // If new GIN has been detected, get destination from its GIN record 
	    
	    IF #sx_NewGinFound AND #si_Gin > 0
	    THEN
	        #si_RequestedDestination := DINT_TO_INT("DB_GIN".GIN[#si_Gin].General.Destination[0]);
	        
	        #sdi_ParcelLength := "DB_GIN".GIN[#si_Gin].General.Length;
	        
	        // If parcel length is lower than conveyor length - decision point use calculated decision point to switch. 
	        // If not, then caluclate additional wait distance, based on correction factor
	        // If the parcel length is equal to 0, use fixed wait distance of decision point minus 40
	        IF #sdi_ParcelLength > 0
	        THEN
	            IF #sdi_ParcelLength < #idi_ConveyorLength / 10 - #iqUDT_PolisorterInterface.Decisionpoint
	            THEN
	                #sdi_WaitDistance := 0;
	            ELSE
	                #sdi_WaitDistance := #sdi_ParcelLength - (#idi_ConveyorLength / 10 - #iqUDT_PolisorterInterface.Decisionpoint) - #idi_WaitDistanceCorrection / 10;
	            END_IF;
	        ELSE
	            #sdi_WaitDistance := #iqUDT_PolisorterInterface.Decisionpoint - 40;
	        END_IF;
	        #si_PreviousGin := #si_Gin;
	        #si_Gin := 0;
	        #iqUDT_PolisorterInterface.RequestedPosition := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Get requested position when new GIN is found 
	    
	    IF #sx_NewGinFound AND #sdi_WaitDistance <= 0
	    THEN
	        // If destination is different than 0, find a position in destination arrays. Otherwise, requested position is set to default.
	        IF #si_RequestedDestination <> 0 THEN
	            FOR #si_LC_Positions := 1 TO #si_NrPositons BY 1 DO
	                FOR #si_LC_Destinations := 0 TO (#si_NrDestinations - 1) BY 1 DO
	                    IF #iqs_DBDestination[#si_LC_Positions].Destination[#si_LC_Destinations] = #si_RequestedDestination
	                    THEN
	                        #si_RequestedPosition := #si_LC_Positions;
	                        EXIT;
	                    END_IF;
	                END_FOR;
	                // Position found
	                IF #si_RequestedPosition <> 0
	                THEN
	                    #iqUDT_PolisorterInterface.RequestedPosition := #si_RequestedPosition;
	                    #sx_NewGinFound := FALSE;
	                    #si_RequestedPosition := 0;
	                    EXIT;
	                END_IF;
	            END_FOR;
	        ELSE
	            // Default position
	            #sx_NewGinFound := FALSE;
	            #iqUDT_PolisorterInterface.RequestedPosition := 99;
	            #si_RequestedPosition := 0;
	        END_IF;
	    END_IF;
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_FedExInsertPoint"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 75
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_ConveyorCommonConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorCommonConfiguration";   // Common configuration of insert conveyor
      iUDT_ConveyorInterface { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorInterface";   // Insert conveyor interface
      idi_EoSPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // End of section sensor position [mm]
      ix_KeySwitch { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when insert mode active
      ix_PushButton { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when push button pressed
      ix_InsertConveyorEoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // End of section sensor of insert conveyor
   END_VAR

   VAR_OUTPUT 
      qx_UpstreamConveyorHold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Hold insert's upstream conveyor
      qx_InsertConveyorHold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Hold insert conveyor
      qx_Indicator { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Blue lamp on push button
      qx_InsertModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR 
      sR_TRIG_ModeChange {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Mode change detection
      sR_TRIG_InsertMode {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Insert mode activation
      sF_TRIG_FlowMode {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Flow mode activation
      sR_TRIG_PushButton {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Push button trigger
      sR_TRIG_EoS {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // End of section sensor trigger
      si_DistanceToStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Distance from end conveyor to stop [cm]
      sx_ClearingSequence { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Clearing sequence active
      sx_ReleaseSequence { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Release sequence active
      sx_ParcelPositionCorrectMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Position correction active
      sx_InsertModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	18/03/2022  | 1.0       | K.Pokorski    | first release MHS TIA 16
	28/06/2022  | 1.1       | K.Pokorski    | Adjust software for monostable key
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	
	REGION 1 - Change Mode detection
	    
	    #sR_TRIG_ModeChange(CLK := #ix_KeySwitch);
	    
	    IF #sR_TRIG_ModeChange.Q
	    THEN
	        IF #sx_InsertModeActive THEN
	            #sx_InsertModeActive := FALSE;
	        ELSE
	            #sx_InsertModeActive := TRUE;
	        END_IF;
	    END_IF;
	    
	    #sR_TRIG_InsertMode(CLK := #sx_InsertModeActive);
	    
	    #sF_TRIG_FlowMode(CLK := #sx_InsertModeActive);
	    
	    #sR_TRIG_PushButton(CLK := #ix_PushButton);
	    
	    #sR_TRIG_EoS(CLK := #ix_InsertConveyorEoS);
	    
	    
	END_REGION
	
	REGION 2 - Insert mode
	    
	    // Key switch in insert mode
	    IF #sx_InsertModeActive THEN
	        
	        // Enable clearing sequence
	        IF #sR_TRIG_InsertMode.Q THEN
	            #si_DistanceToStop := #iUDT_ConveyorCommonConfiguration.Length / 10;
	            #qx_UpstreamConveyorHold := TRUE;
	            #sx_ClearingSequence := TRUE;
	            #sx_ReleaseSequence := FALSE;
	        END_IF;
	        
	        // Indicator control
	        IF #sx_ClearingSequence THEN
	            #qx_Indicator := TRUE;
	        ELSE
	            #qx_Indicator := "DB_Memory".Clock_1Hz;
	        END_IF;
	        
	        // Clearing sequence control
	        IF #sx_ClearingSequence THEN
	            #si_DistanceToStop -= #iUDT_ConveyorInterface.Displacement;
	            IF #si_DistanceToStop <= 0 THEN
	                #qx_InsertConveyorHold := TRUE;
	                #sx_ClearingSequence := FALSE;
	            ELSE
	                #qx_InsertConveyorHold := FALSE;
	            END_IF;
	        END_IF;
	        
	        // Enable release sequence
	        IF #sR_TRIG_PushButton.Q AND NOT #sx_ClearingSequence THEN
	            #sx_ReleaseSequence := TRUE;
	            #si_DistanceToStop := (#iUDT_ConveyorCommonConfiguration.Length / 10);
	        END_IF;
	        
	        // Release sequence control
	        IF #sx_ReleaseSequence THEN
	            
	            IF #sR_TRIG_EoS.Q THEN
	                #si_DistanceToStop := #idi_EoSPosition / 10;
	            END_IF;
	            
	            #si_DistanceToStop -= #iUDT_ConveyorInterface.Displacement;
	            
	            IF #si_DistanceToStop <= 0 THEN
	                #qx_InsertConveyorHold := TRUE;
	                #sx_ReleaseSequence := FALSE;
	            ELSE
	                #qx_InsertConveyorHold := FALSE;
	            END_IF;
	            
	        END_IF;
	        
	    END_IF;
	    
	    #qx_InsertModeActive := #sx_InsertModeActive;
	    
	END_REGION
	
	
	REGION 3 - Flow Mode
	    
	    // Key switch in flow mode
	    IF NOT #sx_InsertModeActive THEN
	        
	        // Initialize flow mode
	        IF #sF_TRIG_FlowMode.Q THEN
	            
	            #qx_InsertConveyorHold := FALSE;
	            #qx_UpstreamConveyorHold := FALSE;
	            #sx_ParcelPositionCorrectMode := FALSE;
	            
	        END_IF;
	        
	        // Position correct mode enable
	        IF #sR_TRIG_PushButton.Q AND NOT #sx_ParcelPositionCorrectMode THEN
	            
	            #qx_InsertConveyorHold := TRUE;
	            #sx_ParcelPositionCorrectMode := TRUE;
	            
	            // Position correct mode disable
	        ELSIF #sR_TRIG_PushButton.Q AND #sx_ParcelPositionCorrectMode THEN
	            
	            #qx_InsertConveyorHold := FALSE;
	            #sx_ParcelPositionCorrectMode := FALSE;
	            
	        END_IF;
	        
	        // Indicator control
	        #qx_Indicator := "DB_Memory".Clock_1Hz AND #sx_ParcelPositionCorrectMode;
	        
	    END_IF;
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_FedExTriggerEventMessage"
TITLE = FB_Heartbeat
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : UPS_SpecificCommunication
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 85
// END_ATTRIBUTES
//Function block to send and monitor the UPS heartbeat message.
   VAR_INPUT 
      iUDT_Facility { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FedExFacility";   // System configuration
      is_LOConEquipment { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[3];   // Location of the equipment
      is_DEPCOD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[6];   // Depot Code
      is_TYPofEquipment { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[3];   // Type of equipment
      is_NumberOfTheEquipment { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[3];   // Number of the equipment 001-999
      is_TrayCellNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[3];   // Tray/Cell number (for loop sorters) or generated by LLC (on line sorters).
      is_SorterNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[2];   // Sorter number
      is_InductionNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[2];   // Induction number
      is_AreaNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[2];   // Area number
      is_IncompatiblesUnit { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[2];   // Id of the unit to be trigger inside the CWC. (e.g Scale1=S1; Scale2=S2).
      ii_Gin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // GIN number
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Error
   END_VAR

   VAR_IN_OUT 
      iqUDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqa_FifoData : Array[*] of "UDT_Message";   // FIFO data
   END_VAR

   VAR 
      sUDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Message";   // Message character array
      sa_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";   // FIFO status structure
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO data buffer full
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO error
         InvalidGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid GIN
         InvalidMessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Calculated message length is different than required
         InvalidMsgArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Length of the message is bigger than length of message array
      END_STRUCT;
      sa_Statistics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Statistics structure
         NotSentWrongMsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // COMISSIONING PURPOSE Messages not sent because built message length does not match with required message length
      END_STRUCT;
      ss_LLCSystemID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[15];   // Identifier of Low-Level controls
      ss_SequencialID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[6];   // Identifier of Low-Level controls
      ss_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Message character string
      ss_PackageID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Identifier of Low-Level controls
      ss_Gap { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Parcel leading gap
      ss_GapUOM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Gap units
      sui_MsgArrayElNr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Message array size
      si_OldGin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Previous Gin
      si_StringLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length of string used in loops to pad string with spaces or 0
      si_LenFillLoop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Loop couter
      si_MaxMsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum message length
      si_MsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // String character message length
   END_VAR

   VAR CONSTANT 
      cc_NULL : Char := '$00';   // NULL sign
      cs_Start : Char := '$02';   // Start of the text
      cs_End : Char := '$03';   // End of the text
      cs_Length : String := '0142';   // Legth of the message
      cs_MessageType : String := 'TE';   // Message type
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	29/06/2021  | 1.0       | F.Baten       | first release MHS TIA 16.0
	10/11/2021  | 1.2       | M.Piela       | Updating regions numbering
	26/04/2022  | 1.3       | K. Pokorski   | Review
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #sa_Status.FIFOStatus,
	              qx_Error => #sa_Status.FIFOError,
	              qx_Warning => #sa_Status.FIFOWarning,
	              iqv_Data := #sUDT_MessageArray,
	              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	              iqv_DataBuffer := #iqa_FifoData);
	END_REGION
	
	REGION GIN validation
	    
	    // GIN validation
	    #sa_Status.InvalidGIN :=
	    #ii_Gin < 1
	    OR #ii_Gin > 9999;
	END_REGION
	
	REGION 3 – Message preparation
	    
	    IF NOT #iqUDT_FifoHeader.Status.Full       // FIFO isn't full
	    THEN
	        IF #ii_Gin <> #si_OldGin                // There is new GIN
	            AND NOT #sa_Status.InvalidGIN       // GIN is valid
	        THEN
	            REGION 3.1 - Sequencial ID
	                // ss_SequencialID character string clearing
	                #ss_SequencialID := '';
	                // ss_SequencialID integer input conversion to a character string
	                VAL_STRG(IN := "DB_GIN".GIN[#ii_Gin].FedEx.CustomerID,
	                         SIZE := 0,
	                         PREC := 0,
	                         FORMAT := 0,
	                         P := 1,
	                         OUT => #ss_SequencialID);
	                // Length of the ss_SequencialID character string 
	                #si_StringLen := LEN(#ss_SequencialID);
	                
	                // ss_SequencialID character string leading zeros addition
	                IF (#si_StringLen < 6)
	                THEN
	                    FOR #si_LenFillLoop := 1 TO 6 - #si_StringLen DO
	                        #ss_SequencialID := CONCAT(IN1 := '0',
	                                                   IN2 := #ss_SequencialID);
	                    END_FOR;
	                END_IF;
	            END_REGION
	            
	            REGION 3.2 - LLC System ID
	                // Build LLC Syatem ID  
	                #ss_LLCSystemID := CONCAT(IN1 := #is_DEPCOD,
	                                          IN2 := #is_LOConEquipment,
	                                          IN3 := #is_TYPofEquipment,
	                                          IN4 := #is_NumberOfTheEquipment);
	            END_REGION
	            
	            REGION 3.3 - Package ID
	                // Build Package ID  
	                #ss_PackageID := CONCAT(IN1 := #is_TrayCellNumber,
	                                        IN2 := #is_SorterNumber,
	                                        IN3 := #is_InductionNumber,
	                                        IN4 := #is_AreaNumber,
	                                        IN5 := #ss_SequencialID);
	            END_REGION
	            
	            REGION 3.4 - Gap
	                // Gap character string clearing
	                #ss_Gap := '';
	                IF ("DB_GIN".GIN[#ii_Gin].General.LeadingGap > 999)
	                THEN
	                    #ss_Gap := '999';
	                ELSE
	                    // Gap integer input conversion to a character string
	                    VAL_STRG(IN := "DB_GIN".GIN[#ii_Gin].General.LeadingGap,
	                             SIZE := 0,
	                             PREC := 0,
	                             FORMAT := 0,
	                             P := 1,
	                             OUT => #ss_Gap);
	                    // Length of the gap character string 
	                    #si_StringLen := LEN(#ss_Gap);
	                    // Gap character string leading zeros addition
	                    IF (#si_StringLen < 3)
	                    THEN
	                        FOR #si_LenFillLoop := 1 TO 3 - #si_StringLen DO
	                            #ss_Gap := CONCAT(IN1 := '0',
	                                              IN2 := #ss_Gap);
	                        END_FOR;
	                        
	                    END_IF;
	                END_IF;
	                #ss_GapUOM := 'CM';
	            END_REGION
	            
	            REGION 3.5 – Message preparation
	                // Message composing according to the structure: STX,Body ,ETX
	                #ss_Message := CONCAT(IN1 := #cs_Start,
	                                      IN2 := #cs_Length,
	                                      IN3 := #cs_MessageType,
	                                      IN4 := #ss_LLCSystemID,
	                                      IN5 := #ss_PackageID,
	                                      IN6 := "DB_GIN".GIN[#ii_Gin].FedEx.HLCPackageID,
	                                      IN7 := #ss_Gap,
	                                      IN8 := #ss_GapUOM,
	                                      IN9 := #is_IncompatiblesUnit,
	                                      IN10 := "DB_GIN".GIN[#ii_Gin].FedEx.PalletType,
	                                      IN11 := "DB_GIN".GIN[#ii_Gin].FedEx.Mask,
	                                      IN12 := "DB_GIN".GIN[#ii_Gin].FedEx.CellNumber,
	                                      IN13 := "DB_GIN".GIN[#ii_Gin].FedEx.CellsOccupied,
	                                      IN14 := "DB_Time".Timestamp,
	                                      IN15 := #iUDT_Facility.TimeZoneDesignator,
	                                      IN16 := "DB_GIN".GIN[#ii_Gin].FedEx.BarcodeIdentification,
	                                      IN17 := "DB_GIN".GIN[#ii_Gin].FedEx.Barcodestatus,
	                                      IN18 := "DB_GIN".GIN[#ii_Gin].FedEx.Barcodedatalength,
	                                      IN19 := "DB_GIN".GIN[#ii_Gin].FedEx.Barcodedata,
	                                      IN20 := #cs_End);
	                
	            END_REGION
	            
	            REGION 3.6 – Maximum number of the message characters
	                
	                #si_MaxMsgLen := "FC_GetNrOfArrayEl"(iv_Array := #sUDT_MessageArray.Character);
	                
	            END_REGION
	            
	            REGION 3.7 – Length of the complete message
	                
	                #si_MsgLen := LEN(#ss_Message);
	                
	                // Message length validation
	                #sa_Status.InvalidMessageLength := #si_MsgLen - 2 <> STRING_TO_INT(#cs_Length);
	                
	            END_REGION
	            
	            REGION 3.8 –  Message array size validation
	                
	                #sa_Status.InvalidMsgArraySize := #si_MsgLen > #si_MaxMsgLen;
	                
	            END_REGION
	            
	            REGION 3.9 –  Message character string conversion to a message array of characters
	                
	                IF (NOT #sa_Status.InvalidMsgArraySize)     // Message character array size is valid 
	                THEN
	                    
	                    Strg_TO_Chars(Strg := #ss_Message,
	                                  pChars := 0,
	                                  Cnt => #sui_MsgArrayElNr,
	                                  Chars := #sUDT_MessageArray.Character);
	                    
	                END_IF;
	                
	            END_REGION
	            
	            REGION 3.10 – Clearing remaining characters in the message character array
	                
	                IF (NOT #sa_Status.InvalidMsgArraySize)     // Message character array size is valid 
	                THEN
	                    
	                    // Filling up not used message character array elements with '$00' (ASCII - 16#00)
	                    FILL_BLK(IN := #cc_NULL,
	                             COUNT := UINT_TO_ULINT(INT_TO_UINT(#si_MaxMsgLen) - #sui_MsgArrayElNr),
	                             OUT => #sUDT_MessageArray.Character[#sui_MsgArrayElNr]);
	                    
	                END_IF;
	                
	            END_REGION
	            
	            REGION 3.11 – Message write into a FIFO register
	                
	                IF NOT #sa_Status.InvalidMsgArraySize           // Message character array size is valid 
	                    AND NOT #sa_Status.InvalidMessageLength     //Message length is valid 
	                THEN
	                    
	                    // Mode 'W' - Write FIFO record
	                    "FC_Fifo"(ic_Mode := 'W',
	                              qUDT_Status => #sa_Status.FIFOStatus,
	                              qx_Error => #sa_Status.FIFOError,
	                              qx_Warning => #sa_Status.FIFOWarning,
	                              iqv_Data := #sUDT_MessageArray,
	                              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                              iqv_DataBuffer := #iqa_FifoData);
	                ELSE
	                    #sa_Statistics.NotSentWrongMsgLen += 1;
	                    
	                END_IF;
	                
	            END_REGION
	            #si_OldGin := #ii_Gin;
	        END_IF;
	        
	        // In case of FIFO full, the FIFO full error bit and FIFO collective error bit are set
	    ELSE
	        
	        #sa_Status.FIFOError := TRUE;
	        #sa_Status.FIFOStatus.FifoFull := TRUE;
	        
	    END_IF;
	END_REGION
	
	REGION 4 - Writing outputs
	    
	    #qx_Error := #sa_Status.InvalidMessageLength        // Invalid message length
	    OR #sa_Status.InvalidGIN                            // Invalid GIN 
	    OR #sa_Status.InvalidMsgArraySize                   // Invalid message array size 
	    OR #sa_Status.FIFOError;                            // FIFO error                                   // FIFO error
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_FedExLogInRequest"
TITLE = FB_Heartbeat
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : UPS_SpecificCommunication
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 76
// END_ATTRIBUTES
//Function block to send and monitor the UPS heartbeat message.
   VAR_INPUT 
      iUDT_Faciality { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FedExFacility";   // System configuration
      ix_LogInRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Log in message send request
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective error output
   END_VAR

   VAR_IN_OUT 
      iqUDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqa_FifoData : Array[*] of "UDT_Message";   // FIFO data
      iqUDT_LoginStatus : "UDT_FedexLoginStatus";
   END_VAR

   VAR 
      sR_TRIG_LogInRequest {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Siemens "R_TRIG" - to prepare the rising edge trigger on "ix_LogInRequest" signal
      sUDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Message";   // Message character array
      sa_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";   // FIFO status structure
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO data buffer full
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO error
         HeartbeatOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO warning
         InvalidTimeInterval { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat ok
         InvalidTimeout { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat time interval lower than zero
         InvalidMsgArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat timeout lower than zero or lower than heartbeat time interval
         InvalidSystemIDLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Invalid designated system parameter input
         InvalidFacialityIDLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Invalid GIN
      END_STRUCT;
      ss_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Message character string
      sc_SS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Maximum frequency of messages string
      ss_VersionID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Version ID string
      sui_MsgArrayElNr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Invalid message array size
      si_SSLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length of converted maximum frequency of messages string
      si_FacialityIDLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Faciality ID length
      si_SystemIDLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // System ID length
      si_VersionIDLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Version ID length
      si_MaxMsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum message length
      si_MsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // String character message length
      si_VersionIDLoop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Version ID spaces padding loop counter
   END_VAR

   VAR CONSTANT 
      cc_NULL : Char := '$00';   // NULL sign
      cc_STX : Char := '$02';   // Start of the text
      cc_ETX : Char := '$03';   // End of the text
      cs_Length : String := '0035';   // Legth of the message
      cs_MessageType : String := 'LI';   // Message type
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	29/06/2021  | 1.0       | F.Baten       | first release MHS TIA 16.0
	08/11/2021  | 1.1       | M.Piela       | Interface corrections
	05/04/2022  | 1.2       | K.Pokorski    | Review
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #sa_Status.FIFOStatus,
	              qx_Error => #sa_Status.FIFOError,
	              qx_Warning => #sa_Status.FIFOWarning,
	              iqv_Data := #sUDT_MessageArray,
	              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	              iqv_DataBuffer := #iqa_FifoData);
	    
	    
	END_REGION
	
	
	REGION 2 – Configuration check and create error
	    
	    #si_FacialityIDLen := LEN(#iUDT_Faciality.FacilityID);
	    #si_SystemIDLen := LEN(#iUDT_Faciality.SystemID);
	    
	    #sa_Status.InvalidSystemIDLen := #si_SystemIDLen <> 15;
	    #sa_Status.InvalidFacialityIDLen := #si_FacialityIDLen <> 6;
	    
	END_REGION
	
	REGION 3 – Message preparation
	    
	    #sR_TRIG_LogInRequest(CLK := #ix_LogInRequest);        // Log in request rising edge trigger detection
	    
	    IF (NOT #iqUDT_FifoHeader.Status.Full)                 // FIFO isn't full
	    THEN
	        
	        IF (NOT #sa_Status.FIFOError                                // No FIFO errors
	            AND NOT #sa_Status.InvalidSystemIDLen                   // Length of system ID field is ok   
	            AND NOT #sa_Status.InvalidFacialityIDLen                // Length of faciality ID field is ok
	            AND #sR_TRIG_LogInRequest.Q)
	        THEN
	            REGION 3.1 – Message preparation
	                
	                // Maximum frequency of messages to string conversion
	                #sc_SS := UDINT_TO_STRING(#iUDT_Faciality.SS);
	                
	                // Delete "+"
	                #sc_SS := DELETE(IN := #sc_SS, L := 1, P := 1);
	                
	                // Maximum frequency of messages length calculation
	                #si_SSLen := LEN(IN := #sc_SS);
	                
	                // If maximum frequency of messages has only one digit then add leading zero
	                IF #si_SSLen = 1
	                THEN
	                    #sc_SS := CONCAT(IN1 := '0', IN2 := #sc_SS);
	                    
	                END_IF;
	                
	                #ss_VersionID := #iUDT_Faciality.VersionID;
	                
	                // Version ID length calculation
	                #si_VersionIDLen := LEN(#iUDT_Faciality.VersionID);
	                
	                // IF Version ID length is less than 6, then padd it with spaces
	                IF #si_VersionIDLen < 6
	                THEN
	                    
	                    FOR #si_VersionIDLoop := 1 TO 6 - #si_VersionIDLen DO
	                        
	                        #ss_VersionID := CONCAT(IN1 := #ss_VersionID, IN2 := ' ');
	                        
	                    END_FOR;
	                    
	                END_IF;
	                
	                // Heartbeat message composing according to the structure: STX,00,06,LS,ETX
	                #ss_Message := CONCAT(IN1 := #cc_STX,                       // Start of message
	                                      IN2 := #cs_Length,                    // Message length
	                                      IN3 := #cs_MessageType,               // Log-in request message
	                                      IN4 := #iUDT_Faciality.FacilityID,   // Generated during configuration. It is a fixed value for all systems 
	                                      IN5 := #iUDT_Faciality.SystemID,     // System ID of the system making the request.
	                                      IN6 := #ss_VersionID,                 // Interface document version.
	                                      IN7 := #sc_SS,                        // Maximum ferquency of messages
	                                      IN8 := #cc_ETX);                      // End of message
	                
	            END_REGION
	            
	            REGION 3.2 – Maximum number of the message characters
	                
	                #si_MaxMsgLen := "FC_GetNrOfArrayEl"(iv_Array := #sUDT_MessageArray.Character);
	                
	            END_REGION
	            
	            REGION 3.3 – Length of the complete message
	                
	                #si_MsgLen := LEN(#ss_Message);
	                
	            END_REGION
	            
	            REGION 3.4 –  Message array size validation
	                
	                #sa_Status.InvalidMsgArraySize := #si_MsgLen > #si_MaxMsgLen;
	                
	            END_REGION
	            
	            REGION 3.5 –  Message character string conversion to a message array of characters
	                
	                IF (NOT #sa_Status.InvalidMsgArraySize)     // Message character array size is valid 
	                THEN
	                    
	                    Strg_TO_Chars(Strg := #ss_Message,
	                                  pChars := 0,
	                                  Cnt => #sui_MsgArrayElNr,
	                                  Chars := #sUDT_MessageArray.Character);
	                    
	                END_IF;
	                
	            END_REGION
	            
	            REGION 3.6 – Clearing remaining characters in the message character array
	                
	                IF (NOT #sa_Status.InvalidMsgArraySize)     // Message character array size is valid 
	                THEN
	                    
	                    // Filling up not used message character array elements with '$00' (ASCII - 16#00)
	                    FILL_BLK(IN := #cc_NULL,
	                             COUNT := UINT_TO_ULINT(INT_TO_UINT(#si_MaxMsgLen) - #sui_MsgArrayElNr),
	                             OUT => #sUDT_MessageArray.Character[#sui_MsgArrayElNr]);
	                    
	                END_IF;
	                
	            END_REGION
	            
	            REGION 3.7 – Message write into a FIFO register
	                
	                IF NOT #sa_Status.InvalidMsgArraySize // Message character array size is valid 
	                THEN
	                    
	                    // Mode 'W' - Write FIFO record
	                    "FC_Fifo"(ic_Mode := 'W',
	                              qUDT_Status => #sa_Status.FIFOStatus,
	                              qx_Error => #sa_Status.FIFOError,
	                              qx_Warning => #sa_Status.FIFOWarning,
	                              iqv_Data := #sUDT_MessageArray,
	                              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                              iqv_DataBuffer := #iqa_FifoData);
	                END_IF;
	                
	            END_REGION
	            
	            #iqUDT_LoginStatus.Accepted := FALSE;
	            #iqUDT_LoginStatus.Rejected := FALSE;
	        END_IF;
	        
	        // In case of FIFO full, the FIFO full error bit and FIFO collective error bit are set
	    ELSE
	        
	        #sa_Status.FIFOError := TRUE;
	        #sa_Status.FIFOStatus.FifoFull := TRUE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 – Status
	    
	    // Parametrization collective error output
	    #qx_Error :=
	    #sa_Status.InvalidSystemIDLen                               // Invalid System ID string length 
	    OR #sa_Status.InvalidFacialityIDLen                         // Invalid Faciality ID lenght
	    OR #sa_Status.InvalidMsgArraySize                           // Invalid message array size 
	    OR #sa_Status.FIFOError;                                    // FIFO error
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_FedExDecodeADC"
TITLE = FB_Decode
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : UPS_SpecificCommunication
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 66
// END_ATTRIBUTES
//Function block to decode UPS messages.
   VAR_INPUT 
      iUDT_FacilityADC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FedExFacility";   // ADC FedEx configuration
      ii_GinRangeStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ii_GinRangeEnd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ii_UFORangeStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ii_UFORangeEnd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
   END_VAR

   VAR_IN_OUT 
      iqUDT_FifoRcvHeader : "UDT_FifoHeader";   // FIFO receive header
      iqv_FifoRcvData : Array[*] of "UDT_Message";   // FIFO receive data
      iqUDT_LoginStatus : "UDT_FedexLoginStatus";   // Login Status
      iqUDT_SI : Struct   // Buffer for SI message
         Data : "UDT_FedExMessageSI";   // SI message body
         NewMessage : Bool;   // New message received from ADC
      END_STRUCT;
      iqUDT_LR : Struct   // Buffer for LR message
         Data : "UDT_FedExMessageLoginResponse";   // LR message body
         NewMessage : Bool;   // New message received from ADC
      END_STRUCT;
      iqUDT_WS : Struct   // Buffer for WS message
         Data : "UDT_FedExMessageWS";   // WS message body
         NewMessage : Bool;   // New message received from ADC
      END_STRUCT;
      iqUDT_CustomerIDReference : "UDT_FedExCustomerID";
      iqx_UnexpectedDXReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request DX message for GIN
      iqx_UnexpectedDLReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request DL message for GIN
      iqx_HeartbeatOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat signal was received
      iqx_ResetWritingTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset writing timer in Heartbeat block
      iqx_ResetListeningTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset listening timer in Heartbeat block
   END_VAR

   VAR 
      sa_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         BadMessage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..10] of "UDT_Message";   //   Unknown message read
         FIFORcvStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";   //   Receive FIFO status structure
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //   FIFO error
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //   FIFO warning
         AcknowledgeError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //   Acknowledge error
         AcknowledgeWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //   Acknowledge warning
         HB_NotOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Health bit not OK
      END_STRUCT;
      sUDT_FifoMsg { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Message";   // Buffer for fifos message
      sUDT_MSGHeader { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FedExMessageHeader";   // Read message header
      ss_NNNNNN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[6];   // Pacel GIN number of read message
      si_SizeOfMsg { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Message array size
      si_GIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Pacel GIN number of read message
      si_CustomerID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // CustomerID of read message
      si_MessageLegth { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Message length
      sx_InvalidLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message invalid length
   END_VAR

   VAR_TEMP 
      tx_MsgRead : Bool;   // Message read from FIFO
   END_VAR

   VAR CONSTANT 
      cs_SI : String := 'SI';
      cs_WS : String := 'WS';
      cs_HB : String := 'HB';
      cs_LR : String := 'LR';
      cs_ConnectionAccepted : String := 'Y';
      ci_SizeSIMessage : Int := 388;
      ci_SizeWSMessage : Int := 92;
      ci_SizeLRMessage : Int := 66;
      ci_SizeHBMessage : Int := 6;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	01/11/2021  | 0.1       | N.Kadam       | first release MHS TIA 16
	05/04/2022  | 0.2       | K.Pokorski    | Review
	17.06.2022  | 0.3       | K. Pokorski   | Reset listening timer when any message is received
	07/07/2022  | 0.4       | K. Pokorski   | Reason code 3 issue fix in SI message
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #sa_Status.FIFORcvStatus,
	              qx_Error => #sa_Status.FIFOError,
	              qx_Warning => #sa_Status.FIFOWarning,
	              iqv_Data := #sUDT_FifoMsg,
	              iqUDT_FifoHeader := #iqUDT_FifoRcvHeader,
	              iqv_DataBuffer := #iqv_FifoRcvData);
	    
	    IF (NOT #iqUDT_FifoRcvHeader.Status.Empty                             // FIFO not empty 
	        AND NOT #sa_Status.FIFOError)                                      // No FIFO error 
	    THEN
	        
	        // Mode 'R' - Read FIFO record
	        "FC_Fifo"(ic_Mode := 'R',
	                  qUDT_Status => #sa_Status.FIFORcvStatus,
	                  qx_Error => #sa_Status.FIFOError,
	                  qx_Warning => #sa_Status.FIFOWarning,
	                  iqv_Data := #sUDT_FifoMsg,
	                  iqUDT_FifoHeader := #iqUDT_FifoRcvHeader,
	                  iqv_DataBuffer := #iqv_FifoRcvData);
	        
	        // Message read bit set and position initialize 
	        #tx_MsgRead := TRUE;
	        
	        
	        // FIFO empty or FIFO error occured      
	    ELSE
	        
	        #tx_MsgRead := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 – Maximum number of the message characters
	    
	    #si_SizeOfMsg := "FC_GetNrOfArrayEl"(iv_Array := #sUDT_FifoMsg.Character);
	    
	END_REGION
	
	REGION 3 – Decoding header
	    
	    IF #tx_MsgRead
	    THEN
	        
	        "FC_FedExDecodeHeader"(iUDT_FifoMsg := #sUDT_FifoMsg,
	                               qUDT_MSGHeader => #sUDT_MSGHeader);
	        
	    END_IF;
	END_REGION
	
	REGION 4 - Decode 
	    
	    IF #tx_MsgRead
	    THEN
	        #si_MessageLegth := STRING_TO_INT(#sUDT_MSGHeader.MessageLength);
	        
	        IF
	            // Decode Login Response Message
	            #sUDT_MSGHeader.MessageType = #cs_LR
	        THEN
	            IF #si_MessageLegth = #ci_SizeLRMessage         // Check length of the message
	                
	            THEN
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 7,
	                              Cnt := 6,
	                              Strg => #iqUDT_LR.Data.FacilityID);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 13,
	                              Cnt := 15,
	                              Strg => #iqUDT_LR.Data.SystemID);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 28,
	                              Cnt := 6,
	                              Strg => #iqUDT_LR.Data.VersionID);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 34,
	                              Cnt := 1,
	                              Strg => #iqUDT_LR.Data.ConnectionStatus);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 35,
	                              Cnt := 32,
	                              Strg => #iqUDT_LR.Data.LocalHost);
	                
	                #iqx_ResetWritingTimer := TRUE;
	                #iqx_ResetListeningTimer := TRUE;
	                #iqUDT_LR.NewMessage := TRUE;
	                
	                // Login Status verification  Y/N 
	                
	                IF #iqUDT_LR.Data.ConnectionStatus = #cs_ConnectionAccepted
	                    AND #iUDT_FacilityADC.FacilityID = #iqUDT_LR.Data.FacilityID
	                    AND #iUDT_FacilityADC.SystemID = #iqUDT_LR.Data.SystemID
	                    AND #iUDT_FacilityADC.VersionID = #iqUDT_LR.Data.VersionID
	                THEN
	                    #iqUDT_LoginStatus.Accepted := TRUE;    // Y = Accepted 
	                    #iqUDT_LoginStatus.Rejected := FALSE;
	                ELSE
	                    #iqUDT_LoginStatus.Rejected := TRUE;   // N = Rejected
	                    #iqUDT_LoginStatus.Accepted := FALSE;
	                END_IF;
	            ELSE
	                #sx_InvalidLength := TRUE;
	                #iqUDT_LoginStatus.Rejected := TRUE;
	                #iqUDT_LoginStatus.Accepted := FALSE;
	            END_IF;
	            
	        ELSIF
	            
	            // //Decode Scan Information message
	            #sUDT_MSGHeader.MessageType = #cs_SI
	        THEN
	            IF #si_MessageLegth = #ci_SizeSIMessage
	            THEN
	                // Convert array of bytes into body structure.
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 7,
	                              Cnt := 15,
	                              Strg => #iqUDT_SI.Data.ADCSystemID);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 22,
	                              Cnt := 1,
	                              Strg => #iqUDT_SI.Data.ScanUnitType);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 23,
	                              Cnt := 6,
	                              Strg => #iqUDT_SI.Data.ImageID);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 29,
	                              Cnt := 15,
	                              Strg => #iqUDT_SI.Data.PackageID);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 44,
	                              Cnt := 10,
	                              Strg => #iqUDT_SI.Data.HLCPackageID);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 54,
	                              Cnt := 15,
	                              Strg => #iqUDT_SI.Data.DIMSystemID);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 69,
	                              Cnt := 5,
	                              Strg => #iqUDT_SI.Data.DimStatus);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 74,
	                              Cnt := 6,
	                              Strg => #iqUDT_SI.Data.PackageDimLength);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 80,
	                              Cnt := 6,
	                              Strg => #iqUDT_SI.Data.PackageDimWidth);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 86,
	                              Cnt := 6,
	                              Strg => #iqUDT_SI.Data.PackageDimHeight);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 92,
	                              Cnt := 2,
	                              Strg => #iqUDT_SI.Data.DIMUOM);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 94,
	                              Cnt := 8,
	                              Strg => #iqUDT_SI.Data.DimLFTstatusCode);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 102,
	                              Cnt := 25,
	                              Strg => #iqUDT_SI.Data.AlibiDims);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 127,
	                              Cnt := 15,
	                              Strg => #iqUDT_SI.Data.SCLSystemID);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 142,
	                              Cnt := 5,
	                              Strg => #iqUDT_SI.Data.SCLStatus);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 147,
	                              Cnt := 6,
	                              Strg => #iqUDT_SI.Data.SCLWT);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 153,
	                              Cnt := 2,
	                              Strg => #iqUDT_SI.Data.SCLWTUOM);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 155,
	                              Cnt := 2,
	                              Strg => #iqUDT_SI.Data.SCLLFTStatusCode);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 157,
	                              Cnt := 25,
	                              Strg => #iqUDT_SI.Data.AlibiWeight);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 182,
	                              Cnt := 1,
	                              Strg => #iqUDT_SI.Data.Stackable);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 183,
	                              Cnt := 17,
	                              Strg => #iqUDT_SI.Data.Timestamp);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 200,
	                              Cnt := 5,
	                              Strg => #iqUDT_SI.Data.TimeZoneDesignator);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 205,
	                              Cnt := 2,
	                              Strg => #iqUDT_SI.Data.CameraHeadstatus);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 207,
	                              Cnt := 1,
	                              Strg => #iqUDT_SI.Data.PackageDataTruncated);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 208,
	                              Cnt := 4,
	                              Strg => #iqUDT_SI.Data.TotalBarcodeDataLength);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 212,
	                              Cnt := 3,
	                              Strg => #iqUDT_SI.Data.Barcode1Identification);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 215,
	                              Cnt := 2,
	                              Strg => #iqUDT_SI.Data.Barcode1status);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 217,
	                              Cnt := 4,
	                              Strg => #iqUDT_SI.Data.Barcode1datalength);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 221,
	                              Cnt := 50,
	                              Strg => #iqUDT_SI.Data.Barcode1data);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 271,
	                              Cnt := 3,
	                              Strg => #iqUDT_SI.Data.Barcode2Identification);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 274,
	                              Cnt := 2,
	                              Strg => #iqUDT_SI.Data.Barcode2status);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 276,
	                              Cnt := 4,
	                              Strg => #iqUDT_SI.Data.Barcode2datalength);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 280,
	                              Cnt := 50,
	                              Strg => #iqUDT_SI.Data.Barcode2data);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 330,
	                              Cnt := 3,
	                              Strg => #iqUDT_SI.Data.Barcode3Identification);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 333,
	                              Cnt := 2,
	                              Strg => #iqUDT_SI.Data.Barcode3status);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 335,
	                              Cnt := 4,
	                              Strg => #iqUDT_SI.Data.Barcode3datalength);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 339,
	                              Cnt := 50,
	                              Strg => #iqUDT_SI.Data.Barcode3data);
	                
	                
	                // Message length is fixed and should be the same
	                IF #si_MessageLegth <> #ci_SizeSIMessage
	                THEN
	                    #sx_InvalidLength := TRUE;
	                ELSE
	                    #sx_InvalidLength := FALSE;
	                END_IF;
	                IF NOT #sx_InvalidLength
	                THEN
	                    // Convert 'NNNNNN' part in package ID to GIN number and store data in GIN database
	                    #ss_NNNNNN := RIGHT(IN := #iqUDT_SI.Data.PackageID, L := 6);
	                    STRG_VAL(IN := #ss_NNNNNN,
	                             FORMAT := 16#0,
	                             P := 1,
	                             OUT => #si_CustomerID);
	                    IF #si_CustomerID > 1 AND #si_CustomerID < 999999 THEN
	                        #si_GIN := #iqUDT_CustomerIDReference.CustomerIDReference[#si_CustomerID];
	                    END_IF;
	                    
	                    IF #si_GIN > 0
	                        AND #si_GIN < 9999 THEN
	                        
	                        // Generate SI message reason code
	                        IF "DB_GIN".GIN[#si_GIN].FedEx.PackageEntranceState = ' '
	                            OR ("DB_GIN".GIN[#si_GIN].FedEx.PackageEntranceState <> ' ' AND "DB_GIN".GIN[#si_GIN].FedEx.PackageExitState <> ' ')
	                            OR NOT ((#si_GIN >= #ii_GinRangeStart AND #si_GIN <= #ii_GinRangeEnd) OR (#si_GIN >= #ii_UFORangeStart AND #si_GIN <= #ii_UFORangeEnd))
	                            
	                        THEN
	                            "DB_GIN".GIN[#si_GIN].FedEx.ReasonCode := '3';
	                            
	                        ELSIF (#iqUDT_SI.Data.PackageDimLength = '      ' OR
	                            #iqUDT_SI.Data.PackageDimWidth = '      ' OR
	                            #iqUDT_SI.Data.PackageDimHeight = '      ')
	                            AND #iqUDT_SI.Data.DimStatus <> 'NOSYS' THEN
	                            "DB_GIN".GIN[#si_GIN].FedEx.ReasonCode := '2';
	                            
	                        ELSIF #iqUDT_SI.Data.SCLWT = '      '
	                            AND #iqUDT_SI.Data.SCLStatus <> 'NOSYS' THEN
	                            
	                            "DB_GIN".GIN[#si_GIN].FedEx.ReasonCode := '2';
	                            
	                        ELSIF "DB_GIN".GIN[#si_GIN].FedEx.ReasonCode = ' ' OR "DB_GIN".GIN[#si_GIN].FedEx.ReasonCode = '4' THEN
	                            "DB_GIN".GIN[#si_GIN].FedEx.ReasonCode := '0';
	                            
	                        ELSIF "DB_GIN".GIN[#si_GIN].FedEx.ReasonCode = '0' THEN
	                            "DB_GIN".GIN[#si_GIN].FedEx.ReasonCode := '5';
	                            
	                            
	                        END_IF;
	                        
	                        IF "DB_GIN".GIN[#si_GIN].FedEx.ReasonCode <> '3' THEN
	                            
	                            // Write data to DB_GIN
	                            "DB_GIN".GIN[#si_GIN].FedEx.ADCSystemID := #iqUDT_SI.Data.ADCSystemID;
	                            "DB_GIN".GIN[#si_GIN].FedEx.ScanUnitType := #iqUDT_SI.Data.ScanUnitType;
	                            "DB_GIN".GIN[#si_GIN].FedEx.ImageID := #iqUDT_SI.Data.ImageID;
	                            "DB_GIN".GIN[#si_GIN].FedEx.PackageID := #iqUDT_SI.Data.PackageID;
	                            "DB_GIN".GIN[#si_GIN].FedEx.HLCPackageID := #iqUDT_SI.Data.HLCPackageID;
	                            "DB_GIN".GIN[#si_GIN].FedEx.DIMSystemID := #iqUDT_SI.Data.DIMSystemID;
	                            "DB_GIN".GIN[#si_GIN].FedEx.DIMStatus := #iqUDT_SI.Data.DimStatus;
	                            "DB_GIN".GIN[#si_GIN].FedEx.PackageDimLength := #iqUDT_SI.Data.PackageDimLength;
	                            "DB_GIN".GIN[#si_GIN].FedEx.PackageDimWidth := #iqUDT_SI.Data.PackageDimWidth;
	                            "DB_GIN".GIN[#si_GIN].FedEx.PackageDimHeight := #iqUDT_SI.Data.PackageDimHeight;
	                            "DB_GIN".GIN[#si_GIN].FedEx.DIMUOM := #iqUDT_SI.Data.DIMUOM;
	                            "DB_GIN".GIN[#si_GIN].FedEx.DimLFTstatusCode := #iqUDT_SI.Data.DimLFTstatusCode;
	                            "DB_GIN".GIN[#si_GIN].FedEx.AlibiDims := #iqUDT_SI.Data.AlibiDims;
	                            "DB_GIN".GIN[#si_GIN].FedEx.SCLSystemID := #iqUDT_SI.Data.SCLSystemID;
	                            "DB_GIN".GIN[#si_GIN].FedEx.SCLStatus := #iqUDT_SI.Data.SCLStatus;
	                            "DB_GIN".GIN[#si_GIN].FedEx.SCLWT := #iqUDT_SI.Data.SCLWT;
	                            "DB_GIN".GIN[#si_GIN].FedEx.SCLWTUOM := #iqUDT_SI.Data.SCLWTUOM;
	                            "DB_GIN".GIN[#si_GIN].FedEx.SCLLFTStatusCode := #iqUDT_SI.Data.SCLLFTStatusCode;
	                            "DB_GIN".GIN[#si_GIN].FedEx.AlibiWeight := #iqUDT_SI.Data.AlibiWeight;
	                            "DB_GIN".GIN[#si_GIN].FedEx.Stackable := #iqUDT_SI.Data.Stackable;
	                            "DB_GIN".GIN[#si_GIN].FedEx.Stackable := #iqUDT_SI.Data.Timestamp;
	                            "DB_GIN".GIN[#si_GIN].FedEx.Stackable := #iqUDT_SI.Data.TimeZoneDesignator;
	                            "DB_GIN".GIN[#si_GIN].FedEx.CameraHeadstatus := #iqUDT_SI.Data.CameraHeadstatus;
	                            "DB_GIN".GIN[#si_GIN].FedEx.PackageDataTruncated := #iqUDT_SI.Data.PackageDataTruncated;
	                            "DB_GIN".GIN[#si_GIN].FedEx.TotalBarcodeDataLength := #iqUDT_SI.Data.TotalBarcodeDataLength;
	                            "DB_GIN".GIN[#si_GIN].FedEx.Barcode1Identification := #iqUDT_SI.Data.Barcode1Identification;
	                            "DB_GIN".GIN[#si_GIN].FedEx.Barcode1status := #iqUDT_SI.Data.Barcode1status;
	                            "DB_GIN".GIN[#si_GIN].FedEx.Barcode1datalength := #iqUDT_SI.Data.Barcode1datalength;
	                            "DB_GIN".GIN[#si_GIN].FedEx.Barcode1data := #iqUDT_SI.Data.Barcode1data;
	                            "DB_GIN".GIN[#si_GIN].FedEx.Barcode2Identification := #iqUDT_SI.Data.Barcode2Identification;
	                            "DB_GIN".GIN[#si_GIN].FedEx.Barcode2status := #iqUDT_SI.Data.Barcode2status;
	                            "DB_GIN".GIN[#si_GIN].FedEx.Barcode2datalength := #iqUDT_SI.Data.Barcode2datalength;
	                            "DB_GIN".GIN[#si_GIN].FedEx.Barcode2data := #iqUDT_SI.Data.Barcode2data;
	                            "DB_GIN".GIN[#si_GIN].FedEx.Barcode3Identification := #iqUDT_SI.Data.Barcode3Identification;
	                            "DB_GIN".GIN[#si_GIN].FedEx.Barcode3status := #iqUDT_SI.Data.Barcode3status;
	                            "DB_GIN".GIN[#si_GIN].FedEx.Barcode3datalength := #iqUDT_SI.Data.Barcode3datalength;
	                            "DB_GIN".GIN[#si_GIN].FedEx.Barcode3data := #iqUDT_SI.Data.Barcode3data;
	                            
	                        ELSE
	                            
	                            // Write data to DB_ExternalGIN when GIN is out of range
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.ADCSystemID := #iqUDT_SI.Data.ADCSystemID;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.ScanUnitType := #iqUDT_SI.Data.ScanUnitType;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.ImageID := #iqUDT_SI.Data.ImageID;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.PackageID := #iqUDT_SI.Data.PackageID;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.HLCPackageID := #iqUDT_SI.Data.HLCPackageID;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.DIMSystemID := #iqUDT_SI.Data.DIMSystemID;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.DIMStatus := #iqUDT_SI.Data.DimStatus;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.PackageDimLength := #iqUDT_SI.Data.PackageDimLength;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.PackageDimWidth := #iqUDT_SI.Data.PackageDimWidth;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.PackageDimHeight := #iqUDT_SI.Data.PackageDimHeight;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.DIMUOM := #iqUDT_SI.Data.DIMUOM;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.DimLFTstatusCode := #iqUDT_SI.Data.DimLFTstatusCode;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.AlibiDims := #iqUDT_SI.Data.AlibiDims;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.SCLSystemID := #iqUDT_SI.Data.SCLSystemID;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.SCLStatus := #iqUDT_SI.Data.SCLStatus;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.SCLWT := #iqUDT_SI.Data.SCLWT;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.SCLWTUOM := #iqUDT_SI.Data.SCLWTUOM;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.SCLLFTStatusCode := #iqUDT_SI.Data.SCLLFTStatusCode;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.AlibiWeight := #iqUDT_SI.Data.AlibiWeight;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.Stackable := #iqUDT_SI.Data.Stackable;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.Stackable := #iqUDT_SI.Data.Timestamp;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.Stackable := #iqUDT_SI.Data.TimeZoneDesignator;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.CameraHeadstatus := #iqUDT_SI.Data.CameraHeadstatus;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.PackageDataTruncated := #iqUDT_SI.Data.PackageDataTruncated;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.TotalBarcodeDataLength := #iqUDT_SI.Data.TotalBarcodeDataLength;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.Barcode1Identification := #iqUDT_SI.Data.Barcode1Identification;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.Barcode1status := #iqUDT_SI.Data.Barcode1status;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.Barcode1datalength := #iqUDT_SI.Data.Barcode1datalength;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.Barcode1data := #iqUDT_SI.Data.Barcode1data;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.Barcode2Identification := #iqUDT_SI.Data.Barcode2Identification;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.Barcode2status := #iqUDT_SI.Data.Barcode2status;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.Barcode2datalength := #iqUDT_SI.Data.Barcode2datalength;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.Barcode2data := #iqUDT_SI.Data.Barcode2data;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.Barcode3Identification := #iqUDT_SI.Data.Barcode3Identification;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.Barcode3status := #iqUDT_SI.Data.Barcode3status;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.Barcode3datalength := #iqUDT_SI.Data.Barcode3datalength;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.Barcode3data := #iqUDT_SI.Data.Barcode3data;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.ReasonCode := '3';
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.PackageID := #iqUDT_SI.Data.PackageID;
	                            "DB_ExternalGIN".UnexpectedSI.FedEx.CustomerID := #si_CustomerID;
	                            #iqx_UnexpectedDXReq := TRUE;// DX request
	                            #iqx_UnexpectedDLReq := TRUE;// DL request
	                        END_IF;
	                        
	                        
	                        
	                        
	                    END_IF;
	                    #iqx_ResetWritingTimer := TRUE;
	                    #iqx_ResetListeningTimer := TRUE;
	                    #iqUDT_SI.NewMessage := TRUE;
	                ELSE
	                    #sx_InvalidLength := TRUE;
	                END_IF;
	            END_IF;
	            
	        ELSIF
	            
	            //Decode Weight Scale Message 
	            #sUDT_MSGHeader.MessageType = #cs_WS
	        THEN
	            IF #si_MessageLegth = #ci_SizeSIMessage
	            THEN
	                // Convert array of bytes into body structure.
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 7,
	                              Cnt := 15,
	                              Strg => #iqUDT_WS.Data.SCLSystemID);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 22,
	                              Cnt := 15,
	                              Strg => #iqUDT_WS.Data.PackageID);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 37,
	                              Cnt := 6,
	                              Strg => #iqUDT_WS.Data.SCLWT);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 43,
	                              Cnt := 2,
	                              Strg => #iqUDT_WS.Data.SCLWTUOM);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 45,
	                              Cnt := 2,
	                              Strg => #iqUDT_WS.Data.SCLLFTStatusCode);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 47,
	                              Cnt := 25,
	                              Strg => #iqUDT_WS.Data.AlibiWeight);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 72,
	                              Cnt := 17,
	                              Strg => #iqUDT_WS.Data.Timestamp);
	                
	                Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                              pChars := 89,
	                              Cnt := 5,
	                              Strg => #iqUDT_WS.Data.TimeZoneDesignator);
	                
	                
	                
	                // Message length is fixed and should be the same
	                IF #si_MessageLegth <> #ci_SizeWSMessage
	                THEN
	                    #sx_InvalidLength := TRUE;
	                ELSE
	                    #sx_InvalidLength := FALSE;
	                END_IF;
	                IF NOT #sx_InvalidLength
	                THEN
	                    // Convert 'NNNNNN' part in package ID to GIN number and store data in GIN database
	                    #ss_NNNNNN := RIGHT(IN := #iqUDT_WS.Data.PackageID, L := 6);
	                    STRG_VAL(IN := #ss_NNNNNN,
	                             FORMAT := 16#0,
	                             P := 1,
	                             OUT => #si_CustomerID);
	                    
	                    IF #si_CustomerID > 1 AND #si_CustomerID < 999999 THEN
	                        #si_GIN := #iqUDT_CustomerIDReference.CustomerIDReference[#si_CustomerID];
	                    END_IF;
	                    
	                    "DB_GIN".GIN[#si_GIN].FedEx.SCLSystemID := #iqUDT_WS.Data.SCLSystemID;
	                    "DB_GIN".GIN[#si_GIN].FedEx.SCLSystemID := #iqUDT_WS.Data.PackageID;
	                    "DB_GIN".GIN[#si_GIN].FedEx.SCLWT := #iqUDT_WS.Data.SCLWT;
	                    "DB_GIN".GIN[#si_GIN].FedEx.SCLWTUOM := #iqUDT_WS.Data.SCLWTUOM;
	                    "DB_GIN".GIN[#si_GIN].FedEx.SCLLFTStatusCode := #iqUDT_WS.Data.SCLLFTStatusCode;
	                    "DB_GIN".GIN[#si_GIN].FedEx.AlibiWeight := #iqUDT_WS.Data.AlibiWeight;
	                    "DB_GIN".GIN[#si_GIN].FedEx.AlibiWeight := #iqUDT_WS.Data.Timestamp;
	                    "DB_GIN".GIN[#si_GIN].FedEx.AlibiWeight := #iqUDT_WS.Data.TimeZoneDesignator;
	                    
	                    #iqx_ResetWritingTimer := TRUE;
	                    #iqx_ResetListeningTimer := TRUE;
	                    #iqUDT_WS.NewMessage := TRUE;
	                    
	                ELSE
	                    #sx_InvalidLength := TRUE;
	                    
	                END_IF;
	            END_IF;
	            
	        END_IF;
	        
	        
	    END_IF;
	END_REGION
	
	
	REGION 9 - Heartbeat Signal
	    // Message is read and type is HB
	    IF #tx_MsgRead
	        AND #sUDT_MSGHeader.MessageType = #cs_HB
	        AND #si_MessageLegth = #ci_SizeHBMessage
	    THEN
	        #iqx_HeartbeatOk := TRUE;
	        
	    END_IF;
	END_REGION
	
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_FedExLogOffRequest"
TITLE = FB_Heartbeat
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : UPS_SpecificCommunication
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 78
// END_ATTRIBUTES
//Function block to send and monitor the UPS heartbeat message.
   VAR_INPUT 
      i_UDT_Facility_PLC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FedExFacility";
      ix_LogOffRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Log off message send request
      ix_Connected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TCPIP connection established
      ix_ConnectionAccepted { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Error
   END_VAR

   VAR_IN_OUT 
      iqUDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqa_FifoData : Array[*] of "UDT_Message";   // FIFO data
      iqx_Reconnect { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Re-establish connection
   END_VAR

   VAR 
      s_FB_TimerOnOffDelay_Connected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sR_TRIG_LogOffRequest {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Siemens "R_TRIG" - to prepare the rising edge trigger on "ix_LogOffRequest" signal
      sUDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Message";   // Message character array
      sa_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";   // FIFO status structure
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO data buffer full
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO Warning
         InvalidMsgArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalig message array size
      END_STRUCT;
      ss_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Message character string
      sui_MsgArrayElNr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Invalid message array size
      si_MaxMsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum message length
      si_MsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // String character message length
   END_VAR

   VAR CONSTANT 
      cc_NULL : Char := '$00';   // NULL sign
      cc_STX : Char := '$02';   // Start of the text
      cc_ETX : Char := '$03';   // End of the text
      cs_MessageLength : String := '0006';   // Legth of the message
      cs_LogOffRequest : String := 'LS';   // Message type
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	29/06/2021  | 1.0       | F.Baten       | first release MHS TIA 16.4
	08/11/2021  | 1.1       | M.Piela       | Interface changes
	05/04/2022  | 1.2       | K.Pokorski    | Review
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #sa_Status.FIFOStatus,
	              qx_Error => #sa_Status.FIFOError,
	              qx_Warning => #sa_Status.FIFOWarning,
	              iqv_Data := #sUDT_MessageArray,
	              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	              iqv_DataBuffer := #iqa_FifoData);
	    
	END_REGION
	
	REGION 2 – Message preparation
	    
	    #s_FB_TimerOnOffDelay_Connected(iudi_OnDelayTime := #i_UDT_Facility_PLC.SS,
	                                    iudi_OffDelayTime := 0,
	                                    ix_SignalToDelay := #ix_Connected AND NOT #ix_ConnectionAccepted);
	    
	    
	    #sR_TRIG_LogOffRequest(CLK := #ix_LogOffRequest OR #s_FB_TimerOnOffDelay_Connected.qx_DelayedSignal);
	    
	    IF (NOT #iqUDT_FifoHeader.Status.Full)                 // FIFO isn't full
	    THEN
	        
	        IF (#sR_TRIG_LogOffRequest.Q                       // Trigger message
	            AND NOT #sa_Status.FIFOError)                   // No FIFO error
	        THEN
	            REGION 2.1 – Message preparation
	                
	                // Heartbeat message composing according to the structure: STX,00,06,LS,ETX
	                #ss_Message := CONCAT(IN1 := #cc_STX,             // Start of message
	                                      IN2 := #cs_MessageLength,            // message length
	                                      IN3 := #cs_LogOffRequest,     // Log-off request message
	                                      IN4 := #cc_ETX);              // End of message
	                
	            END_REGION
	            
	            REGION 2.2 – Maximum number of the message characters
	                
	                #si_MaxMsgLen := "FC_GetNrOfArrayEl"(iv_Array := #sUDT_MessageArray.Character);
	                
	            END_REGION
	            
	            REGION 2.3 – Length of the complete message
	                
	                #si_MsgLen := LEN(#ss_Message);
	                
	            END_REGION
	            
	            REGION 2.4 –  Message array size validation
	                
	                #sa_Status.InvalidMsgArraySize := #si_MsgLen > #si_MaxMsgLen;
	                
	            END_REGION
	            
	            REGION 2.5 –  Message character string conversion to a message array of characters
	                
	                IF (NOT #sa_Status.InvalidMsgArraySize)     // Message character array size is valid 
	                THEN
	                    
	                    Strg_TO_Chars(Strg := #ss_Message,
	                                  pChars := 0,
	                                  Cnt => #sui_MsgArrayElNr,
	                                  Chars := #sUDT_MessageArray.Character);
	                END_IF;
	                
	            END_REGION
	            
	            REGION 2.6 – Clearing remaining characters in the message character array
	                
	                IF (NOT #sa_Status.InvalidMsgArraySize)     // Message character array size is valid 
	                THEN
	                    
	                    // Filling up not used message character array elements with '$00' (ASCII - 16#00)
	                    FILL_BLK(IN := #cc_NULL,
	                             COUNT := UINT_TO_ULINT(INT_TO_UINT(#si_MaxMsgLen) - #sui_MsgArrayElNr),
	                             OUT => #sUDT_MessageArray.Character[#sui_MsgArrayElNr]);
	                    
	                END_IF;
	                
	            END_REGION
	            
	            REGION 2.7 – Message write into a FIFO register
	                
	                IF NOT #sa_Status.InvalidMsgArraySize // Message character array size is valid 
	                THEN
	                    
	                    // Mode 'W' - Write FIFO record
	                    "FC_Fifo"(ic_Mode := 'W',
	                              qUDT_Status => #sa_Status.FIFOStatus,
	                              qx_Error => #sa_Status.FIFOError,
	                              qx_Warning => #sa_Status.FIFOWarning,
	                              iqv_Data := #sUDT_MessageArray,
	                              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                              iqv_DataBuffer := #iqa_FifoData);
	                END_IF;
	                
	            END_REGION
	            
	        END_IF;
	        
	        // In case of FIFO full, the FIFO full error bit and FIFO collective error bit are set
	    ELSE
	        
	        #sa_Status.FIFOError := TRUE;
	        #sa_Status.FIFOStatus.FifoFull := TRUE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION Close connection
	    
	    IF #iqUDT_FifoHeader.TotalEntriesStored = 0
	        AND (#ix_LogOffRequest OR #s_FB_TimerOnOffDelay_Connected.qx_DelayedSignal)
	    THEN
	        #iqx_Reconnect := TRUE;
	    END_IF;
	    
	    
	END_REGION
	
	
	REGION 3 - Writing output
	    
	    #qx_Error := #sa_Status.InvalidMsgArraySize         // Invalid message array size 
	    OR #sa_Status.FIFOError;                            // FIFO error
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_FedExPacketLengthMessage"
TITLE = FB_Heartbeat
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : UPS_SpecificCommunication
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 80
// END_ATTRIBUTES
//Function block to send and monitor the UPS heartbeat message.
   VAR_INPUT 
      iUDT_Facility { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FedExFacility";   // System configuration
      is_LOConEquipment { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[3];   // Location of the equipment
      is_DEPCOD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[6];   // Depot Code
      is_TYPofEquipment { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[3];   // Type of equipment
      is_NumberOfTheEquipment { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[3];   // Number of the equipment 001-999
      is_TrayCellNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[3];   // Tray/Cell number (for loop sorters) or generated by LLC (on line sorters).
      is_SorterNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[2];   // Sorter number
      is_InductionNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[2];   // Induction number
      is_AreaNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[2];   // Area number
      ii_Gin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // GIN number
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Error
   END_VAR

   VAR_IN_OUT 
      iqUDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqa_FifoData : Array[*] of "UDT_Message";   // FIFO data
      iqUDT_CustomerID : "UDT_FedExCustomerID";
   END_VAR

   VAR 
      sFB_FedExCustomerID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_FedExCustomerID";
      sUDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Message";   // Message character array
      sa_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";   // FIFO status structure
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO data buffer full
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO error
         InvalidGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Invalid GIN
         InvalidMessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Calculated message length is different than required
         InvalidMsgArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Length of the message is bigger than length of message array
      END_STRUCT;
      sa_Statistics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Statistics structure
         NotSentWrongMsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // COMISSIONING PURPOSE Messages not sent because built message length does not match with required message length
      END_STRUCT;
      ss_LLCSystemID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[15];   // Identifier of Low-Level controls
      ss_SequencialID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[6];   // Identifier of Low-Level controls
      ss_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Message character string
      ss_PackageID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Identifier of Low-Level controls
      ss_LEN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Length of message
      ss_Gap { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Parcel leading gap
      ss_GapUOM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Gap units
      ss_Length { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Parcel length
      sui_MsgArrayElNr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Message array size
      si_OldGin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Previous Gin
      si_StringLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length of string used in loops to pad string with spaces or 0
      si_LenFillLoop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Loop couter
      si_MaxMsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum message length
      si_MsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // String character message length
   END_VAR

   VAR CONSTANT 
      cc_NULL : Char := '$00';   // NULL sign
      cc_STX : Char := '$02';   // Start of the text
      cc_ETX : Char := '$03';   // End of the text
      cs_Length : String := '0081';   // Legth of the message
      cs_MessageType : String := 'PL';   // Message type
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	29/06/2021  | 1.0       | F.Baten       | first release MHS TIA 16.0
	10/11/2021  | 1.2       | M.Piela       | Updating regions numbering and interface changes
	05/04/2022  | 1.3       | K.Pokorski    | Review
	30/06/2022  | 1.4       | K.Pokorski    | Add cusotmer ID generation and swap GIN with Customer ID 
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #sa_Status.FIFOStatus,
	              qx_Error => #sa_Status.FIFOError,
	              qx_Warning => #sa_Status.FIFOWarning,
	              iqv_Data := #sUDT_MessageArray,
	              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	              iqv_DataBuffer := #iqa_FifoData);
	END_REGION
	
	REGION 2 - GIN validation
	    
	    // GIN validation
	    #sa_Status.InvalidGIN :=
	    #ii_Gin < 1
	    OR #ii_Gin > 9999;
	    
	END_REGION
	
	REGION 3 – Message preparation
	    
	    IF NOT #iqUDT_FifoHeader.Status.Full                 // FIFO isn't full
	    THEN
	        IF #ii_Gin <> #si_OldGin AND NOT #sa_Status.InvalidGIN
	            
	        THEN
	            REGION 3.1 - Sequencial ID
	                
	                // Assign CustomerID
	                #sFB_FedExCustomerID(ii_Gin := #ii_Gin,
	                                     iqUDT_CustomerID := #iqUDT_CustomerID);
	                
	                
	                // ss_SequencialID character string clearing
	                #ss_SequencialID := '';
	                
	                // ss_SequencialID double integer input conversion to a character string
	                VAL_STRG(IN := "DB_GIN".GIN[#ii_Gin].FedEx.CustomerID,
	                         SIZE := 0,
	                         PREC := 0,
	                         FORMAT := 0,
	                         P := 1,
	                         OUT => #ss_SequencialID);
	                // Length of the ss_SequencialID character string 
	                #si_StringLen := LEN(#ss_SequencialID);
	                
	                // ss_SequencialID character string leading zeros addition
	                IF (#si_StringLen < 6)
	                THEN
	                    FOR #si_LenFillLoop := 1 TO 6 - #si_StringLen DO
	                        #ss_SequencialID := CONCAT(IN1 := '0',
	                                                   IN2 := #ss_SequencialID);
	                    END_FOR;
	                END_IF;
	            END_REGION
	            
	            REGION 3.2 - LLC System ID
	                // Build LLC Syatem ID  
	                #ss_LLCSystemID := CONCAT(IN1 := #is_DEPCOD,
	                                          IN2 := #is_LOConEquipment,
	                                          IN3 := #is_TYPofEquipment,
	                                          IN4 := #is_NumberOfTheEquipment);
	            END_REGION
	            
	            REGION 3.3 - Package ID
	                // Build Package ID  
	                #ss_PackageID := CONCAT(IN1 := #is_TrayCellNumber,
	                                        IN2 := #is_SorterNumber,
	                                        IN3 := #is_InductionNumber,
	                                        IN4 := #is_AreaNumber,
	                                        IN5 := #ss_SequencialID);
	            END_REGION
	            
	            REGION 3.4 - Gap
	                // Gap character string clearing
	                #ss_Gap := '';
	                
	                IF ("DB_GIN".GIN[#ii_Gin].General.LeadingGap > 999)
	                THEN
	                    #ss_Gap := '999';
	                ELSE
	                    
	                    // Gap integer input conversion to a character string
	                    VAL_STRG(IN := "DB_GIN".GIN[#ii_Gin].General.LeadingGap,
	                             SIZE := 0,
	                             PREC := 0,
	                             FORMAT := 0,
	                             P := 1,
	                             OUT => #ss_Gap);
	                    // Length of the gap character string 
	                    #si_StringLen := LEN(#ss_Gap);
	                    // Gap character string leading zeros addition
	                    IF (#si_StringLen < 3)
	                    THEN
	                        FOR #si_LenFillLoop := 1 TO 3 - #si_StringLen DO
	                            #ss_Gap := CONCAT(IN1 := '0',
	                                              IN2 := #ss_Gap);
	                        END_FOR;
	                    END_IF;
	                END_IF;
	                #ss_GapUOM := 'CM';
	            END_REGION
	            
	            REGION 3.5 - Length
	                // Length character string clearing
	                #ss_Length := '';
	                // Gap integer input conversion to a character string
	                VAL_STRG(IN := "DB_GIN".GIN[#ii_Gin].General.Length,
	                         SIZE := 0,
	                         PREC := 0,
	                         FORMAT := 0,
	                         P := 1,
	                         OUT => #ss_Length);
	                // Length of the gap character string 
	                #si_StringLen := LEN(#ss_Length);
	                // Gap character string leading zeros addition
	                IF (#si_StringLen < 3)
	                THEN
	                    FOR #si_LenFillLoop := 1 TO 3 - #si_StringLen DO
	                        #ss_Length := CONCAT(IN1 := '0',
	                                             IN2 := #ss_Length);
	                    END_FOR;
	                END_IF;
	                
	            END_REGION
	            
	            
	            REGION 3.6 – Message preparation
	                // Message composing according to the structure: STX,BODY ,ETX
	                #ss_Message := CONCAT(IN1 := #cc_STX,
	                                      IN2 := #cs_Length,
	                                      IN3 := #cs_MessageType,
	                                      IN4 := #ss_LLCSystemID,
	                                      IN5 := #ss_PackageID,
	                                      IN6 := "DB_GIN".GIN[#ii_Gin].FedEx.PackageEntrancePoint,
	                                      IN7 := "DB_GIN".GIN[#ii_Gin].FedEx.PackageEntranceState,
	                                      IN8 := #ss_Gap,
	                                      IN9 := #ss_Length,
	                                      IN10 := #ss_GapUOM,
	                                      IN11 := "DB_Time".Timestamp,
	                                      IN12 := #iUDT_Facility.TimeZoneDesignator,
	                                      IN13 := #cc_ETX);
	                
	            END_REGION
	            
	            REGION 3.7 – Maximum number of the message characters
	                
	                #si_MaxMsgLen := "FC_GetNrOfArrayEl"(iv_Array := #sUDT_MessageArray.Character);
	                
	            END_REGION
	            
	            REGION 3.8 – Length of the complete message
	                
	                #si_MsgLen := LEN(#ss_Message);
	                
	                // Message length validation
	                #sa_Status.InvalidMessageLength := #si_MsgLen - 2 <> STRING_TO_INT(#cs_Length);
	                
	            END_REGION
	            
	            REGION 3.9 –  Message array size validation
	                
	                #sa_Status.InvalidMsgArraySize := #si_MsgLen > #si_MaxMsgLen;
	                
	            END_REGION
	            
	            REGION 3.10 –  Message character string conversion to a message array of characters
	                
	                IF (NOT #sa_Status.InvalidMsgArraySize)     // Message character array size is valid 
	                THEN
	                    
	                    Strg_TO_Chars(Strg := #ss_Message,
	                                  pChars := 0,
	                                  Cnt => #sui_MsgArrayElNr,
	                                  Chars := #sUDT_MessageArray.Character);
	                    
	                END_IF;
	                
	            END_REGION
	            
	            REGION 3.11 – Clearing remaining characters in the message character array
	                
	                IF (NOT #sa_Status.InvalidMsgArraySize)     // Message character array size is valid 
	                THEN
	                    
	                    // Filling up not used message character array elements with '$00' (ASCII - 16#00)
	                    FILL_BLK(IN := #cc_NULL,
	                             COUNT := UINT_TO_ULINT(INT_TO_UINT(#si_MaxMsgLen) - #sui_MsgArrayElNr),
	                             OUT => #sUDT_MessageArray.Character[#sui_MsgArrayElNr]);
	                    
	                END_IF;
	                
	            END_REGION
	            
	            REGION 3.12 – Message write into a FIFO register
	                
	                IF NOT #sa_Status.InvalidMsgArraySize          // Message character array size is valid 
	                    AND NOT #sa_Status.InvalidMessageLength     // Message length size validation
	                THEN
	                    
	                    // Mode 'W' - Write FIFO record
	                    "FC_Fifo"(ic_Mode := 'W',
	                              qUDT_Status => #sa_Status.FIFOStatus,
	                              qx_Error => #sa_Status.FIFOError,
	                              qx_Warning => #sa_Status.FIFOWarning,
	                              iqv_Data := #sUDT_MessageArray,
	                              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                              iqv_DataBuffer := #iqa_FifoData);
	                ELSE
	                    // Increase counter messages not sent because of wrong message length 
	                    #sa_Statistics.NotSentWrongMsgLen += 1;
	                    
	                    
	                END_IF;
	                
	            END_REGION
	            #si_OldGin := #ii_Gin;
	        END_IF;
	        // In case of FIFO full, the FIFO full error bit and FIFO collective error bit are set
	    ELSE
	        
	        #sa_Status.FIFOError := TRUE;
	        #sa_Status.FIFOStatus.FifoFull := TRUE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Writing outputs
	    
	    #qx_Error := #sa_Status.InvalidMessageLength        // Invalid message length
	    OR #sa_Status.InvalidGIN                            // Invalid GIN 
	    OR #sa_Status.InvalidMsgArraySize                   // Invalid message array size 
	    OR #sa_Status.FIFOError;                            // FIFO error
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_FedExChute2Brakes1Stop"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 237
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_ChuteConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_Chute3BrakesConfiguration";   // Chute configuration structure
      iUDT_Facility { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FedExFacility";   // System configuration
      ix_PECChuteFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when chute full photoye is not blocked
      ix_PECBrakeTop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when first (Top) brake assembly photoye is not blocked
      ix_PECBrakeMiddle { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when second (Middle) brake assembly photoye is not blocked
      ix_PECBrakeBottom { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when third (End Stop) brake assembly photoye is not blocked
      ix_PECStopTop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when first/Top brake assembly photoye is not blocked
      ix_PECStopMiddle { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when second/Middle brake assembly photoye is not blocked
      ix_PECStopBottom { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when third/(End Stop) brake assembly photoye is not blocked
      ix_ChuteJam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when external jam appear
      ix_SafetyOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when safety is ok
      ix_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when hardware is ok
      ix_EnergySave { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when enery save is active
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_Chute3BrakeStatus";   // HMI status structure
      qUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   // Common status structure
      qUDT_StatusToXBS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_XBSChuteInterfaceSend";
      qx_Lamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Chute Lamp Jam/Full
      qx_BrakeValve1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // First brake valve assembly
      qx_BrakeValve2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Second brake valve  assembly
      qx_BrakeValve3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Third brake valve assembly
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
      iqUDT_Statistics : "UDT_Chute3BrakeStatistics";   // Statistics structure
      iqUDT_HandShake : "UDT_ConveyorHandshake";   // Downstream handshake structure
      iqUDT_HandShakeUp : "UDT_ConveyorHandshake";   // Upstream handshake structure
      iqUDT_ChuteCommand : "UDT_Chute3BrakeCommand";   // Command strucutre
      iqUDT_FifoHighPriorityHLC : "UDT_FifoHeader";   // FIFO UDS send Header
      iqa_FifoHighPriorityHLC : Array[*] of "UDT_Message";   // FIFO UDS send data
   END_VAR

   VAR 
      sUDT_CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Common status structure
      sUDT_CommonStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Auxiliary status structure
      sUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Chute3BrakeStatus";   // HMI status structure
      sUDT_Configuration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Chute3BrakesConfiguration";   // Auxiliary equipment control structure
      sFB_PneumaticBrakeUnitAssemby1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PneumaticBrakeUnit";   // Function to control a first pneumatic brake contol
      sFB_PneumaticBrakeUnitAssemby2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PneumaticBrakeUnit";   // Function to control a secound pneumatic brake contol
      sFB_StopRoller { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_StopRoller";   // Function to control stoping of the roller
      sFB_FedExEquipmentStatusMessage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_FedExEquipmentStatusMessage";   // Equipment status structure message
      sFB_TimerOnOffDelayPECFul { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Filtering full photo eye signal
      sFB_TimerOnOffDelayPECHalfFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Filtering half full photo eye signal
      sFB_TimerOnOffDelayPECMiddle { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Filtering middle photo eye signal
      sFB_TimerOnOffDelayStopRollerLongBrakePause { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Filtering common signal from all signals needed to increase brake pause
      sR_TRIG_ChuteFull {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge to chute full
      sR_TRIG_ChuteJam {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge to chute jam
      sR_TRIG_ChuteHalfFull {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge to chute half full
      sR_TRIG_DisableFromHMI {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge to disable chute from HMI
      sR_TRIG_DisableFromHLC {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge to disable chute from HLC
      sF_TRIG_UpdateStatus {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;
      ss_StatusCode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[3];   // Status code
      sx_MasterValve { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Master valve
      sx_StopActive1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // First brake valve assembly is active
      sx_StopActive2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Second brake valve assembly is active
      sx_StopActive3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Third brake valve assembly is active
      sx_PECFullFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Delayed full photo eye signal
      sx_PECHalfFullFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Delayed half full photo eye signal
      sx_PECMiddleFullFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Delayed middle full photo eye signal
      sx_StopRollerLongBrakePauseDelayed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Delayed common signal from all signals needed to increase brake pause
      sx_StopRollerLongBrakePause { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Common signal from all signals needed to increase brake pause
      sx_ChuteFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Full status
      sx_ChuateHalfFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Half full occupation status
      sx_ChuteJam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Jam status
      sx_MessageError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message error
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	23/06/2021  | 0.0       | F. Baten      | first release TIA 15.1
	20/10/2021  | 0.1       | M. Piela      | Add statuses and statistics. Stylistic correction
	21/10/2021  | 0.2       | M. Piela      | Change brake stopper pause based on all pec delayed signal
	02/02/2022  | 0.3       | M. Piela      | Add Equipment status message   
	22/02/2022  | 0.4       | M. Piela      | Update HMI Status
	04/04/2022  | 0.5       | S. Deulkar    | Updated status for XBS sorter
	25/06/2022  | 0.6       | M. Kurpiers   | Interface update
	25/06/2022  | 0.7       | M. Piela      | #sx_MasterValve inverted to top brake
	19/07/2022  | 0.8       | M. Piela      | Add external chute jam to the status
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	 *)
	
	REGION 1 - Write input status
	    
	    IF #ix_HardwareOk
	    THEN
	        #sUDT_HMIStatus.Specific.DisableFromHMI := #iqUDT_ChuteCommand.DisableFromHMI;
	        #sUDT_HMIStatus.Specific.DisableFromHLC := #iqUDT_ChuteCommand.DisableFromHLC;
	        #sUDT_HMIStatus.Specific.ChuteFull := #sx_ChuteFull;
	        #sUDT_HMIStatus.Specific.ChuteHalfFull := #sx_ChuateHalfFull;
	        #sUDT_HMIStatus.Specific.ChuteJam := #sx_ChuteJam OR #ix_ChuteJam;
	        #sUDT_HMIStatus.Specific.BrakeFaultTop := FALSE;
	        #sUDT_HMIStatus.Specific.BrakeFaultMiddle := FALSE;
	        #sUDT_HMIStatus.Specific.BrakeFaultBottom := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Triggers
	    
	    // Rising edge trigger full PEC status
	    #sR_TRIG_ChuteFull(CLK := #sx_ChuteFull);
	    
	    // Rissing edge trigger jam PEC status
	    #sR_TRIG_ChuteJam(CLK := #sx_ChuteJam);
	    
	    // Rissing edge trigger hafl full PEC status
	    #sR_TRIG_ChuteHalfFull(CLK := #sx_ChuateHalfFull);
	    
	    // Rising edge trigger disable from HMI
	    #sR_TRIG_DisableFromHMI(CLK := #sUDT_HMIStatus.Specific.DisableFromHMI);
	    
	    // Rising edge trigger disable from MFC
	    #sR_TRIG_DisableFromHLC(CLK := #sUDT_HMIStatus.Specific.DisableFromHLC);
	    
	END_REGION
	
	REGION 3 - Timers
	    
	    // Filtering full photo eye signal
	    #sFB_TimerOnOffDelayPECFul(iudi_OnDelayTime := #iUDT_ChuteConfiguration.PECFullOnDelay,
	                               iudi_OffDelayTime := #iUDT_ChuteConfiguration.PECFullOffDelay,
	                               ix_SignalToDelay := #ix_PECChuteFull,
	                               ix_Enable := TRUE,
	                               qx_DelayedSignal => #sx_PECFullFiltered);
	    
	    //Filtering Half full photo eye signal
	    #sFB_TimerOnOffDelayPECHalfFull(iudi_OnDelayTime := #iUDT_ChuteConfiguration.PECHalfFullOnDelay,
	                                    iudi_OffDelayTime := #iUDT_ChuteConfiguration.PECHalfFullOffDelay,
	                                    ix_SignalToDelay := #ix_PECStopTop,
	                                    ix_Enable := TRUE,
	                                    qx_DelayedSignal => #sx_PECHalfFullFiltered);
	    
	    //Filtering middle photo eye signal
	    #sFB_TimerOnOffDelayPECMiddle(iudi_OnDelayTime := #iUDT_ChuteConfiguration.PECMiddleOnDelay,
	                                  iudi_OffDelayTime := #iUDT_ChuteConfiguration.PECMiddleOffDelay,
	                                  ix_SignalToDelay := #ix_PECStopMiddle,
	                                  ix_Enable := TRUE,
	                                  qx_DelayedSignal => #sx_PECMiddleFullFiltered);
	    
	    // Create common signal from all signals needed to increase brake pause
	    #sx_StopRollerLongBrakePause := #ix_PECBrakeMiddle
	    AND #ix_PECStopMiddle
	    AND #iqUDT_HandShake.RTR;     // Downstream conveyor is running
	    
	    //Filtering common signal from all signals needed to increase brake pause
	    #sFB_TimerOnOffDelayStopRollerLongBrakePause(iudi_OnDelayTime := #iUDT_ChuteConfiguration.LongBrakePauseOnDelay,
	                                                 ix_SignalToDelay := #sx_StopRollerLongBrakePause,
	                                                 ix_Enable := TRUE,
	                                                 qx_DelayedSignal => #sx_StopRollerLongBrakePauseDelayed);
	    
	END_REGION
	
	REGION 4 - Brake assembly
	    
	    // Control first pneumatic break unit assembly
	    #sFB_PneumaticBrakeUnitAssemby1(iUDT_PneumaticBreakConfiguration := #iUDT_ChuteConfiguration.BrakeConfiguration1,
	                                    ix_PECBrake := #ix_PECBrakeTop,
	                                    ix_PECStop := #ix_PECStopTop,
	                                    ix_PECdownstream := #ix_PECBrakeMiddle,
	                                    ix_DownstreamStopActive := #sx_StopActive2,
	                                    ix_MasterValve := NOT #sx_MasterValve,
	                                    ix_SafetyOk := #ix_SafetyOk,
	                                    qx_Valve => #qx_BrakeValve1,
	                                    qx_StopActive => #sx_StopActive1,
	                                    iqUDT_EquipmentControl := #iqUDT_EquipmentControl);
	    
	    // Control secound pneumatic break unit assembly
	    #sFB_PneumaticBrakeUnitAssemby2(iUDT_PneumaticBreakConfiguration := #iUDT_ChuteConfiguration.BrakeConfiguration2,
	                                    ix_PECBrake := #ix_PECBrakeMiddle,
	                                    ix_PECStop := #ix_PECStopMiddle,
	                                    ix_PECdownstream := #ix_PECBrakeBottom,
	                                    ix_DownstreamStopActive := #sx_StopActive3,
	                                    ix_SafetyOk := #ix_SafetyOk,
	                                    qx_Valve => #sx_MasterValve,
	                                    qx_StopActive => #sx_StopActive2,
	                                    iqUDT_EquipmentControl := #iqUDT_EquipmentControl);
	    
	    // Control stop roller section
	    #sFB_StopRoller(iUDT_StopRollerConfiguration := #iUDT_ChuteConfiguration.StopperConfiguration,
	                    ix_Pressure := #ix_PECStopMiddle,
	                    ix_PECBrake := #ix_PECBrakeBottom,
	                    ix_PECStop := #ix_PECStopBottom,
	                    ix_DownstreamStopActive := NOT #iqUDT_HandShake.RTR,
	                    ix_SafetyOk := #ix_SafetyOk,
	                    ix_BrakePauseLong := #sx_StopRollerLongBrakePauseDelayed,
	                    qx_Valve => #qx_BrakeValve3,
	                    qx_StopActive => #sx_StopActive3,
	                    iqUDT_EquipmentControl := #iqUDT_EquipmentControl);
	    
	    #qx_BrakeValve2 := #sx_MasterValve;
	    
	END_REGION
	
	REGION 5 - Filling level   
	    
	    //Half full
	    IF NOT #sx_PECMiddleFullFiltered AND NOT #sx_PECHalfFullFiltered
	    THEN
	        #sx_ChuateHalfFull := TRUE;
	    END_IF;
	    IF #sx_PECMiddleFullFiltered AND #sx_PECHalfFullFiltered
	    THEN
	        #sx_ChuateHalfFull := FALSE;
	    END_IF;
	    
	    //Full
	    IF NOT #sx_PECHalfFullFiltered AND NOT #"sx_PECFullFiltered"
	    THEN
	        #sx_ChuteFull := TRUE;
	    END_IF;
	    IF #sx_PECHalfFullFiltered AND #"sx_PECFullFiltered"
	    THEN
	        #sx_ChuteFull := FALSE;
	    END_IF;
	    
	    // Jam
	    #sx_ChuteJam := #sx_PECHalfFullFiltered AND NOT #"sx_PECFullFiltered";
	    
	END_REGION
	
	REGION 6 - Output
	    
	    //Lamp signal enable
	    #qx_Lamp := NOT (#ix_ChuteJam OR #sx_ChuteJam) AND ((#sx_ChuteFull)
	    OR (#sx_ChuateHalfFull AND "DB_Memory"."Clock_1Hz"))
	    OR (#ix_ChuteJam OR #sx_ChuteJam) AND "DB_Memory"."Clock_2Hz";
	    
	    //Send RTR signal to the sorter
	    #iqUDT_HandShakeUp.RTR := #ix_SafetyOk AND NOT (#ix_ChuteJam OR #sx_ChuteFull)
	    AND NOT #iqUDT_ChuteCommand.DisableFromHMI
	    AND NOT #iqUDT_ChuteCommand.DisableFromHLC;
	    
	END_REGION
	
	REGION 7 - Statistics
	    
	    // Chute disable from HMI.
	    IF #sUDT_HMIStatus.Specific.DisableFromHMI
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.DisableFromHMI,
	                        ix_RTrigActivate := #sR_TRIG_DisableFromHMI.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.DisableFromHMI);
	    END_IF;
	    
	    // Chute disable from HLC
	    IF #sUDT_HMIStatus.Specific.DisableFromHLC
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.DisableFromHLC,
	                        ix_RTrigActivate := #sR_TRIG_DisableFromHLC.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.DisableFromHLC);
	    END_IF;
	    
	    //Chute full
	    IF #sUDT_HMIStatus.Specific.ChuteFull
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.ChuteFull,
	                        ix_RTrigActivate := #sR_TRIG_ChuteFull.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.ChuteFull);
	        
	    END_IF;
	    
	    //Chute half full
	    IF #sUDT_HMIStatus.Specific.ChuteHalfFull
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.ChuteHalfFull,
	                        ix_RTrigActivate := #sR_TRIG_ChuteHalfFull.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.ChuteHalfFull);
	        
	    END_IF;
	    
	    //Chute jam
	    IF #sUDT_HMIStatus.Specific.ChuteJam
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.ChuteJam,
	                        ix_RTrigActivate := #sR_TRIG_ChuteJam.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.ChuteJam);
	        
	    END_IF;
	    
	END_REGION
	
	REGION 8 - Status
	    
	    //Error active
	    #sUDT_CommonStatus.Error := NOT #ix_HardwareOk OR NOT #ix_SafetyOk OR #sx_ChuteJam;
	    
	    //Automation ON
	    #sUDT_CommonStatus.AutoON := #iqUDT_EquipmentControl.Command.AutomaticOn;
	    
	    // Energy save active
	    #sUDT_CommonStatus.EnergySave := #ix_EnergySave;
	    
	    // Running
	    #sUDT_CommonStatus.Running := #sUDT_CommonStatus.AutoON AND NOT #sUDT_CommonStatus.Error;
	    
	    // Stopped 
	    #sUDT_CommonStatus.Stopped := NOT #sUDT_CommonStatus.AutoON OR #sUDT_CommonStatus.Error;
	    
	    // Safety not ok
	    #sUDT_CommonStatus.SafetyStop := NOT #ix_SafetyOk;
	    
	    // Chute disabled
	    IF #sUDT_HMIStatus.Specific.DisableFromHMI OR #sUDT_HMIStatus.Specific.DisableFromHLC AND NOT #sUDT_CommonStatus.SafetyStop
	    THEN
	        #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".DisableByManagement;
	    END_IF;
	    
	    // Chute Half Full
	    IF #sUDT_HMIStatus.Specific.ChuteHalfFull AND NOT #sUDT_CommonStatus.SafetyStop
	    THEN
	        #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".ChuteHalfFull;
	    END_IF;
	    
	    //Chute Full
	    IF #sUDT_HMIStatus.Specific.ChuteFull AND NOT #sUDT_CommonStatus.SafetyStop
	    THEN
	        #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".ChuteFull;
	    END_IF;
	    
	    //Chute Jam
	    IF #sUDT_HMIStatus.Specific.ChuteJam AND NOT #sUDT_CommonStatus.SafetyStop
	    THEN
	        #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".PECJam;
	    END_IF;
	    
	    //Collecting F_TRIG on chute full, half full, jam or chute disabled status to update common status
	    #sF_TRIG_UpdateStatus(CLK := #sUDT_HMIStatus.Specific.ChuteHalfFull OR #sUDT_HMIStatus.Specific.ChuteFull
	                          OR #sUDT_HMIStatus.Specific.ChuteJam OR #sUDT_HMIStatus.Specific.DisableFromHMI
	                          OR #sUDT_HMIStatus.Specific.DisableFromHLC);
	    
	    // HMI status update
	    IF #sUDT_CommonStatusOld <> #sUDT_CommonStatus OR #sF_TRIG_UpdateStatus.Q  // update on change
	    THEN
	        // HMI status initialization
	        #sUDT_HMIStatus.Status := 0;
	        
	        // Energy save
	        IF #sUDT_CommonStatus.EnergySave
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".EnergySave;
	        END_IF;
	        
	        // Running
	        IF #sUDT_CommonStatus.Running
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Running;
	        END_IF;
	        
	        // Stopped
	        IF #sUDT_CommonStatus.Stopped
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Stopped;
	        END_IF;
	        
	        // Error
	        IF #sUDT_CommonStatus.Error
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Stopped;
	        END_IF;
	        
	        // Safety stop
	        IF #sUDT_CommonStatus.SafetyStop
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".SafetyStop;
	        END_IF;
	        
	        #sUDT_CommonStatusOld := #sUDT_CommonStatus;              // Copy status to memory
	        #qUDT_Status := #sUDT_CommonStatus;                       // Copy status to output
	        
	    END_IF;
	    
	    // Copy HMI status to output
	    #qUDT_HMIStatus := #sUDT_HMIStatus;
	    
	END_REGION
	
	REGION 9 - Report to control block
	    
	    // Function to manage report between control block and conveyor block
	    "FC_EquipmentReport"(iUDT_Status := #sUDT_CommonStatus,
	                         iqUDT_Control := #iqUDT_EquipmentControl);
	    
	END_REGION
	
	REGION 10 - Equipment staus message 
	    
	    IF NOT #iqUDT_EquipmentControl.Command.AutomaticOn
	    THEN
	        #ss_StatusCode := '006'; //Inactive
	    ELSIF #sx_ChuteJam
	    THEN
	        #ss_StatusCode := '002';  //Chute Jam
	    ELSIF #sx_ChuteFull
	    THEN
	        #ss_StatusCode := '003';  // Chute Full
	    ELSIF #sx_ChuateHalfFull
	    THEN
	        #ss_StatusCode := '004';  // Chute Half full
	    ELSIF #iqUDT_ChuteCommand.DisableFromHMI OR #iqUDT_ChuteCommand.DisableFromHLC
	    THEN
	        #ss_StatusCode := '005'; // Chute Disabled
	    ELSE
	        #ss_StatusCode := '001'; //Chute is Clear
	    END_IF;
	    
	    #sFB_FedExEquipmentStatusMessage(iUDT_Facility := #iUDT_Facility,
	                                     is_LOConEquipment := #iUDT_ChuteConfiguration.LOConEquipment, // Sorter number
	                                     is_DEPCOD := #iUDT_ChuteConfiguration.DEPCOD,
	                                     is_TYPofEquipment := 'PLC',
	                                     is_NumberOfTheEquipment := #iUDT_ChuteConfiguration.NumberOfTheEquipment,// PLC number
	                                     is_DeviceType := 'CHUTES',
	                                     is_DeviceID := #iUDT_ChuteConfiguration."Device ID", //Chute number
	                                     is_StatusCode := #ss_StatusCode,
	                                     qx_Error => #sx_MessageError,
	                                     iqUDT_FifoHeader := #iqUDT_FifoHighPriorityHLC,
	                                     iqa_FifoData := #iqa_FifoHighPriorityHLC);
	    
	END_REGION
	
	REGION 11 XBS interface
	    // Map chute status to sorter
	    #qUDT_StatusToXBS.Full := #sUDT_HMIStatus.Specific.ChuteFull;
	    #qUDT_StatusToXBS.HalfFull := #sUDT_HMIStatus.Specific.ChuteHalfFull;
	    #qUDT_StatusToXBS.ReadyToReceive := NOT #sUDT_CommonStatus.Error AND #sUDT_CommonStatus.AutoON;
	    #qUDT_StatusToXBS.Running := #sUDT_CommonStatus.Running;
	    #qUDT_StatusToXBS.Fault := #sUDT_CommonStatus.Error;
	    #qUDT_StatusToXBS.Warning := #sUDT_CommonStatus.Warning;
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_FedExPolisorterGlobalEquipmentStatus"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 81
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_FedExFacility { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FedExFacility";   // System configuration
      is_LOConEquipment { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[3];   // Location of the equipment
      is_DEPCOD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[6];   // Depot Code
      is_TYPofEquipment { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[3];   // Type of equipment
      is_NumberOfTheEquipment { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[3];   // Number of the equipment 001-999
      ix_Chute1Jam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Chute 1 jam error
      is_Chute1Name { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[6];   // Chute 1 physical name
      iUDT_Chute1Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";
      ix_Chute2Jam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Chute 2 jam error
      is_Chute2Name { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[6];   // Chute 2 physical name
      i_UDT_Chute2Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";
      ix_Chute3Jam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Chute 3 jam error
      is_Chute3Name { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[6];   // Chute 3 physical name
      iUDT_Chute3Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";
      ix_Chute4Jam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Chute 4 jam error
      is_Chute4Name { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[6];   // Chute 4 physical name
      iUDT_Chute4Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";
      ix_Chute5Jam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Chute 5 jam error
      is_Chute5Name { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[6];   // Chute 5 physical name
      iUDT_Chute5Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";
      ix_Chute6Jam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Chute 6 jam error
      is_Chute6Name { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[6];   // Chute 6 physical name
      iUDT_Chute6Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";
      ix_Chute7Jam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      is_Chute7Name { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[6];
      iUDT_Chute7Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";
      ix_Chute8Jam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      is_Chute8Name { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[6];
      iUDT_Chute8Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";
      ix_Chute9Jam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      is_Chute9Name { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[6];
      iUDT_Chute9Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";
      ix_Chute10Jam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      is_Chute10Name { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[6];
      iUDT_Chute10Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";
      ix_Polisorter1Jam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Polisorter 1 jam error
      ix_Polisorter2Jam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Polisorter 2 jam error
      ix_Polisorter3Jam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Polisorter 3 jam error
      ix_Polisorter4Jam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Polisorter 4 jam error
      iUDT_Polisorter1CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   // Polisorter 1 common status
      iUDT_Polisorter2CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   // Polisorter 2 common status
      iUDT_Polisorter3CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   // Polisorter 3 common status
      iUDT_Polisorter4CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   // Polisorter 4 common status
   END_VAR

   VAR_IN_OUT 
      iUDT_FedExCommands : "UDT_FedExCommands";   // Commands sent by uDS
      iqUDT_FifoHeader : "UDT_FifoHeader";   // Fifo header
      iqa_FifoData : Array[*] of "UDT_Message";   // Fifo data
   END_VAR

   VAR 
      sFB_FedExEquipmentStatusMessageChutes { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_FedExEquipmentStatusMessage";   // Equipment status message for chutes
      sFB_FedExEquipmentStatusMessageSorter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_FedExEquipmentStatusMessage";   // Equipment status message for sorter
      sa_ChuteStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..10] of String[3];   // Chute status array
      sa_ChuteStatus_OLD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..10] of String[3];   // ChuteStatusOLD
      sa_ChuteName { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..10] of String[6];   // Chute name array
      ss_SorterStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[3];   // Sorter status
      ss_SorterStatus_OLD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[3];   // Sorter status OLD
      sR_TRIG_SorterEstop {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Sorter Estop R_TRIG
      sR_TRIG_SorterJam {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Sorter Jam R_TRIG
      sR_TRIG_SorterStopped {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Sorter stop R_TRIG
      sR_TRIG_SorterRunning {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Sorter running R_TRIG
      sFB_TimerOnOffDelay_FullChute1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sFB_TimerOnOffDelay_FullChute2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sFB_TimerOnOffDelay_FullChute3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sFB_TimerOnOffDelay_FullChute4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sFB_TimerOnOffDelay_FullChute5 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sFB_TimerOnOffDelay_FullChute6 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sFB_TimerOnOffDelay_FullChute7 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sFB_TimerOnOffDelay_FullChute8 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sFB_TimerOnOffDelay_FullChute9 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sFB_TimerOnOffDelay_FullChute10 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
   END_VAR

   VAR_TEMP 
      ti_i : Int;
   END_VAR

   VAR CONSTANT 
      ChuteFullDelay : UDInt := 2000;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	26/04/2022  | 1.0       | K. Pokorski   | first release MHS TIA 16.0
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Copy chutes name
	    
	    #sa_ChuteName[1] := #is_Chute1Name;
	    #sa_ChuteName[2] := #is_Chute2Name;
	    #sa_ChuteName[3] := #is_Chute3Name;
	    #sa_ChuteName[4] := #is_Chute4Name;
	    #sa_ChuteName[5] := #is_Chute5Name;
	    #sa_ChuteName[6] := #is_Chute6Name;
	    #sa_ChuteName[7] := #is_Chute7Name;
	    #sa_ChuteName[8] := #is_Chute8Name;
	    #sa_ChuteName[9] := #is_Chute9Name;
	    #sa_ChuteName[10] := #is_Chute10Name;
	    
	END_REGION
	
	REGION 2 - Creating chute status
	    
	    #sFB_TimerOnOffDelay_FullChute1(iudi_OnDelayTime := #ChuteFullDelay,
	                                    ix_SignalToDelay := #iUDT_Chute1Status.Dieback OR #iUDT_Chute1Status.Halted);
	    
	    
	    IF #ix_Chute1Jam THEN
	        #sa_ChuteStatus[1] := '002';
	    ELSIF #sFB_TimerOnOffDelay_FullChute1.qx_DelayedSignal THEN
	        #sa_ChuteStatus[1] := '003';
	        // ELSIF NOT #i_UDT_Chute1Status.AutoON THEN
	        //     #sa_ChuteStatus[1] := '006';
	    ELSE
	        #sa_ChuteStatus[1] := '001';
	    END_IF;
	    
	    #sFB_TimerOnOffDelay_FullChute2(iudi_OnDelayTime := #ChuteFullDelay,
	                                    ix_SignalToDelay := #i_UDT_Chute2Status.Dieback OR #i_UDT_Chute2Status.Halted);
	    
	    IF #ix_Chute2Jam THEN
	        #sa_ChuteStatus[2] := '002';
	    ELSIF #sFB_TimerOnOffDelay_FullChute2.qx_DelayedSignal THEN
	        #sa_ChuteStatus[2] := '003';
	        // ELSIF NOT #i_UDT_Chute2Status.AutoON THEN
	        //     #sa_ChuteStatus[2] := '006';
	    ELSE
	        #sa_ChuteStatus[2] := '001';
	    END_IF;
	    
	    #sFB_TimerOnOffDelay_FullChute3(iudi_OnDelayTime := #ChuteFullDelay,
	                                    ix_SignalToDelay := #iUDT_Chute3Status.Dieback OR #iUDT_Chute3Status.Halted);
	    
	    IF #ix_Chute3Jam THEN
	        #sa_ChuteStatus[3] := '002';
	    ELSIF #sFB_TimerOnOffDelay_FullChute3.qx_DelayedSignal THEN
	        #sa_ChuteStatus[3] := '003';
	        // ELSIF NOT #i_UDT_Chute3Status.AutoON THEN
	        //     #sa_ChuteStatus[3] := '006';
	    ELSE
	        #sa_ChuteStatus[3] := '001';
	    END_IF;
	    
	    #sFB_TimerOnOffDelay_FullChute4(iudi_OnDelayTime := #ChuteFullDelay,
	                                    ix_SignalToDelay := #iUDT_Chute4Status.Dieback OR #iUDT_Chute4Status.Halted);
	    
	    IF #ix_Chute4Jam THEN
	        #sa_ChuteStatus[4] := '002';
	    ELSIF #sFB_TimerOnOffDelay_FullChute4.qx_DelayedSignal THEN
	        #sa_ChuteStatus[4] := '003';
	        // ELSIF NOT #i_UDT_Chute4Status.AutoON THEN
	        //     #sa_ChuteStatus[4] := '006';
	    ELSE
	        #sa_ChuteStatus[4] := '001';
	    END_IF;
	    
	    #sFB_TimerOnOffDelay_FullChute5(iudi_OnDelayTime := #ChuteFullDelay,
	                                    ix_SignalToDelay := #iUDT_Chute5Status.Dieback OR #iUDT_Chute5Status.Halted);
	    
	    IF #ix_Chute5Jam THEN
	        #sa_ChuteStatus[5] := '002';
	    ELSIF #sFB_TimerOnOffDelay_FullChute5.qx_DelayedSignal THEN
	        #sa_ChuteStatus[5] := '003';
	        // ELSIF NOT #i_UDT_Chute5Status.AutoON THEN
	        //     #sa_ChuteStatus[5] := '006';
	    ELSE
	        #sa_ChuteStatus[5] := '001';
	    END_IF;
	    
	    #sFB_TimerOnOffDelay_FullChute6(iudi_OnDelayTime := #ChuteFullDelay,
	                                    ix_SignalToDelay := #iUDT_Chute6Status.Dieback OR #iUDT_Chute6Status.Halted);
	    
	    IF #ix_Chute6Jam THEN
	        #sa_ChuteStatus[6] := '002';
	    ELSIF #sFB_TimerOnOffDelay_FullChute6.qx_DelayedSignal THEN
	        #sa_ChuteStatus[6] := '003';
	        // ELSIF NOT #i_UDT_Chute6Status.AutoON THEN
	        //     #sa_ChuteStatus[6] := '006';
	    ELSE
	        #sa_ChuteStatus[6] := '001';
	    END_IF;
	    
	    
	    #sFB_TimerOnOffDelay_FullChute7(iudi_OnDelayTime := #ChuteFullDelay,
	                                    ix_SignalToDelay := #iUDT_Chute7Status.Dieback OR #iUDT_Chute7Status.Halted);
	    
	    
	    IF #ix_Chute7Jam THEN
	        #sa_ChuteStatus[7] := '002';
	    ELSIF #sFB_TimerOnOffDelay_FullChute7.qx_DelayedSignal THEN
	        #sa_ChuteStatus[7] := '003';
	        // ELSIF NOT #i_UDT_Chute7Status.AutoON THEN
	        //     #sa_ChuteStatus[7] := '006';
	    ELSE
	        #sa_ChuteStatus[7] := '001';
	    END_IF;
	    
	    #sFB_TimerOnOffDelay_FullChute8(iudi_OnDelayTime := #ChuteFullDelay,
	                                    ix_SignalToDelay := #iUDT_Chute8Status.Dieback OR #iUDT_Chute8Status.Halted);
	    
	    IF #ix_Chute8Jam THEN
	        #sa_ChuteStatus[8] := '002';
	    ELSIF #sFB_TimerOnOffDelay_FullChute8.qx_DelayedSignal THEN
	        #sa_ChuteStatus[8] := '003';
	        // ELSIF NOT #i_UDT_Chute8Status.AutoON THEN
	        //     #sa_ChuteStatus[8] := '006';
	    ELSE
	        #sa_ChuteStatus[8] := '001';
	    END_IF;
	    
	    #sFB_TimerOnOffDelay_FullChute9(iudi_OnDelayTime := #ChuteFullDelay,
	                                    ix_SignalToDelay := #iUDT_Chute9Status.Dieback OR #iUDT_Chute9Status.Halted);
	    
	    IF #ix_Chute9Jam THEN
	        #sa_ChuteStatus[9] := '002';
	    ELSIF #sFB_TimerOnOffDelay_FullChute9.qx_DelayedSignal THEN
	        #sa_ChuteStatus[9] := '003';
	        // ELSIF NOT #i_UDT_Chute9Status.AutoON THEN
	        //     #sa_ChuteStatus[9] := '006';
	    ELSE
	        #sa_ChuteStatus[9] := '001';
	    END_IF;
	    
	    #sFB_TimerOnOffDelay_FullChute10(iudi_OnDelayTime := #ChuteFullDelay,
	                                     ix_SignalToDelay := #iUDT_Chute10Status.Dieback OR #iUDT_Chute10Status.Halted);
	    
	    IF #ix_Chute10Jam THEN
	        #sa_ChuteStatus[10] := '002';
	    ELSIF #sFB_TimerOnOffDelay_FullChute10.qx_DelayedSignal THEN
	        #sa_ChuteStatus[10] := '003';
	        // ELSIF NOT #i_UDT_Chute10Status.AutoON THEN
	        //     #sa_ChuteStatus[10] := '006';
	    ELSE
	        #sa_ChuteStatus[10] := '001';
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Sending equipment status message for chutes
	    
	    FOR #ti_i := 1 TO 10 DO
	        
	        IF #sa_ChuteStatus_OLD[#ti_i] <> #sa_ChuteStatus[#ti_i]
	            OR #iUDT_FedExCommands.UploadChuteStatus.NewMessage
	            OR #iUDT_FedExCommands.UploadAllStatus.NewMessage
	        THEN
	            
	            #sFB_FedExEquipmentStatusMessageChutes(iUDT_Facility := #iUDT_FedExFacility,
	                                                   is_LOConEquipment := #is_LOConEquipment,
	                                                   is_DEPCOD := #is_DEPCOD,
	                                                   is_TYPofEquipment := #is_TYPofEquipment,
	                                                   is_NumberOfTheEquipment := #is_NumberOfTheEquipment,
	                                                   is_DeviceType := 'CHUTES',
	                                                   is_DeviceID := #sa_ChuteName[#ti_i],
	                                                   is_StatusCode := #sa_ChuteStatus[#ti_i],
	                                                   iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                                                   iqa_FifoData := #iqa_FifoData);
	        END_IF;
	        
	        
	    END_FOR;
	    
	END_REGION
	
	REGION 4 - Detecting triggers in sorter status
	    
	    #sR_TRIG_SorterEstop(CLK := #iUDT_Polisorter1CommonStatus.SafetyStop
	                         OR #iUDT_Polisorter2CommonStatus.SafetyStop
	                         OR #iUDT_Polisorter3CommonStatus.SafetyStop
	                         OR #iUDT_Polisorter4CommonStatus.SafetyStop);
	    
	    #sR_TRIG_SorterJam(CLK := #ix_Polisorter1Jam
	                       OR #ix_Polisorter2Jam
	                       OR #ix_Polisorter3Jam
	                       OR #ix_Polisorter4Jam);
	    
	    #sR_TRIG_SorterStopped(CLK := #iUDT_Polisorter1CommonStatus.Stopped
	                           AND #iUDT_Polisorter2CommonStatus.Stopped
	                           AND #iUDT_Polisorter3CommonStatus.Stopped
	                           AND #iUDT_Polisorter4CommonStatus.Stopped);
	    
	    #sR_TRIG_SorterRunning(CLK := #iUDT_Polisorter1CommonStatus.Running
	                           OR #iUDT_Polisorter2CommonStatus.Running
	                           OR #iUDT_Polisorter3CommonStatus.Running
	                           OR #iUDT_Polisorter4CommonStatus.Running);
	END_REGION
	
	
	REGION 5 - Creating sorter status
	    
	    IF #sR_TRIG_SorterEstop.Q
	    THEN
	        #ss_SorterStatus := '004';
	    ELSIF #sR_TRIG_SorterJam.Q
	    THEN
	        #ss_SorterStatus := '003';
	    ELSIF #sR_TRIG_SorterStopped.Q
	    THEN
	        #ss_SorterStatus := '002';
	    ELSIF #sR_TRIG_SorterRunning.Q
	    THEN
	        #ss_SorterStatus := '001';
	        
	    END_IF;
	END_REGION
	
	REGION 6 - Sending sorter status
	    
	    IF #ss_SorterStatus_OLD <> #ss_SorterStatus
	        OR #iUDT_FedExCommands.UploadAllStatus.NewMessage THEN
	        
	        #sFB_FedExEquipmentStatusMessageSorter(iUDT_Facility := #iUDT_FedExFacility,
	                                               is_LOConEquipment := #is_LOConEquipment,
	                                               is_DEPCOD := #is_DEPCOD,
	                                               is_TYPofEquipment := #is_TYPofEquipment,
	                                               is_NumberOfTheEquipment := #is_NumberOfTheEquipment,
	                                               is_DeviceType := 'PLC001',
	                                               is_DeviceID := '000001',
	                                               is_StatusCode := #ss_SorterStatus,
	                                               iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                                               iqa_FifoData := #iqa_FifoData);
	        
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Store old statuses
	    
	    #ss_SorterStatus_OLD := #ss_SorterStatus;
	    #sa_ChuteStatus_OLD := #sa_ChuteStatus;
	    
	END_REGION
	
	REGION 8 - Reset uDS commands
	    
	    #iUDT_FedExCommands.UploadAllStatus.NewMessage := FALSE;
	    #iUDT_FedExCommands.UploadChuteStatus.NewMessage := FALSE;
	    
	END_REGION
	
	
	
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_FedExPolisorterSortResult"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 82
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_PolisorterInterface { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PolisorterInterface";   // Polisorter interface
      ia_PolisorterDestinations { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..3] of "UDT_FedExDestinations";   // Polisorter destinations
      is_RejectChute { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[6];   // Physical Destination of custom reject chute
      is_NotReachableDestination1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[6];
      is_NotReachableDestination2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[6];
      ii_DVMessageSendPoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // DV message send point
      ix_FinalSorter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True when sorter is last sorter in the system
   END_VAR

   VAR_IN_OUT 
      iqi_GINDVMessage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // GIN number
   END_VAR

   VAR 
      sF_TRIG_Newparcel {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // New parcel detected at the end of Polisorter
      sdw_ReasonCode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DWord;
      si_LastGin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // GIN number from previous cycle
      si_GINDVMessage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // GIN number
      si_StringLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length of actual destination
      si_LenFillLoop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      sx_SendToNextScan { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_EndOfTracking { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_UnknownReason { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_TEMP 
      ti_LC_Positions : Int;   // Loop counter
      ti_LC_LenFillLoop : Int;   // Loop counter
      ti_LC_Destinations : Int;   // Loop counter
      tw_HTA_RET_VAL : Word;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	26/04/2022  | 1.0       | K. Pokorski   | first release MHS TIA 16.0
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	
	*)
	REGION 1 - Creating sort reason code
	    
	    #sF_TRIG_Newparcel(CLK := #ii_DVMessageSendPoint <> 0);
	    
	    IF #sF_TRIG_Newparcel.Q AND (#si_LastGin) > 0 AND (#si_LastGin <= 9999) THEN
	        #sx_EndOfTracking := FALSE;
	        #sx_UnknownReason := FALSE;
	        
	        IF #ix_FinalSorter THEN
	            #sx_SendToNextScan := TRUE;
	        ELSE
	            #sx_SendToNextScan := FALSE;
	        END_IF;
	        
	        #si_GINDVMessage := #si_LastGin;
	        // No destination received at all
	        IF STRING_TO_DINT("DB_GIN".GIN[#si_GINDVMessage].FedEx.Destination1) = 0 THEN
	            IF "DB_GIN".GIN[#si_GINDVMessage].FedEx.CustomerID <> 0 THEN
	                "DB_GIN".GIN[#si_GINDVMessage].General.SortStatus.NoDivertCause.NoDestRcv := TRUE;
	                #sx_EndOfTracking := TRUE;
	                // No parcel inducted/Unknown state    
	            ELSE
	                #sx_UnknownReason := TRUE;
	            END_IF;
	            
	            FOR #ti_LC_Positions := 1 TO 3 BY 1 DO
	                IF #iUDT_PolisorterInterface.PositionActual = #ti_LC_Positions
	                    OR (#iUDT_PolisorterInterface.PositionActual = 0 AND #iUDT_PolisorterInterface.Positioning AND #iUDT_PolisorterInterface.PositionSetpoint = #ti_LC_Positions)
	                THEN
	                    
	                    VAL_STRG(IN := #ia_PolisorterDestinations[#ti_LC_Positions].PhysicalDestination,
	                             SIZE := 6,
	                             PREC := 0,
	                             FORMAT := 0,
	                             P := 1,
	                             OUT => "DB_GIN".GIN[#si_GINDVMessage].FedEx.ActualDestination);
	                    
	                    #si_StringLen := LEN("DB_GIN".GIN[#si_GINDVMessage].FedEx.ActualDestination);
	                    
	                    IF (#si_StringLen < 6)
	                    THEN
	                        FOR #ti_LC_LenFillLoop := 1 TO 6 - #si_StringLen DO
	                            "DB_GIN".GIN[#si_GINDVMessage].FedEx.ActualDestination := CONCAT(IN1 := '0',
	                                                                                             IN2 := "DB_GIN".GIN[#si_GINDVMessage].FedEx.ActualDestination);
	                            EXIT;
	                            
	                        END_FOR;
	                    END_IF;
	                    EXIT;
	                END_IF;
	            END_FOR;
	            
	            
	            
	            "DB_GIN".GIN[#si_GINDVMessage].FedEx.PackageExitPoint := CONCAT(IN1 := 'CHUTE', IN2 := "DB_GIN".GIN[#si_GINDVMessage].FedEx.ActualDestination);
	            "DB_GIN".GIN[#si_GINDVMessage].FedEx.PackageExitState := '1';
	            
	            
	            // Destination received after decision on Polisorter
	        ELSIF STRING_TO_DINT("DB_GIN".GIN[#si_GINDVMessage].FedEx.Destination1) <> 0 AND "DB_GIN".GIN[#si_GINDVMessage].General.SortStatus.NoDivertCause.NoDestRcv
	        THEN
	            "DB_GIN".GIN[#si_GINDVMessage].General.SortStatus.NoDivertCause.DestTooLate := TRUE;
	            "DB_GIN".GIN[#si_GINDVMessage].General.SortStatus.NoDivertCause.NoDestRcv := FALSE;
	            #sx_EndOfTracking := TRUE;
	            
	            
	            
	            FOR #ti_LC_Positions := 1 TO 3 BY 1 DO
	                IF #iUDT_PolisorterInterface.PositionActual = #ti_LC_Positions
	                    OR (#iUDT_PolisorterInterface.PositionActual = 0 AND #iUDT_PolisorterInterface.Positioning AND #iUDT_PolisorterInterface.PositionSetpoint = #ti_LC_Positions)
	                    
	                THEN
	                    
	                    VAL_STRG(IN := #ia_PolisorterDestinations[#ti_LC_Positions].PhysicalDestination,
	                             SIZE := 6,
	                             PREC := 0,
	                             FORMAT := 0,
	                             P := 1,
	                             OUT => "DB_GIN".GIN[#si_GINDVMessage].FedEx.ActualDestination);
	                    
	                    #si_StringLen := LEN("DB_GIN".GIN[#si_GINDVMessage].FedEx.ActualDestination);
	                    
	                    IF (#si_StringLen < 6)
	                    THEN
	                        FOR #ti_LC_LenFillLoop := 1 TO 6 - #si_StringLen DO
	                            "DB_GIN".GIN[#si_GINDVMessage].FedEx.ActualDestination := CONCAT(IN1 := '0',
	                                                                                             IN2 := "DB_GIN".GIN[#si_GINDVMessage].FedEx.ActualDestination);
	                            EXIT;
	                            
	                        END_FOR;
	                    END_IF;
	                    EXIT;
	                END_IF;
	            END_FOR;
	            
	            
	            
	            
	            "DB_GIN".GIN[#si_GINDVMessage].FedEx.PackageExitPoint := CONCAT(IN1 := 'CHUTE', IN2 := "DB_GIN".GIN[#si_GINDVMessage].FedEx.ActualDestination);
	            "DB_GIN".GIN[#si_GINDVMessage].FedEx.PackageExitState := '1';
	            
	            
	            
	            // Any destination received
	        ELSIF STRING_TO_DINT("DB_GIN".GIN[#si_GINDVMessage].FedEx.Destination1) <> 0 THEN
	            
	            // Destination is not configured
	            IF "DB_GIN".GIN[#si_GINDVMessage].General.SortStatus.NoDivertCause.InvalidDest THEN
	                
	                #sx_EndOfTracking := TRUE;
	                
	                IF "DB_GIN".GIN[#si_GINDVMessage].FedEx.Destination1 = #is_NotReachableDestination1
	                    OR "DB_GIN".GIN[#si_GINDVMessage].FedEx.Destination1 = #is_NotReachableDestination2 THEN
	                    
	                    "DB_GIN".GIN[#si_GINDVMessage].General.SortStatus.NoDivertCause.DestNotReachable := TRUE;
	                    
	                END_IF;
	                
	                FOR #ti_LC_Positions := 1 TO 3 BY 1 DO
	                    IF #iUDT_PolisorterInterface.PositionActual = #ti_LC_Positions
	                        OR (#iUDT_PolisorterInterface.PositionActual = 0 AND #iUDT_PolisorterInterface.Positioning AND #iUDT_PolisorterInterface.PositionSetpoint = #ti_LC_Positions)
	                        
	                    THEN
	                        
	                        VAL_STRG(IN := #ia_PolisorterDestinations[#ti_LC_Positions].PhysicalDestination,
	                                 SIZE := 6,
	                                 PREC := 0,
	                                 FORMAT := 0,
	                                 P := 1,
	                                 OUT => "DB_GIN".GIN[#si_GINDVMessage].FedEx.ActualDestination);
	                        
	                        #si_StringLen := LEN("DB_GIN".GIN[#si_GINDVMessage].FedEx.ActualDestination);
	                        
	                        IF (#si_StringLen < 6)
	                        THEN
	                            FOR #ti_LC_LenFillLoop := 1 TO 6 - #si_StringLen DO
	                                "DB_GIN".GIN[#si_GINDVMessage].FedEx.ActualDestination := CONCAT(IN1 := '0',
	                                                                                                 IN2 := "DB_GIN".GIN[#si_GINDVMessage].FedEx.ActualDestination);
	                                EXIT;
	                                
	                            END_FOR;
	                        END_IF;
	                        EXIT;
	                    END_IF;
	                END_FOR;
	                
	                
	                "DB_GIN".GIN[#si_GINDVMessage].FedEx.PackageExitPoint := CONCAT(IN1 := 'CHUTE', IN2 := "DB_GIN".GIN[#si_GINDVMessage].FedEx.ActualDestination);
	                "DB_GIN".GIN[#si_GINDVMessage].FedEx.PackageExitState := '1';
	                
	                
	            ELSE
	                
	                //Destination matching the configuration - searching if Poliosorter is in good position
	                FOR #ti_LC_Positions := 1 TO 3 BY 1 DO
	                    IF #iUDT_PolisorterInterface.PositionActual = #ti_LC_Positions
	                        OR (#iUDT_PolisorterInterface.PositionActual = 0 AND #iUDT_PolisorterInterface.Positioning AND #iUDT_PolisorterInterface.PositionSetpoint = #ti_LC_Positions)
	                        
	                    THEN
	                        FOR #ti_LC_Destinations := 0 TO 5 DO
	                            IF (#ia_PolisorterDestinations[#ti_LC_Positions].Destination[#ti_LC_Destinations]) = STRING_TO_DINT("DB_GIN".GIN[#si_GINDVMessage].FedEx.Destination1)
	                                
	                            THEN
	                                
	                                // Polisorter is in good position 
	                                VAL_STRG(IN := #ia_PolisorterDestinations[#ti_LC_Positions].PhysicalDestination,
	                                         SIZE := 6,
	                                         PREC := 0,
	                                         FORMAT := 0,
	                                         P := 1,
	                                         OUT => "DB_GIN".GIN[#si_GINDVMessage].FedEx.ActualDestination);
	                                
	                                #si_StringLen := LEN("DB_GIN".GIN[#si_GINDVMessage].FedEx.ActualDestination);
	                                
	                                #sx_EndOfTracking := NOT #ix_FinalSorter AND "DB_GIN".GIN[#si_GINDVMessage].FedEx.ActualDestination <> #is_RejectChute;
	                                
	                                IF (#si_StringLen < 6)
	                                THEN
	                                    FOR #ti_LC_LenFillLoop := 1 TO 6 - #si_StringLen DO
	                                        "DB_GIN".GIN[#si_GINDVMessage].FedEx.ActualDestination := CONCAT(IN1 := '0',
	                                                                                                         IN2 := "DB_GIN".GIN[#si_GINDVMessage].FedEx.ActualDestination);
	                                        EXIT;
	                                        
	                                    END_FOR;
	                                END_IF;
	                                
	                                
	                                EXIT;
	                                
	                                
	                                
	                                
	                                
	                            END_IF;
	                        END_FOR;
	                        EXIT;
	                    END_IF;
	                END_FOR;
	                
	                // Polisorter in wrong position, Divert failed for some reason
	                IF "DB_GIN".GIN[#si_GINDVMessage].FedEx.ActualDestination = '      ' THEN
	                    
	                    "DB_GIN".GIN[#si_GINDVMessage].General.SortStatus.FailedDivert := TRUE;
	                    #sx_EndOfTracking := TRUE;
	                    
	                    FOR #ti_LC_Positions := 1 TO 3 BY 1 DO
	                        IF #iUDT_PolisorterInterface.PositionActual = #ti_LC_Positions
	                            OR (#iUDT_PolisorterInterface.PositionActual = 0 AND #iUDT_PolisorterInterface.Positioning AND #iUDT_PolisorterInterface.PositionSetpoint = #ti_LC_Positions)
	                            
	                        THEN
	                            
	                            VAL_STRG(IN := #ia_PolisorterDestinations[#ti_LC_Positions].PhysicalDestination,
	                                     SIZE := 6,
	                                     PREC := 0,
	                                     FORMAT := 0,
	                                     P := 1,
	                                     OUT => "DB_GIN".GIN[#si_GINDVMessage].FedEx.ActualDestination);
	                            
	                            #si_StringLen := LEN("DB_GIN".GIN[#si_GINDVMessage].FedEx.ActualDestination);
	                            
	                            IF (#si_StringLen < 6)
	                            THEN
	                                FOR #ti_LC_LenFillLoop := 1 TO 6 - #si_StringLen DO
	                                    "DB_GIN".GIN[#si_GINDVMessage].FedEx.ActualDestination := CONCAT(IN1 := '0',
	                                                                                                     IN2 := "DB_GIN".GIN[#si_GINDVMessage].FedEx.ActualDestination);
	                                    EXIT;
	                                    
	                                END_FOR;
	                            END_IF;
	                            EXIT;
	                        END_IF;
	                    END_FOR;
	                    
	                    
	                    "DB_GIN".GIN[#si_GINDVMessage].FedEx.PackageExitPoint := CONCAT(IN1 := 'CHUTE', IN2 := "DB_GIN".GIN[#si_GINDVMessage].FedEx.ActualDestination);
	                    "DB_GIN".GIN[#si_GINDVMessage].FedEx.PackageExitState := '1';
	                    
	                    // Polisorter in good position, divert successful
	                ELSE
	                    
	                    "DB_GIN".GIN[#si_GINDVMessage].General.SortStatus.GoodDivert := TRUE;
	                    "DB_GIN".GIN[#si_GINDVMessage].FedEx.PackageExitPoint := CONCAT(IN1 := 'CHUTE', IN2 := "DB_GIN".GIN[#si_GINDVMessage].FedEx.ActualDestination);
	                    "DB_GIN".GIN[#si_GINDVMessage].FedEx.PackageExitState := '1';
	                    
	                END_IF;
	                
	                
	            END_IF;
	        END_IF;
	        
	        #si_StringLen := LEN("DB_GIN".GIN[#si_GINDVMessage].FedEx.PackageExitPoint);
	        
	        IF (#si_StringLen < 14)
	        THEN
	            FOR #si_LenFillLoop := 1 TO 14 - #si_StringLen DO
	                
	                "DB_GIN".GIN[#si_GINDVMessage].FedEx.PackageExitPoint := CONCAT(IN1 := "DB_GIN".GIN[#si_GINDVMessage].FedEx.PackageExitPoint,
	                                                                                IN2 := ' ');
	            END_FOR;
	            
	        END_IF;
	        
	        #sdw_ReasonCode.%X0 := (#ix_FinalSorter OR (#is_RejectChute = "DB_GIN".GIN[#si_GINDVMessage].FedEx.ActualDestination)) AND ("DB_GIN".GIN[#si_GINDVMessage].General.SortStatus.GoodDivert AND "DB_GIN".GIN[#si_GINDVMessage].FedEx.Destination1 <> '999999');
	        #sdw_ReasonCode.%X1 := "DB_GIN".GIN[#si_GINDVMessage].General.SortStatus.NoDivertCause.InvalidDest AND NOT "DB_GIN".GIN[#si_GINDVMessage].General.SortStatus.NoDivertCause.DestNotReachable;
	        #sdw_ReasonCode.%X2 := "DB_GIN".GIN[#si_GINDVMessage].General.SortStatus.NoDivertCause.NoDestRcv AND NOT #sx_UnknownReason;
	        #sdw_ReasonCode.%X3 := "DB_GIN".GIN[#si_GINDVMessage].General.SortStatus.NoDivertCause.DestTooLate;
	        #sdw_ReasonCode.%X4 := FALSE;
	        #sdw_ReasonCode.%X5 := FALSE;
	        #sdw_ReasonCode.%X6 := FALSE;
	        #sdw_ReasonCode.%X7 := FALSE;
	        #sdw_ReasonCode.%X8 := "DB_GIN".GIN[#si_GINDVMessage].General.SortStatus.FailedDivert;
	        #sdw_ReasonCode.%X9 := FALSE;
	        #sdw_ReasonCode.%X10 := FALSE;
	        #sdw_ReasonCode.%X11 := FALSE;//"DB_GIN".GIN[#si_GIN_DVMessage].General.Lost;
	        #sdw_ReasonCode.%X12 := FALSE;
	        #sdw_ReasonCode.%X13 := FALSE;
	        #sdw_ReasonCode.%X14 := FALSE;
	        #sdw_ReasonCode.%X15 := FALSE;
	        #sdw_ReasonCode.%X16 := #sx_EndOfTracking;
	        #sdw_ReasonCode.%X17 := FALSE;
	        #sdw_ReasonCode.%X18 := FALSE;
	        #sdw_ReasonCode.%X19 := FALSE;
	        #sdw_ReasonCode.%X20 := FALSE;
	        #sdw_ReasonCode.%X21 := FALSE;
	        #sdw_ReasonCode.%X22 := FALSE;
	        #sdw_ReasonCode.%X23 := FALSE;
	        #sdw_ReasonCode.%X24 := FALSE;
	        #sdw_ReasonCode.%X25 := "DB_GIN".GIN[#si_GINDVMessage].General.SortStatus.GoodDivert AND "DB_GIN".GIN[#si_GINDVMessage].FedEx.Destination1 = '999999' AND #ix_FinalSorter;
	        #sdw_ReasonCode.%X26 := (NOT #ix_FinalSorter AND (#is_RejectChute <> "DB_GIN".GIN[#si_GINDVMessage].FedEx.ActualDestination)) AND "DB_GIN".GIN[#si_GINDVMessage].General.SortStatus.GoodDivert;
	        #sdw_ReasonCode.%X27 := FALSE;
	        #sdw_ReasonCode.%X28 := FALSE;
	        #sdw_ReasonCode.%X29 := "DB_GIN".GIN[#si_GINDVMessage].General.SortStatus.NoDivertCause.InvalidDest AND "DB_GIN".GIN[#si_GINDVMessage].General.SortStatus.NoDivertCause.DestNotReachable;
	        #sdw_ReasonCode.%X30 := FALSE;
	        #sdw_ReasonCode.%X31 := #sx_UnknownReason;
	        
	        #tw_HTA_RET_VAL := HTA(IN := #sdw_ReasonCode, N := 4, OUT => "DB_GIN".GIN[#si_GINDVMessage].FedEx.ReasonCode1);
	        
	        
	        #iqi_GINDVMessage := #si_GINDVMessage;
	        
	        
	    END_IF;
	    
	    #si_LastGin := #ii_DVMessageSendPoint;
	    
	END_REGION
	
	
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_FedExStartOfSort"
TITLE = FB_Heartbeat
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : UPS_SpecificCommunication
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 83
// END_ATTRIBUTES
//Function block to send and monitor the UPS heartbeat message.
   VAR_INPUT 
      ix_StartOfSort { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Enable Start of sort Message
      ix_EnableSend { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Enable heartbeat message send
      ix_ResetData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset statistics
   END_VAR

   VAR_IN_OUT 
      iqUDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_Message";   // FIFO data
      iqUDT_Statistics : "UDT_FedExHeartbeatStatistics";   // Statistic strucure
      iqdi_UniqueMsgID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Unique message ID integer
   END_VAR

   VAR 
      s_R_TRIG_EnableSend {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Siemens "R_TRIG" - to prepare the rising edge trigger on "ix_EnableSend" signal
      s_R_TRIG_StartOfSort {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Siemens "R_TRIG" - to prepare the rising edge trigger on "ix_StartOfSort" signal
      s_UDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Message";   // Message character array
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO data buffer full
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO error
         HeartbeatOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO warning
         InvalidTimeInterval { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat ok
         InvalidTimeout { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat time interval lower than zero
         InvalidMsgArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat timeout lower than zero or lower than heartbeat time interval
      END_STRUCT;
      ss_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Message character string
      ss_MSGID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Timestamp
      sui_MsgArrayElNr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Invalid message array size
      si_MaxMsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum message length
      si_MsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // String character message length
      si_LostMsg { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Number of lost messages
      sx_MsgLost { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message lost
   END_VAR

   VAR CONSTANT 
      cc_NULL : Char := '$00';   // NULL sign
      cs_Start : Char := '$02';   // Termination signs
      cs_End : Char := '$03';
      cs_Length : String := '0006';
      cs_StartOfSort : String := 'SS';   // Message type
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	29/06/2021  | 1.0       | F.Baten       | first release MHS TIA 16.4
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOStatus,
	              qx_Error => #ss_Status.FIFOError,
	              qx_Warning => #ss_Status.FIFOWarning,
	              iqv_Data := #s_UDT_MessageArray,
	              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	    
	END_REGION
	
	REGION 4 – Message preparation
	    
	    #s_R_TRIG_StartOfSort(CLK := #ix_StartOfSort);
	    
	    IF (NOT #iqUDT_FifoHeader.Status.Full)                 // FIFO isn't full
	    THEN
	        
	        IF (#ix_EnableSend                                  // Send is enable
	            AND #s_R_TRIG_StartOfSort.Q                     // Trigger message
	            AND NOT #ss_Status.FIFOError)                   // No FIFO error
	        THEN
	            REGION 4.1 – Message preparation
	                
	                // Heartbeat message composing according to the structure: STX,00,06,SS,ETX
	                #ss_Message := CONCAT(IN1 := #cs_Start,     // Start of message
	                                      IN2 := #cs_Length,    // message length
	                                      IN3 := #cs_StartOfSort,// Start of sort message
	                                      IN4 := #cs_End);      // End of message
	                
	            END_REGION
	            
	            REGION 4.2 – Maximum number of the message characters
	                
	                #si_MaxMsgLen := "FC_GetNrOfArrayEl"(iv_Array := #s_UDT_MessageArray.Character);
	                
	            END_REGION
	            
	            REGION 4.3 – Length of the complete message
	                
	                #si_MsgLen := LEN(#ss_Message);
	                
	            END_REGION
	            
	            REGION 4.4 –  Message array size validation
	                
	                #ss_Status.InvalidMsgArraySize := #si_MsgLen > #si_MaxMsgLen;
	                
	            END_REGION
	            
	            REGION 4.5 –  Message character string conversion to a message array of characters
	                
	                IF (NOT #ss_Status.InvalidMsgArraySize)     // Message character array size is valid 
	                THEN
	                    
	                    Strg_TO_Chars(Strg := #ss_Message,
	                                  pChars := 0,
	                                  Cnt => #sui_MsgArrayElNr,
	                                  Chars := #s_UDT_MessageArray.Character);
	                    
	                END_IF;
	                
	            END_REGION
	            
	            REGION 4.6 – Clearing remaining characters in the message character array
	                
	                IF (NOT #ss_Status.InvalidMsgArraySize)     // Message character array size is valid 
	                THEN
	                    
	                    // Filling up not used message character array elements with '$00' (ASCII - 16#00)
	                    FILL_BLK(IN := #cc_NULL,
	                             COUNT := UINT_TO_ULINT(INT_TO_UINT(#si_MaxMsgLen) - #sui_MsgArrayElNr),
	                             OUT => #s_UDT_MessageArray.Character[#sui_MsgArrayElNr]);
	                    
	                END_IF;
	                
	            END_REGION
	            
	            REGION 4.7 – Message write into a FIFO register
	                
	                IF (#ix_EnableSend                          // Heartbeat send enable
	                    AND NOT #ss_Status.InvalidMsgArraySize) // Message character array size is valid 
	                THEN
	                    
	                    // Mode 'W' - Write FIFO record
	                    "FC_Fifo"(ic_Mode := 'W',
	                              qUDT_Status => #ss_Status.FIFOStatus,
	                              qx_Error => #ss_Status.FIFOError,
	                              qx_Warning => #ss_Status.FIFOWarning,
	                              iqv_Data := #s_UDT_MessageArray,
	                              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                              iqv_DataBuffer := #iqs_FifoData);
	                END_IF;
	                
	            END_REGION
	            
	        END_IF;
	        
	        // In case of FIFO full, the FIFO full error bit and FIFO collective error bit are set
	    ELSE
	        
	        #ss_Status.FIFOError := TRUE;
	        #ss_Status.FIFOStatus.FifoFull := TRUE;
	        
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_FedExTCPIPReceive"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 84
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_Connection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_Connection";   // Connection parameters
      ix_EnableReceive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when receive enable
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block error occurred
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block warning occurred
   END_VAR

   VAR_IN_OUT 
      iqUDT_FifoHeader : "UDT_FifoHeader";   // Fifo header
      iqv_FifoData : Variant;   // Fifo data
      iqUDT_Statistics : "UDT_TCPIPReceiveStatistics";   // Statistic structure
   END_VAR

   VAR 
      s_FB_TRCV {InstructionName := 'TRCV'; LibVersion := '4.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TRCV;   // Siemens "TRCV" block - to receive the data from TCPIP socket
      ss_TRCV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // TRCV block interface structure
         Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      TRCV - Enable
         NDR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      TRCV - New data available
         Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      TRCV - Busy
         Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      TRCV - Error
         Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   //      TRCV - Status
         ReceivedLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   //      TRCV - Received length
         Data { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..999] of Char;   //      TRCV - Data
      END_STRUCT;
      s_UDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Message";   // Message byte array
      s_UDT_MessagePartArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Message";   // Part of the message byte array
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         ErrorCode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Error code structure
            TRCV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   //     Siemens TRCV error code - Check documentation
         END_STRUCT;
         FIFOReceiveStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";   // Receive FIFO status structure
         FIFOReceiveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // Receive FIFO error
         FIFOReceiveWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // Receive  FIFO warning
         ReceiveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRCV block operation error - Check TRCVStatus
      END_STRUCT;
      sui_ReceivedMessagesOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Received message offset
      sui_ReceivedMessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Received message length
      sui_NumberOfReceivedMessages { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Number of received messages in one frame
      sui_ReceivedMessagePartLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Length of the part of received message
      si_MaximumMessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum message length
      sx_ReceivedMessagePart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Received part of the message
      sx_STXFound { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // STX in message is found
   END_VAR

   VAR_TEMP 
      ti_LC_MessageChars : Int;   //  Message chars loop counter
   END_VAR

   VAR CONSTANT 
      cc_STX : Char := '$02';   // Start of the message sign
      cc_EXT : Char := '$03';   // End of the message sign
      cc_NULL : Char := '$00';   // Null sign
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	25/10/2021  | 1.0       | J. Krawczuk   | Initial version TIA 16
	17/11/2021  | 1.2       | M. Piela      | Interface changes
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	13/03/2024  | 4.1       | S. Nieświec   | 4.1 Release TIA 18
	02/05/2024  | 4.2       | J.Majer      | Datatype conversions changed from automatic to explicit, to accomodate IEC 61131-3 standard
	*)
	
	REGION 1 – Update FIFO header status bits
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOReceiveStatus,
	              qx_Error => #ss_Status.FIFOReceiveError,
	              qx_Warning => #ss_Status.FIFOReceiveWarning,
	              iqv_Data := #s_UDT_MessageArray,
	              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	              iqv_DataBuffer := #iqv_FifoData);
	    
	END_REGION
	
	REGION 2 – Maximum number of message arrays elements
	    
	    #si_MaximumMessageLength := "FC_GetNrOfArrayEl"(iv_Array := #s_UDT_MessageArray.Character);
	    
	END_REGION
	
	REGION 3 – Receive enable
	    
	    // Allow receiving if the connection is established and there are no FIFO errors.
	    #ss_TRCV.Enable :=
	    #ix_EnableReceive
	    AND NOT #ss_Status.FIFOReceiveError;
	    
	END_REGION
	
	REGION 4 – Receive data
	    
	    // Data received in an ADHOC mode - data available immediately.
	    #s_FB_TRCV(EN_R := #ss_TRCV.Enable,
	               ID := #iUDT_Connection.ID,
	               LEN := 0,
	               ADHOC := TRUE,
	               NDR => #ss_TRCV.NDR,
	               BUSY => #ss_TRCV.Busy,
	               ERROR => #ss_TRCV.Error,
	               STATUS => #ss_TRCV.Status,
	               RCVD_LEN => #ss_TRCV.ReceivedLength,
	               DATA := #ss_TRCV.Data);
	    
	END_REGION
	
	REGION 5 – Received data handling
	    
	    // Receiving data was successful.
	    IF #ss_TRCV.NDR
	        AND NOT #ss_TRCV.Busy
	        AND NOT #ss_TRCV.Error
	        AND #ss_TRCV.ReceivedLength > 0
	        
	    THEN
	        
	        REGION 5.1 – Initialization
	            
	            #sui_ReceivedMessageLength := 0;
	            #sui_ReceivedMessagesOffset := 0;
	            #sui_NumberOfReceivedMessages := 0;
	            
	        END_REGION
	        
	        REGION 5.2 – Received part of the message
	            
	            // Move part of the messages into a buffer if available.
	            IF #sx_ReceivedMessagePart
	            THEN
	                #s_UDT_MessageArray := #s_UDT_MessagePartArray;
	            END_IF;
	            
	        END_REGION
	        
	        REGION 5.3 – Message handling
	            
	            FOR #ti_LC_MessageChars := 0 TO (UDINT_TO_INT(#ss_TRCV.ReceivedLength) - 1) DO
	                // Message length validation.
	                IF #sui_ReceivedMessageLength <= #si_MaximumMessageLength
	                THEN
	                    // First termination sign found.
	                    IF (#ss_TRCV.Data[#ti_LC_MessageChars] = #cc_STX)
	                        AND NOT #sx_STXFound
	                    THEN
	                        #sx_STXFound := TRUE;
	                        #sui_ReceivedMessagesOffset := #ti_LC_MessageChars;
	                        
	                    ELSIF (#ss_TRCV.Data[#ti_LC_MessageChars] = #cc_STX)
	                        AND #sx_STXFound
	                    THEN
	                        // Increment invalid meassage statistic.
	                        #iqUDT_Statistics.InvalidMsg += 1;
	                        #sx_STXFound := FALSE;
	                    END_IF;
	                    
	                    // STX is found.
	                    IF #sx_STXFound
	                    THEN
	                        // Increment received message length.
	                        #sui_ReceivedMessageLength += 1;
	                        
	                        // End of the message sign is found.
	                        IF #ss_TRCV.Data[#ti_LC_MessageChars] = #cc_EXT
	                        THEN
	                            // Move received message to the message array.
	                            MOVE_BLK(IN := #ss_TRCV.Data[#sui_ReceivedMessagesOffset],
	                                     COUNT := #sui_ReceivedMessageLength,
	                                     OUT => #s_UDT_MessageArray.Character[#sui_ReceivedMessagePartLength]);
	                            
	                            // Clear not used message array characters.
	                            IF (#sui_ReceivedMessageLength + #sui_ReceivedMessagePartLength) < #si_MaximumMessageLength
	                            THEN
	                                FILL_BLK(IN := #cc_NULL,
	                                         COUNT := INT_TO_ULINT(#si_MaximumMessageLength) -
	                                         UDINT_TO_ULINT(#sui_ReceivedMessageLength) + #sui_ReceivedMessagePartLength,
	                                         OUT => #s_UDT_MessageArray.Character[#sui_ReceivedMessageLength + #sui_ReceivedMessagePartLength]);
	                            END_IF;
	                            
	                            // Mode 'W' - Write FIFO record.
	                            "FC_Fifo"(ic_Mode := 'W',
	                                      qUDT_Status => #ss_Status.FIFOReceiveStatus,
	                                      qx_Error => #ss_Status.FIFOReceiveError,
	                                      qx_Warning => #ss_Status.FIFOReceiveWarning,
	                                      iqv_Data := #s_UDT_MessageArray,
	                                      iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                                      iqv_DataBuffer := #iqv_FifoData);
	                            
	                            // Increment received message count.
	                            #sui_NumberOfReceivedMessages += 1;
	                            // Initialize variables.
	                            #sui_ReceivedMessageLength := 0;
	                            #sui_ReceivedMessagePartLength := 0;
	                            #sx_ReceivedMessagePart := FALSE;
	                            #sx_STXFound := FALSE;
	                            
	                        END_IF;
	                    END_IF;
	                END_IF;
	            END_FOR;
	            
	        END_REGION
	        
	        REGION 5.4 – Part of the message preparation
	            
	            // Only the part of the message is received.
	            IF (#ss_TRCV.Data[UDINT_TO_INT(#ss_TRCV.ReceivedLength) - 1] <> #cc_EXT            // Last received sign is not a termination sing
	                AND #sui_ReceivedMessageLength < #si_MaximumMessageLength)       // Message length valid
	                AND #sx_STXFound
	            THEN
	                // Clear not used message array characters. 
	                FILL_BLK(IN := #cc_NULL,
	                         COUNT := INT_TO_ULINT(#si_MaximumMessageLength) -
	                         UDINT_TO_ULINT(#sui_ReceivedMessageLength),
	                         OUT => #s_UDT_MessagePartArray.Character[#sui_ReceivedMessageLength]);
	                
	                // Move part of the message into a buffer.
	                MOVE_BLK(IN := #ss_TRCV.Data[#sui_ReceivedMessagesOffset],
	                         COUNT := #sui_ReceivedMessageLength,
	                         OUT => #s_UDT_MessagePartArray.Character[0]);
	                
	                // Set the part of the message received bit and move length of the received message into the length of the part of the message variable.
	                #sx_ReceivedMessagePart := TRUE;
	                #sui_ReceivedMessagePartLength := #sui_ReceivedMessageLength;
	            END_IF;
	            
	        END_REGION
	        
	    END_IF;
	    
	END_REGION
	
	REGION 6 – Status
	    
	    REGION 6.1 - Block status
	        
	        // Receive error.
	        #ss_Status.ReceiveError := #ss_TRCV.Error;
	        
	        // Parametrization collective error output.
	        #qx_Error :=
	        #ss_Status.FIFOReceiveError
	        OR #ss_Status.ReceiveError;
	        
	        // Parametrization collective warning output.
	        #qx_Warning := #ss_Status.FIFOReceiveWarning;
	        
	    END_REGION
	    
	    REGION 6.2 - Error code preparation
	        
	        IF (#ss_TRCV.#Status > 16#8000)
	            OR (#ss_TRCV.#Status = 16#0)
	        THEN
	            #ss_Status.ErrorCode.TRCV := #ss_TRCV.#Status;
	        END_IF;
	        
	    END_REGION
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_FedExHeartbeat"
TITLE = FB_Heartbeat
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : UPS_SpecificCommunication
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 74
// END_ATTRIBUTES
//Function block to send and monitor the UPS heartbeat message.
   VAR_INPUT 
      iudi_HeartbeatTimeout { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Time after which block show heartbeat error
      iudi_HeartbeatInterval { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Heartbeat send interval
      ix_Server { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PLC is Server ( True = Server )
      ix_EnableSend { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Enable heartbeat message send
      ix_ResetData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset statistics
   END_VAR

   VAR_OUTPUT 
      qx_HeartbeatOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat ok
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective error output
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective warning output
   END_VAR

   VAR_IN_OUT 
      iqUDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqa_FifoData : Array[*] of "UDT_Message";   // FIFO data
      iqUDT_Statistics : "UDT_FedExHeartbeatStatistics";   // Heartbeat Statistics
      iqx_Heartbeat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbreat received
      iqx_ResetWritingTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Any message received, do not send Heartbeat
      iqx_ResetListeningTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Any message received, reset timeout timer
      iqx_SendLS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Close the connection
      iqx_Reconnect { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reconnect command
   END_VAR

   VAR 
      sR_TRIG_EnableSend {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Siemens "R_TRIG" - to prepare the rising edge trigger on "ix_EnableSend" signal
      sUDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Message";   // Message character array
      sa_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO data buffer full
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO error
         HeartbeatOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO warning
         InvalidTimeInterval { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat ok
         InvalidTimeout { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat time interval lower than zero
         InvalidMsgArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat timeout lower than zero or lower than heartbeat time interval
      END_STRUCT;
      sFB_HeartbeatPulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Sending Heartbeat timer
      sFB_Timer_HeartbeatCheck { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // MHS "FB_TimerOnOffDelay" - to measure the time of  missing Hearbeat
      ss_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Message character string
      sui_MsgArrayElNr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Invalid message array size
      si_MaxMsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum message length
      si_MsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // String character message length
      si_LostMsg { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Number of lost heartbeat messages
      sx_HeartbeatPulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat pulse
      sx_HeartbeatOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat ok
      sx_MsgLost { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message lost
      sx_HeartbeatCheck { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat check
   END_VAR

   VAR CONSTANT 
      cc_STX : Char := '$02';   // Start of the text
      cc_ETX : Char := '$03';   // End of the text
      cc_NULL : Char := '$00';   // NULL sign
      cs_Length : String := '0006';   // Legth of the message
      cs_MessageType : String := 'HB';   // Message type
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	29/06/2021  | 0.1       | F.Baten       | First release 16.0
	05/04/2022  | 0.2       | K.Pokorski    | Review
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #sa_Status.FIFOStatus,
	              qx_Error => #sa_Status.FIFOError,
	              qx_Warning => #sa_Status.FIFOWarning,
	              iqv_Data := #sUDT_MessageArray,
	              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	              iqv_DataBuffer := #iqa_FifoData);
	    
	    
	END_REGION
	
	REGION 2 – Heartbeat time interval and timeout validation
	    IF NOT #ix_Server
	    THEN
	        #sa_Status.InvalidTimeInterval := #iudi_HeartbeatInterval <= 0;
	        
	        #sa_Status.InvalidTimeout := #iudi_HeartbeatTimeout <= 0
	        OR #iudi_HeartbeatTimeout <= #iudi_HeartbeatInterval;
	    END_IF;
	    
	END_REGION
	
	REGION 3 – Heartbeat pulse generation
	    
	    IF (NOT #sa_Status.InvalidTimeInterval                  // Preset heartbeat time interval is valid 
	        AND NOT #sa_Status.InvalidTimeout)                  // Timeout is valid
	        AND NOT #ix_Server
	    THEN
	        
	        #sFB_HeartbeatPulse(iudi_OnDelayTime := #iudi_HeartbeatInterval,
	                            iudi_OffDelayTime := 0,
	                            ix_SignalToDelay := NOT #iqx_ResetWritingTimer,
	                            qx_DelayedSignal => #sx_HeartbeatPulse);
	        
	        IF #sx_HeartbeatPulse THEN
	            #iqx_ResetWritingTimer := TRUE;
	        ELSE
	            #iqx_ResetWritingTimer := FALSE;
	        END_IF;
	        
	    END_IF;
	    
	    // Reset heartbeat send request if PLC is a server
	    IF #ix_Server
	    THEN
	        #sx_HeartbeatPulse := #iqx_Heartbeat;
	        //  #iqx_Heartbeat := FALSE;
	    END_IF;
	END_REGION
	
	REGION 4 – Heartbeat message preparation
	    
	    IF (NOT #iqUDT_FifoHeader.Status.Full)                 // FIFO isn't full
	    THEN
	        
	        IF (#sx_HeartbeatPulse                              // Heartbeat pulse available                
	            AND #ix_EnableSend                              // Send is enable
	            AND NOT #sa_Status.FIFOError)                   // No FIFO error
	        THEN
	            REGION 4.1 – Message preparation
	                
	                // Heartbeat message composing according to the structure: STX,00,06,HB,ETX
	                #ss_Message := CONCAT(IN1 := #cc_STX,               // Start of message
	                                      IN2 := #cs_Length,            // message length
	                                      IN3 := #cs_MessageType,       // Heartbeat
	                                      IN4 := #cc_ETX);              // End of message
	                
	            END_REGION
	            
	            REGION 4.2 – Maximum number of the message characters
	                
	                #si_MaxMsgLen := "FC_GetNrOfArrayEl"(iv_Array := #sUDT_MessageArray.Character);
	                
	            END_REGION
	            
	            REGION 4.3 – Length of the complete message
	                
	                #si_MsgLen := LEN(#ss_Message);
	                
	            END_REGION
	            
	            REGION 4.4 –  Message array size validation
	                
	                #sa_Status.InvalidMsgArraySize := #si_MsgLen > #si_MaxMsgLen;
	                
	            END_REGION
	            
	            REGION 4.5 –  Message character string conversion to a message array of characters
	                
	                IF (NOT #sa_Status.InvalidMsgArraySize)     // Message character array size is valid 
	                THEN
	                    
	                    Strg_TO_Chars(Strg := #ss_Message,
	                                  pChars := 0,
	                                  Cnt => #sui_MsgArrayElNr,
	                                  Chars := #sUDT_MessageArray.Character);
	                    
	                END_IF;
	                
	            END_REGION
	            
	            REGION 4.6 – Clearing remaining characters in the message character array
	                
	                IF (NOT #sa_Status.InvalidMsgArraySize)     // Message character array size is valid 
	                THEN
	                    
	                    // Filling up not used message character array elements with '$00' (ASCII - 16#00)
	                    FILL_BLK(IN := #cc_NULL,
	                             COUNT := UINT_TO_ULINT(INT_TO_UINT(#si_MaxMsgLen) - #sui_MsgArrayElNr),
	                             OUT => #sUDT_MessageArray.Character[#sui_MsgArrayElNr]);
	                    
	                END_IF;
	                
	            END_REGION
	            
	            REGION 4.7 – Message write into a FIFO register
	                
	                IF (#ix_EnableSend                          // Heartbeat send enable
	                    AND NOT #sa_Status.InvalidMsgArraySize) // Message character array size is valid 
	                THEN
	                    
	                    // Mode 'W' - Write FIFO record
	                    "FC_Fifo"(ic_Mode := 'W',
	                              qUDT_Status => #sa_Status.FIFOStatus,
	                              qx_Error => #sa_Status.FIFOError,
	                              qx_Warning => #sa_Status.FIFOWarning,
	                              iqv_Data := #sUDT_MessageArray,
	                              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                              iqv_DataBuffer := #iqa_FifoData);
	                END_IF;
	                
	            END_REGION
	            
	        END_IF;
	        
	        // In case of FIFO full, the FIFO full error bit and FIFO collective error bit are set
	    ELSE
	        
	        #sa_Status.FIFOError := TRUE;
	        #sa_Status.FIFOStatus.FifoFull := TRUE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 5 – Heartbeat monitoring
	    // IF NOT #ix_Server
	    // THEN
	    IF (NOT #sa_Status.InvalidTimeInterval                  // Time interval is valid
	        AND NOT #sa_Status.InvalidTimeout                   // Timeout is  valid
	        AND NOT #sa_Status.InvalidMsgArraySize)             // Message character array size is valid 
	        
	    THEN
	        
	        #sR_TRIG_EnableSend(CLK := #ix_EnableSend);
	        
	        // Reset heartbeat ok 
	        IF (NOT #ix_EnableSend)                             // Heartbeat send not enable
	        THEN
	            #iqx_SendLS := FALSE;
	            #sx_HeartbeatOk := FALSE;
	            
	        END_IF;
	        
	        // Clear auxiliary variables
	        IF (#iqx_Heartbeat                                  // Hearbeat message received
	            AND #ix_EnableSend)                             // Heartbeat send enable
	        THEN
	            
	            #si_LostMsg := 0;                               // Lost messages counter
	            #sx_MsgLost := FALSE;                           // Message lost bit
	            #sx_HeartbeatOk := TRUE;                        // HeartbeatOk bit
	            
	        END_IF;
	        
	        // Time measurement of a missing heartbeat 
	        #sFB_Timer_HeartbeatCheck(ix_SignalToDelay := #iqx_Heartbeat           // Heartbeat signal
	                                  OR #sx_MsgLost                               // Message lost
	                                  OR #sR_TRIG_EnableSend.Q                    // Enable send trigger
	                                  OR #iqx_ResetListeningTimer,                 // Any message received in this socket
	                                  iudi_OnDelayTime := 0,
	                                  iudi_OffDelayTime := #iudi_HeartbeatTimeout,
	                                  qx_DelayedSignal => #sx_HeartbeatCheck);
	        
	        #iqx_Heartbeat := FALSE;
	        #sx_MsgLost := FALSE;
	        #iqx_ResetListeningTimer := FALSE;
	        
	        // Increment lost messages counter and set lost message bit 
	        IF (NOT #sx_HeartbeatCheck                          // Heartbeat not checked
	            AND NOT #iqx_Reconnect                          // No reconnect command
	            AND #ix_EnableSend)                             // Send is enable   
	        THEN
	            
	            // Send LS, re-establish connection, increment statistics and signalize heartbeat error 
	            
	            #iqx_SendLS := TRUE;
	            #iqUDT_Statistics.ConLost += 1;
	            #si_LostMsg := 0;
	            #sx_MsgLost := FALSE;
	            #sx_HeartbeatOk := FALSE;
	            
	        END_IF;
	        
	        // Configuration error occured    
	    ELSE
	        
	        #sx_HeartbeatOk := FALSE;
	        
	    END_IF;
	    // END_IF;
	    
	END_REGION
	
	REGION 6 – Statistics
	    
	    IF #iqUDT_FifoHeader.Status.Full
	        AND #sx_HeartbeatPulse
	    THEN
	        #iqUDT_Statistics.MsgNotSent += 1;
	        
	    END_IF;
	    
	    IF (#ix_ResetData)                                      // Reset statistics request
	    THEN
	        #iqUDT_Statistics.ConLost := 0;
	        #iqUDT_Statistics.MsgNotSent := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 7 – Status
	    
	    // Hearbeat ok output
	    #qx_HeartbeatOK := #sx_HeartbeatOk;
	    
	    // Parametrization collective error output
	    #qx_Error :=
	    #sa_Status.InvalidTimeInterval                          // Invalid time interval 
	    OR #sa_Status.InvalidTimeout                            // Invalid timeout 
	    OR #sa_Status.InvalidMsgArraySize                       // Invalid message character array size   
	    OR #sa_Status.FIFOError                                 // FIFO error
	    OR NOT #sx_HeartbeatOk;                                 // No heartbeat OK
	    
	    // Parametrization collective warning output
	    #qx_Warning := #sa_Status.FIFOWarning;                  // FIFO warning
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_FedExDecode"
TITLE = FB_Decode
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : UPS_SpecificCommunication
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 65
// END_ATTRIBUTES
//Function block to decode UPS messages.
   VAR_IN_OUT 
      iqUDT_FifoRcvHeader : "UDT_FifoHeader";   // FIFO receive header
      iqv_FifoRcvData : Array[*] of "UDT_Message";   // FIFO receive data
      iqx_HeartbeatOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat signal was received
   END_VAR

   VAR 
      sUDT_MSGHeader { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FedExMessageHeader";
      sUDT_SI { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FedExMessageSI";
      sUDT_WS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FedExMessageWS";
      sUDT_DA { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FedExMessageDaRa";
      sUDT_RA { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FedExMessageDaRa";
      sUDT_FifoMsg { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Message";   // Buffer for fifos message
      sa_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         BadMessage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..10] of "UDT_Message";   //   Unknown message read
         FIFORcvStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";   //   Receive FIFO status structure
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //   FIFO error
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //   FIFO warning
         AcknowledgeError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //   Acknowledge error
         AcknowledgeWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //   Acknowledge warning
         HB_NotOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Health bit not OK
      END_STRUCT;
      ss_NNNNNN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[6];
      sdi_DeserializePosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      si_DeserializeBodyStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_Length { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_Position { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Temporary position parial message
      si_SizeOfMsg { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Message array size
      si_GIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      sx_InvalidLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_TEMP 
      tx_MsgRead : Bool;   // Message read from FIFO
   END_VAR

   VAR CONSTANT 
      cs_SI : String := 'SI';
      cs_WS : String := 'WS';
      cs_DA : String := 'DA';
      cs_RA : String := 'RA';
      cs_ES : String := 'ES';
      cs_HB : String := 'HB';
      ci_SizeSIMessage : Int := 338;
      ci_SizeWSMessage : Int := 92;
      ci_SizeDAMessage : Int := 212;
      ci_SizeRAMessage : Int := 212;
      ci_SizeESMessage : Int := 57;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	22/07/2021  | 0.1       | F.Baten       | first release MHS TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #sa_Status.FIFORcvStatus,
	              qx_Error => #sa_Status.FIFOError,
	              qx_Warning => #sa_Status.FIFOWarning,
	              iqv_Data := #sUDT_FifoMsg,
	              iqUDT_FifoHeader := #iqUDT_FifoRcvHeader,
	              iqv_DataBuffer := #iqv_FifoRcvData);
	    
	    IF (NOT #iqUDT_FifoRcvHeader.Status.Empty                             // FIFO not empty 
	        AND NOT #sa_Status.FIFOError)                                      // No FIFO error 
	    THEN
	        
	        // Mode 'R' - Read FIFO record
	        "FC_Fifo"(ic_Mode := 'R',
	                  qUDT_Status => #sa_Status.FIFORcvStatus,
	                  qx_Error => #sa_Status.FIFOError,
	                  qx_Warning => #sa_Status.FIFOWarning,
	                  iqv_Data := #sUDT_FifoMsg,
	                  iqUDT_FifoHeader := #iqUDT_FifoRcvHeader,
	                  iqv_DataBuffer := #iqv_FifoRcvData);
	        
	        // Message read bit set and position initialize 
	        #tx_MsgRead := TRUE;
	        #si_Position := 0;
	        
	        // FIFO empty or FIFO error occured      
	    ELSE
	        
	        #tx_MsgRead := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 1 – Maximum number of the message characters
	    
	    #si_SizeOfMsg := "FC_GetNrOfArrayEl"(iv_Array := #sUDT_FifoMsg.Character);
	    
	    
	END_REGION
	
	REGION 2 – Decoding header
	    #sUDT_MSGHeader.MessageType := '';
	    
	    IF #tx_MsgRead
	    THEN
	        // Converting message header from array of bytes to UDT.
	        
	        #sdi_DeserializePosition := 0;
	        #si_DeserializeBodyStatus := Deserialize(SRC_ARRAY := #sUDT_FifoMsg,
	                                                 DEST_VARIABLE => #sUDT_MSGHeader,
	                                                 POS := #sdi_DeserializePosition);
	        // Character length into integer conversion
	        #si_Length := STRING_TO_INT(IN := #sUDT_MSGHeader.MessageLength);
	    END_IF;
	END_REGION
	
	REGION 3 - decode Scan Information
	    // Message is read and type is SI
	    IF #tx_MsgRead
	        AND #sUDT_MSGHeader.MessageType = #cs_SI
	    THEN
	        // Convert array of bytes into body structure.
	        #si_DeserializeBodyStatus := Deserialize(SRC_ARRAY := #sUDT_FifoMsg,
	                                                 DEST_VARIABLE => #sUDT_SI,
	                                                 POS := #sdi_DeserializePosition);
	        // Message length is fixed and should be the same
	        IF #si_Length <> #ci_SizeSIMessage
	        THEN
	            #sx_InvalidLength := TRUE;
	        ELSE
	            #sx_InvalidLength := FALSE;
	        END_IF;
	        IF NOT #sx_InvalidLength
	        THEN
	            // Convert 'NNNNNN' part in package ID to GIN number and store data in GIN database
	            #ss_NNNNNN := RIGHT(IN := #sUDT_SI.PackageID, L := 6);
	            STRG_VAL(IN := #ss_NNNNNN,
	                     FORMAT := 16#0,
	                     P := 1,
	                     OUT => #si_GIN);
	            
	            "DB_GIN".GIN[#si_GIN].FedEx.ADCSystemID := #sUDT_SI.ADCSystemID;
	            "DB_GIN".GIN[#si_GIN].FedEx.ScanUnitType := #sUDT_SI.ScanUnitType;
	            "DB_GIN".GIN[#si_GIN].FedEx.ImageID := #sUDT_SI.ImageID;
	            "DB_GIN".GIN[#si_GIN].FedEx.PackageID := #sUDT_SI.PackageID;
	            "DB_GIN".GIN[#si_GIN].FedEx.HLCPackageID := #sUDT_SI.HLCPackageID;
	            "DB_GIN".GIN[#si_GIN].FedEx.DIMSystemID := #sUDT_SI.DIMSystemID;
	            "DB_GIN".GIN[#si_GIN].FedEx.DIMStatus := #sUDT_SI.DimStatus;
	            "DB_GIN".GIN[#si_GIN].FedEx.PackageDimLength := #sUDT_SI.PackageDimLength;
	            "DB_GIN".GIN[#si_GIN].FedEx.PackageDimWidth := #sUDT_SI.PackageDimWidth;
	            "DB_GIN".GIN[#si_GIN].FedEx.PackageDimHeight := #sUDT_SI.PackageDimHeight;
	            "DB_GIN".GIN[#si_GIN].FedEx.DIMUOM := #sUDT_SI.DIMUOM;
	            "DB_GIN".GIN[#si_GIN].FedEx.DimLFTstatusCode := #sUDT_SI.DimLFTstatusCode;
	            "DB_GIN".GIN[#si_GIN].FedEx.AlibiDims := #sUDT_SI.AlibiDims;
	            "DB_GIN".GIN[#si_GIN].FedEx.SCLSystemID := #sUDT_SI.SCLSystemID;
	            "DB_GIN".GIN[#si_GIN].FedEx.SCLStatus := #sUDT_SI.SCLStatus;
	            "DB_GIN".GIN[#si_GIN].FedEx.SCLWT := #sUDT_SI.SCLWT;
	            "DB_GIN".GIN[#si_GIN].FedEx.SCLWTUOM := #sUDT_SI.SCLWTUOM;
	            "DB_GIN".GIN[#si_GIN].FedEx.SCLLFTStatusCode := #sUDT_SI.SCLLFTStatusCode;
	            "DB_GIN".GIN[#si_GIN].FedEx.AlibiWeight := #sUDT_SI.AlibiWeight;
	            "DB_GIN".GIN[#si_GIN].FedEx.Stackable := #sUDT_SI.Stackable;
	            "DB_GIN".GIN[#si_GIN].FedEx.CameraHeadstatus := #sUDT_SI.CameraHeadstatus;
	            "DB_GIN".GIN[#si_GIN].FedEx.PackageDataTruncated := #sUDT_SI.PackageDataTruncated;
	            "DB_GIN".GIN[#si_GIN].FedEx.TotalBarcodeDataLength := #sUDT_SI.TotalBarcodeDataLength;
	            "DB_GIN".GIN[#si_GIN].FedEx.Barcode1Identification := #sUDT_SI.Barcode1Identification;
	            "DB_GIN".GIN[#si_GIN].FedEx.Barcode1status := #sUDT_SI.Barcode1status;
	            "DB_GIN".GIN[#si_GIN].FedEx.Barcode1datalength := #sUDT_SI.Barcode1datalength;
	            "DB_GIN".GIN[#si_GIN].FedEx.Barcode1data := #sUDT_SI.Barcode1data;
	            "DB_GIN".GIN[#si_GIN].FedEx.Barcode2Identification := #sUDT_SI.Barcode2Identification;
	            "DB_GIN".GIN[#si_GIN].FedEx.Barcode2status := #sUDT_SI.Barcode2status;
	            "DB_GIN".GIN[#si_GIN].FedEx.Barcode2datalength := #sUDT_SI.Barcode2datalength;
	            "DB_GIN".GIN[#si_GIN].FedEx.Barcode2data := #sUDT_SI.Barcode2data;
	            "DB_GIN".GIN[#si_GIN].FedEx.Barcode3Identification := #sUDT_SI.Barcode3Identification;
	            "DB_GIN".GIN[#si_GIN].FedEx.Barcode3status := #sUDT_SI.Barcode3status;
	            "DB_GIN".GIN[#si_GIN].FedEx.Barcode3datalength := #sUDT_SI.Barcode3datalength;
	            "DB_GIN".GIN[#si_GIN].FedEx.Barcode3data := #sUDT_SI.Barcode3data;
	        END_IF;
	    END_IF;
	END_REGION
	
	REGION 4 - Decode Weight Scale Message
	    // Message is read and type is WS
	    IF #tx_MsgRead
	        AND #sUDT_MSGHeader.MessageType = #cs_WS
	    THEN
	        // Convert array of bytes into body structure.
	        #si_DeserializeBodyStatus := Deserialize(SRC_ARRAY := #sUDT_FifoMsg,
	                                                 DEST_VARIABLE => #sUDT_WS,
	                                                 POS := #sdi_DeserializePosition);
	        // Message length is fixed and should be the same
	        IF #si_Length <> #ci_SizeWSMessage
	        THEN
	            #sx_InvalidLength := TRUE;
	        ELSE
	            #sx_InvalidLength := FALSE;
	        END_IF;
	        IF NOT #sx_InvalidLength
	        THEN
	            // Convert 'NNNNNN' part in package ID to GIN number and store data in GIN database
	            #ss_NNNNNN := RIGHT(IN := #sUDT_WS.PackageID, L := 6);
	            STRG_VAL(IN := #ss_NNNNNN,
	                     FORMAT := 16#0,
	                     P := 1,
	                     OUT => #si_GIN);
	            
	            "DB_GIN".GIN[#si_GIN].FedEx.SCLSystemID := #sUDT_WS.SCLSystemID;
	            "DB_GIN".GIN[#si_GIN].FedEx.SCLWT := #sUDT_WS.SCLWT;
	            "DB_GIN".GIN[#si_GIN].FedEx.SCLWTUOM := #sUDT_WS.SCLWTUOM;
	            "DB_GIN".GIN[#si_GIN].FedEx.SCLLFTStatusCode := #sUDT_WS.SCLLFTStatusCode;
	            "DB_GIN".GIN[#si_GIN].FedEx.AlibiWeight := #sUDT_WS.AlibiWeight;
	        END_IF;
	    END_IF;
	END_REGION
	
	REGION 5 - Decode Destination Assignment message
	    // Message is read and type is DA
	    IF #tx_MsgRead
	        AND #sUDT_MSGHeader.MessageType = #cs_DA
	    THEN
	        // Convert array of bytes into body structure.
	        #si_DeserializeBodyStatus := Deserialize(SRC_ARRAY := #sUDT_FifoMsg,
	                                                 DEST_VARIABLE => #sUDT_DA,
	                                                 POS := #sdi_DeserializePosition);
	        // Message length is fixed and should be the same
	        IF #si_Length <> #ci_SizeDAMessage
	            OR #si_Length <> #si_SizeOfMsg
	        THEN
	            #sx_InvalidLength := TRUE;
	        ELSE
	            #sx_InvalidLength := FALSE;
	        END_IF;
	        IF NOT #sx_InvalidLength
	        THEN
	            // Convert 'NNNNNN' part in package ID to GIN number and store data in GIN database
	            #ss_NNNNNN := RIGHT(IN := #sUDT_DA.PackageID, L := 6);
	            STRG_VAL(IN := #ss_NNNNNN,
	                     FORMAT := 16#0,
	                     P := 1,
	                     OUT => #si_GIN);
	            
	            "DB_GIN".GIN[#si_GIN].FedEx.HLCPackageID := #sUDT_DA.HLCPackageID;
	            "DB_GIN".GIN[#si_GIN].FedEx.CellNumber := #sUDT_DA.CellNumber;
	            "DB_GIN".GIN[#si_GIN].FedEx.Destination1 := #sUDT_DA.Destination1;
	            "DB_GIN".GIN[#si_GIN].FedEx.CutOffTimeDestination1 := #sUDT_DA.CutOffTimeDestination1;
	            "DB_GIN".GIN[#si_GIN].FedEx.Destination2 := #sUDT_DA.Destination2;
	            "DB_GIN".GIN[#si_GIN].FedEx.CutOffTimeDestination2 := #sUDT_DA.CutOffTimeDestination2;
	            "DB_GIN".GIN[#si_GIN].FedEx.Destination3 := #sUDT_DA.Destination3;
	            "DB_GIN".GIN[#si_GIN].FedEx.CutOffTimeDestination3 := #sUDT_DA.CutOffTimeDestination3;
	            "DB_GIN".GIN[#si_GIN].FedEx.Destination4 := #sUDT_DA.Destination4;
	            "DB_GIN".GIN[#si_GIN].FedEx.CutOffTimeDestination4 := #sUDT_DA.CutOffTimeDestination4;
	            "DB_GIN".GIN[#si_GIN].FedEx.Destination5 := #sUDT_DA.Destination5;
	            "DB_GIN".GIN[#si_GIN].FedEx.CutOffTimeDestination5 := #sUDT_DA.CutOffTimeDestination5;
	            "DB_GIN".GIN[#si_GIN].FedEx.HLCDataText := #sUDT_DA.HLCDataText;
	            "DB_GIN".GIN[#si_GIN].FedEx.Barcodedata := #sUDT_DA.Barcodedata;
	            "DB_GIN".GIN[#si_GIN].FedEx.HLCResultCode := #sUDT_DA.HLCResultCode;
	        END_IF;
	    END_IF;
	END_REGION
	
	REGION 6 - Decode destination Re-Assignment message
	    // Message is read and type is RA
	    IF #tx_MsgRead
	        AND #sUDT_MSGHeader.MessageType = #cs_RA
	    THEN
	        // Convert array of bytes into body structure.
	        #si_DeserializeBodyStatus := Deserialize(SRC_ARRAY := #sUDT_FifoMsg,
	                                                 DEST_VARIABLE => #sUDT_RA,
	                                                 POS := #sdi_DeserializePosition);
	        // Message length is fixed and should be the same
	        IF #si_Length <> #ci_SizeRAMessage
	            OR #si_Length <> #si_SizeOfMsg
	        THEN
	            #sx_InvalidLength := TRUE;
	        ELSE
	            #sx_InvalidLength := FALSE;
	        END_IF;
	        IF NOT #sx_InvalidLength
	        THEN
	            // Convert 'NNNNNN' part in package ID to GIN number and store data in GIN database
	            #ss_NNNNNN := RIGHT(IN := #sUDT_RA.PackageID, L := 6);
	            STRG_VAL(IN := #ss_NNNNNN,
	                     FORMAT := 16#0,
	                     P := 1,
	                     OUT => #si_GIN);
	            
	            "DB_GIN".GIN[#si_GIN].FedEx.HLCPackageID := #sUDT_RA.HLCPackageID;
	            "DB_GIN".GIN[#si_GIN].FedEx.CellNumber := #sUDT_RA.CellNumber;
	            "DB_GIN".GIN[#si_GIN].FedEx.Destination1 := #sUDT_RA.Destination1;
	            "DB_GIN".GIN[#si_GIN].FedEx.CutOffTimeDestination1 := #sUDT_RA.CutOffTimeDestination1;
	            "DB_GIN".GIN[#si_GIN].FedEx.Destination2 := #sUDT_RA.Destination2;
	            "DB_GIN".GIN[#si_GIN].FedEx.CutOffTimeDestination2 := #sUDT_RA.CutOffTimeDestination2;
	            "DB_GIN".GIN[#si_GIN].FedEx.Destination3 := #sUDT_RA.Destination3;
	            "DB_GIN".GIN[#si_GIN].FedEx.CutOffTimeDestination3 := #sUDT_RA.CutOffTimeDestination3;
	            "DB_GIN".GIN[#si_GIN].FedEx.Destination4 := #sUDT_RA.Destination4;
	            "DB_GIN".GIN[#si_GIN].FedEx.CutOffTimeDestination4 := #sUDT_RA.CutOffTimeDestination4;
	            "DB_GIN".GIN[#si_GIN].FedEx.Destination5 := #sUDT_RA.Destination5;
	            "DB_GIN".GIN[#si_GIN].FedEx.CutOffTimeDestination5 := #sUDT_RA.CutOffTimeDestination5;
	            "DB_GIN".GIN[#si_GIN].FedEx.HLCDataText := #sUDT_RA.HLCDataText;
	            "DB_GIN".GIN[#si_GIN].FedEx.Barcodedata := #sUDT_RA.Barcodedata;
	            "DB_GIN".GIN[#si_GIN].FedEx.HLCResultCode := #sUDT_RA.HLCResultCode;
	        END_IF;
	    END_IF;
	END_REGION
	
	REGION 6 - Heartbeat Signal
	    // Message is read and type is HB
	    IF #tx_MsgRead
	        AND #sUDT_MSGHeader.MessageType = #cs_HB
	    THEN
	        #iqx_HeartbeatOk := TRUE;
	        
	    END_IF;
	END_REGION
END_FUNCTION_BLOCK

