TYPE "UDT_DeviceState"
TITLE = UDT_DeviceState
VERSION : 0.1
//User-defined structure of device states.
   STRUCT
      Configure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Device configured in TIA Portal hardware
      Exist { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Device physically connected
      Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Device has an error
      ProfinetNumber : UInt;   // Profinet slave number
      HW_ID : UInt;   // Device's HW_ID
      PNDeviceName : String;   // Device's project name
   END_STRUCT;

END_TYPE

TYPE "UDT_ModuleState"
TITLE = UDT_ModuleState
VERSION : 0.1
//User-defined structure of module states.
   STRUCT
      Configured { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Module configured
      Exist { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Module exist
      Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Module has error
   END_STRUCT;

END_TYPE

TYPE "UDT_GINWES"
VERSION : 0.1
   STRUCT
      Barcode : String[40];
   END_STRUCT;

END_TYPE

TYPE "UDT_EventStatistic"
TITLE = UDT_EventStatistic
VERSION : 0.1
//User-defined structure of event statistic data.
   STRUCT
      NumberOfTimes : DInt;   // Number of times the event occurred since last reset
      LastEventSeconds : DInt;   // Number of seconds of the current or last event
      TotalEventSeconds : DInt;   // Total number of seconds the event occurred since last reset
   END_STRUCT;

END_TYPE

TYPE "UDT_ProfinetDevice"
TITLE = UDT_ProfinetDevice
VERSION : 0.1
//User-defined structure of profinet device state.
   STRUCT
      DeviceState : "UDT_DeviceState";   // Device state
      Module { S7_SetPoint := 'False'} : Array[0..31] of "UDT_ModuleState";   // Modules
   END_STRUCT;

END_TYPE

TYPE "UDT_GINWCS"
VERSION : 0.1
   STRUCT
      ActionTaken : String;   // Location code value that describes the actual disposition of the package
      Destination1 : String[20];   // Location code value that describes where the package should go (Diverter Number)
      Destination2 : String[20];   // Location code value that describes where the package should go (Diverter Number)
      Destination3 : String[20];   // Location code value that describes where the package should go (Diverter Number)
      Destination4 : String[20];   // Location code value that describes where the package should go (Diverter Number)
      Destination5 : String[20];   // Location code value that describes where the package should go (Diverter Number)
      ReasonCode : String[2];   // Management Code value that describes the result of attempting to route the package to the Destination
      Barcode1 : String;   // Barcode identifier code
      Barcode2 : String;
      Barcode3 : String;
      Barcode4 : String;
   END_STRUCT;

END_TYPE

TYPE "UDT_GINStandard"
VERSION : 0.1
   STRUCT
      Destination : Array[0..20] of DInt;   // Destination
      Identification : Struct   // Barcode identification
         GoodRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Barcode read was succesful
         NoRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Barcode read was unsuccesful
         MultiRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Multiple Barcodes were detected
         Barcode : Array[0..10] of Char;   // Barcode values
      END_STRUCT;
      GinAssigned { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // GIN is assigned to package
      Lost { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Lost in tracking
      Length : Int;   // Length in mm
      Width : Int;   // Width in mm
      Height : Int;   // Height in mm
      Weight : DInt;   // Weight in g
      PkgTooLong { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is too long
      PkgTooSmall { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is too small
      PkgTooHigh { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is too high
      PkgOverWeight { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is over weight
      TrailingGap : Int;   // Trailing gap size in cm between the package
      LeadingGap : Int;   // Leading gap size in cm between the package
      NrOfRecirculations : Int;   // Number of recirculations
      DestReqSend { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Destination request sent to high level
      DestRcv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Destination received from high level
      SortStatus : Struct   // Sort status of the package
         DivertDestination : Int;   // Destination to which the package is diverted
         GoodDivert { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package diverted
         FailedDivert { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package failed to divert
         NoDivert : Bool := TRUE;   // Divert is not activated
         NoDivertCause : Struct   // Cause for no divert
            ChuteJam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Chute is jammed
            ChuteFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Chute is full
            NoRTR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Downstream conveyor is not ready to receive
            DestDisabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Destination is disabled
            TrayDisabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Tray is disabled
            SorterNotAtSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sorter is not at speed
            LeadingGapError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Gap size with downstream parcel is not enough
            TrailingGapError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Gap size with upstream parcel is not enough
            PkgTooHigh { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is too high to divert
            PkgTooLong { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is too long to divert
            DestNotReachable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sort destionation is not reachable
            InvalidDest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sort destination is invalid
            DestTooLate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Destination too late
            NoDestRcv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Destination not received from high level
         END_STRUCT;
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_GINFedEx"
VERSION : 0.1
   STRUCT
      Timestamp : String[17];   // Local time timestamp
      TimeZoneDesignator : String[5];   // Time zone designator
      PackageEntrancePoint : String[14];   // Entrance point, where LLC starts tracking the parcel.
      PackageEntranceState : String[1];   // Entrance state
      PackageExitPoint : String[14];   // Exit point name, where LLC reports the last known tracking point.
      PackageExitState : String[1];   // Exit point state when LLC reports the last known tracking point.
      PalletType : String[2];   // Pallet code for different type of pallets on the market
      Mask : String[1];   // Flag to indicate that a pallet has been mask.
      CellNumber : String[4];   // Tray/Cell number (for loop sorters) or generated by LLC (on line sorters).
      CellsOccupied : String[1];   // Cells occupied by the piece for loop sorters.
      ImageID : String[6];   // Image ID number created by the ADC system.
      ScanUnitType : String[1];   // Scan unit type
      ADCSystemID : String[15];   // Number assigned by the ADC system
      PackageID : String[15];   // Number assigned by the LLC system
      LLCSystemID : String[15];
      HLCPackageID : String[10];   // Unique number for the specific package during it stays in HLC system.
      HLCResultCode : String[16];   // Result code based on processing of the scan event messages.
      ShipmentID : String[6];   // Consignment id of the parcel.
      WeightStatus : String[1];   // Status to indicate if the parcel/pallet has weight on the system.
      ActualDestination : String[6];   // Location code value that describes the actual disposition of the package.
      Destination1 : String[6];   // Location code value that describes where the package should go (Diverter Number).
      Destination2 : String[6];   // Location code value that describes where the package should go (Diverter Number).
      Destination3 : String[6];   // Location code value that describes where the package should go (Diverter Number).
      Destination4 : String[6];   // Location code value that describes where the package should go (Diverter Number).
      Destination5 : String[6];   // Location code value that describes where the package should go (Diverter Number).
      CutOffTimeDestination1 : String[5];   // Cut Off Time in Local Time.
      CutOffTimeDestination2 : String[5];   // Cut Off Time in Local Time.
      CutOffTimeDestination3 : String[5];   // Cut Off Time in Local Time.
      CutOffTimeDestination4 : String[5];   // Cut Off Time in Local Time.
      CutOffTimeDestination5 : String[5];   // Cut Off Time in Local Time.
      ReasonCode1 : String[8];   // Management Code value that describes the result of attempting to route the package to the Destination
      ReasonCode2 : String[8];   // Management Code value that describes the result of attempting to route the package to the Destination
      ReasonCode3 : String[8];   // Management Code value that describes the result of attempting to route the package to the Destination
      ReasonCode4 : String[8];   // Management Code value that describes the result of attempting to route the package to the Destination
      ReasonCode5 : String[8];   // Management Code value that describes the result of attempting to route the package to the Destination
      HLCDataText : String[20];   // Free text for future use.
      Customs : String[1];   // Need to be checked by customs
      DIMSystemID : String[15];   // Identifier of dimensioning system.
      DIMStatus : String[5];   // Basic diagnostic information from the dimensioning system at the moment of the measurement.
      PackageDimLength : String[6];   // Length dimension of package in resolution of dim system.
      PackageDimWidth : String[6];   // Width dimension of package in resolution of dim system.
      PackageDimHeight : String[6];   // Height dimension of package in resolution of dim system.
      DIMUOM : String[2];   // Unit of measure of the package dimensions.
      DimLFTstatusCode : String[8];   // Dimension LFT status code.
      DimConfidence : String[2];   // The level of assurance for the correct dimensions.
      DimensionSource : String[1];   // For combined camera/laser dim acquisition devices. It indicates type of capturing mode
      AlibiDims : String[25];   // Alibi for Dimensions
      SCLSystemID : String[15];   // Identifier of weight scale.
      SCLStatus : String[5];   // Basic diagnostic information from the weight scale system.
      SCLWT : String[6];   // Scale weight of package in resolution of scale system.
      SCLWTUOM : String[2];   // Unit of measurement for Weight
      SCLLFTStatusCode : String[2];   // Scale LFT status code.
      AlibiWeight : String[25];   // Alibi for Weight
      ReasonCode : String[1];   // This code should be used when the SI message has some defect.
      Stackable : String[1];   // If stackable recognition is enabled, Y or N
      Stickerstype : String[2];   // When optical recognition is used to sort
      FlyingDocument : String[1];   // Status to confirm if the document/flyer is prone to fly off the sorter.
      ModeofOperation : String[1];   // Camera Tunnel operational mode format:
      CameraHeadstatus : String[2];   // Diagnostic information on camera/laser heads performing barcode reads.
      PackageDataTruncated : String[1];   // Y = Full length of barcode data exceeds 9999 bytes, data truncated
      TotalBarcodeDataLength : String[4];   // Length of all barcode data that was sent in bytes;
      Barcode1Identification : String[3];   // Barcode identifier code.
      Barcode1status : String[2];   // Barcode confidence factor
      Barcode1datalength : String[4];   // String length of barcode data in bytes; inclusive of this field. Use 0054 as a fixed value
      Barcode1data : String[50];   // Highest priority barcode
      Barcode2Identification : String[3];   // Barcode identifier code.
      Barcode2status : String[2];   // Barcode confidence factor
      Barcode2datalength : String[4];   // String length of barcode data in bytes; inclusive of this field. Use 0054 as a fixed value
      Barcode2data : String[50];   // Highest priority barcode
      Barcode3Identification : String[3];   // Barcode identifier code.
      Barcode3status : String[2];   // Barcode confidence factor
      Barcode3datalength : String[4];   // String length of barcode data in bytes; inclusive of this field. Use 0054 as a fixed value
      Barcode3data : String[50];   // Highest priority barcode
      BarcodeIdentification : String[3];   // Barcode identifier code.
      Barcodestatus : String[2];   // Barcode confidence factor
      Barcodedatalength : String[4];   // String length of barcode data in bytes
      Barcodedata : String[50];   // Sortation barcode
      CustomerID : DInt;   // 6 digits SequentialID (NNNNNN)
      AreaNumber : String[2];   // Package Sequence ID "Area Number"
      PurgeEnabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Purge enabled for parcel: destination overwritten with Purge destination
   END_STRUCT;

END_TYPE

TYPE "UDT_CommonStatus"
TITLE = UDT_CommonStatus
VERSION : 0.1
//User-defined structure of common statuses.
   STRUCT
      SafetyStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Emergancy stop
      Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // An error is active
      Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // A warning is active
      ManualRun { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Running in manual mode
      Manual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // In manual mode
      Halted { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Halted
      Dieback { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // In dieback
      Stopped { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stopped
      Running { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Running
      EnergySave { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // In energy saving mode
      AutoON { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Automatic started
   END_STRUCT;

END_TYPE

TYPE "UDT_GINDHL"
VERSION : 0.1
   STRUCT
      ObjectID : String[10];   // Object ID
      VID : String[16];   // Virtual Item Identifier (VID)
      PieceID : String[40];   // Piece ID barcodes
      SortStrategy : String[1];   // Sort Strategy 1 - Highest priority available , 2 - Nearest
      ParcelReject { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Parcel reject
      Destination : Array[1..6] of Struct   // Destination
         ID : UInt;   // ID
         SortCommandActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sort command
         ParcelSorted { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parcel sorted
         Rejected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parcel rejected
         Reason : Int;   // Reason
      END_STRUCT;
      ParcelLocation : Struct   // Parcel Location
         Current : UInt;   // Current
         Last : UInt;   // Last
         Sort : UInt;   // Sort
      END_STRUCT;
      MFCMessage : Struct   // MFC Sort messages
         Sent : Struct   // Messages sent from the PLC to the MFC system
            SortResult { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Sort Result
            VIDResponse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message VID Response
            ScanReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Scan Reset
            XrayResult { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Xray result
            ParcelRegInfo { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Xray registration info
         END_STRUCT;
         Received : Struct   // Messages received from the MFC system to the PLC
            RejectParcel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Reject Parcel
            Destination { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Destination
            DestinationResent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Destination Resent
            TemporaryParcelIdentifier { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Temporary Parcel Identifier
            XrayRegistrationInfo { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         END_STRUCT;
      END_STRUCT;
      Xray : Struct   // Xray data structure
         RoutingCode : String[2];   // Routing code
         Group : String[1];   // The group field is used to identify the group of the operator decisions came from in a
         Level : String[1];   // Level field is used to identify which level the operator decision came from in a
         Result : String[1];   // Results can be indicated with the following:A = Accept, R = Reject, U = Unavailable (Timeout), Z = High Threat
         BagIDMessage : Struct   // Message from PLC to Xray
            MessagePrepared { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message is prepared and ready to send
            WrongMessageStructure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message has wrong structure
            Sent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message sent by PLC to Xray
            SentTime : String;   // Time when message sent by PLC to Xray
            NotSent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message was not sent from the PLC
            Received { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message received by Xray
            TimeReceived : String;   // Time when message received by Xray
            NotReceived { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message did not reach Xray
         END_STRUCT;
         DecisionMessage : Struct   // Message from Xray to PLC
            Received { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message received by PLC
            ReceivedTime : String;   // The message received by PLC
            NotReceivedOnTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message did not reach PLC
         END_STRUCT;
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_GINUPS"
VERSION : 0.1
   STRUCT
      TRKNUM : String[18];   // Tracking number
      PKGUID : String[32];   // Package ID
      MSGID : String[32];   // Message ID
      Length : Int;   // Camera Length in mm
      Width : Int;   // Camera Width in mm
      Height : Int;   // Camera Height in mm
      Weight : DInt;   // Weight in g
      IDCreated { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 1, Bit 0 - PLCID created or TrayID Read
      DimDataRcv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 1, Bit 1 - Package Dimensional Data Received via Camera Scan Data Message
      PkgWrongInduct { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 1, Bit 2 - Package Did NOT Induct Properly (Non-Tray Systems)
      IDCalcFromCamID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 2, Bit 0 - PLCID/TrayID Calculated From CamID
      UnknownParcelID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 2, Bit 4 - Unknown Parcel ID
      UndefinedProblem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 2, Bit 5 - Un-Defined Problem
      UnrecognizedCmd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 2, Bit 6 - Un-recognized command
      SorterInMainteneceMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 2, Bit 7 - Sorter in Maintenance/Commissioning Mode
      DestUserSusp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 3, Bit 3 - Destination User Suspended
      SorterNotSynch { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 3, Bit 6 - Sorter NOT Synchronized (Tilt Tray Systems)
      PkgDetAtVerCheckPoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 4, Bit 0 - Package Detected at Verification Check Point
      ChuteFullAftrAlterDest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 4, Bit 7 - Preferred chute full after passed alternate destination
      ChuteNotAvailAfterAlterDest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 5, Bit 0 - Preferred chute not available after passed alternate destination
      PLCRedirected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 5, Bit 2 - PLC Redirected
      ThreatParcel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Threat parcel
   END_STRUCT;

END_TYPE

TYPE "UDT_PECStatistics"
VERSION : 0.1
   STRUCT
      Jam : "UDT_EventStatistic";   // Number of times PEC got jammed
   END_STRUCT;

END_TYPE

TYPE "UDT_ProfinetNetwork"
TITLE = UDT_ProfinetNetwork
VERSION : 0.1
//User-defined structure of profinet network state.
   STRUCT
      DeviceStatus : Array[0..512] of "UDT_ProfinetDevice";   // Profinet device status
   END_STRUCT;

END_TYPE

TYPE "UDT_GIN"
VERSION : 0.1
   STRUCT
      General { S7_SetPoint := 'False'} : "UDT_GINStandard";
      FedEx { S7_SetPoint := 'False'} : "UDT_GINFedEx";
      UPS { S7_SetPoint := 'False'} : "UDT_GINUPS";
      DHL { S7_SetPoint := 'False'} : "UDT_GINDHL";
      WCS { S7_SetPoint := 'False'} : "UDT_GINWCS";
      WES { S7_SetPoint := 'False'} : "UDT_GINWES";
   END_STRUCT;

END_TYPE

TYPE "UDT_ConveyorCommonConfiguration"
VERSION : 0.1
   STRUCT
      Length : DInt;   // Conveyor length [mm]
      LengthCorrection : DInt;   // Length correction [mm]
   END_STRUCT;

END_TYPE

DATA_BLOCK "DB_Memory"
TITLE = DB_Memory
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
VERSION : 3.0
NON_RETAIN
   VAR 
      ClockByte { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // System clock byte
      Clock_10Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 10 Hz system clock bit
      Clock_5Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 5 Hz system clock bit
      "Clock_2.5Hz" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 2.5 Hz system clock bit
      Clock_2Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 2 Hz system clock bit
      "Clock_1.25Hz" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1.25 Hz system clock bit
      Clock_1Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 Hz system clock bit
      "Clock_0.625Hz" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0.625 Hz system clock bit
      "Clock_0.5Hz" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0.5 Hz system clock bit
      SystemByte { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // System byte
      OSClockByte { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // One shot of clock pulse
      "OS_0.1sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 0.1 sec
      "OS_0.2sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 0.2 sec
      "OS_0.4sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 0.4 sec
      "OS_0.5sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 0.5 sec
      "OS_0.8sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 0.8 sec
      OS_1sec { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 1 sec
      "OS_1.6sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 1.6 sec
      OS_2sec { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 2 sec
      PrevCycleTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Previous PLC cycle Time
      RuntimeMem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Runtime memory
      FirstScan { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // First scan bit
      DiagStatusUpdate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Diagnostic status update
      AlwaysTrue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Always True bit
      AlwaysFalse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Always False bit
      CommissioningFalse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Commissioning always false
      CommissioningTrue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Commissioning always true
      ReconnectCommand { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reconnect command
      ScanMainRack { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Trigger to check main rack confiuration
      ScanProfinet { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Scan profinet bit
      Simulation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Simulation
      PN1OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet ok
      "Local~PROFINET_IO-System" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IO System
      "Local~PROFINET_IO-System_1" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 1
      "Local~PROFINET_IO-System_2" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 2
      "Local~PROFINET_IO-System_3" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 3
      "Local~PROFINET_IO-System_4" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 4
      "Local~PROFINET_IO-System_5" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 5
      "Local~PROFINET_IO-System_6" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 6
      "Local~PROFINET_IO-System_7" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 7
      "Local~PROFINET_IO-System_8" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 8
      "Local~PROFINET_IO-System_9" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 9
   END_VAR


BEGIN

END_DATA_BLOCK

TYPE "UDT_AixMotorStatus"
VERSION : 0.1
   STRUCT
      Overheat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor temperature has exceeded 105 degrees Celsius
      MaxTorque { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor at maximum torque output
      ShortCircuit { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor short circuit
      MotorNotConnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor is not connected
      Overload { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor overloaded after more than 20 seconds in Stalled
      Stalled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor stalled and speed is less than 10% of the set speed
      BadHall { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor Hall Effect Sensor error active
      MotorNotUsed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor is not used
      MotorStatus1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor running and direction status
      MotorStatus2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor running and direction status
      MotorPortinDOmode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor port is in digital output mode .
      Bit03 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
      Bit04 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
      BoardOverheat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
      OverVoltage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Supply voltage + motor back EMF exceeded 30 volts
      LowVoltage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Module power supply is less than 18 Volts
      MotorStatus : DWord;
   END_STRUCT;

END_TYPE

TYPE "UDT_EquipmentControl"
TITLE = UDT_EquipmentControl
VERSION : 0.1
//User-defined structure of equipment control commands.
   STRUCT
      Command : Struct   // Control command
         Start { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start conveyor
         Stop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stop conveyor
         Reset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Faults reset
         ResetData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Statistics reset
         ManualMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual mode required
         DisableManualMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disable manual mode
         AutomaticOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // System is started in automatic mode
         StopRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      END_STRUCT;
      Report { S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Conveyors state
      Request : Struct   // Request from equipment
         RestartRequired { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Restart required from system control
         SignalingRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Beeper required
         InhibitStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_PECUpdateStatus"
TITLE = UDT_PECUpdateStatus
VERSION : 0.1
//User-defined structure of FB_PECUpdate function block status.
   STRUCT
      TooManyLost { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Too many parcels lost in a row
      LowPerformance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Performance warning
      PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Current state of the end of section photo eye
      Jam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PEC Jam error
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_TimerOnOffDelay"
TITLE = FB_TimerOnOffDelay
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 32
// END_ATTRIBUTES
//Function block to generate on/off signal delay.
   VAR_INPUT 
      iudi_OnDelayTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // On delay time [ms]
      iudi_OffDelayTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Off delay time [ms]
      ix_SignalToDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Input signal to be delayed
      ix_Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;   // Timer Enable
   END_VAR

   VAR_OUTPUT 
      qlr_ActualTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Actual time
      qx_DelayedSignal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Delayed signal output
   END_VAR

   VAR 
      s_R_TRIG_Signal {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Siemens "R_Trig" - to prepare the rising edge trigger on "ix_SignalToDelay" signal
      s_F_TRIG_Signal {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Siemens "F_Trig" - to prepare the falling edge trigger on "ix_SignalToDelay" signal
   END_VAR
   VAR RETAIN
      slr_ActualDelayTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Actual delay time [ms]
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	26/08/2019  | 2.1       | M.Kurpiers    | Comments adjusted
	04/11/2019  | 2.2       | L.Klar        | Prevoius cycle scan changed from memory to DB variable
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION Step 1 – Input signal edge detection 
	    
	    #s_R_TRIG_Signal(CLK := #ix_SignalToDelay);
	    
	    
	    #s_F_TRIG_Signal(CLK := #ix_SignalToDelay);
	    
	END_REGION
	
	REGION Step 2 – Actual delay time initialization
	    
	    IF (#s_R_TRIG_Signal.Q OR #s_F_TRIG_Signal.Q)           // Input signal changed        
	    THEN
	        
	        #slr_ActualDelayTime := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION Step 3 – On/Off delay time calculation
	    
	    
	    IF (#ix_SignalToDelay                                       // Signal to be delayed is active
	        AND #ix_Enable)                                         // Ttimer enabled                   
	    THEN
	        
	        // Timer on
	        IF (#slr_ActualDelayTime >= #iudi_OnDelayTime)
	        THEN
	            
	            #qx_DelayedSignal := TRUE;
	            
	        ELSE
	            
	            #slr_ActualDelayTime += "DB_Memory".PrevCycleTime;
	            
	        END_IF;
	        
	    END_IF;
	    
	    // Timer off
	    IF (NOT #ix_SignalToDelay                                   // Signal to delay is not active
	        AND #ix_Enable)                                         // Timer is enabled                  
	    THEN
	        
	        IF (#slr_ActualDelayTime >= #iudi_OffDelayTime)
	        THEN
	            
	            #qx_DelayedSignal := FALSE;
	            
	        ELSE
	            
	            #slr_ActualDelayTime += "DB_Memory".PrevCycleTime;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION Step 4 – Actual time
	    
	    #qlr_ActualTime := #slr_ActualDelayTime;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION "FC_EquipmentReport" : Void
TITLE = FC_Equipment_Report
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 16
// END_ATTRIBUTES
//Function to generate equipment report.
   VAR_INPUT 
      iUDT_Status : "UDT_CommonStatus";   // Status structure
   END_VAR

   VAR_IN_OUT 
      iqUDT_Control : "UDT_EquipmentControl";   // Equipment control
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | F.Baten       | first release MHS TIA 15.1
	17/06/2019  | 0.3       | L.Klar        | Manual mode added to "UDT_EquipmentControl"
	17/07/2019  | 0.4       | A.Nowak       | Add all statuses and comments
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	27/08/2019  | 2.1       | K.Pokorski    | Comments adjusted
	16/09/2019  | 2.2       | K.Pokorski    | Equipment error free condition added to "Restart required" status
	06/10/2019  | 2.3       | S. Deukar     | Updated accoring to new UDT equipment report
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	05/02/2024  | 3.1       | L.Klar        | Auto On extention added 
	13/03/2024  | 4.0       | S. Nieswiec   | Added to baseline
	*)
	
	REGION 1 - Equipment report update
	    
	    // Extension of stopped equipment report with the stopped status
	    #iqUDT_Control.Report.Stopped := #iUDT_Status.Stopped
	    OR #iqUDT_Control.Report.Stopped;
	    
	    // Extension of started equipment report with the started status
	    #iqUDT_Control.Report.Running := #iUDT_Status.Running
	    OR #iqUDT_Control.Report.Running;
	    
	    // Extension of energy save equipment report with the energy save status
	    #iqUDT_Control.Report.EnergySave := #iUDT_Status.EnergySave
	    OR #iqUDT_Control.Report.EnergySave;
	    
	    // Extension of warning equipment report with the warning status
	    #iqUDT_Control.Report.Warning := #iUDT_Status.Warning
	    OR #iqUDT_Control.Report.Warning;
	    
	    // Extension of manual mode equipment report with the manual mode status
	    #iqUDT_Control.Report.Manual := #iUDT_Status.Manual
	    OR #iqUDT_Control.Report.Manual;
	    
	    // Extension of error equipment report with the error status
	    #iqUDT_Control.Report.Error := #iUDT_Status.Error
	    OR #iqUDT_Control.Report.Error;
	    
	    // Extension of safety stop equipment report with the safety stop status
	    #iqUDT_Control.Report.SafetyStop := #iUDT_Status.SafetyStop
	    OR #iqUDT_Control.Report.SafetyStop;
	    
	    // Extension of Auto On equipment report with the Auto On status
	    #iqUDT_Control.Report.AutoON := #iUDT_Status.AutoON
	    OR #iqUDT_Control.Report.AutoON;
	    
	    // Extension of restart required equipment report with the restart required and no equipment error statuses
	    #iqUDT_Control.Request.RestartRequired := #iUDT_Status.Stopped
	    AND NOT #iUDT_Status.Error
	    OR #iqUDT_Control.Request.RestartRequired;
	    
	END_REGION
END_FUNCTION

DATA_BLOCK "DB_HMIStatusConfiguration"
TITLE = DB_HMIStatusConfiguration
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
VERSION : 3.0
NON_RETAIN
   VAR 
      FireAlarm : Int;   // Fire alarm active
      SafetyStop : Int;   // Safety stop error status
      Error : Int;   // Error status
      Warning : Int;   // Warning status
      ManualRun : Int;   // Manual run status
      Manual : Int;   // Manual status
      Halted : Int;   // Halted status
      Dieback : Int;   // Die back status
      Stopped : Int;   // Stopped status
      Running : Int;   // Running status
      EnergySave : Int;   // Energy save status
      CommunicationError : Int;   // Communication error status
      CBError : Int;   // CB error status
      ProfinetError : Int;   // Profinet error status
      HardwareError : Int;   // Hardware error status
      VFDNotHealthy : Int;   // VFD noth healthy status
      VFDError : Int;   // VFD error status
      PECJam : Int;   // PEC jam status
      ChuteFull : Int;   // Chute full status
      EncoderError : Int;   // Encoder error status
      TrackingError : Int;   // Tracking error status
      DimensionError : Int;   // Dimension error status
      OperationalError : Int;   // Operational error status
      AutoON : Int;   // Automatic is on
      ChuteHalfFull : Int;   // Disable by operator
      DisableByManagement : Int;   // Disable by management
      GateOpen : Int;   // Manual operated gate is open
      GateClosed : Int;   // Manual operated gate is closed
      GateClosedAndNoOperatorPresent : Int;   // Manual operated gate is closed and no operator is present
      PositionChangeOngoing : Int;   // Lifting device or arm diverter changing position
      BufferMode : Int;   // BufferMode Active
      ContinuousMode : Int;   // ContinuousMode Active
      LabbelingMode : Int;   // LabbelingMode Active
   END_VAR


BEGIN
   FireAlarm := 1;
   SafetyStop := 3;
   Error := 5;
   Warning := 7;
   ManualRun := 9;
   Manual := 11;
   Halted := 13;
   Dieback := 15;
   Stopped := 17;
   Running := 19;
   EnergySave := 21;
   CommunicationError := 23;
   CBError := 25;
   ProfinetError := 27;
   HardwareError := 29;
   VFDNotHealthy := 31;
   VFDError := 33;
   PECJam := 35;
   ChuteFull := 37;
   EncoderError := 39;
   TrackingError := 41;
   DimensionError := 43;
   OperationalError := 45;
   AutoON := 47;
   ChuteHalfFull := 49;
   DisableByManagement := 51;
   GateOpen := 53;
   GateClosed := 55;
   GateClosedAndNoOperatorPresent := 57;
   PositionChangeOngoing := 59;
   BufferMode := 61;
   ContinuousMode := 63;
   LabbelingMode := 65;

END_DATA_BLOCK

TYPE "UDT_FifoStatus"
TITLE = UDT_FifoStatus
VERSION : 0.1
//
//User-defined structure of FC_Fifo function status.
//Version History:
//Date              | Version   | Author         | Remark
//24/05/2019  | 0.1           | K.Pokorski   | first release MHSE TIA 15.1
//24/05/2019  | 0.2           | K.Pokorski   | first release MHSE TIA 15.1
//
   STRUCT
      InvalidMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid mode selected
      InvalidMaxNrOfEntries { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid maximum number of entries or buffer is not an array
      InvalidTotalEntriesStored { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid total number of entries
      InvalidNextEntryToWrite { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid number of next entry to write
      InvalidNextEntryToRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid number of next entry to read
      InvalidDataType { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message and buffer element data type inconsistent
      FifoPreFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 90 % of FIFO data buffer capacity reached
      FifoFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO data buffer full
   END_STRUCT;

END_TYPE

TYPE "UDT_PNDevice"
VERSION : 0.1
   STRUCT
      PNNetworknumber : Int := 1;   // Number of the profinet network where device exist
      PNDeviceNumber : Int := 0;   // Profinet number of the device
      PNDeviceFound { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Device found in Profinet structure
   END_STRUCT;

END_TYPE

FUNCTION "FC_GetNrOfArrayEl" : Int
TITLE = FC_GetNrOfArrayEl
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 19
// END_ATTRIBUTES
//Function to get the number of array elements.
   VAR_INPUT 
      iv_Array : Variant;   // Input array
   END_VAR

   VAR_TEMP 
      ti_NrOfArrayEl : Int;   // Number of array elements
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	27/08/2019  | 2.1       | K.Pokorski    | Comments adjusted
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – Number of an array elements
	    
	    IF IS_ARRAY(#iv_Array)                                                  // Input variable is an array
	    THEN
	        
	        #ti_NrOfArrayEl := UDINT_TO_INT(CountOfElements(#iv_Array));
	        
	        // Reset array length if the input variable isn't an array
	    ELSE
	        
	        #ti_NrOfArrayEl := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 – Return output
	    
	    #FC_GetNrOfArrayEl := #ti_NrOfArrayEl;
	    
	END_REGION
	
END_FUNCTION

TYPE "UDT_ValveStatistics"
VERSION : 0.1
   STRUCT
      Open : "UDT_EventStatistic";   // Number of times PEC got jammed
      Fail : "UDT_EventStatistic";
   END_STRUCT;

END_TYPE

TYPE "UDT_PECUpdateStatistics"
TITLE = UDT_PECupdateStatistics
VERSION : 0.1
//User-defined structure of FB_PECUpdate function block statistics.
   STRUCT
      PEC { S7_SetPoint := 'False'} : "UDT_PECStatistics";   // PEC Statistics
      TooManyLost { S7_SetPoint := 'False'} : "UDT_EventStatistic";   // Too many lost parcels
      TotalNrOfParcels : DInt;   // Total number of parcels
   END_STRUCT;

END_TYPE

TYPE "UDT_RATCommand"
VERSION : 0.1
   STRUCT
      ManualMode : Bool;   // Manual mode command from HMI
      ManualUp : Bool;   // Command to move section up
      ManualDown : Bool;   // Command to move section down
      ManualStartStop : Bool;   // Run conveyor in manual mode
      ManualFullSpeed : Bool;   // Full speed conveyor in manual mode
      ManualJog : Bool;   // Command to jog conveyor in slow speed from HMI
      Reverse : Bool;   // Command to run conveyor in reverse direction from HMI
      ManualSpeed : Int := 50;   // Manual mode speed as percentage of nominal speed [0-100%]
   END_STRUCT;

END_TYPE

TYPE "UDT_ValveStatus"
TITLE = UDT_ConveyorStatus
VERSION : 0.1
//User-defined structure of FB_Conveyor function block status.
   STRUCT
      Status { ExternalWritable := 'False'} : Int;   // Status number
      Specific { ExternalWritable := 'False'} : Struct
         Opening { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Valve is opening
         Opened { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Valve in Open position
         Closing { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Valve is closing
         Closed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Valve in Closed position
         FailToOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Fail to open / extend
         FailToClose { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Fail to close / retract
         AirPressureLost { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // No air pressure
         ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Configuration is not set correctly
      END_STRUCT;
   END_STRUCT;

END_TYPE

DATA_BLOCK "DB_ProfinetDiagnostic"
TITLE = DB_ProfinetDiagnostic
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
NON_RETAIN
//Data block to store profinet network diagnostic data.
   VAR 
      ProfinetNetworks { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Array[1..10] of "UDT_ProfinetNetwork";
   END_VAR


BEGIN

END_DATA_BLOCK

DATA_BLOCK "DB_GIN"
TITLE = DB_GIN
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
NON_RETAIN
//Data block to store parcels informations.
   VAR 
      GIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Array[1..1] of "UDT_GIN";   // GIN informations - for project remove unneeded customers and extend array bound range to 9999
   END_VAR


BEGIN

END_DATA_BLOCK

TYPE "UDT_ValveCommand"
TITLE = UDT_ConveyorCommand
VERSION : 0.1
//User-defined structure of conveyor commands.
   STRUCT
      ManualMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual mode command from HMI
      AutoMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Automatic mode command from HMI
      ManualOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual command valve Open / Extend
      ManualClose { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual command valve Close / Retract
   END_STRUCT;

END_TYPE

TYPE "UDT_RATStatus"
VERSION : 0.1
   STRUCT
      Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Common divert status
      Specific { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Up { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Divert is in Upper position
         Down { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Divert is in lower position
         Reverse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor is running in reverse direction
         ErrAirpressureNotOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Airpressure is not signalling
         ErrRuntime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Divert took too long to move up or down
         ErrOverrun { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parcel is in guard PEC, it moved too far and cant be devided
         WarnAirPressure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Warning Airpressure is too low
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_AixControllerStatus"
VERSION : 0.1
   STRUCT
      MotorStatus { ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixMotorStatus";
      SpeedFeedbackError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE if  right motor deviates from set speed
      InternalWarning { ExternalWritable := 'False'} : Bool := FALSE;   // An internal warning is active
      InternalError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // An internal error is active
      CommunicationErrorVFD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Communication with VFD timed out
      PNSlaveNotOnline { ExternalWritable := 'False'} : Bool := FALSE;   // Profinet slave is not on line
      PNSlaveError { ExternalWritable := 'False'} : Bool := FALSE;   // Profinet slave has an error
      PNSlaveWarning { ExternalWritable := 'False'} : Bool := FALSE;   // Profinet slave has a warning
      ControllerStatus : DWord;
   END_STRUCT;

END_TYPE

TYPE "UDT_FifoHeader"
TITLE = UDT_FifoHeader
VERSION : 0.1
//User-defined structure of FIFO register header information.
   STRUCT
      Status : Struct   // Status bits
         Empty { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO Empty
         Prefull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO Prefull
         Full { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO Full
      END_STRUCT;
      NextEntryToRead : Int;   // Next FIFO entry to read
      NextEntryToWrite : Int;   // Next FIFO entry to write
      MaxNrOfEntries : Int;   // Maximum number of FIFO entries
      TotalEntriesStored : Int;   // Total number of FIFO entries
   END_STRUCT;

END_TYPE

FUNCTION "FC_Statistics" : Void
TITLE = FC_Statistics
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 26
// END_ATTRIBUTES
//Function to calculate statistics.
   VAR_INPUT 
      ix_Reset : Bool;   // Reset statistics data
      ix_Activate : Bool;   // Activete statistics counters
      ix_RTrigActivate : Bool;   // Activation rise trigger
   END_VAR

   VAR_IN_OUT 
      iqUDT_Statistics : "UDT_EventStatistic";   // Statistic structure
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | C. Leite      | first release MHS TIA 15.1
	17/07/2019  | 0.2       | A.Nowak       | Add comments
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	27/08/2019  | 2.1       | M.Kurpiers    | Comments adjusted
	04/11/2019  | 2.2       | L.Klar        | 1 second pulse changed from memory bit to DB variable
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Number of events
	    
	    IF (#ix_RTrigActivate)      // Event occured                                
	    THEN
	        
	        // Increment the number of times the event occurred and clear the time of the current or last event
	        #iqUDT_Statistics.NumberOfTimes += 1;
	        #iqUDT_Statistics.LastEventSeconds := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Event time
	    
	    // 1 shot every 1 sec and activate statistic counter 
	    IF ("DB_Memory".OS_1sec AND #ix_Activate)
	    THEN
	        
	        // Increment the time of the current or last event and the time of all events that occured
	        #iqUDT_Statistics.LastEventSeconds += 1;
	        #iqUDT_Statistics.TotalEventSeconds += 1;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Data reset
	    
	    
	    IF (#ix_Reset)                                            // Reset statistics data                                          
	    THEN
	        
	        IF (NOT #ix_Activate)                                 // Statistic counter isn't activate                                
	        THEN
	            
	            // Clear statistics data
	            #iqUDT_Statistics.NumberOfTimes := 0;
	            #iqUDT_Statistics.LastEventSeconds := 0;
	            #iqUDT_Statistics.TotalEventSeconds := 0;
	            
	        ELSE
	            
	            // Write 1 to the number of times the event occurred and clear times  
	            #iqUDT_Statistics.NumberOfTimes := 1;
	            #iqUDT_Statistics.LastEventSeconds := 0;
	            #iqUDT_Statistics.TotalEventSeconds := 0;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
END_FUNCTION

TYPE "UDT_ConveyorInterface"
TITLE = UDT_ConveyorInterface
VERSION : 0.1
//User-defined structure of conveyor interface variables.
   STRUCT
      Displacement : Int;   // Displacement per PLC scan [cm] either from position (if available) or speed and time
      SpeedSetpoint : Int;   // Conveyor speed setpoint [mm/s]
      ActualSpeed : Int;   // Conveyors actual speed [mm/s]
      DeltaPosition : Int;   // Read from Conveyor Servo Position [mm] after 1 PLC cycle
      RunFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Run forward request
      RunRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Run reverse request
      InternalErrorEncoder { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Encoder has an error
      InternalErrorVFD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // VFD has an error
      InternalErrorTracking { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Tracking has an error
      InternalErrorPEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PEC has an error
      InternalWarningVFD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // VFD has a warning
      InternalWarningTracking { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Tracking has a warning
      InternalErrorReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset internal errors
      ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Configuration error is active
      VFDRunning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor is running
      VFDatSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor at speed setpoint
      Disconnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // VFD disconnected
      ManualModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Covneyor is in manual mode
      ResetStatistics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset statistics
      HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Hardware for the Equipment is available and healthy
   END_STRUCT;

END_TYPE

TYPE "UDT_ConveyorConfiguration"
TITLE = UDT_ConveyorConfiguration
VERSION : 0.1
//User-defined structure of conveyor parameters.
   STRUCT
      Common : "UDT_ConveyorCommonConfiguration";   // Common configuration
      Forward_Direction : Struct   // Forward Direction configuration
         EnergySaveLenght : DInt;   // Distance conveyor travelled before energy save activate [cm]
         GapHeadToHead : DInt;   // Gapping head to head value [cm]
         GapTailToHead : DInt;   // Gapping tail to head value [cm]
         GapCorrection : DInt;   // Gap offset to cover VFD's ramps [cm]
         PEC_EoSDistanceOffset : DInt;   // Distance offset between photo eye and the end of conveyor [mm]
         Mode : Int;   // Automatic operation; 1- Slave; 2- Queue;
         FirstConveyorToStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // First conveyor to start cascade mode forward direction
      END_STRUCT;
      Reverse_Direction : Struct   // Reverse Direction configuration
         EnergySaveLenght : DInt;   // Distance conveyor travelled before energy save activate [cm]
         GapHeadToHead : DInt;   // Gapping head to head value [cm]
         GapTailToHead : DInt;   // Gapping tail to head value [cm]
         GapCorrection : DInt;   // Gap offset to cover VFD's ramps [cm]
         PEC_BoSDistanceOffset : DInt;   // Distance offset between photo eye and the end of conveyor [mm]
         Mode : Int;   // Automatic operation; 1- Slave; 2- Queue;
         FirstConveyorToStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // First conveyor to start cascade mode reverse direction
      END_STRUCT;
      CascadeTimeOnDelay : UDInt;   // Cascade time on delay [ms]
      ExtraGapRecovery : DInt;   // Extra gap to recovery die back [cm]
      SpeedSetpointLow : Int;   // Low speed setpoint [mm/s]
      SpeedSetpointNominal : Int;   // Nominal speed setpoint [mm/s]
      Energy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Energy save mode enable
      Bi_Directional_Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The conveyor can run in both directions
   END_STRUCT;

END_TYPE

TYPE "UDT_PECConfiguration"
VERSION : 0.1
   STRUCT
      Distance : DInt;   // Distance between photo eye and the end of conveyor [mm]
      JamDisplacementLimit : Int;   // Limit displacement with PEC blocked o detect jam [cm]
      TimeOnDelay : UDInt;   // Photo eye time on delay [ms]
      TimeOffDelay : UDInt;   // Photo eye time off delay [ms]
      ResetWithPECBlocked { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // When 'True' Allow reset system after jam with PEC blocked
   END_STRUCT;

END_TYPE

FUNCTION "SICK_SetValue" : Void
TITLE = Set value
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : SICKAG
FAMILY : Ident
VERSION : 1.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 45
// END_ATTRIBUTES
//This function is needs to set a value to a SICK CoLa command.
   VAR_INPUT 
      bAddBlank : Bool;   // Add blank after value
      nValue : DWord;   // Value that should be written
   END_VAR

   VAR_OUTPUT 
      arrData : Array[0..499] of Byte;   // Destination telegram
      nErrorCode : Word;   // Error code
   END_VAR

   VAR_IN_OUT 
      iPosition : UInt;   // Position offset of the value before and after (starting from 0)
   END_VAR

   VAR_TEMP 
      iValueLength : USInt;   // Byte length of the value that shuld be written
      nReturnValue : Word;   // Return value of the convert function
      sValue : String[8];   // Converted value
      nTempValue : DWord;   // Temporarily variable
      iTemp : UInt;   // Temporarily variable
   END_VAR


BEGIN
	(*===========================================================================================
	Name:   SICK_SetValue
	Author: SICK AG
	=============================================================================================
	Description: 
	This function is for internal use only.
	The function converts a hexadecimal value into a hexadecimal string and add it 
	automatically to the command array.     
	
	=============================================================================================
	Error codes:
	16#0000 = No error
	16#0001 = Invalid position index   
	16#8xxx = Conversion error (HTA-Function) see help system for more information
	                    
	=============================================================================================
	Version history:
	Date       | Version | created under               | Author  | Remark
	---------------------------------------------------------------------------------------------
	30/01/2014 | V1.0    | TIA Portal V12 SP1 Update 2 | SICK AG | Initial version
	22/04/2014 | V1.1    | TIA Portal V12 SP1 Update 4 | SICK AG | Avoid warnings that occur with 
	                                                               TIA V13
	============================================================================================*)
	
	(*===================================== INITIALISATION =====================================*)
	#iValueLength := 0;
	#nErrorCode := 16#0000;
	
	(*======================================= WRITE VALUE ======================================*)
	(*Check current position of the value*)
	IF #iPosition > 499 THEN
	    #nErrorCode := 16#0001; (*Error: Invalid position index*)
	    RETURN;
	END_IF;
	
	
	
	(*Get byte length of the value that should be written*)
	IF #nValue <= 16#FF THEN
	    #nTempValue := SHL(IN := #nValue, N := 24);
	    #iValueLength := 1;
	ELSIF #nValue <= 16#FFFF THEN
	    #nTempValue := SHL(IN := #nValue, N := 16);
	    #iValueLength := 2;
	ELSIF #nValue <= 16#00FF_FFFF THEN
	    #nTempValue := SHL(IN := #nValue, N := 8);
	    #iValueLength := 3;
	ELSIF #nValue <= 16#FFFF_FFFF THEN
	    #nTempValue := #nValue;
	    #iValueLength := 4;
	END_IF;
	
	(*Convert hexadecimal number into a ASCII string*)
	#nReturnValue := HTA(IN := #nTempValue, N := #iValueLength, OUT => #sValue);
	IF #nReturnValue <> 16#0000 THEN
	    #nErrorCode := #nReturnValue; (*Error: Conversion error (HTA-Function)*)
	    RETURN;
	END_IF;
	
	(*Add the string value to the destination telegram*)
	#arrData[#iPosition] := 0; // Avoid warnings under TIA V13
	Strg_TO_Chars(Strg := #sValue,
	              pChars := #iPosition,
	              Cnt => #iTemp,
	              Chars := #arrData);
	
	(*Add blank to the destination telegram and calculate the position of the next element*)
	IF #bAddBlank THEN
	    #arrData[#iPosition + #iTemp] := ' ';
	    #iPosition := #iPosition + #iTemp + 1;
	    
	(*Calculate the position of the next element*)
	ELSE
	    #iPosition := #iPosition + #iTemp;
	END_IF;
END_FUNCTION

FUNCTION "SICK_GetValue" : Void
TITLE = Get value
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : SICKAG
FAMILY : Ident
VERSION : 1.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 44
// END_ATTRIBUTES
//This function is needs to get a value out of a SICK CoLa command.
   VAR_INPUT 
      iTelegramLength : UInt;   // Length of the source telegram
      iValueLength : USInt;   // ASCII length of the value [1..8] = Fix length | [0]= Variable
      arrData : Array[0..499] of Byte;   // Data record (contains the whole CoLa telegram)
   END_VAR

   VAR_OUTPUT 
      nValue : DWord;   // Read value
      nErrorCode : Word;   // Error code
   END_VAR

   VAR_IN_OUT 
      iPosition : UInt;   // Position offset of the value before and after (starting from 0)
   END_VAR

   VAR_TEMP 
      iLoop : Int;   // Temporarily variable
      iSegmentLength : UInt;   // Length of the segement
      nTemp : DWord;   // Temporarily variable
   END_VAR


BEGIN
	(*===========================================================================================
	Name:   SICK_GetValue
	Author: SICK AG
	=============================================================================================
	Description: 
	This function is for internal use only. The function gets the selected Hex-value string out 
	of the CoLa-Telegram and convert it into a hexadecimal number. 
	
	=============================================================================================
	Error codes:
	16#0000 = No error
	16#0001 = Invaild telegram length   
	16#0002 = Invalid position index 
	16#0003 = Invalid value length
	16#0004 = Invalid segment length 
	16#0005 = ASCII character is not in a hexadecimal format             
	                                                                      
	=============================================================================================
	Version history:
	Date       | Version | created under               | Author  | Remark
	---------------------------------------------------------------------------------------------
	30/01/2014 | V1.0    | TIA Portal V12 SP1 Update 2 | SICK AG | Initial version
	============================================================================================*)
	
	(*===================================== INITIALISATION =====================================*)
	#iSegmentLength := 0;
	#nValue := 16#0000_0000;
	#nErrorCode := 16#0000;
	
	(*======================================= READ VALUE =======================================*)
	(*Check telegram length*)
	IF #iTelegramLength <= 0 OR #iTelegramLength > 500 THEN
	    #nErrorCode := 16#0001; (*Error: Invaild telegram length*)
	    RETURN;
	END_IF;
	
	(*Check current position of the value*)
	IF #iPosition > (#iTelegramLength - 1) THEN
	    #nErrorCode := 16#0002; (*Error: Invalid position index*)
	    RETURN;
	END_IF;
	
	(*Check value length*)
	IF #iValueLength > 8 THEN
	    #nErrorCode := 16#0003; (*Error: Invalid value length*)
	    RETURN;
	END_IF;
	
	(*Get a value with a variable length (ends with a ' ' or [ETX]*)
	IF #iValueLength = 0 THEN
	    FOR #iLoop := UINT_TO_INT(#iPosition) TO UINT_TO_INT(#iTelegramLength - 1) DO
	        (*Check if a blank or a [ETX] is detected*)
	        IF (#arrData[#iLoop] = ' ') OR (#arrData[#iLoop] = '$03') THEN
	            EXIT;
	        END_IF;
	        
	        (*Length of the current value segement*)
	        #iSegmentLength := #iSegmentLength + 1;
	    END_FOR;
	    
	(*Get a value with a fixed character length [1..8]*)
	ELSE
	    #iSegmentLength := #iValueLength;
	END_IF;
	
	(*Check if the segment length is valid*)
	IF (#iSegmentLength > 8) OR (#iSegmentLength = 0) THEN
	    #nErrorCode := 16#0004; (*Error: Invalid segment length*)
	    RETURN;
	END_IF;
	
	(*Convert ASCII string into a hexadecimal number*)
	FOR #iLoop := UINT_TO_INT(#iPosition) TO UINT_TO_INT(#iPosition + #iSegmentLength - 1) DO
	    (*ACSII value = [0..9]*)
	    IF #arrData[#iLoop] >= '0' AND #arrData[#iLoop] <= '9' THEN
	        #nTemp := #arrData[#iLoop] - 48;
	        (*ASCII value = [A..F]*)
	    ELSIF #arrData[#iLoop] >= 'A' AND #arrData[#iLoop] <= 'F' THEN
	        #nTemp := #arrData[#iLoop] - 55;
	        (*ASCII value = [a..f]*)
	    ELSIF #arrData[#iLoop] >= 'a' AND #arrData[#iLoop] <= 'f' THEN
	        #nTemp := #arrData[#iLoop] - 87;
	    ELSE
	        #nErrorCode := 16#0005; (*Error: ASCII character is not in a hexadecimal format *)
	        RETURN;
	    END_IF;
	    
	    (*Create hexadecimal number*)
	    #nValue := SHL(IN := #nValue, N := 4);
	    #nValue := #nValue + #nTemp;
	END_FOR;
	
	(*Set the position of the next element in the telegram*)
	IF #iValueLength = 0 THEN
	    #iPosition := #iPosition + #iSegmentLength + 1; (*With blank character*)
	ELSE
	    #iPosition := #iPosition + #iSegmentLength; (*Without blank character*)
	END_IF;
	
END_FUNCTION

FUNCTION_BLOCK "SICK_CCOMM_PNDP"
TITLE = SICK_CCOM_PNDP
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : SICKAG
FAMILY : Ident
VERSION : 1.2
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 266
// END_ATTRIBUTES
//The function block use a Profinet/Probibus connection to communicate with a SICK AutoIdent
//device. The FB makes it possible to send and receive sensor data. The Confirmed Messaging 
//protocol (CM-Protocol) is used to receive even long fragmented read results.
   VAR_INPUT 
      HWInputIdent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_IO;   // Hardware identification number of the input module
      HWInputLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;   // Size of the input module
      HWOutputIdent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_IO;   // Hardware identification number of the output module
      HWOutputLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;   // Size of the output module
      TOut { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time := T#5S;   // Time out
      Req { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // A positive edge starts the request
      CommandLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Byte length of the command
   END_VAR

   VAR_OUTPUT 
      RdDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reading result arrived
      RdLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Byte length of the reading result
      ReqDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Requested data available
      ReqBusy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request busy
      ReqLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Byte length of the requested data
      Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Error
      Errorcode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DWord;   // Error code
   END_VAR

   VAR_IN_OUT 
      arrCommand : Array[0..499] of Byte;
      arrRecord : Array[0..499] of Byte;
   END_VAR

   VAR 
      bTriggerReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;   // Rising edge detection
      bTriggerReqMem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;   // Rising edge detection
      bReadFrag { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      bWriteFrag { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      bReqBusyMem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      iReadStep { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;
      iWriteStep { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;
      iReadIndex { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;
      iWriteIndex { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;
      iReadHeaderLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;
      iWriteHeaderLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;
      iReadFragmentLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;
      iWriteFragmentLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;
      iRecordSize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;
      iCommandSize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;
      nTempErrorCode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DWord;
      arrInputImage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..127] of Byte;
      arrOutputImage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..127] of Byte;
      fbTimeout {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
   END_VAR

   VAR_TEMP 
      iTemp1 : Int;
      iTemp2 : UDInt;
      iTemp3 : UDInt;
   END_VAR


BEGIN
	(*===========================================================================================
	Name:   SICK_CCOMM_PNDP
	Author: SICK AG
	=============================================================================================
	Description: 
	The function block use a Profinet/Probibus connection to communicate with a SICK AutoIdent
	device. The FB makes it possible to send and receive sensor data. The Confirmed Messaging 
	protocol (CM-Protocol) is used to receive even long fragmented read results.
	
	Send a command:
	The "Req" parameter must be triggered with a rising edge (signal change FALSE to TRUE) in 
	order to carry out the function. For the time during which a valid response has yet to be 
	received from the device, the "ReqBusy" parameter is used to signal  that a response is still 
	pending. The module signals the "ReqDone" = TRUE output parameter when the function has been 
	successfully completed. If data was requested by the device, this data is copied into the 
	Record (arrRecord). The "ReqDone" indicates that new data has been received  for a PLC cycle.
	Only one CoLa-A command request can be send to the same device at one time. 
	
	Receive a reading result:
	Data sent via trigger command or directly by the device (e.g., direct trigger via a light 
	barrier) is stored in the Record (arrRecord). The "RdDone" output indicates that new data 
	has been received for a PLC cycle. The data sent by the device can be changed or adapted in 
	output format of SOPAS-ET. 
	
	This AOI supports the folowing SICK devices:
	- Lector6xx
	- RFU6xx
	- CLV6xx 
	- RFH6xx
	=============================================================================================
	Confirmed Messaging Protocol definitions:
	arrInputImage[0]        = Status byte 
	arrInputImage[1]        = Receive counter
	arrInputImage[2]        = Transmit counter back
	arrInputImage[3]        = Command length LSB
	arrInputImage[4]        = Command length MSB
	arrInputImage[5..127]   = Device response (CoLa-A)
	
	arrOutputImage[0]       = Status byte 
	arrOutputImage[1]       = Receive counter back
	arrOutputImage[2]       = Transmit counter
	arrOutputImage[3]       = Command length LSB
	arrOutputImage[4]       = Command length MSB
	arrOutputImage[5..127]  = Device request (CoLa-A)
	=============================================================================================
	Version history:
	Date       | Version | Created under               | Author  | Remark
	---------------------------------------------------------------------------------------------
	16/01/2014 | V1.0    | TIA Portal V12 SP1 Update 2 | SICK AG | Initial version
	07/08/2014 | V1.1    | TIA Portal V12 SP1 Update 4 | SICK AG | Replace R_TRIG function 
	22/04/2015 | V1.2    | TIA Portal V12 SP1 Update 4 | SICK AG | Avoid warnings that occur with 
	                                                               TIA V13
	============================================================================================*)
	
	(*===================================== INITIALISATION =====================================*)
	#iRecordSize := 500;   (*Length of the arrRecord array*)
	#iCommandSize := 500;  (*Length of the arrCommand array*)
	
	#RdDone := false;
	#iReadStep := 0;
	
	(*Rising edge detection of the request flag*)
	#bTriggerReq := #Req AND NOT #bTriggerReqMem;
	#bTriggerReqMem := #Req;
	
	(*Error detection*)
	IF #nTempErrorCode <> 16#0000_0000 THEN
	    #ReqDone := false;
	    #ReqBusy := false;
	    #bReqBusyMem := false;
	    #Error := true;
	    #Errorcode := #nTempErrorCode;
	    #nTempErrorCode := 16#0000_0000;
	    #ReqLength := 0;
	    #iWriteStep := 0;
	    RETURN;
	END_IF;
	
	(*Time out detection*)
	#fbTimeout(IN := #bReqBusyMem,
	           PT := #TOut);
	IF #fbTimeout.Q THEN
	    #nTempErrorCode := 16#0000_0001; (*Error: Time out*)
	END_IF;
	
	(*Check the hardware ident length of the input module*)
	IF #HWInputLength < 8 OR #HWInputLength > 128 THEN
	    #nTempErrorCode := 16#0000_0002; (*Error: Incorrect module input length*)
	END_IF;
	
	(*Check the hardware ident length of the output module*)
	IF #HWOutputLength < 8 OR #HWOutputLength > 128 THEN
	    #nTempErrorCode := 16#0000_0003; (*Error: Incorrect module output length*)
	END_IF;
	
	(*Error detected*)
	IF #nTempErrorCode <> 16#0000_0000 THEN
	    RETURN;
	END_IF;
	
	
	(*===================================== COMMUNICATION ======================================*)
	(*Set output data*)
	#iTemp1 := DPWR_DAT(LADDR := #HWOutputIdent, RECORD := #arrOutputImage);
	IF #iTemp1 <> 0 THEN
	    #nTempErrorCode.%W1 := #iTemp1;
	    #nTempErrorCode.%W0 := 16#0004; (*Error: Set output data via DPWR_DAT*)
	    RETURN;
	END_IF;
	
	(*Get input data*)
	#iTemp1 := DPRD_DAT(LADDR := #HWInputIdent, RECORD => #arrInputImage);
	IF #iTemp1 <> 0 THEN
	    #nTempErrorCode.%W1 := #iTemp1;
	    #nTempErrorCode.%W0 := 16#0005; (*Error: Get input data via DPRD_DAT*)
	    RETURN;
	END_IF;
	
	(*Receive counter ==0 && Receive counter back <>0*)
	IF #arrInputImage[1] = 0 AND #arrOutputImage[1] <> 0 THEN
	    #arrOutputImage[1] := #arrInputImage[1]; (*Recive counter => Receive counter back*)
	    RETURN;
	END_IF;
	
	(*Transmit counter <> Transmit counter back*)
	IF NOT #bReqBusyMem AND (#arrInputImage[2] <> #arrOutputImage[2]) THEN
	    #arrOutputImage[2] := 0; (*0 => Transmit counter*)
	    RETURN;
	END_IF;
	
	
	(*============================== HANDLING OF THE RECEIVED DATA =============================*)
	(*New telegram available*)
	IF NOT (#arrInputImage[1] = #arrOutputImage[1]) THEN
	    
	    (*Reset error every incoming telegram (Read only mode, e.g. for hand held scanners)*)
	    IF #CommandLength <= 0 THEN
	        #Error := false;
	        #Errorcode := 16#0000_0000;
	    END_IF;
	    
	    (*Confirm the receive counter*)
	    #arrOutputImage[1] := #arrInputImage[1];
	    
	    (*Get telegram length from the received header*)
	    #iReadHeaderLength.%B0 := #arrInputImage[3];
	    #iReadHeaderLength.%B1 := #arrInputImage[4];
	    
	    (*Check if fragmentation is not active at the moment*)
	    IF NOT #bReadFrag THEN
	        #iReadIndex := 0;
	        
	        (*Check if fragmentation is needed*)
	        IF (#HWInputLength - 5) < #iReadHeaderLength THEN
	            #bReadFrag := true;
	        END_IF;
	    END_IF;
	    
	    (*Fragmentation is needed*)
	    IF #bReadFrag THEN
	        IF (#HWInputLength - 5) < #iReadHeaderLength THEN
	            #iReadFragmentLength := #HWInputLength - 5;
	        ELSE
	            #iReadFragmentLength := #iReadHeaderLength;
	        END_IF;
	        
	        (*No fragmentation needed*)
	    ELSE
	        #iReadFragmentLength := #iReadHeaderLength;
	    END_IF;
	    
	    (*Copy input data into the output record*)
	    IF (#iReadIndex + #iReadFragmentLength) <= #iRecordSize THEN
	        MOVE_BLK(IN := #arrInputImage[5],
	                 COUNT := #iReadFragmentLength,
	                 OUT => #arrRecord[#iReadIndex]);
	    END_IF;
	    
	    (*Check if all data has been received*)
	    IF (#HWInputLength - 5) < #iReadHeaderLength THEN
	        #iReadIndex := #iReadIndex + #iReadFragmentLength;
	        
	        (*All data has been received*)
	    ELSE
	        #bReadFrag := false;
	        #iReadStep := 1;
	    END_IF;
	    
	    (*Incoming data filter*)
	    (* - Check if the receiving telegram os a CoLa answer on a requested 
	         comand or a reading result.
	       
	        sRA  sWA  sMA  sAN  sAI  sEA  sPX  s{   sSI  sSN  sFA
	    sRN  X                                       X    X    X
	    sRI  X                                       X    X    X
	    sWN       X                                  X    X    X
	    sWI       X                                  X    X    X
	    sMN            X    X                        X    X    X
	    sMI            X         X                   X    X    X
	    sEN                           X              X    X    X
	    sEI                           X              X    X    X
	    sPE                                X         X    X    X
	    s{                                      X    X    X    X
	    *)
	    IF #iReadStep = 1 THEN
	        (*Filter is only active, while requested data expected*)
	        IF #bReqBusyMem THEN
	            IF #CommandLength > 3 THEN
	                (*Get the prefix from the requested command (e.g. 'sRN '*)
	                #iTemp2.%B3 := #arrCommand[0];
	                #iTemp2.%B2 := #arrCommand[1];
	                #iTemp2.%B1 := #arrCommand[2];
	                #iTemp2.%B0 := 16#20;
	                
	                (*Get the prefix from the command response (e.g. 'sRA ')*)
	                #iTemp3.%B3 := #arrRecord[0];
	                #iTemp3.%B2 := #arrRecord[1];
	                #iTemp3.%B1 := #arrRecord[2];
	                #iTemp3.%B0 := 16#20;
	            ELSE
	                #iTemp2 := 16#0000_0000;
	                #iTemp3 := 16#0000_0000;
	            END_IF;
	            
	            CASE #iTemp3 OF
	                    (*'s{  '*)
	                16#737B2020:
	                    IF #iTemp2 = 16#737B2020 THEN
	                        #iReadStep := 2; (*Command response*)
	                    ELSE
	                        #iReadStep := 3; (*Reading result*)
	                    END_IF;
	                    
	                    (*'sRA '*)
	                16#73524120:
	                    IF (#iTemp2 = 16#73524E20) OR (#iTemp2 = 16#73524920) THEN
	                        #iReadStep := 2; (*Command response*)
	                    ELSE
	                        #iReadStep := 3; (*Reading result*)
	                    END_IF;
	                    
	                    (*'sWA '*)
	                16#73574120:
	                    IF (#iTemp2 = 16#73574E20) OR (#iTemp2 = 16#73574920) THEN
	                        #iReadStep := 2; (*Command response*)
	                    ELSE
	                        #iReadStep := 3; (*Reading result*)
	                    END_IF;
	                    
	                    (*'sMA '*)
	                16#734D4120:
	                    IF (#iTemp2 = 16#734D4E20) OR (#iTemp2 = 16#734D4920) THEN
	                        #iReadStep := 2; (*Command response*)
	                    ELSE
	                        #iReadStep := 3; (*Reading result*)
	                    END_IF;
	                    
	                    (*'sAN '*)
	                16#73414E20:
	                    IF #iTemp2 = 16#734D4E20 THEN
	                        #iReadStep := 2; (*Command response*)
	                    ELSE
	                        #iReadStep := 3; (*Reading result*)
	                    END_IF;
	                    
	                    (*'sAI '*)
	                16#73414920:
	                    IF #iTemp2 = 16#734D4920 THEN
	                        #iReadStep := 2; (*Command response*)
	                    ELSE
	                        #iReadStep := 3; (*Reading result*)
	                    END_IF;
	                    
	                    (*'sEA '*)
	                16#73454120:
	                    IF (#iTemp2 = 16#73454E20) OR (#iTemp2 = 16#73454920) THEN
	                        #iReadStep := 2; (*Command response*)
	                    ELSE
	                        #iReadStep := 3; (*Reading result*)
	                    END_IF;
	                    
	                    (*'sPX '*)
	                16#73505820:
	                    IF #iTemp2 = 16#73504520 THEN
	                        #iReadStep := 2; (*Command response*)
	                    ELSE
	                        #iReadStep := 3; (*Reading result*)
	                    END_IF;
	                    
	                    (*'sSI '*)
	                16#73534920:
	                    #iReadStep := 3; (*Reading result*)
	                    
	                    (*'sSN '*)
	                16#73534E20:
	                    #iReadStep := 3; (*Reading result*)
	                    
	                    (*'sFA '*)
	                16#73464120:
	                    #iReadStep := 2; (*Command response*)
	                    
	                    (*Invalid CoLa-A answer*)
	                ELSE
	                    (*Check if a user defined command is used (Request == Response)*)
	                    FOR #iTemp1 := 0 TO UINT_TO_INT(#CommandLength - 1) DO
	                        IF #arrCommand[#iTemp1] = #arrRecord[#iTemp1] THEN
	                            #iReadStep := 2; (*Command response*)
	                        ELSE
	                            #iReadStep := 3; (*Reading result*)
	                            EXIT;
	                        END_IF;
	                    END_FOR;
	            END_CASE;
	            
	            (*Reading result*)
	        ELSE
	            #iReadStep := 3;  (*Reading result*)
	        END_IF;
	    END_IF;
	    
	    (*Incoming telegram is a command response*)
	    IF #iReadStep = 2 THEN
	        IF (#iReadIndex + #iReadFragmentLength) <= #iRecordSize THEN
	            #ReqLength := UDINT_TO_INT(#iReadIndex + #iReadFragmentLength);
	            #ReqDone := true;
	            #ReqBusy := false;
	            #bReqBusyMem := false;
	        ELSE
	            #nTempErrorCode := 16#0000_0006; (*Error: Incoming command response > Record size*)
	        END_IF;
	    END_IF;
	    
	    (*Incoming telegram is a reading result*)
	    IF #iReadStep = 3 THEN
	        IF (#iReadIndex + #iReadFragmentLength) <= #iRecordSize THEN
	            #RdLength := UDINT_TO_INT(#iReadIndex + #iReadFragmentLength);
	            #RdDone := true;
	        ELSE
	            #RdLength := -1;
	            #RdDone := false;
	        END_IF;
	    END_IF;
	END_IF;
	
	
	(*=========================== HANDLING OF THE DATA TO BE WRITTEN ===========================*)
	IF #bTriggerReq AND NOT #bReqBusyMem THEN
	    #ReqDone := false;
	    #ReqBusy := true;
	    #bReqBusyMem := true;
	    #Error := false;
	    #Errorcode := 16#0000_0000;
	    #iWriteIndex := 0;
	    
	    (*Check command length*)
	    IF #CommandLength <= 0 THEN
	        #nTempErrorCode := 16#0000_0007; (*Error: Command length <= 0*)
	        RETURN;
	    ELSIF #CommandLength > #iCommandSize THEN
	        #nTempErrorCode := 16#0000_0008; (*Error: Command length > command array*)
	        RETURN;
	    END_IF;
	    
	    (*Check if the the command telegram must be fragmented*)
	    IF (#HWOutputLength - 5) < #CommandLength THEN
	        #iWriteFragmentLength := #HWOutputLength - 5;
	    ELSE
	        #iWriteFragmentLength := #CommandLength;
	    END_IF;
	    
	    #iWriteHeaderLength := #CommandLength;
	    #iWriteStep := 1;
	END_IF;
	
	(*Write step 1: Command transfer*)
	IF (#iWriteStep = 1) AND (#arrInputImage[2] = #arrOutputImage[2]) THEN
	    
	    (*Copy command data into the output record*)
	    IF ((#iWriteIndex + #iWriteFragmentLength) <= #iCommandSize) AND (#iWriteFragmentLength <= (#HWOutputLength - 5)) THEN
	        MOVE_BLK(IN := #arrCommand[#iWriteIndex],
	                 COUNT := #iWriteFragmentLength,
	                 OUT => #arrOutputImage[5]);
	        (*Increment transmit counter*)
	        IF #arrOutputImage[2] = 16#FF THEN
	            #arrOutputImage[2] := 16#01; (*Counter overflow, zero is skipped*)
	        ELSE
	            #arrOutputImage[2] := #arrOutputImage[2] + 1;
	        END_IF;
	        
	        (*Set command/fragment length*)
	        #arrOutputImage[3] := #iWriteHeaderLength.%B0;
	        #arrOutputImage[4] := #iWriteHeaderLength.%B1;
	        
	        (*Next step*)
	        #iWriteStep := 2;
	    ELSE
	        #nTempErrorCode := 16#0000_0009; (*Error: Fragmentation error*)
	    END_IF;
	    RETURN;
	END_IF;
	
	(*Write step 2: Fragmentation handling*)
	IF #iWriteStep = 2 THEN
	    
	    (*Fragmentation is needed*)
	    IF (#HWOutputLength - 5) < #iWriteHeaderLength THEN
	        #bWriteFrag := true;
	        
	        (*Next index*)
	        #iWriteIndex := #iWriteIndex + #iWriteFragmentLength;
	        
	        (*Set next header length*)
	        #iWriteHeaderLength := #iWriteHeaderLength - #iWriteFragmentLength;
	        
	        (*Set next fragment length*)
	        IF (#HWOutputLength - 5) < #iWriteHeaderLength THEN
	            #iWriteFragmentLength := #HWOutputLength - 5;
	        ELSE
	            #iWriteFragmentLength := #iWriteHeaderLength;
	        END_IF;
	        
	        (*Fragmentation is not needed*)
	    ELSE
	        #bWriteFrag := false;
	    END_IF;
	    
	    (*Next step*)
	    #iWriteStep := 3;
	END_IF;
	
	(*Write step 3: Check if the transmission of the command/fragment is done*)
	IF #iWriteStep = 3 THEN
	    
	    (*Transmit counter back == Transmit counter*)
	    IF #arrInputImage[2] = #arrOutputImage[2] THEN
	        IF #bWriteFrag THEN
	            #iWriteStep := 1;
	        ELSE
	            #iWriteStep := 0;
	        END_IF;
	    END_IF;
	END_IF;
END_FUNCTION_BLOCK

TYPE "ST_SICK_Lector_CLV6xx"
TITLE = SICK Lector/CLV6xx data type
VERSION : 0.1
//This data type includes arguments and results using by the SICK_Lector_CLV6xx_PNDP function block.
   STRUCT
      Matchcode : Struct   // ==Matchcode==
         sName : String[10];   // Matchcode number (Match[1..9]) (Input)
         nCodeType : Char;   // Code type see device documentation. (Example: 'd'= EAN-Code; 's'=QR-Code; '*'= Don't care) (Input)
         iMinMaxLength : USInt;   // Sets the min and may length. 0= Don't care (Input)
         sContent : String[75];   // Matchcode content
      END_STRUCT;
      FreeCommand : Struct   // ==Free Command==
         sCommand : String[100];   // Command (SICK CoLa-A protocol without [STX]/[ETX] framing) (In)
         sResult : String[100];   // Result (SICK CoLa-A protocol) (Out)
      END_STRUCT;
      ReadingResult : Struct   // ==Reading Result==
         iCounter : USInt;   // This counter is incremented if a new reading result has arrived (In)
         iLength : Int;   // Byte length of the reading result (Out)
         arrResult : Array[1..200] of Byte;   // Reading result data defined in the SOPAS output format (Out)
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_VfdNordParameter"
TITLE = UDT_VfdNordParameter
VERSION : 0.1
//Parameter structure to read and write
   STRUCT
      WriteValue : DInt;   // Parameter value to write
      ActualValue : DInt;   // Actual value read from VFD
      ParaNumber : Int;   // Parameter number to access
      Index : Int;   // Parameter index number to access
      ParaSet : Int;   // Parameter set to acces
      Format32 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Write the parameter in DWord format. 0 = Write the parameter in Word format
      WriteAccess { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Write the parameter. 0 = Read the parameter
      InUse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Parameter is to be processed
      RamOnly { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Save parameter in RAM, 0 = Save parameter in RAM and EEPROM
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_VfdNORDParaAcycWrite"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 35
// END_ATTRIBUTES
   VAR_INPUT 
      HW_Identifier { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_IO;
      idi_Value { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      ii_FISystembus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 1;
      ii_ParameterNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ii_ParameterIndex { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ii_ParameterSet { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ix_Execute { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ix_Parameter32Bit { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ix_RAM_Only { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_OUTPUT 
      qx_Done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      qx_Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      qdi_ValueRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      qw_ErrorID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
   END_VAR

   VAR 
      sa_WriteVal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..3] of Word;
      sa_RecWrite { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} AT sa_WriteVal : Struct
         PKE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
         Index { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
         Para_Val { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      END_STRUCT;
      sa_ReadVal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..3] of Word;
      sa_RecRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} AT sa_ReadVal : Struct
         PKE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
         Index { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
         Para_Val { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      END_STRUCT;
      sv_WRRECInstance {InstructionName := 'WRREC'; LibVersion := '1.1'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : WRREC;
      sv_RDRECInstance {InstructionName := 'RDREC'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : RDREC;
      sw_Ak { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
      sw_Pnu { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
      sw_ErrorIDStatic { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
      sdi_DataRecord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      si_Receivecounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      sx_FLMExecute { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_REdgeExecute { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_DoneStatic { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_ErrorStatic { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_TEMP 
      tw_ResponseIND : Word;
      tw_ResponseLABEL : Word;
      tw_ResponsePNU : Word;
      tdi_ResponsePWE : DInt;
      tx_WithIndex : Bool;
      tx_WithParameterSet : Bool;
   END_VAR

   VAR CONSTANT 
      cw_ChangeParameterValueWordEEPROM : Word := 2;
      cw_ChangeParameterValueWordRAM : Word := 14;
      cw_ChangeParameterValueDoubleWordEEPROM : Word := 3;
      cw_ChangeParameterValueDoubleWordRAM : Word := 13;
      cw_IncorretSubindex : Word := 3;
      cw_InternalResponseLabelCannotBeDepicted : Word := 202;
      cw_InvalidDataType : Word := 5;
      cw_NoResponse : Word := 0;
      cw_OrderCannotBeExecuted : Word := 7;
      cw_ParameterOffset : Word := 1000;
      cw_PNUMask : Word := 16#07FF;
      ci_ReceivecounterMax : Int := 255;
      ci_Length : UInt := 8;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	25/01/2021  | 0.1       | S.Theocharis  | Copy fron NORD library 
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5           
	*)
	// protects the frequency inverter from too frequent write requests.
	IF #ix_Execute <> #sx_FLMExecute THEN
	    IF #ix_Execute THEN
	        #sx_REdgeExecute := TRUE;
	    ELSE
	        #sx_REdgeExecute := FALSE;
	    END_IF;
	    #sx_FLMExecute := #ix_Execute;
	ELSE
	    #sx_REdgeExecute := FALSE;
	END_IF;
	
	#tx_WithIndex := #ii_ParameterIndex > 0;
	#tx_WithParameterSet := #ii_ParameterSet > 0;
	
	CASE #si_State OF
	        
	    0:
	        IF #sx_REdgeExecute AND
	            NOT ((#ii_ParameterSet < 0) OR (#ii_ParameterIndex < 0) OR (#ii_ParameterSet > 4) OR
	            (#tx_WithParameterSet AND (#ii_ParameterIndex > 64)) OR (NOT #tx_WithParameterSet AND (#ii_ParameterIndex > 256)) OR
	            (NOT #ix_Parameter32Bit AND #idi_Value < -32768) OR (NOT #ix_Parameter32Bit AND #idi_Value > 16#FFFF)) THEN
	            //initialize
	            #sx_DoneStatic := FALSE;
	            #sx_ErrorStatic := FALSE;
	            #sw_ErrorIDStatic := 0;
	            #si_Receivecounter := 0;
	            #qx_Done := FALSE;
	            #qx_Busy := TRUE;
	            
	            // get PROFINET IO data record
	            IF (#ii_ParameterNumber >= 150 AND #ii_ParameterNumber <= 199) OR (#ii_ParameterNumber >= 800 AND #ii_ParameterNumber <= 849) THEN
	                // order to the bus interface
	                #sdi_DataRecord := 100;
	            ELSIF ((#ii_ParameterNumber >= 0 AND #ii_ParameterNumber < 150) OR (#ii_ParameterNumber >= 200 AND #ii_ParameterNumber <= 799) OR
	                (#ii_ParameterNumber >= 850 AND #ii_ParameterNumber <= 999)) AND (#ii_FISystembus > 0) AND (#ii_FISystembus <= 8) THEN
	                // order to frequency inverter 1..8
	                #sdi_DataRecord := #ii_FISystembus + 100;
	            ELSE
	                #sdi_DataRecord := 0;
	            END_IF;
	            
	            // get order label (AK)
	            IF #ix_RAM_Only THEN
	                IF #ix_Parameter32Bit THEN
	                    #sw_Ak := #cw_ChangeParameterValueDoubleWordRAM;
	                ELSE
	                    #sw_Ak := #cw_ChangeParameterValueWordRAM;
	                END_IF;
	            ELSE
	                IF #ix_Parameter32Bit THEN
	                    #sw_Ak := #cw_ChangeParameterValueDoubleWordEEPROM;
	                ELSE
	                    #sw_Ak := #cw_ChangeParameterValueWordEEPROM;
	                END_IF;
	            END_IF;
	            
	            // merge parameter label (PKE)
	            #sw_Pnu := INT_TO_WORD(#ii_ParameterNumber + WORD_TO_INT(#cw_ParameterOffset));
	            #sa_RecWrite.PKE := SHL(IN := #sw_Ak, N := 12) OR #sw_Pnu;
	            
	            // get sub-index (IND)
	            IF #tx_WithIndex AND #tx_WithParameterSet THEN
	                #sa_RecWrite.Index := SHL(IN := SHL(IN := INT_TO_WORD((#ii_ParameterIndex) - 1), N := 2) OR
	                                          INT_TO_WORD((#ii_ParameterSet) - 1), N := 8);
	            ELSIF NOT #tx_WithIndex AND #tx_WithParameterSet THEN
	                #sa_RecWrite.Index := SHL(IN := INT_TO_WORD((#ii_ParameterSet) - 1), N := 8);
	            ELSIF #tx_WithIndex AND NOT #tx_WithParameterSet THEN
	                #sa_RecWrite.Index := SHL(IN := INT_TO_WORD((#ii_ParameterIndex) - 1), N := 8);
	            ELSE
	                #sa_RecWrite.Index := 0;
	            END_IF;
	            
	            // get parameter value (PWE)
	            #sa_RecWrite.Para_Val := #idi_Value;
	            
	            // write data to device
	            #sv_WRRECInstance(REQ := TRUE,
	                              ID := #HW_Identifier,
	                              INDEX := #sdi_DataRecord,
	                              LEN := #ci_Length,
	                              DONE => #sv_WRRECInstance.DONE,
	                              BUSY => #sv_WRRECInstance.BUSY,
	                              ERROR => #sv_WRRECInstance.ERROR,
	                              RECORD := #sa_WriteVal);
	            #si_State := 1;
	        ELSIF #sx_REdgeExecute AND
	            ((#ii_ParameterSet < 0) OR (#ii_ParameterIndex < 0) OR (#ii_ParameterSet > 4) OR
	            (#tx_WithParameterSet AND (#ii_ParameterIndex > 63)) OR (NOT #tx_WithParameterSet AND (#ii_ParameterIndex > 255))) THEN
	            #sx_DoneStatic := FALSE;
	            #sx_ErrorStatic := TRUE;
	            #sw_ErrorIDStatic := #cw_IncorretSubindex;
	        ELSIF #sx_REdgeExecute AND
	            ((NOT #ix_Parameter32Bit AND #idi_Value < -32768) OR (NOT #ix_Parameter32Bit AND #idi_Value > 16#FFFF)) THEN
	            // limitation to int value range. positive hex crc checksums are allowed
	            #sx_DoneStatic := FALSE;
	            #sx_ErrorStatic := TRUE;
	            #sw_ErrorIDStatic := #cw_InvalidDataType;
	        ELSE
	            #sv_RDRECInstance(REQ := FALSE,
	                              ID := #HW_Identifier,
	                              INDEX := #sdi_DataRecord,
	                              MLEN := #ci_Length,
	                              RECORD := #sa_ReadVal);
	        END_IF;
	        
	    1:
	        #sv_WRRECInstance();
	        
	        IF #sv_WRRECInstance.DONE THEN
	            #sv_WRRECInstance(REQ := FALSE);
	            #si_State := 2;
	        ELSIF #sv_WRRECInstance.ERROR THEN
	            #sx_DoneStatic := FALSE;
	            #sx_ErrorStatic := TRUE;
	            #sw_ErrorIDStatic := DWORD_TO_WORD(#sv_WRRECInstance.STATUS);
	            #si_State := 0;
	            #qx_Done := FALSE;
	            #qx_Busy := TRUE;
	        END_IF;
	        
	    2:
	        #sv_RDRECInstance(REQ := TRUE,
	                          ID := #HW_Identifier,
	                          INDEX := #sdi_DataRecord,
	                          MLEN := #ci_Length,
	                          RECORD := #sa_ReadVal);
	        
	        #tw_ResponseLABEL := SHR(IN := #sa_RecRead.PKE, N := 12);
	        #tw_ResponsePNU := #sa_RecRead.PKE AND #cw_PNUMask;
	        #tw_ResponseIND := #sa_RecRead.Index;
	        #tdi_ResponsePWE := #sa_RecRead.Para_Val;
	        #qdi_ValueRead := #sa_RecRead.Para_Val;
	        IF #sv_RDRECInstance.ERROR THEN
	            #sx_DoneStatic := FALSE;
	            #sx_ErrorStatic := TRUE;
	            #sw_ErrorIDStatic := DWORD_TO_WORD(#sv_RDRECInstance.STATUS);
	            #si_State := 0;
	        ELSIF #sv_RDRECInstance.VALID AND #tw_ResponseLABEL = #cw_OrderCannotBeExecuted THEN
	            #sx_DoneStatic := FALSE;
	            #sx_ErrorStatic := TRUE;
	            #sw_ErrorIDStatic := DINT_TO_WORD(#tdi_ResponsePWE);
	            #si_State := 0;
	        ELSIF #sv_RDRECInstance.VALID AND #tw_ResponseLABEL <> #cw_NoResponse AND
	            #tw_ResponseLABEL <> #cw_OrderCannotBeExecuted AND #tw_ResponsePNU = #sw_Pnu AND
	            #tw_ResponseIND = #sa_RecWrite.Index THEN
	            // acyclic write command complete
	            #sx_DoneStatic := TRUE;
	            #si_State := 0;
	        END_IF;
	        
	        // check for read timeout
	        IF #si_Receivecounter >= #ci_ReceivecounterMax THEN
	            #sx_DoneStatic := FALSE;
	            #sx_ErrorStatic := TRUE;
	            #sw_ErrorIDStatic := #cw_InternalResponseLabelCannotBeDepicted;
	            #si_State := 0;
	        ELSE
	            #si_Receivecounter := #si_Receivecounter + 1;
	        END_IF;
	END_CASE;
	
	// output assignment
	#qx_Busy := INT_TO_BOOL(#si_State) AND NOT #sx_DoneStatic AND NOT #sx_ErrorStatic;
	IF #ix_Execute THEN
	    #qx_Done := #sx_DoneStatic;
	    #qx_Error := #sx_ErrorStatic;
	    #qw_ErrorID := #sw_ErrorIDStatic;
	ELSE
	    #qx_Done := FALSE;
	    #qx_Error := FALSE;
	    #qw_ErrorID := 0;
	END_IF;
END_FUNCTION_BLOCK

TYPE "UDT_ConveyorStatus"
TITLE = UDT_ConveyorStatus
VERSION : 0.1
//User-defined structure of FB_Conveyor function block status.
   STRUCT
      Status : Int;   // Status number
      Specific : Struct
         Reverse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor is running in reverse direction
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_PECStatus"
VERSION : 0.1
   STRUCT
      PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Current state of the photo eye
      Jam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PEC jam error
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_VfdNORDParaAcycRead"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 34
// END_ATTRIBUTES
   VAR_INPUT 
      iHW_Identifier { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_IO;
      ii_FISystembus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 1;
      ii_Parameter_Number { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ii_Parameter_Index { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ii_Parameter_Set { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ix_Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_OUTPUT 
      qdi_Value { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      qw_Error_ID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
      qx_Valid { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      qx_Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR 
      sa_Write_Val { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..3] of Word;
      sa_Rec_Write { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} AT sa_Write_Val : Struct
         PKE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
         Index { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
         Para_Val { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      END_STRUCT;
      sa_Read_Val { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..3] of Word;
      sa_Rec_Read { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} AT sa_Read_Val : Struct
         PKE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
         Index { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
         Para_Val { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      END_STRUCT;
      sv_WRREC_Instance {InstructionName := 'WRREC'; LibVersion := '1.1'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : WRREC;
      sv_RDREC_Instance {InstructionName := 'RDREC'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : RDREC;
      sw_Ak { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
      sdi_Data_Record { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      sdi_ValueStatic { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      sw_Pnu { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
      sw_ErrorIDStatic { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
      si_Receivecounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      sx_ValidStatic { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_ErrorStatic { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_TEMP 
      tw_ResponseIND : Word;
      tw_ResponseLABEL : Word;
      tw_ResponsePNU : Word;
      tdi_ResponsePWE : DInt;
      tx_WithIndex : Bool;
      tx_WithParameterSet : Bool;
   END_VAR

   VAR CONSTANT 
      cw_IncorrectSubindex : Word := 3;
      cw_InternalResponseLabelCannotBeDepicted : Word := 202;
      cw_NoResponse : Word := 0;
      cw_OrderCannotBeExecuted : Word := 7;
      cw_OrderParameterValue : Word := 1;
      cw_ParameterOffset : Word := 1000;
      cw_PNUMask : Word := 16#07FF;
      ci_ReceivecounterMax : Int := 255;
      ci_Length : UInt := 8;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	25/01/2021  | 0.1       | S.Theocharis  | Copy from NORD library 
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5            
	*)
	
	#tx_WithIndex := #ii_Parameter_Index > 0;
	#tx_WithParameterSet := #ii_Parameter_Set > 0;
	
	CASE #si_State OF
	        
	    0:
	        IF #ix_Enable AND
	            NOT ((#ii_Parameter_Set < 0) OR (#ii_Parameter_Index < 0) OR (#ii_Parameter_Set > 4) OR
	            (#tx_WithParameterSet AND (#ii_Parameter_Index > 64)) OR (NOT #tx_WithParameterSet AND (#ii_Parameter_Index > 256))) THEN
	            //initialize
	            #si_Receivecounter := 0;
	            
	            // get PROFINET IO data record
	            IF (#ii_Parameter_Number >= 150 AND #ii_Parameter_Number <= 199) OR (#ii_Parameter_Number >= 800 AND #ii_Parameter_Number <= 849) THEN
	                // order to the bus interface
	                #sdi_Data_Record := 100;
	            ELSIF ((#ii_Parameter_Number >= 0 AND #ii_Parameter_Number < 150) OR (#ii_Parameter_Number >= 200 AND #ii_Parameter_Number <= 799) OR
	                (#ii_Parameter_Number >= 850 AND #ii_Parameter_Number <= 999)) AND (#ii_FISystembus > 0) AND (#ii_FISystembus <= 8) THEN
	                // order to frequency inverter 1..8
	                #sdi_Data_Record := #ii_FISystembus + 100;
	            ELSE
	                #sdi_Data_Record := 0;
	            END_IF;
	            
	            // get order label (AK)
	            #sw_Ak := #cw_OrderParameterValue;
	            
	            // merge parameter label (PKE)
	            #sw_Pnu := INT_TO_WORD(#ii_Parameter_Number + WORD_TO_INT(#cw_ParameterOffset));
	            #sa_Rec_Write.PKE := SHL(IN := #sw_Ak, N := 12) OR #sw_Pnu;
	            
	            // get sub-index (IND)
	            IF #tx_WithIndex AND #tx_WithParameterSet THEN
	                #sa_Rec_Write.Index := SHL(IN := SHL(IN := INT_TO_WORD((#ii_Parameter_Index) - 1), N := 2) OR
	                                           INT_TO_WORD((#ii_Parameter_Set) - 1), N := 8);
	            ELSIF NOT #tx_WithIndex AND #tx_WithParameterSet THEN
	                #sa_Rec_Write.Index := SHL(IN := INT_TO_WORD((#ii_Parameter_Set) - 1), N := 8);
	            ELSIF #tx_WithIndex AND NOT #tx_WithParameterSet THEN
	                #sa_Rec_Write.Index := SHL(IN := INT_TO_WORD((#ii_Parameter_Index) - 1), N := 8);
	            ELSE
	                #sa_Rec_Write.Index := 0;
	            END_IF;
	            
	            // check if parameter or index changed from last request
	            IF (#sa_Rec_Read.PKE AND #cw_PNUMask) <> (#sa_Rec_Write.PKE AND #cw_PNUMask) OR
	                (#sa_Rec_Read.Index <> #sa_Rec_Write.Index) THEN
	                // if changed reset valid bit
	                #sx_ValidStatic := FALSE;
	                #sx_ErrorStatic := FALSE;
	            END_IF;
	            
	            // write data to device
	            #sv_WRREC_Instance(REQ := TRUE,
	                               ID := #iHW_Identifier,
	                               INDEX := #sdi_Data_Record,
	                               LEN := #ci_Length,
	                               DONE => #sv_WRREC_Instance.DONE,
	                               BUSY => #sv_WRREC_Instance.BUSY,
	                               ERROR => #sv_WRREC_Instance.ERROR,
	                               RECORD := #sa_Write_Val);
	            #si_State := 1;
	        ELSIF #ix_Enable AND
	            ((#ii_Parameter_Set < 0) OR (#ii_Parameter_Index < 0) OR (#ii_Parameter_Set > 4) OR
	            (#tx_WithParameterSet AND (#ii_Parameter_Index > 63)) OR (NOT #tx_WithParameterSet AND (#ii_Parameter_Index > 255))) THEN
	            #sx_ValidStatic := FALSE;
	            #sx_ErrorStatic := TRUE;
	            #sdi_ValueStatic := 0;
	            #sw_ErrorIDStatic := #cw_IncorrectSubindex;
	        ELSE
	            #sv_RDREC_Instance(REQ := FALSE,
	                               ID := #iHW_Identifier,
	                               INDEX := #sdi_Data_Record,
	                               MLEN := #ci_Length,
	                               RECORD := #sa_Read_Val);
	            #sx_ValidStatic := FALSE;
	            #sx_ErrorStatic := FALSE;
	            #sw_ErrorIDStatic := 0;
	            #sdi_ValueStatic := 0;
	        END_IF;
	        
	    1:
	        #sv_WRREC_Instance();
	        
	        IF #sv_WRREC_Instance.DONE THEN
	            #sv_WRREC_Instance(REQ := FALSE);
	            #si_State := 2;
	        ELSIF #sv_WRREC_Instance.ERROR THEN
	            #sx_ValidStatic := FALSE;
	            #sx_ErrorStatic := TRUE;
	            #sdi_ValueStatic := 0;
	            #sw_ErrorIDStatic := DWORD_TO_WORD(#sv_WRREC_Instance.STATUS);
	            #si_State := 0;
	        END_IF;
	        
	    2:
	        #sv_RDREC_Instance(REQ := TRUE,
	                           ID := #iHW_Identifier,
	                           INDEX := #sdi_Data_Record,
	                           MLEN := #ci_Length,
	                           RECORD := #sa_Read_Val);
	        
	        #tw_ResponseLABEL := SHR(IN := #sa_Rec_Read.PKE, N := 12);
	        #tw_ResponsePNU := #sa_Rec_Read.PKE AND #cw_PNUMask;
	        #tw_ResponseIND := #sa_Rec_Read.Index;
	        #tdi_ResponsePWE := #sa_Rec_Read.Para_Val;
	        
	        IF #sv_RDREC_Instance.ERROR THEN
	            #sx_ValidStatic := FALSE;
	            #sx_ErrorStatic := TRUE;
	            #sdi_ValueStatic := 0;
	            #sw_ErrorIDStatic := DWORD_TO_WORD(#sv_RDREC_Instance.STATUS);
	            #si_State := 0;
	        ELSIF #sv_RDREC_Instance.VALID AND #tw_ResponseLABEL = #cw_OrderCannotBeExecuted THEN
	            #sx_ValidStatic := FALSE;
	            #sx_ErrorStatic := TRUE;
	            #sdi_ValueStatic := 0;
	            #sw_ErrorIDStatic := DINT_TO_WORD(#tdi_ResponsePWE);
	            #si_State := 0;
	        ELSIF #sv_RDREC_Instance.VALID AND #tw_ResponseLABEL <> #cw_NoResponse AND
	            #tw_ResponseLABEL <> #cw_OrderCannotBeExecuted AND #tw_ResponsePNU = #sw_Pnu AND
	            #tw_ResponseIND = #sa_Rec_Write.Index THEN
	            // acyclic read command complete
	            #sx_ValidStatic := TRUE;
	            #sx_ErrorStatic := FALSE;
	            #sdi_ValueStatic := #tdi_ResponsePWE;
	            #sw_ErrorIDStatic := 0;
	            #si_State := 0;
	        END_IF;
	        
	        // check for read timeout
	        IF #si_Receivecounter >= #ci_ReceivecounterMax THEN
	            #sx_ValidStatic := FALSE;
	            #sx_ErrorStatic := TRUE;
	            #sdi_ValueStatic := 0;
	            #sw_ErrorIDStatic := #cw_InternalResponseLabelCannotBeDepicted;
	            #si_State := 0;
	        ELSE
	            #si_Receivecounter := #si_Receivecounter + 1;
	        END_IF;
	        
	END_CASE;
	
	// output assignment
	#qx_Busy := INT_TO_BOOL(#si_State);
	IF #ix_Enable THEN
	    #qx_Valid := #sx_ValidStatic;
	    #qx_Error := #sx_ErrorStatic;
	    #qw_Error_ID := #sw_ErrorIDStatic;
	    #qdi_Value := #sdi_ValueStatic;
	ELSE
	    #qx_Valid := FALSE;
	    #qx_Error := FALSE;
	    #qw_Error_ID := 0;
	    #qdi_Value := 0;
	END_IF;
END_FUNCTION_BLOCK

TYPE "UDT_ConveyorCommand"
TITLE = UDT_ConveyorCommand
VERSION : 0.1
//User-defined structure of conveyor commands.
   STRUCT
      ManualMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual mode command from HMI
      ManualStartStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Run conveyor in manual mode
      ManualFullSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Full speed conveyor in manual mode
      ManualJog { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command to jog conveyor in slow speed from HMI
      Reverse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command to run conveyor in reverse direction from HMI
      ManualSpeed : Int := 50;   // Manual mode speed as percentage of nominal speed [0-100%]
   END_STRUCT;

END_TYPE

TYPE "UDT_RATStatistics"
VERSION : 0.1
   STRUCT
      AirPressure { S7_SetPoint := 'False'} : "UDT_EventStatistic";
      DivertUpError : "UDT_EventStatistic";
      DivertDownError : "UDT_EventStatistic";
      ConveyorUp : "UDT_EventStatistic";
      ConveyorDown : "UDT_EventStatistic";
      ConveyorStop : "UDT_EventStatistic";
   END_STRUCT;

END_TYPE

TYPE "UDT_ConveyorHandshake"
TITLE = UDT_ConveyorHandshake
VERSION : 0.1
//User-defined structure of conveyor handshake variables.
   STRUCT
      GIN : Int;   // General identification number
      NrOfPosToShift : Int;   // Number of positions to shift
      DownstreamDisplacement : Int;   // Displacement from downstream [cm]
      RTS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor ready to send
      RTR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor ready to receive
      TIP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Transfer in progress
      ResetEnergySave { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset energy save mode
      CascadeStartUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Cascade startup
      ReqStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request stop
   END_STRUCT;

END_TYPE

TYPE "UDT_ConveyorStatistics"
TITLE = UDT_ConveyorStatistics
VERSION : 0.1
//User-defined structure of FB_Conveyor function block statistics.
   STRUCT
      EnergySave : "UDT_EventStatistic";   // Number of times that save energy mode occurs
      ConveyorUp : "UDT_EventStatistic";   // Conveyor up statistics
      ConveyorDown : "UDT_EventStatistic";   // Conveyor down statistics
      ConveyorStop : "UDT_EventStatistic";   // Conveyor down statistics
   END_STRUCT;

END_TYPE

TYPE "UDT_VfdStatistics"
TITLE = UDT_VFDStatistics_SEW
VERSION : 0.1
//User-defined structure of FB_VFD_SEW_MOVI-C function block statistics.
   STRUCT
      PNSlaveNotOnline : "UDT_EventStatistic";   // Statistics of Profinet slave not online
      PNSlaveError : "UDT_EventStatistic";   // Statistics of a Profinet slave error
      VFDInternalError : "UDT_EventStatistic";   // Statistics of an internal VFD error
      CommunicationErrorMovikit : "UDT_EventStatistic";   // Statistics of a communication error
      Running : "UDT_EventStatistic";   // Statistics for running time
   END_STRUCT;

END_TYPE

TYPE "UDT_MotorData"
VERSION : 0.1
   STRUCT
      MainVoltage : Int;   // [Volt] Mains
      NominalVoltage : Int;   // [Volt] Motor nameplate for applicable connection
      NominalCurrent : Real;   // [Amps] Motor nameplate for applicable connection
      NominalPower : Real;   // [kW] Motor nameplate
      NominalSpeed : Int;   // [RPM] Motor nameplate
      NominalTorque : Real;   // [Nm] Motor nameplate
      CosPhi : Real;   // 0.0 - 0.99 Motor nameplate
      Connection : Int;   // 0=Start , 1=Delta
      BrakeConfig { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE = Brake control from VFD. FALSE = No Brake
      EncoderConfig { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE = Encoder connected at the VFD . FALSE = No encoder at the VFD
      EncoderResolution : Int;   // Pulses Per Rev
      ThermalConfig : Int;   // 0=No thermal control, 1= PTC1, 2=KTY84, 4= Bimetalic Switch
      NoMotorsParallel : Int;   // Number of motors in parallel
      VFDType : Int;   // Specific code 1= G120C, 5302= G120D 0,75kW, 5304= G120D 1,5kW, 5306= G120D 3kW, 5307= G120D 4kW, 5308= 5,5kW, 5309= G120D 7,5kW
      MinimumRamp : Int;   // Minimum applicable ramp in ms
      FAdress : Real;   // Safety adress from HW configuration
   END_STRUCT;

END_TYPE

TYPE "UDT_StatusTC07"
VERSION : 0.1
//One direction, motor, controler, EOS
   STRUCT
      Conveyor { ExternalWritable := 'False'} : "UDT_ConveyorStatus";   // Conveyor Status
      PEC_EoS { ExternalWritable := 'False'} : "UDT_PECStatus";   // PEC EoS Status
      MCO_M01 { ExternalWritable := 'False'} : "UDT_AixControllerStatus";   // MCO Status
      BladeStopEoS { ExternalWritable := 'False'} : "UDT_ValveStatus";   // Stop blade at the end of section status
   END_STRUCT;

END_TYPE

FUNCTION "FC_ExtractCodeFromString" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      is_String : String;
   END_VAR

   VAR_OUTPUT 
      qs_String : String;
   END_VAR

   VAR_TEMP 
      ts_String : Bool;
      ti_StartPoint : Int;
      ti_StopPoint : Int;
      ti_CodeLenght : Int;
   END_VAR

   VAR CONSTANT 
      StartSign : String := '$02';
      StopSign : String := '$03';
   END_VAR


BEGIN
	#ti_StartPoint := FIND(IN1 := #is_String, IN2 := #StartSign);
	#ti_StopPoint := FIND(IN1 := #is_String, IN2 := #StopSign);
	#ti_CodeLenght := #ti_StopPoint - #ti_StartPoint - 1;
	
	#qs_String := MID(IN := #is_String, L := #ti_CodeLenght, P := #ti_StartPoint + 1);
	
END_FUNCTION

TYPE "UDT_DataLogic_IN"
VERSION : 0.1
   STRUCT
      DataFromCamera : Byte;   // OK_READ - .%X0; NO_READ -.%X1; PhaseON -.%X3; PhaseOFF .%X4
      BarCodeValue0 : Byte;   // First character of the barcode.
      BarCodeValue : Array[1..14] of Char;   // Remaining characters of the barcode, after the barcode remaining chars are  '$00' = BYTE#16#00
   END_STRUCT;

END_TYPE

TYPE "UDT_StatusTC02"
VERSION : 0.1
//One direction, motor, controler, EOS
   STRUCT
      Conveyor : "UDT_ConveyorStatus";   // Conveyor Status
      PEC_EoS : "UDT_PECStatus";   // PEC EoS Status
      MCO_M01 : "UDT_AixControllerStatus";   // MCO Status
   END_STRUCT;

END_TYPE

TYPE "UDT_StatusTC12"
VERSION : 0.1
//One direction, motor, controler, EOS
   STRUCT
      Conveyor : "UDT_ConveyorStatus";   // Conveyor Status
      PEC_EoS : "UDT_PECStatus";   // PEC EoS Status
      MCO_M01 : "UDT_AixControllerStatus";   // MCO Status
   END_STRUCT;

END_TYPE

TYPE "UDT_StatusTC03"
VERSION : 0.1
//One direction, motor, controler, EOS, Tracking
//
   STRUCT
      Conveyor : "UDT_ConveyorStatus";   // Conveyor Status
      PEC_EoS : "UDT_PECUpdateStatus";   // PEC EoS Status
      MCO_M01 : "UDT_AixControllerStatus";   // MCO Status
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "SICK_Lector_CLV6xx_PNDP"
TITLE = SICK Lector6xx / CLV6xx function block
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : SICKAG
FAMILY : Ident
VERSION : 1.2
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 267
// END_ATTRIBUTES
//This function block is used for a communication between a SICK Lector6xx / SICK CLV6xx code reader and a Siemens S7-1200/S7-1500 PLC via  PROFINET/PROFIBUS
   VAR_INPUT 
      HWInputIdent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_IO;   // Hardware identification number of the input module
      HWInputLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;   // Size of the input module
      HWOutputIdent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_IO;   // Hardware identification number of the output module
      HWOutputLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;   // Size of the output module
      CANId { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;   // CAN ID (0= Master / No CAN network)
      TOut { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time := T#10S;   // Time out
      Req { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // A positive edge starts the request
      TriggerOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Select: Trigger On to open the reading gate via a SW-Trigger command
      TriggerOff { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Select: Trigger Off to close the reading gate via a SW-Trigger command
      Matchcode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Select: Matchcode (details at #Data)
      SavePermanent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Select: Save permanent
      ComTest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Select: Communication test
      FreeCommand { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Select: Free command (details at #Data)
   END_VAR

   VAR_OUTPUT 
      RdDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Positive edge: A reading result sent by the device was received
      ReqDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request done
      ReqBusy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request in process
      Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Error detected
      Errorcode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DWord;   // Error code (see documentation)
   END_VAR

   VAR_IN_OUT 
      Data : "ST_SICK_Lector_CLV6xx";   // Command arguments and result outputs of the FB actions
   END_VAR

   VAR 
      bTriggerReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Rising edge detection
      bTriggerReqMem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Rising edge detection
      bTriggerDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Rising edge detection
      bTriggerDoneMem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Rising edge detection
      bTriggerError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Rising edge detection
      bTriggerErrorMem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Rising edge detection
      bCanActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // CAN-Bus active flag
      bDeviceState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Current device state (True= Edit-Mode | False= Run-Mode)
      bEnforceLogout { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Logout enforced
      bReqBusyMem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Backup variable
      iStep { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;   // Currrent FB step
      iCommandIndex { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Command index
      iCommandLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Length of the command that should be send
      iRecordSize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Length of the record array
      iCommandSize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Length of the command array
      iReadingResultSize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Length of the reading result array
      iIndex { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Index variable
      nTempErrorCode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DWord;   // Temporarily error code
      nLogoutErrorCode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DWord;   // Temporarily error code
      arrSelection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..5] of Bool;   // input bit selection
      arrCommand { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..499] of Byte;   // Contains the transmitted CoLa command
      arrRecord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..499] of Byte;   // Contains the received telegram
      fbTimeout {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;   // Instance: Timer on delay (Time out)
      fbCCom { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "SICK_CCOMM_PNDP";   // Instance: CoLa communication block
   END_VAR

   VAR_TEMP 
      iTemp1 : Int;   // Temporarily variable
      iTemp2 : UDInt;   // Temporarily variable
      iTemp3 : UDInt;   // Temporarily variable
      nFncValue : DWord;   // Get/Set function value
      nFncErrorCode : Word;   // Get/Set function error code
   END_VAR


BEGIN
	(*===========================================================================================
	Name:   SICK_Lector_CLV6xx_PNDP 
	Author: SICK AG
	=============================================================================================
	Description: 
	This function block is used for a communication between a SICK Lector6xx / SICK CLV6xx
	code reader and a Siemens S7-1200/S7-1500 PLC via PROFINET/PROFIBUS.                         
	
	=============================================================================================
	Features:        
	- Receive reading results of the device, triggered by a command, fieldbus or by a hardware 
	  switch. The content of the result can be modified in the "Output Format" option in the
	  SOPAS engineeringtool.                                           
	- Open and close a reading gate (software trigger via command)
	- Set a new Matchcode evaluation condition 
	- Save all device parameters permanent                                                  
	- Communication test
	- Send a free defined CoLa-A telegram and receive the result
	- All commands can also be used in a SICK CAN-Bus network
	                                                                                                                                                               
	=============================================================================================
	Version history:
	Date       | Version | Author  | Remark
	---------------------------------------------------------------------------------------------
	21/02/2014 | V1.0    | SICK AG | Initial version
	07/08/2014 | V1.1    | SICK AG | Replace R_TRIG function 
	24/10/2017 | V1.2    | SICK AG | Avoid initialization warnings which occurs using TIA V13 or higher
	============================================================================================*)
	
	(*===================================== INITIALISATION =====================================*)
	#iRecordSize := 500;         (*Length of the arrRecord array*)
	#iCommandSize := 500;        (*Length of the arrCommand array*)
	#iReadingResultSize := 200;  (*Length of the reading result array*)
	
	(*Rising edge detection*)
	#bTriggerReq := #Req AND NOT #bTriggerReqMem;
	#bTriggerReqMem := #Req;
	#bTriggerDone := #fbCCom.ReqDone AND NOT #bTriggerDoneMem;
	#bTriggerDoneMem := #fbCCom.ReqDone;
	#bTriggerError := #fbCCom.Error AND NOT #bTriggerErrorMem;
	#bTriggerErrorMem := #fbCCom.Error;
	
	(*Reset the read done flag every cycle*)
	#RdDone := false;
	
	
	(*===================================== ERROR HANDLING =====================================*)
	(* bDeviceState  |  bEnforceLogout  |  Action
	       FALSE     |      FALSE       |  Errorcode = Errorcode from last plc cycle
	       FALSE     |      TRUE        |  Errorcode = Logout error
	       TRUE      |      FALSE       |  Enforce "Logout" command
	       TRUE      |      TRUE        |  Errorcode = Logout not possible + Reason*)
	IF #nTempErrorCode <> 16#0000_0000 THEN
	    
	    (*Enfore "Logout" command*)
	    IF #bDeviceState AND NOT #bEnforceLogout THEN
	        #bEnforceLogout := true;
	        #iCommandIndex := 11;                  (*Logout*)
	        #nLogoutErrorCode := #nTempErrorCode;  (*Save current error code*)
	        #nTempErrorCode := 16#0000_0000;       (*Clear currenr error variable*)
	        #iStep := 4;                           (*Create command*)
	        
	        (*Logout can not be ensured*)
	    ELSIF #bDeviceState AND #bEnforceLogout THEN
	        #Errorcode.%W1 := #nTempErrorCode.%W0;
	        #Errorcode.%W0 := 16#0017;  (*Error: Logout can not be ensured (please check the device state)*)
	        
	        (*Errorcode = Errorcode from the last plc cycle or logout error*)
	    ELSE
	        #Errorcode := #nTempErrorCode;
	    END_IF;
	    
	    (*Update FB status*)
	    IF #nTempErrorCode <> 16#0000_0000 THEN
	        #ReqDone := false;
	        #ReqBusy := false;
	        #bReqBusyMem := false;
	        #Error := true;
	        #nTempErrorCode := 16#0000_0000;
	        #nLogoutErrorCode := 16#0000_0000;
	        #iStep := 0;
	        RETURN;
	    END_IF;
	END_IF;
	
	(*Time out detection*)
	#fbTimeout(IN := #bReqBusyMem,
	           PT := #TOut);
	IF #fbTimeout.Q THEN
	    #nTempErrorCode := 16#0000_0010; (*Error: Time out*)
	END_IF;
	
	(*Check if a device error is detected: 'sFA XX'*)
	IF #bTriggerDone AND ((NOT #bCanActive AND
	    #arrRecord[0] = 's' AND
	    #arrRecord[1] = 'F' AND
	    #arrRecord[2] = 'A') OR (#bCanActive AND
	    #arrRecord[0] = 's' AND
	    #arrRecord[12] = 'F' AND
	    #arrRecord[13] = 'A')) THEN
	    
	    (*Get the position of the error code*)
	    IF #bCanActive THEN
	        #iIndex := 15;
	    ELSE
	        #iIndex := 4;
	    END_IF;
	    
	    "SICK_GetValue"(iTelegramLength := INT_TO_UINT(#fbCCom.ReqLength),
	                    iValueLength := 0,
	                    nValue => #nFncValue,
	                    nErrorCode => #nFncErrorCode,
	                    iPosition := #iIndex,
	                    arrData := #arrRecord);
	    
	    IF #nFncErrorCode = 16#0000 THEN
	        #nTempErrorCode.%W1 := DWORD_TO_WORD(#nFncValue);
	        #nTempErrorCode.%W0 := 16#0011; (*Error: Device error*)
	    ELSE
	        #nTempErrorCode.%W1 := #nFncErrorCode;
	        #nTempErrorCode.%W0 := 16#0012; (*Error: SICK_GetValue error*)
	    END_IF;
	END_IF;
	
	(*Error detected*)
	IF #nTempErrorCode <> 16#0000_0000 THEN
	    RETURN;
	END_IF;
	
	
	(*================================= START REQUEST (STEP 1) =================================*)
	IF NOT #bReqBusyMem AND #bTriggerReq THEN
	    #ReqDone := false;
	    #ReqBusy := true;
	    #bReqBusyMem := true;
	    #Error := false;
	    #Errorcode := 16#0000_0000;
	    #bDeviceState := false;
	    #bEnforceLogout := false;
	    
	    (*Save the current bit selection for the job*)
	    #arrSelection[0] := #TriggerOn;
	    #arrSelection[1] := #TriggerOff;
	    #arrSelection[2] := #Matchcode;
	    #arrSelection[3] := #SavePermanent;
	    #arrSelection[4] := #ComTest;
	    #arrSelection[5] := #FreeCommand;
	    
	    (*Check CAN-ID*)
	    IF #CANId > 63 THEN
	        #nTempErrorCode := 16#0000_0014; (*Error invalid CAN Id*)
	    ELSIF #CANId = 0 THEN
	        #bCanActive := false;
	        #iStep := 3; (*Check parameter input*)
	    ELSE
	        #bCanActive := true;
	        #iStep := 2; (*Add CAN identifier*)
	    END_IF;
	END_IF;
	
	
	(*=============================== ADD CAN IDENTIFIER (STEP 2) ==============================*)
	IF #iStep = 2 THEN
	    Strg_TO_Chars(Strg := 's{ 00 01 ',
	                  pChars := 0,
	                  Cnt => #iIndex,
	                  Chars := #arrCommand);
	    
	    "SICK_SetValue"(bAddBlank := false,
	                    nValue := #CANId,
	                    arrData => #arrCommand,
	                    nErrorCode => #nFncErrorCode,
	                    iPosition := #iIndex);
	    IF #nFncErrorCode <> 16#0000 THEN
	        #nTempErrorCode.%W1 := #nFncErrorCode;
	        #nTempErrorCode.%W0 := 16#0013; (*Error: SICK_SetValue error*)
	    ELSE
	        #arrCommand[#iIndex] := '}';
	        #iStep := 3; (*Check parameter input*)
	    END_IF;
	END_IF;
	
	
	(*============================= CHECK PARAMETER INPUT (STEP 3) =============================*)
	IF #iStep = 3 THEN
	    #iTemp1 := 0; (*Counts up the active bit selection*)
	    
	    (*Command: Trigger On*)
	    IF #arrSelection[0] THEN
	        #iTemp1 := #iTemp1 + 1;
	        #iCommandIndex := 0; (*Send a "Trigger On" command*)
	    END_IF;
	    
	    (*Command: Trigger Off*)
	    IF #arrSelection[1] THEN
	        #iTemp1 := #iTemp1 + 1;
	        #iCommandIndex := 1; (*Send a "Trigger Off" command*)
	    END_IF;
	    
	    (*Command: Matchcode*)
	    IF #arrSelection[2] THEN
	        #iTemp1 := #iTemp1 + 1;
	        
	        IF #Data.Matchcode.sName = '' THEN
	            #nTempErrorCode := 16#0000_0022; (*Error: Matchcode name is empty*)
	        ELSIF #Data.Matchcode.nCodeType <= '$20' OR #Data.Matchcode.nCodeType > '$7E' THEN
	            #nTempErrorCode := 16#0000_0023; (*Error: Invalid code type*)
	        END_IF;
	        
	        #iCommandIndex := 10; (*Send a "Login" command*)
	    END_IF;
	    
	    (*Command: Save permanent*)
	    IF #arrSelection[3] THEN
	        #iTemp1 := #iTemp1 + 1;
	        #iCommandIndex := 10; (*Send a "Login" command*)
	    END_IF;
	    
	    (*Command: Communication test*)
	    IF #arrSelection[4] THEN
	        #iTemp1 := #iTemp1 + 1;
	        #iCommandIndex := 4; (*Send a "Comm Test" command*)
	    END_IF;
	    
	    (*Command: Free command*)
	    IF #arrSelection[5] THEN
	        #iTemp1 := #iTemp1 + 1;
	        
	        (*Check length*)
	        IF #bCanActive THEN
	            #iTemp2 := INT_TO_UDINT(LEN(#Data.FreeCommand.sCommand)) + 11;
	        ELSE
	            #iTemp2 := INT_TO_UDINT(LEN(#Data.FreeCommand.sCommand));
	        END_IF;
	        
	        IF (LEN(#Data.FreeCommand.sCommand) <= 0) OR (#iTemp2 > #iCommandSize) THEN
	            #nTempErrorCode := 16#0000_0020; (*Error: Invalid free command length*)
	        END_IF;
	        
	        #iCommandIndex := 5; (*Send a "Free Command" command*)
	    END_IF;
	    
	    (*Check bit sum of the command selection*)
	    IF #iTemp1 <> 1 THEN
	        #nTempErrorCode := 16#0000_0015; (*Error: More than one or no parameter selected*)
	    END_IF;
	    
	    (*Check if a error was detected*)
	    IF #nTempErrorCode = 16#0000_0000 THEN
	        #iStep := 4; (*Create CoLa command*)
	    END_IF;
	END_IF;
	
	
	(*============================== CREATE COLA COMMAND (STEP 4) ==============================*)
	IF #iStep = 4 THEN
	    CASE #iCommandIndex OF
	            
	            (*Create "Trigger On" command*)
	        0:
	            IF #bCanActive THEN
	                Strg_TO_Chars(Strg := 'MN mTCgateon',
	                              pChars := 12,
	                              Cnt => #iTemp3,
	                              Chars := #arrCommand);
	                #iCommandLength := UDINT_TO_UINT(#iTemp3) + 12;
	            ELSE
	                Strg_TO_Chars(Strg := 'sMN mTCgateon',
	                              pChars := 0,
	                              Cnt => #iTemp3,
	                              Chars := #arrCommand);
	                #iCommandLength := UDINT_TO_UINT(#iTemp3);
	            END_IF;
	            #iStep := 5; (*Send command*)
	            
	            (*Create "Trigger Off" command*)
	        1:
	            IF #bCanActive THEN
	                Strg_TO_Chars(Strg := 'MN mTCgateoff',
	                              pChars := 12,
	                              Cnt => #iTemp3,
	                              Chars := #arrCommand);
	                #iCommandLength := UDINT_TO_UINT(#iTemp3) + 12;
	            ELSE
	                Strg_TO_Chars(Strg := 'sMN mTCgateoff',
	                              pChars := 0,
	                              Cnt => #iTemp3,
	                              Chars := #arrCommand);
	                #iCommandLength := UDINT_TO_UINT(#iTemp3);
	            END_IF;
	            #iStep := 5; (*Send command*)
	            
	            (*Create "Matchcode" command*)
	        2:
	            IF #bCanActive THEN
	                Strg_TO_Chars(Strg := 'MN mEVSetMatchCode 00 ',
	                              pChars := 12,
	                              Cnt => #iTemp3,
	                              Chars := #arrCommand);
	                #iIndex := UDINT_TO_UINT(#iTemp3 + 12);
	            ELSE
	                Strg_TO_Chars(Strg := 'sMN mEVSetMatchCode 00 ',
	                              pChars := 0,
	                              Cnt => #iTemp3,
	                              Chars := #arrCommand);
	                #iIndex := UDINT_TO_UINT(#iTemp3);
	            END_IF;
	            
	            (*Add matchcode name*)
	            Strg_TO_Chars(Strg := CONCAT(IN1 := 'name="', IN2 := #Data.Matchcode.sName),
	                          pChars := #iIndex,
	                          Cnt => #iTemp3,
	                          Chars := #arrCommand);
	            #iIndex := #iIndex + UDINT_TO_UINT(#iTemp3);
	            
	            (*Add codeType*)
	            Strg_TO_Chars(Strg := '" codeType="',
	                          pChars := #iIndex,
	                          Cnt => #iTemp3,
	                          Chars := #arrCommand);
	            #iIndex := #iIndex + UDINT_TO_UINT(#iTemp3);
	            IF #Data.Matchcode.nCodeType = '*' THEN
	                Strg_TO_Chars(Strg := 'dontCare',
	                              pChars := #iIndex,
	                              Cnt => #iTemp3,
	                              Chars := #arrCommand);
	                #iIndex := #iIndex + UDINT_TO_UINT(#iTemp3);
	            ELSE
	                #arrCommand[#iIndex] := #Data.Matchcode.nCodeType;
	                #iIndex := #iIndex + 1;
	            END_IF;
	            
	            (*Add Min/Max length*)
	            Strg_TO_Chars(Strg := '" length="',
	                          pChars := #iIndex,
	                          Cnt => #iTemp3,
	                          Chars := #arrCommand);
	            #iIndex := #iIndex + UDINT_TO_UINT(#iTemp3);
	            IF #Data.Matchcode.iMinMaxLength = 0 THEN
	                Strg_TO_Chars(Strg := 'dontCare',
	                              pChars := #iIndex,
	                              Cnt => #iTemp3,
	                              Chars := #arrCommand);
	                #iIndex := #iIndex + UDINT_TO_UINT(#iTemp3);
	            ELSE
	                #arrCommand[#iIndex] := ((#Data.Matchcode.iMinMaxLength / 100) MOD 10) + 16#30;
	                #arrCommand[#iIndex + 1] := ((#Data.Matchcode.iMinMaxLength / 10) MOD 10) + 16#30;
	                #arrCommand[#iIndex + 2] := (#Data.Matchcode.iMinMaxLength MOD 10) + 16#30;
	                #iIndex := #iIndex + 3;
	            END_IF;
	            
	            (*Add content*)
	            Strg_TO_Chars(Strg := CONCAT(IN1 := '" content="', IN2 := #Data.Matchcode.sContent),
	                          pChars := #iIndex,
	                          Cnt => #iTemp3,
	                          Chars := #arrCommand);
	            #iIndex := #iIndex + UDINT_TO_UINT(#iTemp3);
	            #arrCommand[#iIndex] := '"';
	            
	            
	            (*Overwrite the matchcode length*)
	            IF #bCanActive THEN
	                #nFncValue := #iIndex - 33;      (*Length of the #Matchcode command*)
	                #iCommandLength := #iIndex + 1;  (*Length of the whole CoLa command*)
	                #iIndex := 31;                 (*Startindex of the matchcode length*)
	            ELSE
	                #nFncValue := #iIndex - 22;      (*Length of the #Matchcode command*)
	                #iCommandLength := #iIndex + 1;  (*Length of the whole CoLa command*)
	                #iIndex := 20;                 (*Startindex of the matchcode length*)
	            END_IF;
	            
	            "SICK_SetValue"(bAddBlank := false,
	                            nValue := #nFncValue,
	                            arrData => #arrCommand,
	                            nErrorCode => #nFncErrorCode,
	                            iPosition := #iIndex);
	            IF #nFncErrorCode <> 16#0000 THEN
	                #nTempErrorCode.%W1 := #nFncErrorCode;
	                #nTempErrorCode.%W0 := 16#0013; (*Error: SICK_SetValue error*)
	            ELSE
	                #iStep := 5; (*Send command*)
	            END_IF;
	            
	            (*Create "Save Permanent" command*)
	        3:
	            IF #bCanActive THEN
	                Strg_TO_Chars(Strg := 'MN mEEwriteall',
	                              pChars := 12,
	                              Cnt => #iTemp3,
	                              Chars := #arrCommand);
	                #iCommandLength := UDINT_TO_UINT(#iTemp3 + 12);
	            ELSE
	                Strg_TO_Chars(Strg := 'sMN mEEwriteall',
	                              pChars := 0,
	                              Cnt => #iTemp3,
	                              Chars := #arrCommand);
	                #iCommandLength := UDINT_TO_UINT(#iTemp3);
	            END_IF;
	            #iStep := 5; (*Send command*)
	            
	            (*Create "Communication Test" command*)
	        4:
	            IF #bCanActive THEN
	                Strg_TO_Chars(Strg := 'RI0',
	                              pChars := 12,
	                              Cnt => #iTemp3,
	                              Chars := #arrCommand);
	                #iCommandLength := UDINT_TO_UINT(#iTemp3) + 12;
	            ELSE
	                Strg_TO_Chars(Strg := 'sRI0',
	                              pChars := 0,
	                              Cnt => #iTemp3,
	                              Chars := #arrCommand);
	                #iCommandLength := UDINT_TO_UINT(#iTemp3);
	            END_IF;
	            #iStep := 5; (*Send command*)
	            
	            (*Create "Free Command"*)
	        5:
	            IF #bCanActive THEN
	                Strg_TO_Chars(Strg := DELETE(IN := #Data.FreeCommand.sCommand, L := 1, P := 1),
	                              pChars := 12,
	                              Cnt => #iTemp3,
	                              Chars := #arrCommand);
	                #iCommandLength := UDINT_TO_UINT(#iTemp3) + 12;
	            ELSE
	                Strg_TO_Chars(Strg := #Data.FreeCommand.sCommand,
	                              pChars := 0,
	                              Cnt => #iTemp3,
	                              Chars := #arrCommand);
	                #iCommandLength := UDINT_TO_UINT(#iTemp3);
	            END_IF;
	            #iStep := 5; (*Send command*)
	            
	            (*Create "Login" command*)
	        10:
	            IF #bCanActive THEN
	                Strg_TO_Chars(Strg := 'MN SetAccessMode 03 F4724744',
	                              pChars := 12,
	                              Cnt => #iTemp3,
	                              Chars := #arrCommand);
	                #iCommandLength := UDINT_TO_UINT(#iTemp3) + 12;
	            ELSE
	                Strg_TO_Chars(Strg := 'sMN SetAccessMode 03 F4724744',
	                              pChars := 0,
	                              Cnt => #iTemp3,
	                              Chars := #arrCommand);
	                #iCommandLength := UDINT_TO_UINT(#iTemp3);
	            END_IF;
	            #iStep := 5; (*Send command*)
	            
	            (*Create "Logout" command*)
	        11:
	            IF #bCanActive THEN
	                Strg_TO_Chars(Strg := 'MN Run',
	                              pChars := 12,
	                              Cnt => #iTemp3,
	                              Chars := #arrCommand);
	                #iCommandLength := UDINT_TO_UINT(#iTemp3) + 12;
	            ELSE
	                Strg_TO_Chars(Strg := 'sMN Run',
	                              pChars := 0,
	                              Cnt => #iTemp3,
	                              Chars := #arrCommand);
	                #iCommandLength := UDINT_TO_UINT(#iTemp3);
	            END_IF;
	            #iStep := 5; (*Send command*)
	            
	    END_CASE;
	END_IF;
	
	
	(*=============================== SEND COLA COMMAND (STEP 5) ===============================*)
	IF #iStep = 5 THEN
	    IF NOT #fbCCom.ReqBusy AND NOT #bTriggerDone AND NOT #bTriggerError THEN
	        #fbCCom.Req := true;
	        #iStep := 6; (*Wait for the command answer*)
	    END_IF;
	END_IF;
	
	
	(*========================== WAIT FOR THE COMMAND ANSWER (STEP 6) ==========================*)
	IF #iStep = 6 THEN
	    (*Communication error*)
	    IF #bTriggerError THEN
	        #nTempErrorCode := #fbCCom.Errorcode; (*Error: Communication error*)
	        
	        (*Communication done*)
	    ELSIF #bTriggerDone THEN
	        #iStep := 7; (*Check the command answer*)
	    END_IF;
	END_IF;
	
	
	(*============================= CHECK COMMAND RESPONSE (STEP 7) ============================*)
	IF #iStep = 7 THEN
	    CASE #iCommandIndex OF
	            
	            (*Check "Trigger On" response*)
	        0:
	            IF #bCanActive THEN
	                IF #arrRecord[0] = 's' AND
	                    #arrRecord[12] = 'A' AND
	                    #arrRecord[13] = 'N' AND
	                    #arrRecord[22] = 'o' AND
	                    #arrRecord[23] = 'n' AND
	                    #arrRecord[24] = ' ' AND
	                    #arrRecord[25] = '1' THEN
	                    
	                    #iStep := 8; (*Action performed*)
	                ELSE
	                    #nTempErrorCode := 16#0000_0016; (*Error: Invalid device answer*)
	                END_IF;
	            ELSE
	                IF #arrRecord[0] = 's' AND
	                    #arrRecord[1] = 'A' AND
	                    #arrRecord[2] = 'N' AND
	                    #arrRecord[11] = 'o' AND
	                    #arrRecord[12] = 'n' AND
	                    #arrRecord[13] = ' ' AND
	                    #arrRecord[14] = '1' THEN
	                    
	                    #iStep := 8; (*Action performed*)
	                ELSE
	                    #nTempErrorCode := 16#0000_0016; (*Error: Invalid device answer*)
	                END_IF;
	            END_IF;
	            
	            (*Check "Trigger Off" response*)
	        1:
	            IF #bCanActive THEN
	                IF #arrRecord[0] = 's' AND
	                    #arrRecord[12] = 'A' AND
	                    #arrRecord[13] = 'N' AND
	                    #arrRecord[22] = 'o' AND
	                    #arrRecord[23] = 'f' AND
	                    #arrRecord[24] = 'f' AND
	                    #arrRecord[25] = ' ' AND
	                    #arrRecord[26] = '1' THEN
	                    
	                    #iStep := 8; (*Action performed*)
	                ELSE
	                    #nTempErrorCode := 16#0000_0016; (*Error: Invalid device answer*)
	                END_IF;
	            ELSE
	                IF #arrRecord[0] = 's' AND
	                    #arrRecord[1] = 'A' AND
	                    #arrRecord[2] = 'N' AND
	                    #arrRecord[11] = 'o' AND
	                    #arrRecord[12] = 'f' AND
	                    #arrRecord[13] = 'f' AND
	                    #arrRecord[14] = ' ' AND
	                    #arrRecord[15] = '1' THEN
	                    
	                    #iStep := 8; (*Action performed*)
	                ELSE
	                    #nTempErrorCode := 16#0000_0016; (*Error: Invalid device answer*)
	                END_IF;
	            END_IF;
	            
	            (*Check "Matchcode" response*)
	        2:
	            IF #bCanActive THEN
	                IF NOT (#arrRecord[0] = 's' AND
	                    #arrRecord[12] = 'A' AND
	                    #arrRecord[13] = 'N' AND
	                    #arrRecord[27] = 'o' AND
	                    #arrRecord[28] = 'd' AND
	                    #arrRecord[29] = 'e' AND
	                    #arrRecord[30] = ' ' AND
	                    #arrRecord[31] = '1') THEN
	                    
	                    #nTempErrorCode := 16#0000_0016; (*Error: Invalid device answer*)
	                END_IF;
	            ELSE
	                IF NOT (#arrRecord[0] = 's' AND
	                    #arrRecord[1] = 'A' AND
	                    #arrRecord[2] = 'N' AND
	                    #arrRecord[16] = 'o' AND
	                    #arrRecord[17] = 'd' AND
	                    #arrRecord[18] = 'e' AND
	                    #arrRecord[19] = ' ' AND
	                    #arrRecord[20] = '1') THEN
	                    
	                    #nTempErrorCode := 16#0000_0016; (*Error: Invalid device answer*)
	                END_IF;
	            END_IF;
	            
	            IF #nTempErrorCode = 0 THEN
	                #iCommandIndex := 11; (*Logout*)
	                #iStep := 4;         (*Create command*)
	            END_IF;
	            
	            (*Check "Save Permanent" response*)
	        3:
	            IF #bCanActive THEN
	                IF NOT (#arrRecord[0] = 's' AND
	                    #arrRecord[12] = 'A' AND
	                    #arrRecord[13] = 'N' AND
	                    #arrRecord[23] = 'a' AND
	                    #arrRecord[24] = 'l' AND
	                    #arrRecord[25] = 'l' AND
	                    #arrRecord[26] = ' ' AND
	                    #arrRecord[27] = '1') THEN
	                    
	                    #nTempErrorCode := 16#0000_0016; (*Error: Invalid device answer*)
	                END_IF;
	            ELSE
	                IF NOT (#arrRecord[0] = 's' AND
	                    #arrRecord[1] = 'A' AND
	                    #arrRecord[2] = 'N' AND
	                    #arrRecord[12] = 'a' AND
	                    #arrRecord[13] = 'l' AND
	                    #arrRecord[14] = 'l' AND
	                    #arrRecord[15] = ' ' AND
	                    #arrRecord[16] = '1') THEN
	                    
	                    #nTempErrorCode := 16#0000_0016; (*Error: Invalid device answer*)
	                END_IF;
	            END_IF;
	            
	            IF #nTempErrorCode = 0 THEN
	                #iCommandIndex := 11; (*Logout*)
	                #iStep := 4;         (*Create command*)
	            END_IF;
	            
	            (*Check "Communication Test" response*)
	        4:
	            IF #bCanActive THEN
	                IF #arrRecord[0] = 's' AND
	                    #arrRecord[12] = 'R' AND
	                    #arrRecord[13] = 'A' AND
	                    #arrRecord[14] = ' ' THEN
	                    
	                    #iStep := 8; (*Action performed*)
	                ELSE
	                    #nTempErrorCode := 16#0000_0016; (*Error: Invalid device answer*)
	                END_IF;
	            ELSE
	                IF #arrRecord[0] = 's' AND
	                    #arrRecord[1] = 'R' AND
	                    #arrRecord[2] = 'A' AND
	                    #arrRecord[3] = ' ' THEN
	                    
	                    #iStep := 8; (*Action performed*)
	                ELSE
	                    #nTempErrorCode := 16#0000_0016; (*Error: Invalid device answer*)
	                END_IF;
	            END_IF;
	            
	            (*Check "Free command" response*)
	        5:
	            IF #fbCCom.ReqLength <= MAX_LEN(#Data.FreeCommand.sResult) THEN
	                Chars_TO_Strg(Chars := #arrRecord,
	                              pChars := 0,
	                              Cnt := INT_TO_UINT(#fbCCom.ReqLength),
	                              Strg => #Data.FreeCommand.sResult);
	                #iStep := 8; (*Action performed*)
	            ELSE
	                #nTempErrorCode := 16#0000_0021; (*Error: Free command result > Result string*)
	            END_IF;
	            
	            (*Check "Login" response*)
	        10:
	            IF #bCanActive THEN
	                IF NOT (#arrRecord[0] = 's' AND
	                    #arrRecord[12] = 'A' AND
	                    #arrRecord[13] = 'N' AND
	                    #arrRecord[24] = 'M' AND
	                    #arrRecord[25] = 'o' AND
	                    #arrRecord[26] = 'd' AND
	                    #arrRecord[27] = 'e' AND
	                    #arrRecord[28] = ' ' AND
	                    #arrRecord[29] = '1') THEN
	                    
	                    #nTempErrorCode := 16#0000_0016; (*Error: Invalid device answer*)
	                END_IF;
	            ELSE
	                IF NOT (#arrRecord[0] = 's' AND
	                    #arrRecord[1] = 'A' AND
	                    #arrRecord[2] = 'N' AND
	                    #arrRecord[13] = 'M' AND
	                    #arrRecord[14] = 'o' AND
	                    #arrRecord[15] = 'd' AND
	                    #arrRecord[16] = 'e' AND
	                    #arrRecord[17] = ' ' AND
	                    #arrRecord[18] = '1') THEN
	                    
	                    #nTempErrorCode := 16#0000_0016; (*Error: Invalid device answer*)
	                END_IF;
	            END_IF;
	            
	            IF #nTempErrorCode = 0 THEN
	                IF #arrSelection[2] THEN
	                    #iCommandIndex := 2; (*Matchcode*)
	                    #iStep := 4;         (*Create command*)
	                ELSIF #arrSelection[3] THEN
	                    #iCommandIndex := 3; (*Save permanent*)
	                    #iStep := 4;         (*Create command*)
	                END_IF;
	                #bDeviceState := true; (*Edit-Mode active*)
	            END_IF;
	            
	            (*Check "Logout" response*)
	        11:
	            IF #bCanActive THEN
	                IF #arrRecord[0] = 's' AND
	                    #arrRecord[12] = 'A' AND
	                    #arrRecord[13] = 'N' AND
	                    #arrRecord[14] = ' ' AND
	                    #arrRecord[15] = 'R' AND
	                    #arrRecord[16] = 'u' AND
	                    #arrRecord[17] = 'n' AND
	                    #arrRecord[18] = ' ' AND
	                    #arrRecord[19] = '1' THEN
	                    
	                    #bDeviceState := false; (*Run-Mode active*)
	                    #iStep := 8; (*Action performed*)
	                ELSE
	                    #nTempErrorCode := 16#0000_0016; (*Error: Invalid device answer*)
	                END_IF;
	            ELSE
	                IF #arrRecord[0] = 's' AND
	                    #arrRecord[1] = 'A' AND
	                    #arrRecord[2] = 'N' AND
	                    #arrRecord[3] = ' ' AND
	                    #arrRecord[4] = 'R' AND
	                    #arrRecord[5] = 'u' AND
	                    #arrRecord[6] = 'n' AND
	                    #arrRecord[7] = ' ' AND
	                    #arrRecord[8] = '1' THEN
	                    
	                    #bDeviceState := false; (*Run-Mode active*)
	                    #iStep := 8; (*Action performed*)
	                ELSE
	                    #nTempErrorCode := 16#0000_0016; (*Error: Invalid device answer*)
	                END_IF;
	            END_IF;
	    END_CASE;
	END_IF;
	
	
	(*================================ ACTION PERFORMED (STEP 8) ===============================*)
	IF #iStep = 8 THEN
	    IF #bEnforceLogout THEN
	        #nTempErrorCode := #nLogoutErrorCode;
	    ELSE
	        #ReqDone := true;
	        #ReqBusy := false;
	        #bReqBusyMem := false;
	        #iStep := 0;
	    END_IF;
	END_IF;
	
	
	(*====================================== COMMUNICATION =====================================*)
	#fbCCom(HWInputIdent := #HWInputIdent,
	        HWInputLength := #HWInputLength,
	        HWOutputIdent := #HWOutputIdent,
	        HWOutputLength := #HWOutputLength,
	        TOut := #TOut + T#1s,
	        CommandLength := #iCommandLength,
	        arrCommand := #arrCommand,
	        arrRecord := #arrRecord);
	
	(*Reset the request flag every cycle*)
	#fbCCom.Req := false;
	
	(*Read result error*)
	IF #fbCCom.RdLength < 0 AND #fbCCom.RdDone THEN
	    #Data.ReadingResult.iLength := -1; (*Error: Reading result longer than record array*)
	    FOR #iTemp1 := 1 TO UINT_TO_INT(#iReadingResultSize) DO
	        #Data.ReadingResult.arrResult[#iTemp1] := 16#00;
	    END_FOR;
	    
	(*Handling of the reading result*)
	ELSIF #fbCCom.RdDone THEN
	    IF #fbCCom.RdLength > #iReadingResultSize THEN
	        #Data.ReadingResult.iLength := -1; (*Error: Reading result longer than reading result array*)
	        FOR #iTemp1 := 1 TO UINT_TO_INT(#iReadingResultSize) DO
	            #Data.ReadingResult.arrResult[#iTemp1] := 16#00;
	        END_FOR;
	    ELSE
	        MOVE_BLK(IN := #arrRecord[0],
	                 COUNT := INT_TO_UINT(#fbCCom.RdLength),
	                 OUT => #Data.ReadingResult.arrResult[1]);
	        IF (#Data.ReadingResult.iCounter >= 255) THEN
	            #Data.ReadingResult.iCounter := 0;
	        ELSE
	            #Data.ReadingResult.iCounter := #Data.ReadingResult.iCounter + 1;
	        END_IF;
	        #Data.ReadingResult.iLength := #fbCCom.RdLength;
	        #RdDone := true;
	    END_IF;
	END_IF;
END_FUNCTION_BLOCK

TYPE "UDT_Message"
TITLE = UDT_Message
VERSION : 0.1
//User-defined structure of the message characters array.
   STRUCT
      Character : Array[0..499] of Char;   // Message character
   END_STRUCT;

END_TYPE

TYPE "UDT_HMMessageHeader"
TITLE = UDT_H&MMessage
VERSION : 0.1
//User-defined structure of H&M message data.
   STRUCT
      STX { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Char;
      PLCID : String[4];   // Integer that globally identifies the connection
      SequenceNumber : String[8];   // Padded with leading zeros (8 characters total)
      MessageHeader : String[15];   // Message type defined by header
   END_STRUCT;

END_TYPE

FUNCTION "FC_BitAllocation" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      ix_Bit0 : Bool;
      ix_Bit1 : Bool;
      ix_Bit2 : Bool;
      ix_Bit3 : Bool;
      ix_Bit4 : Bool;
      ix_Bit5 : Bool;
      ix_Bit6 : Bool;
      ix_Bit7 : Bool;
      ix_Bit8 : Bool;
      ix_Bit9 : Bool;
      ix_Bit10 : Bool;
      ix_Bit11 : Bool;
      ix_Bit12 : Bool;
      ix_Bit13 : Bool;
      ix_Bit14 : Bool;
      ix_Bit15 : Bool;
      ix_Bit16 : Bool;
      ix_Bit17 : Bool;
      ix_Bit18 : Bool;
      ix_Bit19 : Bool;
      ix_Bit20 : Bool;
      ix_Bit21 : Bool;
      ix_Bit22 : Bool;
      ix_Bit23 : Bool;
      ix_Bit24 : Bool;
      ix_Bit25 : Bool;
      ix_Bit26 : Bool;
      ix_Bit27 : Bool;
      ix_Bit28 : Bool;
      ix_Bit29 : Bool;
      ix_Bit30 : Bool;
      ix_Bit31 : Bool;
   END_VAR

   VAR_OUTPUT 
      qdw_Dword : DWord;
   END_VAR


BEGIN
	#qdw_Dword.%X0 := #ix_Bit0;
	#qdw_Dword.%X1 := #ix_Bit1;
	#qdw_Dword.%X2 := #ix_Bit2;
	#qdw_Dword.%X3 := #ix_Bit3;
	#qdw_Dword.%X4 := #ix_Bit4;
	#qdw_Dword.%X5 := #ix_Bit5;
	#qdw_Dword.%X6 := #ix_Bit6;
	#qdw_Dword.%X7 := #ix_Bit7;
	#qdw_Dword.%X8 := #ix_Bit8;
	#qdw_Dword.%X9 := #ix_Bit9;
	#qdw_Dword.%X10 := #ix_Bit10;
	#qdw_Dword.%X11 := #ix_Bit11;
	#qdw_Dword.%X12 := #ix_Bit12;
	#qdw_Dword.%X13 := #ix_Bit13;
	#qdw_Dword.%X14 := #ix_Bit14;
	#qdw_Dword.%X15 := #ix_Bit15;
	#qdw_Dword.%X16 := #ix_Bit16;
	#qdw_Dword.%X17 := #ix_Bit17;
	#qdw_Dword.%X18 := #ix_Bit18;
	#qdw_Dword.%X19 := #ix_Bit19;
	#qdw_Dword.%X20 := #ix_Bit20;
	#qdw_Dword.%X21 := #ix_Bit21;
	#qdw_Dword.%X22 := #ix_Bit22;
	#qdw_Dword.%X23 := #ix_Bit23;
	#qdw_Dword.%X24 := #ix_Bit24;
	#qdw_Dword.%X25 := #ix_Bit25;
	#qdw_Dword.%X26 := #ix_Bit26;
	#qdw_Dword.%X27 := #ix_Bit27;
	#qdw_Dword.%X28 := #ix_Bit28;
	#qdw_Dword.%X29 := #ix_Bit29;
	#qdw_Dword.%X30 := #ix_Bit30;
	#qdw_Dword.%X31 := #ix_Bit31;
	
END_FUNCTION

TYPE "UDT_DataLogic_OUT"
VERSION : 0.1
   STRUCT
      "Unused_0.0" : Bool;   // Unused
      "Unused_0.1" : Bool;   // Unused
      "Unused_0.2" : Bool;   // Unused
      "Unused_0.3" : Bool;   // Unused
      "Unused_0.4" : Bool;   // Unused
      "Unused_0.5" : Bool;   // Unused
      "Unused_0.6" : Bool;   // Unused
      BladeTrigger : Bool;   // Camera input for trigger
      Unused_1 : Byte;   // Unused
      UnusedBytes : Array[0..14] of Byte;   // Unused
   END_STRUCT;

END_TYPE

TYPE "UDT_StatisticsTC36"
VERSION : 0.1
//Two direction, motor, Tracking, popup, pos. Switch
   STRUCT
      RightAngledTransfer : "UDT_RATStatistics";   // Right angled transfer Statistics
      MCO_M01 : "UDT_VfdStatistics";   // MCO Statistics
   END_STRUCT;

END_TYPE

FUNCTION "FC_WriteGIN" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 31
// END_ATTRIBUTES
   VAR_INPUT 
      ii_GIN : Int;   //    GIN number
      ii_PositionToWrite : Int;   //    Position in tracking array where to start writing GIN
      ii_NumberOfPositions : Int;   //    Number of positions to be written
      ix_Direction : Bool;   //    TRUE when positions in positive direction have to be written
   END_VAR

   VAR_IN_OUT 
      iqa_TrackingData : Array[*] of Int;   //    Tracking data
   END_VAR

   VAR_TEMP 
      ti_LCWritePosition : Int;   //    Loop counter
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	27/02/2020  | 3.1       | L.Klar        | first release MHSE TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – GIN write
	    
	    // Depending on the direction, a GIN is written into a specific number of tracking array positions.
	    #ti_LCWritePosition := 0;
	    
	    IF #ix_Direction
	    THEN
	        FOR #ti_LCWritePosition := #ii_PositionToWrite TO #ii_PositionToWrite + #ii_NumberOfPositions - 1 BY 1 DO
	            #iqa_TrackingData[#ti_LCWritePosition] := #ii_GIN;
	        END_FOR;
	    ELSE
	        FOR #ti_LCWritePosition := #ii_PositionToWrite TO #ii_PositionToWrite - #ii_NumberOfPositions + 1 BY -1 DO
	            #iqa_TrackingData[#ti_LCWritePosition] := #ii_GIN;
	        END_FOR;
	    END_IF;
	    
	END_REGION
END_FUNCTION

TYPE "UDT_VfdNordPO"
TITLE = UDT_VfdNordPO
VERSION : 0.1
//User-defined structure of VFD Nord output telegram.
   STRUCT
      STW : Struct   // Control Word
         "StartFunction408.11" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Bus bit 8 of control word is set. P480
         "StartFunction408.12" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Bus bit 8 of control word is set. P480
         ControlDataValid { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = The bus master trasnfers valid process data. 0 = The transmitted process data are invalid
         RotationRightOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Switch on rotation right
         RotationLeftOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Switch on rotation left
         Reserved { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved from NORD
         ParameterSetBit0 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activates parameter set
         ParameterSetBit1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activates parameter set
         ReadyForOperation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Set the frequency inverter to standby. 0=Reverse with brake ramp
         DisableVoltage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0 = Switch off the frequency inverter output voltage. 1 = Cancel "Disable voltage"
         EmergencyStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0 = Emergency stop with programmed estop time. Not Fail Safe Estop. 1 = Cancel condition "Emergency stop"
         EnableOperation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Enable output voltage acceleration to setpoint. 0 = Block voltage, switch off output voltage
         EnablePulsles { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Enable acceleration encoder. 0 = Acceleraton encoder is set to zero
         EnableRamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Enable setpoint on acceleration encoder. 0 = Freeze the setpoint provided by the acceleration encoder
         EnableSetpoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Activate the selected setpoint on the acceleration encoder. 0= Set the selected setpoint on the acceleration encoder to 0
         Acknowledge { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0-->1 = Inactive errors are acknowledged
      END_STRUCT;
      FrequencySetPoint : Int;   // Frequency HZ SetPoint to VFD 100%=4000HEX /16384 DEC . 0% = 0000HEX / 0 DEC Normalization with P105
      RampTimeSetPoint : Int;   // Ramp time to VFD [Range 0..200%][100% = 4000HEX /16384DEC = 10sec]
   END_STRUCT;

END_TYPE

TYPE "UDT_AixPlcFullOut"
VERSION : 0.1
   STRUCT
      ConveyStopControl { ExternalVisible := 'False'} : Word;   // Writing '1' causes the Stop group to go into STOP state . Transition 0 - 2 is needed to clear the Stop
      LeftMotorAsDIO { ExternalVisible := 'False'} : Struct   // Use the Left M8 motor port as digital IO
         Bit08 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit09 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit10 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit11 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit12 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit13 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit14 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         EnableDIO { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Set bit to enable Left motor M8 port Digital IO mode
         Bit00 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         EnergizeM8Pin4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Energize motor port M8 PIN 4
         EnergizeM8Pin3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Energize motor port M8 PIN 3
         Bit03 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit04 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit05 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit06 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit07 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
      END_STRUCT;
      RightMotorAsDIO { ExternalVisible := 'False'} : Struct   // Use the Right M8 motor port as digital IO
         Bit08 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit09 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit10 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit11 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit12 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit13 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit14 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         EnableDIO { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Set bit to enable Left motor M8 port Digital IO mode
         EnergizeM8Pin2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Energize motor port M8 PIN 2
         Bit01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         EnergizeM8Pin3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Energize motor port M8 PIN 3
         Bit03 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit04 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit05 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit06 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit07 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
      END_STRUCT;
      SensorPortsDO { ExternalVisible := 'False'} : Struct   // The Sensor ports PIN2 as digital outputs
         Bit08 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit09 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit10 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit11 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit12 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit13 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit14 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit15 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         EnergizeLeftPortPin2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Set to turn on Left Port Pin2
         EnergizeRightPortPin2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Set to turn on Right Port Pin2
         Bit02 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit03 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit04 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         EnableLeftPortPin2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Set to enable, reset for Pin2  to be input
         EnableRightPortPin2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Set to enable, reset for Pin2  to be input
         Bit07 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
      END_STRUCT;
      LeftMotorControl { ExternalVisible := 'False'} : Struct   // Run/Stop and Direction control of the Left motor
         MotorDirection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0 = Configured direction /1 = opposite to configured direction
         Bit09 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit10 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit11 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit12 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit13 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit14 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit15 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Run { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Run = 1 / Stop = 0
         Bit01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit02 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit03 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit04 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit05 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit06 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit07 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
      END_STRUCT;
      LeftSetMotorBrakeMode { ExternalVisible := 'False'} : Word;   // Set Left motor Brake Mode.0 = ignore 1 = "Normal" / 2 = "Free" / 3 ="Servo brake"
      LeftSetMotorSlaveMode { ExternalVisible := 'False'} : Word;   // 0 = ignore  1=Off, Left Independant  2=On, Left Mirror Right   3=On, Left Opposite Right direction
      RightMotorControl { ExternalVisible := 'False'} : Struct   // Run/Stop and Direction control of the Right motor
         MotorDirection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0 = Configured direction /1 = opposite to configured direction
         Bit09 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit10 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit11 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit12 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit13 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit14 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit15 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Run { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Run = 1 / Stop = 0
         Bit01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit02 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit03 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit04 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit05 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit06 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit07 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
      END_STRUCT;
      RightSetMotorBrakeMode { ExternalVisible := 'False'} : Word;   // Set Right motor Brake Mode.0 = ignore 1 = "Normal" / 2 = "Free" / 3 ="Servo brake"
      RightSetMotorSlaveMode { ExternalVisible := 'False'} : Word;   // 0 = ignore 1=Off, Right Independant  2=On, Right Mirror Right   3=On, Right Opposite Right direction
      LeftSetMotorSpeed { ExternalVisible := 'False'} : Int;   // Set reference speed for Left motor in mm/s (or 1/10 of an RPM for PGD)
      RightSetMotorSpeed { ExternalVisible := 'False'} : Int;   // Set reference speed for Right motor mm/s  (or 1/10 of an RPM for PGD)
      LeftSetMotorAccel { ExternalVisible := 'False'} : Int;   // Set acceleration distance in mm for Left motor (or pulses for PGD)
      LeftSetMotorDeccel { ExternalVisible := 'False'} : Int;   // Set deceleration distance in mm for Left motor (or pulses for PGD)
      RightSetMotorAccel { ExternalVisible := 'False'} : Int;   // Set acceleration distance in mm for Right motor (or pulses for PGD)
      RightSetMotorDeccel { ExternalVisible := 'False'} : Int;   // Set deceleration distance in mm for Right motor (or pulses for PGD)
      ClearMotorError { ExternalVisible := 'False'} : Word;   // Write '1' to clear motor error, wait 500 msec, then write '0' return to operation
      SendStatusToDownstream { ExternalVisible := 'False'} : Word;   // Write '4' or '5' to signal downstream ConveyLinx module in ZPA mode to wake up
      SendStatusToUpstream { ExternalVisible := 'False'} : Word;   // Write '5' to signal upstream ConveyLinx module in ZPA mode to accumulate, write '1' to signal OK to receive
      SensorPolarity { ExternalVisible := 'False'} : Struct   // Set logic polarity for Sensor Port's PIN2 and PIN4
         Bit08 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit09 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit10 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit11 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit12 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit13 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit14 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit15 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Left_Pin2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Set to invert, reset for normal
         Bit01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Right_Pin2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Set to invert, reset for normal
         Bit03 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Left_Pin4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Set to invert, reset for normal
         Bit05 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Right_Pin4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Set to invert, reset for normal
         Bit07 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
      END_STRUCT;
      TrackingToDownstream { ExternalVisible := 'False'} : DWord;   // Write Tracking data to be captured by downstream ZPA mode ConveyLinx
      Index22 { ExternalVisible := 'False'} : Word;   // Reserved
      ServoControlDistanceLeft { ExternalVisible := 'False'} : Int;   // Position from 0 in mm for Left motor to move on next command
      ServoControlCommandLeft { ExternalVisible := 'False'} : Word;   // Left motor servo command
      ServoControlDistanceRight { ExternalVisible := 'False'} : Int;   // New position from 0 in mm for Right motor to move on next command
      ServoControlCommandRight { ExternalVisible := 'False'} : Word;   // Right motor servo command
      Future { ExternalVisible := 'False'} : Array[27..31] of Int;   // Reserved
   END_STRUCT;

END_TYPE

TYPE "UDT_RATPositioning"
VERSION : 0.1
   STRUCT
      Lower { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Roller part
         StartPositionA { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Start position detected by OB30
         StartPositionB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         EndPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // End position defined by RAT FB
         Start { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start command set by RAT FB
         Done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // MCO finish positioning
         ResetPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         PositionRequired { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      END_STRUCT;
      Upper { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // UBT part
         StartPositionC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Start position detected by OB30
         StartPositionD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         EndPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // End position defined by RAT FB
         Start { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start command set by RAT FB
         Done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // MCO finish positioning
         ResetPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         PositionRequired { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_ValveInterface"
TITLE = UDT_ValveInterface
VERSION : 0.1
//UDT valve interface between modules
   STRUCT
      Open { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Interface command valve Open / Extend
      Close { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Interface command valve Close / Retract
      IsOpened { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Valve feedback opened / extended
      IsClosed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Valve feedback closed / retracted
      Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Valve error
   END_STRUCT;

END_TYPE

FUNCTION "FC_Fifo" : Void
TITLE = FC_Fifo
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 17
// END_ATTRIBUTES
//Function for controlling FIFO register.
   VAR_INPUT 
      ic_Mode : Char;   // Mode selector: "W" - Write; "R" - Read; "C" - Clear (Reset) "S" - Status
   END_VAR

   VAR_OUTPUT 
      qUDT_Status : "UDT_FifoStatus";   // FIFO status structure
      qx_Error : Bool;   // Collective error output
      qx_Warning : Bool;   // Collective warning output
   END_VAR

   VAR_IN_OUT 
      iqv_Data : Variant;   // Data
      iqUDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqv_DataBuffer : Variant;   // FIFO data buffer
   END_VAR

   VAR_TEMP 
      tUDT_Status : "UDT_FifoStatus";   // Status structure
      ti_MoveBLKErrorCode : Int;   // Move_BLK_Variant function return
      tx_HeaderValid : Bool;   // Header valid
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	14/06/2019  | 0.2       | A.Nowak       | Replacement of instruction if for direct write into variable - Region 3 , 4.1 , 4.2 , 4.3 , 4.4 , 8.1  , 8.2 
	17/07/2019  | 0.3       | L.Klar        | Status handling changed
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	23/08/2019  | 2.1       | K.Pokorski    | Comments corrected
	27/08/2019  | 2.2       | M.Kurpiers    | Comments adjusted
	27/09/2019  | 2.3       | K.Pokorski    | Variant input included
	01/10/2019  | 2.4       | A.Nowak       | Correct comments and rename regions
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – Diagnostic bits initialization
	    
	    // Clear FIFO statuses
	    #tUDT_Status.FifoFull := FALSE;
	    #tUDT_Status.FifoPreFull := FALSE;
	    
	END_REGION
	
	REGION 2 – Array's information
	    
	    // If buffer elements type is invalid, set the error 
	    #tUDT_Status.InvalidDataType := NOT (TypeOf(#iqv_Data) = TypeOfElements(#iqv_DataBuffer));
	    
	END_REGION
	
	REGION 3 – Mode validation
	    
	    // Set the mode invalid if selected mode isn't one of the following: W- Write, R - Read, C - Clear, S - Status
	    #tUDT_Status.InvalidMode := #ic_Mode <> 'W'
	    AND #ic_Mode <> 'R'
	    AND #ic_Mode <> 'C'
	    AND #ic_Mode <> 'S';
	    
	END_REGION
	
	REGION 4 – The header settings checking
	    
	    // The correct mode has been selected and data type is valid
	    IF (NOT #tUDT_Status.InvalidMode
	        AND NOT #tUDT_Status.InvalidDataType)
	    THEN
	        
	        REGION 4.1 – The number of maximum FIFO entries validation 
	            
	            // Write the number of array's elements to FIFO header
	            #iqUDT_FifoHeader.MaxNrOfEntries := "FC_GetNrOfArrayEl"(#iqv_DataBuffer);
	            
	            // Set the invalid maximum number of entries error 
	            #tUDT_Status.InvalidMaxNrOfEntries := #iqUDT_FifoHeader.MaxNrOfEntries <= 0;
	            
	        END_REGION
	        
	        REGION 4.2 – The number of total FIFO entries validation
	            
	            // Set the invalid total number of entries error 
	            #tUDT_Status.InvalidTotalEntriesStored := #iqUDT_FifoHeader.TotalEntriesStored < 0        // The total number of entries is lower than 0
	            OR #iqUDT_FifoHeader.TotalEntriesStored > #iqUDT_FifoHeader.MaxNrOfEntries;               // The total number of entries is greater than the maximum number of entries
	            
	        END_REGION
	        
	        REGION 4.3 – The number of the next entry to write 
	            
	            // Set the invalid next entry to write
	            #tUDT_Status.InvalidNextEntryToWrite := #iqUDT_FifoHeader.NextEntryToWrite < 0            // The number of next entry to write is lower than 0  
	            OR #iqUDT_FifoHeader.NextEntryToWrite >= #iqUDT_FifoHeader.MaxNrOfEntries;                // The number of next entry to write is greater or equal to the maximum number of entries 
	            
	        END_REGION
	        
	        REGION 4.4 – The number of the next entry to read 
	            
	            // Set the invalid next entry to read
	            #tUDT_Status.InvalidNextEntryToRead := #iqUDT_FifoHeader.NextEntryToRead < 0              // The number of next entry to read is lower than 0 
	            OR #iqUDT_FifoHeader.NextEntryToRead >= #iqUDT_FifoHeader.MaxNrOfEntries;                 // The number of next entry to read is greater or equal to the maximum nr of entries 
	            
	        END_REGION
	        
	        REGION 4.5 – FIFO header validation summary
	            
	            // Create collective header error
	            #tx_HeaderValid := NOT #tUDT_Status.InvalidMaxNrOfEntries
	            AND NOT #tUDT_Status.InvalidTotalEntriesStored
	            AND NOT #tUDT_Status.InvalidNextEntryToWrite
	            AND NOT #tUDT_Status.InvalidNextEntryToRead;
	            
	        END_REGION
	        
	    END_IF;
	    
	END_REGION
	
	REGION 5 – Writing the data into the FIFO buffer
	    
	    IF (#ic_Mode = 'W'                                                                          // Write mode selected                                                               
	        AND #tx_HeaderValid                                                                     // FIFO header valid 
	        AND NOT #tUDT_Status.InvalidDataType)                                                  // Buffer data type valid
	    THEN
	        
	        
	        IF (#iqUDT_FifoHeader.TotalEntriesStored < #iqUDT_FifoHeader.MaxNrOfEntries)          // Checking total number of stored entries                
	        THEN
	            
	            // Move input data to FIFO data buffer  
	            #ti_MoveBLKErrorCode := MOVE_BLK_VARIANT(SRC := #iqv_Data,
	                                                     COUNT := 1,
	                                                     SRC_INDEX := 0,
	                                                     DEST_INDEX := #iqUDT_FifoHeader.NextEntryToWrite,
	                                                     DEST => #iqv_DataBuffer);
	            
	            // Increment the number of the next entry to write 
	            #iqUDT_FifoHeader.NextEntryToWrite += 1;
	            
	            // Increment the total number of stored entries 
	            #iqUDT_FifoHeader.TotalEntriesStored += 1;
	            
	            
	            IF (#iqUDT_FifoHeader.NextEntryToWrite >= #iqUDT_FifoHeader.MaxNrOfEntries)       // Check the number of the next entry to write                             
	            THEN
	                
	                #iqUDT_FifoHeader.NextEntryToWrite := 0;
	                
	            END_IF;
	            
	        ELSE
	            
	            #tUDT_Status.FifoFull := TRUE;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 6 – Reading the data from the FIFO data buffer
	    
	    IF (#ic_Mode = 'R'                                                                  // Read mode selected    
	        AND #tx_HeaderValid                                                             // FIFO header valid 
	        AND NOT #tUDT_Status.InvalidDataType)                                           // Buffer data type valid                                                
	    THEN
	        
	        IF (#iqUDT_FifoHeader.TotalEntriesStored > 0)                                   // Checking total number of stored entries                                                     
	        THEN
	            
	            // Move the FIFO data to the data output
	            #ti_MoveBLKErrorCode := MOVE_BLK_VARIANT(SRC := #iqv_DataBuffer,
	                                                     COUNT := 1,
	                                                     SRC_INDEX := #iqUDT_FifoHeader.NextEntryToRead,
	                                                     DEST_INDEX := 0,
	                                                     DEST => #iqv_Data);
	            
	            // Increment the number of the next entry to read
	            #iqUDT_FifoHeader.NextEntryToRead += 1;
	            
	            // Decrement the total number of stored entries
	            #iqUDT_FifoHeader.TotalEntriesStored -= 1;
	            
	            IF (#iqUDT_FifoHeader.NextEntryToRead >= #iqUDT_FifoHeader.MaxNrOfEntries)  // Check the number of the next entry to read                 
	            THEN
	                
	                #iqUDT_FifoHeader.NextEntryToRead := 0;
	                
	            END_IF;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 7 – Clearing the FIFO header
	    
	    IF (#ic_Mode = 'C'                      // Clear mode selected  
	        AND #tx_HeaderValid)                // FIFO header valid                         
	    THEN
	        
	        #iqUDT_FifoHeader.TotalEntriesStored := 0;
	        #iqUDT_FifoHeader.NextEntryToWrite := 0;
	        #iqUDT_FifoHeader.NextEntryToRead := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 8 – FIFO management status update
	    
	    IF (#tx_HeaderValid)                   // The header is valid                                     
	    THEN
	        
	        REGION 8.1 – FIFO Empty
	            
	            // Set the FIFO empty status bit
	            #iqUDT_FifoHeader.Status.Empty := #iqUDT_FifoHeader.TotalEntriesStored = 0;
	            
	        END_REGION
	        
	        REGION 8.2 – FIFO Full
	            
	            // Set the FIFO full status bit 
	            #iqUDT_FifoHeader.Status.Full := #iqUDT_FifoHeader.TotalEntriesStored = #iqUDT_FifoHeader.MaxNrOfEntries;
	            
	        END_REGION
	        
	        REGION 8.3 – FIFO Pre-full
	            
	            IF (#iqUDT_FifoHeader.TotalEntriesStored >= 0.9 * #iqUDT_FifoHeader.MaxNrOfEntries)       // Checking if the number of total stored entries is greater or equal to 90% of the max number of entries     
	            THEN
	                
	                // Set the FIFO pre-full status 
	                #iqUDT_FifoHeader.Status.Prefull := TRUE;
	                #tUDT_Status.FifoPreFull := TRUE;
	                
	            ELSE
	                
	                #iqUDT_FifoHeader.Status.Prefull := FALSE;
	                
	            END_IF;
	            
	        END_REGION
	        
	    END_IF;
	    
	END_REGION
	
	REGION 9 – Status
	    
	    REGION 9.1 – Common status update
	        
	        // Collective error output
	        #qx_Error := NOT #tx_HeaderValid
	        OR #tUDT_Status.InvalidMode
	        OR #tUDT_Status.FifoFull
	        OR #tUDT_Status.InvalidDataType;
	        
	        // Collective warning output              
	        #qx_Warning := #tUDT_Status.FifoPreFull;
	        
	    END_REGION
	    
	    REGION 9.2 – Status update
	        
	        // Update the outer status structure with internal status structure
	        #qUDT_Status := #tUDT_Status;
	        
	    END_REGION
	    
	END_REGION
END_FUNCTION

TYPE "UDT_VfdNordPI"
TITLE = UDT_VfdNordPI
VERSION : 0.1
//User-defined structure of VFD Nord input telegram.
   STRUCT
      ZSW : Struct   // Status word
         SetpointReached { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0 = Actual value does not corresponf to setpoint. 1 = Actual value matches the setpoint
         BusControlActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0 = Control on local device active. 1 = The master has beed requestd to take over control
         "StartFunction481.9" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Bus bit 10 of status word is set P481
         RotationRightIsOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = The FI output voltage has a RH rotation field
         RotationLeftIsOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = The FI output voltage has a LH rotation field
         "StartFunction481.10" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Bus bit 13 of status word is set P481
         ParameterSetBit0ON { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parameter set bit 0 status
         ParameterSetBit1ON { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parameter set bit 0 status
         ReadyToStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Initialisation completed, charging relay switched on, output voltage disabled
         ReadyForOperation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0 = No switch-on command present or fault. 1 = The inverted can start with the command "Enable operation"
         OperationEnabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = The output voltage is enabled; ramp of the frequency inverter up to the existing setpoint
         Fault : Bool := FALSE;   // 1 = Drive unit defective, not ready for operation
         VoltageEnabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0 = "Disable voltage" command present
         EmergencyStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0 = "Emergency stop" command present
         StartingDisabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = With the command "Standby" the FI goes into status "Ready to switch on"
         WarningActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Drive operation continues, no acknowledgement necessary
      END_STRUCT;
      ActualSpeed : Int;   // Actual calculated speed [rpm]. [Range  -200% ..200%][100%=4000HEX/ 16384DEC = P202 nominal speed]
      FaultCode : Int;   // Actual fault code
   END_STRUCT;

END_TYPE

DATA_BLOCK "DB_GINDefault"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
   VAR 
      GIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Array[1..20] of "UDT_GIN";   // GIN informations
   END_VAR


BEGIN

END_DATA_BLOCK

FUNCTION_BLOCK "FB_VfdNORDCommissioning"
TITLE = Block for parameterising NORD VFD
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 234
// END_ATTRIBUTES
   VAR_INPUT 
      ihw_HardwareID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_IO := 0;   // Device hardware ID
      iudt_MotorData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_MotorData";
      ir_ReferenceFrequency { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;
      ix_VFDReadyToRun { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Condition to start motor identyfication
   END_VAR

   VAR_OUTPUT 
      qi_HWAdress { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      qx_Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parametrisation in progress
      qx_Done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parametrisation done
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parametrisation error
      qx_24VCommissioningDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 24V commissioning done succesfully
   END_VAR

   VAR_IN_OUT 
      iqx_Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Input enable signal
   END_VAR

   VAR 
      sFB_ParaAcycRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_VfdNORDParaAcycRead";
      sFB_ParaAcycWrite { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_VfdNORDParaAcycWrite";
      sR_TRIG_Done {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_StartJob {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Bit for start trigger for rising edge
      sF_TRIG_CancelJob {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Bit for start trigger for falling edge
      sa_Parameter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Array[0..60] of "UDT_VfdNordParameter";   // Data of parameters
      sa_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Parametrization status
         StepNrError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // The number of the step in witch the error occurred
         ParameterNrError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // The number of the parameter in witch the error occurred
         StepNr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 0;   // Current step number
         ResponseValueError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Response value error
         WrongFormat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Wrong parameter format
         TimeExceeded { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Time has been exceeded
         NeedAck { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Need acknowledge signal (to cintinue parametrization)
         StepDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Step done
      END_STRUCT;
      si_StepTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_StepMax { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 0;   // Maximum step number
      sx_Start { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Signal to start of parameterization function SinaPara
      sx_Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parametrization in progress (busy)
      sx_Done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parametrization done
      sx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Main error signal
      sx_PreparedData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Step data prepared
      sx_ReadOrder { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Order to read paraeter with transition from 0 to 1
      sx_WriteOrder { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Order to write parameter with transition from 0 to 1
      sx_MaxStepCalculation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Maximum step calculated
   END_VAR
   VAR RETAIN
      sx_24VCommissioningDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 24V commissioning done succesfully
   END_VAR

   VAR_TEMP 
      ti_index : Int;   // Temporary array index
      ti_ControlMethod : Int;
      ti_EncoderCode : Int;
      ti_i : Int;   // Loop counter
      ti_BrakeReaction : Int;
   END_VAR

   VAR CONSTANT 
      ci_CFC_ClosedLoop : Int := 1;
      ci_CFC_OpenLoop : Int := 0;
      ci_EncoderRes512 : Int := 1;
      ci_EncoderRes1024 : Int := 3;
      ci_EncoderRes2048 : Int := 5;
      ci_EncoderRes4096 : Int := 6;
      ci_MaxStepTime : Int := 100;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	12/01/2020  | 0.1       | S.Theocharis  | Initial version TIA 15.1
	08/04/2021  | 0.2       | F.Baten       | New read/write blocks
	                                        | New motor parameter set ( most values not 32bit )
	                                        | PN device with onboard safety
	                                        | Reading and writing optimised
	27/01/2022  | 0.3       | K.Pokorski    | Add 24V and 400V commissionig status
	                                        | Fix VFD Output bug
	                                        | Initialize InUse status in all parameters
	                                        | Fix Motor identification
	                                        | Save parameters to External memory
	                                        | Delete saving F-parameters from sequence (not working and creating faults)
	                                        | Delete reading CRC code (reading old CRC code what can be confusing)
	21/04/2022  | 0.4       | K.Pokorski    | Delete motor identification
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	                                        
	*)
	
	REGION 1 - Start Job
	    
	    // Monitor rising trigger if is input enable signal
	    #sR_TRIG_StartJob(CLK := #iqx_Enable);
	    
	    IF (#sR_TRIG_StartJob.Q)
	    THEN
	        #sx_Start := TRUE;
	        #sx_Busy := TRUE;
	        #sx_Done := FALSE;
	        #sx_Error := FALSE;
	        #sx_PreparedData := FALSE;
	        #sx_MaxStepCalculation := FALSE;
	        #sa_Status.StepDone := FALSE;
	        #sa_Status.StepNrError := 0;
	        #sa_Status.ParameterNrError := 0;
	        #sa_Status.StepNr := 0;
	        #si_StepTime := 0;
	        #qi_HWAdress := 0;
	        
	        FOR #ti_i := 0 TO 60 DO
	            #sa_Parameter[#ti_i].InUse := FALSE;
	        END_FOR;
	        
	        
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Build Sequences in static memory
	    
	    IF #sR_TRIG_StartJob.Q THEN
	        //  IF NOT #sx_24VCommissioningDone THEN
	        REGION Step 01 - P523 Factory reset [0..3]           
	            #ti_index := 0;
	            #sa_Parameter[#ti_index].ParaNumber := 523;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := 1;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 02 - P003 Set supervisor code to access all parameters [0..9999]
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 3;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := 3;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 03 - P800 Set Operating mode Safety [0-1]
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 800;
	            #sa_Parameter[#ti_index].Index := 1;
	            #sa_Parameter[#ti_index].WriteValue := 1;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 04 - P800 Set Operating mode Safety [0-1]
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 800;
	            #sa_Parameter[#ti_index].Index := 2;
	            #sa_Parameter[#ti_index].WriteValue := 0;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 05 - P802 Set Enable safety channel [0-1]  Channel 1 on
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 802;
	            #sa_Parameter[#ti_index].Index := 1;
	            #sa_Parameter[#ti_index].WriteValue := 1;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 06 - P802 Set Enable safety channel [0-1]  Channel 2 on
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 802;
	            #sa_Parameter[#ti_index].Index := 2;
	            #sa_Parameter[#ti_index].WriteValue := 1;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 07 - P802 Set Enable safety channel [0-1]  Channel 3 on
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 802;
	            #sa_Parameter[#ti_index].Index := 3;
	            #sa_Parameter[#ti_index].WriteValue := 1;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 08 - P846 Read dipswitches 
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 846;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := 0;
	            #sa_Parameter[#ti_index].WriteAccess := FALSE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 09 - P120 Set extern control units [0-1]  Switch off 3 and 4
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 120;
	            #sa_Parameter[#ti_index].Index := 3;
	            #sa_Parameter[#ti_index].WriteValue := 0;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 10 - P120 Set extern control units [0-1]  Switch off 3 and 4
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 120;
	            #sa_Parameter[#ti_index].Index := 4;
	            #sa_Parameter[#ti_index].WriteValue := 0;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 11 - P202 Write motor nominal speed [150...24000]rpm
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 202;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := #iudt_MotorData.NominalSpeed;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 1; // Parameter set 1
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 12 - P203 Write motor nominal current [0.1 ...1000.0]A
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 203;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := (REAL_TO_DINT(#iudt_MotorData.NominalCurrent * 10));  // Value 55 = 5.5 Amps
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0; // Parameter set 1
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 13 - P204 Write motor nominal voltage [100 ... 800]V
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 204;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := #iudt_MotorData.NominalVoltage;
	            #sa_Parameter[#ti_index].WriteAccess := FALSE;
	            #sa_Parameter[#ti_index].ParaSet := 1; // Parameter set 1
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 14 - P205 Write motor nominal power 
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 205;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := (REAL_TO_DINT(#iudt_MotorData.NominalPower * 100));
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0; // Parameter set 1
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 15 - P206 Write motor cosPhi [0.50 ... 0.95]
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 206;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := REAL_TO_DINT(#iudt_MotorData.CosPhi * 100);
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0; // Parameter set 1
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 16 - P207 Connection Star / Delta [0=Star 1=Delta]
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 207;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := #iudt_MotorData.Connection;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0; // Parameter set 1
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 17 - P105 Write Maximum / Reference Frequency [0.1...400.0]Hz
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 105;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := REAL_TO_DINT(#ir_ReferenceFrequency * 10);
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0; // Parameter set 1
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 18 - P107 Brake reaction
	            IF #iudt_MotorData.BrakeConfig THEN
	                #ti_BrakeReaction := 20;
	            ELSE
	                #ti_BrakeReaction := 0;
	            END_IF;
	            
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 107;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := #ti_BrakeReaction;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0; // Parameter set 1
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 19 - P300 Mode [0..2]
	            //If an IE4 motor is operated in CFC closed loop mode , the slip error monitoring must be activated. P327<>0
	            IF #iudt_MotorData.EncoderResolution <> 0 THEN
	                #ti_ControlMethod := #ci_CFC_ClosedLoop; //CFC closed loop control. Speed control with encoder feedback
	            ELSE
	                #ti_ControlMethod := #ci_CFC_OpenLoop; //VFC open loop control. Speed control without encoder feedback
	            END_IF;
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 300;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := #ti_ControlMethod;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 1; // Parameter set 1
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 20 - P301 Encoder Resolution [0..17]
	            CASE #iudt_MotorData.EncoderResolution OF
	                512:
	                    #ti_EncoderCode := #ci_EncoderRes512;
	                1024:
	                    #ti_EncoderCode := #ci_EncoderRes1024;
	                2048:
	                    #ti_EncoderCode := #ci_EncoderRes2048;
	                4096:
	                    #ti_EncoderCode := #ci_EncoderRes4096;
	                ELSE
	                    #ti_EncoderCode := 6; //default value
	            END_CASE;
	            
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 301;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := #ti_EncoderCode;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 21 - P326 Encoder ratio [0.01 ... 100.0]
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 326;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := (1 * 100); //leave temporary the default 1.00;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 22 - P420[1] Digital inputs [0 ... 80] DI1
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 420;
	            #sa_Parameter[#ti_index].Index := 1;
	            #sa_Parameter[#ti_index].WriteValue := 0;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 23 - P420[2] Digital inputs [0 ... 80] DI2
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 420;
	            #sa_Parameter[#ti_index].Index := 2;
	            #sa_Parameter[#ti_index].WriteValue := 0;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 24 - P420[3] Digital inputs [0 ... 80] DI3
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 420;
	            #sa_Parameter[#ti_index].Index := 3;
	            #sa_Parameter[#ti_index].WriteValue := 0;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 25 - P426 Quick Stop time [0 ... 320.00] sec
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 426;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := 60;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 1; //paraset 1
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 26 - P509 Control word source [0..4]
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 509;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := 3; // System bus communication (PN)
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 27 - P543[1] Actual speed to actual value 1 [0..57]
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 543;
	            #sa_Parameter[#ti_index].Index := 1;
	            #sa_Parameter[#ti_index].WriteValue := 1; // 2 = Set Actual value 1 to actual speed
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 1; // Parameter set 1
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 28 - P543[2] Error code to actual value 2 [0..57]
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 543;
	            #sa_Parameter[#ti_index].Index := 2;
	            #sa_Parameter[#ti_index].WriteValue := 9; // 9 =  Set Actual value 2 to error code
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 1; // Parameter set 1
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 29 - P543[3] DIO status to actual value 3 [0..57]
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 543;
	            #sa_Parameter[#ti_index].Index := 3;
	            #sa_Parameter[#ti_index].WriteValue := 5; // 5 =  Set Actual value 3 to DIO status
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 1; // Parameter set 1
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 30 - P546[1] Frequency setpoint to setpoint 1 [0..36]
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 546;
	            #sa_Parameter[#ti_index].Index := 1;
	            #sa_Parameter[#ti_index].WriteValue := 1; // 5 =  Set setpoint 1 to frequency setpoint
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 1; // Parameter set 1
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 31 - P546[2] Ramp setpoint to setpoint 2 [0..36]
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 546;
	            #sa_Parameter[#ti_index].Index := 2;
	            #sa_Parameter[#ti_index].WriteValue := 15; // 15 =  Set setpoint 2 to ramp setpoint
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 1; // Parameter set 1
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 32 - P546[3] DO control to setpoint 3 [0..36]
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 546;
	            #sa_Parameter[#ti_index].Index := 3;
	            #sa_Parameter[#ti_index].WriteValue := 31; // 5 =  Set setpoint 3 to DIO
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 1; // Parameter set 1
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 33 - P434[3] DO Function [1..2]
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 434;
	            #sa_Parameter[#ti_index].Index := 1;
	            #sa_Parameter[#ti_index].WriteValue := 38;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 1; // Parameter set 1
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 34 - P560 Save [0..2]
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 560;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := 1; // 1= save RAM & EERPOM
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 35 - P550 Copy internal EEPROM to external EEPROM [0..3]
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 550;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := 2; // 2 = Copy internal to external EEPROM 
	            #sa_Parameter[#ti_index].WriteAccess := FALSE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	    END_IF;
	    
	    (* IF #ix_VFDReadyToRun AND #sx_24VCommissioningDone THEN
	         REGION Step 39 - P220 Measurement [0..2]
	             #ti_index := 0;
	             #sa_Parameter[#ti_index].ParaNumber := 220;
	             #sa_Parameter[#ti_index].Index := 0;
	             #sa_Parameter[#ti_index].WriteValue := 2; // 2 =  Motor identification
	             #sa_Parameter[#ti_index].WriteAccess := TRUE;
	             #sa_Parameter[#ti_index].ParaSet := 1;
	             #sa_Parameter[#ti_index].Format32 := FALSE;
	             #sa_Parameter[#ti_index].ActualValue := 0;
	             #sa_Parameter[#ti_index].InUse := TRUE;
	             #sa_Parameter[#ti_index].RamOnly := FALSE;
	         END_REGION
	         
	         REGION Step 40 - P220 Read if measurement started
	             #ti_index := #ti_index + 1;
	             #sa_Parameter[#ti_index].ParaNumber := 220;
	             #sa_Parameter[#ti_index].Index := 0;
	             #sa_Parameter[#ti_index].WriteValue := 0;
	             #sa_Parameter[#ti_index].WriteAccess := FALSE;
	             #sa_Parameter[#ti_index].ParaSet := 1;
	             #sa_Parameter[#ti_index].Format32 := FALSE;
	             #sa_Parameter[#ti_index].ActualValue := 0;
	             #sa_Parameter[#ti_index].InUse := TRUE;
	             #sa_Parameter[#ti_index].RamOnly := FALSE;
	         END_REGION
	         
	         REGION Step 41 - P220 Read if measurement finished
	             #ti_index := #ti_index + 1;
	             #sa_Parameter[#ti_index].ParaNumber := 220;
	             #sa_Parameter[#ti_index].Index := 0;
	             #sa_Parameter[#ti_index].WriteValue := 0;
	             #sa_Parameter[#ti_index].WriteAccess := FALSE;
	             #sa_Parameter[#ti_index].ParaSet := 1;
	             #sa_Parameter[#ti_index].Format32 := FALSE;
	             #sa_Parameter[#ti_index].ActualValue := 0;
	             #sa_Parameter[#ti_index].InUse := TRUE;
	             #sa_Parameter[#ti_index].RamOnly := FALSE;
	         END_REGION
	         
	         
	         REGION Step 42 - P560 Save [0..2] (Step 39 - without motor identification)
	             #ti_index := #ti_index + 1;
	             #sa_Parameter[#ti_index].ParaNumber := 560;
	             #sa_Parameter[#ti_index].Index := 0;
	             #sa_Parameter[#ti_index].WriteValue := 1; // 1= save RAM & EERPOM
	             #sa_Parameter[#ti_index].WriteAccess := TRUE;
	             #sa_Parameter[#ti_index].ParaSet := 0;
	             #sa_Parameter[#ti_index].Format32 := FALSE;
	             #sa_Parameter[#ti_index].ActualValue := 0;
	             #sa_Parameter[#ti_index].InUse := TRUE;
	             #sa_Parameter[#ti_index].RamOnly := FALSE;
	         END_REGION
	         
	         REGION Step 43 - P550 Copy internal EEPROM to external EEPROM [0..3] (Step 40 - without motor identification)
	             #ti_index := #ti_index + 1;
	             #sa_Parameter[#ti_index].ParaNumber := 550;
	             #sa_Parameter[#ti_index].Index := 0;
	             #sa_Parameter[#ti_index].WriteValue := 2; // 2 = Copy internal to external EEPROM 
	             #sa_Parameter[#ti_index].WriteAccess := FALSE;
	             #sa_Parameter[#ti_index].ParaSet := 0;
	             #sa_Parameter[#ti_index].Format32 := FALSE;
	             #sa_Parameter[#ti_index].ActualValue := 0;
	             #sa_Parameter[#ti_index].InUse := TRUE;
	             #sa_Parameter[#ti_index].RamOnly := FALSE;
	         END_REGION
	         #sx_MotorMeasurement := TRUE;
	         
	     END_IF; *)
	    
	    // END_IF;
	    
	END_REGION
	
	REGION 3 - Cancel job
	    
	    // Monitor falling trigger if is input enable signal
	    #sF_TRIG_CancelJob(CLK := #iqx_Enable);
	    
	    IF (#sF_TRIG_CancelJob.Q)
	    THEN
	        // IF parametrization is NOT done
	        IF (NOT #sx_Done)
	        THEN
	            
	            #sx_Error := TRUE;
	            #sx_ReadOrder := FALSE;
	            #sx_WriteOrder := FALSE;
	            #sFB_ParaAcycWrite.qx_Done := FALSE;
	            #sx_Start := FALSE;
	            #sx_Busy := FALSE;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Caclulaton used step in the sequence
	    // If maximum step is not calculated and input enable signal 
	    IF (NOT #sx_MaxStepCalculation
	        AND #iqx_Enable)
	    THEN
	        
	        // Create loop from maximum step number = 1 to 80
	        FOR #si_StepMax := 1 TO 80 DO
	            
	            IF (NOT #sa_Parameter[#si_StepMax].InUse)   // If step commissioning is not used in sequence
	            THEN
	                #sx_MaxStepCalculation := TRUE;
	                EXIT;
	            END_IF;
	        END_FOR;
	    END_IF;
	END_REGION
	
	REGION 5 - Prepare data
	    
	    IF (#sx_Start                                       // If occurs: signal to start of parametrization 
	        AND NOT #sx_PreparedData                        // And step data is not prepared 
	        AND NOT #sa_Status.StepDone                      // And parametrization is not done 
	        AND #iqx_Enable)                                // And input enable signal 
	    THEN
	        
	        #sx_WriteOrder := #sa_Parameter[#sa_Status.StepNr].WriteAccess;
	        #sx_ReadOrder := NOT #sa_Parameter[#sa_Status.StepNr].WriteAccess;
	        #sx_PreparedData := TRUE;
	        
	    END_IF;
	END_REGION
	
	REGION 6 - Call write parameter block
	    
	    IF #sx_WriteOrder AND #sx_PreparedData THEN
	        #sFB_ParaAcycWrite(HW_Identifier := #ihw_HardwareID,
	                           idi_Value := #sa_Parameter[#sa_Status.StepNr].WriteValue,
	                           ii_ParameterNumber := #sa_Parameter[#sa_Status.StepNr].ParaNumber,
	                           ii_ParameterIndex := #sa_Parameter[#sa_Status.StepNr].Index,
	                           ii_ParameterSet := #sa_Parameter[#sa_Status.StepNr].ParaSet,
	                           ix_Parameter32Bit := #sa_Parameter[#sa_Status.StepNr].Format32,
	                           ix_RAM_Only := #sa_Parameter[#sa_Status.StepNr].RamOnly,
	                           ix_Execute := NOT #sFB_ParaAcycWrite.qx_Done,
	                           qx_Done => #sFB_ParaAcycWrite.qx_Done,
	                           qx_Busy => #sFB_ParaAcycWrite.qx_Busy,
	                           qx_Error => #sFB_ParaAcycWrite.qx_Error,
	                           qdi_ValueRead => #sa_Parameter[#sa_Status.StepNr].ActualValue,
	                           qw_ErrorID => #sFB_ParaAcycWrite.qw_ErrorID);
	        
	        #sR_TRIG_Done(CLK := #sFB_ParaAcycWrite.qx_Done);
	    END_IF;
	END_REGION
	
	REGION 7 - Call read parameter block 
	    
	    IF #sx_ReadOrder AND #sx_PreparedData THEN
	        #sFB_ParaAcycRead(iHW_Identifier := #ihw_HardwareID,
	                          ix_Enable := TRUE,
	                          ii_Parameter_Number := #sa_Parameter[#sa_Status.StepNr].ParaNumber,
	                          ii_Parameter_Index := #sa_Parameter[#sa_Status.StepNr].Index,
	                          ii_Parameter_Set := #sa_Parameter[#sa_Status.StepNr].ParaSet,
	                          qx_Valid => #sFB_ParaAcycRead.qx_Valid,
	                          qx_Busy => #sFB_ParaAcycRead.qx_Busy,
	                          qx_Error => #sFB_ParaAcycRead.qx_Error,
	                          qw_Error_ID => #sFB_ParaAcycRead.qw_Error_ID,
	                          qdi_Value => #sFB_ParaAcycRead.qdi_Value);
	    END_IF;
	END_REGION
	
	REGION 8 - Status commissioning
	    
	    REGION 8.1 Step number error
	        
	        IF (#sx_WriteOrder AND #sFB_ParaAcycWrite.qx_Error)
	            OR
	            (#sx_ReadOrder AND #sFB_ParaAcycRead.qx_Error)
	            OR #sa_Status.TimeExceeded
	        THEN
	            #sx_Start := FALSE;
	            #sx_Error := TRUE;
	            #sx_Done := FALSE;
	            
	            #sx_WriteOrder := FALSE;
	            #sx_ReadOrder := False;
	            #sa_Status.StepNrError := #sa_Status.StepNr;
	        END_IF;
	    END_REGION
	    
	    
	    REGION 8.2 - Read done
	        
	        IF #sx_ReadOrder
	            AND NOT #sFB_ParaAcycRead.qx_Busy
	            AND NOT #sFB_ParaAcycRead.qx_Error
	            AND #sFB_ParaAcycRead.qx_Valid
	            
	        THEN
	            
	            #sa_Status.StepDone := TRUE;
	            #sx_ReadOrder := FALSE;
	            #sa_Parameter[#sa_Status.StepNr].ActualValue := DINT_TO_INT(#sFB_ParaAcycRead.qdi_Value);
	            
	            IF #sa_Parameter[#sa_Status.StepNr].ParaNumber = 846
	            THEN
	                #qi_HWAdress := DINT_TO_INT(#sFB_ParaAcycRead.qdi_Value);
	            END_IF;
	            
	        END_IF;
	    END_REGION
	    
	    
	    REGION 8.3 - Write done
	        
	        IF #sx_WriteOrder
	            AND NOT #sFB_ParaAcycWrite.qx_Error
	            AND #sR_TRIG_Done.Q
	        THEN
	            #sa_Status.StepDone := TRUE;
	            #sx_WriteOrder := FALSE;
	            #sFB_ParaAcycWrite.qx_Done := FALSE;
	        END_IF;
	    END_REGION
	    
	    REGION 8.4 - Step time watchdog
	        // the function is too long active
	        IF #iqx_Enable AND "DB_Memory"."OS_0.1sec"
	        THEN
	            #si_StepTime += 1;
	        END_IF;
	        IF (#si_StepTime > #ci_MaxStepTime)
	        THEN
	            #sa_Status.TimeExceeded := TRUE;
	        ELSE
	            #sa_Status.TimeExceeded := FALSE;
	        END_IF;
	    END_REGION
	END_REGION
	
	REGION 9 - Go to next step
	    
	    IF #iqx_Enable
	        AND #sa_Status.StepDone
	        AND "DB_Memory".OS_2sec
	    THEN
	        #sx_PreparedData := FALSE;
	        #sa_Status.StepDone := FALSE;
	        #sa_Status.StepNr += 1;
	        #si_StepTime := 0;
	    END_IF;
	END_REGION
	
	REGION 10 - Commissioning done
	    
	    IF (#si_StepMax <= #sa_Status.StepNr
	        AND #iqx_Enable)
	    THEN
	        #iqx_Enable := FALSE;
	        #sx_Done := TRUE;
	        #sx_Start := FALSE;
	        #sx_Busy := FALSE;
	        #sx_24VCommissioningDone := TRUE;
	        
	    END_IF;
	END_REGION
	
	REGION 11 - Write output
	    
	    #qx_Busy := #sx_Busy;
	    #qx_Done := #sx_Done;
	    #qx_Error := #sx_Error;
	    #qx_24VCommissioningDone := #sx_24VCommissioningDone;
	    
	END_REGION
	
	
END_FUNCTION_BLOCK

TYPE "UDT_CognexDM260_IN"
VERSION : 0.1
   STRUCT
      TriggerReady : Bool;   // Indicates when the device is ready to accept a new trigger. Bit is True when “Trigger Enable”is set and the device is ready to accept a new trigger.
      TriggerAck : Bool;   // Indicates that the DataMan has received a new Trigger. This bit remains True as long as the“Trigger” bit remains True (that is, it is interlocked with the Trigger bit).
      "Acquiring/Reserved??" : Bool;   // Reserved for future use.
      MissedAcq : Bool;   // Indicates that the DataMan was unable to successfully trigger an acquisition. Bit is cleared
      "Not used" : Bool;   // Reserved for future use.8-23
      "Not used_1" : Bool;   // Reserved for future use.8-23
      "Not used_2" : Bool;   // Reserved for future use.8-23
      "Not used_3" : Bool;   // Reserved for future use.8-23
      TriggerID : Byte;   // HIGHER BYTE ID value of the next trigger to be issued (16-bit integer). Used to match issued triggers withcorresponding result data received later. This same value is returned in ResultID of theresult data.
      "TriggerID 1" : Byte;   // LOWER BYTE ID value of the next trigger to be issued (16-bit integer). Used to match issued triggers withcorresponding result data received later. This same value is returned in ResultID of theresult data.
      BYTE_Decoding : Byte;   // Bit:0-Decode Complete, 1-Decode Complete, 2- Results Buffer Overrun, 3- Results Available, 4-6 Unused, 7 - General Fault
      "Train Code Ack" : Bool;   // Indicates that the “Train Code” operation is complete
      "Train Match String Ack" : Bool;   // Indicates that the “Train Match String” operation is complete
      "Train Focus Ack" : Bool;   // Indicates that the “Train Focus” operation is complete
      "Train Brightness Ack" : Bool;   // Indicates that the “Train Brightness” operation is complete
      "Untrain Ack" : Bool;   // Indicates that the “Untrain” operation is complete
      Reserved : Bool;   // Reserved for future use
      "Execute DMCC Ack" : Bool;   // Indicates that the “Execute DMCC” operation is complete
      "Set Match String Ack" : Bool;   // Indicates that the “Set Match String” operation is complete - User Data Option - Currently only used by “Set Match String” soft event.
      ResultID : Byte;   // HIGHER BYTE The value of the “Trigger ID” when the trigger that generated these results was issued. Used to match up triggers with corresponding result data (16-bit Integer).
      "ResultID 1" : Byte;   // LOWER BYTE The value of the “Trigger ID” when the trigger that generated these results was issued. Used to match up triggers with corresponding result data (16-bit Integer).
      "Result Code" : Byte;   // HIGHER BYTE not used
      "Result Code_1" : Byte;   // Indicates the success or failure of the read that produced these results (16-bit Integer).Bit 0,1=read, 0=no read, Bit 1,1=validated, 0=not validated (or validation not in use),  Bit 2,1=verified, 0=not verified (or verification not in use)  Bit 3,1=acquisition trigger overrun  Bit 4,1=acquisition buffer overflow
      "Result Extended" : Byte;   // Currently unused (16-bit Integer).
      "Result Extended_1" : Byte;   // Currently unused (16-bit Integer).
      "Result Length" : Byte;   // HIGHER BYTE Actual number of bytes of read data contained in the “Result Data” field (16-bitInteger).
      "Result Length_1" : Byte;   // LOWER BYE Actual number of bytes of read data contained in the “Result Data” field (16-bitInteger).
      "BarCodeValue[0]-NO_READ_sign" : Char;   // First barecode char
      BarCodeValue : Array[1..63] of Char;   // Remaining characters of the barcode, after the barcode remaining chars are  '$00' = BYTE#16#00
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_ParcelLength"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 20
// END_ATTRIBUTES
   VAR_INPUT 
      ii_PECPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //    Photoeye position [cm]
      ii_Displacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //    Displacement [cm]
      ix_LengthMeasurementEnable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Length measurement enable
      ix_GapMeasurementEnable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Gap measurement enable
   END_VAR

   VAR_IN_OUT 
      iqa_TrackingData : Array[*] of Int;   //    Tracking data
   END_VAR

   VAR 
      sR_TRIG_Data {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //    Data rising edge for length and gap measurements
      sF_TRIG_Data {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //    Data falling edge for length and gap measurements
      si_Length { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //    Parcel length
      si_Gap { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //    Gap distance
      si_GIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //    GIN number of current measured parcel
      si_OldGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //    GIN number of previous mesured parcel
   END_VAR

   VAR CONSTANT 
      ci_Overflow : Int := 32767;   //    Integer overflow value
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	21/02/2020  | 3.1       | L.Klar        | first release MHSE TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – Data triggers
	    
	    // Triggers to detect front and end of data
	    
	    #sR_TRIG_Data(CLK := #iqa_TrackingData[#ii_PECPosition] > 0);
	    #sF_TRIG_Data(CLK := #iqa_TrackingData[#ii_PECPosition] > 0);
	    
	END_REGION
	
	REGION 2 – Length counter
	    
	    //  Length is counted from a displacement, when data is available
	    //  
	    IF (#iqa_TrackingData[#ii_PECPosition] > 0
	        AND #ix_LengthMeasurementEnable
	        AND #si_Length < #ci_Overflow)
	        
	    THEN
	        #si_Length += #ii_Displacement;
	    END_IF;
	    
	END_REGION
	
	REGION 3 – Gap counter
	    
	    //  Gap is counted from a displacement, when data isn't available
	    IF (#iqa_TrackingData[#ii_PECPosition] = 0
	        AND #ix_GapMeasurementEnable
	        AND #si_Gap < #ci_Overflow)
	    THEN
	        #si_Gap += #ii_Displacement;
	    END_IF;
	    
	END_REGION
	
	REGION 4 – Parcel GIN
	    
	    IF (#sR_TRIG_Data.Q AND
	        (#ix_LengthMeasurementEnable OR #ix_GapMeasurementEnable))
	    THEN
	        #si_GIN := #iqa_TrackingData[#ii_PECPosition];
	    END_IF;
	    
	END_REGION
	
	REGION 5 – Write length into a GIN record
	    
	    IF (#sF_TRIG_Data.Q)
	    THEN
	        
	        IF #ix_LengthMeasurementEnable OR #ix_GapMeasurementEnable THEN
	            #si_OldGIN := #si_GIN;
	        END_IF;
	        
	        IF (#si_GIN > 0
	            AND ABS(#si_Length) > 0
	            AND #ix_LengthMeasurementEnable)
	        THEN
	            "DB_GIN".GIN[#si_GIN].General.Length := ABS(#si_Length) - 1;
	            #si_Length := 0;
	        ELSE
	            #si_Length := 0;
	        END_IF;
	    END_IF;
	    
	END_REGION
	
	REGION 6 – Write GIN into a GIN record
	    
	    IF (#sR_TRIG_Data.Q)
	    THEN
	        IF (#si_OldGIN > 0
	            AND #si_GIN > 0
	            AND #si_Gap <> 0
	            AND #si_OldGIN <> #si_GIN
	            AND #ix_GapMeasurementEnable)
	        THEN
	            IF (#ii_Displacement > 0)
	            THEN
	                "DB_GIN".GIN[#si_GIN].General.LeadingGap := ABS(#si_Gap) - 1;
	                "DB_GIN".GIN[#si_OldGIN].General.TrailingGap := "DB_GIN".GIN[#si_GIN].General.LeadingGap;
	                #si_Gap := 0;
	            ELSIF (#ii_Displacement < 0)
	            THEN
	                "DB_GIN".GIN[#si_OldGIN].General.LeadingGap := ABS(#si_Gap - 1);
	                "DB_GIN".GIN[#si_GIN].General.TrailingGap := "DB_GIN".GIN[#si_OldGIN].General.LeadingGap;
	                #si_Gap := 0;
	            END_IF;
	        ELSE
	            #si_Gap := 0;
	        END_IF;
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

TYPE "UDT_DataLogicBlade_IN_SN"
VERSION : 0.1
   STRUCT
      Data : Array[0..15] of Byte;
   END_STRUCT;

END_TYPE

TYPE "UDT_CommisioningNord"
VERSION : 0.1
   STRUCT
      HWAdress : Int;   // Actual dipswitch adress of the VFD
      i_ParCRC : Word;   // VFD generated CRC
      CommissionError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Commissioning error active
   END_STRUCT;

END_TYPE

TYPE "UDT_StatusTC36"
VERSION : 0.1
//One direction, motor, controler, EOS
   STRUCT
      RightAngledTransfer : "UDT_RATStatus";   // Right angled transfer status
      MCO_M01 : "UDT_AixControllerStatus";   // MCO Status
   END_STRUCT;

END_TYPE

TYPE "UDT_CognexDM260_OUT"
VERSION : 0.1
   STRUCT
      TriggerEnable : Bool;   // Setting this bit enables triggering via PROFINET. Clearing this bit disables triggering.
      Trigger : Bool;   // Setting this bit triggers an acquisition when the following conditions are met:l Trigger Enable is set.l No acquisition is currently in progress.l The device is ready to trigger.
      Reserved_0 : Bool;   // Reserved for future use
      Reserved_1 : Bool;   // Reserved for future use
      Reserved_2 : Bool;   // Reserved for future use
      Reserved_3 : Bool;   // Reserved for future use
      Reserved_4 : Bool;   // Reserved for future use
      Reserved_5 : Bool;   // Reserved for future use
      BufferResultsEnable : Bool;   // Enables queuing of “Result Data”. If enabled, the current result data will remain until acknowledged (even if new results arrive). New results are queued. The reader can buffer up to 50 and the base station can buffer up to 500 sets of read results.
      ResultsAck : Bool;   // Bit is used to acknowledge that the PLC has successfully read the latest result data. When set True the “Result Available” bit will be cleared. If result buffering is enabled, the next set of result data will be pulled from the queue and “Result Available” will again be set True.
      Reserved : Bool;   // Reserved for future use.
      Reserved_1_1 : Bool;   // Reserved for future use.
      Reserved_2_1 : Bool;   // Reserved for future use.
      Reserved_3_1 : Bool;   // Reserved for future use.
      Reserved_4_1 : Bool;   // Reserved for future use.
      Reserved_5_1 : Bool;   // Reserved for future use.
      "Train Code" : Bool;   // Bit transition from 0 -> 1 causes the train code operation to be invoked.
      "Train Match String" : Bool;   // Bit transition from 0 -> 1 causes the train match string operation to be invoked.
      "Train Focus" : Bool;   // Bit transition from 0 -> 1 causes the train focus operation to be invoked.
      "Train Brightness" : Bool;   // Bit transition from 0 -> 1 causes the train brightness operation to be invoked
      Untrain : Bool;   // Bit transition from 0 -> 1 causes the untrain operation to be invoked.
      Reserved_6 : Bool;   // Reserved for future use
      "Execute DMCC" : Bool;   // Bit transition from 0 -> 1 causes the DMCC operation to be invoked. Note that a valid DMCC command string must first be placed in “User Data” before invoking this event.
      "Set Match String" : Bool;   // Bit transition from 0 -> 1 causes the set match string operation to be invoked. Note that match string data must first be placed in “User Data” before invoking this event.
      "UserData Option" : Int;   // Specifies which code target to assign the string (16-bit Integer). 1, assign string to 2D codes, 2, assign string to QR codes
      "UserData Length" : Int;   // Number of bytes of valid data actually contained in the “User Data” field (16-bit
      "UserData[0]" : Byte;   // Data sent from the PLC to the DataMan to support acquisition, decoding, andother special operations (array of bytes). User Data Option - Currently only used by “Set Match String” soft event.
      "UserData[1]" : Byte;
      "UserData[2]" : Byte;
      "UserData[3]" : Byte;
      "UserData[4]" : Byte;
      "UserData[5]" : Byte;
      "UserData[6]" : Byte;
      "UserData[7]" : Byte;
      "UserData[8]" : Byte;
      "UserData[9]" : Byte;
      "UserData[10]" : Byte;
      "UserData[11]" : Byte;
      "UserData[12]" : Byte;
      "UserData[13]" : Byte;
      "UserData[14]" : Byte;
      "UserData[15]" : Byte;
      "UserData[16]" : Byte;
      "UserData[17]" : Byte;
      "UserData[18]" : Byte;
      "UserData[19]" : Byte;
      "UserData[20]" : Byte;
      "UserData[21]" : Byte;
      "UserData[22]" : Byte;
      "UserData[23]" : Byte;
      "UserData[24]" : Byte;
      "UserData[25]" : Byte;
      "UserData[26]" : Byte;
      "UserData[27]" : Byte;
      "UserData[28]" : Byte;
      "UserData[29]" : Byte;
      "UserData[30]" : Byte;
      "UserData[31]" : Byte;
      "UserData[32]" : Byte;
      "UserData[33]" : Byte;
      "UserData[34]" : Byte;
      "UserData[35]" : Byte;
      "UserData[36]" : Byte;
      "UserData[37]" : Byte;
      "UserData[38]" : Byte;
      "UserData[39]" : Byte;
      "UserData[40]" : Byte;
      "UserData[41]" : Byte;
      "UserData[42]" : Byte;
      "UserData[43]" : Byte;
      "UserData[44]" : Byte;
      "UserData[45]" : Byte;
      "UserData[46]" : Byte;
      "UserData[47]" : Byte;
      "UserData[48]" : Byte;
      "UserData[49]" : Byte;
      "UserData[50]" : Byte;
      "UserData[51]" : Byte;
      "UserData[52]" : Byte;
      "UserData[53]" : Byte;
      "UserData[54]" : Byte;
      "UserData[55]" : Byte;
      "UserData[56]" : Byte;
      "UserData[57]" : Byte;
      "UserData[58]" : Byte;
      "UserData[59]" : Byte;
      "UserData[60]" : Byte;
      "UserData[61]" : Byte;
      "UserData[62]" : Byte;
      "UserData[63]" : Byte;
   END_STRUCT;

END_TYPE

TYPE "UDT_StatusTC13"
VERSION : 0.1
//One direction, motor, controler, EOS, Tracking
//
   STRUCT
      Conveyor : "UDT_ConveyorStatus";   // Conveyor Status
      PEC_EoS : "UDT_PECUpdateStatus";   // PEC EoS Status
      MCO_M01 : "UDT_AixControllerStatus";   // MCO Status
   END_STRUCT;

END_TYPE

TYPE "UDT_VfdSEWPositioningPO"
TITLE = UDT_VFD_SEW_PO
VERSION : 0.1
//User-defined structure of VFD SEW output telegram.
   STRUCT
      Control_Word_1 : Struct   // Control Word 1
         ResetError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset error "1"
         BIT_09_Reserved { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         ActivateDriveTrain2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate drive train 2 "1"
         BIT_11_Reserved { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         DeactivateSW_LimitSwitch { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Deactivate software limit switch "1"
         ActivateInhibit { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate inhibit "1"
         ActivateStandby { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate standby "1"
         MovikitHandshakeIn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // If the MOVIKIT works the value will be copied into "MovikitHandshakeOut"
         EnableRapidStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Enable “1” / Rapid stop “0”
         EnableApplicationStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Enable “1” / Application stop “0”
         BIT_02_Reserved { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         ReleaseBrake { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Release brake "1"
         JogPos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Jog in positive direction "1"
         JogNeg { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Jog in negative direction "1"
         ApplyRelativePositioning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Take the relative position from the FCB09 "1"
         StartStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start "1" / Stop "0"
      END_STRUCT;
      SetpointSpeed : Int;   // Speed (Int) [mm/s]
      SetpointAcceleration : Int;   // Acceleration (Int) [mm/s²]
      SetpointDeceleration : Int;   // Decceleration (Int) [mm/s²]
      DigitalOutputs : Word;   // Digital Outputs
      SetpointMode : Int;   // Set the application mode (Int)
      SetpointPosition_hW : Word;   // Setpoint Position - High Word
      SetpointPosition_lW : Word;   // Setpoint Position - Low Word
   END_STRUCT;

END_TYPE

TYPE "UDT_RIOVSUStatistics"
TITLE = UDT_RIOStatistics
VERSION : 0.1
//User-defined structure of FB_RIO function block statistics.
   STRUCT
      Int400VCBError : "UDT_EventStatistic";   // Statistics of internal 400V circuit breaker not OK
      Ext400VError : "UDT_EventStatistic";   // Statistics of external 400V not OK
      "24VError" : "UDT_EventStatistic";   // Statistics of external 24V not OK
      BrakeCBerror : "UDT_EventStatistic";   // Statistics of brake circuit breaker not OK
      BrakeThermError : "UDT_EventStatistic";   // Statistics of brake thermal error
      PNSlaveNotOnline : "UDT_EventStatistic";   // Statistics of Profinet slave not online
      PNSlaveError : "UDT_EventStatistic";   // Statistics of a Profinet slave error
   END_STRUCT;

END_TYPE

TYPE "UDT_VfdStatus"
TITLE = UDT_VfdStatus
VERSION : 0.1
//User-defined structure of VFD status.
   STRUCT
      ErrorCode : Int;   // Error code
      SubErrorCode : Int;   // Sub error code
      PNSlaveNotonline : Bool := FALSE;   // Profinet slave is not on line
      PNSlaveError : Bool := FALSE;   // Profinet slave has an error
      InternalError : Bool := FALSE;   // A VFD internal error is active, see error code
      InternalWarning : Bool := FALSE;   // A VFD internal warning is active, see error code
      CommunicationErrorMovikit : Bool := FALSE;   // Communication error with MoviKit
      VFDRunningFeedbackError : Bool := FALSE;   // Motor is not running
      PNSlaveWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet slave has a warning
   END_STRUCT;

END_TYPE

TYPE "UDT_VSULiftStatus"
TITLE = UDT_VSUStatus
VERSION : 0.1
//User-defined structure of FB_VerticalSwitch function block status.
   STRUCT
      Status { ExternalWritable := 'False'} : Int;   // Status number
      Specific { ExternalWritable := 'False'} : Struct   // Equipment specific warnings and errors
         ReferencedErr { ExternalWritable := 'False'} : Bool;   // VFD is not referenced
         ExitGapErr { ExternalWritable := 'False'} : Bool;   // Exit gap check was activated when moving
         EntryGapErr { ExternalWritable := 'False'} : Bool;   // Entrance gap check was activated when moving
         BeltTear1Err { ExternalWritable := 'False'} : Bool;   // Belt tear detected - Sensor 1
         BeltTear2Err { ExternalWritable := 'False'} : Bool;   // Belt tear detected - Sensor 2
         MaintSupport1Err { ExternalWritable := 'False'} : Bool;   // Maintenace support 1 extracted in automatic mode
         MaintSupport2Err { ExternalWritable := 'False'} : Bool;   // Maintenace support 2 extracted in automatic mode
         UpperPositionErr { ExternalWritable := 'False'} : Bool;   // Upper position overrun
         LowerPositionErr { ExternalWritable := 'False'} : Bool;   // Lower position overrun
         DirectionErr { ExternalWritable := 'False'} : Bool;   // Item in the wrong position
         KeyswitchWrn { ExternalWritable := 'False'} : Bool;   // Keyswitch is in '0' position
         SafetyDoorDownErr { ExternalWritable := 'False'} : Bool;   // Safety door down diagnostic fault
         SafetyDoorUpErr { ExternalWritable := 'False'} : Bool;   // Safety door up diagnostic fault
         LiftKeySwitchStop { ExternalWritable := 'False'} : Bool;   // Lift key switch turned to Stop
         MaintenanceSwitchUp { ExternalWritable := 'False'} : Bool;
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_StatisticsTC11"
VERSION : 0.1
//One direction, motor
   STRUCT
      Conveyor : "UDT_ConveyorStatistics";   // Conveyor Statistics
      MCO_M01 : "UDT_VfdStatistics";   // MCO Statistics
   END_STRUCT;

END_TYPE

FUNCTION "FC_GetPNPortStatus" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 20
// END_ATTRIBUTES
   VAR_INPUT 
      ii_NumberOfPorts : Int;   //  Number of ports in device
      iUDT_DevicePNInfo : "UDT_PNDevice";   //  PN device info structure
   END_VAR

   VAR_OUTPUT 
      qa_PortFault : Array[1..8] of Bool;   //  When TRUE then specific port has a fault
   END_VAR

   VAR_TEMP 
      tp_GetDiagInfo {InstructionName := 'DIS'; LibVersion := '1.0'} : DIS;   //  Diagnostic structure
      tp_DeviceGeoAddr {InstructionName := 'GEOADDR'; LibVersion := '1.0'} : GEOADDR;   //  Device pointer structre
      ta_PortFault : Array[1..8] of Bool;   //  When TRUE then port has a fault
      ti_Geo2LogStatus : Int;   //  GEO2LOG status code
      ti_GetDiagStatus : Int;   //  Get_Diag status code
      ti_Log2GeoStatus : Int;   //  LOG2GEO status code
      ti_Loopcounter : Int;   //  Loop counter
      tui_cnt : UInt;   //  Not used
      tdi_PortLaddr : HW_ANY;   //  HW identifier
      ti_PortFault : Bool;   //  At least one port is faulty
      tx_ConfigurationError : Bool;   //  Configuration error occurred
   END_VAR

   VAR CONSTANT 
      ci_Area : UInt := 1;   //     Area ID of IO Profinet devices
      ci_HWTYPE : UInt := 5;
      ci_PortSlot : UInt := 0;
      ci_PortSubslot : Word := 16#8000;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	03/11/2020  | 3.0       | K.Pokorski    | first release MHS TIA 15.1
	17/12/2020  | 3.1       | K.Pokorski    | Run operation only during error
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Check configuration
	    
	    #tx_ConfigurationError := #ii_NumberOfPorts < 1
	    OR #ii_NumberOfPorts > 8
	    OR NOT #iUDT_DevicePNInfo.PNDeviceFound;
	    
	END_REGION
	
	REGION 2 - Read profinet network number
	    
	    // Using LOG2GEO profinet network address is read
	    #ti_Log2GeoStatus := LOG2GEO(LADDR := "DB_ProfinetDiagnostic".ProfinetNetworks[#iUDT_DevicePNInfo.PNNetworknumber].DeviceStatus[#iUDT_DevicePNInfo.PNDeviceNumber].DeviceState.HW_ID,
	                                 GEOADDR := #tp_DeviceGeoAddr);
	    
	END_REGION
	
	REGION 3 - Preparation the device pointer
	    
	    // HWTYPE = 5 - Submodule
	    #tp_DeviceGeoAddr.HWTYPE := #ci_HWTYPE;
	    // AREA = 1 - PROFINET IO
	    #tp_DeviceGeoAddr.AREA := #ci_Area;
	    // SLOT = 0 - Ports are on slot 0 
	    #tp_DeviceGeoAddr.SLOT := #ci_PortSlot;
	    // STATION - Profinet number
	    #tp_DeviceGeoAddr.STATION := "DB_ProfinetDiagnostic".ProfinetNetworks[#iUDT_DevicePNInfo.PNNetworknumber].DeviceStatus[#iUDT_DevicePNInfo.PNDeviceNumber].DeviceState.ProfinetNumber;
	    
	END_REGION
	
	REGION 4 - Checking the port status
	    // If device report error and is available on the PN network
	    IF "DB_ProfinetDiagnostic".ProfinetNetworks[#iUDT_DevicePNInfo.PNNetworknumber].DeviceStatus[#iUDT_DevicePNInfo.PNDeviceNumber].DeviceState.Error
	        AND "DB_ProfinetDiagnostic".ProfinetNetworks[#iUDT_DevicePNInfo.PNNetworknumber].DeviceStatus[#iUDT_DevicePNInfo.PNDeviceNumber].DeviceState.Exist
	        AND NOT #tx_ConfigurationError
	    THEN
	        
	        // Loop through all profinet ports
	        FOR #ti_Loopcounter := 1 TO #ii_NumberOfPorts DO
	            // Reset auxiliary port fault bit 
	            #ta_PortFault[#ti_Loopcounter] := FALSE;
	            // SUBSLOT = 16#8000 plus port number (TIA structure to refer to port)
	            #tp_DeviceGeoAddr.SUBSLOT := INT_TO_UINT(WORD_TO_INT(#ci_PortSubslot) + (#ti_Loopcounter));
	            // Using GEO2LOG port address is read
	            #ti_Geo2LogStatus := GEO2LOG(GEOADDR := #tp_DeviceGeoAddr, LADDR => #tdi_PortLaddr);
	            // Using GET_DIAG port status is read
	            #ti_GetDiagStatus := GET_DIAG(MODE := 1, LADDR := #tdi_PortLaddr, CNT_DIAG => #tui_cnt, DIAG := #tp_GetDiagInfo);
	            
	            // Set port fault if all operations do not report any error and port is faulty
	            IF #ti_GetDiagStatus = 0
	                AND #ti_Geo2LogStatus = 0
	                AND #ti_Log2GeoStatus = 0
	                AND #tp_GetDiagInfo.OwnState = 4
	            THEN
	                #ta_PortFault[#ti_Loopcounter] := TRUE;
	            END_IF;
	        END_FOR;
	        // Reset module status if error occurred
	    ELSIF #tx_ConfigurationError
	    THEN
	        FOR #ti_Loopcounter := 1 TO 8 DO
	            #ta_PortFault[#ti_Loopcounter] := FALSE;
	        END_FOR;
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Write output
	    
	    #qa_PortFault := #ta_PortFault;
	    
	END_REGION
	
	
END_FUNCTION

FUNCTION "FC_GetDevicePN" : Void
TITLE = FC_GetDevicePN
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 18
// END_ATTRIBUTES
   VAR_INPUT 
      is_PNDeviceName : String;   // Name of the device
      ix_SimulationModeActive : Bool;   // True = Simulation mode active
   END_VAR

   VAR_IN_OUT 
      iqUDT_PND : "UDT_PNDevice";   // Device found in Profinet structure
   END_VAR

   VAR_TEMP 
      ti_NrOfConfiguredPNNetworks : Int;   // Number of networks configured in project
      ti_NrOfDevices : Int;   // Nr of devices is networks
      ti_LcPNNetworkNumber : Int;   // Loop counter to find PN network number
      ti_LcPNDeviceNumber : Int;   // Loop counter to find PN device number
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	16/09/2019  | 2.3       | F.Baten       | Cut out of 'FB_RIO'
	29/09/2019  | 2.4       | K.Pokorski    | Network seach started from 1 instead 0
	30/09/2019  | 2.5       | K.Pokorski    | Chagne prefixes of temporary varaibles from 'si' to 'ti'
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Get Device Profinet number
	    // if simulation is disabled 
	    IF NOT #ix_SimulationModeActive
	    THEN
	        // And the profinet device is not found yet
	        IF (#is_PNDeviceName <> "DB_ProfinetDiagnostic".ProfinetNetworks[#iqUDT_PND.PNNetworknumber].DeviceStatus[#iqUDT_PND.PNDeviceNumber].DeviceState.PNDeviceName)
	            OR #iqUDT_PND.PNDeviceFound = FALSE
	        THEN
	            #iqUDT_PND.PNDeviceFound := FALSE;
	            
	            // check how many profinet networks are configured
	            #ti_NrOfConfiguredPNNetworks := "FC_GetNrOfArrayEl"("DB_ProfinetDiagnostic".ProfinetNetworks);
	            
	            FOR #ti_LcPNNetworkNumber := 1 TO (#ti_NrOfConfiguredPNNetworks) DO
	                
	                #iqUDT_PND.PNNetworknumber := #ti_LcPNNetworkNumber;
	                
	                // and check how many devices are configured per network
	                #ti_NrOfDevices := "FC_GetNrOfArrayEl"("DB_ProfinetDiagnostic".ProfinetNetworks[#iqUDT_PND.PNNetworknumber].DeviceStatus);
	                
	                // check for each of the devices in the networks if the PN device name is similair to the configured device name
	                FOR #ti_LcPNDeviceNumber := 0 TO (#ti_NrOfDevices - 1) DO
	                    
	                    #iqUDT_PND.PNDeviceNumber := #ti_LcPNDeviceNumber;
	                    
	                    // set device found when a match is found for the device name in the PN network
	                    IF (#is_PNDeviceName = "DB_ProfinetDiagnostic".ProfinetNetworks[#iqUDT_PND.PNNetworknumber].DeviceStatus[#iqUDT_PND.PNDeviceNumber].DeviceState.PNDeviceName
	                        AND #is_PNDeviceName <> '')
	                    THEN
	                        
	                        #iqUDT_PND.PNDeviceFound := TRUE;
	                        EXIT;
	                        
	                    END_IF;
	                END_FOR;
	                
	                // exit loop when device name is matching
	                IF #iqUDT_PND.PNDeviceFound
	                THEN
	                    
	                    EXIT;
	                    
	                END_IF;
	            END_FOR;
	        END_IF;
	    END_IF;
	    
	END_REGION
END_FUNCTION

TYPE "UDT_PECUpdateConfiguration"
TITLE = UDT_PECConfiguration
VERSION : 0.1
//User-defined structure of PEC parameters.
   STRUCT
      Distance : DInt;   // Distance between photo eye and the end of conveyor [mm]
      JamDisplacementLimit : Int;   // Limit displacement with PEC blocked o detect jam [cm]
      TimeOnDelay : UDInt;   // Photo eye time on delay [ms]
      TimeOffDelay : UDInt;   // Photo eye time off delay [ms]
      ParcelLengthFilter : Bool := TRUE;   // Parcel length filter
      ResetWithPECBlocked { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // When 'True' Allow reset system after jam with PEC blocked
      SearchWindowFwd : Int;   // Search window in forward direction [cm]
      SearchWindowRvs : Int;   // Search window in reverse direction [cm]
      GINRangeStart : Int;   // GIN range start value
      GINRangeEnd : Int;   // GIN range end value
      NrOfTeachParcels : Int;   // Number of parcels to teach
      DefaultGIN : Int := 1;   // Default GIN record
      MaxLost : Int;   // Maximum number of lost parcels in a row
      GenerationPoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Generation point
      NegativeGINDelete { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True when negative GIN has to be deleted
      ParcelLengthMeasurement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parcel length measurement
      GapLengthMeasurement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Gap length measurement
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_Conveyor"
TITLE = FB_Conveyor_BiDirectional
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : Equimpent
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 207
// END_ATTRIBUTES
//Function block to control the bi-directional conveyor.
   VAR_INPUT 
      iUDT_ConveyorConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorConfiguration";   //           Conveyor configuration structure
      idi_PECEoSDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Distance between photo eye and the end of conveyor [mm] in forward direction
      idi_PECBoSDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Distance between photo eye and the end of conveyor [mm] in reverse direction
      ii_ExternalSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //           External speed [mm/s]
      ix_SafetyOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           TRUE when safety is ok
      ix_24vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           TRUE when 24VDC is healthy
      ix_400vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           TRUE when 400VAC is healthy
      ix_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           TRUE when  hardware is Ok
      ix_PECEoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;   //           TRUE when the end of section photoeye in forward direction is not blocked
      ix_PECBoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;   //           TRUE when the end of section photoeye in reverse direction is not blocked
      ix_ReverseDirection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           FALSE when to run in forward direction and True to run in Reverse direction
      ix_ExternalRequestDieBack { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           External input to request die back
      ix_ExternalRequestHold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           External input to request conveyor hold
      ix_ResetEnergySave { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Reset energy save mode timer
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorStatus";   //           HMI status structure
      qUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   //           Common status structure
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   //           Equipment control structure
      iqUDT_ConveyorCommand : "UDT_ConveyorCommand";   //           Conveyor command stucture
      iqUDT_ConveyorInterface : "UDT_ConveyorInterface";   //           Interface structure
      iqUDT_HandShakeUp : "UDT_ConveyorHandshake";   //           Upstream handshake structure in forward direction
      iqUDT_HandShake : "UDT_ConveyorHandshake";   //           Handshake structure in forward direction
      iqUDT_Statistics : "UDT_ConveyorStatistics";   //           Statistics structure
   END_VAR

   VAR 
      sUDT_CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //           Common status structure
      sUDT_CommonStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //           Auxiliary status structure
      sUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";   //           HMI status structure
      sFB_CascadeModeTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //           Timer to cascade start
   END_VAR
   VAR RETAIN
      sdi_GapHeadToHeadConfigurationFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Preset forward gap head to head with correction [cm]
      sdi_GapTailToHeadConfigurationFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Preset forward gap tail to head with correction [cm]
      sdi_GapHeadToHeadConfigurationRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Preset reverse gap head to head with correction [cm]
      sdi_GapTailToHeadConfigurationRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Preset reverse gap tail to head with correction [cm]
      sdi_AuxGapHeadToHeadCounterFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Aux variable to count the head to head
      sdi_AuxGapTailtoHeadCounterFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Aux variable to count the gap
      sdi_AuxGapHeadToHeadCounterRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Aux variable to count the head to head
      sdi_AuxGapTailtoHeadCounterRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Aux variable to count the gap
      sdi_GapFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Gap between two products
      sdi_GapHeadToHeadFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Head to head between two products
      sdi_Gap_Rvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Gap between two products
      sdi_GapHeadToHeadRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Head to head between two products
      sdi_TailToBeginFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Count tail to next conveyor distance
      sdi_HeadToEndFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Count head to end distance
      sdi_TailToBeginRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Count tail to next conveyor distance
      sdi_HeadToEndRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Count head to end distance
      sdi_PECEoSDistanceFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Real distance between PEC and the end of distance
      sdi_PECtoEndDistanceFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Distance between photeye and the end of the conveyor in cm
      sdi_PEC_EoSDistanceRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Real distance between PEC and the end of distance
      sdi_PECtoEndDistanceRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Distance between photeye and the end of the conveyor in cm
      sdi_AuxEnergySaveFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Auxiliary variable to calculate energy save displacement
      sdi_AuxEnergySaveRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Auxiliary variable to calculate energy save displacement
      sdi_DownstreamGapTailtoHeadFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Gap between the beginning of the conveyor and the closer parcel in that conveyor
      sdi_DownstreamGapHeadToHeadFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Head to head between the beginning of the conveyor and the closer parcel in that conveyor
      sdi_DownstreamGapTailtoHeadRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Gap between the beginning of the conveyor and the closer parcel in that conveyor
      sdi_DownstreamGapHeadToHeadRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Head to head between the beginning of the conveyor and the closer parcel in that conveyor
      sdi_TransitionZone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Counter of product in transition zone
   END_VAR
   VAR 
      sR_TRIG_ManualMode {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge trigger manual mode
      sR_TRIG_Jog {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge trigger manual jog
      sR_TRIG_PE_EoSFiltered_Rvs {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge trigger end of section photo eye filtered
      sR_TRIG_PE_EoSFiltered_Fwd {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge trigger end of section photo eye filtered
      sR_TRIG_TailToBegin_Rvs {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge trigger Tail arrive at the beginning of next conveyor
      sR_TRIG_TailToBegin_Fwd {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge trigger Tail arrive at the beginning of next conveyor
      sF_TRIG_ManualMode {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //           Falling edge trigger manual mode
      sF_TRIG_Jog {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //           Falling edge trigger manual mode jog
      sF_TRIG_PEC_EoSFiltered_Rvs {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //           Falling edge trigger end of section photo eye filtered
      sF_TRIG_PEC_EoSFiltered_Fwd {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //           Falling edge trigger end of section photo eye filtered
      sF_TRIG_AuxHeadToEnd_Rvs {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //           Falling edge trigger Aux head to end bit
      sF_TRIG_AuxHeadToEnd_Fwd {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //           Falling edge trigger Aux head to end bit
      sR_TRIG_ConveyorUp {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge trigger conveyor up time
      sR_TRIG_EnergySave {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge trigger energy save
      sR_TRIG_VFDRunning {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge trigger VFD running
      sR_TRIG_ConveyorDownTime {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge trigger conveyor down
      sR_TRIG_RunManual {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge run conveyor in manual mode
      sR_TRIG_Transfering_Rvs {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge transfering
      sR_TRIG_Transfering_Fwd {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge transfering
      sF_TRIG_HeadAtEnd_Rvs {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //           Falling edge head at the end of the conveyor
      sF_TRIG_HeadAtEnd_Fwd {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //           Falling edge head at the end of the conveyor
      sR_TRIG_Reverse {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge of reverse direction
      sF_TRIG_Reverse {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //           Falling edge of reverse direction
      sR_Trig_DirectionChange {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge of change direction
      sF_Trig_DirectionChange {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //           Falling edge of change direction
      sR_TRIG_PrestartManual {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge of manual prestart
      sR_TRIG_ConveyorStopped {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge of stop
      sx_Ready { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Conveyor Ready to operate in Automatic mode
   END_VAR
   VAR RETAIN
      sx_StartReceived { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Save start trigger from the system
      sx_EnergySaveActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Active energy save mode
      sx_AuxHeadToEndFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Aux bit to control head to end positioning in forward direction
      sx_AuxHeadToEndRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Aux bit to control head to end positioning in reverse direction
      sx_TailToBeginFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Tail to begin done in forward direction
      sx_TailToBeginRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Tail to begin done in reverse direction
      sx_GappingFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Gapping in process in forward direction
      sx_GappingRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Gapping in process in reverse direction
   END_VAR
   VAR 
      sx_AutomaticActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Automatic active
   END_VAR
   VAR RETAIN
      sx_RecoveryGapFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Recovery gap activated in forward direction
      sx_RecoveryGapRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Recovery gap activated in reverse direction
   END_VAR
   VAR 
      sx_ManualModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Manual mode active
      sx_PreStartManual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Pre conditions to run conveyor in manual mode
   END_VAR
   VAR RETAIN
      sx_AuxHeadAtEndFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Parcel reach the end of the conveyor in forward direction
      sx_AuxHeadAtEndRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Parcel reach the end of the conveyor in reverse direction
   END_VAR
   VAR 
      sx_CascadeStartUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Cascade startup auxiliary bit
      sx_DirectionChanged { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Change direction until stop
      sx_ReverseDirection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Direction Selection auxiliary bit
      sx_ManualRunning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //          Conveyor running in manual mode
      sx_Up { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Conveyor is up
      sx_Down { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Conveyor is down
      sx_Stopped { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Conveyor is stopped
   END_VAR

   VAR_TEMP 
      tx_CascadeStart : Bool;
   END_VAR

   VAR CONSTANT 
      ci_OverflowLimit : Int := 32000;   //           Limit int overflow
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	            | 3.0       | C.Leite       | First release TIA 15.1
	01/01/2020  | 3.1       | S. Deulkar    | Modified error loging, added reset to reset internal error
	                                        | Cosidered commissioning error to put conveyor in ready state
	07/01/2020  | 3.2       | C. Leite      | Manual mode bug corrected related with conveyor start 
	10/01/2020  | 3.3       | C. Leite      | Manual mode start\stop change
	                                        | Lenght conveyor data type was changed to DInt  
	14/01/2020  | 3.4       | F.Baten       | Renamed Trail to Tail
	                                        | Renamed ii_PEC_EosDistance_EoS to idi_PEC_EoSDistance same for BoS 
	21/01/2020  | 3.5       | C.Leite       | Reset gapping bits when the direction changes 
	06/01/2020  | 3.6       | S. Deulkar    | Added safety Ok in condition to make ready status
	25/02/2020  | 3.7       | S. Deulkar    | Modified to update ststus output every cycle
	21/04/2020  | 3.8       | F.Baten       | Modified energysave reset
	23/04/2020  | 3.9       | S. Deulkar    | Modified logic for reset energy save command if it is slave conveyor
	22/06/2020  | 3.10      | K. Pokorski   | Modified singaling request activation, modified stop conditions (Handshake ReqStop)
	02/07/2020  | 3.11      | K. Pokorski   | Modified condition to disable manual mode (safety ok)
	30/07/2020  | 3.12      | S. Theocharis | Reset HMI commands of manual mode when conveyor no ready
	                                        | Keep downstream running when the a PEC error occurs 
	04/08/2020  | 3.13      | S. Deulkar    | Deletded Manual run stop command and Modified code to let 
	                                        | let slave conveyor go in energy save, Optimized energy save logic
	17/08/2020  | 3.14      | L.Klar        | Gapping corrected to work with PEC offset. Gap correction configuration added
	17/08/2020  | 3.15      | S. Theocharis | Encoder fault added. Manual mode active to interface. Stop trigger added for statistics
	                                        | Fix  statistics 
	11/01/2021  | 3.16      | L.Klar        | Input safety ok added to stop conveyor condition
	02/03/2021  | 3.17      | K. Pokorski   | Halted status enable only when automatic on
	11/03/2021  | 3.18      | S. Theocharis | Added bulk flow mode 3
	13/03/2021  | 3.19      | S. Theocharis | Warning color commented, line 665 added, sensors initial values changed to true
	15/03/2021  | 3.20      | S. Theocharis | Energy safe corrected
	29/03/2021  | 3.21      | M. Kocot      | Added HMI command for manual speed percetage selection and modified logic for cascade 
	                                        | startup
	31/03/2021  | 3.22      | H.Rutkowski   | Changed logic for TransitionZone calculation in mode 3( Converted PEC distance to cm)
	14/05/2021  | 3.23      | S. Nikodem    | Reset value from iq_UDT_HandShakeUp.DownstreamDisplacement and iq_UDT_HandShake.DownstreamDisplacement
	28/06/2021  | 3.24      | N.Kadam       | Modified logic for conveyor downtime and Esave statistics
	29/07/2021  | 3.25      | S. Deulkar    | Autotic ON condition is added to excecut region 7: Automatic mode active
	                                        | Statistics are updated after status
	11/11/2021  | 3.26      | M.Singh       |Shared Hardware signal over Interface
	28/03/2022  | 3.27      | M.Singh       |Solved Esave Bug, Swapped regions "Operation modes" and "Energy Save"
	28/07/2022  | 3.28      | M.Singh       |Removed handsakeUP.RTR from conditions determining downstream TIP and RTS
	30/07/2022  | 3.28      | M.Singh       |Addded hardware ok as condition to show safety status 
	                                        |Added Aux Head at end and TIP to Esave Reset conditions
	                                        
	                                        
	*)
	
	REGION 1 - Initial
	    
	    REGION 1.1 - First PLC cycle
	        
	        // Conveyor stops in the first scan of the PLC
	        IF "DB_Memory".FirstScan
	        THEN
	            #iqUDT_EquipmentControl.Command.Start := FALSE;    // Command start
	            #sx_AutomaticActive := FALSE;                       // switch of automatic active
	            #iqUDT_HandShakeUp.RTR := False;                   // Reset RTR signal
	            
	            #iqUDT_HandShakeUp.CascadeStartUp := FALSE;        // Reset cascade start signal
	            
	            #iqUDT_ConveyorInterface.RunFwd := FALSE;          // Order to run forward to VFD
	            #iqUDT_ConveyorInterface.RunRvs := FALSE;          // Order to run reverse to VFD
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 1.2 - Conversion distance between PEC and end of conveyor [mm to cm]
	        
	        // Move PEC Distance into a static variable. Added on version 2.8
	        #sdi_PECEoSDistanceFwd := #idi_PECEoSDistance;
	        #sdi_PEC_EoSDistanceRvs := #iUDT_ConveyorConfiguration.Common.Length - #idi_PECBoSDistance;
	        
	        // Limit to prevent malfunctions with zero or negative values. Added on version 2.8
	        IF #sdi_PECEoSDistanceFwd < 10
	        THEN
	            #sdi_PECEoSDistanceFwd := 10;
	        END_IF;
	        
	        IF #sdi_PEC_EoSDistanceRvs < 10
	        THEN
	            #sdi_PEC_EoSDistanceRvs := 10;
	        END_IF;
	        
	        //  Convertion of the distance between photo eye and the end of the conveyor from mm to cm.
	        #sdi_PECtoEndDistanceFwd := (#sdi_PECEoSDistanceFwd
	        - #iUDT_ConveyorConfiguration.Forward_Direction.PEC_EoSDistanceOffset) / 10;
	        
	        #sdi_PECtoEndDistanceRvs := (#sdi_PEC_EoSDistanceRvs
	        - #iUDT_ConveyorConfiguration.Reverse_Direction.PEC_BoSDistanceOffset) / 10;
	        
	        
	        // Limit the Pec to End distance in positive ranges. Added on version 2.7
	        IF #sdi_PECtoEndDistanceFwd < 1 THEN
	            #sdi_PECtoEndDistanceFwd := 1;
	        END_IF;
	        
	        IF #sdi_PECtoEndDistanceRvs < 1 THEN
	            #sdi_PECtoEndDistanceRvs := 1;
	        END_IF;
	        
	        #sx_ReverseDirection := (#iqUDT_ConveyorCommand.Reverse OR #ix_ReverseDirection) AND #iUDT_ConveyorConfiguration.Bi_Directional_Enable;
	        
	        
	    END_REGION
	    
	    REGION 1.3 Conditions Up - Down - Stopped
	        //Used for statistics
	        
	        #sx_Up := (#sx_AutomaticActive                               // Automatic active
	        AND #sx_Ready                                                // Ready active
	        AND NOT #sx_EnergySaveActive);                              // Not in energy save
	        
	        #sx_Down := (NOT #sx_ManualModeActive                                                   // Not in manual mode
	        AND #sUDT_CommonStatus.Error                                                           // in error 
	        AND NOT #sx_Ready                                                                       // Conveyor not ready
	        AND NOT #sx_EnergySaveActive);                                                          // Not in energy save
	        
	        #sx_Stopped := (NOT #sx_AutomaticActive AND #sx_Ready);
	        
	    END_REGION
	    
	    REGION 1.3 - Triggers
	        
	        // Rising edge trigger manual mode
	        #sR_TRIG_ManualMode(CLK := #iqUDT_ConveyorCommand.ManualMode
	                            OR #iqUDT_EquipmentControl.Command.ManualMode);
	        
	        // Falling edge trigger manual mode
	        #sF_TRIG_ManualMode(CLK := #iqUDT_ConveyorCommand.ManualMode
	                            OR #iqUDT_EquipmentControl.Command.ManualMode);
	        
	        // Rising edge trigger manual mode jog
	        #sR_TRIG_Jog(CLK := #iqUDT_ConveyorCommand.ManualJog);
	        
	        // Falling edge trigger manual mode jog
	        #sF_TRIG_Jog(CLK := #iqUDT_ConveyorCommand.ManualJog);
	        
	        // Rising edge trigger to start in manual mode
	        #sR_TRIG_RunManual(CLK := #iqUDT_ConveyorCommand.ManualStartStop);
	        
	        // Rising edge trigger end of section photo eye filtered
	        #sR_TRIG_PE_EoSFiltered_Fwd(CLK := #ix_PECEoS);
	        #sR_TRIG_PE_EoSFiltered_Rvs(CLK := #ix_PECBoS);
	        
	        // Falling edge trigger end of section photo eye filtered
	        #sF_TRIG_PEC_EoSFiltered_Fwd(CLK := #ix_PECEoS);
	        #sF_TRIG_PEC_EoSFiltered_Rvs(CLK := #ix_PECBoS);
	        
	        // Rising edge conveyor up
	        #sR_TRIG_ConveyorUp(CLK := #sx_Up);
	        
	        // Rising edge energy save mode
	        #sR_TRIG_EnergySave(CLK := #sx_EnergySaveActive);
	        
	        // Rising edge running
	        #sR_TRIG_VFDRunning(CLK := #iqUDT_ConveyorInterface.VFDRunning);
	        
	        // Rising edge conveyor conveyor down
	        #sR_TRIG_ConveyorDownTime(CLK := #sx_Down);
	        
	        //Rising edge conveyor stopped
	        #sR_TRIG_ConveyorStopped(CLK := #sx_Stopped);
	        
	        // Rising edge conveyor command reverse direction
	        #sR_TRIG_Reverse(CLK := #iqUDT_ConveyorCommand.Reverse);
	        
	        // Falling edge conveyor command reverse direction
	        #sF_TRIG_Reverse(CLK := #iqUDT_ConveyorCommand.Reverse);
	        
	        // Rising edge conveyor change direction
	        #sR_Trig_DirectionChange(CLK := #sx_ReverseDirection);
	        
	        // Falling edge conveyor change direction
	        #sF_Trig_DirectionChange(CLK := #sx_ReverseDirection);
	        
	    END_REGION
	    
	    REGION 1.4 - Move displacement to upstream
	        
	        // Downstream displacement is mode to upstream conveyor to calculate gap
	        
	        IF NOT #sx_ReverseDirection
	        THEN
	            #iqUDT_HandShakeUp.DownstreamDisplacement := #iqUDT_ConveyorInterface.Displacement;
	        ELSE
	            #iqUDT_HandShake.DownstreamDisplacement := #iqUDT_ConveyorInterface.Displacement;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 1.5 - Change direction
	        
	        // The memory bit to change direction is activated when the input is trigger
	        
	        IF #sR_Trig_DirectionChange.Q
	            OR #sF_Trig_DirectionChange.Q
	        THEN
	            #sx_DirectionChanged := TRUE;
	        END_IF;
	        
	        // The direction changed memory bit is just reset when the conveyor stops to prevente mechanical problems
	        
	        IF #sx_DirectionChanged
	            AND #iUDT_ConveyorConfiguration.Bi_Directional_Enable
	            AND NOT #iqUDT_ConveyorInterface.VFDatSpeed
	            AND NOT #iqUDT_ConveyorInterface.VFDRunning
	            AND (#iqUDT_ConveyorInterface.ActualSpeed <= 0)
	        THEN
	            #sx_DirectionChanged := FALSE;
	            
	            #sx_AuxHeadAtEndFwd := FALSE;
	            #sx_AuxHeadAtEndRvs := FALSE;
	            
	            #sdi_AuxGapHeadToHeadCounterFwd := 0;
	            #sdi_AuxGapHeadToHeadCounterRvs := 0;
	            
	            #sdi_AuxGapTailtoHeadCounterRvs := 0;
	            #sdi_AuxGapTailtoHeadCounterFwd := 0;
	            
	            #sx_GappingRvs := FALSE;
	            #sx_GappingFwd := FALSE;
	            
	            #iqUDT_HandShake.TIP := FALSE;
	            #iqUDT_HandShakeUp.TIP := FALSE;
	            
	            #iqUDT_HandShakeUp.DownstreamDisplacement := 0;     // v3.23
	            #iqUDT_HandShake.DownstreamDisplacement := 0;       // v3.23
	            
	        END_IF;
	        
	        IF (#sR_Trig_DirectionChange.Q
	            AND NOT #ix_PECBoS)
	            OR (#sF_Trig_DirectionChange.Q
	            AND NOT #ix_PECEoS)
	            AND #iUDT_ConveyorConfiguration.Bi_Directional_Enable
	        THEN
	            #sdi_AuxGapHeadToHeadCounterFwd := 0;
	            #sdi_AuxGapHeadToHeadCounterRvs := 0;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 1.5 - Gaps configuration
	        
	        // Forward head to head
	        #sdi_GapHeadToHeadConfigurationFwd := #iUDT_ConveyorConfiguration.Forward_Direction.GapHeadToHead + #iUDT_ConveyorConfiguration.Forward_Direction.GapCorrection;
	        // Forward tail to head
	        #sdi_GapTailToHeadConfigurationFwd := #iUDT_ConveyorConfiguration.Forward_Direction.GapTailToHead + #iUDT_ConveyorConfiguration.Forward_Direction.GapCorrection;
	        // Reverse head to head
	        #sdi_GapHeadToHeadConfigurationRvs := #iUDT_ConveyorConfiguration.Reverse_Direction.GapHeadToHead + #iUDT_ConveyorConfiguration.Reverse_Direction.GapCorrection;
	        // Reverse tail to head
	        #sdi_GapTailToHeadConfigurationRvs := #iUDT_ConveyorConfiguration.Reverse_Direction.GapTailToHead + #iUDT_ConveyorConfiguration.Reverse_Direction.GapCorrection;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 2 - Reset faults
	    
	    REGION 2.1 - Send reset request to interface UDT
	        
	        // Reset signal is sent to the interface UDT (VFD block, Tracking block, PEC update block)
	        #iqUDT_ConveyorInterface.InternalErrorReset := #iqUDT_EquipmentControl.Command.Reset;
	        
	        #iqUDT_ConveyorInterface.ResetStatistics := #iqUDT_EquipmentControl.Command.ResetData;
	        
	    END_REGION
	    
	    
	    REGION 2.2 - Error / warning
	        
	        #sUDT_CommonStatus.Error := #iqUDT_ConveyorInterface.InternalErrorPEC               // Internal PEC error status
	        OR #iqUDT_ConveyorInterface.InternalErrorVFD               // Internal VFD error status
	        OR #iqUDT_ConveyorInterface.InternalErrorTracking          // Internal tracking error status
	        OR #iqUDT_ConveyorInterface.Disconnected                   // Isolator switch error status 
	        OR #iqUDT_ConveyorInterface.InternalErrorEncoder;          // Encoder error
	        
	        
	        #sUDT_CommonStatus.Warning := #iqUDT_ConveyorInterface.InternalWarningTracking        // v2.3 Internal Warning Tracking  added
	        OR #iqUDT_ConveyorInterface.InternalWarningVFD;                                        // v2.3 Internal Warning VFD added
	        
	    END_REGION
	    
	END_REGION
	
	REGION 3 - Check conditions to set conveyor ready
	    //Share HardwareOK signal over interface
	    #iqUDT_ConveyorInterface.HardwareOk := #ix_HardwareOk;
	    
	    //  Conditions to set bit sx_Ready to operate in automatic mode
	    #sx_Ready := NOT #sUDT_CommonStatus.Error                              // Ready bit is set true when common error status its false
	    AND #ix_SafetyOk
	    AND #ix_24vOk                                                        // 24V error status
	    AND #ix_400vOk                                                       // 400V error status
	    AND #ix_HardwareOk                                                   // Profinet error status
	    AND NOT #iqUDT_ConveyorInterface.ConfigurationError;                // No configuration error      
	    
	END_REGION
	
	REGION 4 - Stop conveyor
	    
	    // Conditions to stop conveyor
	    IF (#sF_TRIG_Jog.Q                                           // Trigger when conveyor stops jogging by HMI
	        AND #sx_ManualModeActive)                                   // Manual mode is active
	        
	        OR (NOT #iqUDT_EquipmentControl.Command.AutomaticOn        // Conveyor stops if the bit AutomaticOn from control block is false
	        AND NOT #sx_ManualModeActive)                               // Manual mode active bit
	        
	        OR (NOT #sx_Ready                                           // Bit conveyor ready to run in automatic mode
	        AND NOT #sx_ManualModeActive)                               // Manual mode active
	        
	        OR #sR_TRIG_ManualMode.Q                                     // Trigger when manual mode is set on
	        OR #sF_TRIG_ManualMode.Q                                     // Trigger when manual mode is set off
	        
	        OR (#iqUDT_HandShakeUp.ReqStop                             // Stop request from upstream if direction not changed
	        AND NOT #sx_DirectionChanged)
	        
	        OR (#iqUDT_HandShake.ReqStop                               // Stop request from downstream if direction changed
	        AND #sx_DirectionChanged)
	        
	        OR NOT #ix_SafetyOk
	        
	    THEN
	        //  Order to stop VFD
	        #iqUDT_ConveyorInterface.RunFwd := FALSE;                  // Set false order to VFD run in forward direction
	        #iqUDT_ConveyorInterface.RunRvs := FALSE;                  // Set false order to VFD run in reverse direction
	        
	        IF NOT #sx_ReverseDirection
	        THEN
	            
	            #iqUDT_HandShakeUp.RTR := FALSE;                       // Set false the bit ready to receive
	            #iqUDT_HandShakeUp.CascadeStartUp := FALSE;            // Set false cascade start up bit
	            
	        ELSE
	            
	            #iqUDT_HandShake.RTR := FALSE;                       // Set false the bit ready to receive
	            #iqUDT_HandShake.CascadeStartUp := FALSE;            // Set false cascade start up bit
	            
	        END_IF;
	        
	        #sx_AutomaticActive := FALSE;                               // Automatic mode is disable
	        //    #sx_StartReceived := FALSE;                                 // Clear start receive bit 
	        
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Start
	    
	    REGION 5.1 - Save Start bit request
	        
	        // The conditions to set the bit "startReceived" are: 
	        // - Conveyor not in manual mode.
	        // - Conveyor ready to run.
	        // - Bit AutomaticOn from control block must be on.
	        // - Bit start form control block on.
	        
	        IF #iqUDT_EquipmentControl.Command.Start
	            AND #iqUDT_EquipmentControl.Command.AutomaticOn
	        THEN
	            #sx_StartReceived := TRUE;          // Start bit from control block received
	        END_IF;
	        
	    END_REGION
	    
	    REGION 5.2 - Cascade mode
	        
	        (* If the bit "StartReceived" is set, automatic mode is activated if the conveyor is set as the first one to run
	         or the bit cascadestartup from downstream is on. *)
	        
	        IF #iqUDT_EquipmentControl.Command.Start
	            AND #iqUDT_EquipmentControl.Command.AutomaticOn
	            AND NOT #sx_ManualModeActive
	            AND #sx_Ready
	        THEN
	            #sx_AutomaticActive := TRUE;        // Conveyor active automatic mode
	        END_IF;
	        
	        //Timer to cascade mode
	        #tx_CascadeStart := #sx_StartReceived
	        AND ((NOT #sx_ReverseDirection
	        AND (#iUDT_ConveyorConfiguration.Forward_Direction.FirstConveyorToStart
	        OR #iqUDT_HandShake.CascadeStartUp))
	        OR (#sx_ReverseDirection
	        AND (#iUDT_ConveyorConfiguration.Reverse_Direction.FirstConveyorToStart
	        OR #iqUDT_HandShakeUp.CascadeStartUp)));
	        
	        #sFB_CascadeModeTimer(iudi_OnDelayTime := #iUDT_ConveyorConfiguration.CascadeTimeOnDelay,      // Cascade mode timer
	                              ix_SignalToDelay := #tx_CascadeStart,
	                              ix_Enable := TRUE,                                                   // Signal ready to enable cascade mode
	                              qx_DelayedSignal => #sx_CascadeStartUp);
	        
	        IF NOT #iqUDT_EquipmentControl.Command.AutomaticOn
	        THEN
	            #sx_StartReceived := False;
	        END_IF;
	        
	        
	        // Cascade mode signal to upstream
	        IF NOT #sx_ReverseDirection
	        THEN
	            #iqUDT_HandShakeUp.CascadeStartUp := #sx_CascadeStartUp;
	        ELSE
	            #iqUDT_HandShake.CascadeStartUp := #sx_CascadeStartUp;
	        END_IF;
	        
	        
	        
	    END_REGION
	    
	END_REGION
	
	REGION 6 - Manual mode
	    
	    REGION 6.1 - Manual mode force disable
	        
	        // Manual mode bits inputs can be reset in case of malfunction
	        IF #iqUDT_EquipmentControl.Command.DisableManualMode
	        THEN
	            #iqUDT_ConveyorCommand.ManualMode := False;
	            #iqUDT_EquipmentControl.Command.ManualMode := False;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 6.2 - Manual mode activation 
	        
	        // Manual mode is active if it is active from hmi or by control block  
	        #sx_ManualModeActive := #iqUDT_ConveyorCommand.ManualMode
	        OR #iqUDT_EquipmentControl.Command.ManualMode;
	        
	        //Send manual mode active to PEC/VFD blocks to supress errors
	        #iqUDT_ConveyorInterface.ManualModeActive := #sx_ManualModeActive;
	        
	    END_REGION
	    
	    REGION 6.3 - Reset manual commands 
	        //When the system is not any more in manual mode or when fatal error occurs the HMI commands should be reset
	        //Added in V3.12 as bug fix. 
	        IF NOT #ix_SafetyOk
	            OR NOT #ix_24vOk                                                        // 24V error status
	            OR NOT #ix_400vOk                                                       // 400V error status
	            OR NOT #ix_HardwareOk                                                   // Profinet error status
	            OR #iqUDT_ConveyorInterface.ConfigurationError                          // No configuration err
	            OR #iqUDT_ConveyorInterface.InternalErrorVFD
	            OR #iqUDT_ConveyorInterface.Disconnected
	            OR NOT #sx_ManualModeActive
	        THEN
	            #iqUDT_ConveyorCommand.ManualStartStop := FALSE;
	            #iqUDT_ConveyorCommand.ManualFullSpeed := FALSE;
	            #iqUDT_ConveyorCommand.ManualJog := FALSE;
	            #iqUDT_ConveyorCommand.Reverse := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 6.4 - Start/Stop
	        
	        // Pre start conditions to run in manual mode
	        #sx_PreStartManual := #sx_ManualModeActive              // Manual mode active bit
	        AND #ix_SafetyOk                                        // Safety healthy bit
	        AND NOT #iqUDT_ConveyorInterface.Disconnected          // Isolator switch connected
	        AND #ix_HardwareOk                                      // Profinet comunication 
	        AND NOT #iqUDT_ConveyorInterface.InternalErrorVFD;     // Internal error from VFD
	        
	        #sR_TRIG_PrestartManual(CLK := #sx_PreStartManual);
	        
	        
	        IF (#sx_PreStartManual                                  // Pre start conditions to run in manual mode
	            AND (#sR_TRIG_RunManual.Q                            // Trigger when conveyor start running in manual mode
	            OR (#iqUDT_ConveyorCommand.ManualStartStop             // Conveyor start running in manual mode active
	            AND #sR_TRIG_PrestartManual.Q)                       // Trigger when pre start conditions ti run in manual mode
	            AND NOT #iqUDT_ConveyorCommand.ManualJog)          // Conveyor is not running in jog
	            OR (#sx_PreStartManual AND #sR_TRIG_Jog.Q                                   // Trigger to start jogging
	            AND NOT #iqUDT_ConveyorCommand.ManualStartStop))       // Conveyor is not running in manual mode
	        THEN
	            
	            #iqUDT_EquipmentControl.Request.SignalingRequest := TRUE;  // Request signaling to control block before conveyor run in manual mode
	            
	        END_IF;
	        
	        // Run conveyor forward in manual mode
	        #iqUDT_ConveyorInterface.RunFwd := #sx_PreStartManual           // Pre start conditions to run in manual mode
	        AND NOT #iqUDT_ConveyorCommand.Reverse                          // Not in reverse direction
	        AND (NOT #iqUDT_EquipmentControl.Request.SignalingRequest       // Signaling request done
	        OR #sx_ManualRunning)
	        AND (#iqUDT_ConveyorCommand.ManualStartStop                         // Manual mode start to run
	        OR #iqUDT_ConveyorCommand.ManualJog);                           // Jogging
	        
	        // Run conveyor reverse in manual mode
	        #iqUDT_ConveyorInterface.RunRvs := #sx_PreStartManual           // Pre start conditions to run in manual mode
	        AND #iqUDT_ConveyorCommand.Reverse                              // Reverse direction
	        AND (NOT #iqUDT_EquipmentControl.Request.SignalingRequest       // Signaling request done
	        OR #sx_ManualRunning)
	        AND (#iqUDT_ConveyorCommand.ManualStartStop                         // Manual mode start to run
	        OR #iqUDT_ConveyorCommand.ManualJog);                           // Jogging
	        
	        #sx_ManualRunning := #iqUDT_ConveyorInterface.RunFwd
	        OR #iqUDT_ConveyorInterface.RunRvs;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 7 - Automatic mode active
	    
	    IF NOT #sx_ManualModeActive // Manual mode is not active
	    THEN
	        REGION 7.1 - Head to End
	            
	            (*  Function to calculate when the head of the parcel reaches the end of the conveyor
	                When PEC detects parcels head, the functionality increments the displacement of the conveyor until reach the value of the distance
	                between PEC and the end of the conveyor. After that, the counter is reset and the bit #sx_AuxHeadToEnd is triggered to inform the system. *)
	            IF NOT #sx_ReverseDirection
	            THEN
	                REGION 7.1.1 - Forward
	                    
	                    IF #sF_TRIG_PEC_EoSFiltered_Fwd.Q      // Detects the product's head
	                    THEN
	                        
	                        #sdi_HeadToEndFwd := #sdi_PECtoEndDistanceFwd;                // move the distance between PE and the end of the conveyor to auxiliary variable 
	                        #sx_AuxHeadToEndFwd := TRUE;                             // Active head to end function
	                        
	                        #sdi_GapHeadToHeadFwd := #sdi_AuxGapHeadToHeadCounterFwd;     // Move gap calculated to variable
	                        #sdi_AuxGapHeadToHeadCounterFwd := 0;                     // Reset gap counter
	                        
	                        #sdi_GapFwd := #sdi_AuxGapTailtoHeadCounterFwd;    // Move gap calculated to variable
	                        #sdi_AuxGapTailtoHeadCounterFwd := 0;                     // Reset gap counter
	                        
	                        #iqUDT_HandShake.RTS := TRUE;                         // Set ready to send true when a parcel is detected in the PEC
	                        
	                    END_IF;
	                    
	                    IF #sx_AuxHeadToEndFwd                 // Parcel's head detected in photo cell
	                        AND (#sdi_HeadToEndFwd > 0)         // Psrcel's head do not arrive in the end of the conveyor yet
	                    THEN
	                        
	                        #sdi_HeadToEndFwd -= #iqUDT_ConveyorInterface.Displacement;   // Count displacement until arrive to the end of the conveyor
	                        
	                    ELSE
	                        
	                        #sx_AuxHeadToEndFwd := FALSE;      // Stop function head to end
	                        
	                    END_IF;
	                    
	                    // Falling edge trigger Aux Head to End bit
	                    #sF_TRIG_AuxHeadToEnd_Fwd(CLK := #sx_AuxHeadToEndFwd);
	                    
	                    IF #sF_TRIG_AuxHeadToEnd_Fwd.Q
	                    THEN
	                        #sx_AuxHeadAtEndFwd := TRUE;                       // The head of the parcel is at the front positon of the conveyor
	                    END_IF;
	                    
	                    
	                    #sF_TRIG_HeadAtEnd_Fwd(CLK := #sx_AuxHeadAtEndFwd);
	                    
	                END_REGION
	            ELSE
	                REGION 7.1.2 - Reverse
	                    
	                    IF #sF_TRIG_PEC_EoSFiltered_Rvs.Q      // Detects the product's head
	                    THEN
	                        
	                        #sdi_HeadToEndRvs := #sdi_PECtoEndDistanceRvs;                // move the distance between PE and the end of the conveyor to auxiliary variable 
	                        #sx_AuxHeadToEndRvs := TRUE;                             // Active head to end function
	                        
	                        #sdi_GapHeadToHeadRvs := #sdi_AuxGapHeadToHeadCounterRvs;     // Move gap calculated to variable
	                        #sdi_AuxGapHeadToHeadCounterRvs := 0;                     // Reset gap counter
	                        
	                        #sdi_Gap_Rvs := #sdi_AuxGapTailtoHeadCounterRvs;    // Move gap calculated to variable
	                        #sdi_AuxGapTailtoHeadCounterRvs := 0;                     // Reset gap counter
	                        
	                        #iqUDT_HandShakeUp.RTS := TRUE;                         // Set ready to send true when a parcel is detected in the PEC
	                        
	                    END_IF;
	                    
	                    IF #sx_AuxHeadToEndRvs                 // Parcel's head detected in photo cell
	                        AND (#sdi_HeadToEndRvs > 0)         // Psrcel's head do not arrive in the end of the conveyor yet
	                    THEN
	                        
	                        #sdi_HeadToEndRvs += #iqUDT_ConveyorInterface.Displacement;   // Count displacement until arrive to the end of the conveyor
	                        
	                    ELSE
	                        
	                        #sx_AuxHeadToEndRvs := FALSE;      // Stop function head to end
	                        
	                    END_IF;
	                    
	                    // Falling edge trigger Aux Head to End bit
	                    #sF_TRIG_AuxHeadToEnd_Rvs(CLK := #sx_AuxHeadToEndRvs);
	                    
	                    IF #sF_TRIG_AuxHeadToEnd_Rvs.Q
	                    THEN
	                        #sx_AuxHeadAtEndRvs := TRUE;                       // The head of the parcel is at the front positon of the conveyor
	                    END_IF;
	                    
	                    
	                    #sF_TRIG_HeadAtEnd_Rvs(CLK := #sx_AuxHeadAtEndRvs);
	                    
	                END_REGION
	            END_IF;
	        END_REGION
	        
	        REGION 7.2 - Tail to Begin
	            
	            (*   This function tracks when parcels tail reaches the begin of downstream conveyor
	                 When the PEC is clear, the function start to increase the displacement until reaches the distance
	                 between PEC and the end of conveyor. *)
	            IF NOT #sx_ReverseDirection
	            THEN
	                REGION 7.2.1 - Forward
	                    
	                    IF #sR_TRIG_PE_EoSFiltered_Fwd.Q                     // Detects product's tail
	                    THEN
	                        
	                        #sdi_TailToBeginFwd := (#sdi_PECEoSDistanceFwd / 10);   // move distance between PE and the end of the conveyor to auxiliar variable
	                        
	                    END_IF;
	                    
	                    IF (#sdi_TailToBeginFwd > 0)                                           // While tails parcel do not reach the beginning of next conveyor
	                    THEN
	                        
	                        #sdi_TailToBeginFwd -= #iqUDT_ConveyorInterface.Displacement;   // count displacement until the product's tail arrive to the next conveyor
	                        #sx_TailToBeginFwd := FALSE;                                    // Reset tail to begin bit
	                        
	                    ELSE
	                        
	                        #sx_TailToBeginFwd := TRUE;                                     // Product's tail arrived at the begin OF next conveyor
	                        
	                    END_IF;
	                    
	                    // Rising edge trigger Aux tail to Begin bit
	                    #sR_TRIG_TailToBegin_Fwd(CLK := #sx_TailToBeginFwd);
	                    
	                END_REGION
	            ELSE
	                REGION 7.2.2 - Reverse
	                    
	                    IF #sR_TRIG_PE_EoSFiltered_Rvs.Q                     // Detects product's tail
	                    THEN
	                        
	                        #sdi_TailToBeginRvs := (#sdi_PEC_EoSDistanceRvs / 10);   // move distance between PE and the end of the conveyor to auxiliar variable
	                        
	                    END_IF;
	                    
	                    IF (#sdi_TailToBeginRvs > 0)                                           // While tails parcel do not reach the beginning of next conveyor
	                    THEN
	                        
	                        #sdi_TailToBeginRvs += #iqUDT_ConveyorInterface.Displacement;   // count displacement until the product's tail arrive to the next conveyor
	                        #sx_TailToBeginRvs := FALSE;                                    // Reset tail to begin bit
	                        
	                    ELSE
	                        
	                        #sx_TailToBeginRvs := TRUE;                                     // Product's tail arrived at the begin OF next conveyor
	                        
	                    END_IF;
	                    
	                    // Rising edge trigger Aux tail to Begin bit
	                    #sR_TRIG_TailToBegin_Rvs(CLK := #sx_TailToBeginRvs);
	                    
	                END_REGION
	            END_IF;
	        END_REGION
	        
	        REGION 7.3 - Gap
	            
	            (*    Gap tail TO head function calculates the distance (Gap) between two parcels.                                       
	                  The function increases the Counter WHILE the photo eye is clear.                                                    
	                  Everytime a parcel trigger the photo eye, gap value is save AND the counter is reset.  *)
	            IF NOT #sx_ReverseDirection
	            THEN
	                REGION 7.3.1 - Forward
	                    
	                    IF #ix_PECEoS       // Count displacement when the PE do not detects the product
	                    THEN
	                        
	                        IF #sdi_AuxGapTailtoHeadCounterFwd < #ci_OverflowLimit        // Prevent integer variable overflow
	                        THEN
	                            IF #iqUDT_HandShake.RTR THEN
	                                #sdi_AuxGapTailtoHeadCounterFwd += #iqUDT_ConveyorInterface.Displacement;    // Calculate the gap
	                            END_IF;
	                            
	                        END_IF;
	                        
	                    END_IF;
	                    
	                END_REGION
	            ELSE
	                REGION 7.3.2 - Reverse
	                    
	                    IF #ix_PECBoS       // Count displacement when the PE do not detects the product
	                    THEN
	                        
	                        IF #sdi_AuxGapTailtoHeadCounterRvs < #ci_OverflowLimit        // Prevent integer variable overflow
	                        THEN
	                            
	                            #sdi_AuxGapTailtoHeadCounterRvs -= #iqUDT_ConveyorInterface.Displacement;    // Calculate the gap
	                            
	                        END_IF;
	                    END_IF;
	                    
	                END_REGION
	            END_IF;
	        END_REGION
	        
	        REGION 7.4 - Head to head
	            
	            // The functionality head to head is used to calculate the distance between one head's parcel and the head's parcel behind.
	            // To do it, everytime the PEC is triggered, the function save the distance calculated and reset the counter to start
	            // counting again, over and over again.
	            IF NOT #sx_ReverseDirection
	            THEN
	                REGION 7.4.1 - Forward
	                    
	                    IF #sdi_AuxGapHeadToHeadCounterFwd < #ci_OverflowLimit        // Prevent integer variable overflow
	                    THEN
	                        
	                        #sdi_AuxGapHeadToHeadCounterFwd += #iqUDT_ConveyorInterface.Displacement;   // measure the distance between two products
	                        
	                    END_IF;
	                    
	                END_REGION
	            ELSE
	                REGION 7.4.2 - Reverse
	                    
	                    IF #sdi_AuxGapHeadToHeadCounterRvs < #ci_OverflowLimit        // Prevent integer variable overflow
	                    THEN
	                        
	                        #sdi_AuxGapHeadToHeadCounterRvs -= #iqUDT_ConveyorInterface.Displacement;   // measure the distance between two products
	                        
	                    END_IF;
	                    
	                END_REGION
	            END_IF;
	        END_REGION
	        
	        REGION 7.5 - Check gaps between products
	            
	            // Check gaps is a routine that checks all the time if the gap and head to head distance is acording to the configuration.
	            // If not, the bit "sx_Gapping" is set true and the conveyor stops to gap.
	            // Compare gaps calculated with the configured gaps 
	            IF NOT #sx_ReverseDirection
	            THEN
	                REGION 7.5.1 - Forward
	                    
	                    IF ((#sdi_GapHeadToHeadConfigurationFwd > #sdi_GapHeadToHeadFwd               // Compare head to head configured with real distance
	                        OR #sdi_GapTailToHeadConfigurationFwd > #sdi_GapFwd
	                        OR #sdi_GapTailToHeadConfigurationFwd > #sdi_DownstreamGapTailtoHeadFwd           // Compare gap configured with real gap
	                        OR #sdi_GapHeadToHeadConfigurationFwd > #sdi_DownstreamGapHeadToHeadFwd)
	                        AND #sF_TRIG_AuxHeadToEnd_Fwd.Q)                                                         // Trigger when parcel arrive in the end of the conveyor
	                    THEN
	                        
	                        #sx_GappingFwd := TRUE;        // Bit to inform the system that conveyor needs to stop to apply gap
	                        
	                    END_IF;
	                    
	                END_REGION
	            ELSE
	                REGION 7.5.1 - Reverse
	                    
	                    IF ((#sdi_GapHeadToHeadConfigurationRvs > #sdi_GapHeadToHeadRvs               // Compare head to head configured with real distance
	                        OR #sdi_GapTailToHeadConfigurationRvs > #sdi_Gap_Rvs
	                        OR #sdi_GapTailToHeadConfigurationRvs > #sdi_DownstreamGapTailtoHeadRvs           // Compare gap configured with real gap
	                        OR #sdi_GapHeadToHeadConfigurationRvs > #sdi_DownstreamGapHeadToHeadRvs)
	                        AND #sF_TRIG_AuxHeadToEnd_Rvs.Q)                                                         // Trigger when parcel arrive in the end of the conveyor
	                    THEN
	                        
	                        #sx_GappingRvs := TRUE;        // Bit to inform the system that conveyor needs to stop to apply gap
	                        
	                    END_IF;
	                    
	                END_REGION
	            END_IF;
	            //    When conveyor stops to gapping, displacement values from downstream are used to 
	            //    apply new gap.
	            //    When the new gap applied fits with the configured one, the conveyor starts running again.
	            //    If the conveyor stops for die back reason and the gap its been applied, and extra gap value it will be applied.
	            //    This recovery gap it helps to recovery the system after die back.
	            IF NOT #sx_ReverseDirection
	            THEN
	                REGION 7.5.3 - Forward
	                    
	                    IF (#sx_GappingFwd          // Gapping needs to be applied bit
	                        AND ((#sdi_GapHeadToHeadConfigurationFwd > #sdi_GapHeadToHeadFwd    // Configured head to head bigger than the actual one
	                        OR #sdi_GapHeadToHeadConfigurationFwd - #idi_PECEoSDistance / 10 + #sdi_PECtoEndDistanceFwd > #sdi_DownstreamGapHeadToHeadFwd
	                        OR #sdi_GapTailToHeadConfigurationFwd > #sdi_GapFwd     // Configured gap bigger than the actual one
	                        OR #sdi_GapTailToHeadConfigurationFwd - #idi_PECEoSDistance / 10 + #sdi_PECtoEndDistanceFwd > #sdi_DownstreamGapTailtoHeadFwd)
	                        AND NOT #sx_RecoveryGapFwd)                                                // Die back recovery gap bit not active
	                        OR (((#sdi_GapHeadToHeadConfigurationFwd + #iUDT_ConveyorConfiguration.ExtraGapRecovery)   // Add recovery gap to the configured
	                        > #sdi_GapHeadToHeadFwd                                                                                 // Actual head to head distance
	                        OR (#sdi_GapHeadToHeadConfigurationFwd - #idi_PECEoSDistance / 10 + #sdi_PECtoEndDistanceFwd + #iUDT_ConveyorConfiguration.ExtraGapRecovery)
	                        > #sdi_DownstreamGapHeadToHeadFwd
	                        OR (#sdi_GapTailToHeadConfigurationFwd + #iUDT_ConveyorConfiguration.ExtraGapRecovery)    // Add recovery gap to the configured
	                        > #sdi_GapFwd                                                                               // Actual gap between parcels
	                        OR (#sdi_GapTailToHeadConfigurationFwd - #idi_PECEoSDistance / 10 + #sdi_PECtoEndDistanceFwd + #iUDT_ConveyorConfiguration.ExtraGapRecovery)
	                        > #sdi_DownstreamGapTailtoHeadFwd)
	                        AND #sx_RecoveryGapFwd))                                                                       // Recovery gap bit activate
	                    THEN
	                        
	                        #sdi_GapHeadToHeadFwd += #iqUDT_HandShake.DownstreamDisplacement;      // Increase head to head counter with conveyor downstream displacement
	                        #sdi_GapFwd += #iqUDT_HandShake.DownstreamDisplacement;     // Increase gap counter with conveyor downstream displacement
	                        
	                    ELSE
	                        
	                        #sx_GappingFwd := FALSE;                   // Set gapping bit to false
	                        
	                    END_IF;
	                    
	                    IF #sx_GappingFwd                              // Gapping bit active
	                        AND NOT #iqUDT_HandShake.RTR           // Ready to receive not active
	                    THEN
	                        
	                        #sx_RecoveryGapFwd := TRUE;                // Recovery gap activation after die back
	                        
	                    END_IF;
	                    
	                    IF #sx_RecoveryGapFwd                          // Recovery gap active
	                        AND NOT #sx_GappingFwd                     // Gapping bit not active
	                    THEN
	                        
	                        #sx_RecoveryGapFwd := FALSE;               // Recovery gap disable
	                        
	                    END_IF;
	                    
	                END_REGION
	            ELSE
	                REGION 7.5.4 - Reverse
	                    
	                    IF (#sx_GappingRvs          // Gapping needs to be applied bit
	                        AND ((#sdi_GapHeadToHeadConfigurationRvs > #sdi_GapHeadToHeadRvs    // Configured head to head bigger than the actual one
	                        OR #sdi_GapHeadToHeadConfigurationRvs - #idi_PECBoSDistance / 10 + #sdi_PECtoEndDistanceRvs > #sdi_DownstreamGapHeadToHeadRvs
	                        OR #sdi_GapTailToHeadConfigurationRvs > #sdi_Gap_Rvs     // Configured gap bigger than the actual one
	                        OR #sdi_GapTailToHeadConfigurationRvs - #idi_PECBoSDistance / 10 + #sdi_PECtoEndDistanceRvs > #sdi_DownstreamGapTailtoHeadRvs)
	                        AND NOT #sx_RecoveryGapRvs)                                                // Die back recovery gap bit not active
	                        OR (((#sdi_GapHeadToHeadConfigurationRvs + #iUDT_ConveyorConfiguration.ExtraGapRecovery)   // Add recovery gap to the configured
	                        > #sdi_GapHeadToHeadRvs                                                                                 // Actual head to head distance
	                        OR (#sdi_GapHeadToHeadConfigurationRvs - #idi_PECBoSDistance / 10 + #sdi_PECtoEndDistanceRvs + #iUDT_ConveyorConfiguration.ExtraGapRecovery)
	                        > #sdi_DownstreamGapHeadToHeadRvs
	                        OR (#sdi_GapTailToHeadConfigurationRvs + #iUDT_ConveyorConfiguration.ExtraGapRecovery)    // Add recovery gap to the configured
	                        > #sdi_Gap_Rvs                                                                               // Actual gap between parcels
	                        OR (#sdi_GapTailToHeadConfigurationRvs - #idi_PECBoSDistance / 10 + #sdi_PECtoEndDistanceRvs + #iUDT_ConveyorConfiguration.ExtraGapRecovery)
	                        > #sdi_DownstreamGapTailtoHeadRvs)
	                        AND #sx_RecoveryGapRvs))                                                                                // Recovery gap bit activate
	                    THEN
	                        
	                        #sdi_GapHeadToHeadRvs -= #iqUDT_HandShakeUp.DownstreamDisplacement;      // Increase head to head counter with conveyor downstream displacement
	                        #sdi_Gap_Rvs -= #iqUDT_HandShakeUp.DownstreamDisplacement;     // Increase gap counter with conveyor downstream displacement
	                        
	                    ELSE
	                        
	                        #sx_GappingRvs := FALSE;                   // Set gapping bit to false
	                        
	                    END_IF;
	                    
	                    IF #sx_GappingRvs                              // Gapping bit active
	                        AND NOT #iqUDT_HandShakeUp.RTR           // Ready to receive not active
	                    THEN
	                        
	                        #sx_RecoveryGapRvs := TRUE;                // Recovery gap activation after die back
	                        
	                    END_IF;
	                    
	                    IF #sx_RecoveryGapRvs                          // Recovery gap active
	                        AND NOT #sx_GappingRvs                     // Gapping bit not active
	                    THEN
	                        
	                        #sx_RecoveryGapRvs := FALSE;               // Recovery gap disable
	                        
	                    END_IF;
	                    
	                END_REGION
	            END_IF;
	        END_REGION
	        
	        REGION 7.6 - Ready to send and Transfer in progress
	            IF NOT #sx_ReverseDirection
	            THEN
	                REGION 7.6.1 - Forward
	                    
	                    IF #iqUDT_HandShake.RTR                                            // Ready to receive bit
	                        AND NOT #sx_GappingFwd
	                        AND #sx_AuxHeadAtEndFwd                                            // Parcel is at end of conveyor
	                        AND NOT #ix_ExternalRequestDieBack
	                    THEN
	                        
	                        #iqUDT_HandShake.TIP := TRUE;      // Transfer in progress bit
	                        #iqUDT_HandShake.RTS := FALSE;     // Ready to send bit
	                        #sx_AuxHeadAtEndFwd := FALSE;
	                        
	                    END_IF;
	                    
	                    IF #sR_TRIG_TailToBegin_Fwd.Q               // Reset TIP when the parcel leaves interlock
	                    THEN
	                        
	                        #iqUDT_HandShake.TIP := FALSE;     // Transfer in progress bit
	                        
	                    END_IF;
	                    
	                END_REGION
	            ELSE
	                REGION 7.6.2 - Reverse
	                    
	                    IF #iqUDT_HandShakeUp.RTR                                            // Ready to receive bit
	                        AND #iqUDT_HandShake.RTR
	                        AND NOT #sx_GappingRvs
	                        AND #sx_AuxHeadAtEndRvs                                            // Parcel is at end of conveyor
	                        AND NOT #ix_ExternalRequestDieBack
	                    THEN
	                        
	                        #iqUDT_HandShakeUp.TIP := TRUE;      // Transfer in progress bit
	                        #iqUDT_HandShakeUp.RTS := FALSE;     // Ready to send bit
	                        #sx_AuxHeadAtEndRvs := FALSE;
	                        
	                    END_IF;
	                    
	                    IF #sR_TRIG_TailToBegin_Rvs.Q               // Reset TIP when the parcel leaves interlock
	                    THEN
	                        
	                        #iqUDT_HandShakeUp.TIP := FALSE;     // Transfer in progress bit
	                        
	                    END_IF;
	                    
	                END_REGION
	            END_IF;
	        END_REGION
	        
	        REGION 7.7 - Downstream gap
	            
	            (* This functionality is used to maintain the gap between parcel conveyor's downstream.
	               To do this, is used the downstream displacement.  *)
	            IF NOT #sx_ReverseDirection
	            THEN
	                REGION 7.7.1 - Forward
	                    
	                    IF #sR_TRIG_TailToBegin_Fwd.Q                       // When the parcel's tail reach the beginning of downstream conveyor
	                    THEN
	                        
	                        #sdi_DownstreamGapTailtoHeadFwd := 0;                     // Reset downstream gap counter
	                        
	                    END_IF;
	                    
	                    IF #sdi_DownstreamGapTailtoHeadFwd < #ci_OverflowLimit        // Prevent integer variable overflow
	                    THEN
	                        
	                        #sdi_DownstreamGapTailtoHeadFwd += #iqUDT_HandShake.DownstreamDisplacement;          // Downstream displacement gap counter
	                        
	                    END_IF;
	                    
	                END_REGION
	            ELSE
	                REGION 7.7.2 - Reverse
	                    
	                    IF #sR_TRIG_TailToBegin_Rvs.Q                       // When the parcel's tail reach the beginning of downstream conveyor
	                    THEN
	                        
	                        #sdi_DownstreamGapTailtoHeadRvs := 0;                     // Reset downstream gap counter
	                        
	                    END_IF;
	                    
	                    IF #sdi_DownstreamGapTailtoHeadRvs < #ci_OverflowLimit        // Prevent integer variable overflow
	                    THEN
	                        
	                        #sdi_DownstreamGapTailtoHeadRvs -= #iqUDT_HandShakeUp.DownstreamDisplacement;          // Downstream displacement gap counter
	                        
	                    END_IF;
	                    
	                END_REGION
	            END_IF;
	        END_REGION
	        
	        REGION 7.8 - Downstream Head to Head
	            IF NOT #sx_ReverseDirection
	            THEN
	                REGION 7.8.1 - Forward
	                    
	                    #sR_TRIG_Transfering_Fwd(CLK := #iqUDT_HandShake.TIP);
	                    
	                    IF #sR_TRIG_Transfering_Fwd.Q                                                           // Transfering aux bit rising trigger
	                    THEN
	                        
	                        #sdi_DownstreamGapHeadToHeadFwd := 0;                                              // Downstream head to head reset counter
	                        
	                    END_IF;
	                    
	                    IF #sdi_DownstreamGapHeadToHeadFwd < #ci_OverflowLimit                                 // Prevent integer variable overflow
	                    THEN
	                        
	                        #sdi_DownstreamGapHeadToHeadFwd += #iqUDT_HandShake.DownstreamDisplacement;       // Downstream displacement head to head counter 
	                        
	                    END_IF;
	                    
	                END_REGION
	            ELSE
	                REGION 7.8.2 - Reverse
	                    
	                    #sR_TRIG_Transfering_Rvs(CLK := #iqUDT_HandShake.TIP);
	                    
	                    IF #sR_TRIG_Transfering_Rvs.Q                                                           // Transfering aux bit rising trigger
	                    THEN
	                        
	                        #sdi_DownstreamGapHeadToHeadRvs := 0;                                              // Downstream head to head reset counter
	                        
	                    END_IF;
	                    
	                    IF #sdi_DownstreamGapHeadToHeadRvs < #ci_OverflowLimit                                 // Prevent integer variable overflow
	                    THEN
	                        
	                        #sdi_DownstreamGapHeadToHeadRvs -= #iqUDT_HandShakeUp.DownstreamDisplacement;       // Downstream displacement head to head counter 
	                        
	                    END_IF;
	                    
	                END_REGION
	            END_IF;
	        END_REGION
	        
	        REGION 7.9 - Energy save
	            
	            (* Save energy functionality is used to stop conveyor if no parcels are in the system to save energy
	               Save energy function counts displacement if the photo eye do not detects parcels. The counter is reset if:
	               - Photo eye is triggered.
	               - Reset is required from external.
	               - Ready to send is active from upstream. *)
	            
	            IF #iUDT_ConveyorConfiguration.Energy                                       // Energy save functionality enable from configuration
	            THEN
	                
	                IF #sdi_AuxEnergySaveFwd >= #iUDT_ConveyorConfiguration.Forward_Direction.EnergySaveLenght        // Compare energy save counter with configured lenght
	                    OR #sdi_AuxEnergySaveRvs >= #iUDT_ConveyorConfiguration.Reverse_Direction.EnergySaveLenght
	                THEN
	                    #sx_EnergySaveActive := TRUE;                                           // Set energy save active true
	                END_IF;
	                
	                IF ((NOT #ix_PECEoS OR NOT #ix_PECBoS)                                  // Photo eye detects a parcel
	                    AND NOT #sx_EnergySaveActive)                                         // Energy save active bit
	                    OR #ix_ResetEnergySave                                               // Reset energy save
	                    OR (#iqUDT_HandShakeUp.ResetEnergySave AND NOT #sx_ReverseDirection)                               // Reset energy save externaly 
	                    OR (#iqUDT_HandShake.ResetEnergySave AND #sx_ReverseDirection)
	                    OR NOT #iqUDT_EquipmentControl.Command.AutomaticOn                  // Automatic ON from control block
	                    OR #iqUDT_EquipmentControl.Command.Stop                             // Stop command from control block
	                THEN
	                    #sdi_AuxEnergySaveFwd := 0;                                        // Reset energy save counter
	                    #sdi_AuxEnergySaveRvs := 0;                                        // Reset energy save counter
	                    #sx_EnergySaveActive := FALSE;                                      // Set energy save active to false
	                ELSE
	                    // Increament displacement counter
	                    IF NOT #sx_ReverseDirection
	                    THEN
	                        #sdi_AuxEnergySaveFwd += #iqUDT_ConveyorInterface.Displacement;
	                    ELSE
	                        #sdi_AuxEnergySaveRvs -= #iqUDT_ConveyorInterface.Displacement;
	                    END_IF;
	                END_IF;
	                
	            ELSE
	                // If energy save functionality is disable from configuration
	                #sdi_AuxEnergySaveFwd := 0;                                             // Reset energy save counter
	                #sx_EnergySaveActive := FALSE;                                      // Set energy save false
	            END_IF;
	            // Reset to downstream when not already in enery save on signal of PEC
	            // When slave conveyor pass reset esave command to master conveyor
	            
	            IF NOT #sx_ReverseDirection
	            THEN
	                #iqUDT_HandShake.ResetEnergySave := (NOT #ix_PECEoS OR #sx_AuxHeadAtEndFwd OR #iqUDT_HandShake.TIP) AND NOT #sx_EnergySaveActive
	                OR (#iUDT_ConveyorConfiguration.Forward_Direction.Mode = 1 AND #iqUDT_HandShakeUp.ResetEnergySave);
	            ELSE
	                #iqUDT_HandShakeUp.ResetEnergySave := NOT #ix_PECBoS AND NOT #sx_EnergySaveActive
	                OR (#iUDT_ConveyorConfiguration.Reverse_Direction.Mode = 1 AND #iqUDT_HandShake.ResetEnergySave);
	            END_IF;
	        END_REGION
	        
	        REGION 7.10 - Operation modes
	            
	            // Different modes in automatic can be configured
	            // 1 - Slave
	            // 2 - Queue
	            // 3 - Bulk flow
	            
	            IF #sx_AutomaticActive                                          // Automatic mode active
	                AND #tx_CascadeStart                                        // Cascade startup
	            THEN
	                
	                IF NOT #sx_ReverseDirection
	                THEN
	                    
	                    CASE #iUDT_ConveyorConfiguration.Forward_Direction.Mode OF                   // Operation mode configured 
	                            
	                        1:  // Slave
	                            
	                            // Run conveyor if ready to receive if on, and conveyor is not gapping,
	                            // and not halt request and not energy save active
	                            
	                            #iqUDT_ConveyorInterface.RunFwd := #sx_AutomaticActive     // Automatic mode active
	                            AND #sx_Ready                                               // Ready active
	                            AND NOT #ix_ExternalRequestHold                             // Halt request is not active
	                            AND NOT #sx_EnergySaveActive                                // Energy save not active
	                            AND #iqUDT_HandShake.RTR                               // Ready to receive active
	                            AND NOT #sx_DirectionChanged;
	                            
	                            #iqUDT_HandShakeUp.RTR := #iqUDT_ConveyorInterface.RunFwd;
	                            
	                        2:  // Master 
	                            
	                            // With queue configuration, conveyor runs if ready to receive is true.
	                            // If ready to receive is false, conveyor runs until parcel reach the end of the conveyor.
	                            
	                            // Conveyor stops if heads parcel reache the end of the conveyor and:
	                            // - Ready to receive is false
	                            // - Or die back requested.
	                            // - Or halt requested
	                            // Conveyor also stops if gapping is active or energy save mode active.
	                            
	                            #iqUDT_ConveyorInterface.RunFwd := #sx_AutomaticActive             // Automatic mode active
	                            AND #sx_Ready                                                       // Ready active
	                            AND NOT #sx_DirectionChanged
	                            AND NOT #sx_GappingFwd                                                 // Gapping request
	                            AND NOT #sx_EnergySaveActive                                        // Energy save request
	                            AND NOT #ix_ExternalRequestHold                                     // Halt requested from external
	                            AND ((NOT #ix_ExternalRequestDieBack
	                            AND #iqUDT_HandShake.RTR)
	                            OR (NOT #sx_AuxHeadAtEndFwd
	                            AND NOT #iqUDT_HandShake.TIP)
	                            OR (#iqUDT_HandShake.RTR
	                            AND NOT #sx_AuxHeadAtEndFwd));
	                            
	                            #iqUDT_HandShakeUp.RTR := #iqUDT_ConveyorInterface.RunFwd;
	                            
	                            
	                        3: //Master at bulk flow
	                            
	                            #iqUDT_ConveyorInterface.RunFwd := #sx_AutomaticActive             // Automatic mode active
	                            AND #sx_Ready                                                       // Ready active
	                            AND NOT #sx_DirectionChanged
	                            AND NOT #sx_EnergySaveActive                                        // Energy save request
	                            AND NOT #ix_ExternalRequestHold                                     // Halt requested from external
	                            AND (
	                            (NOT #ix_ExternalRequestDieBack                                     //no die back request and the downstream is running
	                            AND #iqUDT_HandShake.RTR)
	                            OR                                                                  //..or..
	                            (#sdi_TransitionZone = 0)                                            // no parcels at the transition zone
	                            OR                                                                  //..or..
	                            (#iqUDT_HandShake.RTR
	                            AND NOT #ix_ExternalRequestDieBack
	                            AND NOT (#sdi_TransitionZone = 0)));                                  //downstream is running and there are   
	                            
	                            //If PEC is blocked, reset tracking counter
	                            IF NOT #ix_PECEoS THEN
	                                #sdi_TransitionZone := (#idi_PECEoSDistance / 10);
	                            END_IF;
	                            
	                            //Track parcels at the zone between EoS and conveyor end (Transition Zone)
	                            #sdi_TransitionZone := #sdi_TransitionZone - #iqUDT_ConveyorInterface.Displacement;
	                            
	                            //If Value is negative then set to 0
	                            IF #sdi_TransitionZone < 0 THEN
	                                #sdi_TransitionZone := 0;
	                            END_IF;
	                            
	                            #iqUDT_HandShakeUp.RTR := #iqUDT_ConveyorInterface.RunFwd;
	                            
	                    END_CASE;
	                    
	                ELSE
	                    
	                    CASE #iUDT_ConveyorConfiguration.Reverse_Direction.Mode OF                   // Operation mode configured 
	                            
	                        1:  // Slave
	                            
	                            // Run conveyor if ready to receive if on, and conveyor is not gapping,
	                            // and not halt request and not energy save active
	                            
	                            #iqUDT_ConveyorInterface.RunRvs := #sx_AutomaticActive     // Automatic mode active
	                            AND #sx_Ready                                               // Ready active
	                            AND NOT #ix_ExternalRequestHold                             // Halt request is not active
	                            AND NOT #sx_EnergySaveActive                                // Energy save not active
	                            AND #iqUDT_HandShakeUp.RTR                                 // Ready to receive active
	                            AND NOT #sx_DirectionChanged;
	                            
	                            #iqUDT_HandShake.RTR := #iqUDT_ConveyorInterface.RunRvs;
	                            
	                        2:  // Master 
	                            
	                            // With queue configuration, conveyor runs if ready to receive is true.
	                            // If ready to receive is false, conveyor runs until parcel reach the end of the conveyor.
	                            
	                            // Conveyor stops if heads parcel reache the end of the conveyor and:
	                            // - Ready to receive is false
	                            // - Or die back requested.
	                            // - Or halt requested
	                            // Conveyor also stops if gapping is active or energy save mode active.
	                            
	                            #iqUDT_ConveyorInterface.RunRvs := #sx_AutomaticActive             // Automatic mode active
	                            AND #sx_Ready                                                       // Ready active
	                            AND NOT #sx_DirectionChanged
	                            AND NOT #sx_GappingRvs                                             // Gapping request
	                            AND NOT #sx_EnergySaveActive                                        // Energy save request
	                            AND NOT #ix_ExternalRequestHold                                     // Halt requested from external
	                            AND ((NOT #ix_ExternalRequestDieBack
	                            AND #iqUDT_HandShakeUp.RTR)
	                            OR (NOT #sx_AuxHeadAtEndRvs
	                            AND NOT #iqUDT_HandShakeUp.TIP)
	                            OR (#iqUDT_HandShakeUp.RTR
	                            AND NOT #sx_AuxHeadAtEndRvs));
	                            
	                            #iqUDT_HandShake.RTR := #iqUDT_ConveyorInterface.RunRvs;
	                            
	                            
	                        3: //Master at bulk flow
	                            
	                            #iqUDT_ConveyorInterface.RunRvs := #sx_AutomaticActive             // Automatic mode active
	                            AND #sx_Ready                                                       // Ready active
	                            AND NOT #sx_DirectionChanged
	                            AND NOT #sx_EnergySaveActive                                        // Energy save request
	                            AND NOT #ix_ExternalRequestHold                                     // Halt requested from external
	                            AND (
	                            (NOT #ix_ExternalRequestDieBack                                     //no die back request and the downstream is running
	                            AND #iqUDT_HandShakeUp.RTR)
	                            OR                                                                  //..or..
	                            (#sdi_TransitionZone = 0)                                            // no parcels at the transition zone
	                            OR                                                                  //..or..
	                            (#iqUDT_HandShakeUp.RTR
	                            AND NOT #ix_ExternalRequestDieBack
	                            AND NOT (#sdi_TransitionZone = 0)));                                  //downstream is running and there are   
	                            
	                            //If PEC is blocked, reset tracking counter
	                            IF NOT #ix_PECBoS THEN
	                                #sdi_TransitionZone := #idi_PECEoSDistance / 10;
	                            END_IF;
	                            //Track parcels at the zone between EoS and conveyor end (Transition Zone)
	                            #sdi_TransitionZone := #sdi_TransitionZone - #iqUDT_ConveyorInterface.Displacement;
	                            
	                            //If Value is negative then set to 0
	                            IF #sdi_TransitionZone < 0 THEN
	                                #sdi_TransitionZone := 0;
	                            END_IF;
	                            
	                            #iqUDT_HandShake.RTR := #iqUDT_ConveyorInterface.RunRvs;
	                    END_CASE;
	                    
	                END_IF;
	                
	            ELSE
	                
	                // If conveyor is not in manual mode and not ready
	                IF NOT #sx_ReverseDirection
	                THEN
	                    #iqUDT_ConveyorInterface.RunFwd := FALSE;                      // Order to VFD stop conveyor
	                    #iqUDT_HandShakeUp.RTR := FALSE;                               // Set ready to receive false
	                ELSE
	                    #iqUDT_ConveyorInterface.RunRvs := FALSE;                      // Order to VFD stop conveyor
	                    #iqUDT_HandShake.RTR := FALSE;                               // Set ready to receive false
	                END_IF;
	                
	            END_IF;
	            
	        END_REGION
	        
	    END_IF;
	END_REGION
	
	REGION 8 - Speed control
	    
	    (*In manual mode, conveyor default runs with manual speed which is calculated as a percentage of nominal speed. If "ManualFullSpeed" is set true, conveyor runs with high speed in manual mode. 
	     In jog mode conveyor always runs in low speed. In automatic mode, conveyor runs with full speed if external is zero. If external speed is bigger than zero, conveyor will run with that speed. *)
	    
	    
	    // security
	    IF #iqUDT_ConveyorCommand.ManualSpeed > 100 THEN
	        #iqUDT_ConveyorCommand.ManualSpeed := 100;
	    END_IF;
	    
	    IF #iqUDT_ConveyorCommand.ManualSpeed < 0 THEN
	        #iqUDT_ConveyorCommand.ManualSpeed := 0;
	    END_IF;
	    
	    
	    
	    IF #sx_ManualModeActive                                                                         // Manual mode active
	    THEN
	        
	        IF #iqUDT_ConveyorCommand.ManualStartStop                                              // Full speed in manual mode
	        THEN
	            
	            IF #iqUDT_ConveyorCommand.ManualFullSpeed                                                  // Full speed in manual mode
	            THEN
	                #iqUDT_ConveyorInterface.SpeedSetpoint := #iUDT_ConveyorConfiguration.SpeedSetpointNominal;    // Move nominal setpoint to the VDF
	                
	            ELSE
	                #iqUDT_ConveyorInterface.SpeedSetpoint := REAL_TO_INT(INT_TO_REAL(#iqUDT_ConveyorCommand.ManualSpeed) * (INT_TO_REAL(#iUDT_ConveyorConfiguration.SpeedSetpointNominal) / 100));     // Calculate and Move manual speed setpoint to VFD
	                
	            END_IF;
	            
	        ELSE                                                                                             //low speed for jog mode
	            
	            IF #iUDT_ConveyorConfiguration.SpeedSetpointLow < #iUDT_ConveyorConfiguration.SpeedSetpointNominal  //Low speed can't be higher than nominal speed 
	            THEN
	                #iqUDT_ConveyorInterface.SpeedSetpoint := #iUDT_ConveyorConfiguration.SpeedSetpointLow;    // Move low speed setpoint to the VDF
	                
	            ELSE
	                
	                #iqUDT_ConveyorInterface.SpeedSetpoint := #iUDT_ConveyorConfiguration.SpeedSetpointNominal;    // Move low speed setpoint to the VDF
	            END_IF;
	        END_IF;
	        
	        
	        
	    ELSE
	        
	        IF #ii_ExternalSpeed > 0                                                                      // If external speed bigger than zero
	        THEN
	            #iqUDT_ConveyorInterface.SpeedSetpoint := #ii_ExternalSpeed;                                     // Move external speed to VFD
	        ELSE
	            #iqUDT_ConveyorInterface.SpeedSetpoint := #iUDT_ConveyorConfiguration.SpeedSetpointNominal;       // Move nominal setpoint to VFD
	        END_IF;
	        
	    END_IF;
	    
	    
	    
	END_REGION
	
	
	REGION 9 - Status
	    #sUDT_HMIStatus.Specific.Reverse := #sx_ReverseDirection;
	    
	    // stopped 
	    #sUDT_CommonStatus.Stopped := NOT #sx_Ready OR NOT #sx_AutomaticActive;
	    
	    // Auto ON
	    #sUDT_CommonStatus.AutoON := #sx_Ready AND #sx_AutomaticActive;
	    
	    // Running
	    #sUDT_CommonStatus.Running := #iqUDT_ConveyorInterface.RunFwd
	    OR #iqUDT_ConveyorInterface.RunRvs;
	    
	    // Halted
	    #sUDT_CommonStatus.Halted := #ix_ExternalRequestHold
	    AND #sUDT_CommonStatus.AutoON
	    AND NOT #sUDT_CommonStatus.EnergySave;
	    
	    // Energy save active
	    #sUDT_CommonStatus.EnergySave := #sx_EnergySaveActive AND #sx_AutomaticActive;
	    
	    // Die back
	    #sUDT_CommonStatus.Dieback := #sUDT_CommonStatus.AutoON
	    AND NOT #sUDT_CommonStatus.EnergySave
	    AND NOT #sUDT_CommonStatus.Running;
	    
	    // Manual
	    #sUDT_CommonStatus.Manual := #sx_ManualModeActive;
	    
	    // Manual Running
	    #sUDT_CommonStatus.ManualRun := #sx_ManualModeActive AND #sUDT_CommonStatus.Running;
	    
	    // Safety not ok
	    #sUDT_CommonStatus.SafetyStop := NOT #ix_SafetyOk AND #ix_HardwareOk;
	    
	    // HMI status update
	    IF #sUDT_CommonStatusOld <> #sUDT_CommonStatus                                            // update on change
	        OR (#sR_TRIG_Reverse.Q OR #sF_TRIG_Reverse.Q)
	    THEN
	        // HMI status initialization
	        #sUDT_HMIStatus.Status := 0;
	        
	        // Energy save
	        IF #sUDT_CommonStatus.EnergySave
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".EnergySave;
	        END_IF;
	        
	        // Running
	        IF #sUDT_CommonStatus.Running
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Running;
	        END_IF;
	        
	        // Stopped
	        IF #sUDT_CommonStatus.Stopped
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Stopped;
	        END_IF;
	        
	        // Dieback
	        IF #sUDT_CommonStatus.Dieback
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Dieback;
	        END_IF;
	        
	        // Halted
	        IF #sUDT_CommonStatus.Halted
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Halted;
	        END_IF;
	        
	        // Manual
	        IF #sUDT_CommonStatus.Manual
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Manual;
	        END_IF;
	        
	        // Running in manual mode
	        IF #sUDT_CommonStatus.ManualRun
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".ManualRun;
	        END_IF;
	        
	(*        // Internal tracking warning
	        IF #iq_UDT_ConveyorInterface.InternalWarningTracking
	        THEN
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Warning;
	        END_IF; *)
	        
	        // Internal tracking error
	        IF #iqUDT_ConveyorInterface.InternalErrorTracking
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".TrackingError;
	        END_IF;
	        
	        // Internal PEC error
	        IF #iqUDT_ConveyorInterface.InternalErrorPEC
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".PECJam;
	        END_IF;
	        
	        // Internal Encoder error
	        IF #iqUDT_ConveyorInterface.InternalErrorEncoder
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".EncoderError;
	        END_IF;
	        
	        // Internal VFD error
	        IF #iqUDT_ConveyorInterface.InternalErrorVFD
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".VFDError;
	        END_IF;
	        
	        // Disconnect error
	        IF #iqUDT_ConveyorInterface.Disconnected
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".CBError;
	        END_IF;
	        
	        // Safety stop
	        IF (#sUDT_CommonStatus.SafetyStop)
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".SafetyStop;
	        END_IF;
	        
	        #sUDT_CommonStatusOld := #sUDT_CommonStatus;              // Copy status to memory
	        #qUDT_Status := #sUDT_CommonStatus;                       // Copy status to output
	        
	    END_IF;
	    
	    // Copy HMI status to output
	    #qUDT_HMIStatus := #sUDT_HMIStatus;
	    
	END_REGION
	
	
	REGION 10 - Statistics
	    
	    REGION 10.1 - Conveyor up time
	        
	        IF #sx_Up OR #iqUDT_EquipmentControl.Command.ResetData    // Reset statistics
	        THEN
	            
	            "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,      // Reset statistics input
	                            ix_Activate := #sx_Up,
	                            ix_RTrigActivate := #sR_TRIG_ConveyorUp.Q,                     // Statistics active trigger
	                            iqUDT_Statistics := #iqUDT_Statistics.ConveyorUp);      // Statistics values output
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 10.2 - Energy save
	        
	        // Statistics Energy save mode active
	        IF #sUDT_CommonStatus.EnergySave(* #sx_EnergySaveActive *)                                                        // Energy save active
	            OR #iqUDT_EquipmentControl.Command.ResetData                               // Reset statistics
	        THEN
	            "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,      // Reset statistics input
	                            ix_Activate := #sUDT_CommonStatus.EnergySave,                         // Activate statistics functions input
	                            ix_RTrigActivate := #sR_TRIG_EnergySave.Q,                    // Statistics active trigger
	                            iqUDT_Statistics := #iqUDT_Statistics.EnergySave);         // Statistics values output
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 10.3 - Conveyor down time
	        
	        // Conveyor down is when conveyor is not in manual mode and has an error
	        IF #sx_Down OR #iqUDT_EquipmentControl.Command.ResetData OR #sUDT_CommonStatus.SafetyStop                                    // Reset statistics
	        THEN
	            
	            "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,             // Reset statistics input
	                            ix_Activate := #sx_Down OR #sUDT_CommonStatus.SafetyStop, // Activate statistics functions input
	                            ix_RTrigActivate := #sR_TRIG_ConveyorDownTime.Q,                     // Statistics active trigger
	                            iqUDT_Statistics := #iqUDT_Statistics.ConveyorDown);              // Statistics values output
	            
	        END_IF;
	    END_REGION
	    
	    REGION 10.4 - Conveyor stop time
	        
	        IF #sx_Stopped OR #iqUDT_EquipmentControl.Command.ResetData                                           // Reset statistics
	        THEN
	            
	            "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,        // Reset statistics input
	                            ix_Activate := #sx_Stopped,                                           // Activate statistics functions input
	                            ix_RTrigActivate := #sR_TRIG_ConveyorStopped.Q,                        // Statistics active trigger
	                            iqUDT_Statistics := #iqUDT_Statistics.ConveyorStop);                  // Statistics values output
	            
	        END_IF;
	    END_REGION
	    
	END_REGION
	
	REGION 11 - Report to control block    
	    // Function to manage report between control block and conveyor block
	    "FC_EquipmentReport"(iUDT_Status := #sUDT_CommonStatus,
	                         iqUDT_Control := #iqUDT_EquipmentControl);
	    
	END_REGION
	
	REGION 12 - Internal errors and warnings reset
	    
	    IF #iqUDT_EquipmentControl.Command.Reset
	    THEN
	        
	        #iqUDT_ConveyorInterface.InternalErrorEncoder := FALSE;
	        #iqUDT_ConveyorInterface.InternalErrorPEC := FALSE;
	        #iqUDT_ConveyorInterface.InternalWarningTracking := FALSE;
	        #iqUDT_ConveyorInterface.InternalErrorTracking := FALSE;
	        #iqUDT_ConveyorInterface.InternalWarningVFD := FALSE;
	        #iqUDT_ConveyorInterface.InternalErrorVFD := FALSE;
	        #iqUDT_ConveyorInterface.Disconnected := FALSE;
	        #iqUDT_ConveyorInterface.ConfigurationError := FALSE;
	    END_IF;
	    
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_PEC"
TITLE = FB_PEC
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : Conveyor
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 219
// END_ATTRIBUTES
   VAR_INPUT 
      ix_PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Signal of the PEC
      iUDT_PECConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";   // PEC configuration structure
   END_VAR

   VAR_OUTPUT 
      qx_PECFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PEC Filtered
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";   // Status structure
   END_VAR

   VAR_IN_OUT 
      iqUDT_ConveyorInterface : "UDT_ConveyorInterface";   // Interface structure
      iqUDT_PECStatistics : "UDT_PECStatistics";   // Statistics structure
   END_VAR

   VAR 
      s_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatus";   // Status structure
      s_StatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatus";   // Auxiliary status structure
      sx_Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Enable
   END_VAR
   VAR RETAIN
      si_AuxJamDisplacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Auxiliary variable to calculate displacement when PEC is blocked
   END_VAR
   VAR 
      sx_PECFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Photo eye filtered
      PEC_TimerOnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Filtering end of section photo eye signal
      R_TRIG_PECJam {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger PEC jam
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	04/10/2019  | 2.0       | S. Nikodem    | first release TIA 15.1
	09/10/2019  | 2.1       | L.Klar        | Internal PEC error added
	28/10/2019  | 2.2       | S. Nikodem    | Change sign in region 2 - equal to greater then
	29/10/2019  | 2.3       | L.Klar        | UDT_PECStatus output variable changed, interface comments adjusted
	29/10/2019  | 2.4       | L.Klar        | Region 4 - time input corrected
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	26/11/2019  | 3.1       | P.Majka       | Static variable name change to PEC from EOS PEC
	12/12/2019  | 3.2       | C. Leite      | Absolute displacement value to control jam error in both directions
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	12/03/2024  | 4.1       | S. Nieswiec   | Small variable name changes according to current standard  
	*)
	
	REGION 1 - Triggers
	    
	    // Rising edge PEC Jam
	    #R_TRIG_PECJam(CLK := #s_Status.Jam);
	    
	END_REGION
	
	REGION 2 - Active function  
	    
	    // To activate the jam monitoring the jam displacement limit  must be configured up to zero. 
	    #sx_Enable := #iUDT_PECConfiguration.JamDisplacementLimit > 0;
	    
	END_REGION
	
	REGION 3 - Reset errors
	    
	    // Jam error is reset when reset bit is active and jam error is active and is connfigured alllow reset jam with PEC blocked or photo eye is not active
	    IF #iqUDT_ConveyorInterface.InternalErrorReset
	        AND (#iUDT_PECConfiguration.ResetWithPECBlocked
	        OR (NOT #iUDT_PECConfiguration.ResetWithPECBlocked
	        AND #sx_PECFiltered))
	        AND #s_Status.Jam
	    THEN
	        
	        #si_AuxJamDisplacement := 0;
	        #s_Status.Jam := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Photo eye filters
	    
	    // End of section photo eye signal filter timer
	    #PEC_TimerOnOffDelay(iudi_OnDelayTime := #iUDT_PECConfiguration.TimeOnDelay,
	                         iudi_OffDelayTime := #iUDT_PECConfiguration.TimeOffDelay,
	                         ix_SignalToDelay := #ix_PEC,
	                         ix_Enable := TRUE,
	                         qx_DelayedSignal => #sx_PECFiltered);
	    
	    // Write the current status of the photo eye
	    #s_Status.PEC := #sx_PECFiltered;
	    #qx_PECFiltered := #sx_PECFiltered;
	    
	END_REGION
	
	REGION 5 - Jam detection   
	    
	    IF NOT #sx_PECFiltered                                                    // Photo eye blocked
	        AND #sx_Enable                                                            // Active of checking the PEC jam 
	    THEN
	        
	        #si_AuxJamDisplacement += ABS(#iqUDT_ConveyorInterface.Displacement);
	        
	    ELSE
	        
	        #si_AuxJamDisplacement := 0;
	        
	    END_IF;
	    
	    // Compare jam auxiliary counter with displacement jam configured
	    IF #si_AuxJamDisplacement > #iUDT_PECConfiguration.JamDisplacementLimit
	    THEN
	        
	        #s_Status.Jam := TRUE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Statistics
	    
	    // Statistics Jam PEC
	    IF #s_Status.Jam                                                                // PEC jam error active
	        OR #iqUDT_ConveyorInterface.ResetStatistics                                       // Reset statistics
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #s_Status.Jam,
	                        ix_RTrigActivate := #R_TRIG_PECJam.Q,
	                        iqUDT_Statistics := #iqUDT_PECStatistics.Jam);
	        
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Internal PEC error
	    
	    IF #s_Status.Jam
	    THEN
	        
	        #iqUDT_ConveyorInterface.InternalErrorPEC := TRUE;
	        
	    END_IF;
	    
	END_REGION
	
	
	REGION 8 - Status
	    
	    // Status update on change
	    IF #s_StatusOld <> #s_Status
	    THEN
	        
	        #qUDT_HMIStatus := #s_Status;
	        #s_StatusOld := #s_Status;
	        
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

TYPE "UDT_RIOVSUStatus"
VERSION : 0.1
   STRUCT
      PNSlaveNotOnline { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet slave is not online
      PNSlaveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet slave has an error
      "400VCircuitBreaker" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 400V Circuit breaker has tripped
      BrakeCircuitBreaker { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Brake Circuit breaker has tripped
      BrakeThermalError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Brake of the servo unit is giving a thermal error
      "24VPowersupplyError" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 24V power supply is in error
      ET200sp_ErrorModule : Array[0..31] of Bool;   // True = ET200sp Module has an error or is offline
      PNSlaveWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet slave has a warning
   END_STRUCT;

END_TYPE

TYPE "UDT_VSUInterface"
TITLE = UDT_VSUInterface
VERSION : 0.1
//User-defined structure of VSU interface parameters.
   STRUCT
      Decisionpoint : Int;   // Point in tracking where the destination is found on the VSU conveyor [mm]
      RequestedPosition : Int;   // Position Requested by destination block
      PositionSetpoint : Int;   // Position number (as configured) to go to by positioning device
      PositionActual : Int;   // Position number the positioning device is actually on
      SwitchingTime : UInt;   // Time it takes to go from one position to the next [ms]
      VSUMainPowerOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True = Main power for VSU ok
      BrakeOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True = VSU brake is ok
      PNDeviceOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Device ok
      Automatic { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Automatic mode request
      RunEnabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Running of the positioning device is enabled by VSU
      GoReference { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate reference run by VSU
      Referenced { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Positioning device is referenced
      Manual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual mode request
      Reference_command { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Refference command
      JogUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Jog request to move equipment up
      JogDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Jog request to move equipment down
      Ready { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Positioning block is running and error free
      MotorRunning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor is running
      Positioning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // positioning device is moving to its position
      ResetStatistics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset statistics
      InternalErrorRIOPanel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // RIO panel has an internal error
      InternalWarningRIOPanel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // RIO panel has an internal waring
      InternalErrorVFD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // positioning device internal error
      InternalWarningVFD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // positioning device has a warning
      InternalErrorReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset internal faults
      StartLowSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Positioning device starting in low speed
      RequestDieBackUpstream { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External request die back to the upstream conveyor of the VSU
      ExternalHold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External request to stop the VSU conveyor
   END_STRUCT;

END_TYPE

TYPE "UDT_VfdPositioningStatus"
TITLE = UDT_VfdPositioningStatus
VERSION : 0.1
//User-defined structure of VFD SEW positioning status.
   STRUCT
      ErrorCode : Int;   // Error code
      SubErrorCode : Int;   // Sub error code
      PNSlaveNotOnline : Bool := FALSE;   // Profinet slave is not on line
      PNSlaveError : Bool := FALSE;   // Profinet slave has an error
      InternalError : Bool := FALSE;   // A VFD internal error is active, see error code
      InternalWarning : Bool := FALSE;   // A VFD internal warning is active, see error code
      CommunicationErrorMovikit : Bool := FALSE;   // Communication error with MoviKit
      PositioningTimeOutError : Bool := FALSE;   // Exceeded time to reach position
      PNSlaveWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet slave has a warning
   END_STRUCT;

END_TYPE

TYPE "UDT_VSULiftStatistics"
TITLE = UDT_VSUStatistics
VERSION : 0.1
//User-defined structure of FB_VerticalSwitch function block statistics.
   STRUCT
      UpTime { ExternalWritable := 'False'} : "UDT_EventStatistic";   // VSU up time
      DownTime { ExternalWritable := 'False'} : "UDT_EventStatistic";   // VSU down time
      ExitGapErr { ExternalWritable := 'False'} : "UDT_EventStatistic";   // Error statistics for VSU
      EntryGapErr { ExternalWritable := 'False'} : "UDT_EventStatistic";   // Error statistics for VSU
      BeltTear1Err { ExternalWritable := 'False'} : "UDT_EventStatistic";   // Error statistics for VSU
      BeltTear2Err { ExternalWritable := 'False'} : "UDT_EventStatistic";   // Error statistics for VSU
      MaintSupport1Err { ExternalWritable := 'False'} : "UDT_EventStatistic";   // Error statistics for VSU
      MaintSupport2Err { ExternalWritable := 'False'} : "UDT_EventStatistic";   // Error statistics for VSU
      UpperPositionErr { ExternalWritable := 'False'} : "UDT_EventStatistic";   // Error statistics for VSU
      LowerPositionErr { ExternalWritable := 'False'} : "UDT_EventStatistic";   // Error statistics for VSU
      SafetyDoorErr { ExternalWritable := 'False'} : "UDT_EventStatistic";   // Error statistics for VSU
      Direction_Error { ExternalWritable := 'False'} : "UDT_EventStatistic";   // Error statistics for VSU
   END_STRUCT;

END_TYPE

TYPE "UDT_VfdPositioningConfiguration"
TITLE = UDT_VfdPositioningConfiguration
VERSION : 0.1
//User defined stucture for configuring positioning device
   STRUCT
      TorqueMax : Real;   // VFD torque max - reference [Nm] as set up in SEW project
      SupplyFdbckOnDelayTime : UDInt;   // On delay time for supply feedback [ms]
      PositionWindow : DInt;   // Position window (tolerance) [mm]
      PositionMax : DInt;   // Maximum allowed position [mm]
      PositionMin : DInt;   // Minimum allowed position [mm]
      VFDSpeed : Int;   // Speed to run in automatic mode [mm/s]
      VFDAccDecel : Int;   // Acceleration and deceleration [mm/s2]
      VFDPNDeviceName : String;   // VFD's device name
      Position : Array[0..10] of DInt;   // Positions in mm to move to as requested
   END_STRUCT;

END_TYPE

TYPE "UDT_VfdSEWSpeedPO"
TITLE = UDT_VFD_SEW_PO
VERSION : 0.1
//User-defined structure of VFD SEW output telegram.
   STRUCT
      Control_Word_1 : Struct   // Control Word 1
         ResetError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset error "1"
         BIT_09_Reserved { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         ActivateDriveTrain2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate drive train 2 "1"
         BIT_11_Reserved { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         DeactivateSW_LimitSwitch { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Deactivate software limit switch "1"
         ActivateInhibit { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate inhibit "1"
         ActivateStandby { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate standby "1"
         MovikitHandshakeIn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // If the MOVIKIT works the value will be copied into "MovikitHandshakeOut"
         EnableRapidStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Enable “1” / Rapid stop “0”
         EnableApplicationStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Enable “1” / Application stop “0”
         BIT_02_Reserved { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         ReleaseBrake { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Release brake "1"
         JogPos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Jog in positive direction "1"
         JogNeg { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Jog in negative direction "1"
         ApplyRelativePositioning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Take the relative position from the FCB09 "1"
         StartStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start "1" / Stop "0"
      END_STRUCT;
      SetpointSpeed : Int;   // Speed (Int) in rpm
      SetpointAcceleration : Int;   // Acceleration (Int) in rpm/s
      SetpointDeceleration : Int;   // Decceleration (Int) in rpm/s
   END_STRUCT;

END_TYPE

TYPE "UDT_AixPlcFullControllerConfiguration"
TITLE = UDT_VFD_Configuration
VERSION : 0.1
//User-defined structure oparameters.
   STRUCT
      AixContrlPNDeviceName { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Ai2's Controller Profinet device name
      Motor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RampUpTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt := 100;   // Ramp up time for monitoring starting [ms]
         RampDownTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt := 100;   // Ramp up time for monitoring stopping [ms]
         SpeedSetpointWindow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 5;   // Speed setpoint window (tolerance) [mm/s]
         Ratio { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real := 1.0;   // Ratio conveyor roller to driven roller
         DirectionReversal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True = direction will be reversed
         InterlockFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;   // False = running in forward direction is not possible / allowed
         InterlockRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // False = running in reverse direction is not possible / allowed
         MotorExist { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True = Motor output connected
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_AixPlcFullIn"
VERSION : 0.1
   STRUCT
      ConveyStopStatus { ExternalVisible := 'False'} : Struct   // Status of ConveyStop
         Bit08 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit09 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         StopActiveCommandPLC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stop active due to stop command from the PLC
         Bit11 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit12 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit13 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit14 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit15 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit00 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit02 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit03 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit04 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         StopActiveOtherModule { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stop condition is active on a module in the ConveyStop group
         StopActiveLostConn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stop is active due to a loss of communication connection
         StopActiveLostPLC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stop active due to a loss of connection with the PLC
      END_STRUCT;
      AllSensorPortInputs { ExternalVisible := 'False'} : Struct   // Left and Right Sensor Port inputs
         Bit08 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit09 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit10 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit11 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit12 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit13 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit14 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Heartbeat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // This bit toggles every 2 seconds
         LeftPin2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left sensor port Pin2 state
         Bit01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         RightPin2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right sensor port Pin2 state
         Bit03 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         LeftSensor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left sensor port Pin4 state
         Bit05 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         RightSensor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right sensor port Pin4 state
         Bit07 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
      END_STRUCT;
      SensorDetect { ExternalVisible := 'False'} : Struct   // Sensor detection
         Bits08_15 { ExternalVisible := 'False'} : SInt;   // Reserved
         RightSensorDetect { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True when sensor is detected
         LeftSensorDetect { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True when sensor is detected
         Bit02 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit03 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit04 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit05 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit06 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit07 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
      END_STRUCT;
      VoltageMotors { ExternalVisible := 'False'} : Int;   // The Voltage applied to the module's motor power connection in millivolts
      LeftMotorCurrent { ExternalVisible := 'False'} : Int;   // Left motor running current in milliamperes
      LeftMotorFreq { ExternalVisible := 'False'} : Int;   // Left motor running electrical frequency in Hz
      LeftMotorCalcTemp { ExternalVisible := 'False'} : Byte;   // Left motor temperature in degrees C
      ModuleTemp { ExternalVisible := 'False'} : Byte;   // Module CPU temperature in degrees C
      LeftMotorDiagnostic { ExternalVisible := 'False'} : Struct   // Left motor diagnostics .
         Overheat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left motor temperature has exceeded 105 degrees Celsius
         MaxTorque { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left motor at maximum torque output
         ShortCircuit { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left motor short circuit
         MotorNotConnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left motor is not connected
         Overload { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left motor overloaded after more than 20 seconds in Stalled
         Stalled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left motor stalled and speed is less than 10% of the set speed
         BadHall { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left motor Hall Effect Sensor error active
         MotorNotUsed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left motor not used
         MotorStatus1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left motor running and direction status
         MotorStatus2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left motor running and direction status
         MotorPortinDOmode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left motor port is in digital Output mode .
         ReservedBit03 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         ReservedBit04 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         BoardOverheat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Board temperature has exceeded 90 degrees Celsius
         OverVoltage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Supply voltage + motor back EMF exceeded 30 volts
         LowVoltage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Module power supply is less than 18 Volts
      END_STRUCT;
      RightMotorCurrent { ExternalVisible := 'False'} : Int;   // Right motor running current in milliamperes
      RightMotorFreq { ExternalVisible := 'False'} : Int;   // Right motor running electrical frequency in Hz
      RightMotorCalcTemp { ExternalVisible := 'False'} : Byte;   // Right motor temperature in degrees Celsius
      ModuleTemp1 { ExternalVisible := 'False'} : Byte;   // Module PCB temperature in degrees C (same as ModuleTemp tag)
      RightMotorDiagnostic { ExternalVisible := 'False'} : Struct   // Right motor diagnostics .
         Overheat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right motor temperature has exceeded 105 degrees Celsius
         MaxTorque { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right motor at maximum torque output
         ShortCircuit { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right motor short circuit
         MotorNotConnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right motor is not connected
         Overload { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right motor overloaded after more than 20 seconds in Stalled
         Stalled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right motor stalled and speed is less than 10% of the set speed
         BadHall { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right motor Hall Effect Sensor error active
         MotorNotUsed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right motor is not used
         MotorStatus1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right motor running and direction status
         MotorStatus2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right motor running and direction status
         MotorPortinDOmode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right motor port is in digital output mode .
         ReservedBit03 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         ReservedBit04 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         BoardOverheat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Board temperature has exceeded 90 degrees Celsius
         OverVoltage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Supply voltage + motor back EMF exceeded 30 volts
         LowVoltage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Module power supply is less than 18 Volts
      END_STRUCT;
      LeftMotorDIOstatus { ExternalVisible := 'False'} : Struct   // Status of Left M8 motor port when used as a digital IO
         Bit08 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit09 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit10 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit11 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         ShortCircuit { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Short circuit between +24V and any of the U,V,W phases
         Bit13 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit14 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit15 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bits00_07 { ExternalVisible := 'False'} : SInt;   // Reserved
      END_STRUCT;
      RightMotorDIOstatus { ExternalVisible := 'False'} : Struct   // Status of Right M8 motor port when used as a digital IO
         Bit08 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit09 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit10 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit11 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         ShortCircuit { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Short circuit between +24V and any of the U,V,W phases
         Bit13 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit14 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit15 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bits00_07 { ExternalVisible := 'False'} : SInt;   // Reserved
      END_STRUCT;
      UpstreamModuleStatus { ExternalVisible := 'False'} : Word;   // The ZPA status from the Upstream ConveyLinx module
      DownstreamModuleStatus { ExternalVisible := 'False'} : Word;   // The ZPA status from the Downstream ConveyLinx module
      TrackingFromUpstream { ExternalVisible := 'False'} : DWord;   // Tracking data from the Upstream ConveyLinx module
      Index18 { ExternalVisible := 'False'} : Word;   // Index
      ServoLocationLeft { ExternalVisible := 'False'} : Int;   // Left motor current location from 0 in mm for MDR and in pulses for PGD
      ServoLocationRight { ExternalVisible := 'False'} : Int;   // Right motor current location from 0 in mm for MDR and in pulses for PGD
      ServoStatusLeft { ExternalVisible := 'False'} : Word;   // Left motor servo commands status
      ServoStatusRight { ExternalVisible := 'False'} : Word;   // Right motor servo commands status
      LeftMotorActualSpeed { ExternalVisible := 'False'} : Word;   // Bits 0 thru 13: Left motor actual speed in mm/sec, Bits 14-15: Status. For PGD, base unit is 1/10 RPM
      RightMotorActualSpeed { ExternalVisible := 'False'} : Word;   // Bits 0 thru 13: Left motor actual speed in mm/sec, Bits 14-15: Status. For PGD, base unit is 1/10 RPM
      Future { ExternalVisible := 'False'} : Array[25..31] of Int;   // Future
   END_STRUCT;

END_TYPE

TYPE "UDT_VfdSEWSpeedPI"
TITLE = UDT_VFD_SEW_PI
VERSION : 0.1
//User-defined structure of VFD SEW input telegram.
   STRUCT
      Status_Word_1 : Struct   // Status Word 1
         Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // An error is active "1"
         Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // A warning is active "1"
         DriveTrain2Active { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Drive train 2 is active "1"
         VelocityTargetActualComparison { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The notification "Velocity target-actual-comparison" is on "1"
         SW_LimitSwitchInactive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // he software limit switch is inactive "1"
         BIT_13_Reserved { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         StandbyActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Standby mode is active "1"
         MovikitHandshakeOut { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Copied value of "MovikitHandshakeIn"
         InverterReady { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // There's no error and the inverter is ready "1"
         STO_Inactive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // STO is not active "1"
         OutputStageEnabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The output stage is released "1"
         BrakeReleased { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The brake is released "1"
         DriveActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The drive is active and the shaft turning "1"
         Referenced { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The drive is referenced "1"
         RelativePositionApplied { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The relative position is applied "1"
         InPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The notification "in position" is on "1"
      END_STRUCT;
      ActualSpeed : Int;   // Actual drive speed (Int) in rpm
      StatusErrorNo : Word;   // Current status of the drive
      ActualTorque : Int;   // Actual torque in percent od the rated unit torque
   END_STRUCT;

END_TYPE

TYPE "UDT_StatisticsTC13"
VERSION : 0.1
//One direction, motor, EoS, Tracking
   STRUCT
      Conveyor : "UDT_ConveyorStatistics";   // Conveyor Statistics
      PEC_EoS : "UDT_PECUpdateStatistics";   // PEC EoS Statistics
      MCO_M01 : "UDT_VfdStatistics";   // MCO Statistics
   END_STRUCT;

END_TYPE

TYPE "UDT_StatisticsTC07"
VERSION : 0.1
//One direction, motor, controler, EoS, Stop blade
   STRUCT
      Conveyor : "UDT_ConveyorStatistics";   // Conveyor Statistics
      PEC_EoS : "UDT_PECStatistics";   // PEC EoS Statistics
      MCO_M01 : "UDT_VfdStatistics";   // MCO Statistics
      BladeStopEoS : "UDT_ValveStatistics";   // Blade stop EoS statistics
   END_STRUCT;

END_TYPE

TYPE "UDT_StatisticsTC02"
VERSION : 0.1
//One direction, motor, controler, EoS
   STRUCT
      Conveyor : "UDT_ConveyorStatistics";   // Conveyor Statistics
      PEC_EoS : "UDT_PECStatistics";   // PEC EoS Statistics
      MCO_M01 : "UDT_VfdStatistics";   // MCO Statistics
   END_STRUCT;

END_TYPE

TYPE "UDT_StatisticsTC03"
VERSION : 0.1
//One direction, motor, controler, EoS, Tracking
   STRUCT
      Conveyor : "UDT_ConveyorStatistics";   // Conveyor Statistics
      PEC_EoS : "UDT_PECUpdateStatistics";   // PEC EoS Statistics
      MCO_M01 : "UDT_VfdStatistics";   // MCO Statistics
   END_STRUCT;

END_TYPE

TYPE "UDT_HMICommandTC36"
VERSION : 0.1
//One direction, motor, controler
   STRUCT
      RightAngledTransfer : "UDT_RATCommand";   // Conveyor Statistics
   END_STRUCT;

END_TYPE

TYPE "UDT_HMICommandTCxx"
VERSION : 0.1
//One direction, motor, controler
   STRUCT
      Conveyor : "UDT_ConveyorCommand";   // Conveyor Statistics
   END_STRUCT;

END_TYPE

TYPE "UDT_RATConfiguration"
VERSION : 0.1
   STRUCT
      OutfeedTimeDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // PEC on delaytime
      InfeedTimeDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // PEC off delaytime
      SectionUpMonitoringTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt := 500;   // Runtime delay lifting device up signal on delay
      SectionDownMonitoringTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt := 500;   // Runtime delay lifting device down signal on delay
      BladeStopUpMonitoringTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt := 500;   // Runtime delay lifting blade stop up signal on delay
      BladeStopDownMonitoringTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt := 500;   // Runtime delay lifting blade stop down signal on delay
      InfeedADistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Distance between A infeed photoeye and place where we want to stop tail of product during infeed [mm]
      InfeedBDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Distance between B infeed photoeye and place where we want to stop tail of product during infeed [mm]
      InfeedCDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Distance between C infeed photoeye and place where we want to stop tail of product during infeed [mm]
      InfeedDDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Distance between D infeed photoeye and place where we want to stop tail of product during infeed [mm]
      InfeedTimeout { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt := 60000;   // The time after which an error is triggered when a package is not received [ms]
      ReactivationTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt := 30000;   // After this time RAT will be restarted if hang [ms]
      DefaultPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 0 = dont care, 1 = go down after, 2 = go up after
      DefaultDestination { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 1 = upstream conveyor default, 2 = downstream conveyor default, 3 = right conveyor default, 4 = left conveyor default, 0= wait until destination is received
      ConveyorADestination { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Unique Conveyor A outfeed destination number
      ConveyorBDestination { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Unique Conveyor B outfeed destination number
      ConveyorCDestination { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Unique Conveyor C outfeed destination number
      ConveyorDDestination { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Unique Conveyor D outfeed destination number
      ControlProductWithPEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;   // TRUE when product presence should be checked by the diagonal PEC
      BladeStopEoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;   // TRUE when blade stop at the end of section is present
      BladeStopBoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;   // TRUE when blade stop at the beginning of section is present
      PositionVerification { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;   // TRUE when position verification during movement is required
   END_STRUCT;

END_TYPE

TYPE "UDT_VfdSEWPositioningPI"
TITLE = UDT_VfdSEWPositioningPI
VERSION : 0.1
//User-defined structure of VFD SEW input telegram.
   STRUCT
      Status_Word_1 : Struct   // Status Word 1
         Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // An error is active "1"
         Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // A warning is active "1"
         DriveTrain2Active { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Drive train 2 is active "1"
         VelocityTargetActualComparison { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The notification "Velocity target-actual-comparison" is on "1"
         SW_LimitSwitchInactive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // he software limit switch is inactive "1"
         BIT_13_Reserved { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         StandbyActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Standby mode is active "1"
         MovikitHandshakeOut { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Copied value of "MovikitHandshakeIn"
         InverterReady { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // There's no error and the inverter is ready "1"
         STO_Inactive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // STO is not active "1"
         OutputStageEnabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The output stage is released "1"
         BrakeReleased { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The brake is released "1"
         DriveActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The drive is active and the shaft turning "1"
         Referenced { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The drive is referenced "1"
         RelativePositionApplied { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The relative position is applied "1"
         InPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The notification "in position" is on "1"
      END_STRUCT;
      ActualSpeed : Int;   // Actual drive speed (Int) [mm/s]
      StatusErrorNo : Word;   // Current status of the drive
      ActualTorque : Int;   // Actual torque in percent od the rated unit torque
      DigitalInput : Word;   // Digital inputs
      Mode : Int;   // Actual application mode (Int)
      ActualPosition_hW : Word;   // Actual position - High Word
      ActualPosition_lW : Word;   // Actual position - Low Word
   END_STRUCT;

END_TYPE

TYPE "UDT_HMICommandTC07"
VERSION : 0.1
//One direction, motor, controler
   STRUCT
      Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";   // Conveyor HMI commands
      BladeStopEoS { S7_SetPoint := 'False'} : "UDT_ValveCommand";   // Blade Stop EoS HMI commands
   END_STRUCT;

END_TYPE

TYPE "UDT_VSUCommand"
TITLE = UDT_VSUCommand
VERSION : 0.1
//User-defined structure of VSU commands.
   STRUCT
      SemiAutomaticMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Semiautomatic mode command from HMI
      ManualMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual mode command from HMI
      CommandUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command from HMI to go to upper position in semiautomatic or manual mode
      CommandDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command from HMI to go to lower position in semiautomatic or manual mode
      JogUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command from HMI to Jog upwards
      JogDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command from HMI to Jog downwards
      ReferenceRun { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command from HMI to reference drive
   END_STRUCT;

END_TYPE

TYPE "UDT_VfdConfiguration"
TITLE = UDT_VFD_Configuration
VERSION : 0.1
//User-defined structure oparameters.
   STRUCT
      GearRatio : Real;   // Gear box value X = turns at input to get 1 turn at output
      ReferenceRPM : Real;   // VFD speed max - reference [rpm]
      WheelEndPerimeter : Real;   // Perimeter of wheel at the end of gear [mm]
      VFDRampUpTime : UDInt;   // VFD ramp up time for monitoring starting [ms]
      VFDRampDownTime : UDInt;   // VFD ramp up time for monitoring stopping [ms]
      SpeedSetpointWindow : Int := 5;   // VFD speed setpoint window (tolerance) [mm/s]
      VFDPNDeviceName : String;   // VFD's Profinet device name
      DirectionReversal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // If true, direction will be swapped
      InterlockFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // False when turning in forward direction is not possible / allowed
      InterlockRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // False when turning in reverse direction is not possible / allowed
      VFDStartupTime : UDInt := 2000;   // Time when the motor should start [ms]
   END_STRUCT;

END_TYPE

TYPE "UDT_VSULiftConfiguration"
TITLE = UDT_VSUConfig
VERSION : 0.1
//User-defined structure of VSU parameters.
   STRUCT
      PEC_GapBeginOnDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Photo eye gap begin check time on delay [ms]
      PEC_GapBeginOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Photo eye  gap begin  check time off delay [ms]
      PEC_GapEndOnDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Photo eye gap end check time on delay [ms]
      PEC_GapEndOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Photo eye  gap end check time off delay [ms]
      JogNoHornTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt := 1000;   // Time within jog buttons can be pressed without new startup indication
      SwitchingTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt := 950;   // Time it takes to go from one position to the next [ms]
      DefaultPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 2;   // Default position number (2= up or 1= down) , If left 0 the block will go to 1
   END_STRUCT;

END_TYPE

TYPE "UDT_ValveConfiguration"
VERSION : 0.1
   STRUCT
      ControlMode : Int := 1;   // 1 = Hold ix_open to keep qx_open active, 2 = detects rising edge on ix_Open to Open, ix_Close to Close
      ValveType : Int := 1;   // 1 = SEV, 2 = DEV
      CloseFeedBackExist { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Valve has a feed back that signals when fully cLosed
      OpenFeedBackExist { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Valve has a feed back that signals when fully Open
      OpenTime : Int;   // estimated open time, will trigger FTO if open feedback exist and not detected
      CloseTime : Int;   // estimated close time, will trigger FTC if close feedback exist and not detected
   END_STRUCT;

END_TYPE

TYPE "UDT_UnknownGIN"
TITLE = UDT_UnknownGIN
VERSION : 0.1
//User-defined structure of unknown GIN range.
   STRUCT
      Start : Int := 1;   // Unknown GIN range start value
      End : Int := 199;   // Unknown GIN range end value
      GIN : Int := 0;   // Las generated unknown GIN
   END_STRUCT;

END_TYPE

TYPE "UDT_WSLStatistics"
VERSION : 0.1
   STRUCT
      "010" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "020" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "030" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "040" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "050" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "060" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "070" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "080" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "090" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "100" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "110" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "120" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "121" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATStatistics";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "210" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "220" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "221" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATStatistics";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "230" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "240" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "250" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "260" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "270" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "280" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "290" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "291" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATStatistics";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "300" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "410" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "420" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "421" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATStatistics";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "430" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "440" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "450" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "460" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "470" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "480" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "490" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "491" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATStatistics";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "500" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "610" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "611" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATStatistics";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "620" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "630" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "640" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_WSLHmiCommands"
VERSION : 0.1
   STRUCT
      "010" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "020" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "030" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "040" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "050" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "060" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "070" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "080" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "090" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "100" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "110" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "120" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "121" : Struct
         RightAngledTransfer { S7_SetPoint := 'False'} : "UDT_RATCommand";
      END_STRUCT;
      "210" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "220" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "221" : Struct
         RightAngledTransfer { S7_SetPoint := 'False'} : "UDT_RATCommand";
      END_STRUCT;
      "230" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "240" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "250" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "260" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "270" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "280" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "290" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "291" : Struct
         RightAngledTransfer { S7_SetPoint := 'False'} : "UDT_RATCommand";
      END_STRUCT;
      "300" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "410" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "420" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "421" : Struct
         RightAngledTransfer { S7_SetPoint := 'False'} : "UDT_RATCommand";
      END_STRUCT;
      "430" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "440" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "450" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "460" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "470" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "480" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "490" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "491" : Struct
         RAT { S7_SetPoint := 'False'} : "UDT_RATCommand";
      END_STRUCT;
      "500" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "610" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "611" : Struct
         RightAngledTransfer { S7_SetPoint := 'False'} : "UDT_RATCommand";
      END_STRUCT;
      "620" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "630" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "640" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_WSLConfiguration"
VERSION : 0.1
   STRUCT
      GlobalConfig { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         LeftStationExists { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;
         RightStationExists { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;
      END_STRUCT;
      "010" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "020" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "030" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "040" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "050" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "060" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "070" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "080" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "090" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "100" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "110" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "120" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "121" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "210" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "220" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "221" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "230" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "240" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "250" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "260" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "270" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "280" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "290" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "291" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "300" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "410" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "420" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "421" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "430" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "440" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "450" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "460" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "470" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "480" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "490" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "491" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "500" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "610" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "611" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "620" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "630" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "640" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_WSLStatus"
VERSION : 0.1
   STRUCT
      "010" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "020" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "030" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "040" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "050" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "060" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "070" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "080" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "090" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "100" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "110" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "120" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "121" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATStatus";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "210" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "220" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "221" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATStatus";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "230" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "240" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "250" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "260" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "270" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "280" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "290" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "291" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATStatus";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "300" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "410" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "420" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "421" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATStatus";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "430" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "440" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "450" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "460" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "470" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "480" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "490" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "491" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATStatus";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "500" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "610" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "611" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATStatus";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "620" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "630" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "640" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_TGWLiftPI"
VERSION : 0.1
   STRUCT
      ix_SafetyDoorDownDiag : Bool;   // Safety door 1 diagnosis (Lower door)
      ix_MainContactorFeedbackOn : Bool;   // Main Contactor Feedback
      ix_ManualMode : Bool;   // Key-operated switch in manual mode
      ix_AutoMode : Bool;   // Key-operated switch in automatic mode
      ix_JogDown : Bool;   // Push button Jog down
      ix_JogUp : Bool;   // Push button Jog up
      ix_Reset : Bool;   // Push button Reset
      ix_LiftConveyorFwd : Bool;   // Push button lift conveyor foward
      ix_Reference : Bool;   // Pushbutton start lift vertical reference
      ix_InfeedConveyor : Bool;   // Pushbutton infeed conveyor
      ix_LiftConveyorRvs : Bool;   // Push button lift conveyor reverse
      ix_OutfeedConveyor : Bool;   // Pushbutton outfeed conveyor
      ix_SafetyDoorUpDiag : Bool;   // Safety door 1 diagnosis (Upper door)
      Spare_1 : Bool;
      ix_OverTempBrakeRes : Bool;   // Over temperature braking resistor
      Spare_2 : Bool;
      ix_LimSwitchDown : Bool;   // Limit switch down
      ix_LimSwitchUp : Bool;   // Limit switch up
      ix_BeltTearLeft : Bool;   // Belt tear detector left
      ix_BeltTearRight : Bool;   // Belt tear detector right
      ix_MainSwitchCabinetOn : Bool;   // Control panel main switch is on
      ix_F1002ok : Bool;   // Circuit breaker tripped +S1 400 VAC
      ix_F1400ok : Bool;   // Circuit breaker tripped +S1 24 VDC
      ix_MaintenanceSwitchUpOn : Bool;   // Maintenance Switch is on
   END_STRUCT;

END_TYPE

TYPE "UDT_WSLCommonStatus"
VERSION : 0.1
   STRUCT
      "010" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "020" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "030" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "040" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "050" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "060" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "070" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "080" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "090" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "100" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "110" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "120" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "121" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "210" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "220" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "221" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "230" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "240" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "250" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "260" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "270" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "280" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "290" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "291" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "300" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "410" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "420" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "421" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "430" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "440" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "450" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "460" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "470" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "480" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "490" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "491" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "500" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "610" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "611" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "620" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "630" { ExternalWritable := 'False'} : "UDT_CommonStatus";
      "640" { ExternalWritable := 'False'} : "UDT_CommonStatus";
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_SickDemoo"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      ix_Trigger { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      HWInputIdent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_IO := 714;   // Hardware identification number of the input module
      HWInputLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt := 32;   // Size of the input module
      HWOutputIdent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_IO := 716;   // Hardware identification number of the output module
      HWOutputLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt := 32;   // Size of the output module
      CANId { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt := 0;   // CAN ID (0= Master / No CAN network)
   END_VAR

   VAR_OUTPUT 
      qs_Barcode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
   END_VAR

   VAR 
      IDB_Lector6xx { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "SICK_Lector_CLV6xx_PNDP";
      sa_Inteface { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Outputs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
            RdDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
            ReqDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
            ReqBusy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
            Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
            Errorcode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DWord;
         END_STRUCT;
         InOut { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
            Data { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "ST_SICK_Lector_CLV6xx";
         END_STRUCT;
         stEdge { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Edge detection flags
            xEdgeTrigger { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
            xEdgeMatchcode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
            xEdgeDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
            xEdgeError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
            xEdgeTriggerMem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
            xEdgeDoneMem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
            xEdgeErrorMem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
            xEdgeMatchcodeMem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         END_STRUCT;
         xTrigger { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start read tag command
         xMatchcode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         xTriggerDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Read tag done
         xMatchcodeDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         sReadingResult { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[200];   // Read content
         stLector { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "ST_SICK_Lector_CLV6xx";   // RFU data
         arrReadingResult { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..199] of Byte;   // Read content backup
      END_STRUCT;
      sR_TRIG_Trigger {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      si_GoodRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_No_Read { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
   END_VAR


BEGIN
	(*----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Function for interacting with Sick  Scanner                                         |
	|                                                                                      |
	|                                                                                      |
	----------------------------------------------------------------------------------------
	
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	15/11/2023  | 0.1       | S.Nieswiec    | First release
	19/06/2023  | 0.2       | S.Nieswiec    | Changes for BOR site
	25/06/2024  | 0.3       | I.BouAjram    | HW parameters passed from Inputs instead of using hard coding inside the block
	                                        | use of static variables to capture the inputs and outputs of the block
	*)
	
	
	
	#sR_TRIG_Trigger(CLK := #ix_Trigger);
	
	REGION Scaner Reading & Sorting
	    
	    
	    IF #iqUDT_EquipmentControl.Command.Reset THEN
	        #sa_Inteface.xTriggerDone := FALSE;
	        #sa_Inteface.xTrigger := FALSE;
	    END_IF;
	    
	    IF #sR_TRIG_Trigger.Q THEN
	        #sa_Inteface.xTrigger := TRUE;
	    END_IF;
	    
	    
	    
	    IF #sa_Inteface.xTriggerDone THEN
	        
	        #sa_Inteface.xTrigger := FALSE;
	        #sa_Inteface.xTriggerDone := FALSE;
	        
	        IF #sa_Inteface.sReadingResult[1] = '!' THEN
	            #si_No_Read += 1;
	            #qs_Barcode := 'NoRead';
	        ELSE
	            #si_GoodRead += 1;
	            
	            "FC_ExtractCodeFromString"(is_String := #sa_Inteface.sReadingResult,
	                                       qs_String => #qs_Barcode);
	            
	        END_IF;
	    END_IF;
	    
	    
	    
	END_REGION
	
	REGION Sick Demo Code
	    (*=========================================================================
	Name: SICK Lector6xx / CLV6xx PROFINET demo
	Author: SICK AG
	===========================================================================
	This demo program enables you open a reading gate using a software trigger
	via the SICK Lector/CLV6xx function block. Furthermore it is possible to 
	create a new evaluation condition using the "Matchcode" command.
	
	The Lector6xx 2D code reader is connected via PROFINET to a Siemens 
	S7-1200 PLC.
	
	Open a reading gate:
	Set the "xTrigger" variable open a reading gate. Please configure the 
	device in way, that the reading gate is automatically closed by a 
	"good read" condition or after 5 seconds. The "xTriggerDone" flag 
	indicates a successful execution of the function and an incoming 
	reading result. The "sReadingResult" variable contains the reading 
	result (defined in the SOPAS output format) as a string value.
	
	Matchcode:
	Set the "xMatchcode" variable to create a new matchcode (myMatch) in 
	the evaluation conditions of the device. The "xMatchcodeDone" flag 
	indicates a successful execution of the function.
	
	Please use the "Example" watch table to control the program. Use the 
	other watch tables to perform further functions of the FB.
	
	The same example can also been used for a CLV6xx barcode scanner. Please 
	configure in this case a CLV6xx instead of a Lector6xx device in
	the hardware configuration of your PLC (GSD settings). 
	=========================================================================*)
	(*Function block call*)
	    #IDB_Lector6xx(HWInputIdent := #HWInputIdent,
	                   HWInputLength := #HWInputLength,
	                   HWOutputIdent := #HWOutputIdent,
	                   HWOutputLength := #HWOutputLength,
	                   CANId := #CANId,
	                   TOut := T#10s,
	                   // Req := #sa_Inteface.Inputs.Req,
	                   // TriggerOn := #sa_Inteface.Inputs.TriggerOn,
	                   // TriggerOff := #sa_Inteface.Inputs.TriggerOff,
	                   // Matchcode := #sa_Inteface.Inputs.Matchcode,
	                   // SavePermanent:= #sa_Inteface.Inputs.SavePermanent,
	                   // ComTest := #sa_Inteface.Inputs.ComTest,
	                   // FreeCommand := #sa_Inteface.Inputs.FreeCommand,
	                   
	                   Data := #sa_Inteface.InOut.Data,
	                   RdDone => #sa_Inteface.Outputs.RdDone,
	                   ReqDone => #sa_Inteface.Outputs.ReqDone,
	                   ReqBusy => #sa_Inteface.Outputs.ReqBusy,
	                   Error => #sa_Inteface.Outputs.Error,
	                   Errorcode => #sa_Inteface.Outputs.Errorcode
	                   
	                   
	    );
	    
	(*Edge detection*)
	    #sa_Inteface.stEdge.xEdgeTrigger := #sa_Inteface.xTrigger AND NOT #sa_Inteface.stEdge.xEdgeTriggerMem;
	    #sa_Inteface.stEdge.xEdgeTriggerMem := #sa_Inteface.xTrigger;
	    #sa_Inteface.stEdge.xEdgeMatchcode := #sa_Inteface.xMatchcode AND NOT #sa_Inteface.stEdge.xEdgeMatchcodeMem;
	    #sa_Inteface.stEdge.xEdgeMatchcodeMem := #sa_Inteface.xMatchcode;
	    #sa_Inteface.stEdge.xEdgeDone := #sa_Inteface.Outputs.ReqDone AND NOT #sa_Inteface.stEdge.xEdgeDoneMem;
	    #sa_Inteface.stEdge.xEdgeDoneMem := #IDB_Lector6xx.ReqDone;
	    #sa_Inteface.stEdge.xEdgeError := #IDB_Lector6xx.Error AND NOT #sa_Inteface.stEdge.xEdgeErrorMem;
	    #sa_Inteface.stEdge.xEdgeErrorMem := #sa_Inteface.Outputs.Error;
	    
	(*Function block init: Clear all selection bits*)
	    IF (#sa_Inteface.stEdge.xEdgeTrigger OR #sa_Inteface.stEdge.xEdgeMatchcode) AND NOT #IDB_Lector6xx.ReqBusy THEN
	        //Clear status bits of the example
	        #sa_Inteface.xTriggerDone := FALSE;
	        #sa_Inteface.xMatchcodeDone := FALSE;
	        
	        //Clear selection bits of the function block
	        #IDB_Lector6xx.TriggerOn := FALSE;
	        #IDB_Lector6xx.TriggerOff := FALSE;
	        #IDB_Lector6xx.Matchcode := FALSE;
	        #IDB_Lector6xx.SavePermanent := FALSE;
	        #IDB_Lector6xx.ComTest := FALSE;
	        #IDB_Lector6xx.FreeCommand := FALSE;
	    END_IF;
	    
	(*Start triger device (open the reading gate)*)
	    IF #sa_Inteface.stEdge.xEdgeTrigger AND NOT #IDB_Lector6xx.ReqBusy THEN
	        #IDB_Lector6xx.TriggerOn := TRUE; //Select: Trigger on
	        #IDB_Lector6xx.Req := TRUE; //Start action
	    END_IF;
	    
	(*Start matchcode (creates a new matchcode evaluation condition*)
	    IF #sa_Inteface.stEdge.xEdgeMatchcode AND NOT #IDB_Lector6xx.ReqBusy THEN
	        #sa_Inteface.stLector.Matchcode.sName := 'MyMatch'; //Name of the matchcode condition
	        #sa_Inteface.stLector.Matchcode.nCodeType := '*'; // Code type ('*' = don't care)
	        #sa_Inteface.stLector.Matchcode.iMinMaxLength := 20; //Min and max length code
	        #sa_Inteface.stLector.Matchcode.sContent := 'Sensor Intelligence.'; //Code content
	        
	        #IDB_Lector6xx.Matchcode := TRUE; //Select: Matchcode
	        #IDB_Lector6xx.Req := TRUE; //Start action
	    END_IF;
	    
	(*Incoming reading result*)
	    IF #IDB_Lector6xx.ReqDone THEN
	        IF #sa_Inteface.xTrigger THEN
	            //Copy the data from the reading result structure to a separate array
	            //Only necessary for old S7-1200 controls to parse the data into a string 
	            MOVE_BLK(IN := #sa_Inteface.stLector.ReadingResult.arrResult[1],
	                     COUNT := INT_TO_UINT(#sa_Inteface.stLector.ReadingResult.iLength),
	                     OUT => #sa_Inteface.arrReadingResult[0]);
	            
	            // Tranfer the data into a string variable
	            Chars_TO_Strg(Chars := #sa_Inteface.arrReadingResult,
	                          pChars := 0,
	                          Cnt := 0,
	                          Strg => #sa_Inteface.sReadingResult);
	            
	            #sa_Inteface.xTriggerDone := TRUE;
	            #sa_Inteface.xTrigger := FALSE;
	        END_IF;
	    END_IF;
	    
	(*Lector action done*)
	    IF #sa_Inteface.stEdge.xEdgeDone THEN
	        IF #sa_Inteface.xMatchcode THEN
	            #sa_Inteface.xMatchcodeDone := TRUE;
	            #sa_Inteface.xMatchcode := FALSE;
	        END_IF;
	        
	(*Error detected*)
	    ELSIF #sa_Inteface.stEdge.xEdgeError THEN
	        ; //Error handling. The "Errorcode" variable gives your more information about the occured error
	    END_IF;
	    
	    
	    #IDB_Lector6xx.Req := FALSE; //Clear request bit every PLC cycle
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_CountActiveInputs"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 195
// END_ATTRIBUTES
   VAR_INPUT 
      ix_Input1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Bool input 1
      ix_Input2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Bool input 2
      ix_Input3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Bool input 3
      ix_Input4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Bool input 4
      ix_Input5 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Bool input 5
      ix_Input6 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Bool input 6
      ix_Input7 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Bool input 7
      ix_Input8 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Bool input 8
      ix_Input9 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Bool input 9
      ix_Input10 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Bool input 10
      ix_Input11 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Bool input 11
      ix_Input12 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Bool input 12
      ix_Input13 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Bool input 13
      ix_Input14 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Bool input 14
      ix_Input15 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Bool input 15
      ix_Input16 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Bool input 16
   END_VAR

   VAR_OUTPUT 
      qi_ActiveInputsCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Number of active inputs
   END_VAR

   VAR 
      si_I { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // FOR Loop index
      sa_BoolArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..16] of Bool;   // Use an array for the Boolean inputs
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	22/01/2024  | 1.00      | J.Majer       | Initial version
	12/03/2024  | 1.00      | S. Nieswiec       | Changed ActiveInputsCount to qi_ActiveInputsCount
	*)
	
	REGION 1 - Initialize counter
	    // On every start of scan initialize output
	    #qi_ActiveInputsCount := 0;
	    
	END_REGION ;
	REGION 2 - Map inputs to array of bool
	    // Map inputs into static array of bools
	    
	    #sa_BoolArray[1] := #ix_Input1;
	    #sa_BoolArray[2] := #ix_Input2;
	    #sa_BoolArray[3] := #ix_Input3;
	    #sa_BoolArray[4] := #ix_Input4;
	    #sa_BoolArray[5] := #ix_Input5;
	    #sa_BoolArray[6] := #ix_Input6;
	    #sa_BoolArray[7] := #ix_Input7;
	    #sa_BoolArray[8] := #ix_Input8;
	    #sa_BoolArray[9] := #ix_Input9;
	    #sa_BoolArray[10] := #ix_Input10;
	    #sa_BoolArray[11] := #ix_Input11;
	    #sa_BoolArray[12] := #ix_Input12;
	    #sa_BoolArray[13] := #ix_Input13;
	    #sa_BoolArray[14] := #ix_Input14;
	    #sa_BoolArray[15] := #ix_Input15;
	    #sa_BoolArray[16] := #ix_Input16;
	    
	END_REGION ;
	
	REGION 2 - Start active bool counter
	    // with FOR loop search for active bits in array structure and add +1 to output if an input is TRUE
	    
	    FOR #si_I := 1 TO 16 DO
	        IF #sa_BoolArray[#si_I] THEN
	            #qi_ActiveInputsCount := #qi_ActiveInputsCount + 1;
	        END_IF;
	    END_FOR;
	    
	END_REGION ;
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_DataLogicBlade"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 261
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_DataLogic { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_DataLogic_IN";   // Data from camera
      ix_trigger { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Trigger - Activate barcode scanning inside this function
   END_VAR

   VAR_OUTPUT 
      qUDT_DataLogic { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_DataLogic_OUT";   // Data from PLC to camera
      qs_Barcode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // String barcode
      qw_RetVal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Error code (W#16#...): A - TimeOut; B - Bit from camera "Result available" blocked; C - NO READ; C5 - 5 NO READ in row;  C0 - Empty data from camera; D - Camera Connection Lost; E - incorrect camera config.
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";
   END_VAR

   VAR 
      ss_LastResults { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Copy of last result reading barcode value
         DataBarCode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..15] of Char;   // Last barcode
      END_STRUCT;
      ss_Statistic { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // All statistics
         st_ActReadingFromCameraTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;   // Actual time measurement from trigger to get data from camera
         st_PrevReadingFromCameraTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;   // Previous time measurement from trigger to get data from camera
         st_ShortestReadingTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;   // The shortest time of reading data from camera  (only OK READ)
         st_LongestReadingTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;   // The longest time of reading data from camera  (only OK READ)
         st_AvgReadingTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;   // Average time of reading data from camera (only OK READ)
         st_SumOfTimesOkRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;   // Sum of all OK READ times - for use in average
         st_ActTimeToNextReady { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;   // Time from trigger to get next high state on bit "Trigger Ready" from camera
         si_OK_READ_CounterGeneral { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Total number of correct readings
         si_TimeOut_CounterGeneral { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Total number of timeouts
         si_NO_READ_CounterGeneral { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Total number of NO READ
         si_NO_READ_CounterInRow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Number of No READ in a row (after 5 generate error)
      END_STRUCT;
      ss_prev_Barcode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Previous barcode to compare with the current one to identify a new read
      sdt_TimeStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Date_And_Time;   // Time value read when "phaseOFF"
      sdt_TimeStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Date_And_Time;   // Time value read when trigger occures.
      sdt_TimeOutTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Date_And_Time;   // Constant time measuring for timeout
      st_DiffTimeOutTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;   // Time difference: #sdt_TimeOutTime and #sdt_TimeStart.
      st_TimeDiff { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;   // Time defference: #sdt_TimeStop and #sdt_TimeStart
      sw_ErrorCode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Error code
      s_R_TRIG_Trigger {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger signal
      s_R_TRIG_StatisticActCycleTime {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for (#R_TRIG_Result_available.Q OR #sx_ErrorTimeOut)
      s_R_TRIG_NoReadCounter {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for general counter NO_READ
      s_R_TRIG_OkReadCounter {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for general counter OK_READ
      s_R_TRIG_TimeOutCounter {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for general counter TimeOut
      s_R_TRIG_EdgeErrorTimeOut {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for error TimeOut
      s_R_TRIG_ResetStatistics {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for ResetStatistics
      s_R_TRIG_FirstScan {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for mask error TimeOut in first trigger
      s_FB_TimerOnOffDelay_Instance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      s_FB_TimerOnOffDelay_Instance_TimeOut_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sx_lastResultOK_READ { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Variable that keeps the OK_READ state of the last scan.
      sx_lastResultNO_READ { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Variable that keeps the NO_READ state of the last scan.
      sx_BUSY { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Function is processing data (set with trigger, reset at the end of processing data from the camera)
      sx_InternalTrigger { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Internal trigger to keep the BladeTrigger active as long as needed.
      sx_PhaseON { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Signal from the camera given when it is scanning
      sx_PhaseOFF { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Signal from the camera given when it finishes scanning.
      sx_RecivedData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Variable used to store information about the occurrence of "PhaseOFF".
      sx_GeneralFault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Any error sets this bit
      sx_ErrorTimeOut { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Begin measuring time with trigger and finish when camera activate "Results Available". Time set up in constants
      sx_Inter_NO_READ { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // This bit is set when the first character of barcode is '$$'
      sx_Inter_OK_READ { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // This bit is set when the first character of barcode is '!'
      sx_ReceiveNewData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // This bit is set when the value of the barcode changes (current compared to previous).
      sx_MemoryInterTrig { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Memory for trigger activation
      sx_FirstTrigger { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // With the first trigger, this bit is set and the program begins to count statistics.
      sx_FirstScan { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      FB_TimerOnOffDelay_Instance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
   END_VAR

   VAR_TEMP 
      ti_TimeCalculation : Int;   // Auxiliary variable for time calculation
   END_VAR

   VAR CONSTANT 
      ct_TimeOut : Time := T#20MS;   // TimeOut form Trigger to For camera in DataMan configured 50ms
      ct_PulsTriggerDuration : Time := T#1S;   // Scaning timer. Camera during thise time is scanning and when finish send all codes what read. [ms]
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|  Stevia Automation Sp.z.o.o                                                          |                         
	|  Copyright  2024                                                                     |
	|  All Rights Reserved                                                                 |
	                                                                                       |     
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author             | Remark
	----------------------------------------------------------------------------------------
	23/5/2024   | 0.1       | Grzegorz Czekała    | first release TIA Portal 17 (upd 6)
	24/5/2024   | 0.2       | Grzegorz Czekała    | Change names from Blade200 to "Blade" (this function is universal for both Blade200 and Blade100).
	12/6/2024   | 1.0       | Grzegorz Czekała    | Change the timers, the way the barcode process works. Stop using signals from the camera (OK and NOK). 
	                                              | Instead, compare the current barcode with the previous one and check the first character ($$ for OK, ! for NO_READ).
	                                              | Change type of timers on FB_TimerOnOffDelay. Reset all statistic changed from Reset to ResetData in DB_Control
	*)
	
	REGION 1.0 - Decoding signals from camera and clear temps
	    
	    #sx_PhaseON := #iUDT_DataLogic.DataFromCamera.%X3;
	    #sx_PhaseOFF := #iUDT_DataLogic.DataFromCamera.%X4;
	    
	    #ti_TimeCalculation := 0;
	    
	END_REGION
	
	REGION 2.0 - Activate trigger PLC output (camera Blade input)
	    
	    #s_R_TRIG_Trigger(CLK := #ix_trigger);  //Rising edge trigger signal
	    #s_R_TRIG_EdgeErrorTimeOut(CLK := #sx_ErrorTimeOut); //Rising edge recive data from camera
	    #s_R_TRIG_FirstScan(CLK := #sx_FirstScan); //Rising edge for mask first scan time out
	    
	    
	    
	    // Activate camera trigger when:, input trigger is activated and previous process is completed
	    IF #s_R_TRIG_Trigger.Q
	        AND NOT #qUDT_DataLogic.BladeTrigger
	        AND NOT #sx_PhaseON
	        AND NOT #sx_PhaseOFF
	        AND NOT #sx_BUSY
	        AND NOT #sx_InternalTrigger
	    THEN
	        #sx_InternalTrigger := TRUE;
	        #sx_BUSY := TRUE;   // process in progress
	        #sx_ErrorTimeOut := FALSE;
	        #sx_RecivedData := FALSE;
	        #sw_ErrorCode := 16#0;
	        #sx_Inter_NO_READ := FALSE;
	        #sx_Inter_OK_READ := FALSE;
	        #sx_FirstTrigger := TRUE;
	    END_IF;
	    
	    REGION 2.1 - Triger duration control
	        
	        IF #sx_InternalTrigger
	        THEN
	            #sx_MemoryInterTrig := true;
	        END_IF;
	        
	        // Control trigger duration
	        #s_FB_TimerOnOffDelay_Instance(iudi_OnDelayTime := TIME_TO_UDINT(#ct_PulsTriggerDuration),
	                                       ix_SignalToDelay := #sx_MemoryInterTrig,
	                                       ix_Enable := TRUE);
	        
	        
	        IF #s_FB_TimerOnOffDelay_Instance.qx_DelayedSignal
	        THEN
	            #sx_MemoryInterTrig := FALSE;
	            
	        END_IF;
	        
	        #qUDT_DataLogic.BladeTrigger := #sx_MemoryInterTrig;
	        
	        
	        // Mask the first time out error, first check result performed value of "ct_TimeOut" before timeout
	        #FB_TimerOnOffDelay_Instance(iudi_OnDelayTime := TIME_TO_UDINT(#ct_PulsTriggerDuration),
	                                     ix_SignalToDelay := #sx_FirstTrigger,
	                                     qx_DelayedSignal => #sx_FirstScan);
	        
	    END_REGION
	    
	    
	END_REGION
	
	REGION 3.0 - Get data from camera
	    
	    //Important information
	    // Comment for testers: This program can't detect the same barcode twice. When testing, use two or more barcodes alternately.
	    //By default, the camera sends data to the PLC when it finishes calculating.
	    //When connected to DL.CODE software, it calculates immediately, but when it is NOT connected (during normal operation),
	    //it takes about 60 ms to finish calculating after "PhaseOFF".
	    //So, it is important to set up "Send DataOn" /PhaseOFF in DL.CODE. You can find this in "Step2/Good Read Setup -> right side menu".
	    // Camera 
	    
	    REGION 3.1 - Copy the last barecode from camera
	        
	        // Copy last result barcode value to DB
	        MOVE_BLK(IN := #iUDT_DataLogic.BarCodeValue[1],
	                 COUNT := 14,
	                 OUT => #ss_LastResults.DataBarCode[1]);
	        
	        IF NOT #sx_FirstTrigger AND NOT #sx_ReceiveNewData
	        THEN
	            FILL_BLK(IN := 1,
	                     COUNT := 14,
	                     OUT => #ss_LastResults.DataBarCode[0]);
	        END_IF;
	        
	        // Conversion from char to string 
	        Chars_TO_Strg(Chars := #ss_LastResults.DataBarCode,
	                      pChars := 1,
	                      Cnt := 0,
	                      Strg => #qs_Barcode);
	        
	        
	    END_REGION
	    
	    
	    REGION 3.2 - Control OF NO_READ OR OK_READ sign
	        // When the barcode value changes or a time error occurs, it means a new reading has finished (either successfully or not).
	        IF #sx_FirstTrigger
	            AND (NOT (#ss_prev_Barcode = #qs_Barcode)
	            OR #s_R_TRIG_EdgeErrorTimeOut.Q)
	            OR #s_R_TRIG_FirstScan.Q
	        THEN
	            IF NOT #s_R_TRIG_EdgeErrorTimeOut.Q
	            THEN
	                #sx_ReceiveNewData := true;
	            END_IF;
	            
	            
	            // Copy Last Result NO_READ sign
	            #ss_LastResults.DataBarCode[0] := #iUDT_DataLogic.BarCodeValue0;
	            
	            // Check NO_READ sign 
	            IF #ss_LastResults.DataBarCode[0] = '!'
	            THEN
	                #sx_Inter_NO_READ := TRUE;
	                #sx_Inter_OK_READ := FALSE;
	            END_IF;
	            
	            // Check OK_READ sign 
	            IF (#ss_LastResults.DataBarCode[0] = '$$')
	                AND NOT #sx_ErrorTimeOut
	            THEN
	                #sx_Inter_OK_READ := TRUE;
	                #sx_Inter_NO_READ := FALSE;
	            END_IF;
	            
	            
	        END_IF;
	    END_REGION
	    
	    REGION 3.3 Storing information OK_READ NO_READ
	        // from the last read FOR analysis purposes
	        IF #sx_ReceiveNewData THEN
	            #sx_lastResultOK_READ := #sx_Inter_OK_READ;
	            #sx_lastResultNO_READ := #sx_Inter_NO_READ;
	        END_IF;
	    END_REGION
	    
	    #ss_prev_Barcode := #qs_Barcode;  // Copy actual value of barecode for the next cycle comparission 
	    
	END_REGION
	
	REGION 4.0 - Statistics 
	    
	    REGION 4.1 - Counting OK_READ for calculate averege time
	        
	        // Countup OK_READ
	        
	        #s_R_TRIG_OkReadCounter(CLK := #sx_Inter_OK_READ); //Rising edge of recived OK_READ - has to be here
	        
	        IF #s_R_TRIG_OkReadCounter.Q
	        THEN
	            #ss_Statistic.si_OK_READ_CounterGeneral += 1;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 4.2 - TimeOut error 
	        
	        // Copy the start time when the trigger occurs
	        IF #sx_InternalTrigger
	        THEN
	            #ti_TimeCalculation := RD_SYS_T(#sdt_TimeStart);
	        END_IF;
	        
	        // Copy the the end time when the PhaseOff occures
	        IF #sx_ReceiveNewData
	        THEN
	            #sx_RecivedData := TRUE;  // Info that ReceiveNewData
	            #ti_TimeCalculation := RD_SYS_T(#sdt_TimeStop);
	            #st_TimeDiff := T_DIFF(IN1 := #sdt_TimeStop, IN2 := #sdt_TimeStart); // subtracts the times
	        END_IF;
	        
	        //Constant time measuring
	        #ti_TimeCalculation := RD_SYS_T(#sdt_TimeOutTime);
	        #"st_DiffTimeOutTime" := T_DIFF(IN1 := #sdt_TimeOutTime, IN2 := #sdt_TimeStart); // subtracts the times
	        
	        // When the time from trigger to receiving new data is longer than
	        // (trigger duration + ct_TimeOut), it means a Time Out Error has occurred.
	        IF NOT #sx_RecivedData
	            AND (#"st_DiffTimeOutTime"
	            > (#ct_TimeOut + #ct_PulsTriggerDuration))
	        THEN
	            #sx_ErrorTimeOut := TRUE;
	        END_IF;
	        
	        // Counts TimeOut errors
	        IF #s_R_TRIG_EdgeErrorTimeOut.Q
	        THEN
	            #ss_Statistic.si_TimeOut_CounterGeneral += 1;
	        END_IF;
	        
	        
	    END_REGION
	    
	    REGION 4.3 - Time statistics
	        
	        // Time measured from trigger to ReceiveNewData occures
	        #s_R_TRIG_StatisticActCycleTime(CLK := #sx_ReceiveNewData OR #s_R_TRIG_EdgeErrorTimeOut.Q); // This R_Trig have to be here
	        
	        // Sending the time only once in the event of receiving data or exceeding the timeout.
	        IF #s_R_TRIG_StatisticActCycleTime.Q
	        THEN
	            #ss_Statistic.st_PrevReadingFromCameraTime := #ss_Statistic.st_ActReadingFromCameraTime;
	            #ss_Statistic.st_ActReadingFromCameraTime := #st_TimeDiff;
	            
	        END_IF;
	        
	        REGION 4.3.1 - Longest and shortest reading time for OK_READs
	            
	            // Statistics include only OK_READ process
	            IF #sx_Inter_OK_READ AND #sx_ReceiveNewData
	            THEN
	                // Chceck the longest time
	                IF #ss_Statistic.st_ActReadingFromCameraTime > #ss_Statistic.st_LongestReadingTime
	                THEN
	                    #ss_Statistic.st_LongestReadingTime := #ss_Statistic.st_ActReadingFromCameraTime;
	                END_IF;
	                
	                // When PLC startup the shortest time is 0ms, so we put there other start shortest time value
	                IF #ss_Statistic.st_ShortestReadingTime < T#1ms
	                THEN
	                    #ss_Statistic.st_ShortestReadingTime := #ss_Statistic.st_ActReadingFromCameraTime;
	                END_IF;
	                
	                // Chceck the shortest time
	                IF (#ss_Statistic.st_ActReadingFromCameraTime < #ss_Statistic.st_ShortestReadingTime)
	                THEN
	                    #ss_Statistic.st_ShortestReadingTime := #ss_Statistic.st_ActReadingFromCameraTime;
	                END_IF;
	                
	                // Calculate averege Time OF OK_READs
	                #ss_Statistic.st_SumOfTimesOkRead := #ss_Statistic.st_SumOfTimesOkRead + #ss_Statistic.st_ActReadingFromCameraTime;
	                #ss_Statistic.st_AvgReadingTime := #ss_Statistic.st_SumOfTimesOkRead / #ss_Statistic.si_OK_READ_CounterGeneral;
	                
	            END_IF;
	            
	        END_REGION
	    END_REGION
	    
	    REGION 4.4 - Counting NO_READ and NO_READ in a row
	        #s_R_TRIG_NoReadCounter(CLK := #sx_Inter_NO_READ); // This R_Trig has to be here
	        
	        IF #sx_Inter_OK_READ
	        THEN
	            #ss_Statistic.si_NO_READ_CounterInRow := 0;
	        END_IF;
	        
	        
	        IF #s_R_TRIG_NoReadCounter.Q
	        THEN
	            #ss_Statistic.si_NO_READ_CounterGeneral += 1;
	            #ss_Statistic.si_NO_READ_CounterInRow += 1;
	        END_IF;
	        
	    END_REGION
	END_REGION
	
	REGION 5.0 - THE END - Resets bits AND is READY TO next trigger
	    
	    #sx_InternalTrigger := FALSE;  // Reset on the end first cycle
	    
	    IF #sx_BUSY
	        AND #sx_ReceiveNewData OR #s_R_TRIG_EdgeErrorTimeOut.Q
	    THEN
	        #sx_BUSY := FALSE;
	        
	    END_IF;
	    
	    #sx_ReceiveNewData := FALSE;
	    
	END_REGION
	
	REGION 6.0 - Reset all statistics
	    
	    // Connects  signals from inputs to reset statistics (either by input bit or input UDT)
	    
	    #s_R_TRIG_ResetStatistics(CLK := #iqUDT_EquipmentControl.Command.ResetData);
	    
	    // Reset all statistic
	    IF #s_R_TRIG_ResetStatistics.Q
	    THEN
	        #ss_Statistic.st_ActReadingFromCameraTime := t#0ms;
	        #ss_Statistic.st_PrevReadingFromCameraTime := t#0ms;
	        #ss_Statistic.st_ShortestReadingTime := t#0ms;
	        #ss_Statistic.st_SumOfTimesOkRead := t#0ms;
	        #ss_Statistic.st_LongestReadingTime := t#0ms;
	        #ss_Statistic.st_ActTimeToNextReady := t#0ms;
	        #ss_Statistic.st_AvgReadingTime := t#0ms;
	        #ss_Statistic.si_OK_READ_CounterGeneral := 0;
	        #ss_Statistic.si_TimeOut_CounterGeneral := 0;
	        #ss_Statistic.si_NO_READ_CounterInRow := 0;
	        #ss_Statistic.si_NO_READ_CounterGeneral := 0;
	        #sx_FirstTrigger := FALSE;
	        #sx_FirstScan := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 7.0 - Errors CODE
	    
	    // Time out
	    IF #sx_ErrorTimeOut
	    THEN
	        #sx_GeneralFault := TRUE;
	        #sw_ErrorCode := 16#800A;
	        #sx_BUSY := FALSE;
	        #sx_PhaseON := FALSE;
	    END_IF;
	    
	    // NO READ
	    IF #sx_Inter_NO_READ
	    THEN
	        #sx_GeneralFault := TRUE;
	        #sw_ErrorCode := 16#800C;     // NO READ
	    END_IF;
	    
	    // 5 NO READ in a row
	    IF #ss_Statistic.si_NO_READ_CounterInRow >= 5
	    THEN
	        #sx_GeneralFault := TRUE;
	        #sw_ErrorCode := 16#805C;    // 5 NO READ in a row
	    END_IF;
	    
	    // Empty data from camera
	    IF (#sx_ReceiveNewData OR #s_R_TRIG_EdgeErrorTimeOut.Q) AND #ss_LastResults.DataBarCode[0] = '$00'
	    THEN
	        #sx_GeneralFault := TRUE;
	        #sw_ErrorCode := 16#80C0;    // Empty data from camera
	    END_IF;
	    
	    // Send error code to output
	    #qw_RetVal := #sw_ErrorCode;
	    
	END_REGION
	
	REGION 8.0 - Errors reset
	    
	    IF #iqUDT_EquipmentControl.Command.Reset
	    THEN
	        #sx_BUSY := FALSE;
	        #sx_GeneralFault := FALSE;
	        #sw_ErrorCode := 16#0000;
	        #sx_FirstTrigger := FALSE;
	        #sx_FirstScan := FALSE;
	    END_IF;
	    
	END_REGION
	
	
	
END_FUNCTION_BLOCK

TYPE "UDT_TGWLiftConfiguration"
VERSION : 0.1
   STRUCT
      "010" : Struct   // Lift Conveyor configuration
         Conveyor : "UDT_ConveyorConfiguration";   // Conveyor configuration
         PEC_BoS : "UDT_PECConfiguration";   // BoS configuration
         PEC_EoS : "UDT_PECConfiguration";   // EoS configuration
         VFD : "UDT_VfdConfiguration";   // VFD configuration
      END_STRUCT;
      "020" : Struct   // Vertical lift configuration
         VSU : "UDT_VSULiftConfiguration";   // VSU lift configuration
         VFD : "UDT_VfdPositioningConfiguration";   // VFD positioning configuration
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_Crossoverstatus"
VERSION : 0.1
   STRUCT
      Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Common divert status
      Specific { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Up { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Divert is in Upper position
         Down { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Divert is in lower position
         Reverse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor is running in reverse direction
         ErrAirpressureNotOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Airpressure is not signalling
         ErrRuntime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Divert took too long to move up or down
         ErrOverrun { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parcel is in guard PEC, it moved too far and cant be devided
         WarnAirPressure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Warning Airpressure is too low
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_CrossoverConfiguration"
VERSION : 0.1
   STRUCT
      OutfeedTimeOnDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // PEC on delaytime
      OutfeedTimeOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // PEC off delaytime
      LiftRuntimeUpOnDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Runtime delay lifting device up signal on delay
      LiftRuntimeUpOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Runtime delay lifting device up signal off delay
      LiftRuntimeDownOnDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Runtime delay lifting device down signal on delay
      LiftRuntimeDownOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Runtime delay lifting device down signal off delay
      ParcelDefaultLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 600;   // Default length of parcel
      OutfeedLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 500;   // Length feeding out
      RollerConveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Lower deck settings
         ConveyorLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length of conveyor
         LengthFrom1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 100;   // Offset length to position in [cm] when feeding from conveyor
         LengthFrom2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 100;   // Offset length to position in [cm] when feeding from conveyor
         Runfwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;   // When true conveyor is running forward to feed in
      END_STRUCT;
      BeltConveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Upper deck settings
         ConveyorLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length of conveyor
         LengthFrom3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 100;   // Offset length to position in [cm] when feeding from conveyor
         LengthFrom4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 100;   // Offset length to position in [cm] when feeding from conveyor
         Runfwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;   // When true conveyor is running forward to feed in
      END_STRUCT;
      Conveyor1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Conveyor 1 settings ( set to true is present )
         IsInfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;   // Is upstream conveyor
         IsOutfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Is downstream conveyor
      END_STRUCT;
      Conveyor2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Conveyor 2 settings ( set to true is present )
         IsInfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Is upstream conveyor
         IsOutfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;   // Is downstream conveyor
      END_STRUCT;
      Conveyor3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Conveyor 3 settings ( set to true is present )
         IsInfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;   // Is upstream conveyor
         IsOutfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Is downstream conveyor
      END_STRUCT;
      Conveyor4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Conveyor 4 settings ( set to true is present )
         IsInfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;   // Is upstream conveyor
         IsOutfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Is downstream conveyor
      END_STRUCT;
   END_STRUCT;

END_TYPE

FUNCTION "FC_HMDecodeHeader" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 41
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_FifoMsg : "UDT_Message";   // Buffer for FIFO's message
   END_VAR

   VAR_OUTPUT 
      qUDT_MSG : "UDT_HMMessageHeader";   // Messade header structure
   END_VAR

   VAR_TEMP 
      ts_MessageHeader : String[15];
      ti_SizeOfMsg : Int;
      ti_Position : Int;
   END_VAR

   VAR CONSTANT 
      cc_DL : Char := '$1D';   // Comma sign
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	27/10/2021  | 0.1       | J.Krawczuk    | first release MHS TIA 15.1
	18/11/2021  | 0.2       | M.Piela       | Interface changes
	*)
	
	REGION - 1 Header decode
	    
	    
	    #qUDT_MSG.STX := #iUDT_FifoMsg.Character[0];
	    
	    Chars_TO_Strg(Chars := #iUDT_FifoMsg.Character,
	                  pChars := 1,
	                  Cnt := 4,
	                  Strg => #qUDT_MSG.PLCID);
	    
	    Chars_TO_Strg(Chars := #iUDT_FifoMsg.Character,
	                  pChars := 6,
	                  Cnt := 8,
	                  Strg => #qUDT_MSG.SequenceNumber);
	    
	    Chars_TO_Strg(Chars := #iUDT_FifoMsg.Character,
	                  pChars := 15,
	                  Cnt := 15,
	                  Strg => #ts_MessageHeader);
	    
	    #ti_Position := FIND(IN1 := #ts_MessageHeader, IN2 := #cc_DL);
	    
	    Chars_TO_Strg(Chars := #iUDT_FifoMsg.Character,
	                  pChars := 15,
	                  Cnt := INT_TO_UINT(#ti_Position - 1),
	                  Strg => #qUDT_MSG.MessageHeader);
	    
	END_REGION
	
	
	
END_FUNCTION

TYPE "UDT_PushUpDivertCommand"
VERSION : 0.1
   STRUCT
      ManualStartStop : Bool;   // Run conveyor in manual mode
      ManualFullSpeed : Bool;   // Full speed conveyor in manual mode
      ManualJog : Bool;   // Command to jog conveyor in slow speed from HMI
      Reverse : Bool;   // Command to run conveyor in reverse direction from HMI
      ManualSpeed : Int := 50;   // Manual mode speed as percentage of nominal speed [0-100%]
      ManualMode : Bool;   // Manual mode command from HMI
      ManualUp : Bool;   // Command to move devise up
      ManualDown : Bool;   // Command to move devise down
   END_STRUCT;

END_TYPE

TYPE "UDT_PushUpDivertStatus"
VERSION : 0.1
   STRUCT
      Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Common divert status
      Specific { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Up { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Divert is in Upper position
         Down { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Divert is in lower position
         Reverse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor is running in reverse direction
         ErrAirpressureNotOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Airpressure is not signalling
         ErrRuntime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Divert took too long to move up or down
         ErrOverrun { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parcel is in guard PEC, it moved too far and cant be devided
         WarnAirPressure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Warning Airpressure is too low
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_PushUpDivertConfiguration"
VERSION : 0.1
   STRUCT
      PECTriggerTimeOnDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : UDInt;   // Time after which PEC full is detected
      PECTriggerTimeOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : UDInt;   // Time after which PEC full is released
      PECLeftTimeOnDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : UDInt;   // Time after which PEC full is detected
      PECLeftTimeOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : UDInt;   // Time after which PEC full is released
      PECRightTimeOnDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : UDInt;   // Time after which PEC full is detected
      PECRightTimeOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : UDInt;   // Time after which PEC full is released
      DivertMonitorUpOnDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : UDInt := 1000;   // Time after which sensor up is detected
      DivertMonitorUPOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : UDInt;   // Time after which sensor up is released
      DivertMonitorDownOnDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : UDInt := 1000;   // Time after which sensor down is detected
      DivertMonitorDownOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : UDInt;   // Time after which sensor down is released
      "Conveyor length" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Int := 1000;   // Length of the conveyor [mm]
      DecisionPoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Int := 1000;   // Point of decision [mm]
      ParcelDefaultLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Int := 600;   // Default length of the parcel if none was measured in [mm]
      LengthIn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Int := 450;   // Length travelling in [mm]
      LengthOut { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Int := 450;   // Length travelling out [mm]
      PositionOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Int;   // Offset to position parcel to compensate speed and weight
      SizeDivert { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool := TRUE;   // When true divert is done based on dimension of parcel
   END_STRUCT;

END_TYPE

TYPE "UDT_NerakLiftStatistics"
VERSION : 0.1
   STRUCT
      ProductFellDown : "UDT_EventStatistic";
      CollisionDetected : "UDT_EventStatistic";
      EnergySave : "UDT_EventStatistic";   // Number of times that save energy mode occurs
      ConveyorUp : "UDT_EventStatistic";   // Conveyor up statistics
      ConveyorDown : "UDT_EventStatistic";   // Conveyor down statistics
      ConveyorStop : "UDT_EventStatistic";   // Conveyor down statistics
   END_STRUCT;

END_TYPE

TYPE "UDT_WSGConfiguration"
VERSION : 0.1
   STRUCT
      GlobalConfig { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         LeftStationExists { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;
         RightStationExists { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;
      END_STRUCT;
      "010" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "020" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, 0, 500, 1000, FALSE, FALSE);
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "021" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, 0, 500, 1000, FALSE, FALSE);
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "110" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), (), (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "120" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), (), (), 500, 1000, FALSE, ());
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "130" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "140" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, 0, 500, 1000, FALSE, FALSE);
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "141" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, 0, 500, 1000, FALSE, FALSE);
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_RATConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "150" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateConfiguration" := (600, 300, 5, 5, (), (), 50, 50, (), (), (), 1, 5, (), (), (), ());
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "160" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, 0, 500, 1000, FALSE, FALSE);
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateConfiguration" := (600, 300, 5, 5, TRUE, FALSE, 50, 50, 1, 5, 0, 1, 5, FALSE, FALSE, FALSE, FALSE);
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "170" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateConfiguration" := (600, 300, 5, 5, (), (), 50, 50, (), (), (), 1, 5, (), (), (), ());
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "180" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateConfiguration" := (600, 300, 5, 5, (), (), 50, 50, (), (), (), 1, 5, (), (), (), ());
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "190" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateConfiguration" := (600, 300, 5, 5, (), (), 50, 50, (), (), (), 1, 5, (), (), (), ());
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "210" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, 0, 500, 1000, FALSE, FALSE);
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "211" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, 0, 500, 1000, FALSE, FALSE);
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_RATConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "220" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, 0, 500, 1000, FALSE, FALSE);
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "221" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, 0, 500, 1000, FALSE, FALSE);
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_RATConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "230" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, (), 500, 1000, FALSE, ());
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "310" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration" := (600, 300, 5, 5, ());
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "320" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration" := (600, 300, 5, 5, ());
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "330" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration" := (600, 300, 5, 5, ());
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "340" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration" := (600, 300, 5, 5, ());
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "350" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration" := (600, 300, 5, 5, ());
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "510" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, (), 500, 1000, FALSE, ());
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "520" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECUpdateConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "530" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECUpdateConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "540" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, 0, 500, 1000, FALSE, FALSE);
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "541" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, 0, 500, 1000, FALSE, FALSE);
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_RATConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "550" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateConfiguration" := (600, 300, 5, 5, (), (), 50, 50, (), (), (), 1, 5, (), (), (), ());
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "560" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, 0, 500, 1000, FALSE, FALSE);
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateConfiguration" := (600, 300, 5, 5, TRUE, FALSE, 50, 50, 1, 5, 0, 1, 5, FALSE, FALSE, FALSE, FALSE);
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "570" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateConfiguration" := (600, 300, 5, 5, (), (), 50, 50, (), (), (), 1, 5, (), (), (), ());
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "580" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateConfiguration" := (600, 300, 5, 5, (), (), 50, 50, (), (), (), 1, 5, (), (), (), ());
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "590" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateConfiguration" := (600, 300, 5, 5, (), (), 50, 50, (), (), (), 1, 5, (), (), (), ());
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "610" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, 0, 500, 1000, FALSE, FALSE);
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "611" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, 0, 500, 1000, FALSE, FALSE);
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_RATConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "620" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, 0, 500, 1000, FALSE, FALSE);
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "621" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, 0, 500, 1000, FALSE, FALSE);
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_RATConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "630" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, (), 500, 1000, FALSE, ());
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "710" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration" := (600, 300, 5, 5, ());
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "720" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration" := (600, 300, 5, 5, ());
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "730" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration" := (600, 300, 5, 5, ());
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "740" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration" := (600, 300, 5, 5, ());
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "750" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), ()), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration" := (600, 300, 5, 5, ());
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_NerakLiftPO"
VERSION : 0.1
   STRUCT
      qx_PowerRelease { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Release main contactor 17Q1
      "qx_spare_0.1" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      qx_ReadyLamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // LED lamp GREEN - Ready
      "qx_spare_0.3" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      qx_FaultLamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // LED lamp RED - Fault
      "qx_spare_0.5" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      "qx_spare_0.6" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      "qx_spare_0.7" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_STRUCT;

END_TYPE

TYPE "UDT_NerakLiftPI"
VERSION : 0.1
   STRUCT
      ix_PowerOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // -10F1, -12F1 and -12Q1 are switched ON
      ix_ManualDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Push button manual DOWN
      ix_ManualMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Key switch manual mode
      ix_FaultReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Push button reset fault
      ix_AutomaticMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Key switch automatic mode
      "ix_spare_0.5" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ix_ManualUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Push button manual UP
      ix_B11ColisionControl { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sensor -B11 Collisiion control top
      ix_B1Infeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sensor  -B1 Infeed occupied
      "ix_B3.3FallingThrought" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sensor -B3.3 Falling through control 
      ix_B2_CollisionControl { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sensor -B2 Collision at infeed
      ix_B4TailbackControlFront { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sensor -B4 Outfeed occupied
      "ix_B3.1FallingThrought" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sensor -B3.1 Falling through control 
      ix_B5TailbackControlBack { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sensor -B4 Product before Outfeed 
      "ix_B3.2FallingThrought" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sensor -B3.2 Falling through control 
      ix_B10_PlatforninPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sensor -B10 Platform in position to start infeed
      ix_DoorSwitchBottom { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Door switch bottom -16S3 diagnostic
      "ix_spare_2.1" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ix_DoorSwitchTop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Door switch up -16S4 diagnostic
      "ix_spare_2.3" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      "ix_spare_2.4" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      "ix_spare_2.5" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      "ix_spare_2.6" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      "ix_spare_2.7" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_STRUCT;

END_TYPE

TYPE "UDT_NerakLiftConfiguration"
VERSION : 0.1
   STRUCT
      Mode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 1 - lowering mode 2 - lifting mode
      CollisionSensorDelayOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Collision sensor delay on
      CollisionSensorDelayOff { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Collision sensor delay off
      FallingThroughSensorDelayOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Falling through sensor delay on
      FallingThroughSensorDelayOff { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Falling through sensor delay off
      TailbackControlFrontSensorDelayOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Tailback control front sensor delay on
      TailbackControlFrontSensorDelayOff { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Tailback control front sensor delay off
      TailbackControlRearSensorDelayOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Tailback control rear sensor delay on
      TailbackControlRearSensorDelayOff { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Tailback control rear sensor delay off
      PlatformPositionSensorDelayOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Platform position sensor delay on
      PlatformPositionSensorDelayOff { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Platform position sensor delay off
      PlatformLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 759;   // Platform length [mm]
      Length { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := 6000;   // Distance to be traveled by the package from start to end[mm]
      EnergySaveLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := 10000;   // Distance to run before energy saving is activated [cm]
      PEC_EoSDistanceOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := 300;   // Position to stop during dieback [mm]
      CascadeTimeOnDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt := 200;   // Cascade start delay
      FirstConveyorToStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;   // Lift first to start in cascade
      SpeedSetpointNominal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 1000;   // Speed setpoint nominal
      Energy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;   // TRUE when energy saving mode enable
   END_STRUCT;

END_TYPE

TYPE "UDT_WSGCommunicationWES"
VERSION : 0.1
   STRUCT
      LeftWorkstation : Struct   // Communication with left side of station
         StartIndexing : Bool;   // Request to start indexing
         Station1 : Struct
            Gin : Int;   // Message from station1
            Barcode : String;
            Error : Bool;
            ReadyForPush : Bool;   // Request to start automatic push out
         END_STRUCT;
         Station2 : Struct
            Gin : Int;   // Message from station1
            Barcode : String;
            Error : Bool;
            ReadyForPush : Bool;   // Request to start automatic push out
         END_STRUCT;
         Station3 : Struct
            Gin : Int;   // Message from station1
            Barcode : String;
            Error : Bool;
            ReadyForPush : Bool;   // Request to start automatic push out
         END_STRUCT;
         Station4 : Struct
            Gin : Int;   // Message from station1
            Barcode : String;
            Error : Bool;
            ReadyForPush : Bool;   // Request to start automatic push out
         END_STRUCT;
         Station5 : Struct
            Gin : Int;   // Message from station1
            Barcode : String;
            Error : Bool;
            ReadyForPush : Bool;   // Request to start automatic push out
         END_STRUCT;
      END_STRUCT;
      RightWorkstation : Struct   // Communication with left side of station
         StartIndexing : Bool;   // Request to start indexing
         Station1 : Struct
            Gin : Int;   // Message from station1
            Barcode : String;
            Error : Bool;
            ReadyForPush : Bool;   // Request to start automatic push out
         END_STRUCT;
         Station2 : Struct
            Gin : Int;   // Message from station1
            Barcode : String;
            Error : Bool;
            ReadyForPush : Bool;   // Request to start automatic push out
         END_STRUCT;
         Station3 : Struct
            Gin : Int;   // Message from station1
            Barcode : String;
            Error : Bool;
            ReadyForPush : Bool;   // Request to start automatic push out
         END_STRUCT;
         Station4 : Struct
            Gin : Int;   // Message from station1
            Barcode : String;
            Error : Bool;
            ReadyForPush : Bool;   // Request to start automatic push out
         END_STRUCT;
         Station5 : Struct
            Gin : Int;   // Message from station1
            Barcode : String;
            Error : Bool;
            ReadyForPush : Bool;   // Request to start automatic push out
         END_STRUCT;
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_WSGCommonStatus"
VERSION : 0.1
   STRUCT
      "010" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "020" : "UDT_CommonStatus";
      "021" : "UDT_CommonStatus";
      "110" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "120" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "130" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "140" : "UDT_CommonStatus";
      "141" : "UDT_CommonStatus";
      "150" : "UDT_CommonStatus";
      "160" : "UDT_CommonStatus";
      "170" : "UDT_CommonStatus";
      "180" : "UDT_CommonStatus";
      "190" : "UDT_CommonStatus";
      "210" : "UDT_CommonStatus";
      "211" : "UDT_CommonStatus";
      "220" : "UDT_CommonStatus";
      "221" : "UDT_CommonStatus";
      "230" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "310" : "UDT_CommonStatus";
      "320" : "UDT_CommonStatus";
      "330" : "UDT_CommonStatus";
      "340" : "UDT_CommonStatus";
      "350" : "UDT_CommonStatus";
      "510" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "520" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "530" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "540" : "UDT_CommonStatus";
      "541" : "UDT_CommonStatus";
      "550" : "UDT_CommonStatus";
      "560" : "UDT_CommonStatus";
      "570" : "UDT_CommonStatus";
      "580" : "UDT_CommonStatus";
      "590" : "UDT_CommonStatus";
      "610" : "UDT_CommonStatus";
      "611" : "UDT_CommonStatus";
      "620" : "UDT_CommonStatus";
      "621" : "UDT_CommonStatus";
      "630" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "710" : "UDT_CommonStatus";
      "720" : "UDT_CommonStatus";
      "730" : "UDT_CommonStatus";
      "740" : "UDT_CommonStatus";
      "750" : "UDT_CommonStatus";
   END_STRUCT;

END_TYPE

TYPE "UDT_WSGStatus"
VERSION : 0.1
   STRUCT
      "010" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS : "UDT_PECStatus";
         MCO_M01 : "UDT_AixControllerStatus";
      END_STRUCT;
      "020" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS : "UDT_PECStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "021" : Struct
         RightAngledTransfer { S7_SetPoint := 'False'} : "UDT_RATStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "110" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS : "UDT_PECUpdateStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "120" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS : "UDT_PECStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "130" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS : "UDT_PECUpdateStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "140" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS : "UDT_PECStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "141" : Struct
         RightAngledTransfer { S7_SetPoint := 'False'} : "UDT_RATStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "150" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS : "UDT_PECUpdateStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "160" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS : "UDT_PECUpdateStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "170" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS : "UDT_PECUpdateStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "180" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS : "UDT_PECUpdateStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "190" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS : "UDT_PECUpdateStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "210" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS { S7_SetPoint := 'False'} : "UDT_PECStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "211" : Struct
         RightAngledTransfer { S7_SetPoint := 'False'} : "UDT_RATStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "220" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS { S7_SetPoint := 'False'} : "UDT_PECStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "221" : Struct
         RightAngledTransfer { S7_SetPoint := 'False'} : "UDT_RATStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "230" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "310" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS : "UDT_PECStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "320" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS : "UDT_PECStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "330" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS : "UDT_PECStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "340" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS { S7_SetPoint := 'False'} : "UDT_PECStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "350" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS : "UDT_PECStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "510" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "520" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS : "UDT_PECUpdateStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "530" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS : "UDT_PECUpdateStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "540" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS : "UDT_PECStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "541" : Struct
         RightAngledTransfer { S7_SetPoint := 'False'} : "UDT_RATStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "550" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS : "UDT_PECUpdateStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "560" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS : "UDT_PECUpdateStatus";
         MCO_M01 : "UDT_AixControllerStatus";
      END_STRUCT;
      "570" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS : "UDT_PECUpdateStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "580" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS : "UDT_PECUpdateStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "590" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS : "UDT_PECUpdateStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "610" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS { S7_SetPoint := 'False'} : "UDT_PECStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "611" : Struct
         RightAngledTransfer { S7_SetPoint := 'False'} : "UDT_RATStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "620" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS { S7_SetPoint := 'False'} : "UDT_PECStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "621" : Struct
         RightAngledTransfer { S7_SetPoint := 'False'} : "UDT_RATStatus";
         MCO_M01 : "UDT_AixControllerStatus";
      END_STRUCT;
      "630" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "710" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS : "UDT_PECStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "720" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS : "UDT_PECStatus";
         MCO_M01 : "UDT_AixControllerStatus";
      END_STRUCT;
      "730" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS : "UDT_PECStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "740" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS { S7_SetPoint := 'False'} : "UDT_PECStatus";
         MCO_M01 : "UDT_AixControllerStatus";
      END_STRUCT;
      "750" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS : "UDT_PECStatus";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_WSGStatistics"
VERSION : 0.1
   STRUCT
      "010" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS : "UDT_PECStatistics";
         MCO_M01 : "UDT_VfdStatistics";
      END_STRUCT;
      "020" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS : "UDT_PECStatistics";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "021" : Struct
         RightAngledTransfer { S7_SetPoint := 'False'} : "UDT_RATStatistics";
         MCO_M01 : "UDT_VfdStatistics";
      END_STRUCT;
      "110" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS : "UDT_PECUpdateStatistics";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "120" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS : "UDT_PECStatistics";
         MCO_M01 : "UDT_VfdStatistics";
      END_STRUCT;
      "130" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS : "UDT_PECUpdateStatistics";
         MCO_M01 : "UDT_VfdStatistics";
      END_STRUCT;
      "140" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS : "UDT_PECStatistics";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "141" : Struct
         RightAngledTransfer { S7_SetPoint := 'False'} : "UDT_RATStatistics";
         MCO_M01 : "UDT_VfdStatistics";
      END_STRUCT;
      "150" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS : "UDT_PECUpdateStatistics";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "160" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS : "UDT_PECUpdateStatistics";
         MCO_M01 : "UDT_VfdStatistics";
      END_STRUCT;
      "170" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS : "UDT_PECUpdateStatistics";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "180" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS : "UDT_PECUpdateStatistics";
         MCO_M01 : "UDT_VfdStatistics";
      END_STRUCT;
      "190" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS : "UDT_PECUpdateStatistics";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "210" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS : "UDT_PECStatistics";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "211" : Struct
         RightAngledTransfer { S7_SetPoint := 'False'} : "UDT_RATStatistics";
         MCO_M01 : "UDT_VfdStatistics";
      END_STRUCT;
      "220" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS : "UDT_PECStatistics";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "221" : Struct
         RightAngledTransfer { S7_SetPoint := 'False'} : "UDT_RATStatistics";
         MCO_M01 : "UDT_VfdStatistics";
      END_STRUCT;
      "230" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "310" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS : "UDT_PECStatistics";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "320" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS : "UDT_PECStatistics";
         MCO_M01 : "UDT_VfdStatistics";
      END_STRUCT;
      "330" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS : "UDT_PECStatistics";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "340" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS : "UDT_PECStatistics";
         MCO_M01 : "UDT_VfdStatistics";
      END_STRUCT;
      "350" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS : "UDT_PECStatistics";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "510" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "520" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS : "UDT_PECUpdateStatistics";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "530" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS : "UDT_PECUpdateStatistics";
         MCO_M01 : "UDT_VfdStatistics";
      END_STRUCT;
      "540" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS : "UDT_PECStatistics";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "541" : Struct
         RightAngledTransfer { S7_SetPoint := 'False'} : "UDT_RATStatistics";
         MCO_M01 : "UDT_VfdStatistics";
      END_STRUCT;
      "550" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS : "UDT_PECUpdateStatistics";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "560" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS : "UDT_PECUpdateStatistics";
         MCO_M01 : "UDT_VfdStatistics";
      END_STRUCT;
      "570" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS : "UDT_PECUpdateStatistics";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "580" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS : "UDT_PECUpdateStatistics";
         MCO_M01 : "UDT_VfdStatistics";
      END_STRUCT;
      "590" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS : "UDT_PECUpdateStatistics";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "610" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS : "UDT_PECStatistics";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "611" : Struct
         RightAngledTransfer { S7_SetPoint := 'False'} : "UDT_RATStatistics";
         MCO_M01 : "UDT_VfdStatistics";
      END_STRUCT;
      "620" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS : "UDT_PECStatistics";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "621" : Struct
         RightAngledTransfer { S7_SetPoint := 'False'} : "UDT_RATStatistics";
         MCO_M01 : "UDT_VfdStatistics";
      END_STRUCT;
      "630" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "710" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS : "UDT_PECStatistics";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "720" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS : "UDT_PECStatistics";
         MCO_M01 : "UDT_VfdStatistics";
      END_STRUCT;
      "730" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS : "UDT_PECStatistics";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "740" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS : "UDT_PECStatistics";
         MCO_M01 : "UDT_VfdStatistics";
      END_STRUCT;
      "750" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS : "UDT_PECStatistics";
         MCO_M01 { S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_WSGHmiCommands"
VERSION : 0.1
   STRUCT
      "010" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "020" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "021" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RAT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATCommand";
      END_STRUCT;
      "110" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "120" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "130" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "140" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "141" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATCommand";
      END_STRUCT;
      "150" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "160" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "170" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "180" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "190" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "210" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "211" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATCommand";
      END_STRUCT;
      "220" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "221" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATCommand";
      END_STRUCT;
      "230" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "310" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "320" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "330" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "340" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "350" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "510" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "520" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "530" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "540" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "541" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATCommand";
      END_STRUCT;
      "550" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "560" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "570" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "580" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "590" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "610" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "611" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATCommand";
      END_STRUCT;
      "620" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "621" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATCommand";
      END_STRUCT;
      "630" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "710" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "720" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "730" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "740" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "750" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_NerakLiftStatus"
VERSION : 0.1
   STRUCT
      Status : Int;   // Status number
      Specific : Struct
         Reverse : Bool;
         CollisionDetected : Bool;
         ProductFellDown : Bool;
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_WSRStatistics"
VERSION : 0.1
   STRUCT
      "010" { S7_SetPoint := 'False'} : "UDT_StatisticsTC03";
      "020" { S7_SetPoint := 'False'} : "UDT_StatisticsTC13";
      "030" { S7_SetPoint := 'False'} : "UDT_StatisticsTC03";
      "040" { S7_SetPoint := 'False'} : "UDT_StatisticsTC07";
      "041" { S7_SetPoint := 'False'} : "UDT_StatisticsTC36";
      "050" { S7_SetPoint := 'False'} : "UDT_StatisticsTC03";
      "060" { S7_SetPoint := 'False'} : "UDT_StatisticsTC13";
      "070" { S7_SetPoint := 'False'} : "UDT_StatisticsTC03";
      "080" { S7_SetPoint := 'False'} : "UDT_StatisticsTC13";
      "110" { S7_SetPoint := 'False'} : "UDT_StatisticsTC03";
      "120" { S7_SetPoint := 'False'} : "UDT_StatisticsTC13";
      "130" { S7_SetPoint := 'False'} : "UDT_StatisticsTC03";
      "140" { S7_SetPoint := 'False'} : "UDT_StatisticsTC07";
      "141" { S7_SetPoint := 'False'} : "UDT_StatisticsTC36";
      "150" { S7_SetPoint := 'False'} : "UDT_StatisticsTC03";
      "160" { S7_SetPoint := 'False'} : "UDT_StatisticsTC13";
      "170" { S7_SetPoint := 'False'} : "UDT_StatisticsTC03";
      "180" { S7_SetPoint := 'False'} : "UDT_StatisticsTC11";
      "210" { S7_SetPoint := 'False'} : "UDT_StatisticsTC03";
      "220" { S7_SetPoint := 'False'} : "UDT_StatisticsTC13";
      "230" { S7_SetPoint := 'False'} : "UDT_StatisticsTC03";
      "240" { S7_SetPoint := 'False'} : "UDT_StatisticsTC02";
      "241" { S7_SetPoint := 'False'} : "UDT_StatisticsTC36";
      "250" { S7_SetPoint := 'False'} : "UDT_StatisticsTC03";
      "260" { S7_SetPoint := 'False'} : "UDT_StatisticsTC13";
      "270" { S7_SetPoint := 'False'} : "UDT_StatisticsTC03";
   END_STRUCT;

END_TYPE

TYPE "UDT_ScannerInterface"
VERSION : 0.1
   STRUCT
      Trigger : Bool;
      BarCodeValue : String;
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_DataLogicBladeSN"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      iudt_DataLogicBladeIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_DataLogicBlade_IN_SN";
      ix_Trigger { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_OUTPUT 
      qx_Trigger { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      qs_Barcode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;
   END_VAR

   VAR 
      sa_Data { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..14] of Char;
      R_TRIG_Trigger {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger signal
      R_TRIG_Succes {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      R_TRIG_Failure {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sfb_TimerOnOffDelay_Trigger { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      si_Index { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_GoodReadCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_BadReadCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      sx_Trigger { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR


BEGIN
	#R_TRIG_Trigger(CLK := #ix_Trigger);  //Rising edge trigger signal
	#R_TRIG_Succes(CLK := #iudt_DataLogicBladeIN.Data[0].%X0);//AND NOT #sx_Trigger);
	#R_TRIG_Failure(CLK := #iudt_DataLogicBladeIN.Data[0].%X1);// AND NOT #sx_Trigger);
	
	REGION 1 - Scanning
	    IF #R_TRIG_Trigger.Q THEN
	        #sx_Trigger := TRUE;
	    END_IF;
	    
	    #sfb_TimerOnOffDelay_Trigger(iudi_OnDelayTime := 600,
	                                 ix_SignalToDelay := #sx_Trigger,
	                                 ix_Enable := TRUE);
	    
	    IF #sfb_TimerOnOffDelay_Trigger.qx_DelayedSignal THEN
	        #sx_Trigger := FALSE;
	    END_IF;
	    
	    
	    
	    
	    IF #R_TRIG_Succes.Q OR #R_TRIG_Failure.Q THEN
	        
	        FOR #si_Index := 1 TO 15 DO
	            #sa_Data[#si_Index - 1] := BYTE_TO_CHAR(#iudt_DataLogicBladeIN.Data[#si_Index]);
	        END_FOR;
	        
	        IF #sa_Data[0] = '$02' AND #sa_Data[11] = '$R' AND #sa_Data[12] = '$L' THEN
	            Chars_TO_Strg(Chars := #sa_Data,
	                          pChars := 1,
	                          Cnt := 10,
	                          Strg => #qs_Barcode);
	            #si_GoodReadCount += 1;
	            
	        ELSIF #sa_Data[1] = '$18' THEN
	            #qs_Barcode := 'NO_READ    ';
	            #si_BadReadCount += 1;
	            
	        END_IF;
	        
	        
	    END_IF;
	END_REGION
	
	
	REGION 2 - Output write
	    #qx_Trigger := #sx_Trigger;
	END_REGION
	
	
	
	
END_FUNCTION_BLOCK

TYPE "UDT_TGWLiftPO"
VERSION : 0.1
   STRUCT
      qx_Fault : Bool;   // Fault lamp
      qx_MainContactorOn : Bool;   // Main contactor on
      Spare_1 : Bool;
      Spare_2 : Bool;
      Spare_3 : Bool;
      Spare_4 : Bool;
      Spare_5 : Bool;
      Spare_6 : Bool;
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_LiftManualControl"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 263
// END_ATTRIBUTES
   VAR_INPUT 
      ix_ManualMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ix_AutoMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ix_UpPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ix_DownPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ix_LiftConveyorRight { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ix_LiftConveyorLeft { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ix_InfeedConveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ix_OutfeedConveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_IN_OUT 
      iqUDT_LiftConveyorCommand : "UDT_ConveyorCommand";
      iqUDT_LowerInfeedConveyorCommand : "UDT_ConveyorCommand";
      iqUDT_LowerOutfeedConveyorCommand : "UDT_ConveyorCommand";
      iqUDT_UpperInfeedConveyorCommand : "UDT_ConveyorCommand";
      iqUDT_UpperOutfeedConveyorCommand : "UDT_ConveyorCommand";
   END_VAR


BEGIN
	(*
	
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	14/06/2024  | 1.0       | R.Pieczonka   | First release
	*)
	
	REGION Modes
	    //Setting manual mode for lift, infeed and outfeed conveyors if key-operated switch is turned to manual mode
	    IF #ix_ManualMode THEN
	        #iqUDT_LiftConveyorCommand.ManualMode := TRUE;
	        #iqUDT_LowerInfeedConveyorCommand.ManualMode := TRUE;
	        #iqUDT_LowerOutfeedConveyorCommand.ManualMode := TRUE;
	        #iqUDT_UpperInfeedConveyorCommand.ManualMode := TRUE;
	        #iqUDT_UpperOutfeedConveyorCommand.ManualMode := TRUE;
	    END_IF;
	    
	    //Setting automatic mode for lift, infeed and outfeed conveyors if key-operated switch is turned to automatic mode
	    IF #ix_AutoMode THEN
	        #iqUDT_LiftConveyorCommand.ManualMode := FALSE;
	        #iqUDT_LowerInfeedConveyorCommand.ManualMode := FALSE;
	        #iqUDT_LowerOutfeedConveyorCommand.ManualMode := FALSE;
	        #iqUDT_UpperInfeedConveyorCommand.ManualMode := FALSE;
	        #iqUDT_UpperOutfeedConveyorCommand.ManualMode := FALSE;
	    END_IF;
	END_REGION
	
	REGION Lift Conveyor
	    //Commands for controling only lift conveyor
	    IF #iqUDT_LiftConveyorCommand.ManualMode AND #ix_LiftConveyorRight THEN
	        #iqUDT_LiftConveyorCommand.ManualStartStop := TRUE;
	        #iqUDT_LiftConveyorCommand.Reverse := FALSE;
	        
	    ELSIF #iqUDT_LiftConveyorCommand.ManualMode AND #ix_LiftConveyorLeft THEN
	        #iqUDT_LiftConveyorCommand.ManualStartStop := TRUE;
	        #iqUDT_LiftConveyorCommand.Reverse := TRUE;
	    ELSE
	        #iqUDT_LiftConveyorCommand.ManualStartStop := FALSE;
	        #iqUDT_LiftConveyorCommand.Reverse := FALSE;
	    END_IF;
	END_REGION
	
	REGION Lower Position
	    //Lower infeed
	    IF #iqUDT_LiftConveyorCommand.ManualMode
	        AND #iqUDT_LowerInfeedConveyorCommand.ManualMode
	        AND #ix_DownPosition
	        AND #ix_LiftConveyorRight
	        AND #ix_InfeedConveyor
	    THEN
	        #iqUDT_LiftConveyorCommand.ManualStartStop := TRUE;
	        #iqUDT_LiftConveyorCommand.Reverse := FALSE;
	        #iqUDT_LowerInfeedConveyorCommand.ManualStartStop := TRUE;
	        #iqUDT_LowerInfeedConveyorCommand.Reverse := FALSE;
	        
	    ELSIF #iqUDT_LiftConveyorCommand.ManualMode
	        AND #iqUDT_LowerInfeedConveyorCommand.ManualMode
	        AND #ix_DownPosition
	        AND #ix_LiftConveyorLeft
	        AND #ix_InfeedConveyor
	    THEN
	        #iqUDT_LiftConveyorCommand.ManualStartStop := TRUE;
	        #iqUDT_LiftConveyorCommand.Reverse := TRUE;
	        #iqUDT_LowerInfeedConveyorCommand.ManualStartStop := TRUE;
	        #iqUDT_LowerInfeedConveyorCommand.Reverse := TRUE;
	    ELSE
	        #iqUDT_LowerInfeedConveyorCommand.ManualStartStop := FALSE;
	        #iqUDT_LowerInfeedConveyorCommand.Reverse := FALSE;
	    END_IF;
	    
	    //Lower Outfeed      
	    IF #iqUDT_LiftConveyorCommand.ManualMode
	        AND #iqUDT_LowerOutfeedConveyorCommand.ManualMode
	        AND #ix_DownPosition
	        AND #ix_LiftConveyorRight
	        AND #ix_OutfeedConveyor
	    THEN
	        #iqUDT_LiftConveyorCommand.ManualStartStop := TRUE;
	        #iqUDT_LiftConveyorCommand.Reverse := FALSE;
	        #iqUDT_LowerOutfeedConveyorCommand.ManualStartStop := TRUE;
	        #iqUDT_LowerOutfeedConveyorCommand.Reverse := FALSE;
	        
	    ELSIF #iqUDT_LiftConveyorCommand.ManualMode
	        AND #iqUDT_LowerOutfeedConveyorCommand.ManualMode
	        AND #ix_DownPosition
	        AND #ix_LiftConveyorLeft
	        AND #ix_OutfeedConveyor
	    THEN
	        #iqUDT_LiftConveyorCommand.ManualStartStop := TRUE;
	        #iqUDT_LiftConveyorCommand.Reverse := TRUE;
	        #iqUDT_LowerOutfeedConveyorCommand.ManualStartStop := TRUE;
	        #iqUDT_LowerOutfeedConveyorCommand.Reverse := TRUE;
	    ELSE
	        #iqUDT_LowerOutfeedConveyorCommand.ManualStartStop := FALSE;
	        #iqUDT_LowerOutfeedConveyorCommand.Reverse := FALSE;
	    END_IF;
	END_REGION
	
	REGION Upper position
	    //Upper Infeed
	    IF #iqUDT_LiftConveyorCommand.ManualMode
	        AND #iqUDT_UpperInfeedConveyorCommand.ManualMode
	        AND #ix_UpPosition
	        AND #ix_LiftConveyorLeft
	        AND #ix_InfeedConveyor
	    THEN
	        #iqUDT_LiftConveyorCommand.ManualStartStop := TRUE;
	        #iqUDT_LiftConveyorCommand.Reverse := TRUE;
	        #iqUDT_UpperInfeedConveyorCommand.ManualStartStop := TRUE;
	        #iqUDT_UpperInfeedConveyorCommand.Reverse := FALSE;
	        
	    ELSIF #iqUDT_LiftConveyorCommand.ManualMode
	        AND #iqUDT_UpperInfeedConveyorCommand.ManualMode
	        AND #ix_UpPosition
	        AND #ix_LiftConveyorRight
	        AND #ix_InfeedConveyor
	    THEN
	        #iqUDT_LiftConveyorCommand.ManualStartStop := TRUE;
	        #iqUDT_LiftConveyorCommand.Reverse := FALSE;
	        #iqUDT_UpperInfeedConveyorCommand.ManualStartStop := TRUE;
	        #iqUDT_UpperInfeedConveyorCommand.Reverse := TRUE;
	    ELSE
	        #iqUDT_UpperInfeedConveyorCommand.ManualStartStop := FALSE;
	        #iqUDT_UpperInfeedConveyorCommand.Reverse := FALSE;
	    END_IF;
	    
	    //Upper Outfeed    
	    IF #iqUDT_LiftConveyorCommand.ManualMode
	        AND #iqUDT_UpperOutfeedConveyorCommand.ManualMode
	        AND #ix_UpPosition
	        AND #ix_LiftConveyorRight
	        AND #ix_OutfeedConveyor
	    THEN
	        #iqUDT_LiftConveyorCommand.ManualStartStop := TRUE;
	        #iqUDT_LiftConveyorCommand.Reverse := FALSE;
	        #iqUDT_UpperOutfeedConveyorCommand.ManualStartStop := TRUE;
	        #iqUDT_UpperOutfeedConveyorCommand.Reverse := TRUE;
	        
	    ELSIF #iqUDT_LiftConveyorCommand.ManualMode
	        AND #iqUDT_UpperOutfeedConveyorCommand.ManualMode
	        AND #ix_UpPosition
	        AND #ix_LiftConveyorLeft
	        AND #ix_OutfeedConveyor
	    THEN
	        #iqUDT_LiftConveyorCommand.ManualStartStop := TRUE;
	        #iqUDT_LiftConveyorCommand.Reverse := TRUE;
	        #iqUDT_UpperOutfeedConveyorCommand.ManualStartStop := TRUE;
	        #iqUDT_UpperOutfeedConveyorCommand.Reverse := FALSE;
	    ELSE
	        #iqUDT_UpperOutfeedConveyorCommand.ManualStartStop := FALSE;
	        #iqUDT_UpperOutfeedConveyorCommand.Reverse := FALSE;
	    END_IF;
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_VfdSEWMOVI-CSpeed"
TITLE = FB_VFD_SEW_MOVI-C_Speed
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 37
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_VfdConfig { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdConfiguration";   //    Configuration structure
      iUDT_VfdInputs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdSEWSpeedPI";   //    VFD inputs structure
      ix_PowerOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    True = External Power OK
      ix_SimulationModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    True = Simulation mode active
      ix_QuickStopDisable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;   //    True = Quick Stop not enabled
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdStatus";   //    HMI status structure
      qUDT_VfdOutputs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdSEWSpeedPO";   //    VFD outputs structure
   END_VAR

   VAR_IN_OUT 
      iqUDT_ConveyorInterface : "UDT_ConveyorInterface";   //    Conveyor interface structure
      iqUDT_VfdStatistics : "UDT_VfdStatistics";   //    Statistics structure
   END_VAR

   VAR 
      sUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatus";   //    HMI status structure
      sUDT_PNDevice { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PNDevice";   //    PN device info structure
      sFB_TimerOnOffDelayCheckSupply { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //    MHS "TimerOnOffDelay" - to delay time for VFD supply contactor
      sFB_TimerOnOffDelayMoviKit { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //    MHS "TimerOnOffDelay" - to delay time for MoviKit response delay error
      sFB_TimerOnOffDelayVFDRunningFeedbackError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //    MHS "TimerOnOffDelay" - to delay time for VFDRunningFeedback error
      sR_TRIG_RunFWD {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //    Rising edge of Run forward signal
      sR_TRIG_RunRVS {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //    Rising edge of Run reverse
      sR_TRIG_PNSlaveNotOnline {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //    Rising edge for trigger Profinet slave not online statistics
      sR_TRIG_PNSlaveError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //    Rising edge for trigger Profinet slave error statistics
      sR_TRIG_InternalError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //    Rising edge for trigger Internal VFD Error statistics
      sR_TRIG_CommunicationErrorMovikit {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //    Rising edge for trigger communication error Movikit statistics
      sR_TRIG_Running {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //    Rising edge for starting of the running signal
      sF_TRIG_RunFwd {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //    Falling edge for run forward signal
      sF_TRIG_RunRvs {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //    Falling edge for run reverse signal
      sa_PNPortsStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..8] of Bool;   // TRUE when specific port has an error
      sr_ActualSpeedSetpoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   //    Actual speed setpoint [RPM]
      si_ActualSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //    Actual speed in [mm/s]
      sx_ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Commissioning: configuration error
      sx_PNDeviceHealthy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Profinet device is online and error free
      sx_MoviKitFeedback { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Movikit feedback delay
      sx_HardwareAvailable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Power and communication to drive are ok
      sx_PowerOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Communication, safety and power are available
      sx_VfdAvailable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Hardware of VFD is ok and no communication error with movikit
      sx_ErrorActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Block has an error
      sx_EnableOperation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Enable operation signal
      sx_RunVfdForward { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Start VFD forward
      sx_RunVfdReverse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Start VFD backward
      sx_SpeedSetpointReached { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Motor is running at requested speed
      sx_VfdStopping { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    VFD Stopping
      sx_MovikitHandshakeIn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Handshake to movikit
   END_VAR

   VAR CONSTANT 
      ci_NumberOfProfinetPorts : Int := 2;   // Number of Profinet ports in device
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | P. Majka      | First release MHS TIA 15.1
	24/07/2019  | 0.2       | K. Pokorski   | Autofind device is Profinet structure (Region 2)
	30/07/2019  | 0.3       | M. Kurc       | Add MoviKit error
	30/07/2019  | 2.0       | P. Majka      | Moved to project with library 2.0
	16/08/2019  | 2.1       | T.v.Beukering | Updated complete block
	03/10/2019  | 2.2       | F.Baten       | Applied FC_GetDevicePN, added running statistics, changed speed window from UInt to Int, added actual speed in conveyor interface. 
	11/10/2019  | 2.3       | M. Kurc       | Added VFD stop signal when occurs both run request (FWD, RVS), added logic for QuickSTOP, added interclok FDW/RVS 
	20/11/2019  | 2.10      | S. Nikodem    | Configuration error
	20/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	03/12/2019  | 3.1       | S. Nikodem    | Change of direction 
	20/12/2019  | 3.2       | S. Deulkar    | Used configureation error bit to report to conveyor block 
	06/02/2020  | 3.3       | S. Nikodem    | Configuration error - Simulation mode bypass PNDeviceFound
	01/03/2020  | 3.4       | F.Baten       | Changed "UDT_VFD_Status" to be without positioning status
	04/03/2020  | 3.5       | F.Baten       | Output speed scaling based on measured speed at fixed output value, removal of gearratio and wheelendperrimeter
	01/05/2020  | 3.7       | F.Baten       | Reverted 3.6 modification measured speed
	14/09/2020  | 3.8       | S.Nikodem     | VFDRunningFeedback error 
	03/11/2020  | 3.9       | K.Pokorski    | Profinet ports diagnostics added 
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Get Device Profinet information
	    
	    "FC_GetDevicePN"(is_PNDeviceName := #iUDT_VfdConfig.VFDPNDeviceName,
	                     ix_SimulationModeActive := #ix_SimulationModeActive,
	                     iqUDT_PND := #sUDT_PNDevice);
	    
	    
	    "FC_GetPNPortStatus"(ii_NumberOfPorts := #ci_NumberOfProfinetPorts,
	                         iUDT_DevicePNInfo := #sUDT_PNDevice,
	                         qa_PortFault => #sa_PNPortsStatus);
	    
	END_REGION
	
	REGION 2 - Reset errors
	    
	    IF #iqUDT_ConveyorInterface.InternalErrorReset                           // Reset errors when reset signal is given
	    THEN
	        #sUDT_HMIStatus.CommunicationErrorMovikit := FALSE;
	        #sUDT_HMIStatus.PNSlaveNotonline := FALSE;
	        #sUDT_HMIStatus.PNSlaveError := FALSE;
	        #sUDT_HMIStatus.InternalError := FALSE;
	        #sUDT_HMIStatus.VFDRunningFeedbackError := FALSE;
	        #sUDT_HMIStatus.PNSlaveWarning := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Hardware checks
	    // Hardware will only be available after the delay, so the device has time for the initialisation
	    #sFB_TimerOnOffDelayCheckSupply(iudi_OnDelayTime := 2000,
	                                    ix_SignalToDelay := #ix_PowerOK);
	    
	    #sx_PowerOk := #sFB_TimerOnOffDelayCheckSupply.qx_DelayedSignal;
	    
	    // Check if PN device is online
	    IF NOT "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.Exist
	        AND NOT #ix_SimulationModeActive
	        AND #sx_PowerOk
	    THEN
	        #sUDT_HMIStatus.PNSlaveNotonline := TRUE;
	    END_IF;
	    
	    
	    // Check if PN ports are healthy 
	    IF #sa_PNPortsStatus[1] XOR #sa_PNPortsStatus[2] THEN
	        #sUDT_HMIStatus.PNSlaveWarning := TRUE;
	    END_IF;
	    
	    // Check if PN device has an error
	    IF "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.Error
	        AND NOT #ix_SimulationModeActive
	        AND #sx_PowerOk
	        AND NOT #sUDT_HMIStatus.PNSlaveWarning
	    THEN
	        #sUDT_HMIStatus.PNSlaveError := TRUE;
	    END_IF;
	    
	    // Set bit when PN device is healthy (online and no error)
	    #sx_PNDeviceHealthy := NOT #sUDT_HMIStatus.PNSlaveNotonline
	    AND NOT #sUDT_HMIStatus.PNSlaveError
	    AND #sUDT_PNDevice.PNDeviceFound
	    AND #sx_PowerOk;
	    
	    // Set hardware available bit when all conditions are met
	    #sx_HardwareAvailable := (#iUDT_VfdInputs.Status_Word_1.STO_Inactive
	    AND #sx_PowerOk
	    AND #sx_PNDeviceHealthy)
	    OR #ix_SimulationModeActive;
	    
	    // Check MoviKit communication (heartbeat)
	    #sx_MoviKitFeedback := ((#sx_MovikitHandshakeIn
	    AND NOT #iUDT_VfdInputs.Status_Word_1.MovikitHandshakeOut)
	    OR (NOT #sx_MovikitHandshakeIn
	    AND #iUDT_VfdInputs.Status_Word_1.MovikitHandshakeOut));
	    
	    #sFB_TimerOnOffDelayMoviKit(iudi_OnDelayTime := 1000,
	                                ix_SignalToDelay := NOT #sx_MoviKitFeedback);
	    
	    // Set error when MoviKit communication is not available
	    IF #sFB_TimerOnOffDelayMoviKit.qx_DelayedSignal AND #sx_HardwareAvailable
	    THEN
	        
	        #sUDT_HMIStatus.CommunicationErrorMovikit := TRUE;
	        
	    END_IF;
	    
	    // Invert output when input is equal 
	    #sx_MovikitHandshakeIn := NOT #iUDT_VfdInputs.Status_Word_1.MovikitHandshakeOut;
	    
	    // VFD is ready for operation if hardware ok and no communication error with Movikit
	    #sx_VfdAvailable := #sx_HardwareAvailable AND NOT #sUDT_HMIStatus.CommunicationErrorMovikit;
	    
	END_REGION
	
	REGION 4 - Check errors and warnings 
	    // Check if the VFD has an error
	    #sUDT_HMIStatus.InternalError := #iUDT_VfdInputs.Status_Word_1.Error;
	    
	    // Check if the VFD has a warning
	    #sUDT_HMIStatus.InternalWarning := #iUDT_VfdInputs.Status_Word_1.Warning;
	    
	    // Copy error/warning code to status DB when error/warning active
	    IF NOT #iUDT_VfdInputs.Status_Word_1.Error
	        AND NOT #iUDT_VfdInputs.Status_Word_1.Warning
	    THEN
	        #sUDT_HMIStatus.ErrorCode := 0;
	        #sUDT_HMIStatus.SubErrorCode := 0;
	    ELSE
	        #sUDT_HMIStatus.ErrorCode := #iUDT_VfdInputs.StatusErrorNo.%B1;
	        #sUDT_HMIStatus.SubErrorCode := #iUDT_VfdInputs.StatusErrorNo.%B0;
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Check if configuration is ok for commissioning purposes
	    // Set configuration error when one or all VFD configuration parameters aren't set
	    IF #iUDT_VfdConfig.WheelEndPerimeter > 0.0
	        AND #iUDT_VfdConfig.GearRatio > 0.0
	        AND #iUDT_VfdConfig.ReferenceRPM > 0.0
	        AND #iUDT_VfdConfig.VFDStartupTime > 0.0
	        AND (#sUDT_PNDevice.PNDeviceFound
	        OR #ix_SimulationModeActive)
	    THEN
	        #sx_ConfigurationError := FALSE;
	    ELSE
	        #sx_ConfigurationError := TRUE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Handle speed  
	    // Calculate speed in mm/s                                                                                                         
	    #si_ActualSpeed := REAL_TO_INT(((#iUDT_VfdInputs.ActualSpeed / #iUDT_VfdConfig.GearRatio) * #iUDT_VfdConfig.WheelEndPerimeter) / 60.0);
	    
	    // Reversal direction speed
	    IF #iUDT_VfdConfig.DirectionReversal
	    THEN
	        #si_ActualSpeed := #si_ActualSpeed * -1;
	        
	    END_IF;
	    
	    // Actual speed setpoint
	    #sr_ActualSpeedSetpoint := ((DINT_TO_REAL(INT_TO_DINT(#iqUDT_ConveyorInterface.SpeedSetpoint) * 60) / #iUDT_VfdConfig.WheelEndPerimeter) * #iUDT_VfdConfig.GearRatio);
	    
	    // Check maximum output
	    IF
	        #sr_ActualSpeedSetpoint > #iUDT_VfdConfig.ReferenceRPM
	    THEN
	        #sr_ActualSpeedSetpoint := #iUDT_VfdConfig.ReferenceRPM;
	    END_IF;
	    
	    
	    //Check if speed setpoint is reached                                 
	    #sx_SpeedSetpointReached := (ABS(#si_ActualSpeed) >= (#iqUDT_ConveyorInterface.SpeedSetpoint - #iUDT_VfdConfig.SpeedSetpointWindow))
	    AND (ABS(#si_ActualSpeed) <= (#iqUDT_ConveyorInterface.SpeedSetpoint + #iUDT_VfdConfig.SpeedSetpointWindow));
	    
	    
	END_REGION
	
	REGION 7 - Prepare output data VFD
	    
	    REGION 7.1 - Set speed setpoint in forward and reverse direction 
	        
	        #sR_TRIG_RunFWD(CLK := #iqUDT_ConveyorInterface.RunFwd);     // Get rising edge of Run forward signal
	        #sR_TRIG_RunRVS(CLK := #iqUDT_ConveyorInterface.RunRvs);     // Get rising edge of Run reverse signal
	        
	        // When rising edge of the forward of reverse signal is received, the drive has to stop to be able to make the switch
	        IF #sR_TRIG_RunFWD.Q OR #sR_TRIG_RunRVS.Q
	        THEN
	            #qUDT_VfdOutputs.SetpointSpeed := 0;
	            
	        END_IF;
	        
	        // If motor stopped and Run forward is requested and forward direction is interlock, the speed setpoint is loaded to run forward.
	        IF (#iqUDT_ConveyorInterface.RunFwd) AND #iUDT_VfdConfig.InterlockFwd //(#i_UDT_VFDInputs.ActualSpeed = 0) AND 
	        THEN
	            #sx_RunVfdForward := TRUE;
	            #sx_RunVfdReverse := FALSE;
	        END_IF;
	        
	        // If motor stopped and Run reverse is requested and reverse direction is interlock, the speed setpoint is loaded to run forward.
	        IF (#iUDT_VfdInputs.ActualSpeed = 0) AND #iqUDT_ConveyorInterface.RunRvs AND #iUDT_VfdConfig.InterlockRvs
	        THEN
	            #sx_RunVfdReverse := TRUE;
	            #sx_RunVfdForward := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 7.2 - Stopping
	        
	        // Create trigger when direction signal falling
	        #sF_TRIG_RunFwd(CLK := #iqUDT_ConveyorInterface.RunFwd);
	        #sF_TRIG_RunRvs(CLK := #iqUDT_ConveyorInterface.RunRvs);
	        
	        // When no run signal or above run signal are given or drive is running and no occurs interlock (in specific direction) the VFD should stop
	        IF (NOT #iqUDT_ConveyorInterface.RunRvs AND NOT #iqUDT_ConveyorInterface.RunFwd)
	            OR (#iqUDT_ConveyorInterface.RunRvs AND #iqUDT_ConveyorInterface.RunFwd)
	            OR (#sx_RunVfdReverse AND NOT #iUDT_VfdConfig.InterlockRvs)
	            OR (#sx_RunVfdForward AND NOT #iUDT_VfdConfig.InterlockFwd)
	            OR #sF_TRIG_RunRvs.Q
	            OR #sF_TRIG_RunFwd.Q
	            
	        THEN
	            #sx_RunVfdReverse := FALSE;
	            #sx_RunVfdForward := FALSE;
	        END_IF;
	        
	        IF NOT #sx_RunVfdReverse AND NOT #sx_RunVfdForward AND (#iUDT_VfdInputs.ActualSpeed <> 0)
	        THEN
	            #sx_VfdStopping := TRUE;
	        ELSE
	            #sx_VfdStopping := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 7.3 - Check for enable operation signal
	        
	        #sx_EnableOperation := #sx_VfdAvailable AND NOT #sx_ConfigurationError AND (#sx_RunVfdForward OR #sx_RunVfdReverse) OR #iqUDT_ConveyorInterface.VFDRunning;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 8 - Write outputs to VFD  
	    
	    REGION 8.1 - Write control word 1
	        
	        #qUDT_VfdOutputs.Control_Word_1.EnableRapidStop := #ix_QuickStopDisable;                       // Writing state to enable VFD to run
	        #qUDT_VfdOutputs.Control_Word_1.EnableApplicationStop := #sx_EnableOperation;                  // Writing state to Enable VFD operation   
	        #qUDT_VfdOutputs.Control_Word_1.ReleaseBrake := FALSE;                                         // Not used 
	        #qUDT_VfdOutputs.Control_Word_1.JogPos := FALSE;                                               // Not used
	        #qUDT_VfdOutputs.Control_Word_1.JogNeg := FALSE;                                               // Not used
	        #qUDT_VfdOutputs.Control_Word_1.ApplyRelativePositioning := FALSE;                             // Not used for speed control
	        #qUDT_VfdOutputs.Control_Word_1.StartStop := #sx_EnableOperation;                              // Writing state to start or stop VFD 
	        #qUDT_VfdOutputs.Control_Word_1.ResetError := #iqUDT_ConveyorInterface.InternalErrorReset;    // Reseting VFD errors with error reset bit 
	        #qUDT_VfdOutputs.Control_Word_1.ActivateDriveTrain2 := FALSE;                                  // Not used for MoviGear with one Drive Train   
	        #qUDT_VfdOutputs.Control_Word_1.DeactivateSW_LimitSwitch := FALSE;                             // Not used
	        #qUDT_VfdOutputs.Control_Word_1.ActivateInhibit := NOT #sx_EnableOperation;                    // Controller Inhibit has TO be "false" before start/stop
	        #qUDT_VfdOutputs.Control_Word_1.ActivateStandby := FALSE;                                      // Not used
	        #qUDT_VfdOutputs.Control_Word_1.MovikitHandshakeIn := #sx_MovikitHandshakeIn;                  // MoviKit handshake controlled BY 0.5 Hz 
	        
	        // If hardware is unavailable clear the control word
	        IF NOT #sx_VfdAvailable
	        THEN
	            #qUDT_VfdOutputs.Control_Word_1.EnableRapidStop := FALSE;                                  // Writing state to enable VFD to run
	            #qUDT_VfdOutputs.Control_Word_1.EnableApplicationStop := FALSE;                            // Writing state to Enable VFD operation   
	            #qUDT_VfdOutputs.Control_Word_1.ReleaseBrake := FALSE;                                     // Not used 
	            #qUDT_VfdOutputs.Control_Word_1.JogPos := FALSE;                                           // Not used
	            #qUDT_VfdOutputs.Control_Word_1.JogNeg := FALSE;                                           // Not used
	            #qUDT_VfdOutputs.Control_Word_1.ApplyRelativePositioning := FALSE;                         // NOT used FOR speed control
	            #qUDT_VfdOutputs.Control_Word_1.StartStop := FALSE;                                        // Writing state to start or stop VFD 
	            #qUDT_VfdOutputs.Control_Word_1.ResetError := FALSE;                                       // Reseting VFD errors with error reset bit 
	            #qUDT_VfdOutputs.Control_Word_1.ActivateDriveTrain2 := FALSE;                              // Not used for MoviGear with one Drive Train   
	            #qUDT_VfdOutputs.Control_Word_1.DeactivateSW_LimitSwitch := FALSE;                         // Not used
	            #qUDT_VfdOutputs.Control_Word_1.ActivateInhibit := FALSE;                                  // Controller Inhibit has TO be "false" before start/stop
	            #qUDT_VfdOutputs.Control_Word_1.ActivateStandby := FALSE;                                  // Not used
	            #qUDT_VfdOutputs.Control_Word_1.MovikitHandshakeIn := FALSE;                               // MoviKit handshake controlled BY 0.5 Hz 
	            #qUDT_VfdOutputs.Control_Word_1.BIT_02_Reserved := FALSE;
	            #qUDT_VfdOutputs.Control_Word_1.BIT_09_Reserved := FALSE;
	            #qUDT_VfdOutputs.Control_Word_1.BIT_11_Reserved := FALSE;
	            
	        END_IF;
	    END_REGION
	    
	    REGION 8.2 - Write speed setpoint to drive
	        // The conveyor stopped and may now run in forward direction
	        IF (#sx_RunVfdForward AND NOT #iUDT_VfdConfig.DirectionReversal)
	            OR (#sx_RunVfdReverse AND #iUDT_VfdConfig.DirectionReversal)
	        THEN
	            #qUDT_VfdOutputs.SetpointSpeed := REAL_TO_INT(#sr_ActualSpeedSetpoint);
	        END_IF;
	        
	        // The conveyor stopped and may now run in reverse direction
	        IF (#sx_RunVfdReverse AND NOT #iUDT_VfdConfig.DirectionReversal)
	            OR (#sx_RunVfdForward AND #iUDT_VfdConfig.DirectionReversal)
	            
	        THEN
	            #qUDT_VfdOutputs.SetpointSpeed := REAL_TO_INT(#sr_ActualSpeedSetpoint * -1);
	        END_IF;
	        
	        // Clear speed setpoint when no run request
	        IF NOT #sx_RunVfdForward AND NOT #sx_RunVfdReverse
	        THEN
	            #qUDT_VfdOutputs.SetpointSpeed := 0;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 8.3 - Write acceleration and deceleration value to drive
	        // Write deceleration value to VFD
	        #qUDT_VfdOutputs.SetpointAcceleration := REAL_TO_INT(#iUDT_VfdConfig.ReferenceRPM / (UDINT_TO_REAL(#iUDT_VfdConfig.VFDRampUpTime) / 1000.0));        //Recalculating Acceleration ramp - deviding maximum configured speed by Ramp up time and devide it by 1000
	        
	        // Write deceleration value to VFD
	        #qUDT_VfdOutputs.SetpointDeceleration := REAL_TO_INT(#iUDT_VfdConfig.ReferenceRPM / (UDINT_TO_REAL(#iUDT_VfdConfig.VFDRampDownTime) / 1000.0));      //Recalculating Deceleration ramp - deviding maximum configured speed by Ramp down time and devide it by 1000
	        
	    END_REGION
	    
	END_REGION
	
	REGION 9 - Check if motor is running
	    
	    //The moto should start running after specific time. If nit the VFDRunningFeedback error occured
	    #sFB_TimerOnOffDelayVFDRunningFeedbackError(iudi_OnDelayTime := #iUDT_VfdConfig.VFDStartupTime,
	                                                ix_SignalToDelay := #sx_EnableOperation AND NOT (#si_ActualSpeed <> 0));
	    
	    IF #sFB_TimerOnOffDelayVFDRunningFeedbackError.qx_DelayedSignal THEN
	        
	        #sUDT_HMIStatus.VFDRunningFeedbackError := TRUE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 10 - Copy signals to interface DB and to status output UDT
	    // Create internal error status
	    #sx_ErrorActive := #sUDT_HMIStatus.PNSlaveNotonline
	    OR #sUDT_HMIStatus.PNSlaveError
	    OR #sUDT_HMIStatus.InternalError
	    OR #sUDT_HMIStatus.CommunicationErrorMovikit
	    OR #sUDT_HMIStatus.VFDRunningFeedbackError;
	    
	    // Write interface bits
	    #iqUDT_ConveyorInterface.VFDRunning := #iUDT_VfdInputs.Status_Word_1.DriveActive AND #sx_VfdAvailable AND #iqUDT_ConveyorInterface.ActualSpeed <> 0;        // Write true on output Conveyor interface structure if VFD is in operation and motor is turning 
	    #iqUDT_ConveyorInterface.VFDatSpeed := #sx_SpeedSetpointReached AND #sx_VfdAvailable;                                                                         // Copy setpoint speed reached state from static  to the output conveyor interface structure 
	    #iqUDT_ConveyorInterface.InternalWarningVFD := #iUDT_VfdInputs.Status_Word_1.Warning;                                                                         // Set the internal VFD warning bit if any warning is active 
	    #iqUDT_ConveyorInterface.InternalErrorVFD := #sx_ErrorActive;                                                                                                  // Set the internal VFD error bit if any fault is active 
	    #iqUDT_ConveyorInterface.ActualSpeed := #si_ActualSpeed;                                                                                                       // Copy the calculated value to the output
	    #iqUDT_ConveyorInterface.ConfigurationError := #iqUDT_ConveyorInterface.ConfigurationError OR #sx_ConfigurationError;
	    
	    // Copy error status to output
	    #qUDT_HMIStatus := #sUDT_HMIStatus;
	END_REGION
	
	REGION 11 - Statistics
	    // Create trigger on error and create statistics for profinet slave not online
	    #sR_TRIG_PNSlaveNotOnline(CLK := #sUDT_HMIStatus.PNSlaveNotonline);                              // Detect the rising edge of the error
	    
	    IF #iqUDT_ConveyorInterface.ResetStatistics OR #sUDT_HMIStatus.PNSlaveNotonline
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #sUDT_HMIStatus.PNSlaveNotonline,
	                        ix_RTrigActivate := #sR_TRIG_PNSlaveNotOnline.Q,
	                        iqUDT_Statistics := #iqUDT_VfdStatistics.PNSlaveNotOnline);
	    END_IF;
	    
	    // Create trigger on error and create statistics for profinet slave error
	    #sR_TRIG_PNSlaveError(CLK := #sUDT_HMIStatus.PNSlaveError);                                      // Detect the rising edge of the error
	    
	    IF #iqUDT_ConveyorInterface.ResetStatistics OR #sUDT_HMIStatus.PNSlaveError
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #sUDT_HMIStatus.PNSlaveError,
	                        ix_RTrigActivate := #sR_TRIG_PNSlaveError.Q,
	                        iqUDT_Statistics := #iqUDT_VfdStatistics.PNSlaveError);
	    END_IF;
	    
	    // Create trigger on error and create statistics for internal VFD Error
	    #sR_TRIG_InternalError(CLK := #sUDT_HMIStatus.InternalError);                                    // Detect the rising edge of the error
	    
	    IF #iqUDT_ConveyorInterface.ResetStatistics OR #sUDT_HMIStatus.InternalError
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #sUDT_HMIStatus.InternalError,
	                        ix_RTrigActivate := #sR_TRIG_InternalError.Q,
	                        iqUDT_Statistics := #iqUDT_VfdStatistics.VFDInternalError);
	    END_IF;
	    
	    // Create trigger on error and create statistics for Movikit communication error
	    #sR_TRIG_CommunicationErrorMovikit(CLK := #sUDT_HMIStatus.CommunicationErrorMovikit);            // Detect the rising edge of the error
	    
	    IF #iqUDT_ConveyorInterface.ResetStatistics OR #sUDT_HMIStatus.CommunicationErrorMovikit
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #sUDT_HMIStatus.CommunicationErrorMovikit,
	                        ix_RTrigActivate := #sR_TRIG_CommunicationErrorMovikit.Q,
	                        iqUDT_Statistics := #iqUDT_VfdStatistics.CommunicationErrorMovikit);
	    END_IF;
	    
	    // Create trigger on running signal and create statistics for running status
	    #sR_TRIG_Running(CLK := #iqUDT_ConveyorInterface.VFDRunning);                                 // Detect the rising edge of the signal
	    
	    IF #iqUDT_ConveyorInterface.ResetStatistics OR #iqUDT_ConveyorInterface.VFDRunning
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #iqUDT_ConveyorInterface.VFDRunning,
	                        ix_RTrigActivate := #sR_TRIG_Running.Q,
	                        iqUDT_Statistics := #iqUDT_VfdStatistics.Running);
	    END_IF;
	END_REGION
	
	REGION 12 - VFD codes
	    (*
	    FCB number |                       | Meaning
	    ______________________________________________________________________________________________________________
	        1                               Output stage inhibit 
	        2                               Default stop
	        4                               Manual Mode
	        5                               Speed control
	                101                     Speed-controlled jogging. Encoder feedback NOT required.
	                200                     Speed control. Encoder feedback NOT required.
	        6                               Interpolated speed control
	        7                               Torque control
	        8                               Interpolated torque control
	        9                               Positioning mode
	                400                     Absolute position control
	                401                     Relative position control
	                402                     Modulo position control - positive
	                403                     Modulo position control - negative
	                404                     Modulo position control - shortest distance
	        10                              Interpolated position control
	        12                              Referencing mode
	                300                     Reference travel - offset via parameter
	                301                     Reference travel - offset via fieldbus
	        13                              Stop at application limits
	        14                              Emergency stop
	        18                              Rotor position identification
	        19                              Position hold control
	        20                              Jog mode
	                100                     Position-controlled jogging. Encoder feedback required
	        21                              Brake test
	        25                              Motor parameter measurement
	        26                              Stop at user limits
	                    
	    Error code | Suberror code        | Meaning                                | Measure  
	    ______________________________________________________________________________________________________________
	        3       1                       Ground fault                            Consult "Fault table" in  
	        4       1                       Brake chopper fault                     document 'SEW Movigear-C 25887130.PDF'
	        6       1                       Line fault                              Chapter 8.7
	        7       1                       DC link fault
	        8       1,2,3                   Speed monitoring fault
	        9       1,2,5,6,9,10            Control mode fault
	        10      1,3-11                  Data flexibility fault
	        11      1-6                     Temperature monitoring fault
	        12      1,2                     Fault brake
	        13      5,24                    Encoder 1 fault
	        16      5-8,10,20-27            Startup fault
	        19      1-9                     Process data fault
	        20      2,11                    Fault device monitoring
	        23      4                       Power section fault
	        25      2-7,20,21,30,31,61,70   Parameter memory monitoring
	        26      1,3                     External fault
	        28      1-12,14                 FCB drive function fault
	        29      1-4                     Hardware limit switch fault
	        30      1-3                     Software limit switch fault
	        31      1-4,7,9                 Thermal protection fault
	        32      2-6,12                  Communication fault
	        33      11,12,13                system initialisation fault
	        34      1                       Process data configuration fault
	        35      1-5                     Function activation fault
	        42      1-3                     Lag fault
	        46      2,3,50,51,52            Safety card fault
	        51      1                       Analog processing fault
	    
	    Error code | Suberror code        | Meaning                                | Measure  
	    ______________________________________________________________________________________________________________
	        1       1,2                     Output stage monitoring fault           Contact SEW-Eurodrive Service       
	        4       2                       Brake chopper fault
	        7       2                       DC link fault
	        9       3,4,8                   Control mode fault
	        10      2,99                    Data flexibility fault
	        11      7,8                     Temperature monitoring fault
	        13      1,3,6,7.8,9,11,13,      Encoder 1 fault
	                15,22,23                
	        16      2,11,12,30              Startup fault
	        17      7                       Internal processor fault
	        18      1,3,4,7,8,9,10,12,13    Software fault
	        20      1,7                     Fault device monitoring
	        21      1                       S-Drive 1 fault
	        23      5,6,7,8                 Power section fault
	        25      10,12-19,50,51,81       Parameter memory monitoring
	        28      13                      FCB drive funcyio fault
	        33      1,2,6,7,8,10            System initialisation fault
	        46      1                       Safety card fault
	        
	    Function Control Block (FCB) codes
	    FBC = 01 Output stage inhibit 
	    FBC = 02 Default stop
	    FBC = 04 Manual Mode
	    FBC = 05 Speed control
	     101 - Speed-controlled jogging. Encoder feedback NOT required.
	     200 - Speed control. Encoder feedback NOT required.
	    FBC = 06 Interpolated speed control
	    FBC = 07 Torque control
	    FBC = 08 Interpolated torque control
	    FBC = 09 Positioning mode
	    400 - Absolute position control
	    401 - Relative position control
	    402 - Modulo position control - positive
	    403 - Modulo position control - negative
	    404 - Modulo position control - shortest distance
	    FBC = 10 Interpolated position control
	    FBC = 12 Referencing mode
	    300 - Reference travel - offset via parameter
	    301 - Reference travel - offset via fieldbus
	    FBC = 13 Stop at application limits
	    FBC = 14 Emergency stop
	    FBC = 18 Rotor position identification
	    FBC = 19 Position hold control
	    FBC = 20 Jog mode
	     100 - Position-controlled jogging. Encoder feedback required
	    FBC = 21 Brake test
	    FBC = 25 Motor parameter measurement
	    FBC = 26 Stop at user limits
	    
	    *)
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_VfdSEWMOVI-CPositioning"
TITLE = FB_VFD_SEW_MOVI-C_Positioning
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 36
// END_ATTRIBUTES
//Control SEW Servo VFD with multiple positions
   VAR_INPUT 
      iUDT_VfdConfig { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdPositioningConfiguration";   //  Configuration structure
      iUDT_VfdInputs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdSEWPositioningPI";   //  VFD inputs structure
      ix_MainPowerOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  True = Main power is ok
      ix_BackupPowerOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  True = back-up power is ok
      ix_SimulationModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Simulation On
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdPositioningStatus";   //  HMI status structure
      qUDT_VfdOutputs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdSEWPositioningPO";   //  VFD outputs structure
   END_VAR

   VAR_IN_OUT 
      iqUDT_VSUInterface : "UDT_VSUInterface";   //  VSU interface structure
      iqUDT_VFDStatistics : "UDT_VfdStatistics";   //  VFD statistics
   END_VAR

   VAR 
      sUDT_PNDevice { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PNDevice";   //  PN device info structure
      sUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdPositioningStatus";   //  Status struture
      sFB_TimerOnOffDelayCheckSupply { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //  MHS "TimerOnOffDelay" - to delay time for VFD supply contactor
      sFB_TimerOnOffDelayMoviKit { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //  MHS "TimerOnOffDelay" - to delay time for MoviKit response delay error
      sFB_TimerOnOffDelayPositioning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //  MHS "TimerOnOffDelay" - to delay time for Porisioning delay error
      sFB_TimerOnOffDelayFasterManualSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sFB_TimerOnOffDelayActivateInhibit { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sF_TRIG_LST {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //  Falling edge positioning feedback
      sR_TRIG_ManInPos {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge manual travel into position
      sR_TRIG_PNSlaveNotOnline {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge for trigger Profinet slave not online statistics
      sR_TRIG_PNSlaveError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge for trigger Profinet slave error statistics
      sR_TRIG_InternalError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge for trigger Internal VFD Error statistics
      sR_TRIG_CommunicationErrorMovikit {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge for trigger communication error Movikit statistics
      sR_TRIG_Running {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge for starting of the running signal
      sa_PNPortsStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..8] of Bool;   // TRUE when specific port has an error
      sr_ActualTorque { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   //  Actual torque of drive
      sdi_ActualPositionValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //  Actual position in mm
      si_ManualSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Actual manual speed
      si_ActualSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Actual speed in mm/s
      si_LastSwitchtime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  The actual time it took the last switch-over
      sx_ErrorActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  An error is active
      sx_WarningActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  A warning is active
      sx_PNDeviceHealthy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  PN Device is healthy, no errors
      sx_MovikitHandshakeIn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Handshake to movikit
      sx_MoviKitFeedback { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Movikit feedback delay
      sx_HardwareAvailable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  All hardware is on line and available
      sx_PowerOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  All Power (in and external) is ok
      sx_PositioningFeedback { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Positioning feedback delay
      sx_VFDReady { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  The VFD control is ready to operate
      sx_StartVFD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Start VFD
      sx_MotorRunning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  The servo motor is running
      sx_ManualPositionStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  A configured position is reached in manual mode
      sx_ManualPosHold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Hold in position
      sx_RestartMan { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Manual restart requested
      sx_ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Commissioning: configuration of parameters is wrong
      si_LoopCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      sx_Check { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_TEMP 
      tdi_EncoderPositionSetpoint : DInt;   //  Value of position setpoint
   END_VAR

   VAR CONSTANT 
      ci_NumberOfProfinetPorts : Int := 2;   // Number of Profinet ports in device
      ci_SpeedManualMode : Int := 100;   // Speed in manual mode for jogging
      ci_SpeedManualModeAfter5s : Int := 200;
   END_VAR


BEGIN
	(* 
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | P. Majka      | first release MHS TIA 15.1
	29/07/2019  | 0.2       | P. Majka      | Adding new functionality - comments to change
	30/07/2019  | 2.0       | P. Majka      | Moved to project with library 2.0
	31/07/2019  | 2.1       | M. Kurpiers   | Updating comments
	08/08/2019  | 2.2       | J.Krawczuk    | Updating referencing
	14/08/2019  | 2.3       | J.Krawczuk    | Added new functionality
	24/08/2019  | 2.4       | F. Baten      | Changed regions / combined errors / modified comments and working 
	05/11/2019  | 2.5       | S.Theocharis  | Change the VFDDeviceName to VFDPNDeviceName for consistency with rest VFD blocks
	20/11/2019  | 2.10      | S. Nikodem    | Configuration error
	20/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	28/02/2020  | 3.1       | F.Baten       | Reinstated positioning warning (Servo takes too long to get to position) and
	                                        | separated it again from OutOfPosition error (over running the set positions)
	01/02/2020  | 3.2       | F.Baten       | Changed "UDT_VFD_Status" to "UDT_VFD_PositioningStatus"
	04/02/2020  | 3.3       | F.Baten       | Changed VSU Rio interface - Error and ready modified.
	06/08/2020  | 3.4       | L.Klar        | Manual speed changed
	03/11/2020  | 3.5       | K.Pokorski    | Profinet ports diagnostics added 
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	06/10/2023  | 4.1       | F.Baten       | All positions converted to DINT as need of higher values for lift funtion
	14/06/2024  | 4.1       | R.Pieczonka   | Changed conditions for "EnableApplicationStop". Fixed setting output speed
	*)
	
	REGION 1 - Get Device Profinet information
	    
	    "FC_GetDevicePN"(is_PNDeviceName := #iUDT_VfdConfig.VFDPNDeviceName,
	                     ix_SimulationModeActive := #ix_SimulationModeActive,
	                     iqUDT_PND := #sUDT_PNDevice);
	    
	    
	    "FC_GetPNPortStatus"(ii_NumberOfPorts := #ci_NumberOfProfinetPorts,
	                         iUDT_DevicePNInfo := #sUDT_PNDevice,
	                         qa_PortFault => #sa_PNPortsStatus);
	    
	END_REGION
	
	REGION 2 - Reset errors
	    
	    IF #iqUDT_VSUInterface.InternalErrorReset
	        
	    THEN
	        #sUDT_HMIStatus.CommunicationErrorMovikit := FALSE;                    // The Movikit application is not reacting 
	        #sUDT_HMIStatus.PNSlaveNotOnline := FALSE;                             // Profinet slave is not on line
	        #sUDT_HMIStatus.PNSlaveError := FALSE;                                 // Profinet slave has an error
	        #sUDT_HMIStatus.PositioningTimeOutError := FALSE;                      // Reset positioning error 
	        #sUDT_HMIStatus.InternalError := FALSE;                                // Reset internal error
	        #sUDT_HMIStatus.PNSlaveWarning := FALSE;
	        
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Check Hardware
	    
	    REGION 3.1 - Power OK
	        // Hardware will be available after delay so the device has time for initialisation
	        #sFB_TimerOnOffDelayCheckSupply(iudi_OnDelayTime := 2000,              // Set time for on delay 
	                                        ix_SignalToDelay := #ix_MainPowerOk);  // Mains are ok
	        
	        #sx_PowerOK := #sFB_TimerOnOffDelayCheckSupply.qx_DelayedSignal;       // And All Power (in and external) is ok
	    END_REGION
	    
	    REGION 3.2 - PN Healthy Check
	        
	        IF NOT "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.Exist     // Or the connected device doesn't exist 
	            AND NOT #ix_SimulationModeActive                                    // And not in simulation   
	            AND (#sx_PowerOK                                                    // Main Power is ok
	            OR #ix_BackupPowerOk)                                               // Or backup power is ok
	        THEN
	            #sUDT_HMIStatus.PNSlaveNotOnline := TRUE;
	        END_IF;
	        
	        // Check if PN ports are healthy 
	        IF #sa_PNPortsStatus[1] XOR #sa_PNPortsStatus[2] THEN
	            #sUDT_HMIStatus.PNSlaveWarning := TRUE;
	        END_IF;
	        
	        IF "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.Error       // Or the device has an error 
	            AND NOT #ix_SimulationModeActive                                    // And not in simulation 
	            AND (#sx_PowerOK                                                    // Main Power is ok
	            OR #ix_BackupPowerOk)                                               // Or backup power is ok
	            AND NOT #sUDT_HMIStatus.PNSlaveWarning                             // and PN ports are healthy
	            
	        THEN
	            #sUDT_HMIStatus.PNSlaveError := TRUE;                              // Profinet slave has an error
	        END_IF;
	        
	        #sx_PNDeviceHealthy := NOT #sUDT_HMIStatus.PNSlaveNotOnline            // Or the device an error 
	        AND NOT #sUDT_HMIStatus.PNSlaveError                                   // Profinet slave has an error
	        AND (#sx_PowerOK                                                        // Main Power is ok
	        OR #ix_BackupPowerOk)                                                   // Or backup power is ok
	        AND #sUDT_PNDevice.PNDeviceFound;                                      // Device is found in network configuration
	        
	    END_REGION
	    
	    // Hardware is available 
	    #sx_HardwareAvailable := #iUDT_VfdInputs.Status_Word_1.STO_Inactive        // Safety is ok
	    AND #sx_PowerOK                                                             // All mains are ok
	    AND #sx_PNDeviceHealthy                                                     // No PN errors
	    OR #ix_SimulationModeActive;                                                // Or simulation active 
	    
	    REGION 3.3 - Check communication MoviKit
	        #sx_MoviKitFeedback :=                                                  // Set MoviKit feedback delay
	        ((#sx_MovikitHandshakeIn                                                // IF MoviKit handshake input is active 
	        AND NOT #iUDT_VfdInputs.Status_Word_1.MovikitHandshakeOut)             // And MoviKit handshake output active 
	        OR (NOT #sx_MovikitHandshakeIn                                          // Or MoviKit handshake input isn't active 
	        AND #iUDT_VfdInputs.Status_Word_1.MovikitHandshakeOut));               // And MoviKit handshake output isn't active 
	        
	        #sFB_TimerOnOffDelayMoviKit(iudi_OnDelayTime := 1000,                  // Set on delay time to 1000
	                                    ix_SignalToDelay := NOT #sx_MoviKitFeedback);          // Start timer  
	        
	        IF (#sFB_TimerOnOffDelayMoviKit.qx_DelayedSignal)                      // If the timer elapsed 
	            AND #sx_HardwareAvailable
	        THEN
	            #sUDT_HMIStatus.CommunicationErrorMovikit := TRUE;                 // Set MoviKit error 
	        END_IF;
	        
	        #sx_MovikitHandshakeIn := NOT #iUDT_VfdInputs.Status_Word_1.MovikitHandshakeOut;   // Set the Handshake signal
	    END_REGION
	    
	    
	END_REGION
	
	REGION 4 - Handle input data
	    
	    REGION 4.1 - Move to status
	        
	        #sr_ActualTorque := INT_TO_REAL(#iUDT_VfdInputs.ActualTorque) / 1000.0 * #iUDT_VfdConfig.TorqueMax;   // Writing actual real calculated torque
	        #si_ActualSpeed := #iUDT_VfdInputs.ActualSpeed;                                                        // Actual speed in mm/s 
	        #sx_MotorRunning := #iUDT_VfdInputs.Status_Word_1.DriveActive;                                         // Set status motor running if motor shaft is turning 
	        
	    END_REGION
	    
	    REGION 4.2 - Actual positon value
	        
	        #sdi_ActualPositionValue := SHL(IN := (WORD_TO_DINT(IN := #iUDT_VfdInputs.ActualPosition_hW)), N := 16) + WORD_TO_DINT(IN := #iUDT_VfdInputs.ActualPosition_lW);   // Calculate actual encoder position from two words  
	        
	        IF #sdi_ActualPositionValue <= (#iUDT_VfdConfig.Position[#iqUDT_VSUInterface.PositionSetpoint] + #iUDT_VfdConfig.PositionWindow)         // If actual encoder position in mm is lower or equal to position setpoint plus position window 
	            AND #sdi_ActualPositionValue >= (#iUDT_VfdConfig.Position[#iqUDT_VSUInterface.PositionSetpoint] - #iUDT_VfdConfig.PositionWindow)    // And actual encoder position in mm is greater or equal to position setpoint minus position window 
	            
	        THEN
	            #iqUDT_VSUInterface.PositionActual := #iqUDT_VSUInterface.PositionSetpoint;                                              // Write position setpoint TO actual position number when position setpoint reached 
	        ELSIF #iqUDT_VSUInterface.Manual
	        THEN
	            #sx_Check := FALSE;
	            FOR #si_LoopCounter := 0 TO "FC_GetNrOfArrayEl"(iv_Array := #iUDT_VfdConfig.Position) DO
	                IF #sdi_ActualPositionValue <= (#iUDT_VfdConfig.Position[#si_LoopCounter] + #iUDT_VfdConfig.PositionWindow)
	                    AND #sdi_ActualPositionValue >= (#iUDT_VfdConfig.Position[#si_LoopCounter] - #iUDT_VfdConfig.PositionWindow)
	                THEN
	                    #iqUDT_VSUInterface.PositionActual := #si_LoopCounter;
	                    #sx_Check := TRUE;
	                END_IF;
	            END_FOR;
	            IF #sx_Check = 0 THEN
	                #iqUDT_VSUInterface.PositionActual := 0;
	            END_IF;
	        ELSE
	            #iqUDT_VSUInterface.PositionActual := 0;
	        END_IF;
	        
	        
	        
	        
	    END_REGION
	    
	    REGION 4.3 - Manual position
	        // to stop at a predefined position when jogging, after the stop the movement can continue by pressing the jogbutton again
	        IF #iUDT_VfdInputs.Mode = 100                                                                          // The actual application mode is equal to 100
	        THEN
	            #sx_ManualPositionStop :=
	            (#sdi_ActualPositionValue <= (#iUDT_VfdConfig.Position[1] + #iUDT_VfdConfig.PositionWindow)       // IF actual encoder position in mm is lower OR equal TO position setpoint plus position window 
	            AND #sdi_ActualPositionValue >= (#iUDT_VfdConfig.Position[1] - #iUDT_VfdConfig.PositionWindow))   // And actual encoder position in mm is greater or equal to position setpoint minus position window
	            OR (#sdi_ActualPositionValue <= (#iUDT_VfdConfig.Position[2] + #iUDT_VfdConfig.PositionWindow)    // IF actual encoder position in mm is lower OR equal TO position setpoint plus position window 
	            AND #sdi_ActualPositionValue >= (#iUDT_VfdConfig.Position[2] - #iUDT_VfdConfig.PositionWindow))   // And actual encoder position in mm is greater or equal to position setpoint minus position window
	            OR (#sdi_ActualPositionValue <= (#iUDT_VfdConfig.Position[3] + #iUDT_VfdConfig.PositionWindow)    // IF actual encoder position in mm is lower OR equal TO position setpoint plus position window 
	            AND #sdi_ActualPositionValue >= (#iUDT_VfdConfig.Position[3] - #iUDT_VfdConfig.PositionWindow))   // And actual encoder position in mm is greater or equal to position setpoint minus position window
	            OR (#sdi_ActualPositionValue <= (#iUDT_VfdConfig.Position[4] + #iUDT_VfdConfig.PositionWindow)    // IF actual encoder position in mm is lower OR equal TO position setpoint plus position window 
	            AND #sdi_ActualPositionValue >= (#iUDT_VfdConfig.Position[4] - #iUDT_VfdConfig.PositionWindow))   // And actual encoder position in mm is greater or equal to position setpoint minus position window
	            OR (#sdi_ActualPositionValue <= (#iUDT_VfdConfig.Position[5] + #iUDT_VfdConfig.PositionWindow)    // IF actual encoder position in mm is lower OR equal TO position setpoint plus position window 
	            AND #sdi_ActualPositionValue >= (#iUDT_VfdConfig.Position[5] - #iUDT_VfdConfig.PositionWindow))   // And actual encoder position in mm is greater or equal to position setpoint minus position window
	            OR (#sdi_ActualPositionValue <= (#iUDT_VfdConfig.Position[6] + #iUDT_VfdConfig.PositionWindow)    // IF actual encoder position in mm is lower OR equal TO position setpoint plus position window 
	            AND #sdi_ActualPositionValue >= (#iUDT_VfdConfig.Position[6] - #iUDT_VfdConfig.PositionWindow))   // And actual encoder position in mm is greater or equal to position setpoint minus position window
	            OR (#sdi_ActualPositionValue <= (#iUDT_VfdConfig.Position[7] + #iUDT_VfdConfig.PositionWindow)    // IF actual encoder position in mm is lower OR equal TO position setpoint plus position window 
	            AND #sdi_ActualPositionValue >= (#iUDT_VfdConfig.Position[7] - #iUDT_VfdConfig.PositionWindow))   // And actual encoder position in mm is greater or equal to position setpoint minus position window
	            OR (#sdi_ActualPositionValue <= (#iUDT_VfdConfig.Position[8] + #iUDT_VfdConfig.PositionWindow)    // IF actual encoder position in mm is lower OR equal TO position setpoint plus position window 
	            AND #sdi_ActualPositionValue >= (#iUDT_VfdConfig.Position[8] - #iUDT_VfdConfig.PositionWindow))   // And actual encoder position in mm is greater or equal to position setpoint minus position window
	            OR (#sdi_ActualPositionValue <= (#iUDT_VfdConfig.Position[9] + #iUDT_VfdConfig.PositionWindow)    // IF actual encoder position in mm is lower OR equal TO position setpoint plus position window 
	            AND #sdi_ActualPositionValue >= (#iUDT_VfdConfig.Position[9] - #iUDT_VfdConfig.PositionWindow))   // And actual encoder position in mm is greater or equal to position setpoint minus position window
	            OR (#sdi_ActualPositionValue <= (#iUDT_VfdConfig.Position[10] + #iUDT_VfdConfig.PositionWindow)   // IF actual encoder position in mm is lower OR equal TO position setpoint plus position window 
	            AND #sdi_ActualPositionValue >= (#iUDT_VfdConfig.Position[10] - #iUDT_VfdConfig.PositionWindow)); // And actual encoder position in mm is greater or equal to position setpoint minus position window
	        END_IF;
	    END_REGION
	END_REGION
	
	REGION 5 - Errors and warnings
	    
	    REGION 5.1 - VFD internal error 
	        
	        #sUDT_HMIStatus.InternalError := #iUDT_VfdInputs.Status_Word_1.Error; // An internal VFD error is active
	        #sUDT_HMIStatus.ErrorCode := #iUDT_VfdInputs.StatusErrorNo.%B1;       // Copy VFD error code from static status structure to HMI status structure 
	        #sUDT_HMIStatus.SubErrorCode := #iUDT_VfdInputs.StatusErrorNo.%B0;    // Copy VFD sub-error code from static status structure to HMI status structure 
	        
	        IF NOT #iUDT_VfdInputs.Status_Word_1.Error
	            AND NOT #iUDT_VfdInputs.Status_Word_1.Warning
	        THEN
	            #sUDT_HMIStatus.ErrorCode := 0;                                    // Copy VFD error code from static status structure TO HMI status structure 
	            #sUDT_HMIStatus.SubErrorCode := 0;                                 // Copy VFD sub-error code from static status structure to HMI status structure 
	        END_IF;
	    END_REGION
	    
	    REGION 5.2 - Positioning error
	        // This timer checks if the speed of the VFD is ok.
	        // The VFD should reach is next destination in the given time
	        // 
	        
	        #sx_PositioningFeedback := #iqUDT_VSUInterface.PositionActual <> #iqUDT_VSUInterface.PositionSetpoint // If actual position is different than setpoint position 
	        AND #iqUDT_VSUInterface.Automatic;                                                                     // And in automatic mode 
	        
	        #sF_TRIG_LST(CLK := #sx_PositioningFeedback);
	        
	        IF #sF_TRIG_LST.Q
	        THEN
	            #si_LastSwitchtime := LREAL_TO_INT(#sFB_TimerOnOffDelayPositioning.qlr_ActualTime);
	        END_IF;
	        
	        
	        
	        #sFB_TimerOnOffDelayPositioning(iudi_OnDelayTime := (#iqUDT_VSUInterface.SwitchingTime),  // Set on delay time 
	                                        ix_SignalToDelay := #sx_PositioningFeedback);              // Start timer when positioning feedback delay 
	        
	        
	        
	        IF #sFB_TimerOnOffDelayPositioning.qx_DelayedSignal                    // If the time elapsed
	        THEN
	            
	            #sUDT_HMIStatus.PositioningTimeOutError := TRUE;                   // Set positioning warning
	            
	        END_IF;
	    END_REGION
	    
	    REGION 5.3 - Common Error
	        // Set VFD error active
	        #sx_ErrorActive := #sUDT_HMIStatus.InternalError                       // The VFD indicates an active error
	        OR #sUDT_HMIStatus.CommunicationErrorMovikit;                          // The block generated an communication error
	        
	    END_REGION
	    
	    REGION 5.4 - Configuration Warning
	        //  Check if no faulty setup is active
	        //  This is the responcebility of the commisioning engineer 
	        
	        IF #iUDT_VfdConfig.PositionMax > #iUDT_VfdConfig.PositionMin          // Max position is bigger than min position
	            AND #iUDT_VfdConfig.PositionMax > 0                                // and not 0
	            AND #iUDT_VfdConfig.VFDSpeed > 0                                   // Max speed is not 0
	            AND #iUDT_VfdConfig.VFDAccDecel > 0                                // Maximum acceleration an deceleration time is not 0
	            AND "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.Configure
	        THEN
	            #sx_ConfigurationError := FALSE;                                    // Reset the configuration warning   
	        ELSE
	            #sx_ConfigurationError := TRUE;                                     // Set configuration warning
	        END_IF;
	    END_REGION
	    
	    REGION 5.5 - Common warning
	        // Set VFD warning active
	        #sx_WarningActive := #iUDT_VfdInputs.Status_Word_1.Warning             // The VFD indicates an active warning
	        OR #sUDT_HMIStatus.PositioningTimeOutError;                                 // The VFD did not reach the position in time.
	        
	    END_REGION
	    
	END_REGION
	
	REGION 6 - Check conditions to set VFD Ready signals
	    
	    REGION 6.1 - Internal VFD ready
	        
	        #sx_VFDReady := #sx_HardwareAvailable                                   // The hardware is powered up and detected
	        AND (#iUDT_VfdInputs.Status_Word_1.InverterReady                       // And VFD is ready to start
	        OR #sx_MotorRunning)                                                    // Or motor running 
	        AND NOT #sx_ErrorActive                                                 // And no VFD error active      
	        AND NOT #sx_ConfigurationError;
	        // AND NOT (#iqUDT_VSUInterface.PositionActual = #iqUDT_VSUInterface.RequestedPosition);    /// Commented out because  it was causing issues for the refernce drive                                // And no configuration error
	        
	    END_REGION
	    
	    REGION 6.2 - External VFD ready (to control)
	        
	        #iqUDT_VSUInterface.Ready :=                                           // Signal ready is active if:
	        (#iqUDT_VSUInterface.Automatic                                         // And automatic mode request
	        AND NOT #iqUDT_VSUInterface.Manual                                     // And no manual mode request
	        AND #iUDT_VfdInputs.Status_Word_1.Referenced                           // And the drive is referenced
	        AND #iUDT_VfdInputs.Mode = 400)                                        // Actual application mode is equal to 400
	        OR
	        (NOT #iqUDT_VSUInterface.Automatic                                     // No automatic mode request 
	        AND #iqUDT_VSUInterface.Manual                                         // AND manual mode request 
	        AND #iUDT_VfdInputs.Mode = 100)                                        // And the actual application mode is equal to 100
	        OR
	        (#iqUDT_VSUInterface.Reference_command                                 // And the "refference" command is active
	        AND #iUDT_VfdInputs.Mode = 301)                                        // The actual application mode is equal TO 301
	        AND
	        (#sx_VFDReady                                                           // Status ready is active
	        AND #iqUDT_VSUInterface.RunEnabled);                                   // And running of the lifting device is enabled by VSU
	        
	    END_REGION
	END_REGION
	
	REGION 7 - Set VFD control data 
	    
	    REGION 7.1 - Stop VFD
	        
	        IF NOT #iqUDT_VSUInterface.Ready                                       // If VFD isn't ready to operate
	        THEN
	            
	            #sx_StartVFD := FALSE;                                              // Reset start VFD 
	            #qUDT_VfdOutputs.SetpointMode := 0;                                // Set the application mode to 0
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 7.3 - Reference VFD
	        
	        IF #sx_VFDReady                                                         // If status VFD ready to operate is active 
	            AND #iqUDT_VSUInterface.Reference_command                          // And the "refference" command is active 
	        THEN
	            
	            #qUDT_VfdOutputs.SetpointMode := 301;                              // Selecting FCB for reference travel FCB = 12 
	            
	            #tdi_EncoderPositionSetpoint := #iUDT_VfdConfig.Position[0];                                  // Set the position value as refference
	            #qUDT_VfdOutputs.SetpointPosition_hW := DINT_TO_WORD(SHR(IN := (#tdi_EncoderPositionSetpoint), N := 16));  // Send new position to encoder - high word 
	            #qUDT_VfdOutputs.SetpointPosition_lW := DINT_TO_WORD(IN := #tdi_EncoderPositionSetpoint);                  // Send new position TO encoder - low word 
	        END_IF;
	        
	        
	        IF #iqUDT_VSUInterface.Ready AND                                       // If VFD system is ready to operation
	            #iUDT_VfdInputs.Mode = 301                                         // And actual application mode  is equal to 301
	        THEN
	            
	            #sx_StartVFD := TRUE;                                               // Set start VFD 
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 7.4 - Manual mode - jogging
	        
	        IF #sx_VFDReady                                                         // If status VFD ready to operation is active
	            AND #iqUDT_VSUInterface.Manual                                     // And manual mode request is active 
	            AND NOT #iqUDT_VSUInterface.Automatic                              // And automatic mode request isn't active 
	            AND #iqUDT_VSUInterface.RunEnabled                                 // And running of the lifting device is enabled by VSU
	            AND NOT #iqUDT_VSUInterface.Reference_command                      // And the "refference" command isn't active 
	            
	        THEN
	            
	            #qUDT_VfdOutputs.SetpointMode := 100;                              // Selecting FCB for position-controlled jogging FCB = 20 
	            
	        END_IF;
	        
	        // On position while jogging: stop, when button is released and pressed again continue to travel
	        // 
	        #sR_TRIG_ManInPos(CLK := #sx_ManualPositionStop);
	        
	        #sx_ManualPosHold := (#sx_ManualPosHold                                 // Hold movement as long as buttons are pressed  
	        OR #sR_TRIG_ManInPos.Q)                                                // trigger position reached
	        AND (#iqUDT_VSUInterface.JogUp                                         // jogging up active
	        OR #iqUDT_VSUInterface.JogDown)                                        // jogging down active
	        AND #iqUDT_VSUInterface.Ready;                                         // ready to operate
	        
	        // Jog commands
	        
	        IF #iqUDT_VSUInterface.Ready                                           // If the VFD system is ready to operate 
	            AND (#iUDT_VfdInputs.Mode = 100)                                   // And the actual application mode is equal to 100
	            AND #iqUDT_VSUInterface.JogUp                                      // And selected jog in positive direction 
	            AND NOT #iqUDT_VSUInterface.JogDown                                // And not selected jog in negative direction  
	            AND NOT #sx_ManualPosHold
	        THEN
	            
	            #qUDT_VfdOutputs.Control_Word_1.JogPos := TRUE;                                                // Set jog positive VFD control bit 
	            #qUDT_VfdOutputs.Control_Word_1.JogNeg := FALSE;                                               // Reset jog negative VFD control bit 
	            
	        ELSIF
	            #iqUDT_VSUInterface.Ready                                          // If the VFD system is ready to operate 
	            AND (#iUDT_VfdInputs.Mode = 100)                                   // And the actual application mode is equal to 100
	            AND NOT #iqUDT_VSUInterface.JogUp                                  // And not selected jog in positive direction 
	            AND #iqUDT_VSUInterface.JogDown                                    // And selected jog in negative direction  
	            AND NOT #sx_ManualPosHold
	        THEN
	            
	            #qUDT_VfdOutputs.Control_Word_1.JogPos := FALSE;                   // Reset jog positive VFD control bit 
	            #qUDT_VfdOutputs.Control_Word_1.JogNeg := TRUE;                    // Set jog negative VFD control bit 
	            
	        ELSE
	            
	            #qUDT_VfdOutputs.Control_Word_1.JogPos := FALSE;                   // Reset jog positive VFD control bit 
	            #qUDT_VfdOutputs.Control_Word_1.JogNeg := FALSE;                   // Reset jog negative VFD control bit 
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 7.5 - Automatic mode - for positioning
	        
	        IF #sx_VFDReady                                                         // If status VFD ready to operation is active 
	            AND #iqUDT_VSUInterface.Automatic                                  // And automatic mode request is active 
	            AND NOT #iqUDT_VSUInterface.Manual                                 // And manual mode request isn't active
	            AND #iqUDT_VSUInterface.RunEnabled                                 // And running of the lifting device is enabled by VSU 
	            AND #iUDT_VfdInputs.Status_Word_1.Referenced                       // And the drive is referenced 
	            AND NOT #iqUDT_VSUInterface.Reference_command                      // And the "refference" command isn't active
	            
	        THEN
	            
	            #qUDT_VfdOutputs.SetpointMode := 400;                              // Select FCB for absolute positioning control FCB = 09 
	            
	        END_IF;
	        
	        IF #iqUDT_VSUInterface.Ready AND                                       // IF VFD system is ready TO operation 
	            #iUDT_VfdInputs.Mode = 400                                         // And actual application mode is equal to 400
	        THEN
	            
	            #tdi_EncoderPositionSetpoint := #iUDT_VfdConfig.Position[#iqUDT_VSUInterface.PositionSetpoint];    // Move position request to setpoint postion 
	            #qUDT_VfdOutputs.SetpointPosition_hW := DINT_TO_WORD(SHR(IN := (#tdi_EncoderPositionSetpoint), N := 16));         // Send new position to encoder - high word 
	            #qUDT_VfdOutputs.SetpointPosition_lW := DINT_TO_WORD(IN := #tdi_EncoderPositionSetpoint);                         // Send new position to encoder - low word 
	            #sx_StartVFD := TRUE;
	            
	        END_IF;
	        
	    END_REGION
	    
	    
	    REGION 7.6 - Set output speed
	        
	        // When the drive was manual operated, first start in manual speed to go to position
	        
	        #si_ManualSpeed := #ci_SpeedManualMode;                                 // Manual speed setpoint
	        
	        IF (#iqUDT_VSUInterface.Manual                                          // Manual command is activated
	            OR #iqUDT_VSUInterface.GoReference)
	            AND NOT #iqUDT_VSUInterface.Automatic
	        THEN
	            #sx_RestartMan := TRUE;                                             // Set memory Manual was activated
	        END_IF;
	        
	        IF #iqUDT_VSUInterface.PositionActual = #iqUDT_VSUInterface.PositionSetpoint     // Signal from VFD, indicating being in position
	            OR #iqUDT_VSUInterface.Automatic
	        THEN
	            #sx_RestartMan := FALSE;                                            // Reset memory Manual was activated
	        END_IF;
	        
	        
	        IF #iUDT_VfdInputs.Mode = 400                                          // If actual application mode is Auto ( 400 )
	        THEN
	            IF NOT #sx_RestartMan                                               // Manual was not activated
	                
	            THEN
	                #qUDT_VfdOutputs.SetpointSpeed := #iUDT_VfdConfig.VFDSpeed;   // Move speedsetpoint to output
	            ELSE                                                                // If manual was activated then
	                #qUDT_VfdOutputs.SetpointSpeed := #si_ManualSpeed;             // Move manual speedsetpoint to output
	            END_IF;
	            
	        ELSIF #iUDT_VfdInputs.Mode = 100                                       // If actual application mode is manual ( 100 )
	        THEN
	            
	            #qUDT_VfdOutputs.SetpointSpeed := #si_ManualSpeed;                 // Move manual speedsetpoint TO output
	            
	        END_IF;
	        
	    END_REGION
	    
	    
	    REGION 7.8 - Other control signals to VFD
	        
	        #qUDT_VfdOutputs.Control_Word_1.EnableRapidStop := (#sx_HardwareAvailable AND #iqUDT_VSUInterface.RunEnabled); // Writing states of VFD power is ready or simulation to enable VFD to run   
	        #qUDT_VfdOutputs.Control_Word_1.EnableApplicationStop := #sx_VFDReady AND ((NOT (#sdi_ActualPositionValue = #tdi_EncoderPositionSetpoint) AND #iqUDT_VSUInterface.Automatic) OR (#iqUDT_VSUInterface.Manual AND ((#iqUDT_VSUInterface.JogDown OR #iqUDT_VSUInterface.JogUp) OR #iqUDT_VSUInterface.Reference_command)));                             // Writing state to enable VFD operation  
	        #qUDT_VfdOutputs.Control_Word_1.ReleaseBrake := FALSE;                                             // Not used
	        #qUDT_VfdOutputs.Control_Word_1.ApplyRelativePositioning := FALSE;                                 // Not used for speed control 
	        #qUDT_VfdOutputs.Control_Word_1.StartStop := #sx_StartVFD;                                         // Writing state to start or stop VFD 
	        #qUDT_VfdOutputs.Control_Word_1.ResetError := #iqUDT_VSUInterface.InternalErrorReset;             // Reseting VFD errors with error reset bit 
	        #qUDT_VfdOutputs.Control_Word_1.ActivateDriveTrain2 := FALSE;                                      // Not used for MoviGear with on Drive Train 
	        #qUDT_VfdOutputs.Control_Word_1.DeactivateSW_LimitSwitch := FALSE;                                 // Not used 
	        #qUDT_VfdOutputs.Control_Word_1.ActivateInhibit := NOT #sx_VFDReady;                                // Controller Inhibit has to be "false" before start/stop
	        #qUDT_VfdOutputs.Control_Word_1.ActivateStandby := FALSE;                                          // Not used 
	        #qUDT_VfdOutputs.Control_Word_1.MovikitHandshakeIn := #sx_MovikitHandshakeIn;                      // Set "MoviKit" handshake input to 1 by 0.5 sec.
	        
	    END_REGION
	    
	    REGION 7.9 - Acceleration and deceleration ramps 
	        
	        #qUDT_VfdOutputs.SetpointAcceleration := #iUDT_VfdConfig.VFDAccDecel;
	        #qUDT_VfdOutputs.SetpointDeceleration := #iUDT_VfdConfig.VFDAccDecel;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 8 - In case of communication error reset VFD outputs
	    
	    IF NOT #sx_HardwareAvailable                                                                            // If hardware is not available
	        
	    THEN
	        
	        #qUDT_VfdOutputs.Control_Word_1.ResetError := FALSE;                                               // Reset reset VFD error 
	        #qUDT_VfdOutputs.Control_Word_1.ActivateDriveTrain2 := FALSE;                                      // Reset activate drive train 
	        #qUDT_VfdOutputs.Control_Word_1.DeactivateSW_LimitSwitch := FALSE;                                 // Reset deactivate software limit switch 
	        #qUDT_VfdOutputs.Control_Word_1.ActivateInhibit := FALSE;                                          // Reset activate inhibit
	        #qUDT_VfdOutputs.Control_Word_1.ActivateStandby := FALSE;                                          // Reset activate standby 
	        #qUDT_VfdOutputs.Control_Word_1.MovikitHandshakeIn := FALSE;                                       // Reset movikit hanshake input 
	        #qUDT_VfdOutputs.Control_Word_1.EnableRapidStop := FALSE;                                          // Reset enable rapid stop
	        #qUDT_VfdOutputs.Control_Word_1.EnableApplicationStop := FALSE;                                    // Reset enable application stop
	        #qUDT_VfdOutputs.Control_Word_1.ReleaseBrake := FALSE;                                             // Reset release brake
	        #qUDT_VfdOutputs.Control_Word_1.JogPos := FALSE;                                                   // Reset jog in positive direction 
	        #qUDT_VfdOutputs.Control_Word_1.JogNeg := FALSE;                                                   // Reset jog in negative direction
	        #qUDT_VfdOutputs.Control_Word_1.ApplyRelativePositioning := FALSE;                                 // Reset applying relatice positioning 
	        #qUDT_VfdOutputs.Control_Word_1.StartStop := FALSE;                                                // Reset Start/Stop VFD
	    END_IF;
	END_REGION
	
	REGION 9 - Statistics
	    
	    // Number OF times the VFD had an internal error
	    
	    #sR_TRIG_PNSlaveNotOnline(CLK := #sUDT_HMIStatus.PNSlaveNotOnline);       // Detect the rising edge of the error
	    
	    IF #iqUDT_VSUInterface.ResetStatistics OR                                  // If there is signal to reset statistics from VSU interface  
	        #sUDT_HMIStatus.PNSlaveNotOnline                                       // Or the error occured
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics,       // Reset statistics
	                        ix_Activate := #sUDT_HMIStatus.PNSlaveNotOnline,       // Actual error
	                        ix_RTrigActivate := #sR_TRIG_PNSlaveNotOnline.Q,       // Trigger rising edge error
	                        iqUDT_Statistics := #iqUDT_VFDStatistics.PNSlaveNotOnline);   // Statistics structure
	    END_IF;
	    
	    // Number of ethernet communication faults to VFD drive
	    
	    #sR_TRIG_PNSlaveError(CLK := #sUDT_HMIStatus.PNSlaveError);               // Detect the rising edge of the error
	    IF #iqUDT_VSUInterface.ResetStatistics OR                                  // If there is signal to reset statistics from VSU interface  
	        #sUDT_HMIStatus.PNSlaveError                                           // Or the error occured
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics,       // Reset statistics
	                        ix_Activate := #sUDT_HMIStatus.PNSlaveError,           // Actual error
	                        ix_RTrigActivate := #sR_TRIG_PNSlaveError.Q,           // Trigger rising edge error 
	                        iqUDT_Statistics := #iqUDT_VFDStatistics.PNSlaveError);       // Statistics structure
	        
	    END_IF;
	    
	    
	    // Number of times the VFD had an internal error
	    
	    #sR_TRIG_InternalError(CLK := #sUDT_HMIStatus.InternalError);             // Detect the rising edge of the error
	    
	    IF #iqUDT_VSUInterface.ResetStatistics OR                                  // IF there is signal TO reset statistics from VSU interface   
	        #sUDT_HMIStatus.InternalError                                          // Or the error occured
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics,       // Reset statistics
	                        ix_Activate := #sUDT_HMIStatus.InternalError,          // Actual error
	                        ix_RTrigActivate := #sR_TRIG_InternalError.Q,          // Trigger rising edge error
	                        iqUDT_Statistics := #iqUDT_VFDStatistics.VFDInternalError);       // Statistics structure
	        
	    END_IF;
	    
	    // Number OF times the VFD had a safety error
	    
	    #sR_TRIG_CommunicationErrorMovikit(CLK := #sUDT_HMIStatus.CommunicationErrorMovikit); // Detect the rising edge of the error
	    
	    IF #iqUDT_VSUInterface.ResetStatistics OR                                  // If there is signal to reset statistics from VSU interface  
	        #sUDT_HMIStatus.CommunicationErrorMovikit                              // Or the error occured
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics,       // Reset statistics
	                        ix_Activate := #sUDT_HMIStatus.CommunicationErrorMovikit,              // Actual error
	                        ix_RTrigActivate := #sR_TRIG_CommunicationErrorMovikit.Q,              // Trigger rising edge error
	                        iqUDT_Statistics := #iqUDT_VFDStatistics.CommunicationErrorMovikit);  // Statistics structure
	        
	    END_IF;
	    
	    // Number of times the VFD has been running
	    
	    #sR_TRIG_Running(CLK := #iUDT_VfdInputs.Status_Word_1.DriveActive);       // Detect the rising edge of the signal
	    
	    IF #iqUDT_VSUInterface.ResetStatistics OR                                  // If there is signal to reset statistics from VSU interface  
	        #iUDT_VfdInputs.Status_Word_1.STO_Inactive                             // Or the status occured
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics,       // Reset statistics
	                        ix_Activate := #iUDT_VfdInputs.Status_Word_1.DriveActive,  // Actual status
	                        ix_RTrigActivate := #sR_TRIG_Running.Q,                // Trigger rising edge 
	                        iqUDT_Statistics := #iqUDT_VFDStatistics.Running);    // Statistics structure
	        
	    END_IF;
	END_REGION
	
	REGION 10 - Write interface outputs
	    
	    //Internal Error
	    #iqUDT_VSUInterface.InternalErrorVFD := #sx_ErrorActive;                   // Set the internal VFD error bit in VSU interface IF Any fault is active 
	    
	    //Internal Warning
	    #iqUDT_VSUInterface.InternalWarningVFD := #sx_WarningActive;               // Set the internal VFD warning bit if any warning is active 
	    
	    //Motor running
	    #iqUDT_VSUInterface.MotorRunning := #iUDT_VfdInputs.Status_Word_1.DriveActive;    // Set motor is running in VSU interface IF status control Word "motor running" is active 
	    
	    //Send signal VFD is referenced
	    #iqUDT_VSUInterface.Referenced := #iUDT_VfdInputs.Status_Word_1.Referenced;       // Write state of drive is referenced from VFD to VSU interface 
	    
	    
	    #iqUDT_VSUInterface.Positioning := #iqUDT_VSUInterface.PositionSetpoint <> #iqUDT_VSUInterface.PositionActual  // Set the lifting device is positioning if position setpoint is different than actual position 
	    AND #iqUDT_VSUInterface.Automatic                                      // AND automatic mode enabled 
	    AND NOT #iqUDT_VSUInterface.InternalErrorVFD;                          // And internal error VFD no occurred  
	    
	    #iqUDT_VSUInterface.StartLowSpeed := #sx_RestartMan;                       // Indicating to VSU the VSD is starting in low speed
	    
	    #qUDT_HMIStatus := #sUDT_HMIStatus;                                       // Copy status to output
	END_REGION
	
	REGION 11 - error codes
	    (*
	    FCB number |                       | Meaning
	    ______________________________________________________________________________________________________________
	        1                               Output stage inhibit 
	        2                               Default stop
	        4                               Manual Mode
	        5                               Speed control
	                101                     Speed-controlled jogging. Encoder feedback NOT required.
	                200                     Speed control. Encoder feedback NOT required.
	        6                               Interpolated speed control
	        7                               Torque control
	        8                               Interpolated torque control
	        9                               Positioning mode
	                400                     Absolute position control
	                401                     Relative position control
	                402                     Modulo position control - positive
	                403                     Modulo position control - negative
	                404                     Modulo position control - shortest distance
	        10                              Interpolated position control
	        12                              Referencing mode
	                300                     Reference travel - offset via parameter
	                301                     Reference travel - offset via fieldbus
	        13                              Stop at application limits
	        14                              Emergency stop
	        18                              Rotor position identification
	        19                              Position hold control
	        20                              Jog mode
	                100                     Position-controlled jogging. Encoder feedback required
	        21                              Brake test
	        25                              Motor parameter measurement
	        26                              Stop at user limits
	              
	    
	    Error code | Suberror code        | Meaning                                | Measure  
	    ______________________________________________________________________________________________________________
	        3       1                       Ground fault                            Consult "Fault table" in  
	        4       1                       Brake chopper fault                     document 'SEW Movigear-C 25887130.PDF'
	        6       1                       Line fault                              Chapter 8.7
	        7       1                       DC link fault
	        8       1,2,3                   Speed monitoring fault
	        9       1,2,5,6,9,10            Control mode fault
	        10      1,3-11                  Data flexibility fault
	        11      1-6                     Temperature monitoring fault
	        12      1,2                     Fault brake
	        13      5,24                    Encoder 1 fault
	        16      5-8,10,20-27            Startup fault
	        19      1-9                     Process data fault
	        20      2,11                    Fault device monitoring
	        23      4                       Power section fault
	        25      2-7,20,21,30,31,61,70   Parameter memory monitoring
	        26      1,3                     External fault
	        28      1-12,14                 FCB drive function fault
	        29      1-4                     Hardware limit switch fault
	        30      1-3                     Software limit switch fault
	        31      1-4,7,9                 Thermal protection fault
	        32      2-6,12                  Communication fault
	        33      11,12,13                system initialisation fault
	        34      1                       Process data configuration fault
	        35      1-5                     Function activation fault
	        42      1-3                     Lag fault
	        46      2,3,50,51,52            Safety card fault
	        51      1                       Analog processing fault
	    
	    Error code | Suberror code        | Meaning                                | Measure  
	    ______________________________________________________________________________________________________________
	        1       1,2                     Output stage monitoring fault           Contact SEW-Eurodrive Service       
	        4       2                       Brake chopper fault
	        7       2                       DC link fault
	        9       3,4,8                   Control mode fault
	        10      2,99                    Data flexibility fault
	        11      7,8                     Temperature monitoring fault
	        13      1,3,6,7.8,9,11,13,      Encoder 1 fault
	                15,22,23                
	        16      2,11,12,30              Startup fault
	        17      7                       Internal processor fault
	        18      1,3,4,7,8,9,10,12,13    Software fault
	        20      1,7                     Fault device monitoring
	        21      1                       S-Drive 1 fault
	        23      5,6,7,8                 Power section fault
	        25      10,12-19,50,51,81       Parameter memory monitoring
	        28      13                      FCB drive funcyio fault
	        33      1,2,6,7,8,10            System initialisation fault
	        46      1                       Safety card fault
	        
	    Function Control Block (FCB) codes
	    FBC = 01 Output stage inhibit 
	    FBC = 02 Default stop
	    FBC = 04 Manual Mode
	    FBC = 05 Speed control
	     101 - Speed-controlled jogging. Encoder feedback NOT required.
	     200 - Speed control. Encoder feedback NOT required.
	    FBC = 06 Interpolated speed control
	    FBC = 07 Torque control
	    FBC = 08 Interpolated torque control
	    FBC = 09 Positioning mode
	    400 - Absolute position control
	    401 - Relative position control
	    402 - Modulo position control - positive
	    403 - Modulo position control - negative
	    404 - Modulo position control - shortest distance
	    FBC = 10 Interpolated position control
	    FBC = 12 Referencing mode
	    300 - Reference travel - offset via parameter
	    301 - Reference travel - offset via fieldbus
	    FBC = 13 Stop at application limits
	    FBC = 14 Emergency stop
	    FBC = 18 Rotor position identification
	    FBC = 19 Position hold control
	    FBC = 20 Jog mode
	     100 - Position-controlled jogging. Encoder feedback required
	    FBC = 21 Brake test
	    FBC = 25 Motor parameter measurement
	    FBC = 26 Stop at user limits
	    
	    *)
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_RIOVSU"
TITLE = FB_RIOVSU
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 226
// END_ATTRIBUTES
   VAR_INPUT 
      is_ET200spPNDeviceName { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   //   Name of the ET200sp device
      ix_400VintOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE if internal circuit breaker 400V is ok
      ix_400VextOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE if external 400V Main cabinet is ok
      ix_BrakeSupplyOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE if circuit breaker of brake power supply is ok
      ix_ThermalBrake { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when No thermal error
      ix_24VOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when 24V power supply to RIO is ok
      ix_SimulationModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   True when Simulation mode active
      ix_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when  hardware is Ok
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_RIOVSUStatus";   //   HMI status structure
   END_VAR

   VAR_IN_OUT 
      iqUDT_Statistics : "UDT_RIOVSUStatistics";   //   Statistics structure
      iqUDT_VSUInterface : "UDT_VSUInterface";   //   Interface RIO and VSU
   END_VAR

   VAR 
      sUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RIOVSUStatus";   //   HMI status structure
      sUDT_PNDevice { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PNDevice";   //   PN device structure
      sa_PNPortsStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..8] of Bool;   // TRUE when specific port has an error
      sFB_TimerOnOffDelayCheckSupply { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //   MHS "TimerOnOffDelay" - to delay time for VFD supply contactor
      sR_TRIG_Int400VCBError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge for trigger 400v internal error
      sR_TRIG_Int24VError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge for trigger 24v internal error
      sR_TRIG_BrakeCBerror {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge for trigger brake circuit breaker tripped
      sR_TRIG_BrakeThermError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge for trigger brake thermal error
      sR_TRIG_DeviceFound {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge for trigger scan modules
      sR_TRIG_PNSlaveNotOnline {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge for trigger Profinet slave not online statistics
      sR_TRIG_PNSlaveError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge for trigger Profinet slave error statistics
      si_ModuleStateReturn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Status structure
      si_NrOfModulesWithError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Number of the faulty modules
      sx_PNSlaveOnline { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Profinet device is online and error free
      sx_PowerOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   True = External Power OK
      sx_ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Commissioning: configuration error
   END_VAR

   VAR_TEMP 
      ta_Configured : Array[0..127] of Bool;   //   Configured modules array
      ta_Exist : Array[0..127] of Bool;   //   Existing modules array
      ta_Error : Array[0..127] of Bool;   //   Faulty modules array
      ti_NrOfModule : Int;   //   Number of current module
      ti_DiagArraySize : Int;   //   Diagnostic array size
   END_VAR

   VAR CONSTANT 
      cui_ConfiguredModulesMode : UInt := 1;   //   Mode selector: 1 = Configured modules scan mode
      cui_ModuleErrorMode : UInt := 2;   //   Mode selector: 2 = Existing modules scan mode
      cui_ExistingModulesMode : UInt := 4;   //   Mode selector: 3 = Module Error scan mode
      ci_PowerSupplyDelayTime : UInt := 4000;   //   Power supply delay time
      ci_NumberOfProfinetPorts : Int := 2;   // Number of Profinet ports in device
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	03/09-2019  | 2.1       | F.Baten       | first release MHS TIA 15.1
	23/09/2019  | 2.2       | F.Baten       | Changed region 1 contents to FC
	12/10/2019  | 2.3       | L. Klar       | Updated status structure
	14/10/2019  | 2.4       | S. Deulkar    | Added equipment control structure and created 
	                                        | region for status
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1   
	29/11/2019  | 3.1       | F.Baten       | Updated interface to VSU
	04/12/2019  | 3.2       | F.Baten       | Region 3: ix_SimulationModeActive rearranged to correct position
	09/12/2019  | 3.3       | F.Baten       | Region 5: added #ix_SimulationModeActive to PNDeviceOk
	04/03/2020  | 3.4       | F.Baten       | Updated errors and warnings and interface to VSU
	06/08/2020  | 3.5       | L.Klar        | Initialize the #si_NrOfModulesWithError on the reset
	03/11/2020  | 3.9       | K.Pokorski    | Profinet ports diagnostics added 
	02/08/2021  | 3.5       | S. Deulkar    | Added logic to reset error when 24V is not okay. 
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Get Device Profinet information
	    
	    "FC_GetDevicePN"(is_PNDeviceName := #is_ET200spPNDeviceName,
	                     ix_SimulationModeActive := #ix_SimulationModeActive,
	                     iqUDT_PND := #sUDT_PNDevice);
	    
	    
	    "FC_GetPNPortStatus"(ii_NumberOfPorts := #ci_NumberOfProfinetPorts,
	                         iUDT_DevicePNInfo := #sUDT_PNDevice,
	                         qa_PortFault => #sa_PNPortsStatus);
	    
	END_REGION
	
	REGION 2 - Reset errors
	    // reset Profinet Slave error/not online  
	    IF #iqUDT_VSUInterface.InternalErrorReset
	        OR NOT #ix_24VOk
	    THEN
	        #sUDT_HMIStatus."400VCircuitBreaker" := FALSE;
	        #sUDT_HMIStatus.BrakeCircuitBreaker := FALSE;
	        #sUDT_HMIStatus.BrakeThermalError := FALSE;
	        #sUDT_HMIStatus.PNSlaveNotOnline := FALSE;
	        #sUDT_HMIStatus.PNSlaveError := FALSE;
	        #sUDT_HMIStatus."24VPowersupplyError" := FALSE;
	        #sUDT_HMIStatus.PNSlaveWarning := FALSE;
	        #si_NrOfModulesWithError := 0;
	        
	    END_IF;
	    
	    // reset ET200sp module error status
	    IF #sUDT_HMIStatus.PNSlaveNotOnline OR #iqUDT_VSUInterface.InternalErrorReset OR NOT #ix_24VOk
	    THEN
	        FILL_BLK(IN := FALSE,
	                 COUNT := 32,
	                 OUT => #sUDT_HMIStatus.ET200sp_ErrorModule[0]);
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Update PN slave device status
	    // Hardware will only be available after the delay, so the device has time for the initialisation
	    #sFB_TimerOnOffDelayCheckSupply(iudi_OnDelayTime := #ci_PowerSupplyDelayTime,
	                                    ix_SignalToDelay := #ix_24VOk,
	                                    qx_DelayedSignal => #sx_PowerOk);
	    
	    // check if PN device is online
	    IF ((NOT "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.Exist
	        AND #sx_PowerOk)
	        OR NOT #sUDT_PNDevice.PNDeviceFound)
	        AND NOT #ix_SimulationModeActive
	    THEN
	        #sUDT_HMIStatus.PNSlaveNotOnline := TRUE;
	    END_IF;
	    
	    // Check if PN ports are healthy 
	    IF #sa_PNPortsStatus[1] XOR #sa_PNPortsStatus[2] THEN
	        #sUDT_HMIStatus.PNSlaveWarning := TRUE;
	    END_IF;
	    
	    // check if PN device has an error
	    IF "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.Error
	        AND #sx_PowerOk
	        AND NOT #ix_SimulationModeActive
	        AND NOT #sUDT_HMIStatus.PNSlaveWarning
	        
	    THEN
	        #sUDT_HMIStatus.PNSlaveError := TRUE;
	    END_IF;
	    
	    // set bit when PN device is healthy (online and no error)
	    #sx_PNSlaveOnline := NOT #sUDT_HMIStatus.PNSlaveNotOnline
	    AND #sUDT_PNDevice.PNDeviceFound
	    AND #sx_PowerOk
	    OR #ix_SimulationModeActive;
	    
	    // create rising edge to scan module status when device is found
	    #sR_TRIG_DeviceFound(CLK := #sUDT_PNDevice.PNDeviceFound);
	    
	END_REGION
	
	REGION 4 - Status update modules ET200sp
	    // update ET200sp module status 
	    IF (#sx_PNSlaveOnline
	        AND (#sUDT_HMIStatus.PNSlaveError
	        OR #sUDT_HMIStatus.PNSlaveWarning))
	        OR #sR_TRIG_DeviceFound.Q
	    THEN
	        // get configured modules
	        #si_ModuleStateReturn := ModuleStates(LADDR := "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.HW_ID,
	                                              MODE := #cui_ConfiguredModulesMode,
	                                              STATE := #ta_Configured);
	        
	        // get module online status
	        #si_ModuleStateReturn := ModuleStates(LADDR := "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.HW_ID,
	                                              MODE := #cui_ExistingModulesMode,
	                                              STATE := #ta_Exist);
	        
	        // get module error status
	        #si_ModuleStateReturn := ModuleStates(LADDR := "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.HW_ID,
	                                              MODE := #cui_ModuleErrorMode,
	                                              STATE := #ta_Error);
	        
	        // Handle ET200sp module errors/offline
	        IF (#si_ModuleStateReturn = 0)
	        THEN
	            #si_NrOfModulesWithError := 0;
	            
	            #ti_DiagArraySize := "FC_GetNrOfArrayEl"(iv_Array := "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].Module);
	            
	            FOR #ti_NrOfModule := 0 TO (#ti_DiagArraySize - 1) DO
	                
	                // check if the module is configured
	                IF (#ta_Configured[#ti_NrOfModule])
	                THEN
	                    "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].Module[#ti_NrOfModule].Configured := TRUE;
	                    // and check if the module is online
	                    IF (#ta_Exist[#ti_NrOfModule])
	                    THEN
	                        "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].Module[#ti_NrOfModule].Exist := TRUE;
	                        
	                    ELSE
	                        "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].Module[#ti_NrOfModule].Exist := FALSE;
	                        #sUDT_HMIStatus.ET200sp_ErrorModule[#ti_NrOfModule] := TRUE;
	                        // count number of modules with error/offline
	                        #si_NrOfModulesWithError += 1;
	                    END_IF;
	                    
	                    // and check if the module has an error
	                    IF (NOT #ta_Error[#ti_NrOfModule])
	                    THEN
	                        "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].Module[#ti_NrOfModule].Error := FALSE;
	                        
	                    ELSE
	                        "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].Module[#ti_NrOfModule].Error := TRUE;
	                        #sUDT_HMIStatus.ET200sp_ErrorModule[#ti_NrOfModule] := TRUE;
	                        // count number OF modules with error/offline
	                        #si_NrOfModulesWithError += 1;
	                    END_IF;
	                    
	                ELSE
	                    // reset module status when module is not configured
	                    "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].Module[#ti_NrOfModule].Configured := FALSE;
	                    "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].Module[#ti_NrOfModule].Exist := FALSE;
	                    "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].Module[#ti_NrOfModule].Error := FALSE;
	                    
	                END_IF;
	            END_FOR;
	        END_IF;
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Check RIO Panel Status
	    
	    // create 400v internal error
	    IF NOT #ix_400VintOk
	    THEN
	        #sUDT_HMIStatus."400VCircuitBreaker" := TRUE;
	    END_IF;
	    
	    // create error circuit breaker brake tripped
	    IF NOT #ix_BrakeSupplyOk
	    THEN
	        #sUDT_HMIStatus.BrakeCircuitBreaker := TRUE;
	    END_IF;
	    
	    // Create error thermal overload brake
	    IF NOT #ix_ThermalBrake
	    THEN
	        #sUDT_HMIStatus.BrakeThermalError := TRUE;
	    END_IF;
	    
	    // Create error thermal overload brake
	    IF NOT #ix_24VOk
	    THEN
	        #sUDT_HMIStatus."24VPowersupplyError" := TRUE;
	    END_IF;
	    
	    // check if 400 v to VFD positioning is ok
	    #iqUDT_VSUInterface.VSUMainPowerOk := #ix_400VextOk;
	    
	    // set config not ok bit if no device found
	    #sx_ConfigurationError := NOT #sUDT_PNDevice.PNDeviceFound;
	    
	END_REGION
	
	REGION 6 - Statistics
	    // create trigger on error and create statistics 
	    #sR_TRIG_Int400VCBError(CLK := #sUDT_HMIStatus."400VCircuitBreaker");
	    
	    IF #iqUDT_VSUInterface.ResetStatistics OR #sUDT_HMIStatus."400VCircuitBreaker"
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics,
	                        ix_Activate := #sUDT_HMIStatus."400VCircuitBreaker",
	                        ix_RTrigActivate := #sR_TRIG_Int400VCBError.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.Int400VCBError);
	    END_IF;
	    
	    // create trigger on error and create statistics 
	    #sR_TRIG_Int24VError(CLK := #sUDT_HMIStatus."24VPowersupplyError");
	    
	    IF #iqUDT_VSUInterface.ResetStatistics OR #sUDT_HMIStatus."24VPowersupplyError"
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics,
	                        ix_Activate := #sUDT_HMIStatus."24VPowersupplyError",
	                        ix_RTrigActivate := #sR_TRIG_Int24VError.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics."24VError");
	    END_IF;
	    
	    // create trigger on error and create statistics 
	    #sR_TRIG_BrakeCBerror(CLK := #sUDT_HMIStatus.BrakeCircuitBreaker);
	    
	    IF #iqUDT_VSUInterface.ResetStatistics OR #sUDT_HMIStatus.BrakeCircuitBreaker
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics,
	                        ix_Activate := #sUDT_HMIStatus.BrakeCircuitBreaker,
	                        ix_RTrigActivate := #sR_TRIG_BrakeCBerror.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.BrakeCBerror);
	    END_IF;
	    
	    // create trigger on error and create statistics 
	    #sR_TRIG_BrakeThermError(CLK := #sUDT_HMIStatus.BrakeThermalError);
	    
	    IF #iqUDT_VSUInterface.ResetStatistics OR #sUDT_HMIStatus.BrakeThermalError
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics,
	                        ix_Activate := #sUDT_HMIStatus.BrakeThermalError,
	                        ix_RTrigActivate := #sR_TRIG_BrakeThermError.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.BrakeThermError);
	    END_IF;
	    
	    // create trigger on error and create statistics for profinet slave not online
	    #sR_TRIG_PNSlaveNotOnline(CLK := #sUDT_HMIStatus.PNSlaveNotOnline);
	    
	    IF #iqUDT_VSUInterface.ResetStatistics OR #sUDT_HMIStatus.PNSlaveNotOnline
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics,
	                        ix_Activate := #sUDT_HMIStatus.PNSlaveNotOnline,
	                        ix_RTrigActivate := #sR_TRIG_PNSlaveNotOnline.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.PNSlaveNotOnline);
	    END_IF;
	    
	    // create trigger on error and create statistics for profinet slave error
	    #sR_TRIG_PNSlaveError(CLK := #sUDT_HMIStatus.PNSlaveError);
	    
	    IF #iqUDT_VSUInterface.ResetStatistics OR #sUDT_HMIStatus.PNSlaveError
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics,
	                        ix_Activate := #sUDT_HMIStatus.PNSlaveError,
	                        ix_RTrigActivate := #sR_TRIG_PNSlaveError.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.PNSlaveError);
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Status
	    // Statement section REGION
	    #iqUDT_VSUInterface.InternalErrorRIOPanel := #sUDT_HMIStatus.PNSlaveError
	    OR #sUDT_HMIStatus.PNSlaveNotOnline
	    OR #si_NrOfModulesWithError <> 0
	    OR #sUDT_HMIStatus."400VCircuitBreaker"
	    OR #sUDT_HMIStatus."24VPowersupplyError"
	    OR #sUDT_HMIStatus.BrakeCircuitBreaker
	    OR #sUDT_HMIStatus.BrakeThermalError;
	    
	    // HMI status update
	    
	    #qUDT_HMIStatus := #sUDT_HMIStatus;                       // Copy HMI status to output
	    
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_Lift"
TITLE = FB_Lift
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 198
// END_ATTRIBUTES
//Function to generate a position decision and handle conveyors around the in and outfeed of a lift
   VAR_INPUT 
      iUDT_LiftConveyorInterface { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorInterface";   // Interface structure
      iUDT_VSUInterface { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VSUInterface";   // Interface between VSU and VFD
      ix_SectionIsDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when section is down
      ix_SectionIsUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when section is up
      ix_PECLift { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when PEC on lift is free
      ix_ConveyorEmptyInAuto { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor is started in auto
      ix_ConveyorEmptyOutAuto { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor is started in auto
      ix_ConveyorFullInAuto { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor is started in auto
      ix_ConveyorFullOutAuto { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor is started in auto
   END_VAR

   VAR_OUTPUT 
      qi_RequestedPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Requested position to go to
      qx_HoldLiftConveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Hold conveyor on lift as lift moves
      qx_TransportIdle { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // No transports are active, free to move
      qx_LiftConveyorDirection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FALSE - Right, TRUE - Left
   END_VAR

   VAR_IN_OUT 
      iqUDT_LiftConveyorHandShakeUpstream : "UDT_ConveyorHandshake";
      iqUDT_LiftConveyorHandShake : "UDT_ConveyorHandshake";
      iqUDT_InfeedEmptyUpHandShake : "UDT_ConveyorHandshake";
      iqUDT_OutfeedEmptyDownHandShake : "UDT_ConveyorHandshake";
      iqUDT_InfeedFullDownHandShake : "UDT_ConveyorHandshake";
      iqUDT_OutfeedFullUpHandShake : "UDT_ConveyorHandshake";
      iqUDT_OutfeedFullUpHandshakeUpstream : "UDT_ConveyorHandshake";
      iqUDT_OutfeedEmptyDownHandshakeUpstream : "UDT_ConveyorHandshake";
   END_VAR

   VAR 
      sUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Common status structure
      sR_TRIG_Automatic {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge starting automatic mode
      sR_TRIG_PECOn {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger PEC on lift conveyor
      sF_TRIG_TIPLiftConveyor {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger TIP signal lift conveyor
      sF_TRIG_PECOff {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger PEC on lift conveyor
      sx_AutomaticActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Running in automatic
      sx_LoadIsEmptyTote { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Load on lift conveyor is an empty tote
      sx_LoadIsFullTote { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Load on lift conveyor is a full tote
      sx_GetEmptyTote { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Transport empty tote in
      sx_GetFullTote { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Transport full tote in
      sx_DeliverEmptyTote { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Transport empty tote out
      sx_DeliverFullTote { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Transport full tote out
      sx_EmptyRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Valid empty request active
      sx_FullRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Valid full request active
      sx_DoEmptyRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Handle empty request
      sx_DoFullRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Handle full request
      sx_Idle { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Transport is Idle
      si_DistanceToOutfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Actual distance to the end of the lift conveyor
      sx_UpperOutfeedingActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Outfeeding to the upper outfeed is on
      sx_LowerOutfeedingActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Outfeeding to the upper outfeed is on
   END_VAR

   VAR CONSTANT 
      ci_Up : Int := 2;
      ci_Down : Int := 1;
      ci_DistanceToOutfeed : Int := 39;   // Distance from middle to the end of the lift conveyor
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	
	Version
	history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	07/04/2023  | 3.0       | F.Baten       | First release TIA 17.5
	14/06/2024  | 3.1       | R.Pieczonka   | Changed handshakes connections, added distance counting while outfeeding
	                                            
	*)
	
	
	REGION 1 - Initial
	    REGION 1.1 - Triggers
	        // Starting automatic
	        #sR_TRIG_Automatic(CLK := #iUDT_VSUInterface.Automatic);
	        
	        // Lift conveyor finished TIP
	        #sF_TRIG_TIPLiftConveyor(CLK := #iqUDT_LiftConveyorHandShake.TIP);
	        
	        // Tote arrived on PEC
	        #sF_TRIG_PECOff(CLK := #ix_PECLift);
	        
	        //Tote gone from PEC
	        #sR_TRIG_PECOn(CLK := #ix_PECLift);
	        
	    END_REGION
	END_REGION
	
	REGION 7 - Automatic mode
	    
	    REGION 7.1 - Determine load on lift
	        // Lift is in upper position and conveyor is ready to send, the empty tote is loaded on the conveyor. 
	        IF #ix_SectionIsUp
	            AND #sx_DoEmptyRequest
	            AND #iUDT_LiftConveyorInterface.VFDRunning
	            AND #sF_TRIG_PECOff.Q
	        THEN
	            #sx_LoadIsEmptyTote := TRUE;
	        END_IF;
	        // Lift is in lower position, and outfeeding empty tote. 
	        IF #ix_SectionIsDown
	            AND #iUDT_LiftConveyorInterface.VFDRunning
	            AND #sR_TRIG_PECOn.Q
	            AND #sx_LoadIsEmptyTote
	        THEN
	            #sx_LowerOutfeedingActive := TRUE;
	            #si_DistanceToOutfeed := #ci_DistanceToOutfeed;
	        END_IF;
	        
	        IF #sx_LowerOutfeedingActive
	        THEN
	            #si_DistanceToOutfeed -= #iUDT_LiftConveyorInterface.Displacement;
	        END_IF;
	        //If the ditance from middle conveyor to the end of it is reached,  then the information about tote on the lift is cleared.
	        IF #sx_LowerOutfeedingActive
	            AND #si_DistanceToOutfeed <= 0
	        THEN
	            #sx_LowerOutfeedingActive := FALSE;
	            #sx_LoadIsEmptyTote := FALSE;
	        END_IF;
	        
	        // Lift is in lower position and conveyor is ready to send, the full tote is loaded on the conveyor. 
	        IF #ix_SectionIsDown
	            AND #sx_DoFullRequest
	            AND #iUDT_LiftConveyorInterface.VFDRunning
	            AND #sF_TRIG_PECOff.Q
	        THEN
	            #sx_LoadIsFullTote := TRUE;
	        END_IF;
	        // Lift is in upper position, and outfeeding full tote. 
	        IF #ix_SectionIsUp
	            AND #iUDT_LiftConveyorInterface.VFDRunning
	            AND #sR_TRIG_PECOn.Q
	            AND #sx_LoadIsFullTote
	        THEN
	            #sx_UpperOutfeedingActive := TRUE;
	            #si_DistanceToOutfeed := #ci_DistanceToOutfeed;
	        END_IF;
	        
	        IF #sx_UpperOutfeedingActive
	        THEN
	            #si_DistanceToOutfeed += #iUDT_LiftConveyorInterface.Displacement;
	        END_IF;
	        //If the ditance from middle conveyor to the end of it is reached, then the information about tote on the lift is cleared. 
	        IF #sx_UpperOutfeedingActive
	            AND #si_DistanceToOutfeed <= 0
	        THEN
	            #sx_LoadIsFullTote := FALSE;
	            #sx_UpperOutfeedingActive := FALSE;
	        END_IF;
	        
	        // When starting automatic mode and no load is active but pec still occupied, the load will be set as Full tote.  
	        IF NOT #sx_LoadIsFullTote
	            AND NOT #sx_LoadIsEmptyTote
	            AND NOT #ix_PECLift
	            AND #sR_TRIG_Automatic.Q
	        THEN
	            #sx_LoadIsFullTote := TRUE;
	        END_IF;
	        
	        IF #sR_TRIG_Automatic.Q
	        THEN
	            #sx_LowerOutfeedingActive := FALSE;
	            #sx_UpperOutfeedingActive := FALSE;
	        END_IF;
	    END_REGION
	    
	    REGION 7.2 - Request totes
	        // request for empty totes : infeed is full and outfeed is empty and both are automatic active
	        #sx_EmptyRequest := #iqUDT_InfeedEmptyUpHandShake.RTS
	        AND #iqUDT_OutfeedEmptyDownHandShake.RTR
	        AND #ix_ConveyorEmptyInAuto
	        AND #ix_ConveyorEmptyOutAuto;
	        
	        // request for full totes : infeed is full and outfeed is empty and both are automatic active
	        #sx_FullRequest := #iqUDT_InfeedFullDownHandShake.RTS
	        AND #iqUDT_OutfeedFullUpHandshakeUpstream.RTR
	        AND #ix_ConveyorFullInAuto
	        AND #ix_ConveyorFullOutAuto;
	    END_REGION
	    
	    REGION 7.3 - Handle request
	        // Setting reqest to be handled
	        IF #sx_EmptyRequest
	            AND NOT #sx_DoFullRequest
	            AND NOT #sx_LoadIsEmptyTote
	        THEN
	            #sx_DoEmptyRequest := TRUE;
	        ELSIF #sx_FullRequest
	            AND NOT #sx_DoEmptyRequest
	            AND NOT #sx_LoadIsFullTote
	        THEN
	            #sx_DoFullRequest := TRUE;
	        END_IF;
	        
	        // Empty tote is loaded
	        IF (#sx_DoEmptyRequest AND #sx_LoadIsEmptyTote)
	        THEN
	            #sx_DoEmptyRequest := FALSE;
	        END_IF;
	        
	        // Full tote is loaded
	        IF (#sx_DoFullRequest AND #sx_LoadIsFullTote)
	        THEN
	            #sx_DoFullRequest := FALSE;
	        END_IF;
	        
	        // Active request is not valid anymore as lift moved to position  
	        IF #sx_DoEmptyRequest AND NOT #sx_EmptyRequest AND #iqUDT_InfeedEmptyUpHandShake.RTS AND #ix_SectionIsUp AND #sx_GetEmptyTote THEN
	            #sx_GetEmptyTote := FALSE;
	            #sx_DoEmptyRequest := FALSE;
	        END_IF;
	        
	        IF #sx_DoFullRequest AND NOT #sx_FullRequest AND #iqUDT_InfeedFullDownHandShake.RTS AND #ix_SectionIsDown AND #sx_GetFullTote THEN
	            #sx_GetFullTote := FALSE;
	            #sx_DoFullRequest := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 7.4 - Active Transports
	        // Load empty tote transport is active
	        IF #sx_DoEmptyRequest AND #ix_SectionIsUp
	        THEN
	            #sx_GetEmptyTote := TRUE;
	        END_IF;
	        
	        IF #sx_GetEmptyTote
	            AND
	            ((#iUDT_LiftConveyorInterface.ActualSpeed = 0) AND #sx_LoadIsEmptyTote)
	        THEN
	            #sx_GetEmptyTote := FALSE;
	        END_IF;
	        
	        // Load full tote transport is active
	        IF #sx_DoFullRequest AND #ix_SectionIsDown
	        THEN
	            #sx_GetFullTote := TRUE;
	        END_IF;
	        
	        IF #sx_GetFullTote AND #sx_LoadIsFullTote AND (#iUDT_LiftConveyorInterface.ActualSpeed = 0)
	        THEN
	            #sx_GetFullTote := FALSE;
	        END_IF;
	        
	        // Deliver transports are active
	        #sx_DeliverEmptyTote := #ix_SectionIsDown AND #sx_LoadIsEmptyTote AND (#iUDT_LiftConveyorInterface.ActualSpeed <> 0);
	        #sx_DeliverFullTote := #ix_SectionIsUp AND #sx_LoadIsFullTote AND (#iUDT_LiftConveyorInterface.ActualSpeed <> 0);
	        
	        // Transport is idle
	        #sx_Idle := NOT #sx_GetEmptyTote
	        AND NOT #sx_GetFullTote
	        AND NOT #sx_DeliverFullTote
	        AND NOT #sx_DeliverEmptyTote;
	    END_REGION
	    
	    REGION 7.5 - Lift position request
	        // When lift is at level and transports finished (free to move)
	        // To go to lower level (bring empty tote or get full one)
	        IF #sx_Idle
	            AND ((#ix_SectionIsUp AND #sx_DoFullRequest)
	            OR #sx_LoadIsEmptyTote)
	        THEN
	            #qi_RequestedPosition := #ci_Down;
	        END_IF;
	        
	        // To go to upper level (bring full tote or get empty one)
	        IF #sx_Idle
	            AND ((#ix_SectionIsDown AND #sx_DoEmptyRequest) OR #sx_LoadIsFullTote)
	        THEN
	            #qi_RequestedPosition := #ci_Up;
	        END_IF;
	        
	        #qx_TransportIdle := #sx_Idle;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 8 - Handshake to conveyors
	    // Reset when not connected 
	    #iqUDT_InfeedEmptyUpHandShake.RTR := FALSE;
	    #iqUDT_InfeedFullDownHandShake.RTR := FALSE;
	    
	    #iqUDT_LiftConveyorHandShakeUpstream.GIN := 0;
	    #iqUDT_LiftConveyorHandShakeUpstream.NrOfPosToShift := 0;
	    #iqUDT_OutfeedFullUpHandShake.GIN := 0;
	    #iqUDT_OutfeedFullUpHandShake.NrOfPosToShift := 0;
	    #iqUDT_OutfeedEmptyDownHandShake.GIN := 0;
	    #iqUDT_OutfeedEmptyDownHandShake.NrOfPosToShift := 0;
	    
	    // Direct interface signals when on level
	    IF #ix_SectionIsUp THEN
	        #qx_LiftConveyorDirection := TRUE;                  // Changing direction to left
	        // Infeed 
	        #iqUDT_InfeedEmptyUpHandShake.RTR := #iqUDT_LiftConveyorHandShake.RTR AND (#sx_EmptyRequest OR #iqUDT_InfeedEmptyUpHandShake.TIP);
	        #iqUDT_LiftConveyorHandShake.GIN := #iqUDT_InfeedEmptyUpHandShake.GIN;
	        #iqUDT_LiftConveyorHandShakeUpstream.NrOfPosToShift := #iqUDT_InfeedEmptyUpHandShake.NrOfPosToShift;
	        #iqUDT_InfeedEmptyUpHandShake.NrOfPosToShift := 0;
	        #iqUDT_LiftConveyorHandShakeUpstream.RTS := #iqUDT_InfeedEmptyUpHandShake.RTS;
	        //  #iqUDT_HandShakeLiftUp.TIP := #iqUDT_HandShakeEmptyIn.TIP;
	        #iqUDT_LiftConveyorHandShakeUpstream.ResetEnergySave := #iqUDT_InfeedEmptyUpHandShake.ResetEnergySave;
	        
	        // Outfeed 
	        #iqUDT_OutfeedFullUpHandshakeUpstream.RTS := #iqUDT_LiftConveyorHandShake.RTS AND #sx_LoadIsFullTote;
	        #iqUDT_OutfeedFullUpHandshakeUpstream.TIP := #iqUDT_LiftConveyorHandShake.TIP;
	        #iqUDT_OutfeedFullUpHandshakeUpstream.GIN := #iqUDT_LiftConveyorHandShake.GIN;
	        #iqUDT_OutfeedFullUpHandshakeUpstream.NrOfPosToShift := #iqUDT_LiftConveyorHandShake.NrOfPosToShift;
	        #iqUDT_LiftConveyorHandShake.NrOfPosToShift := 0;
	        
	        // lift to outfeed transport
	        #iqUDT_LiftConveyorHandShakeUpstream.RTR := #iqUDT_OutfeedFullUpHandshakeUpstream.RTR AND (#sx_LoadIsFullTote OR #iqUDT_LiftConveyorHandShake.TIP);
	    END_IF;
	    
	    IF #ix_SectionIsDown THEN
	        #qx_LiftConveyorDirection := FALSE;                 //Changing direction to right
	        
	        // Infeed Full to lift 
	        #iqUDT_InfeedFullDownHandShake.RTR := #iqUDT_LiftConveyorHandShakeUpstream.RTR AND (#sx_FullRequest OR #iqUDT_InfeedFullDownHandShake.TIP);
	        #iqUDT_LiftConveyorHandShakeUpstream.GIN := #iqUDT_InfeedFullDownHandShake.GIN;
	        #iqUDT_LiftConveyorHandShakeUpstream.NrOfPosToShift := #iqUDT_InfeedFullDownHandShake.NrOfPosToShift;
	        #iqUDT_InfeedFullDownHandShake.NrOfPosToShift := 0;
	        #iqUDT_LiftConveyorHandShakeUpstream.RTS := #iqUDT_InfeedFullDownHandShake.RTS;
	        #iqUDT_LiftConveyorHandShakeUpstream.TIP := #iqUDT_InfeedFullDownHandShake.TIP;
	        #iqUDT_LiftConveyorHandShakeUpstream.ResetEnergySave := #iqUDT_InfeedFullDownHandShake.ResetEnergySave;
	        
	        // Outfeed 
	        #iqUDT_OutfeedEmptyDownHandshakeUpstream.RTS := #iqUDT_LiftConveyorHandShakeUpstream.RTS AND #sx_LoadIsEmptyTote;
	        #iqUDT_OutfeedEmptyDownHandshakeUpstream.TIP := #iqUDT_LiftConveyorHandShake.TIP;
	        #iqUDT_OutfeedEmptyDownHandshakeUpstream.GIN := #iqUDT_LiftConveyorHandShake.GIN;
	        #iqUDT_OutfeedEmptyDownHandshakeUpstream.NrOfPosToShift := #iqUDT_LiftConveyorHandShake.NrOfPosToShift;
	        #iqUDT_LiftConveyorHandShake.NrOfPosToShift := 0;
	        
	        // lift to outfeed transport
	        #iqUDT_LiftConveyorHandShake.RTR := #iqUDT_OutfeedEmptyDownHandshakeUpstream.RTR AND (#sx_LoadIsEmptyTote OR #iqUDT_LiftConveyorHandShake.TIP);
	        
	    END_IF;
	    
	    #iqUDT_OutfeedFullUpHandshakeUpstream.ResetEnergySave := #iqUDT_InfeedFullDownHandShake.ResetEnergySave
	    OR #iqUDT_LiftConveyorHandShake.ResetEnergySave
	    AND #ix_SectionIsUp;
	    #iqUDT_OutfeedEmptyDownHandshakeUpstream.ResetEnergySave := #iqUDT_InfeedEmptyUpHandShake.ResetEnergySave
	    OR #iqUDT_LiftConveyorHandShake.ResetEnergySave
	    AND #ix_SectionIsDown;
	    
	    //Stop when NOT on level
	    #qx_HoldLiftConveyor := NOT #ix_SectionIsDown AND NOT #ix_SectionIsUp;
	    
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_PECUpdate"
TITLE = FB_PECUpdate
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 221
// END_ATTRIBUTES
//Function block to update parcel data in a tracking array at PEC position.
   VAR_INPUT 
      iUDT_PECUpdateConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateConfiguration";   //   PEC update configuration
      iUDT_ConveyorCommonConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorCommonConfiguration";   //   Conveyor configuration
      ix_PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when the end of section photoeye is not blocked
      ix_TeachingMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Teaching mode enable
   END_VAR

   VAR_OUTPUT 
      qUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateStatus";   //   Status structure
      qi_GINwrite { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Gin found or generated
      qx_PECFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Filtered photoeye signal
   END_VAR

   VAR_IN_OUT 
      iqUDT_ConveyorInterface : "UDT_ConveyorInterface";   //   Conveyor interface
      iqUDT_UnknownGINRange : "UDT_UnknownGIN";   //   Unknown GIN
      iqUDT_FifoHeader : "UDT_FifoHeader";   //   FIFO header
      iqUDT_Statistics : "UDT_PECUpdateStatistics";   //   Statistic structure
      iqa_TrackingData : Array[*] of Int;   //   Tracking data
      iqa_FifoData : Array[*] of Int;   //   FIFO data
   END_VAR

   VAR 
      sFB_PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   //   Photoeye function
      sFB_LengthMeasurement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ParcelLength";   //   Length measurement
      sUDT_LostGINFIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoStatus";   //   Lost GIN FIFO status
      ss_PECDataDeviation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // PEC/Data deviation calculation structure
         Last { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Last deviation [cm]
         GIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Last GIN deviation
         Sum { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Deviation sum [cm]
         Nr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Deviation number
      END_STRUCT;
      ss_ValidGINRange { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //   Valid GIN range
         Start { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         End { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         GIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      END_STRUCT;
      ss_AlignedParcelsCounters { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //   Aligned parcels counters
         Total { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Total aligned parcels
         DataNoPEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Parcels aligned in case data detected without photoeye signal
         PECNoData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Parcels aligned in case parcel detected without data
      END_STRUCT;
      ss_LostParcelsCounters { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //   Lost parcels counters
         Total { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Total number of lost parcels
         DoubleData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Parcels lost due to double data found in a search window
         ParcelNotFound { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Parcels lost due to no parcel detected after travelling search window distance
      END_STRUCT;
      ss_LostValidParcelsCounters { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //   Lost parcels counters
         Total { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Total number of lost parcels
         DoubleData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Parcels lost due to double data found in a search window
         ParcelNotFound { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Parcels lost due to no parcel detected after travelling search window distance
      END_STRUCT;
      si_UnknownParcelsCounters { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //   Unknown parcels counters
         Total { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Total number of unknown parcels
         LostParcelFound { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Parcel found with a lost data, unknown GIN created
         DataNotFound { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Data not found during search window scan
      END_STRUCT;
      sR_TRIG_Parcel {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Parcel detected rising edge to count parcels
      sR_TRIG_ParcelFound {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Parcel detected rising edge to update the PEC position tracking record
      sR_TRIG_DataFound {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Any data found at a PEC position rising edge
      sR_TRIG_PositiveDataFound {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Positive data found at a PEC position rising edge
      sR_TRIG_TeachMode {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Teaching mode activation rising edge
      sR_TRIG_TooManyLost {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Too many lost parcels error statistics trigger
      slr_Performance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal := 100.0;   //   Update performance [%]
      sdi_TotalNumberOfParcels { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   Total number of parcels detected
      sdi_TotalNumberOfData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   Total number of data detected
      si_PECPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Photoeye position [cm]
      si_SearchWindow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Data search distance from photoeye position [cm]
      si_GINToWrite { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Found or generated GIN, which will be used to update photoeye position in the tracking array
      si_PositionToUpdate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Position in a tracking array to be updated
      si_Direction { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Direction of the displacement to parametrize loops
      si_Displacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Displacement [cm]
      si_ParcelWaitDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Parcel delay [cm]
      si_LastUpdatedGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Last updated GIN to check if next data is a new one
      si_LastCountedData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Last counted data
      si_LostParcelsInARow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Number of lost parcel in a row
      si_NumberOfTeachedParcels { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Number of teached parcels
      si_AverageSlip { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Average parcel slip [cm]
      si_CalculatedLengthCorrection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Calculated length correction after teaching
      si_ParcelLengthFilterCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Parcel length filter counter [cm]
      si_ParcelLengthFilterOldGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Parcel length filter old GIN
      si_LoopCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Loop counter
      sx_ParcelDetected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Parcel detected
      sx_ParcelWaitEnable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Missing parcel monitoring
      sx_TeachingMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Teaching mode
      sx_GenerateGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Request to generate GIN
      sx_LostGINFIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Lost GIN FIFO error
      sx_LostGINFIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Lost GIN FIFO warning
      sx_InvalidDirection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Invalid direction
      sx_InvalidGINRange { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Invalid GIN range
      sx_InvalidDisplacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Invalid displacement
      sx_InvalidSearchWindow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Invalid search window
      sx_DoubleDataFound { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Double data detected
      sx_LengthMeasurementEnable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_TEMP 
      tUDT_PECConfiguration : "UDT_PECConfiguration";   //   PEC configuration
      tUDT_PECStatus : "UDT_PECStatus";   //   PEC status
   END_VAR

   VAR CONSTANT 
      ci_ZeroGIN : Int;   //   GIN = 0
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHSE TIA 15.1
	13/06/2019  | 0.2       | A.Nowak       | Replacement of instruction if for direct write into variable
	21/06/2019  | 0.3       | A.Nowak       | Add gap mesurement function and reorganise block (regions) 
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHSE library release TIA 15.1
	23/08/2019  | 2.1       | L.Klar        | "UDT_ConveyorConfiguration" changed to "UDT_ConveyorCommonConfiguration"
	XX/08/2019  | 2.2       | L.Klar        | Update logic changed
	19/09/2019  | 2.3       | P.Majka       | Updating checking PEC and PEC filtered signals
	30/09/2019  | 2.4       | L.Klar        | FB_PEC added, Filtered PEC signal output added
	21/10/2019  | 2.6       | L.Klar        | Configuration UDT chanaged to input, PEC configuration interface input name changed
	23/10/2019  | 2.7       | P.Majka       | Added Region 1, renumerating Regions, changed logic in Region 10.3 and Region 5
	29/10/2019  | 2.8       | L.Klar        | FB_PEC call changed
	14/11/2019  | 2.9       | L.Klar        | Deviations calculation corrected
	14/11/2019  | 3.0       | P.Majka       | 3.0 MHSE library release TIA 15.1
	20/12/2019  | 3.1       | S.Deulkar     | Used configureation error bit to report to conveyor block     
	07/01/2020  | 3.2       | L.Klar        | GIN record structure updated, GIN cleared with default one during generation
	                                        | PECUpdate configuration UDT update - search window DINT -> INT, 
	                                        | Conveyor common configuration UDT update - length INT -> DINT  conversion added
	29/01/2020  | 3.3       | L.Klar        | Negative GIN handling fixed, configuration bit added to delete negative GIN instead of ignoing it.
	24/02/2020  | 3.4       | L.Klar        | Formating changes, statistics counter added 
	10/03/2020  | 3.5       | F.Baten       | Range check unknown GIN region 7
	26/03/2020  | 3.6       | F.Baten       | Added output 'qi_GINwrite'
	25/11/2020  | 3.7       | L.Klar        | Length filter added
	07/12/2020  | 3.8       | L.Klar        | Length filter bug fix
	22/01/2021  | 3.9       | L.Klar        | Total number of parcels and lost parcels counter fixed
	14/08/2021  | 3.10      | S. Deulkar    | Update from EMA
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	
	REGION 1 – FIFO header status update
	    
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #sUDT_LostGINFIFOStatus,
	              qx_Error => #sx_LostGINFIFOError,
	              qx_Warning => #sx_LostGINFIFOWarning,
	              iqv_Data := #si_GINToWrite,
	              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	              iqv_DataBuffer := #iqa_FifoData);
	    
	END_REGION
	
	REGION 2 – Displacement read
	    
	    #si_Displacement := #iqUDT_ConveyorInterface.Displacement;
	    
	END_REGION
	
	REGION 3 – PEC Position conversion from mm to cm
	    
	    // The conversion is required because the photoeye position is given in mm and the tracking resolution is 1 cm. 
	    #si_PECPosition := DINT_TO_INT(#iUDT_PECUpdateConfiguration.Distance / 10);
	    
	END_REGION
	
	REGION 4 – Teaching mode enable
	    
	    (* Teaching mode is used to calculate conveyor length correction, which allows to align real conveyor length with a tracking array length.
	       Correction is calculated as a difference between photoeye signal and tracking data deviations.
	       Calculated correction has to be manually copied from a FB_PECUpdate instance data block to conveyor configuration.*)
	    
	    // Teaching mode is initialized and activated manually via block input.
	    #sR_TRIG_TeachMode(CLK := #ix_TeachingMode);
	    
	    IF (#sR_TRIG_TeachMode.Q
	        AND NOT #sx_TeachingMode)
	    THEN
	        #ss_PECDataDeviation.Nr := 0;
	        #ss_PECDataDeviation.Sum := 0;
	        #si_NumberOfTeachedParcels := 0;
	        #sx_TeachingMode := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 5 – Photoeye
	    
	    (*FB_PEC block call to filter photoeye signal and calculate jam status.*)
	    
	    // Copy PEC configuration.
	    #tUDT_PECConfiguration.Distance := #iUDT_PECUpdateConfiguration.Distance;
	    #tUDT_PECConfiguration.JamDisplacementLimit := #iUDT_PECUpdateConfiguration.JamDisplacementLimit;
	    #tUDT_PECConfiguration.TimeOnDelay := #iUDT_PECUpdateConfiguration.TimeOnDelay;
	    #tUDT_PECConfiguration.TimeOffDelay := #iUDT_PECUpdateConfiguration.TimeOffDelay;
	    #tUDT_PECConfiguration.ResetWithPECBlocked := #iUDT_PECUpdateConfiguration.ResetWithPECBlocked;
	    
	    //Call FB_PEC.
	    #sFB_PEC(ix_PEC := #ix_PEC,
	             iUDT_PECConfiguration := #tUDT_PECConfiguration,
	             qUDT_HMIStatus => #tUDT_PECStatus,
	             iqUDT_ConveyorInterface := #iqUDT_ConveyorInterface,
	             iqUDT_PECStatistics := #iqUDT_Statistics.PEC);
	    
	    // Parcel length filter
	    IF NOT #ix_PEC
	        AND #iUDT_PECUpdateConfiguration.ParcelLengthFilter
	        AND #iqa_TrackingData[#si_PECPosition - 1] > 0
	        AND #iqa_TrackingData[#si_PECPosition - 1] <> #si_ParcelLengthFilterOldGIN THEN
	        
	        IF "DB_GIN".GIN[#iqa_TrackingData[#si_PECPosition - 1]].General.Length > 0 THEN
	            #si_ParcelLengthFilterCounter := "DB_GIN".GIN[#iqa_TrackingData[#si_PECPosition - 1]].General.Length;
	        END_IF;
	        
	        #si_ParcelLengthFilterOldGIN := #iqa_TrackingData[#si_PECPosition - 1];
	        
	    END_IF;
	    
	    IF #si_ParcelLengthFilterCounter > 0 THEN
	        
	        #qUDT_Status.PEC := FALSE;
	        #qx_PECFiltered := FALSE;
	        #si_ParcelLengthFilterCounter -= #iqUDT_ConveyorInterface.Displacement;
	        
	    ELSE
	        
	        #qUDT_Status.PEC := #sFB_PEC.qx_PECFiltered;
	        #qx_PECFiltered := #sFB_PEC.qx_PECFiltered;
	        
	    END_IF;
	    
	    #qUDT_Status.Jam := #tUDT_PECStatus.Jam;
	    
	    // Parcel detected variable to simplify further photoeye position tracking record update.
	    #sx_ParcelDetected := NOT #qUDT_Status.PEC;
	    
	END_REGION
	
	REGION 6 – Error reset
	    
	    // Reset errors when reset signal is given.
	    IF (#iqUDT_ConveyorInterface.InternalErrorReset)
	    THEN
	        #si_LostParcelsInARow := 0;
	        #qUDT_Status.TooManyLost := FALSE;
	        #sx_InvalidDisplacement := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 7 – GIN generator initialization
	    
	    // Valid GIN range configuration is moved to a structure.
	    #ss_ValidGINRange.Start := #iUDT_PECUpdateConfiguration.GINRangeStart;
	    #ss_ValidGINRange.End := #iUDT_PECUpdateConfiguration.GINRangeEnd;
	    
	    // Check if the unknown GIN is within range
	    IF #iqUDT_UnknownGINRange.GIN < #iqUDT_UnknownGINRange.Start
	        OR #iqUDT_UnknownGINRange.GIN > #iqUDT_UnknownGINRange.End
	    THEN
	        #iqUDT_UnknownGINRange.GIN := #iqUDT_UnknownGINRange.Start;
	    END_IF;
	    
	    // Whenever valid GIN range is changed and the generated GIN doesn't fit, it's initialized.
	    IF (#ss_ValidGINRange.GIN < #ss_ValidGINRange.Start
	        OR #ss_ValidGINRange.GIN > #ss_ValidGINRange.End)
	    THEN
	        #ss_ValidGINRange.GIN := #ss_ValidGINRange.Start;
	    END_IF;
	    
	    // Valid GIN range is set locally in PEC update configuration structure and it can't overlap with a global unknown GIN range.
	    #sx_InvalidGINRange := #iUDT_PECUpdateConfiguration.GenerationPoint
	    AND (#ss_ValidGINRange.End <= #ss_ValidGINRange.Start
	    OR #ss_ValidGINRange.Start <= #iqUDT_UnknownGINRange.End
	    OR #iqUDT_UnknownGINRange.End <= #iqUDT_UnknownGINRange.Start)
	    AND #ss_ValidGINRange.Start < 1000;   // Until 1000 it is UFO range
	    
	END_REGION
	
	REGION 8 – Search window and displacement validation
	    
	    (*Both parameters have to be checked to prevent tracking array exceeding.*)
	    
	    // Search window cannot be lower than zero and greater than distance between PEC position and conveyor edge.
	    #sx_InvalidSearchWindow := #iUDT_PECUpdateConfiguration.SearchWindowFwd < 0
	    OR #iUDT_PECUpdateConfiguration.SearchWindowFwd >= #iUDT_ConveyorCommonConfiguration.Length + #iUDT_ConveyorCommonConfiguration.LengthCorrection - #si_PECPosition
	    OR #iUDT_PECUpdateConfiguration.SearchWindowRvs < 0
	    OR #iUDT_PECUpdateConfiguration.SearchWindowRvs >= #si_PECPosition;
	    
	    // Displacement cannot be greater than the photoeye position.
	    IF (ABS(#si_Displacement) > #si_PECPosition)
	    THEN
	        #sx_InvalidDisplacement := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 9 – Total number of parcels counter
	    
	    (*Parcels are counted basing on parcel detection rising edge trigger. Counting is blocked
	      during PLC first scan, when photoeye signal becomes 0.*)
	    
	    #sR_TRIG_Parcel(CLK := #sx_ParcelDetected);
	    
	    IF (#sR_TRIG_Parcel.Q
	        AND NOT "DB_Memory".FirstScan)
	    THEN
	        // Total number of parcels.
	        #sdi_TotalNumberOfParcels += 1;
	        
	        // Every detected parcel resets lost parcels in a row counter.
	        #si_LostParcelsInARow := 0;
	        
	        // Number of teached parcels is incremented if teaching mode is activated.
	        IF (#sx_TeachingMode)
	        THEN
	            #si_NumberOfTeachedParcels += 1;
	        END_IF;
	    END_IF;
	    
	END_REGION
	
	REGION 10 – PEC Update
	    (* Photoeye position record is updated after every tracking register shift, basing on
	       actual situation - photoeye signal and data availability. In case of displacement
	       graeter than one, the loop will be executed the proper number of times. The update loop
	       can be executed if there is no configuration errors and the displacement was given.*)
	    
	    WHILE #si_Displacement <> 0
	        AND NOT #sx_InvalidGINRange
	        AND NOT #sx_InvalidDisplacement
	        AND NOT #sx_InvalidSearchWindow
	    DO
	        
	        REGION 10.1 – Direction
	            
	            (*Depending on displacement sign, the direction of movement is determinated. This allows to choose 
	            ` correct search window and parametrize all search loops to count up or down.*)
	            
	            IF (#si_Displacement < 0)
	            THEN
	                #si_Direction := -1;
	                #si_SearchWindow := #iUDT_PECUpdateConfiguration.SearchWindowRvs;
	            ELSIF (#si_Displacement > 0)
	            THEN
	                #si_Direction := 1;
	                #si_SearchWindow := #iUDT_PECUpdateConfiguration.SearchWindowFwd;
	            END_IF;
	            
	        END_REGION
	        
	        REGION 10.2 – Position to update
	            
	            // Position pointer used to specify the tracking array record to be updated.
	            #si_PositionToUpdate := #si_PECPosition - #si_Displacement + #si_Direction;
	            
	        END_REGION
	        
	        
	        REGION 10.3 – Total number of data counter
	            
	            (*Total number of data is incremented every time when new GIN is detected.*)
	            
	            IF (#iqa_TrackingData[#si_PositionToUpdate + 1] > 0
	                AND #iqa_TrackingData[#si_PositionToUpdate + 1] <> #si_LastCountedData)
	            THEN
	                #sdi_TotalNumberOfData += 1;
	                #si_LastCountedData := #iqa_TrackingData[#si_PositionToUpdate + 1];
	            END_IF;
	            
	        END_REGION
	        
	        REGION 10.4 – GIN detection
	            
	            (* Data found and parcel found triggers are used to determine the update case,
	               whether the data occurred first or a parcel.*)
	            
	            // Trigger on any data found at a PEC position to detect the front of the parcel data. 
	            #sR_TRIG_DataFound(CLK := #iqa_TrackingData[#si_PositionToUpdate] <> 0);
	            
	            // Trigger on positive data found at a PEC position to detect the front of the parcel data.   
	            #sR_TRIG_PositiveDataFound(CLK := #iqa_TrackingData[#si_PositionToUpdate] > 0);
	            
	            // Trigger to detect front of the parcel.
	            #sR_TRIG_ParcelFound(CLK := #sx_ParcelDetected);
	            
	(*
	Data detected without PEC signal
	
	                         Search window
	                          <--------|
	Data                              PEC
	|----------------------------------|------------------------------------------|
	|                           XXXXXXXX                                          |
	|----------------------------------|------------------------------------------|
	                                   |
	Conveyor                           |
	|----------------------------------|------------------------------------------|
	|                      YYYYYYYY    |                                          | 
	|                      YYYYYYYY    |                                          |
	|                      YYYYYYYY    |                                          |
	|----------------------------------|------------------------------------------|
	*)
	(* Data detected without PEC signal.*)
	            IF (#sR_TRIG_PositiveDataFound.Q
	                AND NOT #sx_ParcelDetected)
	            THEN
	                #si_GINToWrite := 0;
	                // Double data detection loop.
	                FOR #si_LoopCounter := #si_PositionToUpdate TO
	                    #si_PECPosition + (#si_SearchWindow * #si_Direction) BY #si_Direction DO
	                    // Data found in a search window.
	                    IF (#iqa_TrackingData[#si_LoopCounter] > 0)
	                    THEN
	                        // First GIN found.
	                        IF (#si_GINToWrite = 0)
	                        THEN
	                            // Get the GIN if it's different than last updated GIN.
	                            IF #iqa_TrackingData[#si_LoopCounter] <> #si_LastUpdatedGIN THEN
	                                #si_GINToWrite := #iqa_TrackingData[#si_LoopCounter];
	                            END_IF;
	                            // If the first GIN was found, the scan loop conitues to check if there is no other data.
	                        ELSE
	                            // Next found data is different than the first one. Double data detected.
	                            IF (#iqa_TrackingData[#si_LoopCounter] <> #si_GINToWrite)
	                            THEN
	                                #sx_DoubleDataFound := TRUE;
	                                // First found GIN is marked as a lost one and the GIN is stored in a FIFO register.
	                                IF ("DB_GIN".GIN[#si_GINToWrite].General.Lost = FALSE)
	                                THEN
	                                    "DB_GIN".GIN[#si_GINToWrite].General.Lost := TRUE;
	                                    
	                                    "FC_Fifo"(ic_Mode := 'W',
	                                              qUDT_Status => #sUDT_LostGINFIFOStatus,
	                                              qx_Error => #sx_LostGINFIFOError,
	                                              qx_Warning => #sx_LostGINFIFOWarning,
	                                              iqv_Data := #si_GINToWrite,
	                                              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                                              iqv_DataBuffer := #iqa_FifoData);
	                                    
	                                    // Update statistics
	                                    #ss_LostParcelsCounters.Total += 1;
	                                    #ss_LostParcelsCounters.DoubleData += 1;
	                                    
	                                    
	                                    ////////////////////
	                                    
	                                    IF #si_GINToWrite >= 1000 THEN
	                                        #ss_LostValidParcelsCounters.Total += 1;
	                                        #ss_LostValidParcelsCounters.DoubleData += 1;
	                                    END_IF;
	                                    
	                                    ////////////////
	                                END_IF;
	                                
	                                // Second found GIN is marked as a lost one and the GIN is stored in a FIFO register.
	                                IF ("DB_GIN".GIN[#iqa_TrackingData[#si_LoopCounter]].General.Lost = FALSE)
	                                THEN
	                                    "DB_GIN".GIN[#iqa_TrackingData[#si_LoopCounter]].General.Lost := TRUE;
	                                    
	                                    "FC_Fifo"(ic_Mode := 'W',
	                                              qUDT_Status => #sUDT_LostGINFIFOStatus,
	                                              qx_Error => #sx_LostGINFIFOError,
	                                              qx_Warning => #sx_LostGINFIFOWarning,
	                                              iqv_Data := #iqa_TrackingData[#si_LoopCounter],
	                                              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                                              iqv_DataBuffer := #iqa_FifoData);
	                                    
	                                    // Update statistics
	                                    #ss_LostParcelsCounters.Total += 1;
	                                    #ss_LostParcelsCounters.DoubleData += 1;
	                                    
	                                    ////////////////////
	                                    
	                                    IF #iqa_TrackingData[#si_LoopCounter] >= 1000 THEN
	                                        #ss_LostValidParcelsCounters.Total += 1;
	                                        #ss_LostValidParcelsCounters.DoubleData += 1;
	                                    END_IF;
	                                    
	                                    ////////////////
	                                    //
	                                END_IF;
	                                // Stop search window scan in case of double data detection
	                                EXIT;
	                            END_IF;
	                        END_IF;
	                    END_IF;
	                END_FOR;
	                
	                // Becasue the data was found as a first one, GIN is stored and the logic to wait for a parcel is enebaled.
	                // If the double data was found there is no need to wait for a parcel. Data has been marked as a lost one.
	                IF NOT #sx_DoubleDataFound
	                THEN
	                    #sx_ParcelWaitEnable := TRUE;
	                END_IF;
	                
	                #sx_DoubleDataFound := FALSE;
	(*
	Data and PEC signal detected at the same time - perfect match
	
	                         Search window
	                          <--------|
	Data                              PEC
	|----------------------------------|------------------------------------------|
	|                           XXXXXXXX                                          |
	|----------------------------------|------------------------------------------|
	                                   |
	Conveyor                           |
	|----------------------------------|------------------------------------------|
	|                           XXXXXXXX                                          | 
	|                           XXXXXXXX                                          |
	|                           XXXXXXXX                                          |
	|----------------------------------|------------------------------------------|
	
	or PEC signal found without data or with old ones
	
	                         Search window
	                          <--------|
	Data                              PEC
	|----------------------------------|------------------------------------------|
	|                    XXXXXXXX      |                                          |
	|----------------------------------|------------------------------------------|
	                                   |
	Conveyor                           |
	|----------------------------------|------------------------------------------|
	|                           XXXXXXXX                                          | 
	|                           XXXXXXXX                                          |
	|                           XXXXXXXX                                          |
	|----------------------------------|------------------------------------------|
	*)
	(*Data and PEC signal detected at the same time (perfect match) or PEC signal found without data or with old ones.*)
	            ELSIF (#sR_TRIG_ParcelFound.Q
	                AND (#sR_TRIG_PositiveDataFound.Q
	                OR (#iqa_TrackingData[#si_PositionToUpdate] = 0
	                OR #iqa_TrackingData[#si_PositionToUpdate] = #si_LastUpdatedGIN)
	                AND NOT #sx_ParcelWaitEnable))
	            THEN
	                // If the PEC is set as a GIN generation point, skip data detection loop and go to GIN generator.
	                IF (#iUDT_PECUpdateConfiguration.GenerationPoint)
	                THEN
	                    #sx_GenerateGIN := TRUE;
	                    // If the the PEC isn't a generation point, data search loop is enabled.
	                ELSE
	                    #si_GINToWrite := 0;
	                    
	                    // Double data detection loop.
	                    FOR #si_LoopCounter := #si_PositionToUpdate TO
	                        #si_PECPosition + (#si_SearchWindow * #si_Direction) BY #si_Direction DO
	                        
	                        // Data found in a search window.
	                        IF (#iqa_TrackingData[#si_LoopCounter] > 0)
	                        THEN
	                            // First GIN found.
	                            IF (#si_GINToWrite = 0)
	                            THEN
	                                // Get the GIN if it's different than last updated GIN.
	                                IF #iqa_TrackingData[#si_LoopCounter] <> #si_LastUpdatedGIN THEN
	                                    #si_GINToWrite := #iqa_TrackingData[#si_LoopCounter];
	                                    
	                                    // PEC/Data deviation acquisition
	                                    #ss_PECDataDeviation.Last := DINT_TO_INT(#si_PECPosition - #si_LoopCounter);
	                                    #ss_PECDataDeviation.GIN := #si_GINToWrite;
	                                    #ss_PECDataDeviation.Sum -= ABS(#ss_PECDataDeviation.Last);
	                                    #ss_PECDataDeviation.Nr += 1;
	                                    
	                                    // Parcel aligned statistics
	                                    IF (ABS(#ss_PECDataDeviation.Last) > ABS(#si_Displacement - 1))
	                                    THEN
	                                        #ss_AlignedParcelsCounters.Total += 1;
	                                        #ss_AlignedParcelsCounters.PECNoData += 1;
	                                    END_IF;
	                                END_IF;
	                                // If the first GIN was found, the scan loop conitues to check if there is no other data.
	                            ELSE
	                                // Next found data is different than the first one. Double data detected.
	                                IF (#iqa_TrackingData[#si_LoopCounter] <> #si_GINToWrite)
	                                THEN
	                                    // First found GIN is marked as a lost one and the GIN is stored in a FIFO register.
	                                    IF ("DB_GIN".GIN[#si_GINToWrite].General.Lost = FALSE)
	                                    THEN
	                                        "DB_GIN".GIN[#si_GINToWrite].General.Lost := TRUE;
	                                        "FC_Fifo"(ic_Mode := 'W',
	                                                  qUDT_Status => #sUDT_LostGINFIFOStatus,
	                                                  qx_Error => #sx_LostGINFIFOError,
	                                                  qx_Warning => #sx_LostGINFIFOWarning,
	                                                  iqv_Data := #si_GINToWrite,
	                                                  iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                                                  iqv_DataBuffer := #iqa_FifoData);
	                                        
	                                        // Update statistics
	                                        #ss_LostParcelsCounters.Total += 1;
	                                        #ss_LostParcelsCounters.DoubleData += 1;
	                                        
	                                        ////////////////////
	                                        
	                                        IF #si_GINToWrite >= 1000 THEN
	                                            #ss_LostValidParcelsCounters.Total += 1;
	                                            #ss_LostValidParcelsCounters.DoubleData += 1;
	                                        END_IF;
	                                        
	                                        ////////////////
	                                        //
	                                    END_IF;
	                                    
	                                    // Second found GIN is marked as a lost one and the GIN is stored in a FIFO register.
	                                    IF ("DB_GIN".GIN[#iqa_TrackingData[#si_LoopCounter]].General.Lost = FALSE)
	                                    THEN
	                                        "DB_GIN".GIN[#iqa_TrackingData[#si_LoopCounter]].General.Lost := TRUE;
	                                        "FC_Fifo"(ic_Mode := 'W',
	                                                  qUDT_Status => #sUDT_LostGINFIFOStatus,
	                                                  qx_Error => #sx_LostGINFIFOError,
	                                                  qx_Warning => #sx_LostGINFIFOWarning,
	                                                  iqv_Data := #iqa_TrackingData[#si_LoopCounter],
	                                                  iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                                                  iqv_DataBuffer := #iqa_FifoData);
	                                        
	                                        // Update statistics
	                                        #ss_LostParcelsCounters.Total += 1;
	                                        #ss_LostParcelsCounters.DoubleData += 1;
	                                        
	                                        ////////////////////
	                                        
	                                        IF #iqa_TrackingData[#si_LoopCounter] >= 1000 THEN
	                                            #ss_LostValidParcelsCounters.Total += 1;
	                                            #ss_LostValidParcelsCounters.DoubleData += 1;
	                                        END_IF;
	                                        
	                                        ////////////////
	                                        //
	                                    END_IF;
	                                    // Stop search window scan in case of double data detection
	                                    EXIT;
	                                END_IF;
	                            END_IF;
	                        END_IF;
	                    END_FOR;
	                    
	                    // GIN not found in a search window
	                    IF (#si_GINToWrite = 0)
	                    THEN
	                        #sx_GenerateGIN := TRUE;
	                        #si_UnknownParcelsCounters.DataNotFound += 1;
	                    END_IF;
	                    
	                    // Found GIN is a lost one - generate unknown GIN
	                    // Found GIN isn't lost or it's negative - don't do anything
	                    IF (#si_GINToWrite > 0)
	                    THEN
	                        IF ("DB_GIN".GIN[#si_GINToWrite].General.Lost)
	                        THEN
	                            #sx_GenerateGIN := TRUE;
	                            #si_UnknownParcelsCounters.LostParcelFound += 1;
	                        END_IF;
	                    END_IF;
	                END_IF;
	                
	                (*Second parcel has been found during data update. Situation can occur when search window is too short
	                  and the data is shifted. In that case found GIN will be marked as a lost one and new unknown GIN will be 
	                  generated. Negative GIN will be ignored.*)
	            ELSIF (#sR_TRIG_ParcelFound.Q
	                AND (#iqa_TrackingData[#si_PositionToUpdate] <> 0
	                AND #iqa_TrackingData[#si_PositionToUpdate] <> #si_LastUpdatedGIN)
	                AND NOT #sx_ParcelWaitEnable)
	            THEN
	                IF (#iqa_TrackingData[#si_PositionToUpdate] > 0)
	                THEN
	                    IF ("DB_GIN".GIN[#iqa_TrackingData[#si_PositionToUpdate]].General.Lost = FALSE)
	                    THEN
	                        "DB_GIN".GIN[#iqa_TrackingData[#si_PositionToUpdate]].General.Lost := TRUE;
	                        "FC_Fifo"(ic_Mode := 'W',
	                                  qUDT_Status => #sUDT_LostGINFIFOStatus,
	                                  qx_Error => #sx_LostGINFIFOError,
	                                  qx_Warning => #sx_LostGINFIFOWarning,
	                                  iqv_Data := #iqa_TrackingData[#si_PositionToUpdate],
	                                  iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                                  iqv_DataBuffer := #iqa_FifoData);
	                        
	                        // Update statistics
	                        #ss_LostParcelsCounters.Total += 1;
	                        #ss_LostParcelsCounters.DoubleData += 1;
	                        
	                        ////////////////////
	                        
	                        IF #iqa_TrackingData[#si_PositionToUpdate] >= 1000 THEN
	                            #ss_LostValidParcelsCounters.Total += 1;
	                            #ss_LostValidParcelsCounters.DoubleData += 1;
	                        END_IF;
	                        
	                        ////////////////
	                        //
	                    END_IF;
	                END_IF;
	                
	                // Generate GIN 
	                #sx_GenerateGIN := TRUE;
	                #si_UnknownParcelsCounters.LostParcelFound += 1;
	                
	                (*Second data has been found during data update. Situation can occur when search window is too short
	                  and the data is shifted. In that case found GIN will be marked as a lost one.*)
	            ELSIF (#sR_TRIG_PositiveDataFound.Q
	                AND #sx_ParcelDetected
	                AND #iqa_TrackingData[#si_PositionToUpdate] <> #si_GINToWrite)
	            THEN
	                // Mark GIN as a lost one
	                IF ("DB_GIN".GIN[#iqa_TrackingData[#si_PositionToUpdate]].General.Lost = FALSE)
	                THEN
	                    "DB_GIN".GIN[#iqa_TrackingData[#si_PositionToUpdate]].General.Lost := TRUE;
	                    "FC_Fifo"(ic_Mode := 'W',
	                              qUDT_Status => #sUDT_LostGINFIFOStatus,
	                              qx_Error => #sx_LostGINFIFOError,
	                              qx_Warning => #sx_LostGINFIFOWarning,
	                              iqv_Data := #iqa_TrackingData[#si_PositionToUpdate],
	                              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                              iqv_DataBuffer := #iqa_FifoData);
	                    
	                    // Update statistics
	                    #ss_LostParcelsCounters.Total += 1;
	                    #ss_LostParcelsCounters.DoubleData += 1;
	                    
	                    ////////////////////
	                    
	                    IF #iqa_TrackingData[#si_PositionToUpdate] >= 1000 THEN
	                        #ss_LostValidParcelsCounters.Total += 1;
	                        #ss_LostValidParcelsCounters.DoubleData += 1;
	                    END_IF;
	                    
	                    ////////////////
	                END_IF;
	            END_IF;
	            
	        END_REGION
	        
	        REGION 10.5 – GIN generator
	            
	            (*Used to generate new GIN. If the PEC position is a generation point, the number is taken from an internal GIN range.
	              If it's not, then GIN is taken from a global unknown GIN range.*)
	            
	            IF (#sx_GenerateGIN)
	            THEN
	                // Generation point.
	                IF (#iUDT_PECUpdateConfiguration.GenerationPoint)
	                THEN
	                    // Generate GIN from a valid GIN range.
	                    IF (#ss_ValidGINRange.GIN <= #ss_ValidGINRange.End)
	                    THEN
	                        #si_GINToWrite := #ss_ValidGINRange.GIN;
	                        #ss_ValidGINRange.GIN += 1;
	                    ELSE
	                        #si_GINToWrite := #ss_ValidGINRange.Start;
	                        #ss_ValidGINRange.GIN := #ss_ValidGINRange.Start + 1;
	                    END_IF;
	                    // Unknown GIN generator.
	                ELSE
	                    // Generate GIN from a unknown GIN range.
	                    IF (#iqUDT_UnknownGINRange.GIN <= #iqUDT_UnknownGINRange.End)
	                    THEN
	                        #si_GINToWrite := #iqUDT_UnknownGINRange.GIN;
	                        #iqUDT_UnknownGINRange.GIN += 1;
	                    ELSE
	                        #si_GINToWrite := #iqUDT_UnknownGINRange.Start;
	                        #iqUDT_UnknownGINRange.GIN := #iqUDT_UnknownGINRange.Start + 1;
	                    END_IF;
	                    
	                    // Unknwn parcels statistics.
	                    #si_UnknownParcelsCounters.Total += 1;
	                END_IF;
	                
	                // Reset generte GIN command.
	                #sx_GenerateGIN := FALSE;
	                
	                // GIN record is cleared with configured default GIN record while it's generated.
	                "DB_GIN".GIN[#si_GINToWrite] := "DB_GINDefault".GIN[#iUDT_PECUpdateConfiguration.DefaultGIN];
	            END_IF;
	            
	            #qi_GINwrite := #si_GINToWrite;
	            
	        END_REGION
	        
	        
	        REGION 10.6 – PEC position data update
	            
	            (*While parcel is detected, calculated GIN is written into the PEC position record.
	              If not, then the record is cleared with 0. Negative GIN is ignored or deleted, depending on configuration.*)
	            
	            IF (#sx_ParcelDetected)
	            THEN
	                
	                "FC_WriteGIN"(ii_GIN := #si_GINToWrite,
	                              ii_PositionToWrite := #si_PositionToUpdate,
	                              ii_NumberOfPositions := 1,
	                              ix_Direction := TRUE,
	                              iqa_TrackingData := #iqa_TrackingData);
	                
	            ELSE
	                IF (#iqa_TrackingData[#si_PositionToUpdate] > 0
	                    OR #iUDT_PECUpdateConfiguration.NegativeGINDelete)
	                THEN
	                    
	                    "FC_WriteGIN"(ii_GIN := #ci_ZeroGIN,
	                                  ii_PositionToWrite := #si_PositionToUpdate,
	                                  ii_NumberOfPositions := 1,
	                                  ix_Direction := TRUE,
	                                  iqa_TrackingData := #iqa_TrackingData);
	                    
	                END_IF;
	            END_IF;
	            
	        END_REGION
	        
	        REGION 10.7 – Parcel waiting logic
	            
	            (*Parcel waiting logic is used to wait for the photoeye signal for a search window distance.*)
	            IF (#sx_ParcelWaitEnable)
	            THEN
	                // Counting parcel wait distance depending on conveyor running direction if not detected.
	                IF (NOT #sx_ParcelDetected)
	                THEN
	                    IF (#si_Direction = 1)
	                    THEN
	                        #si_ParcelWaitDistance += 1;
	                    ELSE
	                        #si_ParcelWaitDistance -= 1;
	                    END_IF;
	                    
	                    // Parcel detected - stop waiting, use found GIN to update.   
	                ELSE
	                    // PEC/Data deviation acquisition
	                    #ss_PECDataDeviation.Last := #si_ParcelWaitDistance;
	                    #ss_PECDataDeviation.GIN := #si_GINToWrite;
	                    #ss_PECDataDeviation.Sum += ABS(#ss_PECDataDeviation.Last);
	                    #ss_PECDataDeviation.Nr += 1;
	                    
	                    
	                    // Parcel aligned statistics
	                    IF (#ss_PECDataDeviation.Last > ABS(#si_Displacement - 1))
	                    THEN
	                        #ss_AlignedParcelsCounters.Total += 1;
	                        #ss_AlignedParcelsCounters.DataNoPEC += 1;
	                    END_IF;
	                    
	                    // Parcel waiting logic reset.
	                    #sx_ParcelWaitEnable := FALSE;
	                    #si_ParcelWaitDistance := 0;
	                END_IF;
	            END_IF;
	            
	            // Parcel not found in a search window - stop waiting, mark found GIN as a lost one.
	            IF (ABS(#si_ParcelWaitDistance) = #si_SearchWindow)
	                AND (#si_GINToWrite > 0)
	            THEN
	                // Parcel lost
	                IF "DB_GIN".GIN[#si_GINToWrite].General.Lost = FALSE THEN
	                    "DB_GIN".GIN[#si_GINToWrite].General.Lost := TRUE;
	                    "FC_Fifo"(ic_Mode := 'W',
	                              qUDT_Status => #sUDT_LostGINFIFOStatus,
	                              qx_Error => #sx_LostGINFIFOError,
	                              qx_Warning => #sx_LostGINFIFOWarning,
	                              iqv_Data := #si_GINToWrite,
	                              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                              iqv_DataBuffer := #iqa_FifoData);
	                    
	                    // Parcel waiting logic reset.
	                    #si_ParcelWaitDistance := 0;
	                    #sx_ParcelWaitEnable := FALSE;
	                    
	                    // Lost parcels ina  row counter.
	                    #si_LostParcelsInARow += 1;
	                    
	                    // Update statistics.
	                    #ss_LostParcelsCounters.Total += 1;
	                    #ss_LostParcelsCounters.ParcelNotFound += 1;
	                    
	                    ////////////////////
	                    
	                    IF #si_GINToWrite >= 1000 THEN
	                        #ss_LostValidParcelsCounters.Total += 1;
	                        #ss_LostValidParcelsCounters.ParcelNotFound += 1;
	                    END_IF;
	                    
	                    ////////////////
	                    //
	                END_IF;
	                
	            END_IF;
	            
	            // Reset monitoring in case of going backwards.
	            IF (#si_ParcelWaitDistance = 0
	                AND NOT #sx_ParcelDetected
	                AND #sx_InvalidDirection)
	            THEN
	                #sx_ParcelWaitEnable := FALSE;
	            END_IF;
	            
	            #sx_InvalidDirection := ((#si_Direction = 1
	            AND #si_ParcelWaitDistance < 0)
	            OR (#si_Direction = -1
	            AND #si_ParcelWaitDistance > 0));
	            
	        END_REGION
	        
	        REGION 10.8 – Last updated GIN
	            
	            (*Last updated GIN to avoid processing the same data.*)
	            IF (#sR_TRIG_DataFound.Q)
	            THEN
	                #si_LastUpdatedGIN := #iqa_TrackingData[#si_PositionToUpdate];
	            END_IF;
	            
	        END_REGION
	        
	        REGION 10.8 – Update displacement
	            
	            #si_Displacement := #si_Displacement - #si_Direction;
	            
	        END_REGION
	        
	    END_WHILE;
	    
	END_REGION
	
	REGION 11 – Length measurement
	    
	    
	    
	    (*Length and gap measurements can be enabled via PEC update configuration*)
	    #sFB_LengthMeasurement(ii_PECPosition := #si_PECPosition,
	                           ii_Displacement := #iqUDT_ConveyorInterface.Displacement,
	                           ix_LengthMeasurementEnable := #iUDT_PECUpdateConfiguration.ParcelLengthMeasurement OR #sx_LengthMeasurementEnable,
	                           ix_GapMeasurementEnable := #iUDT_PECUpdateConfiguration.GapLengthMeasurement,
	                           iqa_TrackingData := #iqa_TrackingData);
	    
	    IF #iqa_TrackingData[#si_PECPosition] > 0
	        AND #iqa_TrackingData[#si_PECPosition] >= #iqUDT_UnknownGINRange.Start
	        AND #iqa_TrackingData[#si_PECPosition] <= #iqUDT_UnknownGINRange.End
	    THEN
	        
	        #sx_LengthMeasurementEnable := "DB_GIN".GIN[#iqa_TrackingData[#si_PECPosition]].General.Length = 0;
	    ELSE
	        
	        #sx_LengthMeasurementEnable := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 12 – Teaching done 
	    
	    // Average slip calculation
	    #si_AverageSlip := #ss_PECDataDeviation.Sum / #ss_PECDataDeviation.Nr;
	    #si_CalculatedLengthCorrection := DINT_TO_INT(#iUDT_ConveyorCommonConfiguration.LengthCorrection) + #si_AverageSlip * 10;
	    IF (#sx_TeachingMode                                                                                                            // Teaching mode enabled 
	        AND #si_NumberOfTeachedParcels = #iUDT_PECUpdateConfiguration.NrOfTeachParcels)                                                 // Number of teaching parcels equal to the preset one                                                                                                                                                              // Teaching mode enabled ("sx_TeachMode") 
	    THEN
	        
	        #si_CalculatedLengthCorrection := DINT_TO_INT(#iUDT_ConveyorCommonConfiguration.LengthCorrection) + #si_AverageSlip * 10;
	        #sx_TeachingMode := FALSE;
	        #si_NumberOfTeachedParcels := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 13 – Performance    
	    
	    (*Performnce is a percentage ratio between number of lost parcels and total number of data, used to monitor data update efficiency.*)
	    
	    IF (#sdi_TotalNumberOfData >= #ss_LostParcelsCounters.Total
	        AND #sdi_TotalNumberOfData > 0)
	    THEN
	        #slr_Performance := 100.0 - INT_TO_LREAL(#ss_LostParcelsCounters.Total) / #sdi_TotalNumberOfData * 100.0;
	    END_IF;
	    
	    // Warning is generated if performance drops below 80%.
	    #qUDT_Status.LowPerformance := #slr_Performance < 80;
	    
	END_REGION
	
	REGION 14 – Reset statistics
	    
	    // Statistics are reset if reset signal is given.
	    IF #iqUDT_ConveyorInterface.ResetStatistics
	    THEN
	        #sdi_TotalNumberOfParcels := 0;
	        #ss_AlignedParcelsCounters.Total := 0;
	        #ss_AlignedParcelsCounters.PECNoData := 0;
	        #ss_AlignedParcelsCounters.DataNoPEC := 0;
	        #ss_LostParcelsCounters.Total := 0;
	        #ss_LostParcelsCounters.DoubleData := 0;
	        #ss_LostParcelsCounters.ParcelNotFound := 0;
	        #ss_LostValidParcelsCounters.Total := 0;
	        #ss_LostValidParcelsCounters.DoubleData := 0;
	        #ss_LostValidParcelsCounters.ParcelNotFound := 0;
	        #sdi_TotalNumberOfData := 0;
	        #si_UnknownParcelsCounters.Total := 0;
	        #si_UnknownParcelsCounters.LostParcelFound := 0;
	        #si_UnknownParcelsCounters.DataNotFound := 0;
	        #ss_PECDataDeviation.Sum := 0;
	        #ss_PECDataDeviation.Nr := 0;
	        #slr_Performance := 100;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 15 – Too many lost parcels error
	    
	    (*Error is generated if too many parcels will is marked as a lost one in a row*)
	    IF (#si_LostParcelsInARow >= #iUDT_PECUpdateConfiguration.MaxLost)
	    THEN
	        #qUDT_Status.TooManyLost := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 16 – Statistics
	    
	    // Too many lost
	    #sR_TRIG_TooManyLost(CLK := #qUDT_Status.TooManyLost);
	    IF #qUDT_Status.TooManyLost
	        OR #iqUDT_ConveyorInterface.ResetStatistics
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #qUDT_Status.TooManyLost,
	                        ix_RTrigActivate := #sR_TRIG_TooManyLost.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.TooManyLost);
	    END_IF;
	    
	    // Total number of parcels
	    #iqUDT_Statistics.TotalNrOfParcels := #sdi_TotalNumberOfParcels;
	    
	END_REGION
	
	REGION 17 – Internal tracking warning and error
	    
	    // Internal tracking warning
	    IF (#qUDT_Status.LowPerformance
	        OR #sx_LostGINFIFOWarning)
	    THEN
	        #iqUDT_ConveyorInterface.InternalWarningTracking := TRUE;
	    END_IF;
	    
	    // Internal tracking error
	    IF #qUDT_Status.TooManyLost
	    THEN
	        #iqUDT_ConveyorInterface.InternalErrorTracking := TRUE;
	    END_IF;
	    
	    // Configuration error
	    IF (#sx_InvalidDisplacement
	        OR #sx_InvalidGINRange
	        OR #sx_InvalidSearchWindow)
	    THEN
	        #iqUDT_ConveyorInterface.ConfigurationError := TRUE;
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_VSULift"
TITLE = FB_VerticalSwitch
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : Equipment
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 258
// END_ATTRIBUTES
//Function block to control vertical switch unit.
   VAR_INPUT 
      iUDT_VSUConfig { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VSULiftConfiguration";   // VSU Configuration structure
      ix_SafetyOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when Safety Circuit of the Conveyor is healthy
      ix_BeltTear1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when Belt tear switch 1 is ok
      ix_BeltTear2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when Belt tear switch 2 is ok
      ix_MaintSupport1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when lift maintenance support 1 is retracted
      ix_MaintSupport2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when lift maintenance support 2 is retracted
      ix_PosUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when position sensor is covered
      ix_PosDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when position sensor is covered
      ix_PECGapEnd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when PEC Jamdetection going up is not blocked
      ix_PECGapBegin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when PEC Jamdetection going down is not blocked
      ix_LimitSwitchUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when limit position is overrun
      ix_LimitSwitchDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when limit position is overrun
      ix_SafetyDoorDiagDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE safety door diagnosis ok (Down)
      ix_SafetyDoorDiagUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE safety door diagnosis ok (Up)
      ix_LCPAutoMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when LocalControlPanel switch Automatic is on
      ix_LCPManualMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when LocalControlPanel switch Manual is on
      ix_LCPStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when LocalControlPanel switch Stop is on
      ix_LCPDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when LocalControlPanel switch Down is on
      ix_LCPUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when LocalControlPanel switch Up is on
      ix_LCPRef { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when LocalControlPanel switch Refference is on
      ix_TransportIdle { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when lift block signals transport is idle
      ix_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when  hardware is Ok
      ix_MaintenanceSwitchUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when Maintenance Switch is turned  on
      ix_MainContactorFeedback { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when Main Contactor is OK
      ix_OverTempBrakingResistor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when Over Temperature Braking Resisitor is OK
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VSULiftStatus";   // HMI status structure
      qUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   // Common status structure
      qx_MainContactorOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Main Contactor On
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
      iqUDT_VSUCommand : "UDT_VSUCommand";   // VSU HMI Command structure
      iqUDT_VSUInterface : "UDT_VSUInterface";   // Interface between VSU and VFD
      iqUDT_Statistics : "UDT_VSULiftStatistics";   // Statistics structure
   END_VAR

   VAR 
      sUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VSULiftStatus";   // HMI status structure
      sUDT_StatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Common status structure
      sUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Common status structure
      sFB_PECEoSFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Filtering end of section photo eye signal
      sFB_PEC_GapEndFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Filtering upper jam photo eye signal
      sFB_PEC_GapBeginFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Filtering lower jam photo eye signal
      sFB_JogEnable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Filtering lower jam photo eye signal
      sFB_MaxStopTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer for maximum stopping time
      sR_TRIG_ManualMode {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger manual mode
      sR_TRIG_ManualJogUp {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger manual jog mode command
      sR_TRIG_ManualJogDown {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger manual jog mode command
      sR_TRIG_DownTime {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger VSU is stopped
      sR_TRIG_Error {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger for Error
      sR_TRIG_GapExit_Error {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger for Exit gap check error
      sR_TRIG_GapEntry_Error {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger for Entry gap check error
      sR_TRIG_BeltTear1 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger for Belt tear 1 detected
      sR_TRIG_BeltTear2 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger for Belt tear 2 detected
      sR_TRIG_MaintSupport1Err {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger for Maintenace support 1 extracted
      sR_TRIG_MaintSupport2Err {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger for Maintenace support 2 extracted
      sR_TRIG_UpperPositionErr {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger for Upper position overrun
      sR_TRIG_LowerPositionErr {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger for Lower position overrun
      sR_TRIG_SafetyDoorErr {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger for Safety door diagnostic fault
      sR_TRIG_Direction_Error {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger for Direction error
      sR_TRIG_UpTime {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger VSU is running automatic
      sR_TRIG_GOReference {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger for VFD to do reference run
      sR_TRIG_Referenced {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger VFD refferenced
      sR_TRIG_TIPLeavingVSU {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger TIP VSU Conveyor
      sF_TRIG_TIPLeavingVSU {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger TIP VSU Conveyor
      sR_TRIG_RestartFromError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger Restart from error
   END_VAR
   VAR RETAIN
      sdi_RunEmpty { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Calculation run empty distance
   END_VAR
   VAR 
      si_Position { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Position from Decisionpoint
      si_RequiredGap { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Required gap in front of VSU
   END_VAR
   VAR RETAIN
      si_UpperHeadToHead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Gap calculation Head To Head upper conveyor
      si_UpperGap { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Gap calculation upper outfeed conveyor
      si_LowerHeadToHead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Gap calculation Head To Head lower conveyor
      si_LowerGap { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Gap calculation lower outfeed conveyor
      si_UpJamDisplacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Auxiliary variable to calculate displacement when PEC is blocked
      si_LowJamDisplacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Auxiliary variable to calculate displacement when PEC is blocked
   END_VAR
   VAR 
      si_DefaultPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Auxiliary variable to set default position
      sx_StartReceived { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start command received from system
      sx_PEC_EoSFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // End of section photo eye filtered
      sx_PEC_UpOutFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Upper outfeed photo eye filtered
      sx_PEC_LowOutFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Lower outfeed photo eye filtered
      sx_PEC_GapEnd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Upper jam photo eye filtered
      sx_PEC_GapBegin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Lower jam photo eye filtered
      sx_Ready { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor Ready to operate in Automatic mode
      sx_AutomaticActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Running in automatic
      sx_SemiAutomatic { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Running in semi automatic
      sx_PositionAfterRef { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // After reffer
      sx_PreStartManual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Pre conditions to run conveyor in manual mode
      sx_ManualModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual mode active
      sx_Stopping { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stopping is active, first reach position
      sx_SwitchEnable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Switching conditions
      sx_UpRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request upper outfeed position for actual parcel
      sx_DownRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request lower outfeed position for actual parcel
      sx_ActualPositionUP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Actual position is up
      sx_ActualPositionDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Actual position is down
      sx_GappingUpper { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Gapping upper outfeed is active
      sx_GappingLower { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Gapping lower outfeed is active
      sx_CombinedJogUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Combined signal of jogging buttons
      sx_CombinedJogDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Combined signal of jogging buttons
      sx_RestartFromError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   After an error has occurred the action to be done before resuming normal operation
      sx_StopInfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Stop infeed conveyor
      sx_Jog { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Off delayed signal Jogging was activated
      sx_ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Commissioning: configuration of parameters is wrong
   END_VAR

   VAR_TEMP 
      tr_req : Real;
   END_VAR

   VAR CONSTANT 
      ci_PositionUp : Int := 2;   //   Value for UP Position
      ci_PositionDown : Int := 1;   //   Value for DOWN Position
      ci_PositionDefault : Int := 99;   //   Value for DEFAULT Position
   END_VAR


BEGIN
	(*
	
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	19/10/2023  | 1.0       | F.Baten       | FB_VSULift: Branched version of FB_VSU for Lift application without gapping and tracking 
	19/10/2023  | 1.1       | J.Majer       | Clear unused functions and adding belt tear, gap check, up&down limit switch, lifting carriage supports inputs with statistics and status
	14/06/2024  | 1.2       | R. Pieczonka  | Added new errors
	*)
	
	REGION 1 - Initial
	    
	    REGION 1.1 - First PLC cycle
	        
	        IF "DB_Memory".FirstScan
	        THEN
	            #sx_AutomaticActive := FALSE;                                               // switch of automatic active
	        END_IF;
	        
	    END_REGION
	    
	    REGION 1.2 - Triggers
	        
	        // Detecting rising edge on manual mode Or from Equipment Control
	        #sR_TRIG_ManualMode(CLK := #sUDT_Status.Manual);
	        
	        // Rising edge trigger running        
	        #sR_TRIG_UpTime(CLK := #sx_AutomaticActive AND #sx_Ready);
	        
	        // Detecting rising edge VSU stopped        
	        #sR_TRIG_DownTime(CLK := #sx_AutomaticActive AND NOT #sx_Ready);
	        
	        // Detecting rising edge on VSU error
	        #sR_TRIG_Error(CLK := #sUDT_Status.Error);
	        
	        // Detecting rising edge on start of the restart from error sequence
	        #sR_TRIG_RestartFromError(CLK := #sx_RestartFromError);
	        
	    END_REGION
	    
	    REGION 1.3 - Filters
	        
	        //Gap check end detection photo eye signal filtering
	        #sFB_PEC_GapEndFiltered(iudi_OnDelayTime := #iUDT_VSUConfig.PEC_GapEndOnDelay,
	                                iudi_OffDelayTime := #iUDT_VSUConfig.PEC_GapEndOffDelay,
	                                ix_SignalToDelay := #ix_PECGapEnd,
	                                ix_Enable := TRUE,
	                                qx_DelayedSignal => #sx_PEC_GapEnd);
	        
	        //Gap check begin detection photo eye signal filtering
	        #sFB_PEC_GapBeginFiltered(iudi_OnDelayTime := #iUDT_VSUConfig.PEC_GapBeginOnDelay,
	                                  iudi_OffDelayTime := #iUDT_VSUConfig.PEC_GapBeginOffDelay,
	                                  ix_SignalToDelay := #ix_PECGapBegin,
	                                  ix_Enable := TRUE,
	                                  qx_DelayedSignal => #sx_PEC_GapBegin);
	        
	        // Time to start without start warning while jogging
	        #sFB_JogEnable(iudi_OffDelayTime := #iUDT_VSUConfig.JogNoHornTime,
	                       ix_SignalToDelay := #sx_Jog);
	        
	        // Maximum stopping time
	        #sFB_MaxStopTime(iudi_OnDelayTime := (#iUDT_VSUConfig.SwitchingTime + #iUDT_VSUConfig.SwitchingTime),
	                         ix_SignalToDelay := #sx_Stopping);
	    END_REGION
	    
	    REGION 1.4 - Switching conditions             
	        
	        #sx_SwitchEnable :=                                                       // Enabling of direction switching
	        #ix_TransportIdle                                                         // No transfer in progress
	        AND #sx_PEC_GapBegin                                                      // entry gap sensor free
	        AND #sx_PEC_GapEnd                                                        // exit gap sensor free
	        AND #ix_BeltTear1                                                         // belt tear sensor 1 ok
	        AND #ix_BeltTear2                                                         // belt tear sensor 2 ok
	        AND #ix_MaintSupport1                                                     // Lift support extracted in automatic mode
	        AND #ix_MaintSupport1                                                     // Lift support extracted in automatic mode
	        AND NOT #ix_LimitSwitchUp                                                 // upper limit switch not overrun
	        AND NOT #ix_LimitSwitchDown                                               // lower limit switch not overrun
	        ;
	        
	    END_REGION
	    
	    REGION 1.5 - Position
	        
	        #sx_ActualPositionUP :=                                                         // Set status bit lift in upper position 
	        (#iqUDT_VSUInterface.PositionActual = #ci_PositionUp)                           // If actual position is equal to up 
	        AND NOT #iqUDT_VSUInterface.Positioning                                         // And the positioning is not active 
	        AND #ix_PosUp;                                                                  // And the position sensor signals
	        
	        #sx_ActualPositionDown :=                                                       // Set bit lift in lower position 
	        (#iqUDT_VSUInterface.PositionActual = #ci_PositionDown)                         // If actual position is equal to down 
	        AND NOT #iqUDT_VSUInterface.Positioning                                         // And the positioning is not active 
	        AND #ix_PosDown;                                                                // And the position sensor signals
	    END_REGION
	    
	    REGION 1.6 - Check configuration 
	        #si_DefaultPosition := #iUDT_VSUConfig.DefaultPosition;
	        
	        IF #si_DefaultPosition <= 0
	        THEN
	            #si_DefaultPosition := #ci_PositionDown;
	            
	        END_IF;
	    END_REGION
	END_REGION
	
	REGION 2 - Errors
	    
	    REGION 2.1 - Reset errors
	        
	        IF #iqUDT_EquipmentControl.Command.Reset                                       // Reset
	        THEN
	            // Gap check
	            IF #sUDT_HMIStatus.Specific.ExitGapErr                            // Exit gap check is active 
	                AND (#sx_PEC_GapEnd OR #iqUDT_VSUInterface.PositionActual = #iqUDT_VSUInterface.PositionSetpoint)                                                      // Upper jam sensor is free
	            THEN
	                #sUDT_HMIStatus.Specific.ExitGapErr := FALSE;                 // reset error
	                
	            END_IF;
	            
	            IF #sUDT_HMIStatus.Specific.EntryGapErr                            // Entry gap check is active 
	                AND (#sx_PEC_GapBegin OR #iqUDT_VSUInterface.PositionActual = #iqUDT_VSUInterface.PositionSetpoint)                                                   // Lower jam sensor is free
	            THEN
	                #sUDT_HMIStatus.Specific.EntryGapErr := FALSE;             // reset error
	                
	            END_IF;
	            
	            // Belt tear switch 1
	            IF #ix_BeltTear1                                                        // Belt tear switch 1 is ok
	            THEN
	                #sUDT_HMIStatus.Specific.BeltTear1Err := FALSE;                // reset error
	            END_IF;
	            
	            // Belt tear switch 2
	            IF #ix_BeltTear2                                                        // Belt tear switch 2 is ok
	            THEN
	                #sUDT_HMIStatus.Specific.BeltTear2Err := FALSE;                // reset error
	            END_IF;
	            
	            // Maintenace supports for lift carriage extracted
	            IF #ix_MaintSupport1                                                    // Maintenace support 1 stowed
	            THEN
	                #sUDT_HMIStatus.Specific.MaintSupport1Err := FALSE;             // reset error
	            END_IF;
	            
	            // Maintenace supports for lift carriage extracted
	            IF #ix_MaintSupport2                                                    // Maintenace support 2 stowed
	            THEN
	                #sUDT_HMIStatus.Specific.MaintSupport2Err := FALSE;             // reset error
	            END_IF;
	            
	            // Upper limit switch
	            IF NOT #ix_LimitSwitchUp                                                // Upper limit switch not overrun
	            THEN
	                #sUDT_HMIStatus.Specific.UpperPositionErr := FALSE;             // reset error
	            END_IF;
	            
	            IF #ix_SafetyDoorDiagUp                                                // Safety door diagnostic output
	            THEN
	                #sUDT_HMIStatus.Specific.SafetyDoorUpErr := FALSE;                 // reset error
	            END_IF;
	            
	            // Lower limit switch
	            IF NOT #ix_LimitSwitchDown                                                // Lower limit switch not overrun
	            THEN
	                #sUDT_HMIStatus.Specific.LowerPositionErr := FALSE;             // reset error
	            END_IF;
	            
	            IF #ix_SafetyDoorDiagDown                                                // Safety door diagnostic output
	            THEN
	                #sUDT_HMIStatus.Specific.SafetyDoorDownErr := FALSE;                 // reset error
	            END_IF;
	            
	            // Direction error
	            IF #sUDT_HMIStatus.Specific.DirectionErr                                  // Direction verification found the direction fault, stop VSU action and move in opposite direction
	                AND NOT #iqUDT_VSUInterface.MotorRunning                               // The VFD is stopped
	                AND #sx_PEC_EoSFiltered                                                 // The photoeye on the VSU conveyor is empty
	            THEN
	                
	                #sUDT_HMIStatus.Specific.DirectionErr := FALSE;                       // Direction verification found the direction fault, stop VSU action and move in opposite direction
	                
	            END_IF;
	            
	        END_IF;
	    END_REGION
	    
	    REGION 2.2 - Set errors
	        
	        // Exit gap check blocked in movement
	        IF NOT #sx_PEC_GapEnd                                                             // Upper jam sensor occupied
	            AND #iqUDT_VSUInterface.Positioning                                        // The positioning motor is running
	            AND (#sx_UpRequest OR #sx_DownRequest)                                                         // an uprequest is active (going up)
	        THEN
	            
	            #sUDT_HMIStatus.Specific.ExitGapErr := TRUE;                      // Set error upper jam sensor
	        END_IF;
	        
	        // Entry gap check blocked in movement
	        IF NOT #sx_PEC_GapBegin                                                           // Lower jam sensor occupied               
	            AND #iqUDT_VSUInterface.Positioning                                        // The positioning motor is running
	            AND (#sx_UpRequest OR #sx_DownRequest)                                                       // an downrequest is active (going down)
	        THEN
	            
	            #sUDT_HMIStatus.Specific.EntryGapErr := TRUE;                      // Set error lower jam sensor
	        END_IF;
	        
	        
	        // Belt tear switch 1
	        IF NOT #ix_BeltTear1                                                   // Belt tear switch 1 is activated
	        THEN
	            #sUDT_HMIStatus.Specific.BeltTear1Err := TRUE;                // set error
	        END_IF;
	        
	        // Belt tear switch 2
	        IF NOT #ix_BeltTear2                                                   // Belt tear switch 2 is activated
	        THEN
	            #sUDT_HMIStatus.Specific.BeltTear2Err := TRUE;                // set error
	        END_IF;
	        
	        // Maintenace supports for lift carriage extracted
	        IF NOT #ix_MaintSupport1                                               // Maintenace support 1 extended
	        THEN
	            #sUDT_HMIStatus.Specific.MaintSupport1Err := TRUE;             // set error
	        END_IF;
	        
	        // Maintenace supports for lift carriage extracted
	        IF NOT #ix_MaintSupport2                                                // Maintenace support 2 extended
	        THEN
	            #sUDT_HMIStatus.Specific.MaintSupport2Err := TRUE;             // set error
	        END_IF;
	        
	        // Upper limit switch
	        IF #ix_LimitSwitchUp                                                   // Upper limit switch is overrun
	        THEN
	            #sUDT_HMIStatus.Specific.UpperPositionErr := TRUE;             // set error
	        END_IF;
	        
	        IF NOT #ix_SafetyDoorDiagUp                                                 // Safety door diagnostic output
	        THEN
	            #sUDT_HMIStatus.Specific.SafetyDoorUpErr := TRUE;                // set error
	        END_IF;
	        
	        
	        // Lower limit switch
	        IF #ix_LimitSwitchDown                                                // Lower limit switch is overrun
	        THEN
	            #sUDT_HMIStatus.Specific.LowerPositionErr := TRUE;            // set error
	        END_IF;
	        
	        IF NOT #ix_SafetyDoorDiagDown                                                 // Safety door diagnostic output
	        THEN
	            #sUDT_HMIStatus.Specific.SafetyDoorDownErr := TRUE;                // set error
	        END_IF;
	        
	        // Direction fault in semiautomatic mode
	        IF #sx_SemiAutomatic                                                               // Running Semi-Automatic 
	            AND (((#si_Position = #ci_PositionDown                                     // the requested position is "down"
	            AND #si_DefaultPosition = #ci_PositionDown)                                // and the configured "default" is equal to "down"                                     
	            OR (#si_Position = #ci_PositionDefault                                     // or the request is "default"
	            AND #si_DefaultPosition = #ci_PositionDown)                                // and the configured "default" is equal to "down"      
	            AND #sx_DownRequest)                                                       // but the position is "down"
	            
	            OR ((#si_Position = #ci_PositionUp                                         // or the requested position is "up"
	            AND #si_DefaultPosition = #ci_PositionUp)                                  // and the configured "default" is equal to "up"
	            OR (#si_Position = #ci_PositionDefault                                     // or the request is "default"
	            AND #si_DefaultPosition = #ci_PositionUp)                                  // and the configured "default" is equal to "up"
	            AND #sx_UpRequest))                                                        // but the position is "up"
	        THEN
	            
	            #sUDT_HMIStatus.Specific.DirectionErr := TRUE;                            // Direction verification found the Direction fault, stop the parcel
	        END_IF;
	        
	        
	        
	        #sx_ConfigurationError := (#iUDT_VSUConfig.DefaultPosition <= 0);                  // Set the configuration error bit (No status!!)
	        
	    END_REGION
	    
	    REGION 2.3 - Common Error
	        
	        #sUDT_Status.Error :=
	        #iqUDT_VSUInterface.InternalErrorVFD                                           // or there are errors in the VFD
	        OR #iqUDT_VSUInterface.InternalErrorRIOPanel                                   // or an internal error in the RIO panel occured
	        OR #sUDT_HMIStatus.Specific.DirectionErr                                      // Direction verification found the Direction fault, stop the parcel
	        OR #sUDT_HMIStatus.Specific.ExitGapErr                                // Upper jam PEC detected WHILE going Up
	        OR #sUDT_HMIStatus.Specific.EntryGapErr                                // Lower jam PEC detected while going Down
	        OR #sUDT_HMIStatus.Specific.MaintSupport1Err                            // Maintenace carriage support 1 extended in automatic mode
	        OR #sUDT_HMIStatus.Specific.MaintSupport2Err                            // Maintenace carriage support 2 extended in automatic mode
	        OR #sUDT_HMIStatus.Specific.BeltTear1Err                               // Belt tear sensor 1 was detected
	        OR #sUDT_HMIStatus.Specific.BeltTear2Err                              // Belt tear sensor 2 was detected
	        OR #sUDT_HMIStatus.Specific.UpperPositionErr                             // Upper limit switch is overrun
	        OR #sUDT_HMIStatus.Specific.LowerPositionErr                            // Lower limit switch is overrun
	        OR #sUDT_HMIStatus.Specific.SafetyDoorDownErr;                              // Safety door diagnostic fault
	        
	    END_REGION
	    
	    REGION 2.4 - Common Warning
	        
	        // Keyswitch NOT in a position
	        #sUDT_HMIStatus.Specific.KeyswitchWrn := NOT #ix_LCPAutoMode AND NOT #ix_LCPManualMode;
	        #sUDT_Status.Warning := #sUDT_HMIStatus.Specific.KeyswitchWrn;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 3 - Check conditions to set Equipment ready
	    
	    //Conditions to set bit sx_Ready to operate 
	    
	    #sx_Ready := NOT #sUDT_Status.Error                                                // Error present
	    AND #ix_SafetyOk                                                                    // Safety signalling NOT OK
	    AND #iqUDT_VSUInterface.VSUMainPowerOk;                                             // 400v signalling not OK
	    
	    //Enble main contactor
	    #qx_MainContactorOn := (#ix_LCPManualMode OR #ix_LCPAutoMode)                       // Auto or manual enabled
	    AND #ix_OverTempBrakingResistor;                                                    //Temperature breaking resistor is OK
	    
	    
	END_REGION
	
	REGION 4 - Stop Equipment
	    
	    IF #sx_ManualModeActive                                                             // Manual mode is active
	        AND #sx_AutomaticActive
	        
	        OR (NOT #iqUDT_EquipmentControl.Command.AutomaticOn                            // VSU stops if the bit AutomaticOn from control block is false
	        AND NOT #sx_ManualModeActive)                                                   // Manual mode active bit
	        
	        OR (NOT #sx_Ready                                                               // Bit VSU ready to run in automatic mode
	        AND NOT #sx_ManualModeActive)                                                   // Manual mode active
	        
	        OR NOT #ix_LCPAutoMode                                                          // LCP is not set to automatic
	        OR NOT #ix_SafetyOk                                                             // 
	        
	    THEN                                                                                // Order to stop 
	        #sx_Stopping := TRUE;                                                           // stopping is activated
	        #sx_AutomaticActive := FALSE;                                                   // switch of automatic activ
	        #sx_StartReceived := FALSE;                                                     // Start command received from system 
	        
	    END_IF;
	    
	    IF (#sx_Stopping                                                                     // stopping is activated
	        AND NOT #iqUDT_VSUInterface.Positioning)                                        // The positioning device is not active positioning 
	        OR #sFB_MaxStopTime.qx_DelayedSignal
	        OR NOT #sx_Ready
	        
	    THEN
	        #sx_Stopping := FALSE;                                                          // stopping is activated
	        #iqUDT_VSUCommand.CommandUp := FALSE;
	        #iqUDT_VSUCommand.CommandDown := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Start Automatic mode
	    
	    REGION 5.1 - Start 
	        // if start (OS) is received from system, this is memorised until started in cascade 
	        IF #iqUDT_EquipmentControl.Command.Start                                       // Start from system
	            AND #sx_Ready                                                               // Equipment has no errors
	        THEN
	            
	            #sx_StartReceived := TRUE;                                                  // Start command received from system 
	            
	        END_IF;
	        
	        IF #sx_StartReceived                                                            // Start command received from system
	            AND #iqUDT_VSUInterface.Referenced                                         // and VSU is referenced
	            AND #ix_LCPAutoMode                                                         // and the LCP is set to auto
	        THEN
	            
	            #sx_AutomaticActive := TRUE;                                                // Automatic activated
	            #sx_StartReceived := FALSE;                                                 // Start command received from system
	        END_IF;
	    END_REGION
	    
	    REGION 5.2 - Semi automatic mode
	        
	        #sx_SemiAutomatic := #sx_AutomaticActive                                        // Automatic activated
	        AND #iqUDT_VSUCommand.SemiAutomaticMode;                                       // and Semi-automatic is selected
	        
	    END_REGION
	    
	END_REGION
	
	REGION 6 - Manual mode
	    
	    REGION 6.1 - Manual mode: activation 
	        
	        // Manual mode is active if it is active from hmi or by control block  
	        #sx_ManualModeActive := #iqUDT_VSUCommand.ManualMode
	        OR #iqUDT_EquipmentControl.Command.ManualMode
	        OR #ix_LCPManualMode;
	        
	    END_REGION
	    
	    REGION 6.2 - Jog signals
	        
	        #sx_CombinedJogUp :=
	        (((#iqUDT_VSUCommand.ManualMode                                                // HMI in manual
	        OR #iqUDT_EquipmentControl.Command.ManualMode)                                 // Or a system control command to go to manual
	        AND #iqUDT_VSUCommand.JogUp)                                                   // If selected jog in positive direction 
	        OR (#ix_LCPManualMode                                                           // box in manual
	        AND #ix_LCPUp));                                                                // If selected jog in positive direction 
	        
	        #sx_CombinedJogDown :=
	        (((#iqUDT_VSUCommand.ManualMode                                                 // HMI in manual
	        OR #iqUDT_EquipmentControl.Command.ManualMode)                                  // Or a system control command to go to manual
	        AND #iqUDT_VSUCommand.JogDown)                                                 // If selected jog in negative direction 
	        OR (#ix_LCPManualMode                                                           // box in manual
	        AND #ix_LCPDown));                                                              // If selected jog in negative direction 
	        
	        // Detecting rising edge on manual jog Up           
	        #sR_TRIG_ManualJogUp(CLK := #sx_CombinedJogUp);
	        
	        // Detecting rising edge on manual jog Down          
	        #sR_TRIG_ManualJogDown(CLK := #sx_CombinedJogDown);
	        
	    END_REGION
	    
	    REGION 6.3 - Manual mode: disabled
	        
	        // Manual mode bits inputs can be reset in case of malfunction
	        IF #iqUDT_EquipmentControl.Command.DisableManualMode
	        THEN
	            
	            #iqUDT_VSUCommand.ManualMode := FALSE;                                     // reset manual mode 
	            #iqUDT_EquipmentControl.Command.ManualMode := FALSE;                       // reset manual mode command 
	            #iqUDT_VSUCommand.JogUp := FALSE;                                          // reset manual command Jog Up
	            #iqUDT_VSUCommand.JogDown := FALSE;                                        // reset manual command Jog Down
	            #sx_Jog := FALSE;
	        END_IF;
	    END_REGION
	    
	    REGION 6.4 - Manual PreStart up or down
	        
	        // Pre start conditions to run in manual mode
	        #sx_PreStartManual := #sx_ManualModeActive                                      // Manual mode active bit
	        AND #ix_SafetyOk                                                                // Safety healthy bit
	        //AND #iq_UDT_VSUInterface.PNDeviceOk                                                              // Profinet comunication 
	        AND NOT #iqUDT_VSUInterface.InternalErrorVFD;                                  // Internal error from VFD
	        
	        IF #sx_PreStartManual                                                           // Pre start conditions to run in manual mode
	            AND (#sR_TRIG_ManualJogUp.Q                                                  // Trigger to start VSU run in manual jog mode UP
	            OR #sR_TRIG_ManualJogDown.Q)                                                 // Trigger to start VSU run in manual jog mode Down
	            AND NOT #sFB_JogEnable.qx_DelayedSignal
	        THEN
	            
	            #iqUDT_EquipmentControl.Request.SignalingRequest := TRUE;                  // Request signaling TO control block before VSU runs in manual mode
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 6.5 - Jog mode Up / Down
	        
	        IF #sx_PreStartManual                                                           // IF in manual jog mode 
	            AND (NOT #iqUDT_EquipmentControl.Request.SignalingRequest                  // Signaling request done
	            OR #sFB_JogEnable.qx_DelayedSignal)
	            AND #sx_CombinedJogUp                                                       // If selected jog in positive direction 
	            AND NOT #sx_CombinedJogDown                                                 // And not selected jog in negative direction
	        THEN
	            
	            #iqUDT_VSUInterface.JogUp := TRUE;                                         // set jog positive 
	            #iqUDT_VSUInterface.JogDown := FALSE;                                      // reset jog negative 
	            #sx_Jog := true;
	            
	        ELSIF
	            #sx_PreStartManual                                                          // IF in manual jog mode 
	            AND (NOT #iqUDT_EquipmentControl.Request.SignalingRequest                  // Signaling request done
	            OR #sFB_JogEnable.qx_DelayedSignal)
	            AND NOT #sx_CombinedJogUp                                                   // If selected jog in positive direction 
	            AND #sx_CombinedJogDown                                                     // and there is command to jog in negative direction 
	        THEN
	            
	            #iqUDT_VSUInterface.JogUp := FALSE;                                        // reset jog positive 
	            #iqUDT_VSUInterface.JogDown := TRUE;                                       // set jog negative 
	            #sx_Jog := true;
	            
	        ELSIF
	            NOT #sx_PreStartManual                                                      // If not in manual mode 
	            OR (#sx_PreStartManual                                                      // or in manual mode
	            AND (#sx_CombinedJogUp                                                      // and jog positive is off 
	            AND #sx_CombinedJogDown)                                                    // AND jog negative is off 
	            OR (NOT #sx_CombinedJogUp                                                   // or jog positive is on 
	            AND NOT #sx_CombinedJogDown))                                               // and jog negative is on 
	        THEN
	            
	            #iqUDT_VSUInterface.JogUp := FALSE;                                        // reset jog positive 
	            #iqUDT_VSUInterface.JogDown := FALSE;                                      // reset jog negative 
	            #sx_Jog := False;
	        END_IF;
	    END_REGION
	END_REGION
	
	REGION 7 - Automatic mode
	    
	    REGION 7.1 - Direction from decision point
	        IF #iqUDT_VSUInterface.RequestedPosition <> 0                                  // Position is received from decision block
	        THEN
	            #si_Position := #iqUDT_VSUInterface.RequestedPosition;                     // Copy the input to the memory
	            
	        END_IF;
	        
	        // Requested position reset
	        IF (#iqUDT_VSUInterface.RequestedPosition = #iqUDT_VSUInterface.PositionActual OR
	            (#iqUDT_VSUInterface.RequestedPosition = #ci_PositionDefault AND #iqUDT_VSUInterface.PositionActual = #si_DefaultPosition))
	        THEN
	            
	            #iqUDT_VSUInterface.RequestedPosition := 0;
	            
	        END_IF;
	        
	        
	    END_REGION
	    
	    REGION 7.2 - Position Up / Down             
	        // 2 = Up, 1 = Down and 99 = Default 
	        // 
	        IF (#si_Position = #ci_PositionUp                                                            // If the position "up" is equal to the request 
	            OR (#si_Position = #ci_PositionDefault                                                       // Or the request is "default"
	            AND #si_DefaultPosition = #ci_PositionUp))                                               // and the configured "default" is equal to "up"
	            AND #sx_Ready                                                               // Ready to operate, No errors active
	            AND #sx_AutomaticActive                                                     // Automaticly started
	            AND NOT #sx_SemiAutomatic                                                   // Not running Semi-Automatic
	        THEN
	            
	            #sx_DownRequest := FALSE;                                                   // Reset down command
	            #sx_UpRequest := TRUE;                                                      // Set up command
	            #si_Position := 0;                                                          // Reset the memory
	        END_IF;
	        
	        IF (#si_Position = #ci_PositionDown                                                            // If the position "down" is equal to the request 
	            OR (#si_Position = #ci_PositionDefault                                                       // Or the request is "default"
	            AND #si_DefaultPosition = #ci_PositionDown))                                               // and the configured "default" is equal to "down"
	            AND #sx_Ready                                                               // Ready to operate, No errors active
	            AND #sx_AutomaticActive                                                     // Automaticly started
	            AND NOT #sx_SemiAutomatic                                                   // Not running Semi-Automatic
	        THEN
	            
	            #sx_DownRequest := TRUE;                                                    // Set down command
	            #sx_UpRequest := FALSE;                                                     // Reset up command
	            #si_Position := 0;                                                          // Reset the memory
	        END_IF;
	        
	        // if the VSU is not referenced set the default position, this ensures the VSU to go to the default
	        // after refferecing.
	        
	        IF NOT #iqUDT_VSUInterface.Referenced
	        THEN
	            IF #si_DefaultPosition = #ci_PositionUp
	            THEN
	                #sx_DownRequest := FALSE;                                               // Reset down command
	                #sx_UpRequest := TRUE;                                                  // Set up command
	                #iqUDT_VSUInterface.PositionSetpoint := #ci_PositionUp;                             // Set position to be Up    
	            END_IF;
	            
	            IF #si_DefaultPosition = #ci_PositionDown
	            THEN
	                #sx_DownRequest := TRUE;                                                // Reset down command
	                #sx_UpRequest := FALSE;                                                 // Set up command
	                #iqUDT_VSUInterface.PositionSetpoint := #ci_PositionDown;                             // Set position to be Down    
	            END_IF;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 7.3 - Semi automatic
	        
	        IF #sx_SemiAutomatic                                                            // Not running Semi-Automatic
	            AND #iqUDT_VSUCommand.CommandUp
	            
	        THEN
	            #sx_DownRequest := FALSE;                                                   // Reset down command
	            #sx_UpRequest := TRUE;                                                      // Set up command
	            #iqUDT_VSUCommand.CommandUp := FALSE;
	        END_IF;
	        
	        IF #sx_SemiAutomatic                                                            // Not running Semi-Automatic
	            AND #iqUDT_VSUCommand.CommandDown
	            
	        THEN
	            #sx_DownRequest := TRUE;                                                    // Reset down command
	            #sx_UpRequest := FALSE;                                                     // Set up command
	            #iqUDT_VSUCommand.CommandDown := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 7.4 - Controls to to go UP or Down
	        IF #sx_AutomaticActive                                                          // The VSU is automaticly started
	            AND #sx_Ready                                                               // Ready to run / no errors
	        THEN
	            
	            IF #sx_UpRequest                                                            // If there is request to move to the upper position 
	                AND #sx_SwitchEnable                                                    // The VSU is enabled to move 
	                AND NOT #iqUDT_VSUInterface.Positioning                                // Positioning device is positioning, moving to next position
	                AND #iqUDT_VSUInterface.Ready                                          // the positioning device is errorfree
	                AND NOT #sx_ActualPositionUP                                            // And not in upper position
	                
	            THEN
	                
	                #iqUDT_VSUInterface.PositionSetpoint := #ci_PositionUp;                // Set position to be Up
	                
	            END_IF;
	            
	            IF #sx_DownRequest                                                          // If there is request to move to the lower position 
	                AND #sx_SwitchEnable                                                    // The VSU is enabled to move 
	                AND NOT #iqUDT_VSUInterface.Positioning                                // Positioning device is positioning, moving to next position
	                AND #iqUDT_VSUInterface.Ready                                          // the positioning device is errorfree
	                AND NOT #sx_ActualPositionDown                                          // And not in lower position
	                
	            THEN
	                
	                #iqUDT_VSUInterface.PositionSetpoint := #ci_PositionDown;              // Set position to be Down
	                
	            END_IF;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 7.5 - Start/Stop VSU conveyor directly
	        // Start
	        IF #iqUDT_EquipmentControl.Command.Start                                       // Start from system
	            AND #sx_Ready                                                               // Equipment has no errors
	        THEN
	            #iqUDT_VSUInterface.ExternalHold := FALSE;                                 // External stop signal
	        END_IF;
	        
	        // Stop 
	        IF #sUDT_HMIStatus.Specific.ExitGapErr                                   // Gap check triggered while moving
	            OR #sUDT_HMIStatus.Specific.EntryGapErr                         // Gap check triggered while moving
	            OR #sUDT_HMIStatus.Specific.BeltTear1Err                        // Belt tear detected      
	            OR #sUDT_HMIStatus.Specific.BeltTear2Err                        // Belt tear detected
	            OR #sUDT_HMIStatus.Specific.MaintSupport1Err                    // Lift support extracted in automatic mode
	            OR #sUDT_HMIStatus.Specific.MaintSupport2Err                    // Lift support extracted in automatic mode
	            OR #sUDT_HMIStatus.Specific.UpperPositionErr                             // Upper limit switch is overrun
	            OR #sUDT_HMIStatus.Specific.LowerPositionErr                            // Lower limit switch is overrun
	            OR #sUDT_HMIStatus.Specific.SafetyDoorDownErr                               // Safety door diagnostic fault
	            OR #sUDT_HMIStatus.Specific.DirectionErr                                     // in semi-automatic mode and configured as security area: a parcel should go to reject area but direction is not. 
	            OR NOT #sx_AutomaticActive                                                  // The VSU is not (semi-)automatic active
	        THEN
	            #iqUDT_VSUInterface.ExternalHold := TRUE;                                  // External stop signal
	        END_IF;
	    END_REGION
	    
	END_REGION
	
	REGION 8 - Write interface DB signals
	    
	    REGION 8.1 - Signal interface
	        
	        #iqUDT_VSUInterface.InternalErrorReset := #iqUDT_EquipmentControl.Command.Reset;      // Write Reset signal to the VFD interface
	        #iqUDT_VSUInterface.ResetStatistics := #iqUDT_EquipmentControl.Command.ResetData;     // Write Reset data signal to the VFD interface
	        #iqUDT_VSUInterface.SwitchingTime := #iUDT_VSUConfig.SwitchingTime;           // Write switching time from configuration to VFD interface
	        
	    END_REGION
	    
	    REGION 8.2 - Mode selection 
	        
	        #iqUDT_VSUInterface.Automatic :=
	        (#sx_AutomaticActive                                                            // Automatic started
	        OR #sx_Stopping                                                                 // stopping is activated
	        OR #sx_PositionAfterRef)                                                        // Go to default position
	        AND #iqUDT_VSUInterface.Referenced;                                            // and the drive is referenced
	        
	        #iqUDT_VSUInterface.Manual :=
	        #sx_ManualModeActive                                                            // Manual mode is started
	        // AND (#sx_CombinedJogUp                                                       // 12.06.24: CombinedJogUp and CombinedJogDown are commented because only manual mode is needed for VFD block
	        // OR #sx_CombinedJogDown)
	        AND #iqUDT_VSUInterface.Referenced;                                            // and the drive is referenced
	    END_REGION
	    
	    REGION 8.3 - Run enable
	        
	        #iqUDT_VSUInterface.RunEnabled :=                                              // Enable the positioning device to run
	        NOT #iqUDT_VSUInterface.InternalErrorVFD                                  // or there are errors in the VFD
	        AND NOT #iqUDT_VSUInterface.InternalErrorRIOPanel                              // or an internal error in the RIO panel occured                             
	        AND (#iqUDT_VSUInterface.Automatic
	        OR (#iqUDT_VSUInterface.Manual
	        AND (#sx_CombinedJogUp                                                          // If selected jog in positive direction 
	        OR #sx_CombinedJogDown))
	        OR #iqUDT_VSUInterface.GoReference);
	    END_REGION
	    
	    REGION 8.4 - Referencing VFD
	        
	        #sR_TRIG_GOReference(CLK := (#sx_AutomaticActive                                 // Refferencing in auto when 
	                             AND #sx_StartReceived)                                      // Start command received from system
	                             OR (#sx_ManualModeActive                                    // Manual Refferencing not in auto
	                             AND #iqUDT_VSUCommand.ReferenceRun)                        // Command form HMI to start referecing
	                             OR (#sx_ManualModeActive                                    // Manual Refferencing not in auto
	                             AND #ix_LCPRef));                                           // Command form LCP to start referecing
	        
	        #sR_TRIG_Referenced(CLK := #iqUDT_VSUInterface.Referenced);
	        
	        // Select reference travel and set signalling request prior to VSU movement 
	        IF #sR_TRIG_GOReference.Q                                                        // there is rising edge on referencing request bit 
	            
	        THEN
	            #iqUDT_VSUInterface.GoReference := TRUE;                                   // Activate the reference travel memory 
	            #iqUDT_EquipmentControl.Request.SignalingRequest := TRUE;                  // Request signaling TO control block before running to reference
	        END_IF;
	        
	        // Reference travel mode is active
	        // If signalling request is off set the reference command
	        // if the drive signals to be referenced, reset the command and HMI interface
	        
	        IF #iqUDT_VSUInterface.GoReference = TRUE                                      // The reference travel is activated  
	        THEN
	            // 1: Wait for end of signal request to start drive to do its refference run
	            IF NOT #iqUDT_EquipmentControl.Request.SignalingRequest                    // Request signaling TO control block before running to reference
	                AND NOT #sx_PositionAfterRef                                            // last step is active, prohibit starting again.
	            THEN
	                #iqUDT_VSUInterface.Reference_command := TRUE;                         // Reference command, VSU request to do reference run to positioning device
	                
	            END_IF;
	            
	            // 2: Drive did its refference run and is now at refference position
	            IF #sR_TRIG_Referenced.Q                                                     // If the drive is referenced 
	            THEN
	                #iqUDT_VSUInterface.Reference_command := FALSE;                        // Reset Reference command, VSU request to do reference run to positioning device 
	                #sx_PositionAfterRef := TRUE;                                           // Go to the default position 
	                #iqUDT_VSUInterface.PositionActual := 0;
	            END_IF;
	            
	            // 3: go to requested position after which the system can continue
	            IF #iqUDT_VSUInterface.PositionSetpoint = #iqUDT_VSUInterface.PositionActual   // The position is as requested
	                AND #sx_PositionAfterRef
	                
	            THEN
	                #sx_PositionAfterRef := FALSE;                                          // reset to go to the default position
	                #iqUDT_VSUInterface.GoReference := FALSE;                              // Reset the reference travel memory
	                
	            END_IF;
	        END_IF;
	    END_REGION
	END_REGION
	
	REGION 9 - Statistics
	    
	    // Down Time
	    
	    IF #sx_AutomaticActive                                                              // Automatic active
	        AND NOT #sx_Ready                                                                // Conveyor not ready
	        OR #iqUDT_EquipmentControl.Command.ResetData                                    // Reset statistics
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,              // Or reset statistics from control
	                        ix_Activate := #sx_AutomaticActive AND NOT #sx_Ready,                // VSU is stopped 
	                        ix_RTrigActivate := #sR_TRIG_DownTime.Q,                              // VSU is stopped triger 
	                        iqUDT_Statistics := #iqUDT_Statistics.DownTime);                // VSU is stopped statistics 
	    END_IF;
	    
	    // Up time
	    
	    IF #sx_AutomaticActive                              // Automatic active
	        AND #sx_Ready                                   // Ready active
	        OR #iqUDT_EquipmentControl.Command.ResetData    // Reset statistics
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,        // OR reset statistics from control
	                        ix_Activate := #sx_AutomaticActive AND #sx_Ready,                        // VSU is running 
	                        ix_RTrigActivate := #sR_TRIG_UpTime.Q,                              // VSU running trigger 
	                        iqUDT_Statistics := #iqUDT_Statistics.UpTime);                        // VSU running statistics
	        
	    END_IF;
	    
	    // Exit gap check
	    
	    #sR_TRIG_GapExit_Error(CLK := #sUDT_HMIStatus.Specific.ExitGapErr);               // Oneshot trigger error occurred
	    
	    IF #iqUDT_VSUInterface.ResetStatistics OR                                              // IF there is signal TO reset statistics from VSU interface 
	        #iqUDT_EquipmentControl.Command.ResetData OR                                       // Or there is signal to reset statistics from equipment control structure 
	        #sUDT_HMIStatus.Specific.ExitGapErr                                        // Or an exit gap check was detected 
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics OR                 // Reset statistics from HMI
	                        #iqUDT_EquipmentControl.Command.ResetData,                         // Or reset statistics from control
	                        ix_Activate := #sUDT_HMIStatus.Specific.ExitGapErr,        // Upper switch area error occurred
	                        ix_RTrigActivate := #sR_TRIG_GapExit_Error.Q,                          // Error trigger 
	                        iqUDT_Statistics := #iqUDT_Statistics.ExitGapErr);          // Statistics of VSU errors 
	        
	    END_IF;
	    
	    // Entry gap check
	    
	    #sR_TRIG_GapEntry_Error(CLK := #sUDT_HMIStatus.Specific.EntryGapErr);              // Oneshot trigger error occurred
	    
	    IF #iqUDT_VSUInterface.ResetStatistics OR                                              // IF there is signal TO reset statistics from VSU interface 
	        #iqUDT_EquipmentControl.Command.ResetData OR                                       // Or there is signal to reset statistics from equipment control structure 
	        #sUDT_HMIStatus.Specific.EntryGapErr                                        // Or an entry gap check was detected 
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics OR                 // Reset statistics from HMI
	                        #iqUDT_EquipmentControl.Command.ResetData,                         // Or reset statistics from control
	                        ix_Activate := #sUDT_HMIStatus.Specific.EntryGapErr,        // Upper switch area error occurred
	                        ix_RTrigActivate := #sR_TRIG_GapEntry_Error.Q,                         // Error trigger 
	                        iqUDT_Statistics := #iqUDT_Statistics.EntryGapErr);          // Statistics of VSU errors 
	        
	    END_IF;
	    
	    // Belt tear detection 1
	    
	    #sR_TRIG_BeltTear1(CLK := #sUDT_HMIStatus.Specific.BeltTear1Err);               // Oneshot trigger error occurred
	    
	    IF #iqUDT_VSUInterface.ResetStatistics OR                                              // IF there is signal TO reset statistics from VSU interface 
	        #iqUDT_EquipmentControl.Command.ResetData OR                                       // Or there is signal to reset statistics from equipment control structure 
	        #sUDT_HMIStatus.Specific.BeltTear1Err                                       // Or an upper switch area error occurred 
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics OR                 // Reset statistics from HMI
	                        #iqUDT_EquipmentControl.Command.ResetData,                         // Or reset statistics from control
	                        ix_Activate := #sUDT_HMIStatus.Specific.BeltTear1Err,       // Belt tear 1 was detected
	                        ix_RTrigActivate := #sR_TRIG_BeltTear1.Q,                           // Error trigger 
	                        iqUDT_Statistics := #iqUDT_Statistics.BeltTear1Err);         // Statistics of VSU errors 
	        
	    END_IF;
	    
	    // Belt tear detection 2
	    
	    #sR_TRIG_BeltTear2(CLK := #sUDT_HMIStatus.Specific.BeltTear2Err);              // Oneshot trigger error occurred
	    
	    IF #iqUDT_VSUInterface.ResetStatistics OR                                              // IF there is signal TO reset statistics from VSU interface 
	        #iqUDT_EquipmentControl.Command.ResetData OR                                  // Or there is signal to reset statistics from equipment control structure 
	        #sUDT_HMIStatus.Specific.BeltTear2Err                                       // Or an upper switch area error occurred 
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics OR                 // Reset statistics from HMI
	                        #iqUDT_EquipmentControl.Command.ResetData,                         // Or reset statistics from control
	                        ix_Activate := #sUDT_HMIStatus.Specific.BeltTear2Err,         // Belt tear 2 was detected
	                        ix_RTrigActivate := #sR_TRIG_BeltTear2.Q,                          // Error trigger 
	                        iqUDT_Statistics := #iqUDT_Statistics.BeltTear2Err);         // Statistics of VSU errors 
	        
	    END_IF;
	    
	    // Maintenace support 1 extracted
	    
	    #sR_TRIG_MaintSupport1Err(CLK := #sUDT_HMIStatus.Specific.MaintSupport1Err);              // Oneshot trigger error occurred
	    
	    IF #iqUDT_VSUInterface.ResetStatistics OR                                              // IF there is signal TO reset statistics from VSU interface 
	        #iqUDT_EquipmentControl.Command.ResetData OR                                  // Or there is signal to reset statistics from equipment control structure 
	        #sUDT_HMIStatus.Specific.MaintSupport1Err                                       // Maintenace support 1 extracted in automatic mode error occurred 
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics OR                 // Reset statistics from HMI
	                        #iqUDT_EquipmentControl.Command.ResetData,                         // Or reset statistics from control
	                        ix_Activate := #sUDT_HMIStatus.Specific.MaintSupport1Err,         // Maintenace support 1 extracted
	                        ix_RTrigActivate := #sR_TRIG_MaintSupport1Err.Q,                          // Error trigger 
	                        iqUDT_Statistics := #iqUDT_Statistics.MaintSupport1Err);         // Statistics of VSU errors 
	    END_IF;
	    
	    // Maintenace support 2 extracted
	    
	    #sR_TRIG_MaintSupport2Err(CLK := #sUDT_HMIStatus.Specific.MaintSupport2Err);              // Oneshot trigger error occurred
	    
	    IF #iqUDT_VSUInterface.ResetStatistics OR                                              // IF there is signal TO reset statistics from VSU interface 
	        #iqUDT_EquipmentControl.Command.ResetData OR                                  // Or there is signal to reset statistics from equipment control structure 
	        #sUDT_HMIStatus.Specific.MaintSupport2Err                                       // Maintenace support 2 extracted in automatic mode error occurred 
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics OR                 // Reset statistics from HMI
	                        #iqUDT_EquipmentControl.Command.ResetData,                         // Or reset statistics from control
	                        ix_Activate := #sUDT_HMIStatus.Specific.MaintSupport2Err,         // Maintenace support 2 extracted
	                        ix_RTrigActivate := #sR_TRIG_MaintSupport2Err.Q,                          // Error trigger 
	                        iqUDT_Statistics := #iqUDT_Statistics.MaintSupport2Err);         // Statistics of VSU errors 
	    END_IF;
	    
	    // Limit switch upper position overrun
	    
	    #sR_TRIG_UpperPositionErr(CLK := #sUDT_HMIStatus.Specific.UpperPositionErr);            // Oneshot trigger error occurred
	    
	    IF #iqUDT_VSUInterface.ResetStatistics OR                                              // IF there is signal TO reset statistics from VSU interface 
	        #iqUDT_EquipmentControl.Command.ResetData OR                                  // Or there is signal to reset statistics from equipment control structure 
	        #sUDT_HMIStatus.Specific.UpperPositionErr                                       // Upper position overrun error occurred 
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics OR                 // Reset statistics from HMI
	                        #iqUDT_EquipmentControl.Command.ResetData,                         // Or reset statistics from control
	                        ix_Activate := #sUDT_HMIStatus.Specific.UpperPositionErr,         // Limit switch upper position overrun
	                        ix_RTrigActivate := #sR_TRIG_UpperPositionErr.Q,                          // Error trigger 
	                        iqUDT_Statistics := #iqUDT_Statistics.UpperPositionErr);         // Statistics of VSU errors 
	    END_IF;
	    
	    // Limit switch lower position overrun
	    
	    #sR_TRIG_LowerPositionErr(CLK := #sUDT_HMIStatus.Specific.LowerPositionErr);            // Oneshot trigger error occurred
	    
	    IF #iqUDT_VSUInterface.ResetStatistics OR                                              // IF there is signal TO reset statistics from VSU interface 
	        #iqUDT_EquipmentControl.Command.ResetData OR                                  // Or there is signal to reset statistics from equipment control structure 
	        #sUDT_HMIStatus.Specific.LowerPositionErr                                       // lower position overrun error occurred 
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics OR                 // Reset statistics from HMI
	                        #iqUDT_EquipmentControl.Command.ResetData,                         // Or reset statistics from control
	                        ix_Activate := #sUDT_HMIStatus.Specific.LowerPositionErr,         // Limit switch lower position overrun
	                        ix_RTrigActivate := #sR_TRIG_LowerPositionErr.Q,                          // Error trigger 
	                        iqUDT_Statistics := #iqUDT_Statistics.LowerPositionErr);         // Statistics of VSU errors 
	    END_IF;
	    
	    // Safety door diagnostic fault
	    
	    #sR_TRIG_SafetyDoorErr(CLK := #sUDT_HMIStatus.Specific.SafetyDoorDownErr);
	    
	    IF #iqUDT_VSUInterface.ResetStatistics OR                                              // IF there is signal TO reset statistics from VSU interface 
	        #iqUDT_EquipmentControl.Command.ResetData OR                                  // Or there is signal to reset statistics from equipment control structure 
	        #sUDT_HMIStatus.Specific.SafetyDoorDownErr                                       // Safety door diagnostic fault
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics OR                 // Reset statistics from HMI
	                        #iqUDT_EquipmentControl.Command.ResetData,                         // Or reset statistics from control
	                        ix_Activate := #sUDT_HMIStatus.Specific.SafetyDoorDownErr,         // Safety door diagnostic fault
	                        ix_RTrigActivate := #sR_TRIG_SafetyDoorErr.Q,                          // Error trigger 
	                        iqUDT_Statistics := #iqUDT_Statistics.SafetyDoorErr);         // Statistics of VSU errors 
	    END_IF;
	    
	    // Direction error
	    
	    #sR_TRIG_Direction_Error(CLK := #sUDT_HMIStatus.Specific.DirectionErr);                 // Oneshot trigger error occurred
	    
	    IF #iqUDT_VSUInterface.ResetStatistics OR                                              // IF there is signal TO reset statistics from VSU interface 
	        #iqUDT_EquipmentControl.Command.ResetData OR                                       // Or there is signal to reset statistics from equipment control structure 
	        #sUDT_HMIStatus.Specific.DirectionErr                                              // Or an upper switch area error occurred 
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics OR                 // Reset statistics from HMI
	                        #iqUDT_EquipmentControl.Command.ResetData,                         // Or reset statistics from control
	                        ix_Activate := #sUDT_HMIStatus.Specific.DirectionErr,              // Upper switch area error occurred
	                        ix_RTrigActivate := #sR_TRIG_Direction_Error.Q,                      // Error trigger 
	                        iqUDT_Statistics := #iqUDT_Statistics.Direction_Error);                // Statistics of VSU errors 
	        
	    END_IF;
	    
	END_REGION
	
	REGION 10 - Status
	    
	    #sUDT_Status.Stopped := #sx_Ready AND NOT #sx_AutomaticActive AND NOT #sx_Stopping;    // stopped
	    #sUDT_Status.AutoON := #sx_AutomaticActive OR #sx_Stopping;                            // Auto On
	    #sUDT_Status.Halted := FALSE;                                                          // Halted
	    #sUDT_Status.Dieback := FALSE;                                                         // Die back
	    #sUDT_Status.Running := (#sx_UpRequest OR #sx_DownRequest) AND #sx_AutomaticActive;                              // Running
	    #sUDT_Status.ManualRun := #sx_ManualModeActive AND #sUDT_Status.Running;             // Manual run
	    #sUDT_Status.Manual := #sx_ManualModeActive;                                           // Manual
	    #sUDT_Status.EnergySave := FALSE;                                                      // Energy save active
	    #sUDT_Status.SafetyStop := NOT #ix_SafetyOk;                                           // Safety not ok
	    
	    //   Specific status
	    #sUDT_HMIStatus.Specific.ReferencedErr := NOT #iqUDT_VSUInterface.Referenced;
	    #sUDT_HMIStatus.Specific.LiftKeySwitchStop := #ix_LCPStop;
	    #sUDT_HMIStatus.Specific.MaintenanceSwitchUp := #ix_MaintenanceSwitchUp;
	    
	    IF #sUDT_StatusOld <> #sUDT_Status                                            // update on change
	    THEN
	        
	        // Set status to status number
	        #sUDT_HMIStatus.Status := 0;                                               // Initialise status number              
	        
	        IF #sUDT_Status.Running                                                    // Running
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Running;
	            
	        END_IF;
	        
	        IF #sUDT_Status.Stopped                                                    // Stopped
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Stopped;
	            
	        END_IF;
	        
	        IF #sUDT_Status.Dieback                                                    // Dieback
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Dieback;
	            
	        END_IF;
	        
	        IF #sUDT_Status.ManualRun                                                  // Manual run
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".ManualRun;
	            
	        END_IF;
	        
	        IF #sUDT_Status.Manual                                                     // Manual
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Manual;
	            
	        END_IF;
	        
	        IF #iqUDT_VSUInterface.InternalWarningVFD                                  // The VFD has an internal warning
	            OR #iqUDT_VSUInterface.InternalWarningRIOPanel                         // The RIO panel has an internal warning    
	            
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Warning;
	            
	        END_IF;
	        
	        IF #sUDT_HMIStatus.Specific.BeltTear1Err                           // Upper entrance PEC Jam error
	            OR #sUDT_HMIStatus.Specific.BeltTear2Err                       // Lower entrance PEC Jam error
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".PECJam;
	            
	        END_IF;
	        
	        IF #sUDT_HMIStatus.Specific.ReferencedErr                                // Refference error
	            OR #sUDT_HMIStatus.Specific.ExitGapErr                        // Upper limit switch error
	            OR #sUDT_HMIStatus.Specific.EntryGapErr                        // Lower limit switch error
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".VFDError;
	            
	        END_IF;
	        
	        IF #sUDT_HMIStatus.Specific.DirectionErr                                   // Direction error
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".OperationalError;
	            
	        END_IF;
	        
	        
	        IF #sUDT_HMIStatus.Specific.KeyswitchWrn                                  // Key switch error
	            OR #iqUDT_VSUInterface.InternalErrorVFD                                // The VFD has an internal error
	            OR #iqUDT_VSUInterface.InternalErrorRIOPanel                           // The RIO panel has an internal error
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Error;
	            
	        END_IF;
	        
	        
	        IF #sUDT_Status.SafetyStop                                                 // Safety stop
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".SafetyStop;
	            
	        END_IF;
	        
	        #qUDT_HMIStatus := #sUDT_HMIStatus;                                       // Copy status to output
	        #sUDT_StatusOld := #sUDT_Status;                                          // Copy status TO memory
	        #qUDT_Status := #sUDT_Status;                                             // Copy status to output
	    END_IF;
	    
	    #qUDT_HMIStatus.Specific.UpperPositionErr := #sx_ActualPositionUP;
	    #qUDT_HMIStatus.Specific.LowerPositionErr := #sx_ActualPositionDown;
	    
	END_REGION
	
	REGION 11 - Report to control block
	    
	    "FC_EquipmentReport"(iUDT_Status := #sUDT_Status,
	                         iqUDT_Control := #iqUDT_EquipmentControl);
	    
	END_REGION
END_FUNCTION_BLOCK

TYPE "UDT_WSRBufferState"
VERSION : 0.1
   STRUCT
      Destination : Int;
      BufferState1 : Struct
         BinRequest : Bool;
         BinSend : Bool;
         UpcomingBarcode : String[30];
         WaintingTime : Int;
      END_STRUCT;
      BufferState2 : Struct
         BinRequest : Bool;
         BinSend : Bool;
         UpcomingBarcode : String[30];
         WaintingTime : Int;
      END_STRUCT;
      BufferState3 : Struct
         BinRequest : Bool;
         BinSend : Bool;
         UpcomingBarcode : String[30];
         WaintingTime : Int;
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_WSRCommonStatus"
VERSION : 0.1
   STRUCT
      "010" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "020" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "030" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "040" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "041" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "050" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "060" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "070" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "080" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "110" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "120" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "130" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "140" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "141" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "150" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "160" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "170" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "180" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "210" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "220" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "230" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "240" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "241" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "250" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "260" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "270" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
   END_STRUCT;

END_TYPE

TYPE "UDT_WSRStatus"
VERSION : 0.1
   STRUCT
      "010" { S7_SetPoint := 'False'} : "UDT_StatusTC03";
      "020" { S7_SetPoint := 'False'} : "UDT_StatusTC13";
      "030" { S7_SetPoint := 'False'} : "UDT_StatusTC03";
      "040" { S7_SetPoint := 'False'} : "UDT_StatusTC07";
      "041" { S7_SetPoint := 'False'} : "UDT_StatusTC36";
      "050" { S7_SetPoint := 'False'} : "UDT_StatusTC03";
      "060" { S7_SetPoint := 'False'} : "UDT_StatusTC13";
      "070" { S7_SetPoint := 'False'} : "UDT_StatusTC03";
      "080" { S7_SetPoint := 'False'} : "UDT_StatusTC13";
      "110" { S7_SetPoint := 'False'} : "UDT_StatusTC03";
      "120" { S7_SetPoint := 'False'} : "UDT_StatusTC13";
      "130" { S7_SetPoint := 'False'} : "UDT_StatusTC03";
      "140" { S7_SetPoint := 'False'} : "UDT_StatusTC07";
      "141" { S7_SetPoint := 'False'} : "UDT_StatusTC36";
      "150" { S7_SetPoint := 'False'} : "UDT_StatusTC03";
      "160" { S7_SetPoint := 'False'} : "UDT_StatusTC13";
      "170" { S7_SetPoint := 'False'} : "UDT_StatusTC03";
      "180" { S7_SetPoint := 'False'} : "UDT_StatusTC12";
      "210" { S7_SetPoint := 'False'} : "UDT_StatusTC03";
      "220" { S7_SetPoint := 'False'} : "UDT_StatusTC13";
      "230" { S7_SetPoint := 'False'} : "UDT_StatusTC03";
      "240" { S7_SetPoint := 'False'} : "UDT_StatusTC02";
      "241" { S7_SetPoint := 'False'} : "UDT_StatusTC36";
      "250" { S7_SetPoint := 'False'} : "UDT_StatusTC03";
      "260" { S7_SetPoint := 'False'} : "UDT_StatusTC13";
      "270" { S7_SetPoint := 'False'} : "UDT_StatusTC03";
   END_STRUCT;

END_TYPE

TYPE "UDT_WSRConfiguration"
VERSION : 0.1
   STRUCT
      GlobalConfig : Struct
         LeftStationAvailable : Bool := TRUE;
         RightStationAvailable : Bool := TRUE;
         OperationTimeout : UDInt;
         DestinationEmpty : Int;
         DestinationPartialy : Int;
         GINRangeStart : Int;
         GINRangeEnd : Int;
         BinReleaseDistance : Int;
         BinOrderTimeout : Int;
      END_STRUCT;
      "010" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS : "UDT_PECUpdateConfiguration";
         MCO_M01 : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "020" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS : "UDT_PECUpdateConfiguration";
         MCO_M01 : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "030" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS : "UDT_PECUpdateConfiguration";
         MCO_M01 : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "040" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS : "UDT_PECConfiguration";
         MCO_M01 : "UDT_AixPlcFullControllerConfiguration";
         BladeStopEoS : "UDT_ValveConfiguration";
      END_STRUCT;
      "041" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         RightAngledTransfer : "UDT_RATConfiguration";
         MCO_M01 : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "050" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS : "UDT_PECUpdateConfiguration";
         MCO_M01 : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "060" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS : "UDT_PECUpdateConfiguration";
         MCO_M01 : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "070" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS : "UDT_PECUpdateConfiguration";
         MCO_M01 : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "080" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS : "UDT_PECUpdateConfiguration";
         MCO_M01 : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "110" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS : "UDT_PECUpdateConfiguration";
         MCO_M01 : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "120" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS : "UDT_PECUpdateConfiguration";
         MCO_M01 : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "130" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS : "UDT_PECUpdateConfiguration";
         MCO_M01 : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "140" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS : "UDT_PECConfiguration";
         MCO_M01 : "UDT_AixPlcFullControllerConfiguration";
         BladeStopEoS : "UDT_ValveConfiguration";
      END_STRUCT;
      "141" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         RightAngledTransfer : "UDT_RATConfiguration";
         MCO_M01 : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "150" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS : "UDT_PECUpdateConfiguration";
         MCO_M01 : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "160" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS : "UDT_PECUpdateConfiguration";
         MCO_M01 : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "170" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS : "UDT_PECUpdateConfiguration";
         MCO_M01 : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "180" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS : "UDT_PECConfiguration";
         MCO_M01 : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "210" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS : "UDT_PECUpdateConfiguration";
         MCO_M01 : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "220" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS : "UDT_PECUpdateConfiguration";
         MCO_M01 : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "230" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS : "UDT_PECUpdateConfiguration";
         MCO_M01 : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "240" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS : "UDT_PECConfiguration";
         MCO_M01 : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "241" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         RightAngledTransfer : "UDT_RATConfiguration";
         MCO_M01 : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "250" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS : "UDT_PECUpdateConfiguration";
         MCO_M01 : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "260" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS : "UDT_PECUpdateConfiguration";
         MCO_M01 : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "270" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         PEC_EoS : "UDT_PECUpdateConfiguration";
         MCO_M01 : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_CrossoverCommand"
VERSION : 0.1
   STRUCT
      ManualMode : Bool;   // Manual mode command from HMI
      ManualUp : Bool;   // Command to move devise up
      ManualDown : Bool;   // Command to move devise down
   END_STRUCT;

END_TYPE

TYPE "UDT_WSRHmiCommands"
VERSION : 0.1
   STRUCT
      "010" { S7_SetPoint := 'False'} : "UDT_HMICommandTCxx";
      "020" { S7_SetPoint := 'False'} : "UDT_HMICommandTCxx";
      "030" { S7_SetPoint := 'False'} : "UDT_HMICommandTCxx";
      "040" { S7_SetPoint := 'False'} : "UDT_HMICommandTC07";
      "041" : "UDT_HMICommandTC36";
      "050" : "UDT_HMICommandTCxx";
      "060" { S7_SetPoint := 'False'} : "UDT_HMICommandTCxx";
      "070" { S7_SetPoint := 'False'} : "UDT_HMICommandTCxx";
      "080" { S7_SetPoint := 'False'} : "UDT_HMICommandTCxx";
      "110" { S7_SetPoint := 'False'} : "UDT_HMICommandTCxx";
      "120" { S7_SetPoint := 'False'} : "UDT_HMICommandTCxx";
      "130" { S7_SetPoint := 'False'} : "UDT_HMICommandTCxx";
      "140" { S7_SetPoint := 'False'} : "UDT_HMICommandTC07";
      "141" : "UDT_HMICommandTC36";
      "150" { S7_SetPoint := 'False'} : "UDT_HMICommandTCxx";
      "160" { S7_SetPoint := 'False'} : "UDT_HMICommandTCxx";
      "170" { S7_SetPoint := 'False'} : "UDT_HMICommandTCxx";
      "180" { S7_SetPoint := 'False'} : "UDT_HMICommandTCxx";
      "210" { S7_SetPoint := 'False'} : "UDT_HMICommandTCxx";
      "220" { S7_SetPoint := 'False'} : "UDT_HMICommandTCxx";
      "230" { S7_SetPoint := 'False'} : "UDT_HMICommandTCxx";
      "240" { S7_SetPoint := 'False'} : "UDT_HMICommandTCxx";
      "241" : "UDT_HMICommandTC36";
      "250" { S7_SetPoint := 'False'} : "UDT_HMICommandTCxx";
      "260" { S7_SetPoint := 'False'} : "UDT_HMICommandTCxx";
      "270" { S7_SetPoint := 'False'} : "UDT_HMICommandTCxx";
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_Tracking"
TITLE = FB_Tracking
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 33
// END_ATTRIBUTES
//Function block to shift data in the tracking array.
   VAR_INPUT 
      iUDT_ConveyorCommonConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorCommonConfiguration";   // Conveyor common configuration
   END_VAR

   VAR_IN_OUT 
      iqa_TrackingData : Array[*] of Int;   // Tracking array
      iqUDT_ConveyorInterface : "UDT_ConveyorInterface";   // Conveyor interface
      iqUDT_HandshakeUp : "UDT_ConveyorHandshake";   // Upstream conveyor handshake
      iqUDT_Handshake : "UDT_ConveyorHandshake";   // Conveyor handshake
   END_VAR

   VAR 
      si_TrackingArrayLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Tracking array length
      si_TrackingArrayLowBound { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Tracking array lower bound
      sdi_TotalConvLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Number of tracking entries is equal to the conveyor length in cm
      si_Displacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Displacement
      si_ShiftDestination { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Pointer to the entry to start writing the tracking data
      si_ShiftOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Number of entries to be shifted and its direction
      sdi_GINInsertPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Position where GIN form upstream conveyor will be inserted
      sdi_GINExtractPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Position from which GIN will be moved to the downstream conveyor
      sx_InvalidTrackArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid tracking array size
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2019             MHS                                                     |
	|  All Rights Reserved         Larenweg 90                                             |
	|                              5234 KC 's-Hertogenbosch,                               |
	|                              Netherlands                                             |
	|                                                                                      |     
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L. Klar      | first release MHS TIA 15.1
	14/06/2019  | 0.2       | A.Nowak      | Replacement of instruction if for direct write into variable - Region 3 
	19/07/2019  | 0.5       | L.Klar       | Status handling changed
	24/07/2019  | 2.0       | L.Klar       | 2.0 MHS library release TIA 15.1
	23/08/2019  | 2.1       | L.Klar       | "UDT_ConveyorConfiguration" changed to "UDT_ConveyorCommonConfiguration", internal tracking error set instead of coil assigment. 
	10/09/2019  | 2.2       | L.Klar       | Comments changed, block optimized
	21/10/2019  | 2.3       | L.Klar       | Configuration UDT chanaged to input
	12/11/2019  | 3.0       | P.Majka      | 3.0 MHS library release TIA 15.1
	20/12/2019  | 3.1       | S. Deulkar   | Used configureation error bit to report to conveyor block 
	15/01/2020  | 3.2       | L.Klar       | Block adjusted to allow to transfer negative GIN numbers
	*)
	
	REGION 1 – Get the required number of entries
	    
	    // Number of entries is a conveyor length in cm
	    #sdi_TotalConvLength := (#iUDT_ConveyorCommonConfiguration.Length + #iUDT_ConveyorCommonConfiguration.LengthCorrection) / 10;
	    
	END_REGION
	
	REGION 2 – Number of tracking records validation
	    
	    // Tracking array dimensions
	    #si_TrackingArrayLen := "FC_GetNrOfArrayEl"(#iqa_TrackingData);
	    #si_TrackingArrayLowBound := DINT_TO_INT(LOWER_BOUND(ARR := #iqa_TrackingData, DIM := 1));
	    
	    // Check if the number of entries is exceeding the tracking array size
	    #sx_InvalidTrackArraySize := #si_TrackingArrayLen < #sdi_TotalConvLength + 2
	    OR #si_TrackingArrayLowBound <> 0;
	    
	END_REGION
	
	REGION 3 – Read the displacement
	    
	    #si_Displacement := #iqUDT_ConveyorInterface.Displacement;
	    
	END_REGION
	
	REGION 4 – Prepare tracking array pointers
	    
	    // A conveyor can run in forward and reverse direction
	    // Data will be shifted into tracking entry position 1 for both cases.
	    #si_ShiftDestination := 1;
	    
	    // If the direction is forward (positive displacement), entry 2 is taken as offset (shifts conveyor length from pos 2 in pos 1)
	    IF #si_Displacement > 0
	    THEN
	        
	        #si_ShiftOffset := 2;
	        #sdi_GINInsertPosition := #sdi_TotalConvLength + 1;
	        #sdi_GINExtractPosition := 1;
	        
	        // If the direction is reverse (negative displacement), entry 0 is taken as offset (shifts conveyor length from pos 0 in pos 1)
	    ELSE
	        
	        #si_ShiftOffset := 0;
	        #sdi_GINInsertPosition := 0;
	        #sdi_GINExtractPosition := #sdi_TotalConvLength;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 5 – Shift data
	    
	    // Data is shifted only if the conveyor is running (positive or negtive displacement)
	    WHILE #si_Displacement <> 0 DO
	        
	        // Conveyor running forward
	        IF (#si_Displacement > 0)
	        THEN
	            
	            // GIN is moved into the tracking array on GIN insert position if the number of positions in upstream conveyor handshake is available
	            // The number of positions to be shifted will be decremented
	            IF (#iqUDT_HandshakeUp.GIN <> 0
	                AND #iqUDT_HandshakeUp.NrOfPosToShift > 0)
	            THEN
	                
	                #iqa_TrackingData[#sdi_GINInsertPosition] := #iqUDT_HandshakeUp.GIN;
	                #iqUDT_HandshakeUp.NrOfPosToShift -= 1;
	                
	            ELSIF (#iqUDT_HandshakeUp.GIN <> 0
	                AND #iqUDT_HandshakeUp.NrOfPosToShift = 0)
	            THEN
	                
	                #iqa_TrackingData[#sdi_GINInsertPosition] := #iqUDT_HandshakeUp.GIN;
	                
	            END_IF;
	            
	            // Clear the downsteam handshake GIN if the number of positions to be shifted is 0
	            IF (#iqUDT_Handshake.GIN <> 0 AND #iqUDT_Handshake.NrOfPosToShift = 0)
	            THEN
	                
	                #iqUDT_Handshake.GIN := 0;
	                
	            END_IF;
	            
	            // GIN is moved into the handshake structure if the data is available at GIN extract position
	            // The number of positions will be incremented
	            IF (#iqa_TrackingData[#sdi_GINExtractPosition] <> 0)
	            THEN
	                
	                IF (#iqUDT_Handshake.GIN = 0)
	                THEN
	                    
	                    #iqUDT_Handshake.GIN := #iqa_TrackingData[#sdi_GINExtractPosition];
	                    #iqUDT_Handshake.NrOfPosToShift += 1;
	                    
	                ELSIF (#iqUDT_Handshake.GIN = #iqa_TrackingData[#sdi_GINExtractPosition])
	                THEN
	                    
	                    #iqUDT_Handshake.NrOfPosToShift += 1;
	                    
	                END_IF;
	                
	            END_IF;
	            
	            // Update displacement
	            #si_Displacement -= 1;
	            
	            // Conveyor running backward
	        ELSIF (#si_Displacement < 0)
	        THEN
	            
	            // GIN is moved into the tracking array on GIN insert position if the number of positions in downstream conveyor handshake is available
	            // The number of positions to be shifted will be decremented
	            IF (#iqUDT_Handshake.GIN <> 0
	                AND #iqUDT_Handshake.NrOfPosToShift > 0)
	            THEN
	                
	                #iqa_TrackingData[#sdi_GINInsertPosition] := #iqUDT_Handshake.GIN;
	                #iqUDT_Handshake.NrOfPosToShift -= 1;
	                
	                // In case of displacement greater than 1 and no positions to be shifted the GIN will be written to avoid gaps in data
	                // Writing will be stopped when GIN 0 is detected
	            ELSIF (#iqUDT_Handshake.GIN <> 0
	                AND #iqUDT_Handshake.NrOfPosToShift = 0)
	            THEN
	                
	                #iqa_TrackingData[#sdi_GINInsertPosition] := #iqUDT_Handshake.GIN;
	                
	            END_IF;
	            
	            // Clear the upstream handshake GIN if the number of positions to be shifted is 0
	            IF (#iqUDT_HandshakeUp.GIN <> 0 AND #iqUDT_HandshakeUp.NrOfPosToShift = 0)
	            THEN
	                
	                #iqUDT_HandshakeUp.GIN := 0;
	                
	            END_IF;
	            
	            // GIN is moved into the handshake structure if the data is available at GIN extract position
	            // The number of positions will be incremented
	            IF (#iqa_TrackingData[#sdi_GINExtractPosition] <> 0)
	            THEN
	                
	                IF (#iqUDT_HandshakeUp.GIN = 0)
	                THEN
	                    
	                    #iqUDT_HandshakeUp.GIN := #iqa_TrackingData[#sdi_GINExtractPosition];
	                    #iqUDT_HandshakeUp.NrOfPosToShift += 1;
	                    
	                    // In case of displacement greater than 1 and no positions to be shifted the GIN will be written to avoid gaps in data
	                    // Writing will be stopped when GIN 0 is detected    
	                ELSIF (#iqUDT_HandshakeUp.GIN = #iqa_TrackingData[#sdi_GINExtractPosition])
	                THEN
	                    
	                    #iqUDT_HandshakeUp.NrOfPosToShift += 1;
	                    
	                END_IF;
	                
	            END_IF;
	            
	            // Update displacement
	            #si_Displacement += 1;
	            
	        END_IF;
	        
	        // Shift the total conveyor length (number of tracking array entries) one cm up or down
	        MOVE_BLK(IN := #iqa_TrackingData[#si_ShiftOffset],
	                 COUNT := DINT_TO_ULINT(#sdi_TotalConvLength),
	                 OUT => #iqa_TrackingData[#si_ShiftDestination]);
	        
	        // Clear the GIN insert position
	        #iqa_TrackingData[#sdi_GINInsertPosition] := 0;
	        
	    END_WHILE;
	    
	END_REGION
	
	REGION 6 – Internal tracking error
	    
	    // The internal tracking error is set to stop the conveyor
	    // It is reset in the conveyor block
	    IF (#sx_InvalidTrackArraySize)
	    THEN
	        
	        #iqUDT_ConveyorInterface.ConfigurationError := TRUE;
	        
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MCOConveyLinxAixController"
TITLE = FB_VfdConveyLinxAixController
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Fortna
VERSION : 4.0
//Function to interface with ConveyLinx Aix Controller. On the controller is the possibility to connect two motors with two photoeyes and run the motors independent from each other. Also can each motor output used as a "normal" on/off output
//--V4.0 split the function to accomodate only 1 Motor
   VAR_INPUT 
      iUDT_AixConfig { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";   // Configuration structure
      iUDT_AixInputsModule { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // ConveyLinxAix inputs structure
      ii_MotorPositionId { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 1 = Master Left, 2 = Master Right, 11 Slave Left, 12 Slave Right
      ii_PositionSetpoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ix_24vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 24VDC is healthy
      ix_SimulationModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when Simulation mode active
      ix_StartPositioning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ix_ResetPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";   // HMI status structure for right motor
      qx_Positioned { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_IN_OUT 
      iqUDT_AixOutputsModule : "UDT_AixPlcFullOut";   // ConveyLinxAix nr.1 outputs structure
      iqUDT_ConveyorInterface : "UDT_ConveyorInterface";   // Conveyor interface structure Motor
      iqUDT_MCOStatistics : "UDT_VfdStatistics";   // Satistics structure
   END_VAR

   VAR 
      sFB_TimerOnOffDelayMCOSpeedFeedbackError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sFB_TimerOnOffDelayCheck24V { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // MHS "TimerOnOffDelay" - to delay time for MCO 24V contactor
      sFB_TimerOnOffDelayMCO { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sFB_TimerOnOffDelayMCOReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // MHS "TimerOnOffDelay" - to extend MCO reset
      sFB_TimerOnOffDelayMCORunningFeedbackError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sFB_TimerOnOffDelayAcceleration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";   // Detailed MCO status overview
      sUDT_PNDeviceController { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PNDevice";   // PN device info structure, Controller 1
      ss_PNPortsStatusController { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..8] of Bool;   // TRUE when specific port has an error, Controller
      sR_TRIG_PNSlaveNotOnline {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for trigger Profinet slave not online statistics
      sR_TRIG_PNSlaveError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for trigger Profinet slave error statistics
      sR_TRIG_MCOInternalError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for trigger Internal MCO Error statistics
      sR_TRIG_Running {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for trigger running motor
      sR_TRIG_CommunicationErrorMCO {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for trigger communication error
      sR_TRIG_ResetPosition {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge reset position
      sF_TRIG_RunFwd {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge for run forward signal
      sF_TRIG_RunRvs {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge for run reverse signal
      sr_ActualSpeedSetpoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Actual speed setpoint motor
      si_ActualSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Actual speed motor
      si_MotorAcceleration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Left motor acceleration
      si_MotorDeceleration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Motor deceleration
      si_LeftMotorPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Left motor actual position
      si_LastLeftMotorPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Left motor last cycle position
      si_RightMotorPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Right motor actual position
      si_LastRightMotorPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Right motor last cycle position
      sx_GeneralStatisticsReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset from or right conveyor
      sx_HardwareOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Hardware is ok
      sx_ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Commissioning: configuration error
      sx_PNDeviceHealthyControler { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet device is online and error free, Controller 1
      sx_AixAvailableControler { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Hardware of MCO is ok and no communication error with movikit, Controller 1
      sx_24vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 24VDC is healthy
      sx_ErrorActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block has an error
      sx_EnableOperation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Enable operation signal
      sx_RunForward { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start MCO forward
      sx_RunReverse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start MCO backward
      sx_SpeedSetpointReached { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Speed setpoint reached motor
      sx_SpeedFeedbackError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // motor speed feedback error
      sx_ErrorController { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Active if any erorr from controller 1 is active
      sx_ErrorCMotor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE if error from controler motor is active
      sx_Accelerating { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor acceleration
      sx_HardwareOk_Motor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor hardware ok
      sx_LeftServoHomeHasBeenSet { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Servo position has beeen reset to 0
      sx_RightServoHomeHasBeenSet { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Servo position has beeen reset to 0
      sb_MotorRotationStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // 0 Motor not running, Normal or Servo Braking Mode applied; 1 Motor running in CCW Direction; 2 Motor running in CW Direction; 3 Motor not running and Free Braking Mode applied
   END_VAR

   VAR CONSTANT 
      ci_MCOArea : UInt := 1;   // Area ID of IO Profinet devices
      ci_SubmoduleHWType : UInt := 5;   // Submodule HW_type number
      ci_TelegramSlot : UInt := 1;   // Free Siemens telegram slot
      ci_TelegramSubslot : UInt := 3;   // Free Siemens telegram subslot
      ci_NumberOfProfinetPorts : Int := 2;   // Number of Profinet ports in device
      cr_MaximumOutput : Real := 16384.0;   // PLC maximum output value
      cw_ActualSpeedMask : Word := 2#0011_1111_1111_1111;   // Mask to get the speed from the profinet MotorActualSpeed Word
      cudi_ExtendedResetTime : UDInt := 500;   // Extending the reset puls
      cudi_HardwareCheckDelay : UDInt := 2000;   // Delay to enable hardware to start up, checking will start after this time
      cudi_FeedbackErrorDelay : UDInt := 10000;   // Maximum delaytime deviation from setpoint is allowed
      cudi_TimeOffsetSpeedmonitoring : UDInt := 2000;   // Additional time
      cudi_HeartbeatDelay : UDInt := 5000;   // Maximum dely between heartbeat
      ci_Master_Left : Int := 1;
      ci_Master_Right : Int := 2;
      ci_Slave_Left : Int := 11;
      ci_Slave_Right : Int := 12;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                       
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	03/01/2022  | 1.0       | N.Kadam       | First release MHSE TIA 16.0
	24/03/2022  | 1.1       | M.Piela       | Bug fix, adding running feedback error
	05/05/2022  | 1.2       | M.Piela       | Status update
	31/05/2022  | 1.3       | M.Piela       | Ramp up/down calculation fix
	21/07/2022  | 1.4       | M.Piela       | Prevent motor to go below the minimum speed
	29/07/2022  | 1.5       | M.Piela       | Status update, add hardware ok to the profinet checking
	01/08/2022  | 1.6       | M.Piela       | Add Hardware ok to reset internal error
	01/08/2022  | 1.7       | G.Vlooswijk   | Fix to make it possible to run 1 of the 2 motors
	                                        | Check setpoint instead of sx_EnableOperation for Feedback Error check
	                                        | Removed if statement i_UDT_Ai2Config.DirectionReversal, speed from controller always positive
	06/08/2022  | 1.8       | G.Vlooswijk   | Removed minimal speedsetpoint
	05/07/2023  | 1.9       | F.Baten       | Complete separation of 2 motors
	13/09/2023  | 4.0       | F.Baten       | Reorganised structure and took out unused symbolics
	                                        | Status as 1 controller with 2 seperate controlled motors
	02/05/2024  | 5.0       | I.Ajram       | Split the function to accomodate only 1 Motor, added an input to indicate which motor to control
	08/05/2024  | 5.1       | S.Nieswiec    | qUDT_AixOutputsModule move to in/out variables, name changed to iqUDT_AixOutputsModule
	08/05/2024  | 5.2       | K. Pokorski   | Add displacement calculation
	13/05/2024  | 5.3       | K. Pokorski   | Add roller ratio
	08/06/2024  | 5.4       | S.Nieswiec    | Fixed servo delta calculation (went back to previous functioning version), adjusted region numbering
	                                        | displacement was negative on some conveyors while positive on others
	21/06/2024  | 5.5       | I.Ajram       | Added Master / Slave Mod, Slave is used when one conveyor is controlling more than 1 MCO, the rest will act/ be configured as slaves
	*)
	
	REGION 1 - Get Device Profinet information
	    
	    //Get Device Profinet name, Controller 
	    "FC_GetDevicePN"(is_PNDeviceName := #iUDT_AixConfig.AixContrlPNDeviceName,
	                     ix_SimulationModeActive := #ix_SimulationModeActive,
	                     iqUDT_PND := #sUDT_PNDeviceController);
	    
	    //Get number of ports, Controller 
	    "FC_GetPNPortStatus"(ii_NumberOfPorts := #ci_NumberOfProfinetPorts,
	                         iUDT_DevicePNInfo := #sUDT_PNDeviceController,
	                         qa_PortFault => #ss_PNPortsStatusController);
	    
	END_REGION
	
	REGION 2 - Reset errors
	    
	    
	    REGION 2.1 - Motor
	        
	        // Reset errors when InternalErrorReset is given
	        IF #iqUDT_ConveyorInterface.InternalErrorReset OR (NOT #iqUDT_ConveyorInterface.HardwareOk AND #sUDT_HMIStatus.PNSlaveNotOnline)
	        THEN
	            #sUDT_HMIStatus.PNSlaveNotOnline := FALSE;
	            #sUDT_HMIStatus.PNSlaveError := FALSE;
	            #sUDT_HMIStatus.InternalError := FALSE;
	            #sUDT_HMIStatus.PNSlaveWarning := FALSE;
	            #sUDT_HMIStatus.SpeedFeedbackError := FALSE;
	            #sx_SpeedFeedbackError := FALSE;
	            #sx_ErrorCMotor := FALSE;
	            #sUDT_HMIStatus.MotorStatus.Overheat := FALSE;
	            #sUDT_HMIStatus.MotorStatus.MaxTorque := FALSE;
	            #sUDT_HMIStatus.MotorStatus.ShortCircuit := FALSE;
	            #sUDT_HMIStatus.MotorStatus.MotorNotConnected := FALSE;
	            #sUDT_HMIStatus.MotorStatus.Overload := FALSE;
	            #sUDT_HMIStatus.MotorStatus.Stalled := FALSE;
	            #sUDT_HMIStatus.MotorStatus.BadHall := FALSE;
	            #sUDT_HMIStatus.MotorStatus.BoardOverheat := FALSE;
	            #sUDT_HMIStatus.MotorStatus.OverVoltage := FALSE;
	            #sUDT_HMIStatus.MotorStatus.LowVoltage := FALSE;
	            #iqUDT_ConveyorInterface.InternalErrorVFD := FALSE;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 2.2 - Reset pulse
	        // Create extended pulse for MCO Reset
	        #sFB_TimerOnOffDelayMCOReset(iudi_OnDelayTime := #cudi_ExtendedResetTime,
	                                     iudi_OffDelayTime := 0,
	                                     ix_SignalToDelay := #iqUDT_AixOutputsModule.ClearMotorError = 1,
	                                     ix_Enable := TRUE);
	        // set the reset signal directly when reset is active
	        IF #iqUDT_ConveyorInterface.InternalErrorReset THEN
	            #iqUDT_AixOutputsModule.ClearMotorError := 1;
	        END_IF;
	        
	        // Reset the ClearMotorError after 500[ms] pulse
	        IF #sFB_TimerOnOffDelayMCOReset.qx_DelayedSignal
	        THEN
	            #iqUDT_AixOutputsModule.ClearMotorError := 0;
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 3 - Hardware checks
	    
	    // Hardware will only be available after the delay, so the device has time for the initialisation
	    #sFB_TimerOnOffDelayCheck24V(iudi_OnDelayTime := #cudi_HardwareCheckDelay,
	                                 ix_SignalToDelay := #ix_24vOk);
	    
	    #sx_24vOk := #sFB_TimerOnOffDelayCheck24V.qx_DelayedSignal;
	    
	    #sx_HardwareOk_Motor := #iqUDT_ConveyorInterface.HardwareOk AND #iUDT_AixConfig.Motor.MotorExist;
	    
	    #sx_HardwareOK := NOT #ix_SimulationModeActive
	    AND #sx_24vOk
	    AND (#sx_HardwareOk_Motor OR NOT #iUDT_AixConfig.Motor.MotorExist)
	    AND (#ss_PNPortsStatusController[1] OR #ss_PNPortsStatusController[2])
	    AND #iqUDT_ConveyorInterface.HardwareOk;
	    
	    
	    // Check if PN device is online
	    IF NOT "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDeviceController.PNNetworknumber].DeviceStatus[#sUDT_PNDeviceController.PNDeviceNumber].DeviceState.Exist
	        AND #sx_HardwareOK
	    THEN
	        #sUDT_HMIStatus.PNSlaveNotOnline := TRUE;
	    END_IF;
	    
	    // Check IF PN ports are healthy 
	    IF #ss_PNPortsStatusController[1] XOR #ss_PNPortsStatusController[2]
	        
	    THEN
	        #sUDT_HMIStatus.PNSlaveWarning := TRUE;
	    END_IF;
	    
	    // Check if PN device has an error
	    IF "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDeviceController.PNNetworknumber].DeviceStatus[#sUDT_PNDeviceController.PNDeviceNumber].DeviceState.Error
	        AND #sx_HardwareOK
	        AND NOT #sUDT_HMIStatus.PNSlaveWarning
	    THEN
	        #sUDT_HMIStatus.PNSlaveError := TRUE;
	    END_IF;
	    
	    // Set bit when PN device is healthy (online and no error)
	    #sx_PNDeviceHealthyControler := NOT #sUDT_HMIStatus.PNSlaveNotOnline
	    AND NOT #sUDT_HMIStatus.PNSlaveError
	    AND #sUDT_PNDeviceController.PNDeviceFound
	    AND #sx_24vOk;
	    
	    // Set hardware available bit when all conditions are met
	    #sx_AixAvailableControler := (#sx_24vOk
	    AND #sx_PNDeviceHealthyControler
	    AND (#sx_HardwareOk_Motor OR NOT #iUDT_AixConfig.Motor.MotorExist))
	    OR #ix_SimulationModeActive;
	    
	    // Check communication (heartbeat)
	    #sFB_TimerOnOffDelayMCO(iudi_OnDelayTime := #cudi_HeartbeatDelay,
	                            ix_SignalToDelay := NOT #iUDT_AixInputsModule.AllSensorPortInputs.Heartbeat);
	    
	    // Set error when MoviKit communication is not available
	    IF #sFB_TimerOnOffDelayMCO.qx_DelayedSignal AND #sx_HardwareOK
	    THEN
	        
	        #sUDT_HMIStatus.CommunicationErrorVFD := TRUE;
	        
	    END_IF;
	END_REGION
	
	REGION 4 - Check errors and warnings 
	    REGION 4.1 - Error from controller for right motor 
	        IF #ii_MotorPositionId = #ci_Master_Right OR #ii_MotorPositionId = #ci_Slave_Right THEN
	            //Write errors to UDT_Status
	            IF #iUDT_AixInputsModule.RightMotorDiagnostic.Overheat
	            THEN
	                #sUDT_HMIStatus.MotorStatus.Overheat := TRUE;
	            END_IF;
	            
	            #sUDT_HMIStatus.MotorStatus.MaxTorque := #iUDT_AixInputsModule.RightMotorDiagnostic.MaxTorque;
	            
	            IF #iUDT_AixInputsModule.RightMotorDiagnostic.ShortCircuit
	            THEN
	                #sUDT_HMIStatus.MotorStatus.ShortCircuit := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModule.RightMotorDiagnostic.MotorNotConnected
	            THEN
	                #sUDT_HMIStatus.MotorStatus.MotorNotConnected := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModule.RightMotorDiagnostic.Overload
	            THEN
	                #sUDT_HMIStatus.MotorStatus.Overload := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModule.RightMotorDiagnostic.Stalled
	            THEN
	                #sUDT_HMIStatus.MotorStatus.Stalled := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModule.RightMotorDiagnostic.BadHall
	            THEN
	                #sUDT_HMIStatus.MotorStatus.BadHall := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModule.RightMotorDiagnostic.BoardOverheat
	            THEN
	                #sUDT_HMIStatus.MotorStatus.BoardOverheat := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModule.RightMotorDiagnostic.OverVoltage
	            THEN
	                #sUDT_HMIStatus.MotorStatus.OverVoltage := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModule.RightMotorDiagnostic.LowVoltage
	            THEN
	                #sUDT_HMIStatus.MotorStatus.LowVoltage := TRUE;
	            END_IF;
	            
	        END_IF;
	    END_REGION
	    
	    REGION 4.2 - Error from controller for left motor             
	        IF #ii_MotorPositionId = #ci_Master_Left OR #ii_MotorPositionId = #ci_Slave_Left THEN
	            //Write errors to UDT_Status
	            IF #iUDT_AixInputsModule.LeftMotorDiagnostic.Overheat
	            THEN
	                #sUDT_HMIStatus.MotorStatus.Overheat := TRUE;
	            END_IF;
	            
	            #sUDT_HMIStatus.MotorStatus.MaxTorque := #iUDT_AixInputsModule.LeftMotorDiagnostic.MaxTorque;
	            
	            IF #iUDT_AixInputsModule.LeftMotorDiagnostic.ShortCircuit
	            THEN
	                #sUDT_HMIStatus.MotorStatus.ShortCircuit := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModule.LeftMotorDiagnostic.MotorNotConnected
	            THEN
	                #sUDT_HMIStatus.MotorStatus.MotorNotConnected := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModule.LeftMotorDiagnostic.Overload
	            THEN
	                #sUDT_HMIStatus.MotorStatus.Overload := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModule.LeftMotorDiagnostic.Stalled
	            THEN
	                #sUDT_HMIStatus.MotorStatus.Stalled := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModule.LeftMotorDiagnostic.BadHall
	            THEN
	                #sUDT_HMIStatus.MotorStatus.BadHall := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModule.LeftMotorDiagnostic.BoardOverheat
	            THEN
	                #sUDT_HMIStatus.MotorStatus.BoardOverheat := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModule.LeftMotorDiagnostic.OverVoltage
	            THEN
	                #sUDT_HMIStatus.MotorStatus.OverVoltage := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModule.LeftMotorDiagnostic.LowVoltage
	            THEN
	                #sUDT_HMIStatus.MotorStatus.LowVoltage := TRUE;
	            END_IF;
	        END_IF;
	    END_REGION
	    
	    REGION 4.3 - Collective Error
	        //If any error from controller motor ocursed then set error to TRUE
	        IF #iUDT_AixConfig.Motor.MotorExist
	        THEN
	            #sx_ErrorCMotor := #sUDT_HMIStatus.MotorStatus.Overheat OR
	            // #sUDT_HMIStatus.MotorError.MaxTorque OR
	            #sUDT_HMIStatus.MotorStatus.ShortCircuit OR
	            #sUDT_HMIStatus.MotorStatus.MotorNotConnected OR
	            #sUDT_HMIStatus.MotorStatus.Overload OR
	            #sUDT_HMIStatus.MotorStatus.Stalled OR
	            #sUDT_HMIStatus.MotorStatus.BadHall OR
	            #sUDT_HMIStatus.MotorStatus.BoardOverheat OR
	            #sUDT_HMIStatus.MotorStatus.OverVoltage OR
	            #sUDT_HMIStatus.MotorStatus.LowVoltage OR
	            #sUDT_HMIStatus.SpeedFeedbackError OR
	            #sUDT_HMIStatus.PNSlaveNotOnline OR
	            #sUDT_HMIStatus.PNSlaveError;
	        END_IF;
	    END_REGION
	    
	    REGION 4.4 - Controller general
	        
	        // Error Controller is two drives combined 
	        #sx_ErrorController :=
	        #iUDT_AixInputsModule.ConveyStopStatus.StopActiveLostConn OR
	        #iUDT_AixInputsModule.ConveyStopStatus.StopActiveLostPLC OR
	        #sx_ErrorCMotor OR
	        FALSE;
	        
	        // Check if a Controller has an error
	        #sx_ErrorActive := (#sx_ErrorController AND #iUDT_AixConfig.Motor.MotorExist)
	        OR #sFB_TimerOnOffDelayMCORunningFeedbackError.qx_DelayedSignal
	        OR #sFB_TimerOnOffDelayMCOSpeedFeedbackError.qx_DelayedSignal;
	        
	        // Internal error 
	        #sUDT_HMIStatus.InternalError := #sx_AixAvailableControler AND #sx_ErrorController;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 5 - Check if configuration is ok for commissioning purposes
	    
	    IF (
	        #iUDT_AixConfig.Motor.MotorExist                            // Check only if motor exists
	        AND (#iUDT_AixConfig.Motor.RampUpTime > 0)                  // If ramp up time is greater than 0
	        AND (#iUDT_AixConfig.Motor.RampDownTime > 0)                // and ramp down time is greater than 0
	        )
	        AND
	        (
	        #sUDT_PNDeviceController.PNDeviceFound
	        OR NOT #iUDT_AixConfig.Motor.MotorExist                       // and device found in PN structure
	        OR #ix_SimulationModeActive                                 // or simulation mode is active
	        )
	    THEN
	        #sx_ConfigurationError := FALSE;                                // Reset configuration error
	    ELSE
	        #sx_ConfigurationError := TRUE;                                 // Set configuration error
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Prepare output data for Controller
	    
	    REGION 6.1 - Set direction for motor
	        
	        // If Run forward is requested, set direction to forward
	        IF #iqUDT_ConveyorInterface.RunFwd
	            AND #iUDT_AixConfig.Motor.InterlockFwd
	        THEN
	            #sx_RunForward := TRUE;
	            #sx_RunReverse := FALSE;
	        END_IF;
	        
	        // If Run reverse is requested, set direction into reverse
	        IF #iqUDT_ConveyorInterface.RunRvs
	            AND #iUDT_AixConfig.Motor.InterlockRvs
	        THEN
	            #sx_RunReverse := TRUE;
	            #sx_RunForward := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    
	    REGION 6.3 - Stopping motor
	        
	        // Create trigger when direction signal falling
	        #sF_TRIG_RunFwd(CLK := #iqUDT_ConveyorInterface.RunFwd);
	        #sF_TRIG_RunRvs(CLK := #iqUDT_ConveyorInterface.RunRvs);
	        
	        // When no run signal is given the controllers should stop
	        IF (NOT #iqUDT_ConveyorInterface.RunRvs AND NOT #iqUDT_ConveyorInterface.RunFwd)
	            OR (#iqUDT_ConveyorInterface.RunRvs AND #iqUDT_ConveyorInterface.RunFwd)
	            OR (#sF_TRIG_RunRvs.Q)
	            OR (#sF_TRIG_RunFwd.Q)
	            OR #sx_ErrorActive
	        THEN
	            #sx_RunReverse := FALSE;
	            #sx_RunForward := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 6.5 - Check for enable operation signal
	        
	        //Enable operation if there is no error active and there is an given direction
	        #sx_EnableOperation := NOT #sx_ErrorActive
	        AND NOT #sx_ConfigurationError
	        AND (#sx_RunForward OR #sx_RunReverse);
	    END_REGION
	    
	    REGION 6.6 - Calculate acceleration and deceleration values
	        
	        //Motor
	        //Recalculating Acceleration (from ms to mm)
	        #si_MotorAcceleration := REAL_TO_INT((INT_TO_REAL(#iqUDT_ConveyorInterface.SpeedSetpoint) * #iUDT_AixConfig.Motor.Ratio / 2) * (UDINT_TO_REAL(#iUDT_AixConfig.Motor.RampUpTime) / 1000));
	        
	        //Recalculating Deceleration (from ms to mm) 
	        #si_MotorDeceleration := REAL_TO_INT((INT_TO_REAL(#iqUDT_ConveyorInterface.SpeedSetpoint) * #iUDT_AixConfig.Motor.Ratio / 2) * (UDINT_TO_REAL(#iUDT_AixConfig.Motor.RampDownTime) / 1000));
	        
	    END_REGION
	    
	END_REGION
	
	REGION 7 - Write outputs to controller  
	    // Clear speed setpoint when no run request or above direction request or is configuration error
	    IF #sx_EnableOperation
	    THEN
	        #sr_ActualSpeedSetpoint := INT_TO_REAL(#iqUDT_ConveyorInterface.SpeedSetpoint) / #iUDT_AixConfig.Motor.Ratio;
	    ELSE
	        #sr_ActualSpeedSetpoint := 0;
	    END_IF;
	    
	    REGION 7.1 - Controller Left motor
	        
	        IF #ii_MotorPositionId = #ci_Master_Left OR #ii_MotorPositionId = #ci_Slave_Left THEN
	            //Seting up speed for Left motor
	            #iqUDT_AixOutputsModule.LeftSetMotorSpeed := REAL_TO_INT(#sr_ActualSpeedSetpoint);
	            IF #iqUDT_AixOutputsModule.LeftSetMotorSpeed > #cr_MaximumOutput
	            THEN
	                // if actual value is greater than maximmu output value then write maximmu output value
	                #iqUDT_AixOutputsModule.LeftSetMotorSpeed := REAL_TO_INT(#cr_MaximumOutput);
	            END_IF;
	            
	            //Check if motor is in use, if yes set parameters from conveyor to the controller and motor
	            IF #iUDT_AixConfig.Motor.MotorExist
	            THEN
	                //Setting up run bit, acceleration, deceleration
	                #iqUDT_AixOutputsModule.LeftMotorControl.Run := #sx_EnableOperation
	                AND (#iqUDT_ConveyorInterface.RunFwd OR #iqUDT_ConveyorInterface.RunRvs);
	                
	                // Position setpoint
	                #iqUDT_AixOutputsModule.ServoControlDistanceLeft := #ii_PositionSetpoint;
	                
	                //Start positioning
	                #iqUDT_AixOutputsModule.ServoControlCommandLeft.%X1 := #ix_StartPositioning
	                AND #sx_EnableOperation
	                AND (#iqUDT_ConveyorInterface.RunFwd OR #iqUDT_ConveyorInterface.RunRvs);
	                
	                // Reset position
	                #sR_TRIG_ResetPosition(CLK := #ix_ResetPosition);
	                
	                // Reset position after every operation
	                IF #sR_TRIG_ResetPosition.Q THEN
	                    
	                    #iqUDT_AixOutputsModule.ServoControlCommandLeft.%X0 := TRUE;
	                    
	                END_IF;
	                
	                // End homing procedure when motor is reset
	                IF #iUDT_AixInputsModule.ServoStatusLeft.%X1 THEN
	                    
	                    #iqUDT_AixOutputsModule.ServoControlCommandLeft.%X0 := FALSE;
	                    
	                END_IF;
	                
	                
	                #iqUDT_AixOutputsModule.LeftSetMotorAccel := #si_MotorAcceleration;
	                #iqUDT_AixOutputsModule.LeftSetMotorDeccel := #si_MotorDeceleration;
	                
	                //Setting direction
	                IF (#sx_RunReverse AND NOT #iUDT_AixConfig.Motor.DirectionReversal)
	                    OR (#sx_RunForward AND #iUDT_AixConfig.Motor.DirectionReversal)
	                THEN
	                    #iqUDT_AixOutputsModule.LeftMotorControl.MotorDirection := 1;
	                ELSE
	                    #iqUDT_AixOutputsModule.LeftMotorControl.MotorDirection := 0;
	                END_IF;
	            ELSE
	                #iqUDT_AixOutputsModule.LeftMotorControl.Run := FALSE;
	            END_IF;
	        END_IF;
	    END_REGION
	    
	    REGION 7.2 - Controller right motor
	        IF #ii_MotorPositionId = #ci_Master_Right OR #ii_MotorPositionId = #ci_Slave_Right THEN
	            //Seting up speed for Right motor
	            #iqUDT_AixOutputsModule.RightSetMotorSpeed := REAL_TO_INT(#sr_ActualSpeedSetpoint);
	            IF #iqUDT_AixOutputsModule.RightSetMotorSpeed > #cr_MaximumOutput
	            THEN
	                // if actual value is greater than maximmu output value then write maximmu output value
	                #iqUDT_AixOutputsModule.RightSetMotorSpeed := REAL_TO_INT(#cr_MaximumOutput);
	            END_IF;
	            
	            //Check if motor is in use, if yes set parameters from conveyor to the controller and motor
	            IF #iUDT_AixConfig.Motor.MotorExist
	            THEN
	                //Setting up run bit, acceleration, deceleration
	                #iqUDT_AixOutputsModule.RightMotorControl.Run := #sx_EnableOperation
	                AND (#iqUDT_ConveyorInterface.RunFwd OR #iqUDT_ConveyorInterface.RunRvs);
	                
	                // Position setpoint
	                #iqUDT_AixOutputsModule.ServoControlDistanceRight := #ii_PositionSetpoint;
	                
	                //Start positioning
	                #iqUDT_AixOutputsModule.ServoControlCommandRight.%X1 := #ix_StartPositioning
	                AND #sx_EnableOperation
	                AND (#iqUDT_ConveyorInterface.RunFwd OR #iqUDT_ConveyorInterface.RunRvs);
	                
	                // Reset position
	                #sR_TRIG_ResetPosition(CLK := #ix_ResetPosition);
	                
	                // Reset position after every operation
	                IF #sR_TRIG_ResetPosition.Q THEN
	                    
	                    #iqUDT_AixOutputsModule.ServoControlCommandRight.%X0 := TRUE;
	                    
	                END_IF;
	                
	                // End homing procedure when motor is reset
	                IF #iUDT_AixInputsModule.ServoStatusRight.%X1 THEN
	                    
	                    #iqUDT_AixOutputsModule.ServoControlCommandRight.%X0 := FALSE;
	                    
	                END_IF;
	                
	                
	                #iqUDT_AixOutputsModule.RightSetMotorAccel := #si_MotorAcceleration;
	                #iqUDT_AixOutputsModule.RightSetMotorDeccel := #si_MotorDeceleration;
	                
	                //Setting direction
	                IF (#sx_RunReverse AND NOT #iUDT_AixConfig.Motor.DirectionReversal)
	                    OR (#sx_RunForward AND #iUDT_AixConfig.Motor.DirectionReversal)
	                THEN
	                    #iqUDT_AixOutputsModule.RightMotorControl.MotorDirection := 1;
	                ELSE
	                    #iqUDT_AixOutputsModule.RightMotorControl.MotorDirection := 0;
	                END_IF;
	            ELSE
	                #iqUDT_AixOutputsModule.RightMotorControl.Run := FALSE;
	            END_IF;
	        END_IF;
	    END_REGION
	    
	END_REGION
	
	REGION 8 - Reading actual speed
	    
	    REGION 8.1 - Left Motor
	        IF #ii_MotorPositionId = #ci_Master_Left OR #ii_MotorPositionId = #ci_Slave_Left THEN
	            //When motors are in constant speed use motor actual speed
	            IF #iUDT_AixConfig.Motor.MotorExist
	            THEN
	                #si_ActualSpeed := REAL_TO_INT(INT_TO_REAL(WORD_TO_INT(#iUDT_AixInputsModule.LeftMotorActualSpeed & #cw_ActualSpeedMask)) * #iUDT_AixConfig.Motor.Ratio);
	            ELSE
	                #si_ActualSpeed := 0;
	            END_IF;
	        END_IF;
	    END_REGION
	    
	    REGION 8.2 - Right Motor
	        IF #ii_MotorPositionId = #ci_Master_Right OR #ii_MotorPositionId = #ci_Slave_Right THEN
	            //When motors are in constant speed use motor actual speed
	            IF #iUDT_AixConfig.Motor.MotorExist
	            THEN
	                #si_ActualSpeed := REAL_TO_INT(INT_TO_REAL(WORD_TO_INT(#iUDT_AixInputsModule.RightMotorActualSpeed & #cw_ActualSpeedMask)) * #iUDT_AixConfig.Motor.Ratio);
	            ELSE
	                #si_ActualSpeed := 0;
	            END_IF;
	        END_IF;
	    END_REGION
	    
	    REGION 8.3 - Calculation
	        //Actual speed is in mm/s 
	        //Sets error signal if an motor is running for a longer time with a diferent speed than speed setpoint but after a certain time 
	        #sFB_TimerOnOffDelayMCORunningFeedbackError(iudi_OnDelayTime := #cudi_FeedbackErrorDelay,
	                                                    ix_SignalToDelay := #sr_ActualSpeedSetpoint <> 0.0 AND NOT (#si_ActualSpeed <> 0));
	        
	        //The motor should start running after specific time. If not the MCORunningFeedback error occured
	        #sFB_TimerOnOffDelayMCOSpeedFeedbackError(iudi_OnDelayTime := #cudi_FeedbackErrorDelay,
	                                                  ix_SignalToDelay := #sx_SpeedFeedbackError);
	        
	        IF #sFB_TimerOnOffDelayMCORunningFeedbackError.qx_DelayedSignal OR #sFB_TimerOnOffDelayMCOSpeedFeedbackError.qx_DelayedSignal
	        THEN
	            #sUDT_HMIStatus.SpeedFeedbackError := TRUE;
	        END_IF;
	        
	        //Sets signal for the time in which the motors are accelerating
	        #sFB_TimerOnOffDelayAcceleration(iudi_OnDelayTime := 0,
	                                         iudi_OffDelayTime := #iUDT_AixConfig.Motor.RampUpTime + #cudi_TimeOffsetSpeedmonitoring,
	                                         ix_SignalToDelay := #sR_TRIG_Running.Q,
	                                         ix_Enable := TRUE,
	                                         qx_DelayedSignal => #sx_Accelerating);
	        
	        
	        //If conveyor is running and runs forwad or backwards and is not accelerating, when any motor is running at a lower/greater speed than set speed then set an error
	        IF #iqUDT_ConveyorInterface.VFDRunning AND (#iqUDT_ConveyorInterface.RunFwd OR #iqUDT_ConveyorInterface.RunRvs) AND NOT #sx_Accelerating
	        THEN
	            //Check if the difference betwen acctual speed and set speed is bigger than deviation then set error
	            #sx_SpeedFeedbackError := #iUDT_AixConfig.Motor.SpeedSetpointWindow < (ABS(#si_ActualSpeed) - (#iqUDT_ConveyorInterface.SpeedSetpoint));
	        END_IF;
	        
	        
	        // Check IF speed setpoint is reached FOR motor
	        #sx_SpeedSetpointReached := (ABS(#si_ActualSpeed) >= ((#iqUDT_ConveyorInterface.SpeedSetpoint) - #iUDT_AixConfig.Motor.SpeedSetpointWindow))
	        AND (ABS(#si_ActualSpeed) <= ((#iqUDT_ConveyorInterface.SpeedSetpoint) + #iUDT_AixConfig.Motor.SpeedSetpointWindow));
	    END_REGION
	    
	END_REGION
	
	(* REGION 9 - Reading actual position
	    
	    REGION 9.1 - Left Motor
	        
	        #sx_LeftServoHomeHasBeenSet := #iUDT_AixInputsModule.ServoStatusLeft.%X1;
	        IF #ix_MotorPositionId = #ci_Left
	        THEN
	            IF #sx_LeftServoHomeHasBeenSet THEN
	                #si_LastLeftMotorPosition := 0;
	            END_IF;
	            // Add last position change to static memory
	            #si_LeftMotorPosition += - #si_LastLeftMotorPosition;
	            // Save last motor position
	            #si_LastLeftMotorPosition := #iUDT_AixInputsModule.ServoLocationLeft;
	            
	            // Copy displacement if motor position change is greater or equal to 1 cm and store rest
	            IF #si_LeftMotorPosition > 10 THEN
	                #iqUDT_ConveyorInterface.DeltaPosition := REAL_TO_INT(INT_TO_REAL(#si_LeftMotorPosition) * #iUDT_AixConfig.Motor.Ratio) / 10;
	                #si_LeftMotorPosition := #si_LeftMotorPosition MOD 10;
	            ELSE
	                #iqUDT_ConveyorInterface.DeltaPosition := 0;
	            END_IF;
	            
	            // allocate Motor Rotation status
	            #sb_MotorRotationStatus.%X0 := #iUDT_AixInputsModule.LeftMotorDiagnostic.MotorStatus1;
	            #sb_MotorRotationStatus.%X1 := #iUDT_AixInputsModule.LeftMotorDiagnostic.MotorStatus2;
	            
	            // Change direction sign if motor running reverse
	            IF ((#sb_MotorRotationStatus = #cb_MotorInCW) AND NOT #iUDT_AixConfig.Motor.DirectionReversal) OR
	                ((#sb_MotorRotationStatus = #cb_MotorInCCW) AND #iUDT_AixConfig.Motor.DirectionReversal)
	            THEN
	                
	                #iqUDT_ConveyorInterface.DeltaPosition *= -1;
	                
	            END_IF;
	            
	            // Motor positioned
	            #qx_Positioned := #iUDT_AixInputsModule.ServoStatusLeft.%X0;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 9.2 - Right motor 
	        #sx_RightServoHomeHasBeenSet := #iUDT_AixInputsModule.ServoStatusRight.%X1;
	        IF #ix_MotorPositionId = #ci_Right
	        THEN
	            IF #sx_RightServoHomeHasBeenSet THEN
	                #si_LastRightMotorPosition := 0;
	            END_IF;
	            // Add last position change to static memory
	            #si_RightMotorPosition += - #si_LastRightMotorPosition;
	            // Save last motor position
	            #si_LastRightMotorPosition := #iUDT_AixInputsModule.ServoLocationRight;
	            
	            // Copy displacement if motor position change is greater or equal to 1 cm and store rest
	            IF #si_RightMotorPosition > 10 THEN
	                #iqUDT_ConveyorInterface.DeltaPosition := REAL_TO_INT(INT_TO_REAL(#si_RightMotorPosition) * #iUDT_AixConfig.Motor.Ratio) / 10;
	                #si_RightMotorPosition := #si_RightMotorPosition MOD 10;
	            ELSE
	                #iqUDT_ConveyorInterface.DeltaPosition := 0;
	            END_IF;
	            
	            // allocate Motor Rotation status
	            #sb_MotorRotationStatus.%X0 := #iUDT_AixInputsModule.RightMotorDiagnostic.MotorStatus1;
	            #sb_MotorRotationStatus.%X1 := #iUDT_AixInputsModule.RightMotorDiagnostic.MotorStatus2;
	            
	            // Change direction sign if motor running reverse
	            IF ((#sb_MotorRotationStatus = #cb_MotorInCW) AND NOT #iUDT_AixConfig.Motor.DirectionReversal) OR
	                ((#sb_MotorRotationStatus = #cb_MotorInCCW) AND #iUDT_AixConfig.Motor.DirectionReversal)
	            THEN
	                
	                #iqUDT_ConveyorInterface.DeltaPosition *= -1;
	                
	            END_IF;
	            
	            // Motor positioned
	            #qx_Positioned := #iUDT_AixInputsModule.ServoStatusRight.%X0;
	            
	        END_IF;
	        
	    END_REGION
	    
	    
	END_REGION *)
	
	REGION 9 - Reading actual position
	    
	    REGION 9.1 - Left motor 
	        
	        IF #ii_MotorPositionId = #ci_Master_Left OR #ii_MotorPositionId = #ci_Slave_Left
	        THEN
	            IF #iUDT_AixInputsModule.ServoLocationLeft = 0 THEN
	                #si_LastLeftMotorPosition := 0;
	            END_IF;
	            // Add last position change to static memory
	            #si_LeftMotorPosition += ABS(ABS(#iUDT_AixInputsModule.ServoLocationLeft) - ABS(#si_LastLeftMotorPosition));
	            // Save last motor position
	            #si_LastLeftMotorPosition := #iUDT_AixInputsModule.ServoLocationLeft;
	            
	            // Copy delta position if motor position change is greater or equal to 1 cm and store rest
	            IF #si_LeftMotorPosition > 10 THEN
	                IF #ii_MotorPositionId = #ci_Master_Left THEN
	                    #iqUDT_ConveyorInterface.DeltaPosition := REAL_TO_INT(INT_TO_REAL(#si_LeftMotorPosition) * #iUDT_AixConfig.Motor.Ratio) / 10;
	                END_IF;
	                #si_LeftMotorPosition := #si_LeftMotorPosition MOD 10;
	            ELSE
	                IF #ii_MotorPositionId = #ci_Master_Left THEN
	                    #iqUDT_ConveyorInterface.DeltaPosition := 0;
	                END_IF;
	            END_IF;
	            // Change direction sign if motor running reverse
	            IF #iUDT_AixInputsModule.LeftMotorDiagnostic.MotorStatus1 AND NOT #iUDT_AixInputsModule.LeftMotorDiagnostic.MotorStatus2 AND NOT #iUDT_AixConfig.Motor.DirectionReversal
	                OR NOT #iUDT_AixInputsModule.LeftMotorDiagnostic.MotorStatus1 AND #iUDT_AixInputsModule.LeftMotorDiagnostic.MotorStatus2 AND #iUDT_AixConfig.Motor.DirectionReversal
	            THEN
	                IF #ii_MotorPositionId = #ci_Master_Left THEN
	                    #iqUDT_ConveyorInterface.DeltaPosition *= -1;
	                END_IF;
	            END_IF;
	            
	            // Motor positioned
	            #qx_Positioned := #iUDT_AixInputsModule.ServoStatusLeft.%X0;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 9.2 - Right motor 
	        
	        IF #ii_MotorPositionId = #ci_Master_Right OR #ii_MotorPositionId = #ci_Slave_Right
	        THEN
	            IF #iUDT_AixInputsModule.ServoLocationRight = 0 THEN
	                #si_LastRightMotorPosition := 0;
	            END_IF;
	            // Add last position change to static memory
	            #si_RightMotorPosition += ABS(ABS(#iUDT_AixInputsModule.ServoLocationRight) - ABS(#si_LastRightMotorPosition));
	            // Save last motor position
	            #si_LastRightMotorPosition := #iUDT_AixInputsModule.ServoLocationRight;
	            
	            // Copy delta position if motor position change is greater or equal to 1 cm and store rest
	            IF #si_RightMotorPosition > 10 THEN
	                IF #ii_MotorPositionId = #ci_Master_Right THEN
	                    #iqUDT_ConveyorInterface.DeltaPosition := REAL_TO_INT(INT_TO_REAL(#si_RightMotorPosition) * #iUDT_AixConfig.Motor.Ratio) / 10;
	                END_IF;
	                #si_RightMotorPosition := #si_RightMotorPosition MOD 10;
	            ELSE
	                IF #ii_MotorPositionId = #ci_Master_Right THEN
	                    #iqUDT_ConveyorInterface.DeltaPosition := 0;
	                END_IF;
	            END_IF;
	            // Change direction sign if motor running reverse
	            IF #iUDT_AixInputsModule.RightMotorDiagnostic.MotorStatus1 AND NOT #iUDT_AixInputsModule.RightMotorDiagnostic.MotorStatus2 AND NOT #iUDT_AixConfig.Motor.DirectionReversal
	                OR NOT #iUDT_AixInputsModule.RightMotorDiagnostic.MotorStatus1 AND #iUDT_AixInputsModule.RightMotorDiagnostic.MotorStatus2 AND #iUDT_AixConfig.Motor.DirectionReversal
	            THEN
	                IF #ii_MotorPositionId = #ci_Master_Right THEN
	                    #iqUDT_ConveyorInterface.DeltaPosition *= -1;
	                END_IF;
	            END_IF;
	            
	            // Motor positioned
	            #qx_Positioned := #iUDT_AixInputsModule.ServoStatusRight.%X0;
	            
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	
	REGION 10 - Copy signals to interface DB and to status output UDT
	    
	    REGION 10.1 - Motor
	        
	        // Create internal error status
	        // Write Conveyor interface bits only if it is a Master
	        IF #ii_MotorPositionId = #ci_Master_Left OR #ii_MotorPositionId = #ci_Master_Right THEN
	            
	            #iqUDT_ConveyorInterface.VFDRunning := #sx_AixAvailableControler AND
	            (#si_ActualSpeed <> 0);                 // Write true on output Conveyor interface structure if Ai2's are in operation and motor is turning 
	            
	            #iqUDT_ConveyorInterface.VFDatSpeed := #sx_SpeedSetpointReached AND
	            #sx_AixAvailableControler AND
	            #si_ActualSpeed <> 0 AND
	            NOT #sx_SpeedFeedbackError;             // Copy setpoint speed reached state from static to the output conveyor interface structure
	            
	            #iqUDT_ConveyorInterface.InternalWarningVFD := #sUDT_HMIStatus.PNSlaveWarning;                                                       // Set the internal warning bit if any warning is active
	            
	            #iqUDT_ConveyorInterface.InternalErrorVFD := #sx_ErrorCMotor;                   // Set the internal error bit if any fault is active 
	            
	            #iqUDT_ConveyorInterface.ActualSpeed := ABS(#si_ActualSpeed);                   // Copy the calculated value to the output
	            
	            #iqUDT_ConveyorInterface.ConfigurationError := #sx_ConfigurationError;          // Copy the calculated value to the output
	            
	        END_IF;
	        
	        
	    END_REGION
	    
	    REGION 10.2 - Move error status TO HMI Status 
	        
	        // Copy error status to output
	        #qUDT_HMIStatus := #sUDT_HMIStatus;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 11 - Statistic
	    
	    REGION 11.1 - General
	        // Statement section REGION
	        #sx_GeneralStatisticsReset := #iqUDT_ConveyorInterface.ResetStatistics;
	    END_REGION
	    
	    // Create trigger on error and create statistics for profinet slave not online
	    #sR_TRIG_PNSlaveNotOnline(CLK := #sUDT_HMIStatus.PNSlaveNotOnline);                 // Detect the rising edge of the error
	    
	    IF #sx_GeneralStatisticsReset OR #sUDT_HMIStatus.PNSlaveNotOnline
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #sx_GeneralStatisticsReset,
	                        ix_Activate := #sUDT_HMIStatus.PNSlaveNotOnline,
	                        ix_RTrigActivate := #sR_TRIG_PNSlaveNotOnline.Q,
	                        iqUDT_Statistics := #iqUDT_MCOStatistics.PNSlaveNotOnline);
	        
	        #iqUDT_MCOStatistics.PNSlaveNotOnline := #iqUDT_MCOStatistics.PNSlaveNotOnline;
	    END_IF;
	    
	    // Create trigger on error and create statistics for profinet slave error
	    #sR_TRIG_PNSlaveError(CLK := #sUDT_HMIStatus.PNSlaveError);                                                                          // Detect the rising edge of the error
	    
	    IF #sx_GeneralStatisticsReset OR #sUDT_HMIStatus.PNSlaveError
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #sx_GeneralStatisticsReset,
	                        ix_Activate := #sUDT_HMIStatus.PNSlaveError,
	                        ix_RTrigActivate := #sR_TRIG_PNSlaveError.Q,
	                        iqUDT_Statistics := #iqUDT_MCOStatistics.PNSlaveError);
	        
	        #iqUDT_MCOStatistics.PNSlaveError := #iqUDT_MCOStatistics.PNSlaveError;
	    END_IF;
	    
	    
	    // Create trigger on error and create statistics for MCO communication error
	    #sR_TRIG_CommunicationErrorMCO(CLK := #qUDT_HMIStatus.CommunicationErrorVFD);            // Detect the rising edge of the error
	    
	    IF #sx_GeneralStatisticsReset OR #qUDT_HMIStatus.CommunicationErrorVFD
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #sx_GeneralStatisticsReset,
	                        ix_Activate := #qUDT_HMIStatus.CommunicationErrorVFD,
	                        ix_RTrigActivate := #sR_TRIG_CommunicationErrorMCO.Q,
	                        iqUDT_Statistics := #iqUDT_MCOStatistics.CommunicationErrorMovikit);
	        
	    END_IF;
	    
	    REGION 11.1 - Motor       
	        
	        // Create trigger on error and create statistics for internal MCO Error
	        #sR_TRIG_MCOInternalError(CLK := #sUDT_HMIStatus.InternalError);         // Detect the rising edge of the error
	        
	        IF #iqUDT_ConveyorInterface.ResetStatistics OR #sUDT_HMIStatus.InternalError
	        THEN
	            
	            "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                            ix_Activate := #sUDT_HMIStatus.InternalError,
	                            ix_RTrigActivate := #sR_TRIG_MCOInternalError.Q,
	                            iqUDT_Statistics := #iqUDT_MCOStatistics.VFDInternalError);
	            
	        END_IF;
	        
	        // Create trigger on running signal and create statistics for running status
	        #sR_TRIG_Running(CLK := #iqUDT_ConveyorInterface.VFDRunning);                           // Detect the rising edge of the signal
	        
	        IF #iqUDT_ConveyorInterface.ResetStatistics OR #iqUDT_ConveyorInterface.VFDRunning
	        THEN
	            
	            "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                            ix_Activate := #iqUDT_ConveyorInterface.VFDRunning,
	                            ix_RTrigActivate := #sR_TRIG_Running.Q,
	                            iqUDT_Statistics := #iqUDT_MCOStatistics.Running);
	        END_IF;
	        
	        
	    END_REGION
	    REGION 12 Status bit allocation
	        "FC_BitAllocation"(ix_Bit0 := #qUDT_HMIStatus.SpeedFeedbackError,
	                           ix_Bit1 := #qUDT_HMIStatus.InternalWarning,
	                           ix_Bit2 := #qUDT_HMIStatus.InternalError,
	                           ix_Bit3 := #qUDT_HMIStatus.CommunicationErrorVFD,
	                           ix_Bit4 := #qUDT_HMIStatus.PNSlaveNotOnline,
	                           ix_Bit5 := #qUDT_HMIStatus.PNSlaveError,
	                           ix_Bit6 := #qUDT_HMIStatus.PNSlaveWarning,
	                           ix_Bit7 := FALSE,
	                           ix_Bit8 := FALSE,
	                           ix_Bit9 := FALSE,
	                           ix_Bit10 := FALSE,
	                           ix_Bit11 := FALSE,
	                           ix_Bit12 := FALSE,
	                           ix_Bit13 := FALSE,
	                           ix_Bit14 := FALSE,
	                           ix_Bit15 := FALSE,
	                           ix_Bit16 := FALSE,
	                           ix_Bit17 := FALSE,
	                           ix_Bit18 := FALSE,
	                           ix_Bit19 := FALSE,
	                           ix_Bit20 := FALSE,
	                           ix_Bit21 := FALSE,
	                           ix_Bit22 := FALSE,
	                           ix_Bit23 := FALSE,
	                           ix_Bit24 := FALSE,
	                           ix_Bit25 := FALSE,
	                           ix_Bit26 := FALSE,
	                           ix_Bit27 := FALSE,
	                           ix_Bit28 := FALSE,
	                           ix_Bit29 := FALSE,
	                           ix_Bit30 := FALSE,
	                           ix_Bit31 := FALSE,
	                           qdw_Dword => #qUDT_HMIStatus.ControllerStatus);
	    END_REGION
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_Displacement"
TITLE = FB_Displacement
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
//Function block to calculate the displacement.
   VAR_IN_OUT 
      iqUDT_ConveyorInterface : "UDT_ConveyorInterface";   // Conveyor interface structure Motor
   END_VAR

   VAR 
      slr_FormDisplacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Conveyor displacement [cm]
      slr_Correction { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Correction [cm]
      sx_PositionModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Position Mode is used, Will reset after power change
   END_VAR

   VAR_TEMP 
      ti_Displacement : Int;   // Conveyor displacement [cm]
   END_VAR

   VAR CONSTANT 
      ci_IntMin : Int := -32768;
      ci_IntMax : Int := 32767;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	12/09/2019  | 2.1       | P.Majka       | Comments updataed
	04/11/2019  | 2.2       | L.Klar        | Prevoius cycle scan changed from memory to DB variable
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	31/05/2024  | 4.1       | I.Ajram       | Added Displacement from Position feedback
	*)
	REGION 0 - Mode detection
	    IF #iqUDT_ConveyorInterface.DeltaPosition <> 0 THEN
	        #sx_PositionModeActive := true;
	    END_IF;
	END_REGION
	
	
	REGION 1 - Displacement From Speed
	    IF NOT #sx_PositionModeActive THEN
	        REGION 1.1 Calculate Displacement
	            // Displacement is calculated using actual conveyor speed and the previous PLC cycle scan time
	            #slr_FormDisplacement := INT_TO_LREAL(#iqUDT_ConveyorInterface.ActualSpeed) * "DB_Memory".PrevCycleTime / 10000.0;
	            
	            // Correction is used to accumulate the rest of the calculated value
	            #slr_Correction := FRAC(#slr_FormDisplacement) + #slr_Correction;
	            
	            // The actual displacement is a sum of complete parts of the displacement and correction variables
	            #ti_Displacement := DINT_TO_INT(TRUNC(#slr_FormDisplacement) + TRUNC(#slr_Correction));
	            
	        END_REGION
	        
	        REGION 1.2 - Correction check
	            
	            // Correction incrementation or decremantation if it exceeds 1 or -1 in case of negative speed
	            IF (#slr_Correction >= 1)
	            THEN
	                
	                #slr_Correction -= 1;
	                
	            ELSIF (#slr_Correction <= -1)
	            THEN
	                
	                #slr_Correction += 1;
	                
	            END_IF;
	            
	        END_REGION
	        
	        #iqUDT_ConveyorInterface.Displacement := #ti_Displacement;
	    END_IF;
	END_REGION
	
	REGION 2 - Displacement from Position
	    // pass position displacement from Servo Feedback
	    IF #sx_PositionModeActive THEN
	        #iqUDT_ConveyorInterface.Displacement := #iqUDT_ConveyorInterface.DeltaPosition;
	        
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_RightAngledTransfer"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      iUDT_Configuration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_RATConfiguration" := ((), (), (), (), (), (), (), (), (), (), (), (), (), (), 1, 2, 3, 4, (), (), (), ());   // Configuration structure
      iUDT_LowerConveyorConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorConfiguration";   // Lower configuration structure
      iUDT_UpperConveyorConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorConfiguration";   // Upper configuration structure
      iUDT_PECConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";   // PEC configuration structure
      ii_DestinationA { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Forced destination for every product from conveyor A. When this is 0 then destination is taken from GIN
      ii_DestinationB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Forced destination for every product from conveyor B. When this is 0 then destination is taken from GIN
      ii_DestinationC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Forced destination for every product from conveyor C. When this is 0 then destination is taken from GIN
      ii_DestinationD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Forced destination for every product from conveyor D. When this is 0 then destination is taken from GIN
      ix_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when  hardware is Ok
      ix_400vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 400VAC is healthy
      ix_24vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 24VDC is healthy
      ix_SafetyOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when safety is ok
      ix_AirPressureOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Air pressure circuit healthy
      ix_SectionIsDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when section is down
      ix_SectionIsUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when section is up
      ix_ConveyorAAuto { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor is started in auto
      ix_ConveyorBAuto { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor is started in auto
      ix_ConveyorCAuto { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor is started in auto
      ix_ConveyorDAuto { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor is started in auto
      ix_PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True when outfeed PEC is not occupied
      ix_ExternalReceiveRequestA { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send parcel request from A conveyor
      ix_ExternalReceiveRequestB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send parcel request from B conveyor
      ix_ExternalReceiveRequestC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send parcel request from C conveyor
      ix_ExternalReceiveRequestD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send parcel request from D conveyor
      ix_PECInfeedA { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // End of section from infeed A
      ix_PECInfeedB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // End of section from infeed B
      ix_PECInfeedC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // End of section from infeed C
      ix_PECInfeedD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // End of section from infeed D
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIRATStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_RATStatus";   // HMI status structure
      qUDT_HMIConveyorStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorStatus";   // HMI status structure for lower conveyor
      qUDT_HMIPECStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";   // HMI status structure for PEC
      qUDT_RATStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   // Common status structure
      qUDT_ConveyorStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   // Common status structure for lower conveyor
      qx_PopupControl { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Output to control popup section
      qx_ExternalSendRequestA { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send request to next RAT in A direction
      qx_ExternalSendRequestB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send request to next RAT in B direction
      qx_ExternalSendRequestC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send request to next RAT in C direction
      qx_ExternalSendRequestD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send request to next RAT in D direction
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
      iqUDT_RATCommand : "UDT_RATCommand";   // RAT command stucture
      iqUDT_ConveyorCommand : "UDT_ConveyorCommand";   // Conveyor command stucture
      iqUDT_RATStatistics : "UDT_RATStatistics";   // RAT statistics structure
      iqUDT_ConveyorStatistics : "UDT_ConveyorStatistics";   // Statistics structure
      iqUDT_PECStatistics : "UDT_PECStatistics";   // PEC statistics structure
      iqUDT_HandShakeConveyorA : "UDT_ConveyorHandshake";   // Handshake structure low level conveyor
      iqUDT_HandShakeConveyorB : "UDT_ConveyorHandshake";   // Handshake structure low level conveyor
      iqUDT_HandShakeConveyorC : "UDT_ConveyorHandshake";   // Handshake structure high level conveyor
      iqUDT_HandShakeConveyorD : "UDT_ConveyorHandshake";   // Handshake structure high level conveyor
      iqUDT_LowerConveyorInterface : "UDT_ConveyorInterface";   // Lower conveyor interface structure
      iqUDT_UpperConveyorInterface : "UDT_ConveyorInterface";   // Upper conveyor interface structure
      iqUDT_RATPositioning : "UDT_RATPositioning";   // Positioning control structure
      iqUDT_BladeStopEoSInterface : "UDT_ValveInterface";   // Blade stop EoS interface signals
      iqUDT_BladeStopBoSInterface : "UDT_ValveInterface";   // Blade stop BoS interface signals
   END_VAR

   VAR RETAIN
      sa_FiFo { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..#ci_FiFoLength] of Int := [10(0)];   // FiFo of request
   END_VAR
   VAR 
      sUDT_CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Common status structure
      sUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATStatus";   // HMI status structure
      sUDT_HandshakeBuffer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Auxiliary handshake structure
      sUDT_HandshakeUpLowerConveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Upstream handshake for lower conveyor
      sUDT_HandshakeUpUpperConveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Upstream handshake for upper conveyor
      sUDT_HandshakeLowerConveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Downstream handshake for lower conveyor
      sUDT_HandshakeUpperConveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Downstream handshake for upper conveyor
      sFB_Conveyor_LowerConveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Lower conveyor block instance
      sFB_Conveyor_UpperConveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Upper conveyor block instance
      sFB_SectionUpMonitor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer to monitor divert took too long to move to upper position
      sFB_SectionDownMonitor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer to monitor divert took too long to move to lower position
      sFB_PECOnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer for PEC filtering
      sFB_InfeedTimeout { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer to monitor infeed timeout
      sFB_ConveyorAReactivation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer to monitor reativation on Conveyor A
      sFB_ConveyorBReactivation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer to monitor reativation on Conveyor B
      sFB_ConveyorCReactivation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer to monitor reativation on Conveyor C
      sFB_ConveyorDReactivation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer to monitor reativation on Conveyor D
      sFB_PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // RAT PEC handling
      sR_TRIG_ReceiveRequestConveyorA {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger RTS signal from infeed
      sR_TRIG_ReceiveRequestConveyorB {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger RTS signal from infeed
      sR_TRIG_ReceiveRequestConveyorC {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger RTS signal from infeed
      sR_TRIG_ReceiveRequestConveyorD {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger RTS signal from infeed
      sR_TRIG_ManualMode {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger manual mode
      sF_TRIG_ManualMode {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger manual mode
      sR_TRIG_ManualGoUp {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge run conveyor in manual mode
      sR_TRIG_ManualGoDown {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger manual jog
      sR_TRIG_PecOutfeed {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge of reverse direction
      sF_TRIG_Jog {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger manual mode jog
      sR_TRIG_LowerInfeed {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge of infeeding on lower conveyor
      sR_TRIG_UpperInfeed {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge of infeeding on upper conveyor
      sR_TRIG_LowerOutfeedRunning {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge of outfeeding on lower conveyor
      sR_TRIG_UpperOutfeedRunning {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge of outfeeding on upper conveyor
      sR_TRIG_LowerOutfeed {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge of outfeed mode on lower conveyor
      sR_TRIG_UpperOutfeed {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge of outfeed mode on upper conveyor
      sR_TRIG_AirPressureFault {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge of air pressure fault
      sR_TRIG_DivertUpError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge of divert up error
      sR_TRIG_DivertDownError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge of divert down error
      sR_TRIG_PECInfeedA {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge on A infeed PEC
      sR_TRIG_PECInfeedB {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge on B infeed PEC
      sR_TRIG_PECInfeedC {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge on C infeed PEC
      sR_TRIG_PECInfeedD {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge on D infeed PEC
      sR_TRIG_LowerInfeedDone {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge lower infeed done
      sR_TRIG_UpperInfeedDone {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge upper infeed done
   END_VAR
   VAR RETAIN
      si_Step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Active step number
      si_Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Active infeed
   END_VAR
   VAR 
      si_LoopArrayCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Counter for loop
   END_VAR
   VAR RETAIN
      si_Destination { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Destionation for the product
      si_LowerInfeedDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Counter to receive product on lower conveyor
      si_UpperInfeedDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Counter to receive product on upper conveyor
      si_LowerOutfeedDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Counter to send product from lower conveyor
      si_UpperOutfeedDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Counter to send product from upper conveyor
      sx_PECFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Signal filtered with on and off delay
      sx_Active { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Device sequence is activated for parcel
      sx_DataReceived { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Destination data is received
      sx_InfeedCHK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Step Infeed check
      sx_UpDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Step determine go up or down (wait for destination)
      sx_MoveSectionUpinfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Step move device to upper position
      sx_MoveSectionUpOutfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Step move device to upper position
      sx_MoveSectionUpEnd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Step move device to upper position
      sx_MoveSectionDownInfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Step move device to lower position
      sx_MoveSectionDownOutfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Step move device to lower position
      sx_MoveSectiondownEnd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Step move device to lower position
      sx_UpperTransportIn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Step transport is activated
      sx_UpperTransportOut { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Step transport is activated
      sx_LowerTransportIn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Step transport is activated
      sx_LowerTransportOut { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Step transport is activated
      sx_LowerRTR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // RTR signal to lower level
      sx_UpperRTR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // RTR signal to upper level
   END_VAR
   VAR 
      sx_Ready { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor Ready to operate in Automatic mode
      sx_AutomaticActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Running in automatic
      sx_PreStartManual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Pre conditions to run conveyor in manual mode
      sx_ManualModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual mode active
      sx_ManualRunning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Device running in manual mode
      sx_ManualGoUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual control go Up
      sx_ManualGoDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual control go down
      sx_ManUP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Auxiliary bit for manual up possition
      sx_ManDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Auxiliary bit for manual down possition
   END_VAR
   VAR RETAIN
      sx_DestinationA { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Destination is output A
      sx_DestinationB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Destination is output B
      sx_DestinationC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Destination is output C
      sx_DestinationD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Destination is output D
   END_VAR
   VAR 
      sx_DivertUpRunTimeErr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // It is taking too long to move divert up
      sx_DivertDownRunTimeErr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // It is taking too long to move divert down
      sx_ReactivateA { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reactivate conveyor A bit
      sx_ReactivateB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reactivate conveyor B bit
      sx_ReactivateC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reactivate conveyor C bit
      sx_ReactivateD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reactivate conveyor D bit
   END_VAR
   VAR RETAIN
      sx_SectionDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Section down bit
      sx_SectionUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Section up bit
      sx_ProductReceivedDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Product received on lower conveyor
      sx_ProductSentDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Product sent from lower conveyor
      sx_ProductSentUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Product sent from upper conveyor
      sx_ProductReceivedUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Product received on upper conveyor
      sx_ReverseUpper { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Upper conveyor direction 0 - normal 1 - reverse
      sx_ReverseLower { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Lower conveyor direction 0 - normal 1 - reverse
      sx_ServoInfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Infeed base on servo position
      sx_DisplacementInfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Infeed base on displacement
   END_VAR
   VAR 
      sx_TrigPECInfeedA { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Infeed A released product
      sx_TrigPECInfeedB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Infeed B released product
      sx_TrigPECInfeedC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Infeed C released product
      sx_TrigPECInfeedD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Infeed D released product
      sx_BladeStopEoSControl { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when blade stop should go up
      sx_BladeStopBoSControl { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when blade stop should go up
      sx_BladeStopUpRunTimeErr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // It is taking too long for blade stop to move up
      sx_BladeStopDownRunTimeErr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // It is taking too long for blade stop to move down
   END_VAR

   VAR_TEMP 
      tUDT_ConveyorCommandUpper : "UDT_ConveyorCommand";   // Upper conveyor command structure
      tUDT_HMIStatus : "UDT_ConveyorStatus";   // Temporary conveyor hmi status
      tUDT_CommonStatus : "UDT_CommonStatus";   // Temporary conveyor common status
      tUDT_ConveyorStatistics : "UDT_ConveyorStatistics";   // Temporary conveyor statistics
      tUDT_ConveyorInterface : "UDT_ConveyorInterface";   // Temporary conveyor interface
      tx_LowerConveyorRunFwd : Bool;   // Run forward signal for lower conveyor
      tx_UpperConveyorRunFwd : Bool;   // Run backward signal for lower conveyor
      tx_LowerConveyorRunRvs : Bool;   // Run forward signal for upper conveyor
      tx_UpperConveyorRunRvs : Bool;   // Run backwardsignal for upper conveyor
   END_VAR

   VAR CONSTANT 
      ci_FiFoLength : Int := 10;   // Fifo length
      ci_ConveyorA : Int := 1;   // Conveyor A is Infeeding
      ci_ConveyorB : Int := 2;   // Conveyor B is Infeeding
      ci_ConveyorC : Int := 3;   // Conveyor C is Infeeding
      ci_ConveyorD : Int := 4;   // Conveyor D is Infeeding
      ci_DefaultPositionUp : Int := 1;
      ci_DefaultPositiondown : Int;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	18/10/2023  | 1.0       | F.Baten       | Initial version
	07/11/2023  | 1.1       | K. Pokorski   | Review and tests. 
	                                        | Add infeed timeout and infeed reactivation functionality. 
	                                        | Fix inserting GIN number to Handshake during outfeed 
	                                        | Fix hold control for upper and lower belt of transfer
	                                        | Add reset of RTR when sequence if over 
	                                        | Increase length of filling tracking with 0 when outfeed transfer starts
	                                        | Add 4 different destinations input for every infeed separately
	                                        | Unused variables clearing
	                                        | Disable sending RTS because of reverse direction problem and fake FIFO reservations
	02/02/2024  | 1.2       | K.Pokorski    | Add FB conveyor inside RAT block and make code clear and commented            
	04/04/2024  | 1.3       | S.Nieswiec    | Newest version from Kamil Pokorski
	08/04/2024  | 1.4       | R. Pieczonka  | Changed writing pneumatic outputs in Region 8.1 due to the valve being monostable 
	06/05/2024  | 1.5       | K. Pokorski   | Changed condition for tracking transition
	                                        | Add 4 direction infeed tracking and change condition to track product tail base on infeed PEC
	                                        | Correct product GIN transition
	                                        | Add configuration to disable PEC product controlling
	10/05/2024  | 1.6       | K. Pokorski   | Add outfeed based on displacement
	31/05/2024  | 1.7       | K. Pokorski   | Add positioning infeed control
	28/08/2024  | 1.8       | J.Majer       | Added BoS blade stop, added valve status input interface, removed blade stop position monitoring in RAT block, replaced integers with constants for destination
	                                          
	*)
	
	(*                                                                   
	    From A to B product is transported via rollers                 
	    From C to D product is transported via pop up belt strips      
	    
	                        |             |                                    
	                        |             |                                                                                                      
	                        | Conveyor B  |                                                                                                    
	                        |      /\     |
	                        |      |      |
	                        |      |      |
	                        |      \/     |
	 _______________________--------------- ________________________
	                        |               |                         
	                        |               |                         
	   Conveyor D <-->      |      RAT      |  Conveyor C <-->        
	                        |               |                         
	                        |               |                         
	 _______________________|               |________________________
	                         ---------------
	                        |      /\      |
	                        |      |       |
	                        |      |       |
	                        |      \/      |
	                        |  Conveyor A  |
	                        |              |
	                        |              |
	
	*)                                                                                                                                                                                                                                                                                                                                             
	REGION 1 - Initial
	    
	    REGION 1.1 - Triggers
	        
	        // Rising edge trigger manual mode
	        #sR_TRIG_ManualMode(CLK := #iqUDT_RATCommand.ManualMode
	                            OR #iqUDT_EquipmentControl.Command.ManualMode
	                            OR #iqUDT_ConveyorCommand.ManualMode);
	        
	        // Falling edge trigger manual mode
	        #sF_TRIG_ManualMode(CLK := #iqUDT_RATCommand.ManualMode
	                            OR #iqUDT_EquipmentControl.Command.ManualMode
	                            OR #iqUDT_ConveyorCommand.ManualMode);
	        
	        // Rising edge trigger to start in manual mode
	        #sR_TRIG_ManualGoUp(CLK := #iqUDT_RATCommand.ManualUp);
	        
	        // Rising edge trigger manual mode jog
	        #sR_TRIG_ManualGoDown(CLK := #iqUDT_RATCommand.ManualDown);
	        
	        // Rising edge PEC outfeed
	        #sR_TRIG_PecOutfeed(CLK := #sx_PECFiltered);
	        
	        // Infeed conveyor is ready to send
	        #sR_TRIG_ReceiveRequestConveyorA(CLK := (#ix_ExternalReceiveRequestA) AND #ix_ConveyorAAuto);
	        #sR_TRIG_ReceiveRequestConveyorB(CLK := (#ix_ExternalReceiveRequestB) AND #ix_ConveyorBAuto);
	        #sR_TRIG_ReceiveRequestConveyorC(CLK := (#ix_ExternalReceiveRequestC) AND #ix_ConveyorCAuto);
	        #sR_TRIG_ReceiveRequestConveyorD(CLK := (#ix_ExternalReceiveRequestD) AND #ix_ConveyorDAuto);
	        
	        // Rising edge infeed on lower conveyor started
	        #sR_TRIG_LowerInfeed(CLK := #sx_LowerTransportIn);
	        
	        // Rising edge infeed on upper conveyor started
	        #sR_TRIG_UpperInfeed(CLK := #sx_UpperTransportIn);
	        
	        // Rising edge outfeed on lower conveyor started
	        #sR_TRIG_LowerOutfeed(CLK := #sx_LowerTransportOut);
	        
	        // Rising edge outfeed on upper conveyor started
	        #sR_TRIG_UpperOutfeed(CLK := #sx_UpperTransportOut);
	        
	        // Rising edge outfeed on lower conveyor when it's running
	        #sR_TRIG_LowerOutfeedRunning(CLK := #iqUDT_LowerConveyorInterface.ActualSpeed <> 0 AND #sx_LowerTransportOut);
	        
	        // Rising edge outfeed on upper conveyor when it's running
	        #sR_TRIG_UpperOutfeedRunning(CLK := #iqUDT_UpperConveyorInterface.ActualSpeed <> 0 AND #sx_UpperTransportOut);
	        
	        //Rising edge air pressure error occured
	        #sR_TRIG_AirPressureFault(CLK := #sUDT_HMIStatus.Specific.ErrAirpressureNotOk);
	        
	        // Rising edge divert up operation timeout
	        #sR_TRIG_DivertUpError(CLK := #sx_DivertUpRunTimeErr);
	        
	        // Rising edge divert down operation timeout
	        #sR_TRIG_DivertDownError(CLK := #sx_DivertDownRunTimeErr);
	        
	        // Rising edge of Infeed A photoeye
	        #sR_TRIG_PECInfeedA(CLK := #ix_PECInfeedA);
	        
	        // Rising edge of Infeed B photoeye
	        #sR_TRIG_PECInfeedB(CLK := #ix_PECInfeedB);
	        
	        // Rising edge of Infeed C photoeye
	        #sR_TRIG_PECInfeedC(CLK := #ix_PECInfeedC);
	        
	        // Rising edge of Infeed D photoeye
	        #sR_TRIG_PECInfeedD(CLK := #ix_PECInfeedD);
	        
	        // Rising edge lower servo positioning finished
	        #sR_TRIG_LowerInfeedDone(CLK := #iqUDT_RATPositioning.Lower.Done);
	        
	        // Rising edge upper servo positioning finished
	        #sR_TRIG_UpperInfeedDone(CLK := #iqUDT_RATPositioning.Upper.Done);
	        
	    END_REGION
	    
	    REGION 1.2 - Timers
	        
	        // Delay photoeye signal for operation purposes
	        #sFB_PECOnOffDelay(iudi_OnDelayTime := #iUDT_Configuration.OutfeedTimeDelay,
	                           iudi_OffDelayTime := #iUDT_Configuration.InfeedTimeDelay,
	                           ix_SignalToDelay := #ix_PEC,
	                           ix_Enable := TRUE,
	                           qx_DelayedSignal => #sx_PECFiltered);
	        
	        // Monitor upward movement and generate an error when time is exceeded 
	        #sFB_SectionUpMonitor(iudi_OnDelayTime := #iUDT_Configuration.SectionUpMonitoringTime,
	                              ix_SignalToDelay := #sx_AutomaticActive
	                              AND #sx_SectionUp
	                              AND NOT #ix_SectionIsUp,
	                              ix_Enable := TRUE,
	                              qx_DelayedSignal => #sx_DivertUpRunTimeErr);
	        
	        // Monitor downward movement and generate an error when time is exceeded 
	        #sFB_SectionDownMonitor(iudi_OnDelayTime := #iUDT_Configuration.SectionDownMonitoringTime,
	                                ix_SignalToDelay := #sx_AutomaticActive
	                                AND #sx_SectionDown
	                                AND NOT #ix_SectionIsDown,
	                                ix_Enable := TRUE,
	                                qx_DelayedSignal => #sx_DivertDownRunTimeErr);
	        
	    END_REGION
	    
	    REGION 1.3 - Initialization
	        
	        #iqUDT_RATPositioning.Lower.ResetPosition := FALSE;
	        #iqUDT_RATPositioning.Upper.ResetPosition := FALSE;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 2 - Error / warning
	    
	    REGION 2.1 - Reset errors
	        
	        IF #iqUDT_EquipmentControl.Command.Reset                        // Reset command received 
	        THEN
	            #sUDT_HMIStatus.Specific.ErrRuntime := FALSE;               // reset movement timeout error
	            #sUDT_HMIStatus.Specific.ErrAirpressureNotOk := FALSE;      // reset airpressure error
	        END_IF;
	        
	    END_REGION
	    
	    REGION 2.2 - Set errors
	        
	        // Runtime delay error
	        IF #sx_DivertUpRunTimeErr                                       // It took too long to move up
	            OR #sx_DivertDownRunTimeErr                                 // It took too long to move down
	        THEN
	            #sUDT_HMIStatus.Specific.ErrRuntime := TRUE;                // Set error runtime error
	        END_IF;
	        
	        // Airpressure not ok
	        IF (NOT #ix_AirPressureOk                                        // Airpressure is not signalling              
	            AND #sx_SectionUp)                                           // If there is request to move up
	        THEN
	            #sUDT_HMIStatus.Specific.ErrAirpressureNotOk := TRUE;       // Set error airpressure
	        END_IF;
	        
	    END_REGION
	    
	    REGION 2.3 - Warning
	        
	        #sUDT_HMIStatus.Specific.WarnAirPressure := NOT #ix_AirPressureOk;  // Airpressure is not signalling
	        
	    END_REGION
	    
	    
	    REGION 2.4 - Common Error
	        
	        #sUDT_CommonStatus.Error := #sUDT_HMIStatus.Specific.ErrRuntime         // Direction verification found the Direction fault, stop the parcel
	        OR #sUDT_HMIStatus.Specific.ErrAirpressureNotOk                         // Upper jam PEC detected WHILE going Up
	        OR #sUDT_HMIStatus.Specific.ErrOverrun                                  // Parcel travelled too far to divert
	        OR #iqUDT_LowerConveyorInterface.InternalErrorPEC                       // Error PEC on lower conveyor
	        OR #iqUDT_UpperConveyorInterface.InternalErrorPEC                       // Error PEC on upper conveyor
	        OR #iqUDT_LowerConveyorInterface.InternalErrorVFD                       // Error lower conveyor VFD
	        OR #iqUDT_UpperConveyorInterface.InternalErrorVFD                       // Error upper conveyor VFD
	        OR #iqUDT_BladeStopEoSInterface.Error                                   // Blade stop EoS has error
	        OR #iqUDT_BladeStopBoSInterface.Error;                                  // Blade stop BoS has error
	        
	        
	    END_REGION
	    
	    REGION 2.5 - Common Warning
	        
	        #sUDT_CommonStatus.Warning := #sUDT_HMIStatus.Specific.WarnAirPressure;   // Airpressure is not signalling
	        
	    END_REGION
	    
	    REGION 2.6 - Common Stopped
	        
	        #sUDT_CommonStatus.Stopped := NOT #sx_Ready OR NOT #sx_AutomaticActive;       //Device is stopped
	        
	    END_REGION
	    
	END_REGION
	
	REGION 3 - Check conditions to set Equipment ready
	    
	    //Conditions to set bit sx_Ready to operate 
	    
	    #sx_Ready := NOT #sUDT_CommonStatus.Error                           // Error present
	    AND #ix_SafetyOk                                                    // Safety signalling OK
	    AND #ix_24vOk                                                       // 24V signalling OK
	    AND #ix_400vOk;                                                     // 400v signalling OK 
	    
	END_REGION
	
	REGION 4 - Stop Equipment
	    
	    // Conditions to stop conveyor
	    IF (#sF_TRIG_Jog.Q                                                  // Trigger when conveyor stops jogging by HMI
	        AND #sx_ManualModeActive)                                       // Manual mode is active
	        
	        OR (NOT #iqUDT_EquipmentControl.Command.AutomaticOn             // Conveyor stops if the bit AutomaticOn from control block is false
	        AND NOT #sx_ManualModeActive)                                   // Manual mode active bit
	        
	        OR (NOT #sx_Ready                                               // Bit conveyor ready to run in automatic mode
	        AND NOT #sx_ManualModeActive)                                   // Manual mode active
	        
	        OR #sR_TRIG_ManualMode.Q                                        // Trigger when manual mode is set on
	        OR #sF_TRIG_ManualMode.Q                                        // Trigger when manual mode is set off
	        
	        OR NOT #ix_SafetyOk                                             // Safety not ok
	    THEN
	        //  Order to stop VFD
	        #iqUDT_LowerConveyorInterface.RunFwd := FALSE;                       // Set false order to VFD run in forward direction
	        #iqUDT_LowerConveyorInterface.RunRvs := FALSE;                       // Set false order to VFD run in reverse direction
	        #iqUDT_UpperConveyorInterface.RunFwd := FALSE;
	        #iqUDT_UpperConveyorInterface.RunRvs := FALSE;
	        #sx_AutomaticActive := FALSE;                                   // Automatic mode is disable
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Start
	    
	    REGION 5.1 - Set Automatic active
	        
	        // The conditions to set the bit "startReceived" are: 
	        // - Divert not in manual mode.
	        // - Divert ready to run.
	        // - Bit AutomaticOn from control block must be on.
	        // - Bit start form control block on.
	        
	        IF #iqUDT_EquipmentControl.Command.Start
	            AND #iqUDT_EquipmentControl.Command.AutomaticOn
	            AND NOT #sx_ManualModeActive
	            AND #sx_Ready
	        THEN
	            #sx_AutomaticActive := TRUE;                                // Diverter active automatic mode
	        END_IF;
	        
	    END_REGION
	    
	    REGION 5.2 - Restart request
	        
	        #iqUDT_EquipmentControl.Request.RestartRequired := NOT #sx_AutomaticActive
	        AND NOT #sx_ManualModeActive
	        AND #sx_Ready;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 6 - Manual mode
	    
	    REGION 6.1 - Manual mode force disable
	        
	        // Manual mode bits inputs can be reset in case of malfunction
	        IF #iqUDT_EquipmentControl.Command.DisableManualMode
	        THEN
	            #iqUDT_RATCommand.ManualMode := FALSE;
	            #iqUDT_EquipmentControl.Command.ManualMode := False;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 6.2 - Manual mode activation 
	        
	        // Manual mode is active if it is active from hmi or by control block  
	        #sx_ManualModeActive := #iqUDT_RATCommand.ManualMode
	        OR #iqUDT_EquipmentControl.Command.ManualMode
	        OR #iqUDT_ConveyorCommand.ManualMode;
	        
	    END_REGION
	    
	    REGION 6.3 - Reset manual commands 
	        //When the system is not any more in manual mode or when fatal error occurs the HMI commands should be reset
	        IF NOT #ix_SafetyOk                                             // Safety not ok
	            OR NOT #ix_24vOk                                            // 24V error status
	            OR NOT #ix_400vOk                                           // 400V error status
	            OR NOT #ix_HardwareOk                                       // Profinet error status
	            OR NOT #sx_ManualModeActive                                 // Manual mode active
	        THEN
	            #iqUDT_RATCommand.ManualDown := FALSE;                      // Reset movement command
	            #iqUDT_RATCommand.ManualUp := FALSE;                        // Reset movement command
	        END_IF;
	        
	    END_REGION
	    
	    REGION 6.4 - Start/Stop
	        
	        // Pre start conditions to run in manual mode
	        #sx_PreStartManual := #sx_ManualModeActive                      // Manual mode active bit
	        AND #ix_SafetyOk                                                // Safety healthy bit
	        AND #ix_HardwareOk;                                             // Profinet comunication 
	        
	        // If manual command is active to one side, first button has to be released to accept new
	        #sx_ManUP := (#sR_TRIG_ManualGoUp.Q AND NOT #sx_ManDown) OR
	        (#sx_ManUP AND #iqUDT_RATCommand.ManualUp);
	        
	        #sx_ManDown := (#sR_TRIG_ManualGoDown.Q AND NOT #sx_ManUP) OR
	        (#sx_ManDown AND #iqUDT_RATCommand.ManualDown);
	        
	        // Do signal request (horn sounding before movement)
	        IF #sx_PreStartManual                                           // Pre start conditions to run in manual mode
	            AND (#sR_TRIG_ManualGoUp.Q AND #sx_ManUP)                  // Trigger when conveyor start running in manual mode
	            OR (#sR_TRIG_ManualGoDown.Q AND #sx_ManDown)
	        THEN
	            
	            #iqUDT_EquipmentControl.Request.SignalingRequest := TRUE;   // Request signaling to control block before conveyor run in manual mode
	            
	        END_IF;
	        
	        // Go up in manual mode
	        #sx_ManualGoUp := #sx_PreStartManual                            // Pre start conditions to run in manual mode
	        AND (NOT #iqUDT_EquipmentControl.Request.SignalingRequest       // Signaling request done
	        OR #sx_ManualRunning)
	        AND #sx_ManUP;
	        ;                                                // Manual mode start TO run
	        
	        // Go down in manual mode
	        #sx_ManualGoDown := #sx_PreStartManual                          // Pre start conditions to run in manual mode
	        AND (NOT #iqUDT_EquipmentControl.Request.SignalingRequest       // Signaling request done
	        OR #sx_ManualRunning)
	        AND #sx_ManDown;                                                // Manual mode start to run
	        
	        #sx_ManualRunning := #sx_ManualGoUp
	        OR #sx_ManualGoDown;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 7 - Automatic mode
	    REGION 7.1 - Update FiFo
	        FOR #si_LoopArrayCount := 1 TO (#ci_FiFoLength - 1) BY 1 DO                 // Set loop to process
	            IF #sa_FiFo[#si_LoopArrayCount] = 0                                     // Do when actual value is '0'
	            THEN
	                #sa_FiFo[#si_LoopArrayCount] := #sa_FiFo[#si_LoopArrayCount + 1];   // copy next entry to actual
	                #sa_FiFo[#si_LoopArrayCount + 1] := 0;                              // Reset next entry
	            END_IF;
	        END_FOR;
	        // Get double entry out 
	        IF #sx_Active                                                               // When Sequence is activated
	        THEN
	            IF (#sa_FiFo[2] <> 0)                                                   // Entry 2 is not equal to '0'
	                AND (#sa_FiFo[2] = #sa_FiFo[3])                                     // Entry 2 is equal to 3
	            THEN
	                #sa_FiFo[3] := 0;                                                   // remove entry 3
	            ELSIF
	                (#sa_FiFo[2] <> 0)                                                  // Entry 2 is not equal to '0'
	                AND (#sa_FiFo[2] = #sa_FiFo[4])                                     // Entry 2 is equal to 4
	            THEN
	                #sa_FiFo[4] := 0;                                                   // Remove entry 4
	            END_IF;
	        END_IF;
	    END_REGION
	    
	    REGION 7.2 - FIFO handling
	        // When an infeed send command it is put in the FiFo then the FiFo is shifted.
	        
	        IF #sR_TRIG_ReceiveRequestConveyorA.Q                                           // Signal received from infeed A
	            OR #sx_ReactivateA                                                          // Reactivate infeed A request
	        THEN
	            #sa_FiFo[#ci_FiFoLength] := 1;                                              // Set last FiFo entry to A
	            
	            FOR #si_LoopArrayCount := 1 TO (#ci_FiFoLength - 1) BY 1 DO                 // Set loop to process
	                IF #sa_FiFo[#si_LoopArrayCount] = 0                                     // Do when actual value is '0'
	                THEN
	                    #sa_FiFo[#si_LoopArrayCount] := #sa_FiFo[#si_LoopArrayCount + 1];   // copy next entry to actual
	                    #sa_FiFo[#si_LoopArrayCount + 1] := 0;                              // Reset next entry
	                END_IF;
	            END_FOR;
	            #sx_ReactivateA := FALSE;                                                   // Clear reactivation bit for conveyor A
	        END_IF;
	        
	        IF #sR_TRIG_ReceiveRequestConveyorB.Q                                           // Signal received from infeed B
	            OR #sx_ReactivateB                                                          // Reactivate infeed B request                                      
	        THEN
	            #sa_FiFo[#ci_FiFoLength] := 2;                                              // Set last FiFo entry to B
	            
	            FOR #si_LoopArrayCount := 1 TO (#ci_FiFoLength - 1) BY 1 DO                 // Set loop to process
	                IF #sa_FiFo[#si_LoopArrayCount] = 0                                     // Do when actual value is '0'
	                THEN
	                    #sa_FiFo[#si_LoopArrayCount] := #sa_FiFo[#si_LoopArrayCount + 1];   // copy next entry to actual
	                    #sa_FiFo[#si_LoopArrayCount + 1] := 0;                              // Reset next entry
	                END_IF;
	            END_FOR;
	            #sx_ReactivateB := FALSE;                                                   // Clear reactivation bit for conveyor B 
	        END_IF;
	        
	        IF #sR_TRIG_ReceiveRequestConveyorC.Q                                           // Signal received from infeed C
	            OR #sx_ReactivateC                                                          // Reactivate infeed C request
	        THEN
	            #sa_FiFo[#ci_FiFoLength] := 3;                                              // Set last FiFo entry to C
	            
	            FOR #si_LoopArrayCount := 1 TO (#ci_FiFoLength - 1) BY 1 DO                 // Set loop to process
	                IF #sa_FiFo[#si_LoopArrayCount] = 0                                     // Do when actual value is '0'
	                THEN
	                    #sa_FiFo[#si_LoopArrayCount] := #sa_FiFo[#si_LoopArrayCount + 1];   // copy next entry to actual
	                    #sa_FiFo[#si_LoopArrayCount + 1] := 0;                              // Reset next entry
	                END_IF;
	            END_FOR;
	            #sx_ReactivateC := FALSE;                                                   // Clear reactivation bit for conveyor C
	        END_IF;
	        
	        IF #sR_TRIG_ReceiveRequestConveyorD.Q                                           // Signal received from infeed D
	            OR #sx_ReactivateD                                                          // Reactivate infeed D request
	        THEN
	            #sa_FiFo[#ci_FiFoLength] := 4;                                              // Set last FiFo entry to D
	            
	            FOR #si_LoopArrayCount := 1 TO (#ci_FiFoLength - 1) BY 1 DO                 // Set loop to process
	                IF #sa_FiFo[#si_LoopArrayCount] = 0                                     // Do when actual value is '0'
	                THEN
	                    #sa_FiFo[#si_LoopArrayCount] := #sa_FiFo[#si_LoopArrayCount + 1];   // copy next entry to actual
	                    #sa_FiFo[#si_LoopArrayCount + 1] := 0;                              // Reset next entry
	                END_IF;
	            END_FOR;
	            #sx_ReactivateD := FALSE;                                                   // Clear reactivation bit for conveyor D
	        END_IF;
	    END_REGION
	    
	    REGION 7.3 - Start sequence, infeed conveyor request 
	        
	        REGION 7.3.1 - Start sequence, infeed conveyor request 
	            // If FiFo has an entry which is matching request, the request is rewarded and the sequence is started  
	            IF NOT #sx_Active                                               // Not activated yet
	                AND #sa_FiFo[1] <> 0                                        // There is a request in FiFo 1
	            THEN
	                IF #sa_FiFo[1] = #ci_ConveyorA                              // Conveyor A is infeed
	                    AND #ix_ExternalReceiveRequestA                         // Check if infeed A requested send
	                THEN
	                    #sx_InfeedCHK := TRUE;                                  // Infeed is checked
	                    #si_Conveyor := #ci_ConveyorA;                          // Set active infeed
	                    
	                ELSIF #sa_FiFo[1] = #ci_ConveyorB                           // Conveyor B is infeed
	                    AND #ix_ExternalReceiveRequestB                         // Check if infeed B requested send
	                THEN
	                    #sx_InfeedCHK := TRUE;                                  // Infeed is checked
	                    #si_Conveyor := #ci_ConveyorB;                          // Set active infeed
	                    
	                ELSIF #sa_FiFo[1] = #ci_ConveyorC                           // Conveyor C is infeed
	                    AND #ix_ExternalReceiveRequestC                         // Check if infeed C requested send
	                THEN
	                    #sx_InfeedCHK := TRUE;                                  // Infeed is checked
	                    #si_Conveyor := #ci_ConveyorC;                          // Set active infeed
	                    
	                ELSIF #sa_FiFo[1] = #ci_ConveyorD                           // Conveyor D is infeed
	                    AND #ix_ExternalReceiveRequestD                         // Check if infeed D requested send
	                THEN
	                    #sx_InfeedCHK := TRUE;                                  // Infeed is checked
	                    #si_Conveyor := #ci_ConveyorD;                          // Set active infeed
	                ELSE
	                    #sa_FiFo[1] := 0;                                       // No infeed request was matching
	                END_IF;
	                
	                IF #sx_InfeedCHK                                            // Infeed is checked
	                THEN
	                    #sx_Active := TRUE;                                     // Sequence is started
	                    #sa_FiFo[1] := 0;                                       // Reset entry D
	                    #si_Step := 1;                                          // Set step number for diagnostic purposes
	                END_IF;
	            END_IF;
	        END_REGION
	        
	        REGION 7.3.2 Receiving destination from input 
	            IF NOT #sx_DataReceived                                                                                             // Data is not yet received    
	                AND (#sx_LowerTransportIn AND (#sR_TRIG_PECInfeedA.Q OR #sR_TRIG_PECInfeedB.Q))                                 // Try to get data during lower infeed
	                OR (#sx_UpperTransportIn AND (#sR_TRIG_PECInfeedC.Q OR #sR_TRIG_PECInfeedD.Q))                                  // Try to get data during upper infeed
	                OR #sx_UpDown                                                                                                   // Infeed transport or waiting for data
	            THEN
	                IF #si_Conveyor = #ci_ConveyorA
	                THEN                                                                                        // Search destination for product from Conveyor A
	                    IF #ii_DestinationA <> 0
	                    THEN                                                                               // Destination is forced from output
	                        #si_Destination := #ii_DestinationA;
	                    ELSIF #sUDT_HandshakeBuffer.GIN <> 0
	                    THEN
	                        IF "DB_GIN".GIN[#sUDT_HandshakeBuffer.GIN].General.Destination[0] <> 0                                  // Destination is not forced from output and GIN is detected
	                        THEN
	                            #si_Destination := DINT_TO_INT("DB_GIN".GIN[#sUDT_HandshakeBuffer.GIN].General.Destination[0]);     // Divert product to the GIN destination
	                        END_IF;
	                    END_IF;
	                    
	                ELSIF #si_Conveyor = #ci_ConveyorB
	                THEN                                                                                     // Search destination for product from Conveyor B
	                    IF #ii_DestinationB <> 0
	                    THEN                                                                               // Destination is forced from output
	                        #si_Destination := #ii_DestinationB;
	                    ELSIF #sUDT_HandshakeBuffer.GIN <> 0
	                    THEN
	                        IF "DB_GIN".GIN[#sUDT_HandshakeBuffer.GIN].General.Destination[0] <> 0                                  // Destination is not forced from output and GIN is detected
	                        THEN
	                            #si_Destination := DINT_TO_INT("DB_GIN".GIN[#sUDT_HandshakeBuffer.GIN].General.Destination[0]);     // Divert product to the GIN destination
	                        END_IF;
	                    END_IF;
	                ELSIF #si_Conveyor = #ci_ConveyorC
	                THEN                                                                                     // Search destination for product from Conveyor C
	                    IF #ii_DestinationC <> 0
	                    THEN                                                                               // Destination is forced from output
	                        #si_Destination := #ii_DestinationC;
	                    ELSIF #sUDT_HandshakeBuffer.GIN <> 0
	                    THEN
	                        IF "DB_GIN".GIN[#sUDT_HandshakeBuffer.GIN].General.Destination[0] <> 0                                  // Destination is not forced from output and GIN is detected
	                        THEN
	                            #si_Destination := DINT_TO_INT("DB_GIN".GIN[#sUDT_HandshakeBuffer.GIN].General.Destination[0]);     // Divert product to the GIN destination
	                        END_IF;
	                    END_IF;
	                ELSIF #si_Conveyor = #ci_ConveyorD
	                THEN                                                                                     // Search destination for product from Conveyor D
	                    IF #ii_DestinationD <> 0
	                    THEN                                                                               // Destination is forced from output
	                        #si_Destination := #ii_DestinationD;
	                    ELSIF #sUDT_HandshakeBuffer.GIN <> 0
	                    THEN
	                        IF "DB_GIN".GIN[#sUDT_HandshakeBuffer.GIN].General.Destination[0] <> 0                                  // Destination is not forced from output and GIN is detected
	                        THEN
	                            #si_Destination := DINT_TO_INT("DB_GIN".GIN[#sUDT_HandshakeBuffer.GIN].General.Destination[0]);     // Divert product to the GIN destination
	                        END_IF;
	                    END_IF;
	                END_IF;
	                
	                IF #si_Destination > 0
	                THEN                                     // Destination is not '0'
	                    #sx_DataReceived := TRUE;                                   // Data is valid
	                END_IF;
	                
	                
	                // Destination received, set the appropriate bit 
	                
	                #sx_DestinationA := #sx_DataReceived AND (#iUDT_Configuration.ConveyorADestination = #si_Destination);
	                #sx_DestinationB := #sx_DataReceived AND (#iUDT_Configuration.ConveyorBDestination = #si_Destination);
	                #sx_DestinationC := #sx_DataReceived AND (#iUDT_Configuration.ConveyorCDestination = #si_Destination);
	                #sx_DestinationD := #sx_DataReceived AND (#iUDT_Configuration.ConveyorDDestination = #si_Destination);
	                
	                
	                // If destination is not configured then go to default destination
	                IF NOT #sx_DestinationA AND NOT #sx_DestinationB AND NOT #sx_DestinationC AND NOT #sx_DestinationD
	                THEN
	                    
	                    IF #iUDT_Configuration.DefaultDestination = #ci_ConveyorA
	                    THEN
	                        #sx_DestinationA := TRUE;
	                        #sx_DataReceived := TRUE;
	                    ELSIF #iUDT_Configuration.DefaultDestination = #ci_ConveyorB
	                    THEN
	                        #sx_DestinationB := TRUE;
	                        #sx_DataReceived := TRUE;
	                    ELSIF #iUDT_Configuration.DefaultDestination = #ci_ConveyorC
	                    THEN
	                        #sx_DestinationC := TRUE;
	                        #sx_DataReceived := TRUE;
	                    ELSIF #iUDT_Configuration.DefaultDestination = #ci_ConveyorD
	                    THEN
	                        #sx_DestinationD := TRUE;
	                        #sx_DataReceived := TRUE;
	                    END_IF;
	                END_IF;
	            END_IF;
	            
	        END_REGION
	        
	        REGION 7.3.3 - Lower infeed product tracking
	            
	            //Trigger from PEC-infeed A
	            IF #sR_TRIG_PECInfeedA.Q
	                AND #si_Conveyor = #ci_ConveyorA
	                AND #sx_LowerTransportIn
	                AND NOT #sx_ServoInfeed
	                AND NOT #sx_DisplacementInfeed
	            THEN
	                #sx_TrigPECInfeedA := TRUE;
	            END_IF;
	            
	            //Waiting for new postion from input, then setting end position
	            IF #sx_TrigPECInfeedA
	                AND #iqUDT_RATPositioning.Lower.StartPositionA <> 0
	                AND ((#sx_DataReceived
	                AND NOT #sx_DestinationB)
	                OR NOT #sx_DataReceived)
	            THEN
	                #sx_ServoInfeed := TRUE;
	                #iqUDT_RATPositioning.Lower.EndPosition := #iqUDT_RATPositioning.Lower.StartPositionA + #iUDT_Configuration.InfeedADistance;
	                #sx_TrigPECInfeedA := FALSE;
	                #iqUDT_RATPositioning.Lower.StartPositionA := 0;
	                #iqUDT_RATPositioning.Lower.PositionRequired := FALSE;
	                #iqUDT_RATPositioning.Lower.Start := TRUE;
	                
	                // If straight destination detected then use displacement mode
	            ELSIF #sx_TrigPECInfeedA
	                AND #sx_DataReceived
	                AND #sx_DestinationB
	            THEN
	                #si_LowerInfeedDistance := ABS(#iUDT_Configuration.InfeedADistance / 10);
	                #sx_TrigPECInfeedA := FALSE;
	                #sx_DisplacementInfeed := TRUE;
	                #iqUDT_RATPositioning.Lower.StartPositionA := 0;
	                #iqUDT_RATPositioning.Lower.PositionRequired := FALSE;
	            END_IF;
	            
	            //Trigger from PEC-infeed B    
	            IF #sR_TRIG_PECInfeedB.Q
	                AND #si_Conveyor = #ci_ConveyorB
	                AND #sx_LowerTransportIn
	                AND NOT #sx_ServoInfeed
	                AND NOT #sx_DisplacementInfeed
	            THEN
	                #sx_TrigPECInfeedB := TRUE;
	            END_IF;
	            
	            //Waiting for new postion from input, then setting end position
	            IF #sx_TrigPECInfeedB
	                AND #iqUDT_RATPositioning.Lower.StartPositionB <> 0
	                AND ((#sx_DataReceived
	                AND NOT #sx_DestinationA)
	                OR NOT #sx_DataReceived)
	            THEN
	                #sx_ServoInfeed := TRUE;
	                #iqUDT_RATPositioning.Lower.EndPosition := #iqUDT_RATPositioning.Lower.StartPositionB - #iUDT_Configuration.InfeedBDistance;
	                #sx_TrigPECInfeedB := FALSE;
	                #iqUDT_RATPositioning.Lower.StartPositionB := 0;
	                #iqUDT_RATPositioning.Lower.PositionRequired := FALSE;
	                #iqUDT_RATPositioning.Lower.Start := TRUE;
	                // If straight destination detected then use displacement mode
	            ELSIF #sx_TrigPECInfeedB
	                AND #sx_DataReceived
	                AND #sx_DestinationA
	            THEN
	                #si_LowerInfeedDistance := ABS(#iUDT_Configuration.InfeedBDistance / 10);
	                #sx_TrigPECInfeedB := FALSE;
	                #sx_DisplacementInfeed := TRUE;
	                #iqUDT_RATPositioning.Lower.StartPositionB := 0;
	                #iqUDT_RATPositioning.Lower.PositionRequired := FALSE;
	            END_IF;
	            
	            
	            //If position is reached, set ProductRecived
	            IF #sR_TRIG_LowerInfeedDone.Q
	                AND #sx_ServoInfeed
	            THEN
	                #sx_ProductReceivedDown := TRUE;
	                #iqUDT_RATPositioning.Lower.Start := FALSE;
	            END_IF;
	            
	            // During lower infeeding count distance to end of RAT 
	            IF #sx_LowerTransportIn AND
	                #sx_DisplacementInfeed
	                AND NOT #sx_ProductReceivedDown
	            THEN
	                #si_LowerInfeedDistance -= ABS(#iqUDT_LowerConveyorInterface.Displacement);
	                IF #si_LowerInfeedDistance <= 0
	                THEN
	                    #sx_ProductReceivedDown := TRUE;
	                END_IF;
	            END_IF;
	            
	        END_REGION
	        
	        REGION 7.3.4 - Upper infeed product tracking
	            
	            //Trigger from PEC-infeed C
	            IF #sR_TRIG_PECInfeedC.Q
	                AND #si_Conveyor = #ci_ConveyorC
	                AND #sx_UpperTransportIn
	                AND NOT #sx_ServoInfeed
	                AND NOT #sx_DisplacementInfeed
	            THEN
	                #sx_TrigPECInfeedC := TRUE;
	            END_IF;
	            
	            //Waiting for new postion from input, then setting end position
	            IF #sx_TrigPECInfeedC
	                AND #iqUDT_RATPositioning.Upper.StartPositionC <> 0
	                AND ((#sx_DataReceived
	                AND NOT #sx_DestinationD)
	                OR NOT #sx_DataReceived)
	            THEN
	                #sx_ServoInfeed := TRUE;
	                #iqUDT_RATPositioning.Upper.EndPosition := #iqUDT_RATPositioning.Upper.StartPositionC + #iUDT_Configuration.InfeedCDistance;
	                #sx_TrigPECInfeedC := FALSE;
	                #iqUDT_RATPositioning.Upper.StartPositionC := 0;
	                #iqUDT_RATPositioning.Upper.PositionRequired := FALSE;
	                #iqUDT_RATPositioning.Upper.Start := TRUE;
	                // If straight destination detected then use displacement mode
	            ELSIF #sx_TrigPECInfeedC
	                AND #sx_DataReceived
	                AND #sx_DestinationD
	            THEN
	                #si_UpperInfeedDistance := ABS(#iUDT_Configuration.InfeedCDistance / 10);
	                #sx_TrigPECInfeedC := FALSE;
	                #sx_DisplacementInfeed := TRUE;
	                #iqUDT_RATPositioning.Upper.StartPositionC := 0;
	                #iqUDT_RATPositioning.Upper.PositionRequired := FALSE;
	            END_IF;
	            
	            //Trigger from PEC-infeed D    
	            IF #sR_TRIG_PECInfeedD.Q
	                AND #si_Conveyor = #ci_ConveyorD
	                AND #sx_UpperTransportIn
	                AND NOT #sx_ServoInfeed
	                AND NOT #sx_DisplacementInfeed
	            THEN
	                #sx_TrigPECInfeedD := TRUE;
	            END_IF;
	            
	            //Waiting for new postion from input, then setting end position
	            IF #sx_TrigPECInfeedD
	                AND #iqUDT_RATPositioning.Upper.StartPositionD <> 0
	                AND ((#sx_DataReceived
	                AND NOT #sx_DestinationC)
	                OR NOT #sx_DataReceived)
	            THEN
	                #sx_ServoInfeed := TRUE;
	                #iqUDT_RATPositioning.Upper.EndPosition := #iqUDT_RATPositioning.Upper.StartPositionD - #iUDT_Configuration.InfeedDDistance;
	                #sx_TrigPECInfeedD := FALSE;
	                #iqUDT_RATPositioning.Upper.StartPositionD := 0;
	                #iqUDT_RATPositioning.Upper.PositionRequired := FALSE;
	                #iqUDT_RATPositioning.Upper.Start := TRUE;
	                // If straight destination detected then use displacement mode
	            ELSIF #sx_TrigPECInfeedD
	                AND #sx_DataReceived
	                AND #sx_DestinationC
	            THEN
	                #si_UpperInfeedDistance := ABS(#iUDT_Configuration.InfeedDDistance / 10);
	                #sx_TrigPECInfeedD := FALSE;
	                #sx_DisplacementInfeed := TRUE;
	                #iqUDT_RATPositioning.Upper.StartPositionD := 0;
	                #iqUDT_RATPositioning.Upper.PositionRequired := FALSE;
	            END_IF;
	            
	            //If position is reached, set ProductRecived
	            IF #sR_TRIG_UpperInfeedDone.Q
	                AND #sx_ServoInfeed
	            THEN
	                #sx_ProductReceivedUp := TRUE;
	                #iqUDT_RATPositioning.Upper.Start := FALSE;
	            END_IF;
	            
	            // During upper infeeding count distance to end of RAT 
	            IF #sx_UpperTransportIn AND
	                #sx_DisplacementInfeed
	                AND NOT #sx_ProductReceivedUp
	            THEN
	                #si_UpperInfeedDistance -= ABS(#iqUDT_UpperConveyorInterface.Displacement);
	                IF #si_UpperInfeedDistance <= 0
	                THEN
	                    #sx_ProductReceivedUp := TRUE;
	                END_IF;
	            END_IF;
	            
	        END_REGION
	        
	    END_REGION
	    
	    REGION 7.4 - Infeed checked, go to infeed level
	        // Lower
	        IF #sx_AutomaticActive                                          // The device is automaticly started
	            AND #sx_Ready                                               // The device is ready to opereate
	            AND #sx_Active                                              // The sequence is started
	            AND #sx_InfeedCHK                                           // Step infeed check is active
	            AND ((#si_Conveyor = #ci_ConveyorA) OR #si_Conveyor = #ci_ConveyorB)// Infeed is on low level
	        THEN
	            #sx_MoveSectionDownInfeed := TRUE;                          // Move section down
	            #sx_InfeedCHK := FALSE;                                     // Reset step infeed check
	            #si_Step := 2;                                              // Set step number for diagnostic purposes
	            // Upper    
	        ELSIF #sx_AutomaticActive                                       // The device is automaticly started
	            AND #sx_Ready                                               // The device is ready to opereate
	            AND #sx_Active                                              // The sequence is started
	            AND #sx_InfeedCHK                                           // Step infeed check is active
	            AND ((#si_Conveyor = #ci_ConveyorC) OR #si_Conveyor = #ci_ConveyorD) // Infeed is on high level
	        THEN
	            #sx_MoveSectionUpinfeed := TRUE;                            // Move section up
	            #sx_InfeedCHK := FALSE;                                     // Reset step infeed check
	            #si_Step := 2;                                              // Set step number for diagnostic purposes
	        END_IF;
	    END_REGION
	    
	    REGION 7.5 - At infeed level, start infeed transport
	        // Lower
	        IF #sx_AutomaticActive                                          // The device is automaticly started
	            AND #sx_Ready                                               // The device is ready to opereate
	            AND #sx_Active                                              // The sequence is started
	            AND (#ix_SectionIsDown                                      // Section is actual down
	            OR (#sx_SectionDown                                         // or request to go down is set and configuration allows it
	            AND NOT #iUDT_Configuration.PositionVerification))
	            AND #sx_MoveSectionDownInfeed                               // Step move down to infeed was activated 
	        THEN
	            #sx_MoveSectionDownInfeed := FALSE;                         // Reset step move down to infeed level
	            #sx_LowerTransportIn := TRUE;                               // Start infeed roller transport
	            #iqUDT_RATPositioning.Lower.PositionRequired := TRUE;
	            #sx_LowerRTR := TRUE;                                       // Set RTR to infeed until TIP gets active
	            #si_Step := 3;                                              // Set step number for diagnostic purposes
	            // Upper    
	        ELSIF #sx_AutomaticActive                                       // The device is automaticly started
	            AND #sx_Ready                                               // The device is ready to opereate
	            AND #sx_Active                                              // The sequence is started
	            AND (#ix_SectionIsUp                                        // Section is actual up
	            OR (#sx_SectionUp                                           // or request to go up is set and configuration allows it
	            AND NOT #iUDT_Configuration.PositionVerification))
	            AND #sx_MoveSectionUpinfeed                                 // Step move up to infeed was activated 
	            //     AND #iqUDT_UpperConveyorInterface.ActualSpeed = 0
	        THEN
	            #sx_MoveSectionUpinfeed := FALSE;                           // Reset step move up to infeed level
	            #sx_UpperTransportIn := TRUE;                               // Start infeed belt transport
	            #iqUDT_RATPositioning.Upper.PositionRequired := TRUE;
	            #sx_UpperRTR := TRUE;                                       // Set RTR to infeed until TIP gets active
	            #si_Step := 3;                                              // Set step number for diagnostic purposes
	            
	        END_IF;
	    END_REGION
	    
	    REGION 7.6 - Stop transport, wait for destnation
	        
	        // Lower
	        IF #sx_AutomaticActive                                          // The device is automaticly started
	            AND #sx_Ready                                               // The device is ready to opereate
	            AND #sx_Active                                              // The sequence is started
	            AND #sx_LowerTransportIn                                    // Step infeed lower transport is active
	            AND (NOT #sx_PECFiltered OR NOT #iUDT_Configuration.ControlProductWithPEC)                                     // Position is occupied
	            AND #sx_ProductReceivedDown                                // Product available at the end of RAT
	            
	        THEN
	            #sx_LowerTransportIn := FALSE;                              // Reset step infeed lower transport
	            #sx_LowerRTR := FALSE;                                      // Reset RTR signal for infeed conveyor
	            #sx_UpDown := TRUE;                                         // Wait for direction
	            #sx_ProductReceivedDown := FALSE;                           // Reset "product received" bit
	            #sx_ServoInfeed := FALSE;
	            #sx_DisplacementInfeed := FALSE;
	            #si_Step := 4;                                              // Set step number for diagnostic purposes
	            
	            // Upper    
	        ELSIF #sx_AutomaticActive                                       // The device is automaticly started
	            AND #sx_Ready                                               // The device is ready to opereate
	            AND #sx_Active                                              // The sequence is started
	            AND #sx_UpperTransportIn                                    // Step infeed belt transport is active
	            AND (NOT #sx_PECFiltered OR NOT #iUDT_Configuration.ControlProductWithPEC)                                      // Position is occupied
	            AND #sx_ProductReceivedUp                                  // Product available at the end of RAT
	        THEN
	            #sx_UpperTransportIn := FALSE;                              // Reset step infeed belttransport
	            #sx_UpperRTR := FALSE;                                      // Reset RTR signal for infeed conveyor
	            #sx_UpDown := TRUE;                                         // Wait for direction
	            #sx_ProductReceivedUp := FALSE;                             // Reset "product received" bit
	            #sx_ServoInfeed := FALSE;
	            #sx_DisplacementInfeed := FALSE;
	            #si_Step := 4;                                              // Set step number for diagnostic purposes
	            
	        END_IF;
	    END_REGION
	    
	    REGION 7.7 - Destination received, move to outfeed level
	        IF #sx_AutomaticActive                                                  // The device is automaticly started
	            AND #sx_Ready                                                       // The device is ready to opereate
	            AND #sx_Active                                                      // The sequence is started
	            AND #sx_UpDown                                                      // Wait for direction
	            AND #sx_DataReceived                                                // Direction is received
	        THEN
	            #sx_UpDown := FALSE;                                                // Wait for direction
	            #sx_MoveSectionDownOutfeed := #sx_DestinationA OR #sx_DestinationB; // Depending on outfeed conveyor section is moved to outfeed level
	            #sx_MoveSectionUpOutfeed := #sx_DestinationC OR #sx_DestinationD;   // Depending on outfeed conveyor section is moved to outfeed level
	            #si_Step := 5;                                                      // Set step number for diagnostic purposes
	        END_IF;
	    END_REGION
	    
	    
	    REGION 7.8 - At outfeed level, start outfeed transport
	        // Lower
	        IF #sx_AutomaticActive                                          // The device is automaticly started
	            AND #sx_Ready                                               // The device is ready to opereate
	            AND #sx_Active                                              // The sequence is started
	            AND #sx_MoveSectionDownOutfeed                              // Step move down to outfeed is active
	            AND (#ix_SectionIsDown                                      // Section is actual down
	            OR (#sx_SectionDown                                         // or request to go down is set and configuration allows it
	            AND NOT #iUDT_Configuration.PositionVerification))
	        THEN
	            #sx_MoveSectionDownOutfeed := FALSE;                        // Reset step move down to outfeed
	            #sx_LowerTransportOut := TRUE;                              // Start outfeed roller transport
	            #si_LowerOutfeedDistance := DINT_TO_INT(#iUDT_LowerConveyorConfiguration.Common.Length / 10);
	            #si_Step := 6;                                              // Set step number for diagnostic purposes
	            // Upper    
	        ELSIF #sx_AutomaticActive                                       // The device is automaticly started
	            AND #sx_Ready                                               // The device is ready to opereate
	            AND #sx_Active                                              // The sequence is startede
	            AND #sx_MoveSectionUpOutfeed                                // Step move up to outfeed is active
	            AND (#ix_SectionIsUp                                        // Section is actual up
	            OR (#sx_SectionUp                                          // or request to go up is set and configuration allows it
	            AND NOT #iUDT_Configuration.PositionVerification))
	        THEN
	            #sx_MoveSectionUpOutfeed := FALSE;                          // Reset step move up to outfeed
	            #sx_UpperTransportOut := TRUE;                              // Start outfeed belt transport
	            #si_UpperOutfeedDistance := DINT_TO_INT(#iUDT_UpperConveyorConfiguration.Common.Length / 10);
	            #si_Step := 6;                                              // Set step number for diagnostic purposes
	        END_IF;
	    END_REGION
	    
	    
	    REGION 7.9 Outfeed product tracking 
	        
	        IF #sx_LowerTransportOut AND NOT #sx_ProductSentDown
	        THEN
	            #si_LowerOutfeedDistance -= ABS(#iqUDT_LowerConveyorInterface.Displacement);
	            IF #si_LowerOutfeedDistance <= 0
	            THEN
	                #sx_ProductSentDown := TRUE;
	            END_IF;
	        END_IF;
	        
	        // Upper
	        IF #sx_UpperTransportOut AND NOT #sx_ProductSentUp
	        THEN
	            #si_UpperOutfeedDistance -= ABS(#iqUDT_UpperConveyorInterface.Displacement);
	            IF #si_UpperOutfeedDistance <= 0
	            THEN
	                #sx_ProductSentUp := TRUE;
	            END_IF;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 7.9 - End sequence
	        IF #sx_AutomaticActive                                          // The device is automaticly started
	            AND #sx_Ready                                               // The device is ready to opereate
	            AND #sx_Active                                              // The sequence is started
	            AND ((#sx_LowerTransportOut AND #sx_ProductSentDown)        // Outfeed transport is active and Produce is away
	            OR (#sx_UpperTransportOut AND #sx_ProductSentUp))           // Outfeed transport is active and Produce is away
	            AND (#sx_PECFiltered OR NOT #iUDT_Configuration.ControlProductWithPEC)                                          // Position is cleared
	            OR #sFB_InfeedTimeout.qx_DelayedSignal                      // Operation time elapsed
	        THEN
	            
	            // Reset all auxiliary bits and variables
	            #sx_LowerTransportOut := FALSE;
	            #sx_UpperTransportOut := FALSE;
	            #si_Conveyor := 0;
	            #sx_Active := FALSE;
	            #sx_DataReceived := FALSE;
	            #si_Step := 0;
	            IF #sx_DestinationA
	            THEN
	                #sx_DestinationA := FALSE;
	                #iqUDT_HandShakeConveyorA.GIN := 0;
	                #iqUDT_HandShakeConveyorA.NrOfPosToShift := 0;
	                #iqUDT_HandShakeConveyorA.TIP := FALSE;
	            END_IF;
	            IF #sx_DestinationB
	            THEN
	                #sx_DestinationB := FALSE;
	                #iqUDT_HandShakeConveyorB.GIN := 0;
	                #iqUDT_HandShakeConveyorB.NrOfPosToShift := 0;
	                #iqUDT_HandShakeConveyorB.TIP := FALSE;
	            END_IF;
	            IF #sx_DestinationC
	            THEN
	                #sx_DestinationC := FALSE;
	                #iqUDT_HandShakeConveyorC.GIN := 0;
	                #iqUDT_HandShakeConveyorC.NrOfPosToShift := 0;
	                #iqUDT_HandShakeConveyorC.TIP := FALSE;
	            END_IF;
	            IF #sx_DestinationD
	            THEN
	                #sx_DestinationD := FALSE;
	                #iqUDT_HandShakeConveyorD.GIN := 0;
	                #iqUDT_HandShakeConveyorD.NrOfPosToShift := 0;
	                #iqUDT_HandShakeConveyorD.TIP := FALSE;
	            END_IF;
	            #iqUDT_HandShakeConveyorA.RTR := FALSE;
	            #iqUDT_HandShakeConveyorB.RTR := FALSE;
	            #iqUDT_HandShakeConveyorC.RTR := FALSE;
	            #iqUDT_HandShakeConveyorD.RTR := FALSE;
	            
	            #si_Destination := 0;
	            #sx_ProductReceivedDown := FALSE;
	            #sx_ProductReceivedUp := FALSE;
	            #sx_ProductSentDown := FALSE;
	            #sx_ProductSentUp := FALSE;
	            #iqUDT_RATPositioning.Lower.ResetPosition := TRUE;
	            #iqUDT_RATPositioning.Upper.ResetPosition := TRUE;
	            #iqUDT_RATPositioning.Lower.StartPositionA := 0;
	            #iqUDT_RATPositioning.Lower.StartPositionB := 0;
	            #iqUDT_RATPositioning.Upper.StartPositionC := 0;
	            #iqUDT_RATPositioning.Upper.StartPositionD := 0;
	            #iqUDT_RATPositioning.Lower.PositionRequired := FALSE;
	            #iqUDT_RATPositioning.Upper.PositionRequired := FALSE;
	            
	            // Move to configured default position
	            IF #iUDT_Configuration.DefaultPosition = #ci_DefaultPositionUp
	                AND #ix_SectionIsUp                                     // Section is actual up    
	                AND #sa_FiFo[1] = 0
	            THEN
	                #sx_MoveSectiondownEnd := TRUE;                         // Then move down to infeed
	            END_IF;
	            IF #iUDT_Configuration.DefaultPosition = #ci_DefaultPositiondown
	                AND #ix_SectionIsDown                                   // Section is actual down    
	                AND #sa_FiFo[1] = 0
	            THEN
	                #sx_MoveSectionUpEnd := TRUE;                           // Then move down to infeed
	            END_IF;
	        END_IF;
	        // Reset when on position
	        IF #sx_MoveSectionUpEnd                                         // Reset Up request when up
	            AND #ix_SectionIsUp
	        THEN
	            #sx_MoveSectionUpEnd := False;
	        END_IF;
	        
	        IF #sx_MoveSectiondownEnd                                       // Reset down request when down
	            AND #ix_SectionIsDown
	        THEN
	            #sx_MoveSectiondownEnd := False;
	        END_IF;
	        
	    END_REGION
	END_REGION
	
	REGION 8 - Output
	    REGION 8.1 - Lifting device
	        
	        // Conditions to move sention down
	        #sx_SectionDown := (#sx_AutomaticActive
	        AND
	        ((#sx_MoveSectionDownInfeed OR #sx_MoveSectionDownOutfeed OR #sx_MoveSectiondownEnd))
	        OR (#sx_ManualModeActive AND #sx_ManualGoDown));
	        // Conditions to move sention up
	        #sx_SectionUp := (#sx_AutomaticActive
	        AND
	        ((#sx_MoveSectionUpinfeed OR #sx_MoveSectionUpOutfeed OR #sx_MoveSectionUpEnd))
	        OR (#sx_ManualModeActive AND #sx_ManualGoUp));
	        
	        // Write valve outputs
	        IF #sx_SectionUp
	        THEN
	            #qx_PopupControl := TRUE;
	        ELSIF #sx_SectionDown
	        THEN
	            #qx_PopupControl := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 8.2 - Lower conveyor
	        
	        // Run forward 
	        #tx_LowerConveyorRunFwd :=
	        ((#sx_LowerTransportIn AND (#si_Conveyor = #ci_ConveyorA) AND #ix_ConveyorAAuto)                                    // Transport in and transporting from infeed A
	        OR (#sx_LowerTransportOut AND #sx_DestinationB AND #iqUDT_HandShakeConveyorB.RTR))                      // Transport out and RTR is received
	        AND #sx_AutomaticActive;
	        
	        // Run reverse 
	        #tx_LowerConveyorRunRvs :=
	        ((#sx_LowerTransportIn AND (#si_Conveyor = #ci_ConveyorB) AND #ix_ConveyorBAuto)                                     // Transport in and transporting from infeed B
	        OR (#sx_LowerTransportOut AND #sx_DestinationA AND #iqUDT_HandShakeConveyorA.RTR))                      // Transport out AND RTR is received
	        AND #sx_AutomaticActive;
	        // Handshake RTR mapping
	        #sUDT_HandshakeUpLowerConveyor.RTR := #tx_LowerConveyorRunRvs;
	        #sUDT_HandshakeLowerConveyor.RTR := #tx_LowerConveyorRunFwd;
	        
	        IF #tx_LowerConveyorRunRvs THEN
	            #sx_ReverseLower := TRUE;
	        END_IF;
	        
	        IF #tx_LowerConveyorRunFwd THEN
	            #sx_ReverseLower := FALSE;
	        END_IF;
	        
	        // Control lower conveyor with FB_Conveyor block
	        #sFB_Conveyor_LowerConveyor(iUDT_ConveyorConfiguration := #iUDT_LowerConveyorConfiguration,
	                                    ix_SafetyOk := #ix_SafetyOk,
	                                    ix_24vOk := #ix_24vOk,
	                                    ix_400vOk := #ix_400vOk,
	                                    ix_HardwareOk := #ix_HardwareOk,
	                                    ix_ReverseDirection := #sx_ReverseLower,
	                                    ix_ResetEnergySave := TRUE,
	                                    qUDT_HMIStatus => #qUDT_HMIConveyorStatus,
	                                    qUDT_Status => #qUDT_ConveyorStatus,
	                                    iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                    iqUDT_ConveyorCommand := #iqUDT_ConveyorCommand,
	                                    iqUDT_ConveyorInterface := #iqUDT_LowerConveyorInterface,
	                                    iqUDT_HandShakeUp := #sUDT_HandshakeUpLowerConveyor,
	                                    iqUDT_HandShake := #sUDT_HandshakeLowerConveyor,
	                                    iqUDT_Statistics := #iqUDT_ConveyorStatistics);
	        
	    END_REGION
	    
	    REGION 8.3 - Upper conveyor
	        
	        // Run forward 
	        #tx_UpperConveyorRunFwd :=
	        ((#sx_UpperTransportIn AND (#si_Conveyor = #ci_ConveyorC) AND #ix_ConveyorCAuto)                                                  // Transport in and transporting from infeed C c
	        OR (#sx_UpperTransportOut AND #sx_DestinationD AND #iqUDT_HandShakeConveyorD.RTR))             // Transport out and RTR is received
	        AND #sx_AutomaticActive;
	        
	        // Run reverse 
	        #tx_UpperConveyorRunRvs :=
	        ((#sx_UpperTransportIn AND (#si_Conveyor = #ci_ConveyorD) AND #ix_ConveyorDAuto)                                                   // Transport in and transporting from infeed D
	        OR (#sx_UpperTransportOut AND #sx_DestinationC AND #iqUDT_HandShakeConveyorC.RTR))              // Transport out and RTR is received
	        AND #sx_AutomaticActive;
	        
	        // Handshake RTR mapping
	        #sUDT_HandshakeUpUpperConveyor.RTR := #tx_UpperConveyorRunRvs;
	        #sUDT_HandshakeUpperConveyor.RTR := #tx_UpperConveyorRunFwd;
	        
	        
	        // MAnual mode mapping from RAT structure
	        #tUDT_ConveyorCommandUpper.ManualMode := #iqUDT_RATCommand.ManualMode;
	        #tUDT_ConveyorCommandUpper.ManualStartStop := #iqUDT_RATCommand.ManualStartStop;
	        #tUDT_ConveyorCommandUpper.ManualFullSpeed := #iqUDT_RATCommand.ManualFullSpeed;
	        #tUDT_ConveyorCommandUpper.ManualSpeed := #iqUDT_RATCommand.ManualSpeed;
	        #tUDT_ConveyorCommandUpper.ManualJog := #iqUDT_RATCommand.ManualJog;
	        #tUDT_ConveyorCommandUpper.Reverse := #iqUDT_RATCommand.Reverse;
	        
	        IF #tx_UpperConveyorRunRvs
	        THEN
	            #sx_ReverseUpper := TRUE;
	        END_IF;
	        
	        IF #tx_UpperConveyorRunFwd
	        THEN
	            #sx_ReverseUpper := FALSE;
	        END_IF;
	        
	        // Control pop-up conveyor with FB_Conveyor block
	        #sFB_Conveyor_UpperConveyor(iUDT_ConveyorConfiguration := #iUDT_UpperConveyorConfiguration,
	                                    ix_SafetyOk := #ix_SafetyOk,
	                                    ix_24vOk := #ix_24vOk,
	                                    ix_400vOk := #ix_400vOk,
	                                    ix_HardwareOk := #ix_HardwareOk,
	                                    ix_ReverseDirection := #sx_ReverseUpper,
	                                    ix_ExternalRequestDieBack := FALSE,
	                                    ix_ResetEnergySave := TRUE,
	                                    qUDT_HMIStatus => #tUDT_HMIStatus,
	                                    qUDT_Status => #tUDT_CommonStatus,
	                                    iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                    iqUDT_ConveyorCommand := #tUDT_ConveyorCommandUpper,
	                                    iqUDT_ConveyorInterface := #iqUDT_UpperConveyorInterface,
	                                    iqUDT_HandShakeUp := #sUDT_HandshakeUpUpperConveyor,
	                                    iqUDT_HandShake := #sUDT_HandshakeUpperConveyor,
	                                    iqUDT_Statistics := #tUDT_ConveyorStatistics);
	        
	        // Manual mode mapping from conveyor to RAT
	        #iqUDT_RATCommand.ManualMode := #tUDT_ConveyorCommandUpper.ManualMode;
	        #iqUDT_RATCommand.ManualStartStop := #tUDT_ConveyorCommandUpper.ManualStartStop;
	        #iqUDT_RATCommand.ManualFullSpeed := #tUDT_ConveyorCommandUpper.ManualFullSpeed;
	        #iqUDT_RATCommand.ManualSpeed := #tUDT_ConveyorCommandUpper.ManualSpeed;
	        #iqUDT_RATCommand.ManualJog := #tUDT_ConveyorCommandUpper.ManualJog;
	        
	    END_REGION
	    
	    
	    REGION 8.4 - Handshake in-outfeed conveyors 
	        
	        #iqUDT_HandShakeConveyorA.RTR := FALSE;
	        #iqUDT_HandShakeConveyorB.RTR := FALSE;
	        #iqUDT_HandShakeConveyorC.RTR := FALSE;
	        #iqUDT_HandShakeConveyorD.RTR := FALSE;
	        
	        IF (#si_Conveyor = 1)
	        THEN
	            // Infeed conveyor low level
	            #iqUDT_HandShakeConveyorA.CascadeStartUp := #sx_AutomaticActive;
	            #iqUDT_HandShakeConveyorA.RTR := (#sx_LowerRTR OR #iqUDT_HandShakeConveyorA.TIP) AND #sx_AutomaticActive;
	            #iqUDT_HandShakeConveyorA.ResetEnergySave := false;
	            
	            IF #sx_LowerTransportIn
	            THEN
	                IF #iqUDT_HandShakeConveyorA.GIN <> 0
	                THEN                          // Save gin number in buffer
	                    #sUDT_HandshakeBuffer.GIN := #iqUDT_HandShakeConveyorA.GIN;
	                END_IF;
	                
	                // Count number position to shift in buffer
	                #sUDT_HandshakeBuffer.NrOfPosToShift += #iqUDT_HandShakeConveyorA.NrOfPosToShift;
	                #iqUDT_HandShakeConveyorA.NrOfPosToShift := 0;
	            END_IF;
	            
	        ELSE
	            // Outfeed conveyor low level 
	            #qx_ExternalSendRequestA := #sx_DestinationA AND NOT #sFB_PEC.qx_PECFiltered;// AND #sx_LowerTransportOut;
	            IF #sx_LowerTransportOut AND #sx_DestinationA
	            THEN
	                IF #sR_TRIG_LowerOutfeedRunning.Q
	                THEN
	                    #iqUDT_HandShakeConveyorA.GIN := #sUDT_HandshakeBuffer.GIN;
	                    #iqUDT_HandShakeConveyorA.NrOfPosToShift := #sUDT_HandshakeBuffer.NrOfPosToShift;
	                    #sUDT_HandshakeBuffer.GIN := 0;
	                    #sUDT_HandshakeBuffer.NrOfPosToShift := 0;
	                END_IF;
	                
	                IF #ix_PEC
	                THEN
	                    #iqUDT_HandShakeConveyorA.GIN := 0;
	                    #iqUDT_HandShakeConveyorA.NrOfPosToShift := 0;
	                END_IF;
	            END_IF;
	            
	        END_IF;
	        
	        IF (#si_Conveyor = 2)
	        THEN
	            // Infeed conveyor low level
	            #iqUDT_HandShakeConveyorB.CascadeStartUp := #sx_AutomaticActive;
	            #iqUDT_HandShakeConveyorB.RTR := (#sx_LowerRTR OR #iqUDT_HandShakeConveyorB.TIP) AND #sx_AutomaticActive;
	            #iqUDT_HandShakeConveyorB.ResetEnergySave := false;
	            IF #sx_LowerTransportIn
	            THEN
	                IF #iqUDT_HandShakeConveyorB.GIN <> 0
	                THEN
	                    #sUDT_HandshakeBuffer.GIN := #iqUDT_HandShakeConveyorB.GIN;
	                END_IF;
	                
	                #sUDT_HandshakeBuffer.NrOfPosToShift += #iqUDT_HandShakeConveyorB.NrOfPosToShift;
	                #iqUDT_HandShakeConveyorB.NrOfPosToShift := 0;
	            END_IF;
	        ELSE
	            // Outfeed conveyor low level
	            #qx_ExternalSendRequestB := #sx_DestinationB AND NOT #sFB_PEC.qx_PECFiltered;// AND #sx_LowerTransportOut;
	            IF #sx_DestinationB AND #sx_LowerTransportOut
	            THEN
	                IF #sR_TRIG_LowerOutfeedRunning.Q
	                THEN
	                    #iqUDT_HandShakeConveyorB.GIN := #sUDT_HandshakeBuffer.GIN;
	                    #iqUDT_HandShakeConveyorB.NrOfPosToShift := #sUDT_HandshakeBuffer.NrOfPosToShift;
	                    #sUDT_HandshakeBuffer.GIN := 0;
	                    #sUDT_HandshakeBuffer.NrOfPosToShift := 0;
	                END_IF;
	                
	                IF #ix_PEC
	                THEN
	                    #iqUDT_HandShakeConveyorB.GIN := 0;
	                    #iqUDT_HandShakeConveyorB.NrOfPosToShift := 0;
	                    
	                END_IF;
	                
	            END_IF;
	        END_IF;
	        
	        IF (#si_Conveyor = 3)
	        THEN
	            // Infeed conveyor high level
	            #iqUDT_HandShakeConveyorC.CascadeStartUp := #sx_AutomaticActive;
	            #iqUDT_HandShakeConveyorC.RTR := (#sx_UpperRTR OR #iqUDT_HandShakeConveyorC.TIP) AND #sx_AutomaticActive;
	            #iqUDT_HandShakeConveyorC.ResetEnergySave := false;
	            IF #sx_UpperTransportIn
	            THEN
	                IF #iqUDT_HandShakeConveyorC.GIN <> 0
	                THEN
	                    #sUDT_HandshakeBuffer.GIN := #iqUDT_HandShakeConveyorC.GIN;
	                END_IF;
	                
	                #sUDT_HandshakeBuffer.NrOfPosToShift += #iqUDT_HandShakeConveyorC.NrOfPosToShift;
	                #iqUDT_HandShakeConveyorC.NrOfPosToShift := 0;
	            END_IF;
	        ELSE
	            // Outfeed conveyor high level 
	            #qx_ExternalSendRequestC := #sx_DestinationC AND NOT #sFB_PEC.qx_PECFiltered;// AND #sx_LowerTransportOut;
	            IF #sx_DestinationC AND #sx_UpperTransportOut
	            THEN
	                IF #sR_TRIG_UpperOutfeedRunning.Q
	                THEN
	                    #iqUDT_HandShakeConveyorC.GIN := #sUDT_HandshakeBuffer.GIN;
	                    #iqUDT_HandShakeConveyorC.NrOfPosToShift := #sUDT_HandshakeBuffer.NrOfPosToShift;
	                    #sUDT_HandshakeBuffer.GIN := 0;
	                    #sUDT_HandshakeBuffer.NrOfPosToShift := 0;
	                END_IF;
	                IF #ix_PEC
	                THEN
	                    #iqUDT_HandShakeConveyorC.GIN := 0;
	                    #iqUDT_HandShakeConveyorC.NrOfPosToShift := 0;
	                END_IF;
	                
	            END_IF;
	            
	        END_IF;
	        
	        IF (#si_Conveyor = 4)
	        THEN
	            // Infeed conveyor high level
	            #iqUDT_HandShakeConveyorD.CascadeStartUp := #sx_AutomaticActive;
	            #iqUDT_HandShakeConveyorD.RTR := (#sx_UpperRTR OR #iqUDT_HandShakeConveyorD.TIP) AND #sx_AutomaticActive;
	            #iqUDT_HandShakeConveyorD.ResetEnergySave := false;
	            IF #sx_UpperTransportIn
	            THEN
	                IF #iqUDT_HandShakeConveyorD.GIN <> 0
	                THEN
	                    #sUDT_HandshakeBuffer.GIN := #iqUDT_HandShakeConveyorD.GIN;
	                END_IF;
	                
	                #sUDT_HandshakeBuffer.NrOfPosToShift += #iqUDT_HandShakeConveyorD.NrOfPosToShift;
	                #iqUDT_HandShakeConveyorD.NrOfPosToShift := 0;
	            END_IF;
	        ELSE
	            // Outfeed conveyor high level 
	            #qx_ExternalSendRequestD := #sx_DestinationD AND NOT #sFB_PEC.qx_PECFiltered;// AND #sx_LowerTransportOut;
	            IF #sx_DestinationD AND #sx_UpperTransportOut
	            THEN
	                IF #sR_TRIG_UpperOutfeedRunning.Q
	                THEN
	                    #iqUDT_HandShakeConveyorD.GIN := #sUDT_HandshakeBuffer.GIN;
	                    #iqUDT_HandShakeConveyorD.NrOfPosToShift := #sUDT_HandshakeBuffer.NrOfPosToShift;
	                    #sUDT_HandshakeBuffer.GIN := 0;
	                    #sUDT_HandshakeBuffer.NrOfPosToShift := 0;
	                END_IF;
	                
	                IF #ix_PEC
	                THEN
	                    #iqUDT_HandShakeConveyorD.GIN := 0;
	                    #iqUDT_HandShakeConveyorD.NrOfPosToShift := 0;
	                END_IF;
	                
	            END_IF;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 8.5 - Blade stop EoS
	        // If blade stop is available then handle valve
	        IF #iUDT_Configuration.BladeStopEoS
	        THEN
	            // Use blade stop if product is comming from A to side destination
	            IF #si_Conveyor = #ci_ConveyorA AND (#sx_DestinationC OR #sx_DestinationD) AND #sx_LowerTransportIn
	            THEN
	                #sx_BladeStopEoSControl := TRUE;
	            END_IF;
	            IF NOT #sx_LowerTransportIn
	            THEN
	                #sx_BladeStopEoSControl := FALSE;
	            END_IF;
	            #iqUDT_BladeStopEoSInterface.Open := #sx_BladeStopEoSControl;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 8.6 - Blade stop BoS
	        IF #iUDT_Configuration.BladeStopBoS
	        THEN
	            // Use blade stop if product is comming from B to side destination
	            IF #si_Conveyor = #ci_ConveyorB AND (#sx_DestinationC OR #sx_DestinationD) AND #sx_LowerTransportIn
	            THEN
	                #sx_BladeStopBoSControl := TRUE;
	            END_IF;
	            IF NOT #sx_LowerTransportIn
	            THEN
	                #sx_BladeStopBoSControl := FALSE;
	            END_IF;
	            #iqUDT_BladeStopBoSInterface.Open := #sx_BladeStopBoSControl;
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 9 - PEC
	    // Use displacement from both interfaces - lower and upper 
	    #tUDT_ConveyorInterface := #iqUDT_UpperConveyorInterface;
	    #tUDT_ConveyorInterface.Displacement := #iqUDT_UpperConveyorInterface.Displacement + #iqUDT_LowerConveyorInterface.Displacement;
	    
	    // PEC handling
	    #sFB_PEC(ix_PEC := #ix_PEC,
	             iUDT_PECConfiguration := #iUDT_PECConfiguration,
	             qUDT_HMIStatus => #qUDT_HMIPECStatus,
	             iqUDT_ConveyorInterface := #tUDT_ConveyorInterface,
	             iqUDT_PECStatistics := #iqUDT_PECStatistics);
	    
	    // copy error to both intefaces - lower and upper
	    #iqUDT_UpperConveyorInterface.InternalErrorPEC := #iqUDT_UpperConveyorInterface.InternalErrorPEC OR #tUDT_ConveyorInterface.InternalErrorPEC;
	    #iqUDT_LowerConveyorInterface.InternalErrorPEC := #iqUDT_LowerConveyorInterface.InternalErrorPEC OR #tUDT_ConveyorInterface.InternalErrorPEC;
	    
	END_REGION
	
	REGION 9 - Status
	    
	    // Status update
	    #sUDT_HMIStatus.Specific.Down := #ix_SectionIsDown AND NOT #ix_SectionIsUp;
	    #sUDT_HMIStatus.Specific.Up := #ix_SectionIsUp AND NOT #ix_SectionIsDown;
	    #sUDT_HMIStatus.Specific.Reverse := #tUDT_HMIStatus.Specific.Reverse;
	    #sUDT_HMIStatus.Status := #tUDT_HMIStatus.Status;
	    
	    #sUDT_CommonStatus.SafetyStop := NOT #ix_SafetyOk AND #ix_HardwareOk;
	    #sUDT_CommonStatus.Stopped := NOT #sx_Ready OR NOT #sx_AutomaticActive OR #tUDT_CommonStatus.Stopped;
	    #sUDT_CommonStatus.AutoON := #sx_Ready AND #sx_AutomaticActive AND #tUDT_CommonStatus.AutoON;
	    #sUDT_CommonStatus.Manual := #sx_ManualModeActive;
	    #sUDT_CommonStatus.ManualRun := #sx_ManualModeActive AND #sUDT_CommonStatus.Running;
	    #sUDT_CommonStatus.Running := #tUDT_CommonStatus.Running;
	    
	    #qUDT_RATStatus := #sUDT_CommonStatus;
	    #qUDT_HMIRATStatus := #sUDT_HMIStatus;
	    
	END_REGION
	
	REGION 10 - Statistics
	    
	    REGION 10.1 - Air pressure fault
	        // Update statistics if error is active or statistics reset detected
	        IF #sUDT_HMIStatus.Specific.ErrAirpressureNotOk OR #iqUDT_EquipmentControl.Command.ResetData      // Reset statistics
	        THEN
	            
	            "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,  // Reset statistics input
	                            ix_Activate := #sUDT_HMIStatus.Specific.ErrAirpressureNotOk,
	                            ix_RTrigActivate := #sR_TRIG_AirPressureFault.Q,            // Statistics active trigger
	                            iqUDT_Statistics := #iqUDT_RATStatistics.AirPressure);
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 10.2 - Device up time
	        
	        // Conveyor up is when conveyor is not in manual mode and has an error
	        IF #sx_DivertUpRunTimeErr OR #iqUDT_EquipmentControl.Command.ResetData      // Reset statistics
	        THEN
	            
	            "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,  // Reset statistics input
	                            ix_Activate := #sx_DivertUpRunTimeErr, // Activate statistics functions input
	                            ix_RTrigActivate := #sR_TRIG_DivertUpError.Q,          // Statistics active trigger
	                            iqUDT_Statistics := #iqUDT_RATStatistics.DivertUpError);   // Statistics values output
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 10.3 - Device down time
	        
	        // Conveyor down is when conveyor is not in manual mode and has an error
	        IF #sx_DivertDownRunTimeErr OR #iqUDT_EquipmentControl.Command.ResetData      // Reset statistics
	        THEN
	            
	            "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,  // Reset statistics input
	                            ix_Activate := #sx_DivertDownRunTimeErr, // Activate statistics functions input
	                            ix_RTrigActivate := #sR_TRIG_DivertDownError.Q,          // Statistics active trigger
	                            iqUDT_Statistics := #iqUDT_RATStatistics.DivertDownError);   // Statistics values output
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 10.4 - Conveyor statistics   
	        // Copy statistics from conveyor block
	        #iqUDT_RATStatistics.ConveyorDown := #tUDT_ConveyorStatistics.ConveyorDown;
	        #iqUDT_RATStatistics.ConveyorStop := #tUDT_ConveyorStatistics.ConveyorStop;
	        #iqUDT_RATStatistics.ConveyorUp := #tUDT_ConveyorStatistics.ConveyorUp;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 11 - Report to control block    
	    // Function to manage report between control block and conveyor block
	    "FC_EquipmentReport"(iUDT_Status := #sUDT_CommonStatus,
	                         iqUDT_Control := #iqUDT_EquipmentControl);
	    
	END_REGION
	
	REGION 12 - Internal errors and warnings reset
	    
	    REGION 12.1 Infeed timeout
	        // Infeed stuck, timeout calculation
	        #sFB_InfeedTimeout(iudi_OnDelayTime := #iUDT_Configuration.InfeedTimeout,
	                           ix_SignalToDelay := #si_Step = 3 AND (#sx_ProductReceivedDown OR #sx_ProductReceivedUp));
	        
	    END_REGION
	    
	    REGION 12.2 Reactivation
	        // Reactivate conveyor 1 if request is active and no register find
	        #sFB_ConveyorAReactivation(iudi_OnDelayTime := #iUDT_Configuration.ReactivationTime,
	                                   ix_SignalToDelay := #ix_ExternalReceiveRequestA AND #ix_ConveyorAAuto);
	        
	        IF #sFB_ConveyorAReactivation.qx_DelayedSignal AND NOT (#si_Conveyor = 1)
	        THEN
	            #sx_ReactivateA := TRUE;
	            FOR #si_LoopArrayCount := 1 TO #ci_FiFoLength DO
	                
	                IF #sa_FiFo[#si_LoopArrayCount] = 1
	                THEN
	                    #sx_ReactivateA := FALSE;
	                END_IF;
	                
	            END_FOR;
	            
	        END_IF;
	        // Reactivate conveyor 1 if request is active and no register find
	        #sFB_ConveyorBReactivation(iudi_OnDelayTime := #iUDT_Configuration.ReactivationTime,
	                                   ix_SignalToDelay := #ix_ExternalReceiveRequestB AND #ix_ConveyorBAuto);
	        
	        IF #sFB_ConveyorBReactivation.qx_DelayedSignal AND NOT (#si_Conveyor = 2)
	        THEN
	            #sx_ReactivateB := TRUE;
	            FOR #si_LoopArrayCount := 1 TO #ci_FiFoLength DO
	                
	                IF #sa_FiFo[#si_LoopArrayCount] = 2
	                THEN
	                    #sx_ReactivateB := FALSE;
	                END_IF;
	                
	            END_FOR;
	            
	        END_IF;
	        // Reactivate conveyor 1 if request is active and no register find
	        #sFB_ConveyorCReactivation(iudi_OnDelayTime := #iUDT_Configuration.ReactivationTime,
	                                   ix_SignalToDelay := #ix_ExternalReceiveRequestC AND #ix_ConveyorCAuto);
	        
	        IF #sFB_ConveyorCReactivation.qx_DelayedSignal AND NOT (#si_Conveyor = 3)
	        THEN
	            #sx_ReactivateC := TRUE;
	            FOR #si_LoopArrayCount := 1 TO #ci_FiFoLength DO
	                
	                IF #sa_FiFo[#si_LoopArrayCount] = 3
	                THEN
	                    #sx_ReactivateC := FALSE;
	                END_IF;
	                
	            END_FOR;
	            
	        END_IF;
	        // Reactivate conveyor 1 if request is active and no register find
	        #sFB_ConveyorDReactivation(iudi_OnDelayTime := #iUDT_Configuration.ReactivationTime,
	                                   ix_SignalToDelay := #ix_ExternalReceiveRequestD AND #ix_ConveyorDAuto);
	        
	        IF #sFB_ConveyorDReactivation.qx_DelayedSignal AND NOT (#si_Conveyor = 4)
	        THEN
	            #sx_ReactivateD := TRUE;
	            FOR #si_LoopArrayCount := 1 TO #ci_FiFoLength DO
	                
	                IF #sa_FiFo[#si_LoopArrayCount] = 4
	                THEN
	                    #sx_ReactivateD := FALSE;
	                END_IF;
	                
	            END_FOR;
	            
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
END_FUNCTION_BLOCK

DATA_BLOCK "DB_FIFOLostGIN"
TITLE = DB_FIFO
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
NON_RETAIN
//Data block to store FIFO registers.
   VAR RETAIN
      Header { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoHeader";   // FIFO Header
      Data { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..199] of Int;   // FIFO data buffer
   END_VAR
   VAR 
      Header_1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoHeader";
      Data_1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..199] of Int;
      Header_2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoHeader";
      Data_2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..199] of Int;
      Header_3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoHeader";
      Data_3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..199] of Int;
      Header_4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoHeader";
      Data_4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..199] of Int;
      Header_5 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoHeader";
      Data_5 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..199] of Int;
      Header_6 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoHeader";
      Data_6 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..199] of Int;
   END_VAR


BEGIN

END_DATA_BLOCK

FUNCTION_BLOCK "FB_CognexDM260"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 263
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_CognexDM260_IN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CognexDM260_IN";   // Data from camera
      ix_Trigger { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Trigger - Activate barcode scanning inside this function
   END_VAR

   VAR_OUTPUT 
      qUDT_CognexDM260_OUT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CognexDM260_OUT";   // Data send to camera
      qs_Barcode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;
      qw_RetVal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Error code (W#16#...): A - TimeOut; B - Bit from camera "Result available" blocked; C - NO READ; C5 - 5 NO READ in row;  C0 - Empty data from camera
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl { S7_HiddenAssignment := 'HideIfNoParamAssigned'} : "UDT_EquipmentControl";   // Optional. Use UDT to reset errors and statistic [ or two next bits:  ix_ResetError  to reset erors and ResetStatistic]
   END_VAR

   VAR 
      sFB_TimerOnOffDelay_TimeOut { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // TimeOut timer
      sFB_TimerOnOffDelay_ResultsAvailableError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer for control Result Avilable duration time
      sFB_TimerOnOffDelay_ActTimeToNextReady { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Time from trigger to get data from camera (Result_Available)
      sFB_TimerOnOffDelay_ActReadingFromCameraTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Time from trigger to get data from camera (Result_Available)
      sR_TRIG_StatisticActCycleTime {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for (#R_TRIG_Result_available.Q OR #sx_ErrorTimeOut)
      sR_TRIG_Trigger {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger signal
      sR_TRIG_TriggerReady {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for bit from camera "trigger ready"
      sR_TRIG_ResultAvailable {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for bit from camera "Result_Available"
      sR_TRIG_NoReadCounter {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for general counter NO_READ
      sR_TRIG_OkReadCounter {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for general counter OK_READ
      sR_TRIG_TimeOutCounter {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for general counter TimeOut
      sR_TRIG_ResetStatistics {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for ResetStatistics
      ss_LastResults { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Copy of last result reading barcode value
         ID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // The value of the “Trigger ID” when the trigger that generated these results was issued. Used to match up triggers with corresponding result data (16-bit Integer).
         Flags { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Indicates the success or failure of the read that produced these results (16-bit Integer).Bit 0,1=read, 0=no read, Bit 1,1=validated, 0=not validated (or validation not in use),  Bit 2,1=verified, 0=not verified (or verification not in use)  Bit 3,1=acquisition trigger overrun  Bit 4,1=acquisition buffer overflow
         Length { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Actual number of bytes of read data contained in the “Result Data” field (16-bitInteger).
         DataBarCode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..63] of Char;   // Last barcode
         DataBarCodeString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Last barcode as string // for future use
      END_STRUCT;
      ss_Statistic { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // All statistics
         udi_ActReadingFromCameraTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Actual time measurement from trigger to get data from camera
         udi_PrevReadingFromCameraTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Previous time measurement from trigger to get data from camera
         udi_ShortestReadingTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // The shortest time of reading data from camera  (only OK READ)
         udi_LongestReadingTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // The longest time of reading data from camera  (only OK READ)
         udi_AvgReadingTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Average time of reading data from camera (only OK READ)
         udi_SumOfTimesOkRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Sum of all OK READ times - for use in average
         udi_ActTimeToNextReady { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Time from trigger to get next high state on bit "Trigger Ready" from camera
         si_OK_READ_CounterGeneral { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Total number of correct readings
         si_TimeOut_CounterGeneral { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Total number of timeouts
         si_NO_READ_CounterGeneral { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Total number of NO READ
         si_NO_READ_CounterInRow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Number of No READ in a row (after 5 generate error)
      END_STRUCT;
      sw_ErrorCode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Error code
      sx_BUSY { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Function is processing data (set with trigger, reset at the end of processing data from the camera)
      sx_OK_READ { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Correct reading
      sx_NO_READ { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Camera can't read last barcode
      sx_ErrorTimeOut { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Begin measuring time with trigger and finish when camera activate "Results Available". Time set up in constants
      "sx_General Fault" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Any error set this bit
      sx_ResetResultAvailableBit { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Bit is used as memory during the reset procedure of "Result available" bit ( it requires communication between the camera and the PLC)
      sx_ResetErrorsInterlocked { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Bit is used as memory during error reset process.
   END_VAR

   VAR_TEMP 
      ti_Trigger_ID : Int;   // ID value of the next trigger to be issued (16-bit integer). Copy of input tag get from camera after decoding UDT bytes (original TriggerID)
      ti_ResultID : Int;   // “Trigger ID” when the trigger that generated these results was. Copy of input tag get from camera after decoding UDT bytes (original ResultID)
      ti_ResultCode : Int;   // Indicates the success or failure of the read that produced these results Copy of input tag get from camera after decoding UDT bytes (original Result Code or "flags")
      ti_ResultLength : Int;   // Actual number of bytes of read data contained in the “Result Data” field (16-bit)  Copy of input tag get from camera after decoding UDT bytes (original Result Code or "flags")
      tx_Decoding : Bool;   // Indicates that the DataMan is decoding an acquired image. The value of the Decoding bit is identical to the value of the Acquiring bit. Both bits are true if an acquisition, or series of acquisitions of the same trigger, is in progress. Copy of input tag get from camera after decoding UDT bytes (original Decoding)
      tx_DecodeComplete : Bool;   // Bit is toggled on the completion of a decode operation when the new results are made available (0 -> 1 or 1 -> 0).  Copy of input tag get from camera after decoding UDT bytes (original Decode complete)
      tx_ResultsBufferOverrun : Bool;   // Indicates that the DataMan has discarded a set of read results because the results Copy of input tag get from camera after decoding UDT bytes (orginal Results Buffer Overrun)
      tx_CameraNoRead : Bool;   // Result Code = 0 -> Camera NO READ code
      tx_CameraOkRead : Bool;   // Result Code = 1 -> Camera READ code
      tx_ResultsAvailable : Bool;   // Indicates that a new set of read results are available, that is, the contents of the Result Data module are valid. Cleared when the results are acknowledged. Copy of input tag get from camera after decoding UDT bytes (orginal Result Available)
   END_VAR

   VAR CONSTANT 
      cudi_TimeOut : UDInt := 110;   // Timeout time
      cudi_MaxUDint : UDInt := 4_294_967_295;   // Maximal value of UDint
   END_VAR


BEGIN
	(*
	                                                                                 
	Version history:
	Date        | Version   | Author             | Remark
	----------------------------------------------------------------------------------------
	08/05/2024   | 0.1       | Grzegorz Czekała    | first release TIA Portal 17 (upd 6)
	11/05/2024   | 0.2       | S. Nieswiec         | removed optional inputs, added barcode string to outputs,
	                                               | changed system commands to equipment control
	25/05/2024   | 0.3       | S. Nieswiec         | Switched IEC timers for FB_TimerOnOffDelay 
	27/05/2024   | 0.4       | S. Nieswiec         | Cleaned up code, changed region names
	                                               | TO DO, clean up statistics region, can't just copy paste it higher because statistics brake
	*)
	
	
	REGION 1 - Initial
	    
	    REGION 1.1 - Reset Temp variables
	        #ti_Trigger_ID := 0;
	        #ti_ResultID := 0;
	        #ti_ResultCode := 0;
	        #ti_ResultLength := 0;
	        #tx_Decoding := FALSE;
	        #tx_DecodeComplete := FALSE;
	        #tx_ResultsBufferOverrun := FALSE;
	        #tx_CameraOkRead := FALSE;
	        #tx_CameraNoRead := FALSE;
	        #tx_ResultsAvailable := FALSE;
	    END_REGION
	    
	    REGION 1.2 - Timers
	        REGION 1.2.1 - Timeout
	            #sFB_TimerOnOffDelay_TimeOut(iudi_OnDelayTime := #cudi_TimeOut,
	                                         ix_SignalToDelay := #sx_BUSY AND NOT #tx_ResultsAvailable,
	                                         ix_Enable := TRUE);
	        END_REGION
	        
	        REGION 1.2.2 - Results available timeout
	            #sFB_TimerOnOffDelay_ResultsAvailableError(iudi_OnDelayTime := 20,
	                                                       ix_SignalToDelay := #tx_ResultsAvailable,
	                                                       ix_Enable := TRUE);
	        END_REGION
	    END_REGION
	    
	    REGION 1.3 - Triggers
	        #sR_TRIG_Trigger(CLK := #ix_Trigger);  //Rising edge trigger signal
	        //  #sR_TRIG_TriggerReady(CLK := #iUDT_CognexDM260_IN.TriggerReady); lower in code
	        // #sR_TRIG_ResultAvailable(CLK := #"tx_ResultsAvailable");    // lower in code
	        #sR_TRIG_OkReadCounter(CLK := #sx_OK_READ);
	        #sR_TRIG_NoReadCounter(CLK := #sx_NO_READ);
	        #sR_TRIG_ResetStatistics(CLK := #iqUDT_EquipmentControl.Command.ResetData);
	    END_REGION
	    
	    REGION 1.4 - Trigger Enable
	        
	        #qUDT_CognexDM260_OUT.TriggerEnable := TRUE;  // Camera always ready to trigger
	        
	    END_REGION
	    
	END_REGION
	
	REGION 2. Trigger activation
	    
	    #"tx_ResultsAvailable" := #iUDT_CognexDM260_IN.BYTE_Decoding.%X3; // decoding info from camera "Results Available" (Information on receiving data from the camera regardless of whether the barcode is read or not.) 
	    
	    // Activate camera trigger when: camera is ready, input trigger is activated and previous process is completed without errors
	    IF #sR_TRIG_Trigger.Q
	        AND #iUDT_CognexDM260_IN.TriggerReady
	        AND NOT #qUDT_CognexDM260_OUT.Trigger
	        AND NOT #iUDT_CognexDM260_IN.TriggerAck
	        AND NOT #"tx_ResultsAvailable"
	        AND NOT #qUDT_CognexDM260_OUT.ResultsAck
	        AND NOT #sx_BUSY
	        AND NOT #sx_ResetErrorsInterlocked
	    THEN
	        #qUDT_CognexDM260_OUT.Trigger := TRUE;
	        #sx_BUSY := TRUE;   // process in progress
	        #sx_ErrorTimeOut := FALSE;
	        #sx_NO_READ := FALSE;
	        #sx_OK_READ := FALSE;
	        #sw_ErrorCode := 16#0;
	    END_IF;
	END_REGION
	
	
	REGION 3 - Handling data received from camera
	    
	    IF #sx_BUSY
	        AND #tx_ResultsAvailable
	        AND NOT #qUDT_CognexDM260_OUT.ResultsAck
	    THEN
	        #qUDT_CognexDM260_OUT.Trigger := FALSE;
	        #qUDT_CognexDM260_OUT.ResultsAck := TRUE;
	        
	        REGION 3.1 - Decoding data
	            
	            // Data decoding is necessary because we receive data from the camera in the form of bytes when we need integers and bit
	            // Decoding byte nr 3
	            #tx_Decoding := #iUDT_CognexDM260_IN.BYTE_Decoding.%X0;
	            #"tx_DecodeComplete" := #iUDT_CognexDM260_IN.BYTE_Decoding.%X1;
	            #"tx_ResultsBufferOverrun" := #iUDT_CognexDM260_IN.BYTE_Decoding.%X2;
	            // #"Results Available" := #iUDT_Cognex260_control."BYTE_Decoding-GeneralFault".%X3;  // This is decoding upper line
	            #"sx_General Fault" := #iUDT_CognexDM260_IN.BYTE_Decoding.%X7;
	            
	            // Trigger ID
	            #ti_Trigger_ID.%B1 := #iUDT_CognexDM260_IN.TriggerID;
	            #ti_Trigger_ID.%B0 := #iUDT_CognexDM260_IN."TriggerID 1";
	            
	            // Result ID
	            #ti_ResultID.%B1 := #iUDT_CognexDM260_IN.ResultID;
	            #ti_ResultID.%B0 := #iUDT_CognexDM260_IN."ResultID 1";
	            
	            // Result Code
	            #ti_ResultCode.%B1 := #iUDT_CognexDM260_IN."Result Code";
	            #ti_ResultCode.%B0 := #iUDT_CognexDM260_IN."Result Code_1";
	            
	            // Result Lenght
	            #ti_ResultLength.%B1 := #iUDT_CognexDM260_IN."Result Length";
	            #ti_ResultLength.%B0 := #iUDT_CognexDM260_IN."Result Length_1";
	            
	            REGION 3.1.1 - Copying last result barcode value
	                
	                // Copy Last Result NO_READ sign
	                #ss_LastResults.DataBarCode[0] := #iUDT_CognexDM260_IN."BarCodeValue[0]-NO_READ_sign";
	                
	                // Copy last result barcode value to DB
	                MOVE_BLK(IN := #iUDT_CognexDM260_IN.BarCodeValue[1],
	                         COUNT := 63,
	                         OUT => #ss_LastResults.DataBarCode[1]);
	                
	                // Marge Bytes to int
	                #ss_LastResults.ID := #ti_ResultID;
	                #ss_LastResults.Flags := #ti_ResultCode;
	                #ss_LastResults.Length := #ti_ResultLength;
	                
	                // For future use conversion from char to string 
	                Chars_TO_Strg(Chars := #ss_LastResults.DataBarCode,
	                              pChars := 0,
	                              Cnt := 0,
	                              Strg => #ss_LastResults.DataBarCodeString);
	                #qs_Barcode := #ss_LastResults.DataBarCodeString;
	            END_REGION
	            
	        END_REGION
	        
	        REGION 3.2  No READ // When NO_READ this bit is activate (is set until new trigger)
	            
	            // Check when get new data if there is "!"
	            IF #qUDT_CognexDM260_OUT.ResultsAck AND #ss_LastResults.DataBarCode[0] = '!'
	            THEN
	                #sx_NO_READ := TRUE;
	                #sx_OK_READ := FALSE;
	            END_IF;
	            
	            IF #qUDT_CognexDM260_OUT.ResultsAck AND #ss_LastResults.DataBarCode[0] <> '!'
	            THEN
	                #sx_NO_READ := FALSE;
	                #sx_OK_READ := TRUE;
	            END_IF;
	            
	            //Addidtional data from camera
	            #tx_CameraOkRead := #ti_ResultCode.%X0 AND #qUDT_CognexDM260_OUT.ResultsAck;
	            #tx_CameraNoRead := NOT #ti_ResultCode.%X0 AND #qUDT_CognexDM260_OUT.ResultsAck;
	            
	        END_REGION
	    END_IF;
	    
	    REGION 3.3  End of reading procedure 
	        //Resets bits  is READY TO next trigger
	        IF #sx_BUSY
	            AND #qUDT_CognexDM260_OUT.ResultsAck
	            AND NOT #"tx_ResultsAvailable"
	        THEN
	            #qUDT_CognexDM260_OUT.ResultsAck := FALSE;
	            #sx_BUSY := FALSE;
	        END_IF;
	        
	    END_REGION
	END_REGION
	
	
	REGION 4 - Statistics 
	    
	    
	    REGION 4.1  Time statistics
	        
	        ////////////////////////////////// Time measured from trigger to receiving a response "Results Available".
	        
	        #sR_TRIG_ResultAvailable(CLK := #"tx_ResultsAvailable");
	        #sR_TRIG_StatisticActCycleTime(CLK := #sR_TRIG_ResultAvailable.Q OR #sx_ErrorTimeOut);
	        
	        
	        IF #sR_TRIG_StatisticActCycleTime.Q  // Sending the time only once in the event of receiving data or exceeding the timeout.
	        THEN
	            #ss_Statistic.udi_PrevReadingFromCameraTime := #ss_Statistic.udi_ActReadingFromCameraTime;
	            #ss_Statistic.udi_ActReadingFromCameraTime := LREAL_TO_UDINT(#sFB_TimerOnOffDelay_ActTimeToNextReady.qlr_ActualTime);
	            #sFB_TimerOnOffDelay_ActReadingFromCameraTime.ix_SignalToDelay := FALSE;
	        END_IF;
	        
	        REGION 4.1.1 Longest, shortest and average reading time
	            
	            // Statistics include only OK_READ process
	            IF #sR_TRIG_ResultAvailable.Q AND #sx_OK_READ
	            THEN
	                
	                // Chceck the longest time
	                IF #ss_Statistic.udi_ActReadingFromCameraTime > #ss_Statistic.udi_LongestReadingTime
	                THEN
	                    #ss_Statistic.udi_LongestReadingTime := #ss_Statistic.udi_ActReadingFromCameraTime;
	                    
	                END_IF;
	                
	                // When PLC startup the shortest time is 0ms, so we put there other start shortest time value
	                IF #ss_Statistic.udi_ShortestReadingTime < 1
	                THEN
	                    #ss_Statistic.udi_ShortestReadingTime := #ss_Statistic.udi_ActReadingFromCameraTime;
	                END_IF;
	                
	                // Chceck the shortest time
	                IF (#ss_Statistic.udi_ActReadingFromCameraTime < #ss_Statistic.udi_ShortestReadingTime)
	                THEN
	                    
	                    #ss_Statistic.udi_ShortestReadingTime := #ss_Statistic.udi_ActReadingFromCameraTime;
	                END_IF;
	                
	                // Calculate average time of OK_READs
	                #ss_Statistic.udi_SumOfTimesOkRead := #ss_Statistic.udi_SumOfTimesOkRead + #ss_Statistic.udi_ActReadingFromCameraTime;
	                #ss_Statistic.udi_AvgReadingTime := #ss_Statistic.udi_SumOfTimesOkRead / #ss_Statistic.si_OK_READ_CounterGeneral;
	                
	            END_IF;
	        END_REGION
	        
	        REGION 4.1.2 Time from trigger to ResultsAvailable
	            
	            IF #sx_BUSY AND NOT #tx_ResultsAvailable THEN
	                #sFB_TimerOnOffDelay_ActReadingFromCameraTime.ix_SignalToDelay := TRUE;
	            END_IF;
	            
	            #sFB_TimerOnOffDelay_ActReadingFromCameraTime(iudi_OnDelayTime := #cudi_MaxUDint,
	                                                          ix_Enable := TRUE);
	            
	            //Time measured from trigger to receiving a response "Trigger ready".
	            #sR_TRIG_TriggerReady(CLK := #iUDT_CognexDM260_IN.TriggerReady);
	            
	            IF #sx_BUSY THEN
	                #sFB_TimerOnOffDelay_ActTimeToNextReady.ix_SignalToDelay := TRUE;
	            END_IF;
	            
	            IF #sR_TRIG_TriggerReady.Q OR #sx_ErrorTimeOut
	            THEN
	                #ss_Statistic.udi_ActTimeToNextReady := LREAL_TO_UDINT(#sFB_TimerOnOffDelay_ActTimeToNextReady.qlr_ActualTime);
	                #sFB_TimerOnOffDelay_ActTimeToNextReady.ix_SignalToDelay := FALSE;
	            END_IF;
	            
	            #sFB_TimerOnOffDelay_ActTimeToNextReady(iudi_OnDelayTime := #cudi_MaxUDint,
	                                                    ix_Enable := TRUE);
	        END_REGION
	    END_REGION
	    
	    
	    REGION 4.2 - Count statistics
	        REGION 4.2.1 - OK_READ 
	            
	            IF #sR_TRIG_OkReadCounter.Q
	            THEN
	                #ss_Statistic.si_OK_READ_CounterGeneral += 1;
	            END_IF;
	        END_REGION
	        
	        REGION 4.2.2 -  NO_READ and NO_READ in row
	            
	            IF #sx_OK_READ
	            THEN
	                #ss_Statistic.si_NO_READ_CounterInRow := 0;
	            END_IF;
	            
	            IF #sR_TRIG_NoReadCounter.Q
	            THEN
	                #ss_Statistic.si_NO_READ_CounterGeneral += 1;
	                #ss_Statistic.si_NO_READ_CounterInRow += 1;
	            END_IF;
	        END_REGION
	    END_REGION
	    
	    REGION 4.3 - Reset statistics
	        
	        // Reset all statistic
	        IF #sR_TRIG_ResetStatistics.Q
	        THEN
	            #ss_Statistic.udi_ActReadingFromCameraTime := 0;
	            #ss_Statistic.udi_PrevReadingFromCameraTime := 0;
	            #ss_Statistic.udi_ShortestReadingTime := 0;
	            #ss_Statistic.udi_SumOfTimesOkRead := 0;
	            #ss_Statistic.udi_LongestReadingTime := 0;
	            #ss_Statistic.udi_ActTimeToNextReady := 0;
	            #ss_Statistic.udi_AvgReadingTime := 0;
	            #ss_Statistic.si_OK_READ_CounterGeneral := 0;
	            #ss_Statistic.si_TimeOut_CounterGeneral := 0;
	            #ss_Statistic.si_NO_READ_CounterInRow := 0;
	            #ss_Statistic.si_NO_READ_CounterGeneral := 0;
	        END_IF;
	    END_REGION
	    
	END_REGION
	
	REGION 5 - End of reading procedure
	    
	    IF #sx_BUSY
	        AND #qUDT_CognexDM260_OUT.ResultsAck
	        AND NOT #"tx_ResultsAvailable"
	    THEN
	        #qUDT_CognexDM260_OUT.ResultsAck := FALSE;
	        #sx_BUSY := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Errors
	    
	    REGION 4.1 - Timeout
	        
	        IF #sFB_TimerOnOffDelay_TimeOut.qx_DelayedSignal THEN
	            #sx_ErrorTimeOut := TRUE;
	        END_IF;
	        
	        IF #sR_TRIG_TimeOutCounter.Q
	        THEN
	            #ss_Statistic.si_TimeOut_CounterGeneral += 1;
	        END_IF;
	    END_REGION
	    
	    REGION 4.2 - Results available blocked
	        
	        IF #sFB_TimerOnOffDelay_ResultsAvailableError.qx_DelayedSignal
	        THEN
	            #"sx_General Fault" := TRUE;
	            #sw_ErrorCode := 16#800B;             // Bit from camera "Result available" blocked
	            #sx_ResetErrorsInterlocked := TRUE;  // Start procedure of reset bit Results Available
	        END_IF;
	        
	        IF #sx_ErrorTimeOut AND #"tx_ResultsAvailable"
	        THEN
	            #sx_ResetErrorsInterlocked := TRUE;  // Reset bit Results Available
	        END_IF;
	    END_REGION
	    
	    REGION 4.3 - Error codes
	        
	        REGION 4.3.1 - Timeout
	            IF #sx_ErrorTimeOut
	            THEN
	                #"sx_General Fault" := TRUE;
	                #sw_ErrorCode := 16#800A;
	            END_IF;
	        END_REGION
	        
	        REGION 4.3.2 - No read
	            IF #sx_NO_READ
	            THEN
	                #"sx_General Fault" := TRUE;
	                #sw_ErrorCode := 16#800C;     // NO READ
	            END_IF;
	        END_REGION
	        
	        REGION 4.3.3 - Five no read in row
	            IF #ss_Statistic.si_NO_READ_CounterInRow >= 5
	            THEN
	                #"sx_General Fault" := TRUE;
	                #sw_ErrorCode := 16#805C;    // 5 NO READ in row
	            END_IF;
	        END_REGION
	        
	        REGION 4.3.4 - Empty data from camera
	            IF #qUDT_CognexDM260_OUT.ResultsAck AND #ss_LastResults.DataBarCode[0] = '$00'
	            THEN
	                #"sx_General Fault" := TRUE;
	                #sw_ErrorCode := 16#80C0;    // Empty data from camera
	            END_IF;
	        END_REGION
	        
	        REGION 4.3.5 - Writing error code to ouput
	            
	            #qw_RetVal := #sw_ErrorCode;
	            
	        END_REGION
	    END_REGION
	END_REGION
	
	REGION 7 - Errors reset
	    
	    REGION 6.1 - General
	        IF #iqUDT_EquipmentControl.Command.Reset THEN
	            #ss_Statistic.si_TimeOut_CounterGeneral := 0;
	            #ss_Statistic.si_NO_READ_CounterInRow := 0;
	            
	            #sx_BUSY := FALSE;
	            #qUDT_CognexDM260_OUT.ResultsAck := FALSE;
	            #"sx_General Fault" := TRUE;
	            #sw_ErrorCode := 16#0000;
	            
	            #sx_ResetErrorsInterlocked := TRUE;
	        END_IF;
	    END_REGION
	    
	    REGION 6.2 Reset "Result Available" and Trigger Ack bit from camera
	        
	        // To clear the bit "#Results Available" from camera, it is necessary to SET the bit "ResultsAck" and wait for confirmation from the camera.
	        IF #sx_ResetResultAvailableBit AND NOT #"tx_ResultsAvailable"
	        THEN
	            #sx_ResetResultAvailableBit := FALSE;
	            #qUDT_CognexDM260_OUT.ResultsAck := FALSE;
	            #qUDT_CognexDM260_OUT.Trigger := FALSE;
	        END_IF;
	        
	        IF #sx_ResetErrorsInterlocked AND #"tx_ResultsAvailable"
	        THEN
	            #qUDT_CognexDM260_OUT.ResultsAck := TRUE;
	            #sx_ResetResultAvailableBit := TRUE;
	        END_IF;
	        
	        
	        IF #sx_ResetErrorsInterlocked AND NOT #"tx_ResultsAvailable"
	        THEN
	            #sx_ResetErrorsInterlocked := FALSE;
	        END_IF;
	        
	    END_REGION
	END_REGION
	
	
	
END_FUNCTION_BLOCK

TYPE "UDT_WSVConfiguration"
VERSION : 0.1
   STRUCT
      GlobalConfig { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightStationExists { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;
         LeftStationExists { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;
      END_STRUCT;
      "010" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "020" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "030" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "040" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "050" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "060" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "070" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "080" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "090" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "100" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "110" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "120" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "121" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "230" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECUpdateConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "240" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, 0, 500, 1000, FALSE, FALSE);
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "241" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, 0, 500, 1000, FALSE, FALSE);
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "250" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, 0, 500, 1000, FALSE, FALSE);
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECUpdateConfiguration" := (600, 300, 5, 5, TRUE, FALSE, 50, 50, 0, 0, 0, 1, 5, FALSE, FALSE, FALSE, FALSE);
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "260" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, 0, 500, 1000, FALSE, FALSE);
         VFD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdConfiguration";
      END_STRUCT;
      "270" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, 0, 500, 1000, FALSE, FALSE);
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "280" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, 0, 500, 1000, FALSE, FALSE);
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "310" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         VFD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdConfiguration";
      END_STRUCT;
      "320" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECUpdateConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "330" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "340" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "341" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "350" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "351" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "360" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "361" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "370" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "371" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "380" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECUpdateConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "390" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECUpdateConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "530" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECUpdateConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "540" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, 0, 500, 1000, FALSE, FALSE);
         PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "541" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "550" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, 0, 500, 1000, FALSE, FALSE);
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECUpdateConfiguration" := (600, 300, 5, 5, TRUE, FALSE, 50, 50, 0, 0, 0, 1, 5, FALSE, FALSE, FALSE, FALSE);
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "560" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, 0, 500, 1000, FALSE, FALSE);
         VFD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdConfiguration";
      END_STRUCT;
      "570" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, 0, 500, 1000, FALSE, FALSE);
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "580" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, 0, 500, 1000, FALSE, FALSE);
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "610" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration";
         VFD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdConfiguration";
      END_STRUCT;
      "620" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECUpdateConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "630" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECUpdateConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "640" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "641" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "650" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "651" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "660" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "661" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "670" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "671" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "680" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECUpdateConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
      "690" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := ((0, 0), (), (), 100, (), 500, 1000, FALSE, ());
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECUpdateConfiguration";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";
      END_STRUCT;
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_VfdNORDPPO4"
TITLE = Control block for NORD VFD with PPO4
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHS
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 235
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_VFDConfig { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdConfiguration";   // Configuration structure
      iUDT_VFDInputs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdNordPI";   // VFD inputs structure
      iUDT_MotorData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_MotorData";   // Motor data structure
      ix_24vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 24VDC is healthy
      ix_400vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 400VAC is healthy
      ix_QuickStopDisable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;   // TRUE when Motor can turn, False = Quick stop
      ix_SimulationModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when Simulation mode active
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdStatus";   // HMI status structure
      qUDT_VFDOutputs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdNordPO";   // VFD outputs structure
      qUDT_commisioning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommisioningNord";
   END_VAR

   VAR_IN_OUT 
      iqUDT_ConveyorInterface : "UDT_ConveyorInterface";   // Conveyor interface structure
      iqUDT_VFDStatistics : "UDT_VfdStatistics";   // Satistics structure
      iqx_StartCommissioning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when Start auto-commissioning
   END_VAR

   VAR 
      sFB_TimerOnOffDelayCheck24V { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // MHS "TimerOnOffDelay" - to delay time for VFD 24V contactor
      sFB_TimerOnOffDelayCheck400V { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // MHS "TimerOnOffDelay" - to delay time for VFD 400V contactor
      sFB_TimerOnOffDelayVFDReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // MHS "TimerOnOffDelay" - to extend VFD reset
      sFB_TimerOnOffDelayVFDRunningFeedbackError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // MHS "TimerOnOffDelay" - to delay time for VFDRunningFeedback error
      sFB_VfdNORDCommissiong { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_VfdNORDCommissioning";   // FB to commissiong NORD drive
      sUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatus";   // Detailed VFD status overview
      sUDT_PNDevice { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PNDevice";   // PN device info structure
      sa_PNPortsStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..8] of Bool;   // TRUE when specific port has an error
      sp_VFDTelegram { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // Free telegram's HW_ID
      sv_VFDGeoStruct {InstructionName := 'GEOADDR'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : GEOADDR;   //  Geo structure indicate to telegram
      sR_TRIG_PNSlaveNotOnline {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for trigger Profinet slave not online statistics
      sR_TRIG_PNSlaveError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for trigger Profinet slave error statistics
      sR_TRIG_VFDInternalError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for trigger Internal VFD Error statistics
      sR_TRIG_Running {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for starting of the running signal
      sF_TRIG_RunFwd {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge for run forward signal
      sF_TRIG_RunRvs {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge for run reverse signal
      sr_RPMActual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Drive RPM feedback
      sr_RPMSetpoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Actual speed setpoint [rpm]
      sr_ReferenceFrequency { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Frequency of the reference RPM in [Hz]
      sdi_LastRampTimeUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Last cycle ramp down time
      sdi_LastRampTimeDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Last cycle ramp up time
      si_ActualRamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Actual ramp value
      si_ActualRampUpTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Actual ramp up time
      si_ActualRampDownTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Actual ramp down time
      si_HWAdress { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_ActualSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Actual speed in [mm/sec]
      si_Log2GeoReturn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Log2Geo function return
      si_Geo2LogReturn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Geo2Log function return
      sx_ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Commissioning: configuration error
      sx_PNDeviceHealthy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet device is online and error free
      sx_HardwareAvailable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Power and communication to drive are ok
      sx_VfdAvailable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Hardware of VFD is ok and no communication error with movikit
      sx_24vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 24VDC is healthy
      sx_400vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 400VAC is healthy
      sx_ErrorActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block has an error
      sx_EnableOperation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Enable operation signal
      sx_RunVFDReverse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start VFD backward
      sx_RunVFDForward { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start VFD forward
      sx_SpeedSetpointReached { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor is running at requested speed
      sx_VFDStopping { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // VFD Stopping
      sx_VFDNotReadyError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Temporary Error need to be implemented in the status
   END_VAR

   VAR CONSTANT 
      cr_MaximumValueSpeedWord : Real := 16384.0;   // Maximum value of speed actual value
      cr_MaximumValueRampWord : Real := 32767.0;   // Maximum value of ramp setpoint ( corresponds to 20Sec)
      cr_MaximumFrequency : Real := 16384.0;   // Maximum value of frequency setpoint (corresponds to P105 Maximum Frequency)
      cudi_DefaultRampDownTime : UDInt := 20000;   // VFD ramp down default time [ms]
      cudi_DefaultRampUpTime : UDInt := 20000;   // VFD ramp up default time [ms]
      ci_VFDArea : UInt := 1;   // Area ID of IO Profinet devices
      ci_SubmoduleHWType : UInt := 5;   // Submodule HW_type number
      ci_TelegramSlot : UInt := 0;   // PPO4 telegram slot
      ci_TelegramSubslot : UInt := 1;   // PPO4 telegram subslot
      ci_NumberOfProfinetPorts : Int := 2;   // Number of Profinet ports in device
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	25/01/2020  | 0.1       | S.Theocharis  | Initial version TIA 15.1
	28/04/2022  | 0.2       | K. Pokorski   | NORD Commissioning interface change
	09/05/2022  | 0.3       | M. Pluskota   | Reference speed changed to nominal speed for actual speed calculation
	12/05/2022  | 0.4       | M. Pluskota   | Ramp equation adjustet for nord drives
	04/06/2022  | 0.5       | M. Pluskota   | Aded a if statment to not exceed the max value of the ramp value
	                                        | Error decoding changed now the error is shown as ErrorCode.SubErrorCodee
	12/07/2022  | 0.6       | M. Pluskota   | Ramp equation bug fix 
	29/07/2022  | 0.7       | M. Piela      | Add hardware ok to the profinet checking
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	
	REGION 1 - Get Device Profinet information
	    
	    "FC_GetDevicePN"(is_PNDeviceName := #iUDT_VFDConfig.VFDPNDeviceName,
	                     ix_SimulationModeActive := #ix_SimulationModeActive,
	                     iqUDT_PND := #sUDT_PNDevice);
	    
	    
	    "FC_GetPNPortStatus"(ii_NumberOfPorts := #ci_NumberOfProfinetPorts,
	                         iUDT_DevicePNInfo := #sUDT_PNDevice,
	                         qa_PortFault => #sa_PNPortsStatus);
	    
	END_REGION
	
	REGION 2 - Reset errors
	    
	    IF #iqUDT_ConveyorInterface.InternalErrorReset OR (NOT #iqUDT_ConveyorInterface.HardwareOk AND #sUDT_Status.PNSlaveNotonline)   // Reser errors when Reset is given
	    THEN
	        
	        #sUDT_Status.PNSlaveNotonline := FALSE;
	        #sUDT_Status.PNSlaveError := FALSE;
	        #sUDT_Status.InternalError := FALSE;
	        #sUDT_Status.VFDRunningFeedbackError := FALSE;
	        #sUDT_Status.PNSlaveWarning := FALSE;
	        
	    END_IF;
	    
	    
	    // Create  extended pulse for VFD Reset
	    #sFB_TimerOnOffDelayVFDReset(iudi_OnDelayTime := 0,
	                                 iudi_OffDelayTime := 200,
	                                 ix_SignalToDelay := #iqUDT_ConveyorInterface.InternalErrorReset,
	                                 ix_Enable := TRUE);
	    
	END_REGION
	
	REGION 3 - Hardware checks
	    // Hardware will only be available after the delay, so the device has time for the initialisation
	    #sFB_TimerOnOffDelayCheck24V(iudi_OnDelayTime := 2000,
	                                 iudi_OffDelayTime := 0,
	                                 ix_SignalToDelay := #ix_24vOk
	    );
	    
	    #sx_24vOk := #sFB_TimerOnOffDelayCheck24V.qx_DelayedSignal;
	    
	    #sFB_TimerOnOffDelayCheck400V(iudi_OnDelayTime := 2000,
	                                  ix_SignalToDelay := #ix_400vOk);
	    
	    #sx_400vOk := #sFB_TimerOnOffDelayCheck400V.qx_DelayedSignal;
	    
	    // Check if PN device is online
	    IF NOT "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.Exist
	        AND NOT #ix_SimulationModeActive
	        AND #sx_24vOk
	        AND #iqUDT_ConveyorInterface.HardwareOk
	    THEN
	        #sUDT_Status.PNSlaveNotonline := TRUE;
	        
	    END_IF;
	    
	    // Check if PN ports are healthy 
	    IF #sa_PNPortsStatus[1] XOR #sa_PNPortsStatus[2] THEN
	        #sUDT_Status.PNSlaveWarning := TRUE;
	    END_IF;
	    
	    
	    // Check if PN device has an error
	    IF "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.Error
	        AND NOT #ix_SimulationModeActive
	        AND #sx_24vOk
	        AND NOT #sUDT_Status.PNSlaveWarning
	        AND #iqUDT_ConveyorInterface.HardwareOk
	    THEN
	        #sUDT_Status.PNSlaveError := TRUE;
	    END_IF;
	    
	    // Set bit when PN device is healthy (online and no error)
	    #sx_PNDeviceHealthy := NOT #sUDT_Status.PNSlaveNotonline
	    AND NOT #sUDT_Status.PNSlaveError
	    AND #sUDT_PNDevice.PNDeviceFound
	    AND #sx_24vOk;
	    
	    // Set hardware available bit when all conditions are met
	    #sx_HardwareAvailable := (#sx_24vOk
	    AND #sx_PNDeviceHealthy)
	    OR #ix_SimulationModeActive;
	    
	    
	    // VFD is ready for operation if hardware ok 
	    #sx_VfdAvailable := #sx_HardwareAvailable;
	    
	    //VFD not ready error . Temporary 
	    #sx_VFDNotReadyError := #sx_HardwareAvailable
	    AND NOT #iUDT_VFDInputs.ZSW.ReadyToStart
	    AND #iUDT_VFDInputs.ZSW.EmergencyStop
	    OR NOT #iUDT_VFDInputs.ZSW.BusControlActive;
	    
	    
	    
	    
	END_REGION
	
	REGION 4 - Check errors and warnings 
	    
	    // Check if the VFD has a warning
	    #sUDT_Status.InternalWarning := #iUDT_VFDInputs.ZSW.WarningActive;
	    
	    // Copy warning code to status DB when warning active
	    IF #sUDT_Status.InternalWarning
	    THEN
	        
	        #sUDT_Status.ErrorCode := #iUDT_VFDInputs.FaultCode / 10; // AST check the value of warning
	        #sUDT_Status.SubErrorCode := #iUDT_VFDInputs.FaultCode MOD 10;
	        
	    END_IF;
	    
	    // Check if the VFD has an error
	    #sUDT_Status.InternalError := #iUDT_VFDInputs.ZSW.Fault; // AND NOT #sx_StartMeasuring;
	    
	    // Copy error code to status DB when error active
	    IF #sUDT_Status.InternalError
	    THEN
	        
	        #sUDT_Status.ErrorCode := #iUDT_VFDInputs.FaultCode / 10; // AST check the value of warning
	        #sUDT_Status.SubErrorCode := #iUDT_VFDInputs.FaultCode MOD 10;
	        
	    END_IF;
	    
	    // Reset error code if warning and error not available    
	    IF (NOT #sUDT_Status.InternalWarning
	        AND NOT #sUDT_Status.InternalError)
	    THEN
	        
	        #sUDT_Status.ErrorCode := 0;
	        #sUDT_Status.SubErrorCode := 0;
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Check if configuration is ok for commissioning purposes
	    
	    IF #iUDT_VFDConfig.WheelEndPerimeter > 0.0                                         // If perimeter of wheel at the end of gear is greater than 0 
	        AND #iUDT_VFDConfig.GearRatio > 0.0                                            // and gear ratio is greater than 0
	        AND #iUDT_VFDConfig.ReferenceRPM > 0.0                                         // and maximum speed is greater than 0
	        AND #iUDT_VFDConfig.VFDRampUpTime > 0                                          // and ramp up time is greater than 0
	        AND #iUDT_VFDConfig.VFDRampDownTime > 0                                        // and ramp down time is greater than zero
	        AND #iUDT_VFDConfig.VFDStartupTime > 0.0                                       // and startup time is greater then zero
	        //  AND MOTOR NOMINAL SPEED IS >0  the reference speed is invalid for NORD drives    
	        AND #cudi_DefaultRampUpTime > #iUDT_VFDConfig.VFDRampUpTime                     // and ramp up time is not greater than default ramp up time
	        AND #cudi_DefaultRampDownTime > #iUDT_VFDConfig.VFDRampDownTime                 // and ramp down time is not greater than default ramp down time
	        // need to know if the FI receives a percentage of a default ramp or value in ms , depending to that the configuration validation code will change
	        
	        AND (#sUDT_PNDevice.PNDeviceFound                                              // and device not found in PN structure 
	        OR #ix_SimulationModeActive)                                                    // or simulation mode is active
	    THEN
	        #sx_ConfigurationError := FALSE;                                                // Reset configuration error
	    ELSE
	        #sx_ConfigurationError := TRUE;                                                 // Set configuration error
	    END_IF;
	    #qUDT_commisioning.CommissionError := #sx_ConfigurationError;
	    
	END_REGION
	
	REGION 6 - Speed handling  
	    
	    //Calculate actual speed value in rpm 
	    // #sr_RPMActual := ((INT_TO_REAL(#i_UDT_VFDInputs.ActualSpeed) / #cr_MaximumValueSpeedWord) * INT_TO_REAL(#i_UDT_MotorData.NominalSpeed));
	    
	    //#sr_RPMActual := ((INT_TO_REAL(#i_UDT_VFDInputs.ActualSpeed) / #cr_MaximumValueSpeedWord) * (#i_UDT_MotorData.NominalSpeed));
	    #sr_RPMActual := ((INT_TO_REAL(#iUDT_VFDInputs.ActualSpeed) / #cr_MaximumFrequency) * (#iUDT_VFDConfig.ReferenceRPM));
	    // Calculate actual speed in mm/s                                                                                                         
	    #si_ActualSpeed := REAL_TO_INT((#sr_RPMActual / #iUDT_VFDConfig.GearRatio) * ((#iUDT_VFDConfig.WheelEndPerimeter) / 60.0));
	    
	    
	    //change the i_UDT_VFDInput.Actualspeed to RPM
	    
	    // Reversal actual speed
	    IF #iUDT_VFDConfig.DirectionReversal THEN
	        
	        #si_ActualSpeed := #si_ActualSpeed * -1;
	        
	    END_IF;
	    
	    // Calculate actual speed setpoint in rpm
	    #sr_RPMSetpoint := ((DINT_TO_REAL(INT_TO_DINT(#iqUDT_ConveyorInterface.SpeedSetpoint) * 60)) / #iUDT_VFDConfig.WheelEndPerimeter) * #iUDT_VFDConfig.GearRatio;
	    
	    // Check if speed setpoint is reached                                 
	    #sx_SpeedSetpointReached := (ABS(#si_ActualSpeed) >= (#iqUDT_ConveyorInterface.SpeedSetpoint - #iUDT_VFDConfig.SpeedSetpointWindow))
	    AND (ABS(#si_ActualSpeed) <= (#iqUDT_ConveyorInterface.SpeedSetpoint + #iUDT_VFDConfig.SpeedSetpointWindow));
	    
	    
	END_REGION
	
	REGION 7 - Prepare output data VFD
	    
	    REGION 7.1 - Set speed setpoint in forward and reverse directory 
	        
	        // If motor stopped and Run forward is requested and interlock forward is active, the speed setpoint is loaded to run forward.
	        //  IF (#i_UDT_VFDInputs.ActualSpeed = 0) AND #iq_UDT_ConveyorInterface.RunFwd AND #i_UDT_VFDConfig.InterlockFwd
	        IF #iqUDT_ConveyorInterface.RunFwd AND #iUDT_VFDConfig.InterlockFwd
	        THEN
	            #sx_RunVFDForward := TRUE;
	            #sx_RunVFDReverse := FALSE;
	        END_IF;
	        
	        // If motor stopped and Run reverse is requested and interlock reverse is active, the speed setpoint is loaded to run reverse.
	        IF (#iUDT_VFDInputs.ActualSpeed = 0) AND #iqUDT_ConveyorInterface.RunRvs AND #iUDT_VFDConfig.InterlockRvs
	        THEN
	            #sx_RunVFDReverse := TRUE;
	            #sx_RunVFDForward := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 7.2 - Stopping
	        
	        // Create trigger when direction signal falling
	        #sF_TRIG_RunFwd(CLK := #iqUDT_ConveyorInterface.RunFwd);
	        #sF_TRIG_RunRvs(CLK := #iqUDT_ConveyorInterface.RunRvs);
	        
	        // When no run signal is given the VFD should stop
	        IF NOT #iqUDT_ConveyorInterface.RunRvs AND NOT #iqUDT_ConveyorInterface.RunFwd
	            OR (#iqUDT_ConveyorInterface.RunRvs AND #iqUDT_ConveyorInterface.RunFwd)
	            OR #sF_TRIG_RunRvs.Q
	            OR #sF_TRIG_RunFwd.Q
	            
	        THEN
	            #sx_RunVFDReverse := FALSE;
	            #sx_RunVFDForward := FALSE;
	        END_IF;
	        
	        IF NOT #sx_RunVFDReverse AND NOT #sx_RunVFDForward AND (#iUDT_VFDInputs.ActualSpeed <> 0)
	        THEN
	            #sx_VFDStopping := TRUE;
	        ELSE
	            #sx_VFDStopping := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 7.3 - Check for enable operation signal
	        
	        #sx_EnableOperation := #sx_VfdAvailable
	        AND #sx_400vOk
	        AND NOT #sx_ConfigurationError
	        AND (#sx_RunVFDForward OR #sx_RunVFDReverse); // add communication error
	        
	    END_REGION
	    
	    REGION 7.4 - Write acceleration and deceleration value to drive
	        
	        //Detect is VFD is ramping up 
	        IF ABS(#sr_RPMSetpoint) > ABS(#sr_RPMActual)
	            AND NOT #sx_SpeedSetpointReached
	            AND #iUDT_VFDInputs.ZSW.OperationEnabled
	            AND (#sx_RunVFDForward OR #sx_RunVFDReverse)
	        THEN
	            // Calculate the ramp up time if the vfd configuration is changed durning process or the vfd starts from speed 0 
	            IF #sdi_LastRampTimeUp <> #iUDT_VFDConfig.VFDRampUpTime THEN
	                #si_ActualRamp := REAL_TO_UINT(UDINT_TO_REAL(#iUDT_VFDConfig.VFDRampUpTime) / UDINT_TO_REAL(#cudi_DefaultRampUpTime) * #cr_MaximumValueRampWord / (#sr_RPMSetpoint / #iUDT_VFDConfig.ReferenceRPM));
	                #si_ActualRampUpTime := #si_ActualRamp;
	            ELSE
	                #si_ActualRamp := #si_ActualRampUpTime;
	            END_IF;
	            #sdi_LastRampTimeUp := #iUDT_VFDConfig.VFDRampUpTime;
	        ELSE
	            // Calculate the ramp down time if the actual speed is greater than 0 and the configuration has changed durning process
	            // or the VFD perform the first deceleration
	            
	            IF #si_ActualSpeed <> 0 THEN
	                IF #sdi_LastRampTimeDown <> #iUDT_VFDConfig.VFDRampDownTime
	                THEN
	                    #si_ActualRamp := REAL_TO_UINT(UDINT_TO_REAL(#iUDT_VFDConfig.VFDRampDownTime) / UDINT_TO_REAL(#cudi_DefaultRampDownTime) * #cr_MaximumValueRampWord / (#sr_RPMSetpoint / #iUDT_VFDConfig.ReferenceRPM));
	                    #si_ActualRampDownTime := #si_ActualRamp;
	                    
	                ELSE
	                    #si_ActualRamp := #si_ActualRampDownTime;
	                END_IF;
	                #sdi_LastRampTimeDown := #iUDT_VFDConfig.VFDRampDownTime;
	            ELSE
	                #sdi_LastRampTimeDown := 0;
	                #sdi_LastRampTimeUp := 0;
	            END_IF;
	            
	        END_IF;
	        
	        // If the ramp value exceeds the maximum value, then the maximum value is sent to the VFD
	        IF UINT_TO_REAL(#si_ActualRamp) > #cr_MaximumValueRampWord
	        THEN
	            #qUDT_VFDOutputs.RampTimeSetPoint := REAL_TO_INT(#cr_MaximumValueRampWord);
	        ELSE
	            #qUDT_VFDOutputs.RampTimeSetPoint := REAL_TO_INT(UINT_TO_REAL(#si_ActualRamp));
	        END_IF;
	        
	        
	    END_REGION
	END_REGION
	
	REGION 8 - Auto Commmissioning 
	    
	    REGION 8.1 Initialize 
	        IF #iqx_StartCommissioning THEN
	            
	            //Caclulate theoretical reference Hz. Necessary for NORD drives cause the setpoint is given at Hz
	            //Variation of motor slip from 50Hz to reference Hz is not taken into account. That means there will always be a variantion between Setpoint and actual speed
	            #sr_ReferenceFrequency := (#iUDT_VFDConfig.ReferenceRPM / 1500) * 50; //1500 for 4 pole motor 
	            
	            // Get hardware adres of "SK-TU4-PNS~Head" submodule
	            #si_Log2GeoReturn := LOG2GEO(LADDR := "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.HW_ID, GEOADDR := #sv_VFDGeoStruct);       // "LOG2GEO" to get profinet network number
	            #sv_VFDGeoStruct.AREA := #ci_VFDArea;                                                                                                                                                                               // Set IO Profinet devices area ID
	            #sv_VFDGeoStruct.HWTYPE := #ci_SubmoduleHWType;                                                                                                                                                                     // Set submodule HW_type number
	            #sv_VFDGeoStruct.STATION := INT_TO_UINT(#sUDT_PNDevice.PNDeviceNumber);                                                                                                                                            // Set device's profinet number
	            #sv_VFDGeoStruct.SLOT := #ci_TelegramSlot;                                                                                                                                                                          // Set free telegram slot
	            #sv_VFDGeoStruct.SUBSLOT := #ci_TelegramSubslot;                                                                                                                                                                    // Set free telegram subslot
	            
	            #si_Geo2LogReturn := GEO2LOG(GEOADDR := #sv_VFDGeoStruct, LADDR => #sp_VFDTelegram);                                                                                                                              // "GEO2LOG" to get free telegram's HW_ID
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 8.2 Run - auto commissioning 
	        
	        #sFB_VfdNORDCommissiong(ix_VFDReadyToRun := #sx_400vOk AND #iUDT_VFDInputs.ZSW.EmergencyStop AND NOT #iUDT_VFDInputs.ZSW.Fault,
	                                qx_24VCommissioningDone => #sFB_VfdNORDCommissiong.qx_24VCommissioningDone,
	                                iqx_Enable := #iqx_StartCommissioning,
	                                ir_ReferenceFrequency := #sr_ReferenceFrequency,
	                                ihw_HardwareID := #sp_VFDTelegram,
	                                iudt_MotorData := #iUDT_MotorData,
	                                qi_HWAdress => #qUDT_commisioning.HWAdress,
	                                qx_Busy => #sFB_VfdNORDCommissiong.qx_Busy,
	                                qx_Done => #sFB_VfdNORDCommissiong.qx_Done,
	                                qx_Error => #sFB_VfdNORDCommissiong.qx_Error);
	        
	    END_REGION
	    
	END_REGION
	
	REGION 9 - Write outputs to VFD  
	    
	    REGION 9.1 - Write control word 1
	        
	        #qUDT_VFDOutputs.STW.ReadyForOperation := #sx_RunVFDReverse OR #sx_RunVFDForward;
	        #qUDT_VFDOutputs.STW.DisableVoltage := TRUE;
	        #qUDT_VFDOutputs.STW.EmergencyStop := #ix_QuickStopDisable;
	        #qUDT_VFDOutputs.STW.EnableOperation := TRUE;
	        #qUDT_VFDOutputs.STW.EnablePulsles := TRUE;
	        #qUDT_VFDOutputs.STW.EnableRamp := TRUE;
	        #qUDT_VFDOutputs.STW.EnableSetpoint := TRUE;
	        #qUDT_VFDOutputs.STW.Acknowledge := #sFB_TimerOnOffDelayVFDReset.qx_DelayedSignal;
	        #qUDT_VFDOutputs.STW."StartFunction408.11" := FALSE;
	        #qUDT_VFDOutputs.STW."StartFunction408.12" := FALSE;
	        #qUDT_VFDOutputs.STW.ControlDataValid := TRUE;
	        #qUDT_VFDOutputs.STW.RotationRightOn := TRUE; //direction reversal via the speed setpoint
	        #qUDT_VFDOutputs.STW.RotationLeftOn := FALSE;
	        #qUDT_VFDOutputs.STW.Reserved := FALSE;
	        #qUDT_VFDOutputs.STW.ParameterSetBit0 := FALSE; //Parameter set 1
	        #qUDT_VFDOutputs.STW.ParameterSetBit1 := FALSE; //Parameter set 1
	        
	        IF (NOT #sx_VfdAvailable OR NOT #sx_400vOk) //AND NOT #sx_StartMeasuring
	        THEN
	            #qUDT_VFDOutputs.STW.ReadyForOperation := FALSE;
	            #qUDT_VFDOutputs.STW.EmergencyStop := FALSE;
	            #qUDT_VFDOutputs.STW.EnableSetpoint := FALSE;
	            #qUDT_VFDOutputs.STW."StartFunction408.11" := FALSE;
	            #qUDT_VFDOutputs.STW."StartFunction408.12" := FALSE;
	        END_IF;
	    END_REGION
	    
	    REGION 9.2 - Write speed setpoint to drive
	        
	        // Calculate normalized speed setpoint
	        #qUDT_VFDOutputs.FrequencySetPoint := REAL_TO_INT((#sr_RPMSetpoint / #iUDT_VFDConfig.ReferenceRPM) * #cr_MaximumFrequency);
	        
	        IF #qUDT_VFDOutputs.FrequencySetPoint > #cr_MaximumFrequency
	        THEN
	            #qUDT_VFDOutputs.FrequencySetPoint := REAL_TO_INT(#cr_MaximumFrequency);
	        END_IF;
	        
	        // The conveyor stopped and may now run in reverse direction
	        IF (#sx_RunVFDReverse AND NOT #iUDT_VFDConfig.DirectionReversal)
	            OR (#sx_RunVFDForward AND #iUDT_VFDConfig.DirectionReversal)
	        THEN
	            #qUDT_VFDOutputs.FrequencySetPoint := #qUDT_VFDOutputs.FrequencySetPoint * -1;
	        END_IF;
	        
	        // Clear speed setpoint when no run request or above direction request or is configuration error
	        IF (NOT #sx_RunVFDForward AND NOT #sx_RunVFDReverse)
	            OR #sx_ConfigurationError
	        THEN
	            #qUDT_VFDOutputs.FrequencySetPoint := 0;
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 10 - Check if motor is running
	    
	    //The motor should start running after specific time. If not the VFDRunningFeedback error occured
	    #sFB_TimerOnOffDelayVFDRunningFeedbackError(iudi_OnDelayTime := #iUDT_VFDConfig.VFDStartupTime,
	                                                ix_SignalToDelay := #sx_EnableOperation AND NOT (#si_ActualSpeed <> 0));
	    
	    IF #sFB_TimerOnOffDelayVFDRunningFeedbackError.qx_DelayedSignal THEN
	        
	        #sUDT_Status.VFDRunningFeedbackError := TRUE;
	        
	    END_IF;
	    
	    
	    
	END_REGION
	
	REGION 11 - Copy signals to interface DB and to status output UDT
	    
	    // Create internal error status
	    #sx_ErrorActive := #sUDT_Status.PNSlaveNotonline
	    OR #sUDT_Status.VFDRunningFeedbackError
	    OR #sUDT_Status.PNSlaveError //Commented out BY AST TO allow run in ring topology v3.12
	    OR #sUDT_Status.InternalError;
	    
	    // Write interface bits - AST Check thoses statuses
	    #iqUDT_ConveyorInterface.VFDRunning := #sx_VfdAvailable AND (#iqUDT_ConveyorInterface.ActualSpeed <> 0 OR #qUDT_VFDOutputs.STW.ReadyForOperation);   // Write true on output Conveyor interface structure if VFD is in operation and motor is turning 
	    #iqUDT_ConveyorInterface.VFDatSpeed := #sx_SpeedSetpointReached AND #sx_VfdAvailable AND #si_ActualSpeed <> 0;                                                                                                  // Copy setpoint speed reached state from static to the output conveyor interface structure
	    #iqUDT_ConveyorInterface.InternalWarningVFD := #iUDT_VFDInputs.ZSW.WarningActive;                                                                                                      // Set the internal VFD warning bit if any warning is active
	    #iqUDT_ConveyorInterface.InternalErrorVFD := #sx_ErrorActive;                                                                                                                           // Set the internal VFD error bit if any fault is active 
	    #iqUDT_ConveyorInterface.ActualSpeed := #si_ActualSpeed;                                                                                                                                // Copy the calculated value to the output
	    #iqUDT_ConveyorInterface.ConfigurationError := #iqUDT_ConveyorInterface.ConfigurationError OR #sx_ConfigurationError;
	    
	    // Copy error status to output
	    #qUDT_HMIStatus := #sUDT_Status;
	    
	END_REGION
	
	REGION 12 - Statistic
	    // Create trigger on error and create statistics for profinet slave not online
	    #sR_TRIG_PNSlaveNotOnline(CLK := #sUDT_Status.PNSlaveNotonline);                                        // Detect the rising edge of the error
	    
	    IF #iqUDT_ConveyorInterface.ResetStatistics OR #sUDT_Status.PNSlaveNotonline
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #sUDT_Status.PNSlaveNotonline,
	                        ix_RTrigActivate := #sR_TRIG_PNSlaveNotOnline.Q,
	                        iqUDT_Statistics := #iqUDT_VFDStatistics.PNSlaveNotOnline);
	    END_IF;
	    
	    // Create trigger on error and create statistics for profinet slave error
	    #sR_TRIG_PNSlaveError(CLK := #sUDT_Status.PNSlaveError);                                        // Detect the rising edge of the error
	    
	    IF #iqUDT_ConveyorInterface.ResetStatistics OR #sUDT_Status.PNSlaveError
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #sUDT_Status.PNSlaveError,
	                        ix_RTrigActivate := #sR_TRIG_PNSlaveError.Q,
	                        iqUDT_Statistics := #iqUDT_VFDStatistics.PNSlaveError);
	    END_IF;
	    
	    // Create trigger on error and create statistics for internal VFD Error
	    #sR_TRIG_VFDInternalError(CLK := #sUDT_Status.InternalError);                                        // Detect the rising edge of the error
	    
	    IF #iqUDT_ConveyorInterface.ResetStatistics OR #sUDT_Status.InternalError
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #sUDT_Status.InternalError,
	                        ix_RTrigActivate := #sR_TRIG_VFDInternalError.Q,
	                        iqUDT_Statistics := #iqUDT_VFDStatistics.VFDInternalError);
	    END_IF;
	    
	    // Create trigger on running signal and create statistics for running status
	    #sR_TRIG_Running(CLK := #iqUDT_ConveyorInterface.VFDRunning);                                        // Detect the rising edge of the signal
	    
	    IF #iqUDT_ConveyorInterface.ResetStatistics OR #iqUDT_ConveyorInterface.VFDRunning
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #iqUDT_ConveyorInterface.VFDRunning,
	                        ix_RTrigActivate := #sR_TRIG_Running.Q,
	                        iqUDT_Statistics := #iqUDT_VFDStatistics.Running);
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

TYPE "UDT_TGWLiftHmiCommands"
VERSION : 0.1
   STRUCT
      "010" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "020" : Struct
         VSU : "UDT_VSUCommand";
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_TGWLiftStatistics"
VERSION : 0.1
   STRUCT
      "010" : Struct   // Lift conveyor Statistics
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_BoS : "UDT_PECStatistics";
         PEC_EoS : "UDT_PECStatistics";
         VFD : "UDT_VfdStatistics";
      END_STRUCT;
      "020" : Struct   // Vertical lift Statistics
         VSU { S7_SetPoint := 'False'} : "UDT_VSULiftStatistics";
         VSU_RIO : "UDT_RIOVSUStatistics";
         VFD : "UDT_VfdStatistics";
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_TGWLiftStatus"
VERSION : 0.1
   STRUCT
      "010" : Struct   // Lift conveyor status
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_BoS : "UDT_PECStatus";
         PEC_EoS : "UDT_PECStatus";
         VFD : "UDT_VfdStatus";
      END_STRUCT;
      "020" : Struct   // Vertical lift status
         VSU { S7_SetPoint := 'False'} : "UDT_VSULiftStatus";
         VSU_RIO : "UDT_RIOVSUStatus";
         VFD : "UDT_VfdPositioningStatus";
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_WSVHmiCommands"
VERSION : 0.1
   STRUCT
      "010" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "020" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "030" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "040" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "050" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "060" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "070" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "080" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "090" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "100" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "110" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "120" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "121" : Struct
         RightAngledTransfer { S7_SetPoint := 'False'} : "UDT_RATCommand";
      END_STRUCT;
      "230" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "240" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "241" : Struct
         RightAngledTransfer { S7_SetPoint := 'False'} : "UDT_RATCommand";
      END_STRUCT;
      "250" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "260" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "270" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "280" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "310" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "320" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "330" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "340" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "341" : Struct
         RightAngledTransfer { S7_SetPoint := 'False'} : "UDT_RATCommand";
      END_STRUCT;
      "350" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "351" : Struct
         RightAngledTransfer { S7_SetPoint := 'False'} : "UDT_RATCommand";
      END_STRUCT;
      "360" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "361" : Struct
         RightAngledTransfer { S7_SetPoint := 'False'} : "UDT_RATCommand";
      END_STRUCT;
      "370" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "371" : Struct
         RightAngledTransfer { S7_SetPoint := 'False'} : "UDT_RATCommand";
      END_STRUCT;
      "380" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "390" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "530" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "540" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "541" : Struct
         RightAngledTransfer { S7_SetPoint := 'False'} : "UDT_RATCommand";
      END_STRUCT;
      "550" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "560" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "570" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "580" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "610" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "620" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "630" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "640" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "641" : Struct
         RightAngledTransfer { S7_SetPoint := 'False'} : "UDT_RATCommand";
      END_STRUCT;
      "650" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "651" : Struct
         RightAngledTransfer { S7_SetPoint := 'False'} : "UDT_RATCommand";
      END_STRUCT;
      "660" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "661" : Struct
         RightAngledTransfer { S7_SetPoint := 'False'} : "UDT_RATCommand";
      END_STRUCT;
      "670" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "671" : Struct
         RightAngledTransfer { S7_SetPoint := 'False'} : "UDT_RATCommand";
      END_STRUCT;
      "680" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
      "690" : Struct
         Conveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommand";
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_WSVStatistics"
VERSION : 0.1
   STRUCT
      "010" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "020" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "030" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "040" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "050" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "060" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "070" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "080" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "090" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "100" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "110" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "120" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "121" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "230" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "240" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "241" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_RATStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "250" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECUpdateStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "260" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorStatistics";
         VFD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "270" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "280" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "310" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         VFD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "320" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "330" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "340" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "341" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "350" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "351" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "360" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "361" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "370" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "371" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "380" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "390" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "530" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "540" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "541" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_RATStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "550" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECUpdateStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "560" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorStatistics";
         VFD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "570" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "580" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorStatistics";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "610" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         VFD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "620" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "630" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "640" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "641" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "650" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "651" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "660" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "661" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "670" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "671" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "680" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
      "690" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatistics";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateStatistics";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";
      END_STRUCT;
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_Valve"
TITLE = Single ended Valve Control and monitor
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'I.Ajram'
VERSION : 0.1
   VAR_INPUT 
      iUDT_Configuration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ValveConfiguration";   // Valve configuration
      ix_Open { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Open command (Hold if ControlMode = 1, pulse if ControlMode = 2)
      ix_Close { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Close command (Not used if ControlMode = 1, pulse if ControlMode = 2)
      ix_IsOpened { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Feedback Signal ( Not used if #iqUDT_SEVConfiguration.IsOpenFeedBackExist is FALSE)
      ix_IsClosed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Feedback Signal ( Not used if #iqUDT_SEVConfiguration.IsCloseFeedBackExist is FALSE)
      ix_AirPressureOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Air pressure is healthy
   END_VAR

   VAR_OUTPUT 
      qx_Open { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Open command
      qx_Close { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Close command
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ValveStatus";
      qUDT_Statistics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ValveStatistics";
   END_VAR

   VAR_IN_OUT 
      iqUDT_HMICommand : "UDT_ValveCommand";   // Interafce for HMI commands
      iqUDT_Interface : "UDT_ValveInterface";   // Interface with external modules
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
   END_VAR

   VAR 
      sx_ManualModeSelected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_AutoModeSelected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_OpenActivated { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_CloseActivated { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_FaultActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sTON_Opening {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
      sTON_Closing {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
      sTime_Closing { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;
      sTime_Opening { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;
      RTRIG_Open {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      RTRIG_Close {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      RTRIG_FaultActive {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      RTRIG_Opened {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
   END_VAR

   VAR CONSTANT 
      ci_ControlModeHold : Int := 1;   // Energize to hold
      ci_ControlModePulse : Int := 2;   // Pulse energized to change state
      ci_ValveTypeSEV : Int := 1;   // Single coil valve
      ci_ValveTypeDEV : Int := 2;   // Double coil valve, bi-stable, latching
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	08/07/2024  | 0.1       | I. Ajram      | first release TIA 18
	16/07/2024  | 0.2       | I. Ajram      | Changed block name from FB_SEV to FB_Valve
	                                        |  +    Added Configuration to allow for SEV and DEV
	                                        |  +    Added qx_Close Output
	                                        |  +    Added logic to accomodate for DEV
	30/08/2024  | 0.3       | J. Majer      | Added comments, number regions, added iq_UDT_EquipmentInterface, iqUDT_EquipmentControl                                         
	----------------------------------------------------------------------------------------
	
	*)
	
	REGION 1 - Edge detection
	    // Trigger rising edge detection for different signals: Open, Close, FaultActive, and Opened.
	    #RTRIG_Open(CLK := #ix_Open OR #iqUDT_Interface.Open);
	    #RTRIG_Close(CLK := #ix_Close OR #iqUDT_Interface.Close);
	    #RTRIG_FaultActive(CLK := #sx_FaultActive);
	    #RTRIG_Opened(CLK := #qUDT_HMIStatus.Specific.Opened);
	    
	END_REGION
	
	REGION 2 - Auto / Manual
	    
	    // Handle auto mode command.
	    IF #iqUDT_EquipmentControl.Command.Start AND #iqUDT_EquipmentControl.Command.AutomaticOn
	    THEN
	        #sx_AutoModeSelected := TRUE;
	        #sx_ManualModeSelected := FALSE;
	        #iqUDT_HMICommand.AutoMode := FALSE;
	    END_IF;
	    
	    // Manual mode bits inputs can be reset in case of malfunction
	    IF #iqUDT_EquipmentControl.Command.DisableManualMode
	    THEN
	        #iqUDT_HMICommand.ManualMode := FALSE;
	        #iqUDT_EquipmentControl.Command.ManualMode := FALSE;
	    END_IF;
	    
	    // Handle manual mode command.
	    IF (#iqUDT_EquipmentControl.Command.ManualMode OR #iqUDT_HMICommand.ManualMode)
	        AND NOT #iqUDT_EquipmentControl.Command.DisableManualMode
	    THEN
	        #sx_AutoModeSelected := FALSE;
	        #sx_ManualModeSelected := TRUE;
	        #iqUDT_HMICommand.ManualMode := FALSE;
	    END_IF;
	    
	    REGION 2.1 - Restart request
	        
	        // Indicating need for system restart if no mode is selected
	        #iqUDT_EquipmentControl.Request.RestartRequired := NOT #sx_AutoModeSelected
	        AND NOT #sx_AutoModeSelected;
	        
	    END_REGION
	END_REGION
	
	REGION 3 - Faults
	    
	    REGION 3.1 - Configuration Error
	        // Check for configuration errors by validating the ControlMode and ValveType values.
	        IF #iUDT_Configuration.ControlMode < #ci_ControlModeHold
	            OR #iUDT_Configuration.ControlMode > #ci_ControlModePulse
	            OR #iUDT_Configuration.ValveType < #ci_ValveTypeSEV
	            OR #iUDT_Configuration.ValveType > #ci_ValveTypeDEV
	        THEN
	            #qUDT_HMIStatus.Specific.ConfigurationError := TRUE;
	        ELSE
	            #qUDT_HMIStatus.Specific.ConfigurationError := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 3.2 - Low Pressure
	        // Set AirPressureLost flag if air pressure is not okay.
	        IF NOT #ix_AirPressureOk THEN
	            #qUDT_HMIStatus.Specific.AirPressureLost := TRUE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 3.3 - Fail to Open
	        // Set FailToOpen flag if the valve failed to open within the expected time.
	        IF #sTON_Opening.Q AND #iUDT_Configuration.OpenFeedBackExist THEN
	            #qUDT_HMIStatus.Specific.FailToOpen := TRUE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 3.4 - Fail to Close
	        // Set FailToClose flag if the valve failed to close within the expected time.
	        IF #sTON_Closing.Q AND #iUDT_Configuration.CloseFeedBackExist THEN
	            #qUDT_HMIStatus.Specific.FailToClose := TRUE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 3.4 - Collective fault
	        // Set FaultActive flag if any specific fault is detected (fail to open/close, air pressure lost, or configuration error).
	        #sx_FaultActive := #qUDT_HMIStatus.Specific.FailToClose OR
	        #qUDT_HMIStatus.Specific.FailToOpen OR
	        #qUDT_HMIStatus.Specific.AirPressureLost OR
	        #qUDT_HMIStatus.Specific.ConfigurationError;
	        
	        // forward error to the interface with other modules
	        #iqUDT_Interface.Error := #sx_FaultActive;
	        
	        // If FaultActive is set, deactivate open and close commands.
	        IF #sx_FaultActive THEN
	            #sx_OpenActivated := FALSE;
	            #sx_CloseActivated := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 3.5 - Reset
	        // Reset fault flags and set air pressure flag based on the state of AirPressureOk.
	        IF #iqUDT_EquipmentControl.Command.Reset THEN
	            #qUDT_HMIStatus.Specific.FailToOpen := FALSE;
	            #qUDT_HMIStatus.Specific.FailToClose := FALSE;
	            #qUDT_HMIStatus.Specific.AirPressureLost := NOT #ix_AirPressureOk;
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 4 - Command
	    // Process commands based on the current mode (Auto/Manual) and fault state.
	    IF NOT #sx_FaultActive THEN
	        
	        REGION 4.1 - Auto
	            // Handle command logic in Auto mode based on control mode (Hold or Pulse).
	            IF #sx_AutoModeSelected THEN
	                CASE #iUDT_Configuration.ControlMode OF
	                        
	                        // ControlModeHold: Open/close based on the ix_Open signal.
	                    #ci_ControlModeHold:
	                        #sx_OpenActivated := #ix_Open;
	                        #sx_CloseActivated := NOT #ix_Open;
	                        
	                        // ControlModePulse: Open/close based on rising edge detection.
	                    #ci_ControlModePulse:
	                        IF #RTRIG_Open.Q AND NOT #ix_IsOpened THEN
	                            #sx_OpenActivated := TRUE;
	                            #sx_CloseActivated := FALSE;
	                        END_IF;
	                        
	                        IF #RTRIG_Close.Q AND NOT #ix_IsClosed THEN
	                            #sx_OpenActivated := FALSE;
	                            #sx_CloseActivated := TRUE;
	                        END_IF;
	                        
	                END_CASE;
	            END_IF;
	            
	        END_REGION
	        
	        REGION 4.2 - Manual
	            // Handle command logic in Manual mode based on control mode (Hold or Pulse).
	            IF #sx_ManualModeSelected THEN
	                CASE #iUDT_Configuration.ControlMode OF
	                        
	                        // ControlModeHold: Open/close based on manual commands.
	                    #ci_ControlModeHold:
	                        #sx_OpenActivated := #iqUDT_HMICommand.ManualOpen;
	                        #sx_CloseActivated := #iqUDT_HMICommand.ManualClose;
	                        
	                        // ControlModePulse: Open/close based on manual commands with feedback checks.
	                    #ci_ControlModePulse:
	                        IF #iqUDT_HMICommand.ManualOpen AND NOT #ix_IsOpened THEN
	                            #sx_OpenActivated := TRUE;
	                            #sx_CloseActivated := FALSE;
	                            #iqUDT_HMICommand.ManualOpen := FALSE;
	                        END_IF;
	                        
	                        IF #iqUDT_HMICommand.ManualClose AND NOT #ix_IsClosed THEN
	                            #sx_OpenActivated := FALSE;
	                            #sx_CloseActivated := TRUE;
	                            #iqUDT_HMICommand.ManualClose := FALSE;
	                        END_IF;
	                        
	                END_CASE;
	            END_IF;
	            
	        END_REGION
	    ELSE
	        // On fault, clear all open/close commands.
	        #sx_OpenActivated := FALSE;
	        #sx_CloseActivated := FALSE;
	        #iqUDT_HMICommand.ManualClose := FALSE;
	        #iqUDT_HMICommand.ManualOpen := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Statistics
	    // Update statistical data when reset or fault occurs.
	    IF #iqUDT_EquipmentControl.Command.ResetData OR #sx_FaultActive THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sx_FaultActive,
	                        ix_RTrigActivate := #RTRIG_FaultActive.Q,
	                        iqUDT_Statistics := #qUDT_Statistics.Fail);
	    END_IF;
	    
	    // Update open statistics when reset or opened.
	    IF #iqUDT_EquipmentControl.Command.ResetData OR #qUDT_HMIStatus.Specific.Opened THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #qUDT_HMIStatus.Specific.Opened,
	                        ix_RTrigActivate := #RTRIG_Opened.Q,
	                        iqUDT_Statistics := #qUDT_Statistics.Open);
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Status
	    
	    REGION 6.1 - Opened / Closed
	        // Handle open/close status based on feedback or timers.
	        IF #iUDT_Configuration.OpenFeedBackExist THEN
	            // Set opened status based on feedback.
	            #qUDT_HMIStatus.Specific.Opened := #ix_IsOpened;
	        ELSE
	            // Use opening timer as an indicator if feedback is not available.
	            IF #sTON_Opening.Q THEN
	                #qUDT_HMIStatus.Specific.Opened := TRUE;
	            END_IF;
	            IF #sx_CloseActivated THEN
	                #qUDT_HMIStatus.Specific.Opened := FALSE;
	            END_IF;
	        END_IF;
	        
	        // Module interface valve feedback opened 
	        #iqUDT_Interface.IsOpened := #qUDT_HMIStatus.Specific.Opened;
	        
	        IF #iUDT_Configuration.CloseFeedBackExist THEN
	            // Set closed status based on feedback.
	            #qUDT_HMIStatus.Specific.Closed := #ix_IsClosed;
	        ELSE
	            // Use closing timer as an indicator if feedback is not available.
	            IF #sTON_Closing.Q THEN
	                #qUDT_HMIStatus.Specific.Closed := TRUE;
	            END_IF;
	            IF #sx_OpenActivated THEN
	                #qUDT_HMIStatus.Specific.Closed := FALSE;
	            END_IF;
	        END_IF;
	        
	        // Module interface valve feedback closed 
	        #iqUDT_Interface.IsClosed := #qUDT_HMIStatus.Specific.Closed;
	        
	    END_REGION
	    
	    REGION 6.2 - Opening
	        // Handle the logic for the valve opening, including timer initialization and status updates.
	        IF #iUDT_Configuration.OpenTime = 0 THEN
	            #sTime_Opening := T#1s;  // Default to 1 second if not configured.
	        ELSE
	            #sTime_Opening := INT_TO_TIME(#iUDT_Configuration.OpenTime);  // Use configured open time.
	        END_IF;
	        
	        IF #sx_OpenActivated AND NOT #qUDT_HMIStatus.Specific.Opened THEN
	            #qUDT_HMIStatus.Specific.Opening := TRUE;
	        ELSE
	            #qUDT_HMIStatus.Specific.Opening := FALSE;
	        END_IF;
	        
	        // Start the opening timer.
	        #sTON_Opening(IN := #qUDT_HMIStatus.Specific.Opening,
	                      PT := #sTime_Opening);
	        
	    END_REGION
	    
	    REGION 6.3 - Closing
	        // Handle the logic for the valve closing, including timer initialization and status updates.
	        IF #iUDT_Configuration.CloseTime = 0 THEN
	            #sTime_Closing := T#1s;  // Default to 1 second if not configured.
	        ELSE
	            #sTime_Closing := INT_TO_TIME(#iUDT_Configuration.CloseTime);  // Use configured close time.
	        END_IF;
	        
	        IF #sx_CloseActivated AND NOT #qUDT_HMIStatus.Specific.Closed THEN
	            #qUDT_HMIStatus.Specific.Closing := TRUE;
	        ELSE
	            #qUDT_HMIStatus.Specific.Closing := FALSE;
	        END_IF;
	        
	        // Start the closing timer.
	        #sTON_Closing(IN := #qUDT_HMIStatus.Specific.Closing,
	                      PT := #sTime_Closing);
	        
	    END_REGION
	    
	END_REGION
	
	REGION 7 - Output
	    
	    // Select the action based on the valve type configuration
	    CASE #iUDT_Configuration.ValveType OF
	            
	            // SEV Valve Type
	        #ci_ValveTypeSEV:
	            // The valve opens if Open is activated, Close is not activated, and no fault is active
	            #qx_Open :=
	            #sx_OpenActivated AND
	            NOT #sx_CloseActivated AND
	            NOT #sx_FaultActive;
	            
	            // Reset the open signal, SEV logic requires manual reset after operation
	            #qx_Open := FALSE;
	            
	            // DEV Valve Type
	        #ci_ValveTypeDEV:
	            // The valve opens if there are no faults, Open is activated, and the valve is not yet opened
	            #qx_Open :=
	            NOT #sx_FaultActive AND
	            #sx_OpenActivated AND NOT #qUDT_HMIStatus.Specific.Opened;
	            
	            // The valve closes if there are no faults, Close is activated, and the valve is not yet closed
	            #qx_Close :=
	            NOT #sx_FaultActive AND
	            #sx_CloseActivated AND NOT #qUDT_HMIStatus.Specific.Closed;
	            
	            // If the valve is opened, a fault occurs, or the valve is in the closing state, deactivate Open
	            IF #qUDT_HMIStatus.Specific.Opened OR
	                #sx_FaultActive OR
	                #qUDT_HMIStatus.Specific.Closing
	            THEN
	                #sx_OpenActivated := FALSE;
	            END_IF;
	            
	            // If the valve is closed, a fault occurs, or the valve is in the opening state, deactivate Close
	            IF #qUDT_HMIStatus.Specific.Closed OR
	                #sx_FaultActive OR
	                #qUDT_HMIStatus.Specific.Opening
	            THEN
	                #sx_CloseActivated := FALSE;
	            END_IF;
	            
	    END_CASE;
	    
	END_REGION
	
END_FUNCTION_BLOCK

TYPE "UDT_TGWLiftCommonStatus"
VERSION : 0.1
   STRUCT
      "010" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "020" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
   END_STRUCT;

END_TYPE

TYPE "UDT_WSVStatus"
VERSION : 0.1
   STRUCT
      "010" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "020" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "030" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "040" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "050" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "060" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "070" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "080" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "090" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "100" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "110" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "120" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "121" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "230" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "240" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "241" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_RATStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "250" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECUpdateStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "260" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorStatus";
         VFD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdStatus";
      END_STRUCT;
      "270" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "280" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "310" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         VFD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdStatus";
      END_STRUCT;
      "320" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "330" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "340" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "341" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "350" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "351" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "360" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "361" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "370" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "371" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "380" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "390" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "530" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "540" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "541" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_RATStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "550" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECUpdateStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "560" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorStatus";
         VFD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdStatus";
      END_STRUCT;
      "570" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "580" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorStatus";
         PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "610" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         VFD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdStatus";
      END_STRUCT;
      "620" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "630" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "640" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "641" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "650" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "651" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "660" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "661" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "670" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "671" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RightAngledTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RATStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "680" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
      "690" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";
         PEC_Eos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateStatus";
         MCO_M01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_WSVCommonStatus"
VERSION : 0.1
   STRUCT
      "010" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "020" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "030" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "040" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "050" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "060" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "070" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "080" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "090" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "100" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "110" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "120" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "121" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "230" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "240" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "241" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "250" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "260" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "270" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "280" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "310" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "320" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "330" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "340" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "341" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "350" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "351" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "360" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "361" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "370" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "371" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "380" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "390" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "530" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "540" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "541" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "550" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "560" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "570" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "580" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "610" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "620" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "630" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "640" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "641" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "650" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "651" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "660" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "661" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "670" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "671" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "680" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      "690" { S7_SetPoint := 'False'} : "UDT_CommonStatus";
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_HMDecode"
TITLE = FB_H&MDecode
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Fortna
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 197
// END_ATTRIBUTES
//Function block to decode H&M messages.
   VAR_INPUT 
      II_PLCID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // PLC ID number
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective error output
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective warning output
   END_VAR

   VAR_IN_OUT 
      iqUDT_FifoRcvHeader : "UDT_FifoHeader";   // FIFO receive header
      iqa_FifoRcvData : Array[*] of "UDT_Message";   // FIFO receive data
      iqx_HeartBeat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat message detect
   END_VAR

   VAR 
      sUDT_MessageHeader { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_HMMessageHeader";
      sUDT_FifoMsg { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Message";   // Buffer for fifos message
      sa_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         BadMessage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..10] of "UDT_Message";   //   Unknown message read
         FIFORcvStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";   //   Receive FIFO status structure
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //   FIFO error
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //   FIFO warning
         AcknowledgeError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //   Acknowledge error
         AcknowledgeWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //   Acknowledge warning
         HB_NotOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Health bit not OK
      END_STRUCT;
      sa_HBRec { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // HB message last received timestamp (as string)
         "Date" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;
         "Time" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;
      END_STRUCT;
      sa_DestRec { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Destination message last received timestamp (as string)
         Gin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[4];   // Gin of this product
         Dest1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[4];   // First possible destination
         Dest2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[4];   // Second possible destination
         Dest3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[4];   // Third possible destination
         Dest4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[4];   // Fourth possible destination
      END_STRUCT;
      si_PLCID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // PLC ID number
      si_FoundPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Character found at this position in string
      si_Gin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // GIN sent by HLC
      sx_HB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // HB message detect
   END_VAR

   VAR_TEMP 
      ti_Position : Int;   // Temporary position parial message
      tx_MsgRead : Bool;   // Message read from FIFO
   END_VAR

   VAR CONSTANT 
      cc_DL : Char := '$1D';   // Comma sign
      cs_HB : String := 'HB';   // "HB" message type
      cs_DRespM : String := 'DRespM';   // "DRespM" message type
      cs_GIN : String := 'GIN';   // Gin
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	18/092/2023 | 4.0       | F.Baten       | First Release TIA 17.5
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #sa_Status.FIFORcvStatus,
	              qx_Error => #sa_Status.FIFOError,
	              qx_Warning => #sa_Status.FIFOWarning,
	              iqv_Data := #sUDT_FifoMsg,
	              iqUDT_FifoHeader := #iqUDT_FifoRcvHeader,
	              iqv_DataBuffer := #iqa_FifoRcvData);
	    
	    IF (NOT #iqUDT_FifoRcvHeader.Status.Empty                               // FIFO not empty 
	        AND NOT #sa_Status.FIFOError)                                       // No FIFO error 
	    THEN
	        
	        // Mode 'R' - Read FIFO record
	        "FC_Fifo"(ic_Mode := 'R',
	                  qUDT_Status => #sa_Status.FIFORcvStatus,
	                  qx_Error => #sa_Status.FIFOError,
	                  qx_Warning => #sa_Status.FIFOWarning,
	                  iqv_Data := #sUDT_FifoMsg,
	                  iqUDT_FifoHeader := #iqUDT_FifoRcvHeader,
	                  iqv_DataBuffer := #iqa_FifoRcvData);
	        
	        // Message read bit set and position initialize 
	        #tx_MsgRead := TRUE;
	        #ti_Position := 0;
	        
	        // FIFO empty or FIFO error occured      
	    ELSE
	        
	        #tx_MsgRead := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	
	REGION 2 – Decoding header
	    
	    IF #tx_MsgRead      // New message
	    THEN
	        // Header decode
	        "FC_HMDecodeHeader"(iUDT_FifoMsg := #sUDT_FifoMsg,
	                            qUDT_MSG => #sUDT_MessageHeader);
	        
	        // Check if message was intended for this PLC
	        #si_PLCID := STRING_TO_INT(IN := #sUDT_MessageHeader.PLCID);
	        
	        IF #si_PLCID <> #II_PLCID
	        THEN
	            #tx_MsgRead := FALSE;
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Decoding body
	    
	    IF #tx_MsgRead                                                              // New message
	    THEN
	        // HB
	        IF #sUDT_MessageHeader.MessageHeader = #cs_HB
	        THEN
	            // Faciality ID
	            Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                          pChars := 31,
	                          Cnt := 9,
	                          Strg => #sa_HBRec."Date");
	            
	            // System ID
	            Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                          pChars := 40,
	                          Cnt := 12,
	                          Strg => #sa_HBRec."Time");
	            
	            #sx_HB := TRUE;
	        END_IF;
	        
	        IF #sUDT_MessageHeader.MessageHeader = #cs_DRespM
	        THEN
	            
	            // Gin
	            Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                          pChars := 63,
	                          Cnt := 4,
	                          Strg => #sa_DestRec.Gin);
	            
	            // destination 1
	            Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                          pChars := 81,
	                          Cnt := 4,
	                          Strg => #sa_DestRec.Dest1);
	            
	            // destination 2
	            Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                          pChars := 88,
	                          Cnt := 4,
	                          Strg => #sa_DestRec.Dest2);
	            
	            // destination 3
	            Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                          pChars := 95,
	                          Cnt := 4,
	                          Strg => #sa_DestRec.Dest3);
	            
	            // destination 4
	            Chars_TO_Strg(Chars := #sUDT_FifoMsg.Character,
	                          pChars := 102,
	                          Cnt := 4,
	                          Strg => #sa_DestRec.Dest4);
	        END_IF;
	        
	    END_IF;
	END_REGION
	
	REGION 4 - Convert and write
	    
	    IF #tx_MsgRead      // New message
	    THEN
	        
	        #si_Gin := STRING_TO_INT(IN := #sa_DestRec.Gin);
	        
	        // Write data from destination assignment message to GIN array 
	        IF #si_Gin > 0
	            AND #si_Gin <= 9999
	        THEN
	            IF #sa_DestRec.Dest1 = 'P001' THEN
	                "DB_GIN".GIN[#si_Gin].General.Destination[0] := 1;
	            ELSIF #sa_DestRec.Dest1 = 'P002' THEN
	                "DB_GIN".GIN[#si_Gin].General.Destination[0] := 2;
	            ELSIF #sa_DestRec.Dest1 = 'BOTH' THEN
	                "DB_GIN".GIN[#si_Gin].General.Destination[0] := 3;
	            ELSIF #sa_DestRec.Dest1 = 'NONE' THEN
	                "DB_GIN".GIN[#si_Gin].General.Destination[0] := 99;
	            END_IF;
	            
	            IF #sa_DestRec.Dest2 = 'P001' THEN
	                "DB_GIN".GIN[#si_Gin].General.Destination[1] := 1;
	            ELSIF #sa_DestRec.Dest2 = 'P002' THEN
	                "DB_GIN".GIN[#si_Gin].General.Destination[1] := 2;
	            ELSIF #sa_DestRec.Dest2 = 'BOTH' THEN
	                "DB_GIN".GIN[#si_Gin].General.Destination[1] := 3;
	            ELSIF #sa_DestRec.Dest2 = 'NONE' THEN
	                "DB_GIN".GIN[#si_Gin].General.Destination[1] := 99;
	            END_IF;
	            
	            IF #sa_DestRec.Dest3 = 'P001' THEN
	                "DB_GIN".GIN[#si_Gin].General.Destination[2] := 1;
	            ELSIF #sa_DestRec.Dest3 = 'P002' THEN
	                "DB_GIN".GIN[#si_Gin].General.Destination[2] := 2;
	            ELSIF #sa_DestRec.Dest3 = 'BOTH' THEN
	                "DB_GIN".GIN[#si_Gin].General.Destination[2] := 3;
	            ELSIF #sa_DestRec.Dest3 = 'NONE' THEN
	                "DB_GIN".GIN[#si_Gin].General.Destination[2] := 99;
	            END_IF;
	            
	            IF #sa_DestRec.Dest4 = 'P001' THEN
	                "DB_GIN".GIN[#si_Gin].General.Destination[3] := 1;
	            ELSIF #sa_DestRec.Dest4 = 'P002' THEN
	                "DB_GIN".GIN[#si_Gin].General.Destination[3] := 2;
	            ELSIF #sa_DestRec.Dest4 = 'BOTH' THEN
	                "DB_GIN".GIN[#si_Gin].General.Destination[3] := 3;
	            ELSIF #sa_DestRec.Dest4 = 'NONE' THEN
	                "DB_GIN".GIN[#si_Gin].General.Destination[3] := 99;
	            END_IF;
	            
	        END_IF;
	        
	    END_IF;
	END_REGION
	
	
	
	
	
	
	
	
	
	
	
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_WSV"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 269
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_Configuration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_WSVConfiguration";   // Workstation configuration structure
      iUDT_MotorInput010 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 010 ConveyLinxAix inputs structure
      iUDT_MotorInput020 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 020 ConveyLinxAix inputs structure
      iUDT_MotorInput030 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 030 ConveyLinxAix inputs structure
      iUDT_MotorInput040 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 040 ConveyLinxAix inputs structure
      iUDT_MotorInput050 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 050 ConveyLinxAix inputs structure
      iUDT_MotorInput060 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 060 ConveyLinxAix inputs structure
      iUDT_MotorInput070 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 070 ConveyLinxAix inputs structure
      iUDT_MotorInput080 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 080 ConveyLinxAix inputs structure
      iUDT_MotorInput090 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 090 ConveyLinxAix inputs structure
      iUDT_MotorInput100 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 100 ConveyLinxAix inputs structure
      iUDT_MotorInput110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 110 ConveyLinxAix inputs structure
      iUDT_MotorInput120 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 120 ConveyLinxAix inputs structure
      iUDT_MotorInput230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 230 ConveyLinxAix inputs structure
      iUDT_MotorInput240 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 240 ConveyLinxAix inputs structure
      iUDT_MotorInput250 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 250 ConveyLinxAix inputs structure
      iUDT_MotorInput260 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdNordPI";   // 260 Nord inputs structure
      iUDT_MotorInput270 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 270 ConveyLinxAix inputs structure
      iUDT_MotorInput310 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdNordPI";   // 310 Nord inputs structure
      iUDT_MotorInput320 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 320 ConveyLinxAix inputs structure
      iUDT_MotorInput340 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 340 ConveyLinxAix inputs structure
      iUDT_MotorInput350 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 350 ConveyLinxAix inputs structure
      iUDT_MotorInput360 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 360 ConveyLinxAix inputs structure
      iUDT_MotorInput370 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 370 ConveyLinxAix inputs structure
      iUDT_MotorInput380 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 380 ConveyLinxAix inputs structure
      iUDT_MotorInput390 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 390 ConveyLinxAix inputs structure
      iUDT_MotorInput530 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 530 ConveyLinxAix inputs structure
      iUDT_MotorInput540 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 540 ConveyLinxAix inputs structure
      iUDT_MotorInput550 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 550 ConveyLinxAix inputs structure
      iUDT_MotorInput560 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdNordPI";   // 560 Nord inputs structure
      iUDT_MotorInput570 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 570 ConveyLinxAix inputs structure
      iUDT_MotorInput610 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdNordPI";   // 610 Nord inputs structure
      iUDT_MotorInput620 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 620 ConveyLinxAix inputs structure
      iUDT_MotorInput640 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 640 ConveyLinxAix inputs structure
      iUDT_MotorInput650 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 650 ConveyLinxAix inputs structure
      iUDT_MotorInput660 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 660 ConveyLinxAix inputs structure
      iUDT_MotorInput670 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 670 ConveyLinxAix inputs structure
      iUDT_MotorInput680 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 680 ConveyLinxAix inputs structure
      iUDT_MotorInput690 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 690 ConveyLinxAix inputs structure
      iUDT_MotorData260 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_MotorData";   // 260 Motor data structure
      iUDT_MotorData310 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_MotorData";   // 310 Motor data structure
      iUDT_MotorData560 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_MotorData";   // 560 Motor data structure
      iUDT_MotorData610 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_MotorData";   // 610 Motor data structure
      iUDT_ScannerInput110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CognexDM260_IN";   // Cognex inputs structur
      iUDT_ScannerInput330 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CognexDM260_IN";
      iUDT_ScannerInput630 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CognexDM260_IN";
      iUDT_Blade_IN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_DataLogicBlade_IN_SN";
      ix_24vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 24VDC is healthy
      ix_400vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 400VAC is healthy
      ix_SafetyOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when safety is ok
      ix_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when hardware is ok
      ix_AirPressureOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when air pressure is ok
      ix_SectionIsUp121 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 121 section is up
      ix_SectionIsDown121 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 121 section is down
      ix_SectionIsUp241 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 241 section is up
      ix_SectionIsDown241 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 241 section is down
      ix_SectionIsUp341 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 341 section is up
      ix_SectionIsDown341 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 341 section is down
      ix_SectionIsUp351 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 351 section is up
      ix_SectionIsDown351 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 351 section is down
      ix_SectionIsUp361 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 361 section is up
      ix_SectionIsDown361 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 361 section is down
      ix_SectionIsUp371 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 371 section is up
      ix_SectionIsDown371 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 371 section is down
      ix_SectionIsUp541 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 541 section is up
      ix_SectionIsDown541 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 541 section is down
      ix_SectionIsUp641 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 641 section is up
      ix_SectionIsDown641 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 641 section is down
      ix_SectionIsUp651 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 651 section is up
      ix_SectionIsDown651 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 651 section is down
      ix_SectionIsUp661 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 661 section is up
      ix_SectionIsDown661 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 661 section is down
      ix_SectionIsUp671 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 671 section is up
      ix_SectionIsDown671 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 671 section is down
      ix_LeftStationActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when left station is active
      ix_RightStationActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when right station is active
      ix_LeftReqFromMid { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when signal from operator to send tray left
      ix_RightReqFromMid { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when signal from operator to send tray right
      ix_StationActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_OUTPUT 
      qUDT_MotorOutput010 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 010 ConveyLinxAix outputs structure
      qUDT_MotorOutput020 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 020 ConveyLinxAix outputs structure
      qUDT_MotorOutput030 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 030 ConveyLinxAix outputs structure
      qUDT_MotorOutput040 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 040 ConveyLinxAix outputs structure
      qUDT_MotorOutput050 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 050 ConveyLinxAix outputs structure
      qUDT_MotorOutput060 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 060 ConveyLinxAix outputs structure
      qUDT_MotorOutput070 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 070 ConveyLinxAix outputs structure
      qUDT_MotorOutput080 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 080 ConveyLinxAix outputs structure
      qUDT_MotorOutput090 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 090 ConveyLinxAix outputs structure
      qUDT_MotorOutput100 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 100 ConveyLinxAix outputs structure
      qUDT_MotorOutput110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 110 ConveyLinxAix outputs structure
      qUDT_MotorOutput120 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 120 ConveyLinxAix outputs structure
      qUDT_MotorOutput230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 230 ConveyLinxAix outputs structure
      qUDT_MotorOutput240 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 240 ConveyLinxAix outputs structure
      qUDT_MotorOutput250 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 250 ConveyLinxAix outputs structure
      qUDT_MotorOutput260 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdNordPO";   // 260 Nord outputs structure
      qUDT_MotorOutput270 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 270 ConveyLinxAix outputs structure
      qUDT_MotorOutput310 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdNordPO";   // 310 Nord outputs structure
      qUDT_MotorOutput320 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 320 ConveyLinxAix outputs structure
      qUDT_MotorOutput340 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 340 ConveyLinxAix outputs structure
      qUDT_MotorOutput350 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 350 ConveyLinxAix outputs structure
      qUDT_MotorOutput360 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 360 ConveyLinxAix outputs structure
      qUDT_MotorOutput370 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 370 ConveyLinxAix outputs structure
      qUDT_MotorOutput380 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 380 ConveyLinxAix outputs structure
      qUDT_MotorOutput390 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 390 ConveyLinxAix outputs structure
      qUDT_MotorOutput530 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 530 ConveyLinxAix outputs structure
      qUDT_MotorOutput540 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 540 ConveyLinxAix outputs structure
      qUDT_MotorOutput550 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 550 ConveyLinxAix outputs structure
      qUDT_MotorOutput560 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdNordPO";   // 560 Nord outputs structure
      qUDT_MotorOutput570 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 570 ConveyLinxAix outputs structure
      qUDT_MotorOutput610 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdNordPO";   // 610 Nord outputs structure
      qUDT_MotorOutput620 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 620 ConveyLinxAix outputs structure
      qUDT_MotorOutput640 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 640 ConveyLinxAix outputs structure
      qUDT_MotorOutput650 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 650 ConveyLinxAix outputs structure
      qUDT_MotorOutput660 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 660 ConveyLinxAix outputs structure
      qUDT_MotorOutput670 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 670 ConveyLinxAix outputs structure
      qUDT_MotorOutput680 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 680 ConveyLinxAix outputs structure
      qUDT_MotorOutput690 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 690 ConveyLinxAix outputs structure
      qUDT_ScannerOutput110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CognexDM260_OUT";   // Cognex output structure
      qUDT_ScannerOutput330 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CognexDM260_OUT";
      qUDT_ScannerOutput630 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CognexDM260_OUT";
      qx_PopupControl121 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command up for section 121
      qx_PopupControl241 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command up for section 241
      qx_PopupControl341 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command up for section 341
      qx_PopupControl351 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command up for section 351
      qx_PopupControl361 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command up for section 361
      qx_PopupControl371 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command up for section 371
      qx_PopupControl541 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command up for section 541
      qx_PopupControl641 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command up for section 641
      qx_PopupControl651 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command up for section 651
      qx_PopupControl661 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command up for section 661
      qx_PopupControl671 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command up for section 671
      qx_BladeOUT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
      iqUDT_HandshakeUpstream010 : "UDT_ConveyorHandshake";
      iqUDT_HandshakeDownstream280 : "UDT_ConveyorHandshake";   // Downstream handshake structure for conveyor 280
      iqUDT_HandshakeUpstream310 : "UDT_ConveyorHandshake";   // Upstream handshake structure for conveyor 310
      iqUDT_HandshakeDownstream580 : "UDT_ConveyorHandshake";   // Downstream handshake structure for conveyor 580
      iqUDT_HandshakeUpstream610 : "UDT_ConveyorHandshake";   // Upstream handshake structure for conveyor 610
      iqUDT_UnknownGINRange : "UDT_UnknownGIN";   // Unknown GIN
      iqUDT_WorkstationCommands : "UDT_WSVHmiCommands";   // Workstation command structure
      iqUDT_WorkstationStatistics : "UDT_WSVStatistics";   // Statistics structure
      iqUDT_WorkstationStatus : "UDT_WSVStatus";   // HMI Status structure
      iqUDT_WorkstationCommonStatus : "UDT_WSVCommonStatus";   // Common status structure
      iqUDT_RATPositioning120 : "UDT_RATPositioning";   // Structure including data for servo control RAT 120
      iqUDT_RATPositioning240 : "UDT_RATPositioning";   // Structure including data for servo control RAT 240
      iqUDT_RATPositioning340 : "UDT_RATPositioning";   // Structure including data for servo control RAT 340
      iqUDT_RATPositioning350 : "UDT_RATPositioning";   // Structure including data for servo control RAT 350
      iqUDT_RATPositioning360 : "UDT_RATPositioning";   // Structure including data for servo control RAT 360
      iqUDT_RATPositioning370 : "UDT_RATPositioning";   // Structure including data for servo control RAT 370
      iqUDT_RATPositioning540 : "UDT_RATPositioning";   // Structure including data for servo control RAT 540
      iqUDT_RATPositioning640 : "UDT_RATPositioning";   // Structure including data for servo control RAT 640
      iqUDT_RATPositioning650 : "UDT_RATPositioning";   // Structure including data for servo control RAT 650
      iqUDT_RATPositioning660 : "UDT_RATPositioning";   // Structure including data for servo control RAT 660
      iqUDT_RATPositioning670 : "UDT_RATPositioning";   // Structure including data for servo control RAT 670
      iqUDT_ScannerInput110 : "UDT_ScannerInterface";
      iqUDT_ScannerInput330 : "UDT_ScannerInterface";
      iqUDT_ScannerInput630 : "UDT_ScannerInterface";
      iqx_StartComissioning260 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start comissioning bit for 260 VFD
      iqx_StartComissioning310 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start comissioning bit for 310 VFD
      iqx_StartComissioning560 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start comissioning bit for 560 VFD
      iqx_StartComissioning610 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start comissioning bit for 610 VFD
      iqx_Done380 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request to take away from 380
      iqx_Done390 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request to take away from 390
      iqx_Done680 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request to take away from 680
      iqx_Done690 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request to take away from 690
   END_VAR

   VAR 
      sFB_Displacement010 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 010 conveyor
      sFB_Displacement020 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 020 conveyor
      sFB_Displacement030 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 030 conveyor
      sFB_Displacement040 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 040 conveyor
      sFB_Displacement050 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 050 conveyor
      sFB_Displacement060 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 060 conveyor
      sFB_Displacement070 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 070 conveyor
      sFB_Displacement080 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 080 conveyor
      sFB_Displacement090 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 090 conveyor
      sFB_Displacement100 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 100 conveyor
      sFB_Displacement110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 110 conveyor
      sFB_Displacement120 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 120 conveyor
      sFB_Displacement121 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 121 conveyor
      sFB_Displacement230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 230 conveyor
      sFB_Displacement240 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 240 conveyor
      sFB_Displacement241 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 241 conveyor
      sFB_Displacement250 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 250 conveyor
      sFB_Displacement260 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 260 conveyor
      sFB_Displacement270 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 270 conveyor
      sFB_Displacement280 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 280 conveyor
      sFB_Displacement310 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 310 conveyor
      sFB_Displacement320 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 320 conveyor
      sFB_Displacement330 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 330 conveyor
      sFB_Displacement340 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 340 conveyor
      sFB_Displacement341 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 341 conveyor
      sFB_Displacement350 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 350 conveyor
      sFB_Displacement351 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 351 conveyor
      sFB_Displacement360 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 360 conveyor
      sFB_Displacement361 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 361 conveyor
      sFB_Displacement370 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 370 conveyor
      sFB_Displacement371 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 371 conveyor
      sFB_Displacement380 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 380 conveyor
      sFB_Displacement390 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 390 conveyor
      sFB_Displacement530 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 530 conveyor
      sFB_Displacement540 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 540 conveyor
      sFB_Displacement541 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 541 conveyor
      sFB_Displacement550 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 550 conveyor
      sFB_Displacement560 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 560 conveyor
      sFB_Displacement570 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 570 conveyor
      sFB_Displacement580 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 580 conveyor
      sFB_Displacement610 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 610 conveyor
      sFB_Displacement620 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 620 conveyor
      sFB_Displacement630 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 630 conveyor
      sFB_Displacement640 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 640 conveyor
      sFB_Displacement641 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 641 conveyor
      sFB_Displacement650 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 650 conveyor
      sFB_Displacement651 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 651 conveyor
      sFB_Displacement660 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 660 conveyor
      sFB_Displacement661 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 661 conveyor
      sFB_Displacement670 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 670 conveyor
      sFB_Displacement671 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 671 conveyor
      sFB_Displacement680 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 680 conveyor
      sFB_Displacement690 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 690 conveyor
      sUDT_Interface_010 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 010 conveyor
      sUDT_Interface_020 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 020 conveyor
      sUDT_Interface_050 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 030 conveyor
      sUDT_Interface_030 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 040 conveyor
      sUDT_Interface_040 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 050 conveyor
      sUDT_Interface_060 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 060 conveyor
      sUDT_Interface_070 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 070 conveyor
      sUDT_Interface_080 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 080 conveyor
      sUDT_Interface_090 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 090 conveyor
      sUDT_Interface_100 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 100 conveyor
      sUDT_Interface_110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 110 conveyor
      sUDT_Interface_120 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 120 conveyor
      sUDT_Interface_121 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 121 conveyor
      sUDT_Interface_230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 230 conveyor
      sUDT_Interface_240 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 240 conveyor
      sUDT_Interface_241 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 241 conveyor
      sUDT_Interface_250 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 250 conveyor
      sUDT_Interface_260 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 260 conveyor
      sUDT_Interface_270 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 270 conveyor
      sUDT_Interface_280 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 280 conveyor
      sUDT_Interface_310 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 310 conveyor
      sUDT_Interface_320 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 320 conveyor
      sUDT_Interface_330 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 330 conveyor
      sUDT_Interface_340 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 340 conveyor
      sUDT_Interface_341 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 341 conveyor
      sUDT_Interface_350 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 350 conveyor
      sUDT_Interface_351 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 351 conveyor
      sUDT_Interface_360 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 360 conveyor
      sUDT_Interface_361 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 361 conveyor
      sUDT_Interface_370 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 370 conveyor
      sUDT_Interface_371 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 371 conveyor
      sUDT_Interface_380 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 380 conveyor
      sUDT_Interface_390 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 390 conveyor
      sUDT_Interface_530 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 530 conveyor
      sUDT_Interface_540 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 540 conveyor
      sUDT_Interface_541 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 541 conveyor
      sUDT_Interface_550 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 550 conveyor
      sUDT_Interface_560 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 560 conveyor
      sUDT_Interface_570 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 570 conveyor
      sUDT_Interface_580 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 580 conveyor
      sUDT_Interface_610 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 610 conveyor
      sUDT_Interface_620 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 620 conveyor
      sUDT_Interface_630 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 630 conveyor
      sUDT_Interface_640 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 640 conveyor
      sUDT_Interface_641 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 641 conveyor
      sUDT_Interface_650 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 650 conveyor
      sUDT_Interface_651 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 651 conveyor
      sUDT_Interface_660 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 660 conveyor
      sUDT_Interface_661 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 661 conveyor
      sUDT_Interface_670 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 670 conveyor
      sUDT_Interface_671 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 671 conveyor
      sUDT_Interface_680 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 680 conveyor
      sUDT_Interface_690 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 690 conveyor
      sFB_Tracking_230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 230 conveyor
      sFB_Tracking_320 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 320 conveyor
      sFB_Tracking_330 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 330 conveyor
      sFB_Tracking_380 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 380 conveyor
      sFB_Tracking_390 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 390 conveyor
      sFB_Tracking_530 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 530 conveyor
      sFB_Tracking_550 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 550 conveyor
      sFB_Tracking_620 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 620 conveyor
      sFB_Tracking_630 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 630 conveyor
      sFB_Tracking_640 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 640 conveyor
      sFB_Tracking_680 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 680 conveyor
      sFB_Tracking_690 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 690 conveyor
      sa_TrackingArray_230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..2501] of Int;   // Tracking array for 230 conveyor
      sa_TrackingArray_250 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..2501] of Int;   // Tracking array for 250 conveyor
      sa_TrackingArray_320 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..2501] of Int;   // Tracking array for 320 conveyor
      sa_TrackingArray_330 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..2501] of Int;   // Tracking array for 330 conveyor
      sa_TrackingArray_380 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..2501] of Int;   // Tracking array for 380 conveyor
      sa_TrackingArray_390 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..2501] of Int;   // Tracking array for 390 conveyor
      sa_TrackingArray_530 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..2501] of Int;   // Tracking array for 530 conveyor
      sa_TrackingArray_550 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..2501] of Int;   // Tracking array for 550 conveyor
      sa_TrackingArray_620 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..2501] of Int;   // Tracking array for 620 conveyor
      sa_TrackingArray_630 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..2501] of Int;   // Tracking array for 630 conveyor
      sa_TrackingArray_680 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..2501] of Int;   // Tracking array for 680 conveyor
      sa_TrackingArray_690 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..2501] of Int;   // Tracking array for 690 conveyor
      sUDT_Handshake_010 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 010 conveyor
      sUDT_Handshake_020 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 020 conveyor
      sUDT_Handshake_030 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 030 conveyor
      sUDT_Handshake_040 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 040 conveyor
      sUDT_Handshake_050 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 050 conveyor
      sUDT_Handshake_060 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 060 conveyor
      sUDT_Handshake_070 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 070 conveyor
      sUDT_Handshake_080 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 080 conveyor
      sUDT_Handshake_090 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 090 conveyor
      sUDT_Handshake_100 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 100 conveyor
      sUDT_Handshake_110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 110 conveyor
      sUDT_Handshake_120 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 120 conveyor
      sUDT_Handshake_121 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 121 conveyor
      sUDT_HandshakeUp_121 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake" := ((), (), (), (), TRUE, (), (), (), ());   // HandshakeUp structure for 121 conveyor
      sUDT_Handshake_230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 230 conveyor
      sUDT_Handshake_240 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 240 conveyor
      sUDT_Handshake_241 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 241 conveyor
      sUDT_Handshake_250 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 250 conveyor
      sUDT_Handshake_260 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 260 conveyor
      sUDT_Handshake_270 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 270 conveyor
      sUDT_Handshake_310 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 310 conveyor
      sUDT_Handshake_320 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 320 conveyor
      sUDT_Handshake_330 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 330 conveyor
      sUDT_Handshake_340 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 340 conveyor
      sUDT_Handshake_341 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 341 conveyor
      sUDT_HandshakeUp_341 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake" := ((), (), (), (), TRUE, (), (), (), ());   // HandshakeUp structure for 341 conveyor
      sUDT_Handshake_350 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 350 conveyor
      sUDT_Handshake_351 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 351 conveyor
      sUDT_Handshake_360 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 360 conveyor
      sUDT_HandshakeUp_361 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // HandshakeUp structure for 361 conveyor
      sUDT_Handshake_361 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 361 conveyor
      sUDT_Handshake_370 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 370 conveyor
      sUDT_Handshake_371 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 371 conveyor
      sUDT_Handshake_380 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 380 conveyor
      sUDT_Handshake_390 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 390 conveyor
      sUDT_Handshake_530 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 530 conveyor
      sUDT_Handshake_540 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 540 conveyor
      sUDT_Handshake_550 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 541 conveyor
      sUDT_Handshake_541 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 550 conveyor
      sUDT_Handshake_560 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 560 conveyor
      sUDT_Handshake_570 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 570 conveyor
      sUDT_Handshake_610 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 610 conveyor
      sUDT_Handshake_620 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 620 conveyor
      sUDT_Handshake_630 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 630 conveyor
      sUDT_Handshake_640 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 640 conveyor
      sUDT_Handshake_641 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 641 conveyor
      sUDT_HandshakeUp_641 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake" := ((), (), (), (), TRUE, (), (), (), ());   // HandshakeUp structure for 641 conveyor
      sUDT_Handshake_650 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 650 conveyor
      sUDT_Handshake_651 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 651 conveyor
      sUDT_Handshake_660 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 660 conveyor
      sUDT_HandshakeUp_661 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 661 conveyor
      sUDT_Handshake_670 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 670 conveyor
      sUDT_Handshake_671 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 671 conveyor
      sUDT_HandshakeUp_671 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // HandshakeUp structure for 671 conveyor
      sUDT_Handshake_680 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 680 conveyor
      sUDT_Handshake_690 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 690 conveyor
      sFB_PECUpdate_230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 230 conveyor
      sFB_PECUpdate_250 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 250 conveyor
      sFB_PECUpdate_320 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 320 conveyor
      sFB_PECUpdate_330 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 330 conveyor
      sFB_PECUpdate_380 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 380 conveyor
      sFB_PECUpdate_390 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 390 conveyor
      sFB_PECUpdate_530 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 530 conveyor
      sFB_PECUpdate_550 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 550 conveyor
      sFB_PECUpdate_620 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 620 conveyor
      sFB_PECUpdate_630 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 630 conveyor
      sFB_PECUpdate_680 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 680 conveyor
      sFB_PECUpdate_690 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 690 conveyor
      sFB_PEC_020 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 020 conveyor
      sFB_PEC_030 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 030 conveyor
      sFB_PEC_040 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 040 conveyor
      sFB_PEC_050 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 050 conveyor
      sFB_PEC_060 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 060 conveyor
      sFB_PEC_070 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 070 conveyor
      sFB_PEC_080 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 080 conveyor
      sFB_PEC_100 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 100 conveyor
      sFB_PEC_110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 110 conveyor
      sFB_PEC_270 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 270 conveyor
      sFB_PEC_280 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 280 conveyor
      sFB_PEC_570 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 570 conveyor
      sFB_PEC_580 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 580 conveyor
      sFB_Conveyor_010 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 010 conveyor
      sFB_Conveyor_020 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 020 conveyor
      sFB_Conveyor_030 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 030 conveyor
      sFB_Conveyor_040 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 040 conveyor
      sFB_Conveyor_050 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 050 conveyor
      sFB_Conveyor_060 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 060 conveyor
      sFB_Conveyor_070 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 070 conveyor
      sFB_Conveyor_080 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 080 conveyor
      sFB_Conveyor_090 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 090 conveyor
      sFB_Conveyor_100 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 100 conveyor
      sFB_Conveyor_110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 110 conveyor
      sFB_Conveyor_230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 230 conveyor
      sFB_Conveyor_250 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 250 conveyor
      sFB_Conveyor_260 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 260 conveyor
      sFB_Conveyor_270 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 270 conveyor
      sFB_Conveyor_280 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 280 conveyor
      sFB_Conveyor_310 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 310 conveyor
      sFB_Conveyor_320 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 320 conveyor
      sFB_Conveyor_330 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 330 conveyor
      sFB_Conveyor_380 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 380 conveyor
      sFB_Conveyor_390 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 390 conveyor
      sFB_Conveyor_530 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 530 conveyor
      sFB_Conveyor_550 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 550 conveyor
      sFB_Conveyor_560 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 560 conveyor
      sFB_Conveyor_570 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 570 conveyor
      sFB_Conveyor_580 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 580 conveyor
      sFB_Conveyor_610 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 610 conveyor
      sFB_Conveyor_620 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 620 conveyor
      sFB_Conveyor_630 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 630 conveyor
      sFB_Conveyor_680 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 680 conveyor
      sFB_Conveyor_690 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 690 conveyor
      sFB_MCOConveyLinxAixController_010 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 010
      sFB_MCOConveyLinxAixController_020 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 020
      sFB_MCOConveyLinxAixController_030 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 030
      sFB_MCOConveyLinxAixController_040 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 040
      sFB_MCOConveyLinxAixController_050 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 050
      sFB_MCOConveyLinxAixController_060 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 060
      sFB_MCOConveyLinxAixController_070 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 070
      sFB_MCOConveyLinxAixController_080 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 080
      sFB_MCOConveyLinxAixController_090 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 090
      sFB_MCOConveyLinxAixController_100 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 100
      sFB_MCOConveyLinxAixController_110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 110
      sFB_MCOConveyLinxAixController_120 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 120
      sFB_MCOConveyLinxAixController_121 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 121
      sFB_MCOConveyLinxAixController_230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 230
      sFB_MCOConveyLinxAixController_240 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 240
      sFB_MCOConveyLinxAixController_241 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 241
      sFB_MCOConveyLinxAixController_250 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 250
      sFB_MCOConveyLinxAixController_270 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 270
      sFB_MCOConveyLinxAixController_280 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 280
      sFB_MCOConveyLinxAixController_320 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 320
      sFB_MCOConveyLinxAixController_330 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 330
      sFB_MCOConveyLinxAixController_340 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 340
      sFB_MCOConveyLinxAixController_341 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 341
      sFB_MCOConveyLinxAixController_350 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 350
      sFB_MCOConveyLinxAixController_351 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 351
      sFB_MCOConveyLinxAixController_360 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 360
      sFB_MCOConveyLinxAixController_361 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 361
      sFB_MCOConveyLinxAixController_370 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 370
      sFB_MCOConveyLinxAixController_371 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 371
      sFB_MCOConveyLinxAixController_380 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 380
      sFB_MCOConveyLinxAixController_390 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 390
      sFB_MCOConveyLinxAixController_530 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 530
      sFB_MCOConveyLinxAixController_540 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 540
      sFB_MCOConveyLinxAixController_541 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 541
      sFB_MCOConveyLinxAixController_550 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 550
      sFB_MCOConveyLinxAixController_570 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 570
      sFB_MCOConveyLinxAixController_580 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 580
      sFB_MCOConveyLinxAixController_620 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 620
      sFB_MCOConveyLinxAixController_630 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 630
      sFB_MCOConveyLinxAixController_640 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 640
      sFB_MCOConveyLinxAixController_641 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 641
      sFB_MCOConveyLinxAixController_650 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 650
      sFB_MCOConveyLinxAixController_651 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 651
      sFB_MCOConveyLinxAixController_660 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 660
      sFB_MCOConveyLinxAixController_661 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 661
      sFB_MCOConveyLinxAixController_670 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 670
      sFB_MCOConveyLinxAixController_671 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 671
      sFB_MCOConveyLinxAixController_680 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 680
      sFB_MCOConveyLinxAixController_690 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 690
      sFB_VfdNORDPPO4_260 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_VfdNORDPPO4";   // Function to interface with Nord VFD for 260
      sFB_VfdNORDPPO4_310 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_VfdNORDPPO4";   // Function to interface with Nord VFD for 310
      sFB_VfdNORDPPO4_560 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_VfdNORDPPO4";   // Function to interface with Nord VFD for 560
      sFB_VfdNORDPPO4_610 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_VfdNORDPPO4";   // Function to interface with Nord VFD for 610
      sFB_RightAngledTransfer_121 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_RightAngledTransfer";   // Funtion to control 121 RAT
      sFB_RightAngledTransfer_241 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_RightAngledTransfer";   // Funtion to control 241 RAT
      sFB_RightAngledTransfer_341 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_RightAngledTransfer";   // Funtion to control 341 RAT
      sFB_RightAngledTransfer_351 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_RightAngledTransfer";   // Funtion to control 351 RAT
      sFB_RightAngledTransfer_361 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_RightAngledTransfer";   // Funtion to control 361 RAT
      sFB_RightAngledTransfer_371 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_RightAngledTransfer";   // Funtion to control 371 RAT
      sFB_RightAngledTransfer_541 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_RightAngledTransfer";   // Funtion to control 541 RAT
      sFB_RightAngledTransfer_641 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_RightAngledTransfer";   // Funtion to control 641 RAT
      sFB_RightAngledTransfer_651 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_RightAngledTransfer";   // Funtion to control 651 RAT
      sFB_RightAngledTransfer_661 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_RightAngledTransfer";   // Funtion to control 661 RAT
      sFB_RightAngledTransfer_671 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_RightAngledTransfer";   // Funtion to control 671 RAT
      sFB_CognexDM260_110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_CognexDM260";   // Cognex output structure
      sFB_CognexDM260_330 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_CognexDM260";
      sFB_CognexDM260_630 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_CognexDM260";
      sFB_Blade { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_DataLogicBladeSN";
      sFB_SickDemoo { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_SickDemoo";
      s_F_Trig_240 {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Negative slope trigger for sensor 240
      s_F_Trig_540 {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Negative slope trigger for sensor 540
      s_F_Trig_ClearRight {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Negative slope trigger for ClearRight command
      s_F_Trig_ClearLeft {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Negative slope trigger for ClearLeft command
      si_120DestinationA { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 120 RAT A destination value
      si_120DestinationB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 120 RAT B destination value
      si_120DestinationC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 120 RAT C destination value
      si_120DestinationD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 120 RAT D destination value
      si_240DestinationA { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 240 RAT A destination value
      si_240DestinationB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 240 RAT B destination value
      si_240DestinationC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 240 RAT C destination value
      si_240DestinationD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 240 RAT D destination value
      si_340DestinationA { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 340 RAT A destination value
      si_340DestinationB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 340 RAT B destination value
      si_340DestinationC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 340 RAT C destination value
      si_340DestinationD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 340 RAT D destination value
      si_350DestinationA { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 350 RAT A destination value
      si_350DestinationB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 350 RAT B destination value
      si_350DestinationC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 350 RAT C destination value
      si_350DestinationD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 350 RAT D destination value
      si_360DestinationA { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 360 RAT A destination value
      si_360DestinationB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 360 RAT B destination value
      si_360DestinationC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 360 RAT C destination value
      si_360DestinationD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 360 RAT D destination value
      si_370DestinationA { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 370 RAT A destination value
      si_370DestinationB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 370 RAT B destination value
      si_370DestinationC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 370 RAT C destination value
      si_370DestinationD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 370 RAT D destination value
      si_540DestinationA { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 540 RAT A destination value
      si_540DestinationB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 540 RAT B destination value
      si_540DestinationC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 540 RAT C destination value
      si_540DestinationD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 540 RAT D destination value
      si_640DestinationA { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 640 RAT A destination value
      si_640DestinationB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 640 RAT B destination value
      si_640DestinationC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 640 RAT C destination value
      si_640DestinationD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 640 RAT D destination value
      si_650DestinationA { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 650 RAT A destination value
      si_650DestinationB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 650 RAT B destination value
      si_650DestinationC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 650 RAT C destination value
      si_650DestinationD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 650 RAT D destination value
      si_660DestinationA { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 660 RAT A destination value
      si_660DestinationB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 660 RAT B destination value
      si_660DestinationC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 660 RAT C destination value
      si_660DestinationD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 660 RAT D destination value
      si_670DestinationA { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 670 RAT A destination value
      si_670DestinationB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 670 RAT B destination value
      si_670DestinationC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 670 RAT C destination value
      si_670DestinationD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 670 RAT D destination value
      sx_ActiveRequest380 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request for 380 is active
      sx_ActiveRequest390 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request for 390 is active
      sx_ReqInProgress380 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request for 380 is in progress
      sx_ReqInProgress390 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request for 390 is in progress
      sx_ActiveRequest680 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request for 680 is active
      sx_ActiveRequest690 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request for 690 is active
      sx_ReqInProgress680 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request for 680 is in progress
      sx_ReqInProgress690 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request for 690 is in progress
      sx_TransferOut380 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Transfer out from 380 is active
      sx_TransferOut390 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Transfer out from 390 is active
      sx_TransferOut680 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Transfer out from 680 is active
      sx_TransferOut690 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Transfer out from 690 is active
      sx_DirectionChange380 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Direction of conveyor 380
      sx_DirectionChange390 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Direction of conveyor 390
      sx_DirectionChange680 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Direction of conveyor 680
      sx_DirectionChange690 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Direction of conveyor 690
      sx_Hold230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_Hold530 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_ClearRightStation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command to clear right station
      sx_ClearLeftStation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command to clear left station
   END_VAR

   VAR_TEMP 
      tUDT_dummyHandshake : "UDT_ConveyorHandshake";   // Dummy handshake structure
      tUDT_DummyBladeStop : "UDT_ValveInterface";
      ts_Barcode110 : String;
      ts_Barcode330 : String;
      ts_Barcode630 : String;
      tw_dummy : Word;
      ti_dummy : Int;   // Dummy int
      tx_dummy : Bool;   // Dummy bool
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	23/02/2024  | 0.1       | R. Pieczonka  | Initial version
	26/02/2024  | 0.2       | S. Nieswiec   | Updated to new library blocks, added HardwareOk input
	27/02/2024  | 0.3       | S. Nieswiec   | Mapped  safetyOk, 24vOk, 400vOk from inputs to function blocks, added VFDs in place of conveylinx at conveyors 260,310,560,610
	18/03/2024  | 0.4       | S. Nieswiec   | Adjusted comments and variable names
	15/04/2024  | 0.5       | S. Nieswiec   | Added ConveyLinx Controllers
	10/05/2024  | 0.6       | R. Pieczonka  | Added new MCO and clearing sequence. Changes in station operation sequence.
	04/06/2024  | 0.7       | S. Nieswiec   | Partially added scanners
	11/06/2024  | 0.8       | S. Nieswiec   | New RAT, MCO and Displacement FB + added datalogic scanner
	14/06/2024  | 0.9       | S. Nieswiec   | New RAT, MCO and Displacement FB + added datalogic scanner
	*)
	(*
	----------------------------------------------------------------------------------------
	
	Notes:
	Date        | Version   | Author        | Notes
	----------------------------------------------------------------------------------------
	25/06/2024  | 0.9       | I.Bou Ajram   | Barcode scanners and the use of external DBs directly needs tidying up. request update
	
	
	*)
	
	REGION Middle line - Infeed
	    (*
	    REGION 010      
	        
	        REGION Displacement
	            
	            #sFB_Displacement010(#sUDT_Interface_010);
	            
	        END_REGION
	        
	        REGION Conveyor
	            #sFB_Conveyor_010(iUDT_ConveyorConfiguration := #iUDT_Configuration."010".Conveyor,
	                              idi_PECEoSDistance         := 0,
	                              idi_PECBoSDistance         := 0,
	                              ii_ExternalSpeed           := 0,
	                              ix_SafetyOk                := #ix_SafetyOk,
	                              ix_24vOk                   := #ix_24vOk,
	                              ix_400vOk                  := #ix_400vOk,
	                              ix_HardwareOk              := #ix_HardwareOk,
	                              ix_PECEoS                  := TRUE,
	                              ix_PECBoS                  := TRUE,
	                              ix_ExternalRequestHold     := false,
	                              qUDT_HMIStatus             => #iqUDT_WorkstationStatus."010".Conveyor,
	                              qUDT_Status                => #iqUDT_WorkstationCommonStatus."010",
	                              iqUDT_EquipmentControl     := #iqUDT_EquipmentControl,
	                              iqUDT_ConveyorCommand      := #iqUDT_WorkstationCommands."010",
	                              iqUDT_ConveyorInterface    := #sUDT_Interface_010,
	                              iqUDT_HandShakeUp          := #iqUDT_HandshakeUpstream010,
	                              iqUDT_HandShake            := #sUDT_Handshake_010,
	                              iqUDT_Statistics           := #iqUDT_WorkstationStatistics."010".Conveyor);
	        END_REGION
	        
	        REGION MCO
	            #sFB_MCOConveyLinxAixController_010(iUDT_AixConfig          := #iUDT_Configuration."010".MCO,
	                                                iUDT_AixInputsModule    := #iUDT_MotorInput010,
	                                                ix_24vOk                := #ix_24vOk,
	                                                ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                ii_MotorPositionId      := 1,
	                                                qUDT_HMIStatus          => #iqUDT_WorkstationStatus."010".MCO,
	                                                iqUDT_AixOutputsModule  := #qUDT_MotorOutput010,
	                                                iqUDT_ConveyorInterface := #sUDT_Interface_010,
	                                                iqUDT_MCOStatistics     := #iqUDT_WorkstationStatistics."010".MCO);
	        END_REGION
	    END_REGION
	    
	    
	    REGION 020
	        
	        REGION Displacement
	            
	            #sFB_Displacement020(#sUDT_Interface_020);
	            
	        END_REGION
	        
	        REGION EoS               
	            
	            #sFB_PEC_020(ix_PEC                   := #iUDT_MotorInput020.AllSensorPortInputs.LeftSensor,
	                         iUDT_PECConfiguration   := #iUDT_Configuration."020".PEC_Eos,
	                         qUDT_HMIStatus          => #iqUDT_WorkstationStatus."020".PEC_Eos,
	                         iqUDT_ConveyorInterface := #sUDT_Interface_020,
	                         iqUDT_PECStatistics     := #iqUDT_WorkstationStatistics."020".PEC_Eos);
	            
	        END_REGION
	        
	        REGION Conveyor
	            #sFB_Conveyor_020(iUDT_ConveyorConfiguration := #iUDT_Configuration."020".Conveyor,
	                              idi_PECEoSDistance         := #iUDT_Configuration."020".PEC_Eos.Distance,
	                              idi_PECBoSDistance         := 0,
	                              ii_ExternalSpeed           := 0,
	                              ix_SafetyOk                := #ix_SafetyOk,
	                              ix_24vOk                   := #ix_24vOk,
	                              ix_400vOk                  := #ix_400vOk,
	                              ix_HardwareOk              := #ix_HardwareOk,
	                              ix_PECEoS                  := #iqUDT_WorkstationStatus."020".PEC_Eos.PEC,
	                              ix_PECBoS                  := TRUE,
	                              ix_ExternalRequestHold     := false,
	                              qUDT_HMIStatus             => #iqUDT_WorkstationStatus."020".Conveyor,
	                              qUDT_Status                => #iqUDT_WorkstationCommonStatus."020",
	                              iqUDT_EquipmentControl     := #iqUDT_EquipmentControl,
	                              iqUDT_ConveyorCommand      := #iqUDT_WorkstationCommands."020",
	                              iqUDT_ConveyorInterface    := #sUDT_Interface_020,
	                              iqUDT_HandShakeUp          := #sUDT_Handshake_010,
	                              iqUDT_HandShake            := #sUDT_Handshake_020,
	                              iqUDT_Statistics           := #iqUDT_WorkstationStatistics."020".Conveyor);
	        END_REGION
	        
	        REGION MCO
	            #sFB_MCOConveyLinxAixController_020(iUDT_AixConfig          := #iUDT_Configuration."020".MCO,
	                                                iUDT_AixInputsModule    := #iUDT_MotorInput020,
	                                                ix_24vOk                := #ix_24vOk,
	                                                ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                ii_MotorPositionId      := 1,
	                                                qUDT_HMIStatus          => #iqUDT_WorkstationStatus."020".MCO,
	                                                iqUDT_AixOutputsModule  := #qUDT_MotorOutput020,
	                                                iqUDT_ConveyorInterface := #sUDT_Interface_020,
	                                                iqUDT_MCOStatistics     := #iqUDT_WorkstationStatistics."020".MCO);
	        END_REGION
	        
	        
	    END_REGION
	    
	    REGION 030
	        
	        REGION Displacement
	            
	            #sFB_Displacement030(#sUDT_Interface_030);
	            
	        END_REGION
	        
	        REGION EoS               
	            
	            #sFB_PEC_030(ix_PEC                   := #iUDT_MotorInput030.AllSensorPortInputs.LeftSensor,
	                         iUDT_PECConfiguration   := #iUDT_Configuration."030".PEC_Eos,
	                         qUDT_HMIStatus          => #iqUDT_WorkstationStatus."030".PEC_Eos,
	                         iqUDT_ConveyorInterface := #sUDT_Interface_030,
	                         iqUDT_PECStatistics     := #iqUDT_WorkstationStatistics."030".PEC_Eos);
	            
	        END_REGION
	        
	        REGION Conveyor
	            #sFB_Conveyor_030(iUDT_ConveyorConfiguration := #iUDT_Configuration."030".Conveyor,
	                              idi_PECEoSDistance         := #iUDT_Configuration."030".PEC_Eos.Distance,
	                              idi_PECBoSDistance         := 0,
	                              ii_ExternalSpeed           := 0,
	                              ix_SafetyOk                := #ix_SafetyOk,
	                              ix_24vOk                   := #ix_24vOk,
	                              ix_400vOk                  := #ix_400vOk,
	                              ix_HardwareOk              := #ix_HardwareOk,
	                              ix_PECEoS                  := #iqUDT_WorkstationStatus."030".PEC_Eos.PEC,
	                              ix_PECBoS                  := TRUE,
	                              ix_ExternalRequestHold     := false,
	                              qUDT_HMIStatus             => #iqUDT_WorkstationStatus."030".Conveyor,
	                              qUDT_Status                => #iqUDT_WorkstationCommonStatus."030",
	                              iqUDT_EquipmentControl     := #iqUDT_EquipmentControl,
	                              iqUDT_ConveyorCommand      := #iqUDT_WorkstationCommands."030",
	                              iqUDT_ConveyorInterface    := #sUDT_Interface_030,
	                              iqUDT_HandShakeUp          := #sUDT_Handshake_020,
	                              iqUDT_HandShake            := #sUDT_Handshake_030,
	                              iqUDT_Statistics           := #iqUDT_WorkstationStatistics."030".Conveyor);
	        END_REGION
	        
	        REGION MCO
	            #sFB_MCOConveyLinxAixController_030(iUDT_AixConfig          := #iUDT_Configuration."030".MCO,
	                                                iUDT_AixInputsModule    := #iUDT_MotorInput030,
	                                                ix_24vOk                := #ix_24vOk,
	                                                ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                ii_MotorPositionId      := 1,
	                                                qUDT_HMIStatus          => #iqUDT_WorkstationStatus."030".MCO,
	                                                iqUDT_AixOutputsModule  := #qUDT_MotorOutput030,
	                                                iqUDT_ConveyorInterface := #sUDT_Interface_030,
	                                                iqUDT_MCOStatistics     := #iqUDT_WorkstationStatistics."030".MCO);
	        END_REGION
	    END_REGION
	    
	    REGION 040
	        
	        REGION Displacement
	            
	            #sFB_Displacement040(#sUDT_Interface_040);
	            
	        END_REGION
	        
	        REGION EoS               
	            
	            #sFB_PEC_040(ix_PEC                   := #iUDT_MotorInput040.AllSensorPortInputs.LeftSensor,
	                         iUDT_PECConfiguration   := #iUDT_Configuration."040".PEC_Eos,
	                         qUDT_HMIStatus          => #iqUDT_WorkstationStatus."040".PEC_Eos,
	                         iqUDT_ConveyorInterface := #sUDT_Interface_040,
	                         iqUDT_PECStatistics     := #iqUDT_WorkstationStatistics."040".PEC_Eos);
	            
	        END_REGION
	        
	        REGION Conveyor
	            #sFB_Conveyor_040(iUDT_ConveyorConfiguration := #iUDT_Configuration."040".Conveyor,
	                              idi_PECEoSDistance         := #iUDT_Configuration."040".PEC_Eos.Distance,
	                              idi_PECBoSDistance         := 0,
	                              ii_ExternalSpeed           := 0,
	                              ix_SafetyOk                := #ix_SafetyOk,
	                              ix_24vOk                   := #ix_24vOk,
	                              ix_400vOk                  := #ix_400vOk,
	                              ix_HardwareOk              := #ix_HardwareOk,
	                              ix_PECEoS                  := #iqUDT_WorkstationStatus."040".PEC_Eos.PEC,
	                              ix_PECBoS                  := TRUE,
	                              ix_ExternalRequestHold     := false,
	                              qUDT_HMIStatus             => #iqUDT_WorkstationStatus."040".Conveyor,
	                              qUDT_Status                => #iqUDT_WorkstationCommonStatus."040",
	                              iqUDT_EquipmentControl     := #iqUDT_EquipmentControl,
	                              iqUDT_ConveyorCommand      := #iqUDT_WorkstationCommands."040",
	                              iqUDT_ConveyorInterface    := #sUDT_Interface_040,
	                              iqUDT_HandShakeUp          := #sUDT_Handshake_030,
	                              iqUDT_HandShake            := #sUDT_Handshake_040,
	                              iqUDT_Statistics           := #iqUDT_WorkstationStatistics."040".Conveyor);
	        END_REGION
	        
	        REGION MCO
	            #sFB_MCOConveyLinxAixController_040(iUDT_AixConfig          := #iUDT_Configuration."040".MCO,
	                                                iUDT_AixInputsModule    := #iUDT_MotorInput040,
	                                                ix_24vOk                := #ix_24vOk,
	                                                ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                ii_MotorPositionId      := 1,
	                                                qUDT_HMIStatus          => #iqUDT_WorkstationStatus."040".MCO,
	                                                iqUDT_AixOutputsModule  := #qUDT_MotorOutput040,
	                                                iqUDT_ConveyorInterface := #sUDT_Interface_040,
	                                                iqUDT_MCOStatistics     := #iqUDT_WorkstationStatistics."040".MCO);
	        END_REGION
	        
	    END_REGION
	    
	    REGION 050
	        
	        REGION Displacement
	            
	            #sFB_Displacement050(#sUDT_Interface_050);
	            
	        END_REGION
	        
	        REGION EoS               
	            
	            #sFB_PEC_050(ix_PEC                   := #iUDT_MotorInput050.AllSensorPortInputs.LeftSensor,
	                         iUDT_PECConfiguration   := #iUDT_Configuration."050".PEC_Eos,
	                         qUDT_HMIStatus          => #iqUDT_WorkstationStatus."050".PEC_Eos,
	                         iqUDT_ConveyorInterface := #sUDT_Interface_050,
	                         iqUDT_PECStatistics     := #iqUDT_WorkstationStatistics."050".PEC_Eos);
	            
	        END_REGION
	        
	        REGION Conveyor
	            #sFB_Conveyor_050(iUDT_ConveyorConfiguration := #iUDT_Configuration."050".Conveyor,
	                              idi_PECEoSDistance         := #iUDT_Configuration."050".PEC_Eos.Distance,
	                              idi_PECBoSDistance         := 0,
	                              ii_ExternalSpeed           := 0,
	                              ix_SafetyOk                := #ix_SafetyOk,
	                              ix_24vOk                   := #ix_24vOk,
	                              ix_400vOk                  := #ix_400vOk,
	                              ix_HardwareOk              := #ix_HardwareOk,
	                              ix_PECEoS                  := #iqUDT_WorkstationStatus."050".PEC_Eos.PEC,
	                              ix_PECBoS                  := TRUE,
	                              ix_ExternalRequestHold     := false,
	                              qUDT_HMIStatus             => #iqUDT_WorkstationStatus."050".Conveyor,
	                              qUDT_Status                => #iqUDT_WorkstationCommonStatus."050",
	                              iqUDT_EquipmentControl     := #iqUDT_EquipmentControl,
	                              iqUDT_ConveyorCommand      := #iqUDT_WorkstationCommands."050",
	                              iqUDT_ConveyorInterface    := #sUDT_Interface_050,
	                              iqUDT_HandShakeUp          := #sUDT_Handshake_040,
	                              iqUDT_HandShake            := #sUDT_Handshake_050,
	                              iqUDT_Statistics           := #iqUDT_WorkstationStatistics."050".Conveyor);
	        END_REGION
	        
	        REGION MCO
	            #sFB_MCOConveyLinxAixController_050(iUDT_AixConfig          := #iUDT_Configuration."050".MCO,
	                                                iUDT_AixInputsModule    := #iUDT_MotorInput050,
	                                                ix_24vOk                := #ix_24vOk,
	                                                ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                ii_MotorPositionId      := 1,
	                                                qUDT_HMIStatus          => #iqUDT_WorkstationStatus."050".MCO,
	                                                iqUDT_AixOutputsModule  := #qUDT_MotorOutput050,
	                                                iqUDT_ConveyorInterface := #sUDT_Interface_050,
	                                                iqUDT_MCOStatistics     := #iqUDT_WorkstationStatistics."050".MCO);
	        END_REGION
	    END_REGION
	    
	    REGION 060
	        
	        REGION Displacement
	            
	            #sFB_Displacement060(#sUDT_Interface_060);
	            
	        END_REGION
	        
	        REGION EoS               
	            
	            #sFB_PEC_060(ix_PEC                   := #iUDT_MotorInput060.AllSensorPortInputs.LeftSensor,
	                         iUDT_PECConfiguration   := #iUDT_Configuration."060".PEC_Eos,
	                         qUDT_HMIStatus          => #iqUDT_WorkstationStatus."060".PEC_Eos,
	                         iqUDT_ConveyorInterface := #sUDT_Interface_060,
	                         iqUDT_PECStatistics     := #iqUDT_WorkstationStatistics."060".PEC_Eos);
	            
	        END_REGION
	        
	        REGION Conveyor
	            #sFB_Conveyor_060(iUDT_ConveyorConfiguration := #iUDT_Configuration."060".Conveyor,
	                              idi_PECEoSDistance         := #iUDT_Configuration."060".PEC_Eos.Distance,
	                              idi_PECBoSDistance         := 0,
	                              ii_ExternalSpeed           := 0,
	                              ix_SafetyOk                := #ix_SafetyOk,
	                              ix_24vOk                   := #ix_24vOk,
	                              ix_400vOk                  := #ix_400vOk,
	                              ix_HardwareOk              := #ix_HardwareOk,
	                              ix_PECEoS                  := #iqUDT_WorkstationStatus."060".PEC_Eos.PEC,
	                              ix_PECBoS                  := TRUE,
	                              ix_ExternalRequestHold     := false,
	                              qUDT_HMIStatus             => #iqUDT_WorkstationStatus."060".Conveyor,
	                              qUDT_Status                => #iqUDT_WorkstationCommonStatus."060",
	                              iqUDT_EquipmentControl     := #iqUDT_EquipmentControl,
	                              iqUDT_ConveyorCommand      := #iqUDT_WorkstationCommands."060",
	                              iqUDT_ConveyorInterface    := #sUDT_Interface_060,
	                              iqUDT_HandShakeUp          := #sUDT_Handshake_050,
	                              iqUDT_HandShake            := #sUDT_Handshake_060,
	                              iqUDT_Statistics           := #iqUDT_WorkstationStatistics."060".Conveyor);
	        END_REGION
	        
	        REGION MCO
	            #sFB_MCOConveyLinxAixController_060(iUDT_AixConfig          := #iUDT_Configuration."060".MCO,
	                                                iUDT_AixInputsModule    := #iUDT_MotorInput060,
	                                                ix_24vOk                := #ix_24vOk,
	                                                ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                ii_MotorPositionId      := 1,
	                                                qUDT_HMIStatus          => #iqUDT_WorkstationStatus."060".MCO,
	                                                iqUDT_AixOutputsModule  := #qUDT_MotorOutput060,
	                                                iqUDT_ConveyorInterface := #sUDT_Interface_060,
	                                                iqUDT_MCOStatistics     := #iqUDT_WorkstationStatistics."060".MCO);
	        END_REGION
	        
	    END_REGION
	    
	    REGION 070
	        
	        REGION Displacement
	            
	            #sFB_Displacement070(#sUDT_Interface_070);
	            
	        END_REGION
	        
	        REGION EoS               
	            
	            #sFB_PEC_070(ix_PEC                   := #iUDT_MotorInput070.AllSensorPortInputs.LeftSensor,
	                         iUDT_PECConfiguration   := #iUDT_Configuration."070".PEC_Eos,
	                         qUDT_HMIStatus          => #iqUDT_WorkstationStatus."070".PEC_Eos,
	                         iqUDT_ConveyorInterface := #sUDT_Interface_070,
	                         iqUDT_PECStatistics     := #iqUDT_WorkstationStatistics."070".PEC_Eos);
	            
	        END_REGION
	        
	        REGION Conveyor
	            #sFB_Conveyor_070(iUDT_ConveyorConfiguration := #iUDT_Configuration."070".Conveyor,
	                              idi_PECEoSDistance         := #iUDT_Configuration."070".PEC_Eos.Distance,
	                              idi_PECBoSDistance         := 0,
	                              ii_ExternalSpeed           := 0,
	                              ix_SafetyOk                := #ix_SafetyOk,
	                              ix_24vOk                   := #ix_24vOk,
	                              ix_400vOk                  := #ix_400vOk,
	                              ix_HardwareOk              := #ix_HardwareOk,
	                              ix_PECEoS                  := #iqUDT_WorkstationStatus."070".PEC_Eos.PEC,
	                              ix_PECBoS                  := TRUE,
	                              ix_ExternalRequestHold     := false,
	                              qUDT_HMIStatus             => #iqUDT_WorkstationStatus."070".Conveyor,
	                              qUDT_Status                => #iqUDT_WorkstationCommonStatus."070",
	                              iqUDT_EquipmentControl     := #iqUDT_EquipmentControl,
	                              iqUDT_ConveyorCommand      := #iqUDT_WorkstationCommands."070",
	                              iqUDT_ConveyorInterface    := #sUDT_Interface_070,
	                              iqUDT_HandShakeUp          := #sUDT_Handshake_060,
	                              iqUDT_HandShake            := #sUDT_Handshake_070,
	                              iqUDT_Statistics           := #iqUDT_WorkstationStatistics."070".Conveyor);
	        END_REGION
	        
	        REGION MCO
	            #sFB_MCOConveyLinxAixController_070(iUDT_AixConfig          := #iUDT_Configuration."070".MCO,
	                                                iUDT_AixInputsModule    := #iUDT_MotorInput070,
	                                                ix_24vOk                := #ix_24vOk,
	                                                ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                ii_MotorPositionId      := 1,
	                                                qUDT_HMIStatus          => #iqUDT_WorkstationStatus."070".MCO,
	                                                iqUDT_AixOutputsModule  := #qUDT_MotorOutput070,
	                                                iqUDT_ConveyorInterface := #sUDT_Interface_070,
	                                                iqUDT_MCOStatistics     := #iqUDT_WorkstationStatistics."070".MCO);
	        END_REGION
	    END_REGION
	    
	    REGION 080
	        
	        REGION Displacement
	            
	            #sFB_Displacement080(#sUDT_Interface_080);
	            
	        END_REGION
	        
	        REGION EoS               
	            
	            #sFB_PEC_080(ix_PEC                   := #iUDT_MotorInput080.AllSensorPortInputs.LeftSensor,
	                         iUDT_PECConfiguration   := #iUDT_Configuration."080".PEC_Eos,
	                         qUDT_HMIStatus          => #iqUDT_WorkstationStatus."080".PEC_Eos,
	                         iqUDT_ConveyorInterface := #sUDT_Interface_080,
	                         iqUDT_PECStatistics     := #iqUDT_WorkstationStatistics."080".PEC_Eos);
	            
	        END_REGION
	        
	        REGION Conveyor
	            #sFB_Conveyor_080(iUDT_ConveyorConfiguration := #iUDT_Configuration."080".Conveyor,
	                              idi_PECEoSDistance         := #iUDT_Configuration."080".PEC_Eos.Distance,
	                              idi_PECBoSDistance         := 0,
	                              ii_ExternalSpeed           := 0,
	                              ix_SafetyOk                := #ix_SafetyOk,
	                              ix_24vOk                   := #ix_24vOk,
	                              ix_400vOk                  := #ix_400vOk,
	                              ix_HardwareOk              := #ix_HardwareOk,
	                              ix_PECEoS                  := #iqUDT_WorkstationStatus."080".PEC_Eos.PEC,
	                              ix_PECBoS                  := TRUE,
	                              ix_ExternalRequestHold     := false,
	                              qUDT_HMIStatus             => #iqUDT_WorkstationStatus."080".Conveyor,
	                              qUDT_Status                => #iqUDT_WorkstationCommonStatus."080",
	                              iqUDT_EquipmentControl     := #iqUDT_EquipmentControl,
	                              iqUDT_ConveyorCommand      := #iqUDT_WorkstationCommands."080",
	                              iqUDT_ConveyorInterface    := #sUDT_Interface_080,
	                              iqUDT_HandShakeUp          := #sUDT_Handshake_070,
	                              iqUDT_HandShake            := #sUDT_Handshake_080,
	                              iqUDT_Statistics           := #iqUDT_WorkstationStatistics."080".Conveyor);
	        END_REGION
	        
	        REGION MCO
	            #sFB_MCOConveyLinxAixController_080(iUDT_AixConfig          := #iUDT_Configuration."080".MCO,
	                                                iUDT_AixInputsModule    := #iUDT_MotorInput080,
	                                                ix_24vOk                := #ix_24vOk,
	                                                ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                ii_MotorPositionId      := 1,
	                                                qUDT_HMIStatus          => #iqUDT_WorkstationStatus."080".MCO,
	                                                iqUDT_AixOutputsModule  := #qUDT_MotorOutput080,
	                                                iqUDT_ConveyorInterface := #sUDT_Interface_080,
	                                                iqUDT_MCOStatistics     := #iqUDT_WorkstationStatistics."080".MCO);
	        END_REGION
	    END_REGION
	    
	    REGION 090
	        
	        REGION Displacement
	            
	            #sFB_Displacement090(#sUDT_Interface_090);
	            
	        END_REGION
	        
	        REGION Conveyor
	            #sFB_Conveyor_090(iUDT_ConveyorConfiguration := #iUDT_Configuration."090".Conveyor,
	                              idi_PECEoSDistance         := 0,
	                              idi_PECBoSDistance         := 0,
	                              ii_ExternalSpeed           := 0,
	                              ix_SafetyOk                := #ix_SafetyOk,
	                              ix_24vOk                   := #ix_24vOk,
	                              ix_400vOk                  := #ix_400vOk,
	                              ix_HardwareOk              := #ix_HardwareOk,
	                              ix_PECEoS                  := TRUE,
	                              ix_PECBoS                  := TRUE,
	                              ix_ExternalRequestHold     := false,
	                              qUDT_HMIStatus             => #iqUDT_WorkstationStatus."090".Conveyor,
	                              qUDT_Status                => #iqUDT_WorkstationCommonStatus."090",
	                              iqUDT_EquipmentControl     := #iqUDT_EquipmentControl,
	                              iqUDT_ConveyorCommand      := #iqUDT_WorkstationCommands."090",
	                              iqUDT_ConveyorInterface    := #sUDT_Interface_090,
	                              iqUDT_HandShakeUp          := #sUDT_Handshake_080,
	                              iqUDT_HandShake            := #sUDT_Handshake_090,
	                              iqUDT_Statistics           := #iqUDT_WorkstationStatistics."090".Conveyor);
	        END_REGION
	        
	        REGION MCO
	            #sFB_MCOConveyLinxAixController_090(iUDT_AixConfig          := #iUDT_Configuration."090".MCO,
	                                                iUDT_AixInputsModule    := #iUDT_MotorInput090,
	                                                ix_24vOk                := #ix_24vOk,
	                                                ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                ii_MotorPositionId      := 1,
	                                                qUDT_HMIStatus          => #iqUDT_WorkstationStatus."090".MCO,
	                                                iqUDT_AixOutputsModule  := #qUDT_MotorOutput090,
	                                                iqUDT_ConveyorInterface := #sUDT_Interface_090,
	                                                iqUDT_MCOStatistics     := #iqUDT_WorkstationStatistics."090".MCO);
	        END_REGION
	    END_REGION
	    
	    REGION 100
	        
	        REGION Displacement
	            
	            #sFB_Displacement100(#sUDT_Interface_100);
	            
	        END_REGION
	        
	        REGION EoS               
	            
	            #sFB_PEC_100(ix_PEC                   := #iUDT_MotorInput100.AllSensorPortInputs.LeftSensor,
	                         iUDT_PECConfiguration   := #iUDT_Configuration."100".PEC_Eos,
	                         qUDT_HMIStatus          => #iqUDT_WorkstationStatus."100".PEC_Eos,
	                         iqUDT_ConveyorInterface := #sUDT_Interface_100,
	                         iqUDT_PECStatistics     := #iqUDT_WorkstationStatistics."100".PEC_Eos);
	            
	        END_REGION
	        
	        REGION Conveyor
	            #sFB_Conveyor_100(iUDT_ConveyorConfiguration := #iUDT_Configuration."100".Conveyor,
	                              idi_PECEoSDistance         := #iUDT_Configuration."100".PEC_Eos.Distance,
	                              idi_PECBoSDistance         := 0,
	                              ii_ExternalSpeed           := 0,
	                              ix_SafetyOk                := #ix_SafetyOk,
	                              ix_24vOk                   := #ix_24vOk,
	                              ix_400vOk                  := #ix_400vOk,
	                              ix_HardwareOk              := #ix_HardwareOk,
	                              ix_PECEoS                  := #iqUDT_WorkstationStatus."100".PEC_Eos.PEC,
	                              ix_PECBoS                  := TRUE,
	                              ix_ExternalRequestHold     := false,
	                              qUDT_HMIStatus             => #iqUDT_WorkstationStatus."100".Conveyor,
	                              qUDT_Status                => #iqUDT_WorkstationCommonStatus."100",
	                              iqUDT_EquipmentControl     := #iqUDT_EquipmentControl,
	                              iqUDT_ConveyorCommand      := #iqUDT_WorkstationCommands."100",
	                              iqUDT_ConveyorInterface    := #sUDT_Interface_100,
	                              iqUDT_HandShakeUp          := #sUDT_Handshake_090,
	                              iqUDT_HandShake            := #sUDT_Handshake_100,
	                              iqUDT_Statistics           := #iqUDT_WorkstationStatistics."100".Conveyor);
	        END_REGION
	        
	        REGION MCO
	            #sFB_MCOConveyLinxAixController_100(iUDT_AixConfig          := #iUDT_Configuration."100".MCO,
	                                                iUDT_AixInputsModule    := #iUDT_MotorInput100,
	                                                ix_24vOk                := #ix_24vOk,
	                                                ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                ii_MotorPositionId      := 1,
	                                                qUDT_HMIStatus          => #iqUDT_WorkstationStatus."100".MCO,
	                                                iqUDT_AixOutputsModule  := #qUDT_MotorOutput100,
	                                                iqUDT_ConveyorInterface := #sUDT_Interface_100,
	                                                iqUDT_MCOStatistics     := #iqUDT_WorkstationStatistics."100".MCO);
	        END_REGION
	        
	    END_REGION
	    
	    REGION 110
	        
	        REGION Displacement
	            
	            #sFB_Displacement110(#sUDT_Interface_110);
	            
	        END_REGION
	        
	        REGION EoS               
	            
	            #sFB_PEC_110(ix_PEC                   := #iUDT_MotorInput110.AllSensorPortInputs.LeftSensor,
	                         iUDT_PECConfiguration   := #iUDT_Configuration."110".PEC_Eos,
	                         qUDT_HMIStatus          => #iqUDT_WorkstationStatus."110".PEC_Eos,
	                         iqUDT_ConveyorInterface := #sUDT_Interface_110,
	                         iqUDT_PECStatistics     := #iqUDT_WorkstationStatistics."110".PEC_Eos);
	            
	        END_REGION
	        
	        REGION Scanner
	            
	            #sFB_CognexDM260_110(iUDT_CognexDM260_IN    := #iUDT_ScannerInput110,
	                                 qs_Barcode             => #ts_Barcode110,
	                                 iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                 ix_Trigger             := #tx_dummy,
	                                 qUDT_CognexDM260_OUT   => #qUDT_ScannerOutput110,
	                                 qw_RetVal              => #tw_dummy);
	            
	        END_REGION
	        
	        REGION Conveyor
	            #sUDT_Handshake_110.RTR := #sUDT_Handshake_110.RTR OR #iqUDT_WorkstationStatus."110".PEC_Eos.PEC;
	            #sFB_Conveyor_110(iUDT_ConveyorConfiguration := #iUDT_Configuration."110".Conveyor,
	                              idi_PECEoSDistance         := #iUDT_Configuration."110".PEC_Eos.Distance,
	                              idi_PECBoSDistance         := 0,
	                              ii_ExternalSpeed           := 0,
	                              ix_SafetyOk                := #ix_SafetyOk,
	                              ix_24vOk                   := #ix_24vOk,
	                              ix_400vOk                  := #ix_400vOk,
	                              ix_HardwareOk              := #ix_HardwareOk,
	                              ix_PECEoS                  := #iqUDT_WorkstationStatus."110".PEC_Eos.PEC,
	                              ix_PECBoS                  := TRUE,
	                              ix_ExternalRequestHold     := false,
	                              qUDT_HMIStatus             => #iqUDT_WorkstationStatus."110".Conveyor,
	                              qUDT_Status                => #iqUDT_WorkstationCommonStatus."110",
	                              iqUDT_EquipmentControl     := #iqUDT_EquipmentControl,
	                              iqUDT_ConveyorCommand      := #iqUDT_WorkstationCommands."110",
	                              iqUDT_ConveyorInterface    := #sUDT_Interface_110,
	                              iqUDT_HandShakeUp          := #sUDT_Handshake_100,
	                              iqUDT_HandShake            := #sUDT_Handshake_110,
	                              iqUDT_Statistics           := #iqUDT_WorkstationStatistics."110".Conveyor);
	        END_REGION
	        
	        REGION MCO
	            #sFB_MCOConveyLinxAixController_110(iUDT_AixConfig          := #iUDT_Configuration."110".MCO,
	                                                iUDT_AixInputsModule    := #iUDT_MotorInput110,
	                                                ix_24vOk                := #ix_24vOk,
	                                                ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                ii_MotorPositionId      := 1,
	                                                qUDT_HMIStatus          => #iqUDT_WorkstationStatus."110".MCO,
	                                                iqUDT_AixOutputsModule  := #qUDT_MotorOutput110,
	                                                iqUDT_ConveyorInterface := #sUDT_Interface_110,
	                                                iqUDT_MCOStatistics     := #iqUDT_WorkstationStatistics."110".MCO);
	        END_REGION
	    END_REGION
	    
	    REGION 120
	        
	        REGION Displacement
	            
	            #sFB_Displacement120(#sUDT_Interface_120);
	            
	        END_REGION
	        
	        REGION MCO
	            #sFB_MCOConveyLinxAixController_120(iUDT_AixConfig          := #iUDT_Configuration."120".MCO,
	                                                iUDT_AixInputsModule    := #iUDT_MotorInput120,
	                                                ii_PositionSetpoint     := #iqUDT_RATPositioning120.Lower.EndPosition,
	                                                ix_24vOk                := #ix_24vOk,
	                                                ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                ii_MotorPositionId      := 1,
	                                                ix_StartPositioning     := #iqUDT_RATPositioning120.Lower.Start,
	                                                ix_ResetPosition        := #iqUDT_RATPositioning120.Lower.ResetPosition,
	                                                qUDT_HMIStatus          => #iqUDT_WorkstationStatus."120".MCO,
	                                                qx_Positioned           => #iqUDT_RATPositioning120.Lower.Done,
	                                                iqUDT_AixOutputsModule  := #qUDT_MotorOutput120,
	                                                iqUDT_ConveyorInterface := #sUDT_Interface_120,
	                                                iqUDT_MCOStatistics     := #iqUDT_WorkstationStatistics."120".MCO);
	        END_REGION
	        
	        
	    END_REGION
	    
	    REGION 121
	        
	        REGION RAT
	            //Destination from 120
	            IF #ix_LeftReqFromMid THEN
	                #si_120DestinationA := 2;
	                #si_120DestinationB := 0;
	                #si_120DestinationC := 0;
	                #si_120DestinationD := 0;
	            ELSIF #ix_RightReqFromMid THEN
	                #si_120DestinationA := 1;
	                #si_120DestinationB := 0;
	                #si_120DestinationC := 0;
	                #si_120DestinationD := 0;
	            ELSE
	                #si_120DestinationA := 0;
	                #si_120DestinationB := 0;
	                #si_120DestinationC := 0;
	                #si_120DestinationD := 0;
	            END_IF;
	            
	            #sUDT_HandshakeUp_121.RTR := TRUE;
	            #sUDT_Handshake_121.RTR := TRUE;
	            
	    IF #sUDT_Interface_120.ActualSpeed = 0 AND NOT #iqUDT_WorkstationStatus."120".PEC_Eos.PEC THEN
	                "qx_WSV01-221-S11_Light" := TRUE;
	                "qx_WSV01-521-S11_Light" := TRUE;
	            ELSE
	                "qx_WSV01-221-S11_Light" := FALSE;
	                "qx_WSV01-521-S11_Light" := FALSE;
	            END_IF;
	            
	            #sFB_RightAngledTransfer_121(iUDT_Configuration              := #iUDT_Configuration."121".RAT,
	                                         iUDT_LowerConveyorConfiguration := #iUDT_Configuration."120".Conveyor,
	                                         iUDT_UpperConveyorConfiguration := #iUDT_Configuration."121".Conveyor,
	                                         iUDT_PECConfiguration           := #iUDT_Configuration."120".PEC,
	                                         ii_DestinationA                 := #si_120DestinationA,
	                                         ii_DestinationB                 := #si_120DestinationB,
	                                         ii_DestinationC                 := #si_120DestinationC,
	                                         ii_DestinationD                 := #si_120DestinationD,
	                                         ix_HardwareOk                   := #ix_HardwareOk,
	                                         ix_400vOk                       := #ix_400vOk,
	                                         ix_24vOk                        := #ix_24vOk,
	                                         ix_SafetyOk                     := #ix_SafetyOk,
	                                         ix_AirPressureOk                := #ix_AirPressureOk,
	                                         ix_SectionIsDown                := #ix_SectionIsDown121,
	                                         ix_SectionIsUp                  := #ix_SectionIsUp121,
	                                         ix_ConveyorAAuto                := #iqUDT_WorkstationCommonStatus."110".AutoON,
	                                         ix_ConveyorBAuto                := false,
	                                         ix_ConveyorCAuto                := true,
	                                         ix_ConveyorDAuto                := true,
	                                         ix_PEC                          := #iUDT_MotorInput120.AllSensorPortInputs.LeftSensor,
	                                         ix_ExternalReceiveRequestA      := NOT #iqUDT_WorkstationStatus."110".PEC_Eos.PEC,
	                                         ix_ExternalReceiveRequestB      := false,
	                                         ix_ExternalReceiveRequestC      := false,
	                                         ix_ExternalReceiveRequestD      := false,
	                                         ix_PECInfeedA                   :=#iqUDT_WorkstationStatus."110".PEC_Eos.PEC,
	                                         qUDT_HMIRATStatus               => #iqUDT_WorkstationStatus."121".RAT,
	                                         qUDT_HMICovneyorStatus          => #iqUDT_WorkstationStatus."120".Conveyor,
	                                         qUDT_HMIPECStatus               => #iqUDT_WorkstationStatus."120".PEC_Eos,
	                                         qUDT_RATStatus                  => #iqUDT_WorkstationCommonStatus."121",
	                                         qUDT_ConveyorStatus             => #iqUDT_WorkstationCommonStatus."120",
	                                         qx_PopupControl                 => #qx_PopupControl121,
	                                         iqUDT_EquipmentControl          := #iqUDT_EquipmentControl,
	                                         iqUDT_RATCommand                := #iqUDT_WorkstationCommands."121",
	                                         iqUDT_ConveyorCommand           := #iqUDT_WorkstationCommands."120",
	                                         iqUDT_RATStatistics             := #iqUDT_WorkstationStatistics."121".RAT,
	                                         iqUDT_ConveyorStatistics        := #iqUDT_WorkstationStatistics."120".Conveyor,
	                                         iqUDT_PECStatistics             := #iqUDT_WorkstationStatistics."120".PEC_Eos,
	                                         iqUDT_HandShakeConveyorA        := #sUDT_Handshake_110,
	                                         iqUDT_HandShakeConveyorB        := #sUDT_Handshake_120,
	                                         iqUDT_HandShakeConveyorC        := #sUDT_HandshakeUp_121,
	                                         iqUDT_HandShakeConveyorD        := #sUDT_Handshake_121,
	                                         iqUDT_LowerConveyorInterface    := #sUDT_Interface_120,
	                                         iqUDT_UpperConveyorInterface    := #sUDT_Interface_121,
	                                         iqUDT_RATPositioning            := #iqUDT_RATPositioning120);
	            
	        END_REGION
	        REGION MCO
	            #sFB_MCOConveyLinxAixController_121(iUDT_AixConfig          := #iUDT_Configuration."121".MCO,
	                                                iUDT_AixInputsModule    := #iUDT_MotorInput120,
	                                                ix_24vOk                := #ix_24vOk,
	                                                ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                ii_MotorPositionId      := 2,
	                                                qUDT_HMIStatus          => #iqUDT_WorkstationStatus."121".MCO,
	                                                iqUDT_AixOutputsModule  := #qUDT_MotorOutput120,
	                                                iqUDT_ConveyorInterface := #sUDT_Interface_121,
	                                                iqUDT_MCOStatistics     := #iqUDT_WorkstationStatistics."121".MCO);
	        END_REGION
	    END_REGION*)
	END_REGION
	
	
	IF #iUDT_Configuration.GlobalConfig.RightStationExists THEN
	    REGION Right Station
	        REGION Right station control
	            
	            //Triggers
	            #s_F_Trig_240(CLK := #iqUDT_WorkstationStatus."240".PEC_Eos.PEC);
	            #s_F_Trig_ClearRight(CLK := #sx_ClearRightStation);
	            
	            //If any request comes, start if possible
	            IF #iqUDT_WorkstationStatus."380".PEC_Eos.PEC
	                AND #ix_StationActive
	                AND NOT #sx_ActiveRequest380
	                AND NOT #sx_TransferOut380
	                AND NOT #sx_ClearRightStation
	            THEN
	                #sx_ActiveRequest380 := TRUE;
	                
	            END_IF;
	            IF #iqUDT_WorkstationStatus."390".PEC_Eos.PEC
	                AND #ix_StationActive
	                AND NOT #sx_ActiveRequest390
	                AND NOT #sx_TransferOut390
	                AND NOT #sx_ClearRightStation
	            THEN
	                #sx_ActiveRequest390 := TRUE;
	            END_IF;
	            
	            //Request in progress
	            IF #sx_ActiveRequest380 AND #sFB_RightAngledTransfer_351.qx_ExternalSendRequestB
	            THEN
	                #sx_ReqInProgress380 := TRUE;
	            END_IF;
	            
	            IF #sx_ActiveRequest390 AND #sFB_RightAngledTransfer_341.qx_ExternalSendRequestB
	            THEN
	                #sx_ReqInProgress390 := TRUE;
	            END_IF;
	            
	            //Request fulfilled
	            IF #sx_ActiveRequest390 AND NOT #iqUDT_WorkstationStatus."390".PEC_Eos.PEC
	            THEN
	                #sx_ActiveRequest390 := FALSE;
	                #sx_ReqInProgress390 := FALSE;
	            END_IF;
	            
	            IF #sx_ActiveRequest380 AND NOT #iqUDT_WorkstationStatus."390".PEC_Eos.PEC
	            THEN
	                #sx_ActiveRequest380 := FALSE;
	                #sx_ReqInProgress380 := FALSE;
	            END_IF;
	            
	            //Start transfer out
	            IF #iqx_Done380
	                AND NOT #sx_TransferOut390
	                AND (#iqUDT_WorkstationStatus."240".PEC_Eos.PEC OR #sx_Hold230)
	                AND NOT #iqUDT_WorkstationStatus."380".PEC_Eos.PEC
	            THEN
	                #sx_TransferOut380 := TRUE;
	                #sx_Hold230 := TRUE;
	                #iqx_Done380 := FALSE;
	            END_IF;
	            
	            IF #iqx_Done390
	                AND NOT #sx_TransferOut380
	                AND (#iqUDT_WorkstationStatus."240".PEC_Eos.PEC OR #sx_Hold230)
	                AND NOT #iqUDT_WorkstationStatus."390".PEC_Eos.PEC
	            THEN
	                #sx_TransferOut390 := TRUE;
	                #sx_Hold230 := TRUE;
	                #iqx_Done390 := FALSE;
	            END_IF;
	            
	            //If transfer is in progress, set up directions and destinations  
	            IF #sx_TransferOut380 THEN
	                #sx_DirectionChange380 := TRUE;
	            END_IF;
	            
	            IF #sx_TransferOut390 THEN
	                #sx_DirectionChange390 := TRUE;
	            END_IF;
	            
	            //If transfer is over set up directions and destinations  
	            
	            IF NOT #sx_TransferOut380 AND NOT #sx_TransferOut390 THEN
	                #sx_Hold230 := FALSE;
	            END_IF;
	            
	            IF #sx_TransferOut380
	                AND #s_F_Trig_240.Q
	            THEN
	                #sx_TransferOut380 := FALSE;
	                #sx_DirectionChange380 := FALSE;
	            END_IF;
	            
	            IF #sx_TransferOut390
	                AND #s_F_Trig_240.Q
	            THEN
	                #sx_TransferOut390 := FALSE;
	                #sx_DirectionChange390 := FALSE;
	            END_IF;
	            
	            
	            //Destinations from RAT 340
	            IF #sx_ActiveRequest390 AND NOT #sx_ReqInProgress390 THEN
	                #si_340DestinationA := 1;
	                #si_340DestinationB := 0;
	                #si_340DestinationC := 0;
	                #si_340DestinationD := 0;
	                
	            ELSIF #iqUDT_WorkstationStatus."350".PEC_Eos.PEC THEN
	                #si_340DestinationA := 2;
	                #si_340DestinationB := 0;
	                #si_340DestinationC := 0;
	                #si_340DestinationD := 0;
	            ELSE
	                #si_340DestinationA := 0;
	                #si_340DestinationB := 0;
	                #si_340DestinationC := 0;
	                #si_340DestinationD := 0;
	            END_IF;
	            
	            
	            //Destinations from RAT 350
	            IF #sx_ActiveRequest380 AND NOT #sx_ReqInProgress380 THEN
	                #si_350DestinationA := 0;
	                #si_350DestinationB := 0;
	                #si_350DestinationC := 0;
	                #si_350DestinationD := 1;
	            ELSE
	                #si_350DestinationA := 0;
	                #si_350DestinationB := 0;
	                #si_350DestinationC := 0;
	                #si_350DestinationD := 0;
	            END_IF;
	            
	            //Other destinations (stay the same as long as station is operating)       
	            #si_240DestinationA := 1;
	            #si_240DestinationB := 0;
	            #si_240DestinationC := 0;
	            #si_240DestinationD := 1;
	            
	            #si_360DestinationA := 1;
	            #si_360DestinationB := 2;
	            #si_360DestinationC := 0;
	            #si_360DestinationD := 0;
	            
	            #si_370DestinationA := 1;
	            #si_370DestinationB := 2;
	            #si_370DestinationC := 2;
	            #si_370DestinationD := 0;
	        END_REGION
	        REGION Clear Right Station
	            //When clearing procedure is requested, set directions and destinations
	            IF NOT #ix_RightStationActive THEN
	                
	                #sx_ClearRightStation := TRUE;
	                
	                #sx_DirectionChange380 := TRUE;
	                #sx_DirectionChange390 := TRUE;
	                
	                #si_340DestinationA := 1;
	                #si_340DestinationB := 0;
	                #si_340DestinationC := 0;
	                #si_340DestinationD := 0;
	                
	                #si_350DestinationA := 0;
	                #si_350DestinationB := 0;
	                #si_350DestinationC := 0;
	                #si_350DestinationD := 1;
	                
	                #si_360DestinationA := 2;
	                #si_360DestinationB := 2;
	                #si_360DestinationC := 0;
	                #si_360DestinationD := 0;
	                
	                #si_370DestinationA := 2;
	                #si_370DestinationB := 2;
	                #si_370DestinationC := 2;
	                #si_370DestinationD := 0;
	            ELSE
	                #sx_ClearRightStation := FALSE;
	            END_IF;
	            
	            //When clearing procedure is done reset directions
	            IF #s_F_Trig_ClearRight.Q THEN
	                #sx_DirectionChange380 := FALSE;
	                #sx_DirectionChange390 := FALSE;
	            END_IF;
	        END_REGION
	        REGION 310
	            
	            REGION Displacement
	                
	                #sFB_Displacement310(#sUDT_Interface_310);
	                
	            END_REGION
	            
	            
	            REGION Conveyor
	                #sFB_Conveyor_310(iUDT_ConveyorConfiguration := #iUDT_Configuration."310".Conveyor,
	                                  idi_PECEoSDistance := 0,
	                                  idi_PECBoSDistance := 0,
	                                  ii_ExternalSpeed := 0,
	                                  ix_SafetyOk := #ix_SafetyOk,
	                                  ix_24vOk := #ix_24vOk,
	                                  ix_400vOk := #ix_400vOk,
	                                  ix_HardwareOk := #ix_HardwareOk,
	                                  ix_PECEoS := TRUE,
	                                  ix_PECBoS := TRUE,
	                                  ix_ExternalRequestHold := false,
	                                  qUDT_HMIStatus => #iqUDT_WorkstationStatus."310".Conveyor,
	                                  qUDT_Status => #iqUDT_WorkstationCommonStatus."310",
	                                  iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                  iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."310".Conveyor,
	                                  iqUDT_ConveyorInterface := #sUDT_Interface_310,
	                                  iqUDT_HandShakeUp := #iqUDT_HandshakeUpstream310,
	                                  iqUDT_HandShake := #sUDT_Handshake_310,
	                                  iqUDT_Statistics := #iqUDT_WorkstationStatistics."310".Conveyor);
	            END_REGION
	            
	            REGION VFD
	                
	                #sFB_VfdNORDPPO4_310(iUDT_VFDConfig := #iUDT_Configuration."310".VFD,
	                                     iUDT_VFDInputs := #iUDT_MotorInput310,
	                                     iUDT_MotorData := #iUDT_MotorData310,
	                                     ix_24vOk := #ix_24vOk,
	                                     ix_400vOk := #ix_400vOk,
	                                     ix_QuickStopDisable := TRUE,
	                                     ix_SimulationModeActive := "DB_Memory".Simulation,
	                                     qUDT_HMIStatus => #iqUDT_WorkstationStatus."310".VFD,
	                                     qUDT_VFDOutputs => #qUDT_MotorOutput310,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface_310,
	                                     iqUDT_VFDStatistics := #iqUDT_WorkstationStatistics."310".VFD,
	                                     iqx_StartCommissioning := #iqx_StartComissioning310);
	                
	            END_REGION
	        END_REGION
	        
	        
	        REGION 320
	            
	            REGION Displacement
	                
	                #sFB_Displacement320(#sUDT_Interface_320);
	                
	            END_REGION
	            
	            REGION Tracking
	                
	                #sFB_Tracking_320(iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."320".Conveyor.Common,
	                                  iqa_TrackingData := #sa_TrackingArray_320,
	                                  iqUDT_ConveyorInterface := #sUDT_Interface_320,
	                                  iqUDT_HandshakeUp := #sUDT_Handshake_310,
	                                  iqUDT_Handshake := #sUDT_Handshake_320);
	            END_REGION
	            
	            REGION EOS
	                
	                #sFB_PECUpdate_320(iUDT_PECUpdateConfiguration := #iUDT_Configuration."320".PEC_Eos,
	                                   iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."320".Conveyor.Common,
	                                   ix_PEC := #iUDT_MotorInput320.AllSensorPortInputs.LeftSensor,
	                                   ix_TeachingMode := FALSE,
	                                   qUDT_Status => #iqUDT_WorkstationStatus."320".PEC_Eos,
	                                   qi_GINwrite => #ti_dummy,
	                                   qx_PECFiltered => #tx_dummy,
	                                   iqa_TrackingData := #sa_TrackingArray_320,
	                                   iqUDT_ConveyorInterface := #sUDT_Interface_320,
	                                   iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                                   iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                                   iqa_FifoData := "DB_FIFOLostGIN".Data,
	                                   iqUDT_Statistics := #iqUDT_WorkstationStatistics."320".PEC_Eos);
	                
	            END_REGION
	            
	            REGION Conveyor
	                #sFB_Conveyor_320(iUDT_ConveyorConfiguration := #iUDT_Configuration."320".Conveyor,
	                                  idi_PECEoSDistance := #iUDT_Configuration."320".PEC_Eos.Distance,
	                                  idi_PECBoSDistance := 0,
	                                  ii_ExternalSpeed := 0,
	                                  ix_SafetyOk := #ix_SafetyOk,
	                                  ix_24vOk := #ix_24vOk,
	                                  ix_400vOk := #ix_400vOk,
	                                  ix_HardwareOk := #ix_HardwareOk,
	                                  ix_PECEoS := #iqUDT_WorkstationStatus."320".PEC_Eos.PEC,
	                                  ix_PECBoS := TRUE,
	                                  ix_ExternalRequestHold := FALSE,
	                                  qUDT_HMIStatus => #iqUDT_WorkstationStatus."320".Conveyor,
	                                  qUDT_Status => #iqUDT_WorkstationCommonStatus."320",
	                                  iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                  iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."320".Conveyor,
	                                  iqUDT_ConveyorInterface := #sUDT_Interface_320,
	                                  iqUDT_HandShakeUp := #sUDT_Handshake_310,
	                                  iqUDT_HandShake := #sUDT_Handshake_320,
	                                  iqUDT_Statistics := #iqUDT_WorkstationStatistics."320".Conveyor);
	            END_REGION
	            
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_320(iUDT_AixConfig := #iUDT_Configuration."320".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput320,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 1,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."320".MCO_M01,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput320,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_320,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."320".MCO_M01);
	            END_REGION
	            
	            
	        END_REGION
	        REGION 330
	            
	            REGION Displacement
	                
	                #sFB_Displacement330(#sUDT_Interface_330);
	                
	            END_REGION
	            
	            REGION Tracking
	                
	                #sFB_Tracking_330(iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."330".Conveyor.Common,
	                                  iqa_TrackingData := #sa_TrackingArray_330,
	                                  iqUDT_ConveyorInterface := #sUDT_Interface_330,
	                                  iqUDT_HandshakeUp := #sUDT_Handshake_320,
	                                  iqUDT_Handshake := #sUDT_Handshake_330);
	            END_REGION
	            
	            REGION EOS
	                
	                #sFB_PECUpdate_330(iUDT_PECUpdateConfiguration := #iUDT_Configuration."330".PEC_Eos,
	                                   iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."330".Conveyor.Common,
	                                   ix_PEC := #iUDT_MotorInput320.AllSensorPortInputs.RightSensor,
	                                   ix_TeachingMode := FALSE,
	                                   qUDT_Status => #iqUDT_WorkstationStatus."330".PEC_Eos,
	                                   qi_GINwrite => #ti_dummy,
	                                   qx_PECFiltered => #tx_dummy,
	                                   iqa_TrackingData := #sa_TrackingArray_330,
	                                   iqUDT_ConveyorInterface := #sUDT_Interface_330,
	                                   iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                                   iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                                   iqa_FifoData := "DB_FIFOLostGIN".Data,
	                                   iqUDT_Statistics := #iqUDT_WorkstationStatistics."330".PEC_Eos);
	                
	            END_REGION
	            
	            REGION Scanner
	                
	                // #sFB_CognexDM260_330(iUDT_CognexDM260_IN    := #iUDT_ScannerInput330,
	                //                      qs_Barcode             => #ts_Barcode330,
	                //                      iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                //                      ix_Trigger             := #sa_TrackingArray_330[50] > 0,
	                //                      qUDT_CognexDM260_OUT   => #qUDT_ScannerOutput330,
	                //                      qw_RetVal              => #tw_dummy);
	                //                      
	                //                      
	                
	                // #sFB_Blade(iudt_DataLogicBladeIN := #iUDT_Blade_IN,
	                //            ix_Trigger            := #sa_TrackingArray_330[55] > 0,
	                //            qx_Trigger            => #qx_BladeOUT,
	                //            qs_Barcode            => #ts_Barcode330);
	                //            
	                (* 
	                #sFB_SickDemoo(ix_Trigger := #sa_TrackingArray_330[55] > 0 (*OR "DB_Test"."TRL03-141_Destination" = 2*),
	                               HWInputIdent := 714,
	                               HWInputLength := 32,
	                               HWOutputIdent := 716,
	                               HWOutputLength := 32,
	                               CANId := 0,
	                               qs_Barcode => #ts_Barcode330,
	                               iqUDT_EquipmentControl := #iqUDT_EquipmentControl);
	                *)
	                #iqUDT_ScannerInput330.Trigger := #sa_TrackingArray_330[55] > 0 (*OR "DB_Test"."TRL03-141_Destination" = 2*);
	                #ts_Barcode330 := #iqUDT_ScannerInput330.BarCodeValue;
	                
	                
	                
	                
	            END_REGION
	            
	            REGION Conveyor
	                #sUDT_Handshake_330.RTR := #sUDT_Handshake_330.RTR OR #iqUDT_WorkstationStatus."330".PEC_Eos.PEC;
	                // #sx_Enable330 := #iUDT_MotorInput320.AllSensorPortInputs.RightSensor OR #iUDT_MotorInput390.AllSensorPortInputs.LeftSensor OR #iUDT_MotorInput350.AllSensorPortInputs.LeftSensor;
	                #sFB_Conveyor_330(iUDT_ConveyorConfiguration := #iUDT_Configuration."330".Conveyor,
	                                  idi_PECEoSDistance := #iUDT_Configuration."330".PEC_Eos.Distance,
	                                  idi_PECBoSDistance := 0,
	                                  ii_ExternalSpeed := 0,
	                                  ix_SafetyOk := #ix_SafetyOk,
	                                  ix_24vOk := #ix_24vOk,
	                                  ix_400vOk := #ix_400vOk,
	                                  ix_HardwareOk := #ix_HardwareOk,
	                                  ix_PECEoS := #iqUDT_WorkstationStatus."330".PEC_Eos.PEC,
	                                  ix_PECBoS := TRUE,
	                                  ix_ExternalRequestHold := false,
	                                  qUDT_HMIStatus => #iqUDT_WorkstationStatus."330".Conveyor,
	                                  qUDT_Status => #iqUDT_WorkstationCommonStatus."330",
	                                  iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                  iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."330".Conveyor,
	                                  iqUDT_ConveyorInterface := #sUDT_Interface_330,
	                                  iqUDT_HandShakeUp := #sUDT_Handshake_320,
	                                  iqUDT_HandShake := #sUDT_Handshake_330,
	                                  iqUDT_Statistics := #iqUDT_WorkstationStatistics."330".Conveyor);
	            END_REGION
	            
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_330(iUDT_AixConfig := #iUDT_Configuration."330".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput320,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 2,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."330".MCO_M01,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput320,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_330,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."330".MCO_M01);
	            END_REGION
	            
	            
	        END_REGION
	        
	        REGION 340
	            
	            REGION Displacement
	                
	                #sFB_Displacement340(#sUDT_Interface_340);
	                
	            END_REGION
	            
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_340(iUDT_AixConfig := #iUDT_Configuration."340".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput340,
	                                                    ii_PositionSetpoint := #iqUDT_RATPositioning340.Lower.EndPosition,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 1,
	                                                    ix_StartPositioning := #iqUDT_RATPositioning340.Lower.Start,
	                                                    ix_ResetPosition := #iqUDT_RATPositioning340.Lower.ResetPosition,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."340".MCO_M01,
	                                                    qx_Positioned => #iqUDT_RATPositioning340.Lower.Done,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput340,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_340,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."340".MCO_M01);
	            END_REGION
	            
	            
	        END_REGION
	        REGION 341
	            
	            REGION Displacement
	                
	                #sFB_Displacement341(#sUDT_Interface_341);
	                
	            END_REGION
	            
	            REGION RAT
	                
	                #sFB_RightAngledTransfer_341(iUDT_Configuration := #iUDT_Configuration."341".RightAngledTransfer,
	                                             iUDT_LowerConveyorConfiguration := #iUDT_Configuration."340".Conveyor,
	                                             iUDT_UpperConveyorConfiguration := #iUDT_Configuration."341".Conveyor,
	                                             iUDT_PECConfiguration := #iUDT_Configuration."340".PEC_Eos,
	                                             ii_DestinationA := #si_340DestinationA,
	                                             ii_DestinationB := #si_340DestinationB,
	                                             ii_DestinationC := #si_340DestinationC,
	                                             ii_DestinationD := #si_340DestinationD,
	                                             ix_HardwareOk := #ix_HardwareOk,
	                                             ix_400vOk := #ix_400vOk,
	                                             ix_24vOk := #ix_24vOk,
	                                             ix_SafetyOk := #ix_SafetyOk,
	                                             ix_AirPressureOk := #ix_AirPressureOk,
	                                             ix_SectionIsDown := #ix_SectionIsDown341,
	                                             ix_SectionIsUp := #ix_SectionIsUp341,
	                                             ix_ConveyorAAuto := #iqUDT_WorkstationCommonStatus."330".AutoON,
	                                             ix_ConveyorBAuto := #iqUDT_WorkstationCommonStatus."370".AutoON,
	                                             ix_ConveyorCAuto := #iqUDT_WorkstationCommonStatus."351".AutoON,
	                                             ix_ConveyorDAuto := FALSE,
	                                             ix_PEC := #iUDT_MotorInput340.AllSensorPortInputs.LeftSensor,
	                                             ix_ExternalReceiveRequestA := NOT #iqUDT_WorkstationStatus."330".PEC_Eos.PEC,
	                                             ix_ExternalReceiveRequestB := false,
	                                             ix_ExternalReceiveRequestC := false,
	                                             ix_ExternalReceiveRequestD := false,
	                                             ix_PECInfeedA := #iqUDT_WorkstationStatus."330".PEC_Eos.PEC,
	                                             ix_PECInfeedB := #iqUDT_WorkstationStatus."370".PEC_Eos.PEC,
	                                             ix_PECInfeedC := #iqUDT_WorkstationStatus."350".PEC_Eos.PEC,
	                                             qUDT_HMIRATStatus => #iqUDT_WorkstationStatus."341".RightAngledTransfer,
	                                             qUDT_HMIConveyorStatus => #iqUDT_WorkstationStatus."340".Conveyor,
	                                             qUDT_HMIPECStatus => #iqUDT_WorkstationStatus."340".PEC_Eos,
	                                             qUDT_RATStatus => #iqUDT_WorkstationCommonStatus."341",
	                                             qUDT_ConveyorStatus => #iqUDT_WorkstationCommonStatus."340",
	                                             qx_PopupControl => #qx_PopupControl341,
	                                             iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                             iqUDT_RATCommand := #iqUDT_WorkstationCommands."341".RightAngledTransfer,
	                                             iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."340".Conveyor,
	                                             iqUDT_RATStatistics := #iqUDT_WorkstationStatistics."341".RightAngledTransfer,
	                                             iqUDT_ConveyorStatistics := #iqUDT_WorkstationStatistics."340".Conveyor,
	                                             iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."340".PEC_Eos,
	                                             iqUDT_HandShakeConveyorA := #sUDT_Handshake_330,
	                                             iqUDT_HandShakeConveyorB := #sUDT_Handshake_340,
	                                             iqUDT_HandShakeConveyorC := #sUDT_HandshakeUp_341,
	                                             iqUDT_HandShakeConveyorD := #sUDT_Handshake_341,
	                                             iqUDT_LowerConveyorInterface := #sUDT_Interface_340,
	                                             iqUDT_UpperConveyorInterface := #sUDT_Interface_341,
	                                             iqUDT_RATPositioning := #iqUDT_RATPositioning340,
	                                             iqUDT_BladeStopEoSInterface := #tUDT_DummyBladeStop,
	                                             iqUDT_BladeStopBoSInterface := #tUDT_DummyBladeStop);
	                
	            END_REGION
	            
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_341(iUDT_AixConfig := #iUDT_Configuration."341".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput340,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 2,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."341".MCO_M01,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput340,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_341,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."341".MCO_M01);
	            END_REGION
	            
	        END_REGION
	        
	        REGION 350
	            
	            REGION Displacement
	                
	                #sFB_Displacement350(#sUDT_Interface_350);
	                
	            END_REGION
	            
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_350(iUDT_AixConfig := #iUDT_Configuration."350".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput350,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 1,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."350".MCO_M01,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput350,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_350,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."350".MCO_M01);
	            END_REGION
	            
	        END_REGION
	        
	        REGION 351
	            
	            REGION Displacement
	                
	                #sFB_Displacement351(#sUDT_Interface_351);
	                
	            END_REGION
	            
	            REGION RAT
	                
	                #sFB_RightAngledTransfer_351(iUDT_Configuration := #iUDT_Configuration."351".RightAngledTransfer,
	                                             iUDT_LowerConveyorConfiguration := #iUDT_Configuration."350".Conveyor,
	                                             iUDT_UpperConveyorConfiguration := #iUDT_Configuration."351".Conveyor,
	                                             iUDT_PECConfiguration := #iUDT_Configuration."350".PEC_Eos,
	                                             ii_DestinationA := #si_350DestinationA,
	                                             ii_DestinationB := #si_350DestinationB,
	                                             ii_DestinationC := #si_350DestinationC,
	                                             ii_DestinationD := #si_350DestinationD,
	                                             ix_HardwareOk := #ix_HardwareOk,
	                                             ix_400vOk := #ix_400vOk,
	                                             ix_24vOk := #ix_24vOk,
	                                             ix_SafetyOk := #ix_SafetyOk,
	                                             ix_AirPressureOk := #ix_AirPressureOk,
	                                             ix_SectionIsDown := #ix_SectionIsDown351,
	                                             ix_SectionIsUp := #ix_SectionIsUp351,
	                                             ix_ConveyorAAuto := false,
	                                             ix_ConveyorBAuto := #iqUDT_WorkstationCommonStatus."360".AutoON,
	                                             ix_ConveyorCAuto := false,
	                                             ix_ConveyorDAuto := #iqUDT_WorkstationCommonStatus."341".AutoON,
	                                             ix_PEC := #iUDT_MotorInput350.AllSensorPortInputs.LeftSensor,
	                                             ix_ExternalReceiveRequestA := false,
	                                             ix_ExternalReceiveRequestB := false,
	                                             ix_ExternalReceiveRequestC := false,
	                                             ix_ExternalReceiveRequestD := #sFB_RightAngledTransfer_341.qx_ExternalSendRequestC,//NOT #iUDT_MotorInput340.AllSensorPortInputs.LeftSensor AND NOT #sx_ActiveRequest390,,,,,,,,
	                                             ix_PECInfeedB := #iqUDT_WorkstationStatus."360".PEC_Eos.PEC,
	                                             ix_PECInfeedD := #iqUDT_WorkstationStatus."340".PEC_Eos.PEC,
	                                             qUDT_HMIRATStatus => #iqUDT_WorkstationStatus."351".RightAngledTransfer,
	                                             qUDT_HMIConveyorStatus => #iqUDT_WorkstationStatus."350".Conveyor,
	                                             qUDT_HMIPECStatus => #iqUDT_WorkstationStatus."350".PEC_Eos,
	                                             qUDT_RATStatus => #iqUDT_WorkstationCommonStatus."351",
	                                             qUDT_ConveyorStatus => #iqUDT_WorkstationCommonStatus."350",
	                                             qx_PopupControl => #qx_PopupControl351,
	                                             iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                             iqUDT_RATCommand := #iqUDT_WorkstationCommands."351".RightAngledTransfer,
	                                             iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."350".Conveyor,
	                                             iqUDT_RATStatistics := #iqUDT_WorkstationStatistics."351".RightAngledTransfer,
	                                             iqUDT_ConveyorStatistics := #iqUDT_WorkstationStatistics."350".Conveyor,
	                                             iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."350".PEC_Eos,
	                                             iqUDT_HandShakeConveyorA := #tUDT_dummyHandshake,
	                                             iqUDT_HandShakeConveyorB := #sUDT_Handshake_350,
	                                             iqUDT_HandShakeConveyorC := #tUDT_dummyHandshake,
	                                             iqUDT_HandShakeConveyorD := #sUDT_HandshakeUp_341,
	                                             iqUDT_LowerConveyorInterface := #sUDT_Interface_350,
	                                             iqUDT_UpperConveyorInterface := #sUDT_Interface_351,
	                                             iqUDT_RATPositioning := #iqUDT_RATPositioning350,
	                                             iqUDT_BladeStopEoSInterface := #tUDT_DummyBladeStop,
	                                             iqUDT_BladeStopBoSInterface := #tUDT_DummyBladeStop);
	                
	            END_REGION
	            
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_351(iUDT_AixConfig := #iUDT_Configuration."351".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput350,
	                                                    ii_PositionSetpoint := #iqUDT_RATPositioning350.Upper.EndPosition,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 2,
	                                                    ix_StartPositioning := #iqUDT_RATPositioning350.Upper.Start,
	                                                    ix_ResetPosition := #iqUDT_RATPositioning350.Upper.ResetPosition,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."351".MCO_M01,
	                                                    qx_Positioned => #iqUDT_RATPositioning350.Upper.Done,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput350,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_351,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."351".MCO_M01);
	            END_REGION
	        END_REGION
	        
	        REGION 360
	            
	            REGION Displacement
	                
	                #sFB_Displacement360(#sUDT_Interface_360);
	                
	            END_REGION
	            
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_360(iUDT_AixConfig := #iUDT_Configuration."360".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput360,
	                                                    ii_PositionSetpoint := #iqUDT_RATPositioning360.Lower.EndPosition,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 1,
	                                                    ix_StartPositioning := #iqUDT_RATPositioning360.Lower.Start,
	                                                    ix_ResetPosition := #iqUDT_RATPositioning360.Lower.ResetPosition,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."360".MCO_M01,
	                                                    qx_Positioned => #iqUDT_RATPositioning360.Lower.Done,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput360,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_360,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."360".MCO_M01);
	            END_REGION
	            
	        END_REGION
	        REGION 361
	            
	            REGION Displacement
	                
	                #sFB_Displacement361(#sUDT_Interface_361);
	                
	            END_REGION
	            
	            REGION RAT
	                
	                #sFB_RightAngledTransfer_361(iUDT_Configuration := #iUDT_Configuration."361".RightAngledTransfer,
	                                             iUDT_LowerConveyorConfiguration := #iUDT_Configuration."360".Conveyor,
	                                             iUDT_UpperConveyorConfiguration := #iUDT_Configuration."361".Conveyor,
	                                             iUDT_PECConfiguration := #iUDT_Configuration."360".PEC_Eos,
	                                             ii_DestinationA := #si_360DestinationA,
	                                             ii_DestinationB := #si_360DestinationB,
	                                             ii_DestinationC := #si_360DestinationC,
	                                             ii_DestinationD := #si_360DestinationD,
	                                             ix_HardwareOk := #ix_HardwareOk,
	                                             ix_400vOk := #ix_400vOk,
	                                             ix_24vOk := #ix_24vOk,
	                                             ix_SafetyOk := #ix_SafetyOk,
	                                             ix_AirPressureOk := #ix_AirPressureOk,
	                                             ix_SectionIsDown := #ix_SectionIsDown361,
	                                             ix_SectionIsUp := #ix_SectionIsUp361,
	                                             ix_ConveyorAAuto := #iqUDT_WorkstationCommonStatus."350".AutoON,
	                                             ix_ConveyorBAuto := #iqUDT_WorkstationCommonStatus."380".AutoON,
	                                             ix_ConveyorCAuto := FALSE,
	                                             ix_ConveyorDAuto := #iqUDT_WorkstationCommonStatus."371".AutoON,
	                                             ix_PEC := #iUDT_MotorInput360.AllSensorPortInputs.LeftSensor,
	                                             ix_ExternalReceiveRequestA := #sFB_RightAngledTransfer_351.qx_ExternalSendRequestB AND (#sx_ActiveRequest380 OR #sx_ClearRightStation),//#sx_ActiveRequest380 AND NOT #iUDT_MotorInput350.AllSensorPortInputs.LeftSensor,
	                                             ix_ExternalReceiveRequestB := (#sx_TransferOut380 OR #sx_ClearRightStation) AND NOT #iqUDT_WorkstationStatus."380".PEC_Eos.PEC,
	                                             ix_ExternalReceiveRequestC := false,
	                                             ix_ExternalReceiveRequestD := false,
	                                             ix_PECInfeedA := #iqUDT_WorkstationStatus."350".PEC_Eos.PEC,
	                                             ix_PECInfeedB := #iqUDT_WorkstationStatus."380".PEC_Eos.PEC,
	                                             ix_PECInfeedD := #iqUDT_WorkstationStatus."370".PEC_Eos.PEC,
	                                             qUDT_HMIRATStatus => #iqUDT_WorkstationStatus."361".RightAngledTransfer,
	                                             qUDT_HMIConveyorStatus => #iqUDT_WorkstationStatus."360".Conveyor,
	                                             qUDT_HMIPECStatus => #iqUDT_WorkstationStatus."360".PEC_Eos,
	                                             qUDT_RATStatus => #iqUDT_WorkstationCommonStatus."361",
	                                             qUDT_ConveyorStatus => #iqUDT_WorkstationCommonStatus."360",
	                                             qx_PopupControl => #qx_PopupControl361,
	                                             iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                             iqUDT_RATCommand := #iqUDT_WorkstationCommands."361".RightAngledTransfer,
	                                             iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."360".Conveyor,
	                                             iqUDT_RATStatistics := #iqUDT_WorkstationStatistics."361".RightAngledTransfer,
	                                             iqUDT_ConveyorStatistics := #iqUDT_WorkstationStatistics."360".Conveyor,
	                                             iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."360".PEC_Eos,
	                                             iqUDT_HandShakeConveyorA := #sUDT_Handshake_350,
	                                             iqUDT_HandShakeConveyorB := #sUDT_Handshake_360,
	                                             iqUDT_HandShakeConveyorC := #tUDT_dummyHandshake,
	                                             iqUDT_HandShakeConveyorD := #sUDT_Handshake_361,
	                                             iqUDT_LowerConveyorInterface := #sUDT_Interface_360,
	                                             iqUDT_UpperConveyorInterface := #sUDT_Interface_361,
	                                             iqUDT_RATPositioning := #iqUDT_RATPositioning360,
	                                             iqUDT_BladeStopEoSInterface := #tUDT_DummyBladeStop,
	                                             iqUDT_BladeStopBoSInterface := #tUDT_DummyBladeStop);
	                
	            END_REGION
	            
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_361(iUDT_AixConfig := #iUDT_Configuration."361".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput360,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 2,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."361".MCO_M01,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput360,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_361,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."361".MCO_M01);
	            END_REGION
	            
	        END_REGION
	        
	        REGION 370
	            
	            REGION Displacement
	                
	                #sFB_Displacement370(#sUDT_Interface_370);
	                
	            END_REGION
	            
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_370(iUDT_AixConfig := #iUDT_Configuration."370".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput370,
	                                                    ii_PositionSetpoint := #iqUDT_RATPositioning370.Lower.EndPosition,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 1,
	                                                    ix_StartPositioning := #iqUDT_RATPositioning370.Lower.Start,
	                                                    ix_ResetPosition := #iqUDT_RATPositioning370.Lower.ResetPosition,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."370".MCO_M01,
	                                                    qx_Positioned => #iqUDT_RATPositioning370.Lower.Done,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput370,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_370,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."370".MCO_M01);
	            END_REGION
	            
	            
	        END_REGION
	        REGION 371
	            
	            REGION Displacement
	                
	                #sFB_Displacement371(#sUDT_Interface_371);
	                
	            END_REGION
	            
	            REGION RAT
	                
	                #sFB_RightAngledTransfer_371(iUDT_Configuration := #iUDT_Configuration."371".RightAngledTransfer,
	                                             iUDT_LowerConveyorConfiguration := #iUDT_Configuration."370".Conveyor,
	                                             iUDT_UpperConveyorConfiguration := #iUDT_Configuration."371".Conveyor,
	                                             iUDT_PECConfiguration := #iUDT_Configuration."370".PEC_Eos,
	                                             ii_DestinationA := #si_370DestinationA,
	                                             ii_DestinationB := #si_370DestinationB,
	                                             ii_DestinationC := #si_370DestinationC,
	                                             ii_DestinationD := #si_370DestinationD,
	                                             ix_HardwareOk := #ix_HardwareOk,
	                                             ix_400vOk := #ix_400vOk,
	                                             ix_24vOk := #ix_24vOk,
	                                             ix_SafetyOk := #ix_SafetyOk,
	                                             ix_AirPressureOk := #ix_AirPressureOk,
	                                             ix_SectionIsDown := #ix_SectionIsDown371,
	                                             ix_SectionIsUp := #ix_SectionIsUp371,
	                                             ix_ConveyorAAuto := #iqUDT_WorkstationCommonStatus."340".AutoON,
	                                             ix_ConveyorBAuto := #iqUDT_WorkstationCommonStatus."390".AutoON,
	                                             ix_ConveyorCAuto := #iqUDT_WorkstationCommonStatus."361".AutoON,
	                                             ix_ConveyorDAuto := #iqUDT_WorkstationCommonStatus."241".AutoON,
	                                             ix_PEC := #iUDT_MotorInput370.AllSensorPortInputs.LeftSensor,
	                                             ix_ExternalReceiveRequestA := #sFB_RightAngledTransfer_341.qx_ExternalSendRequestB,
	                                             ix_ExternalReceiveRequestB := (#sx_TransferOut390 OR #sx_ClearRightStation) AND NOT #iqUDT_WorkstationStatus."390".PEC_Eos.PEC,
	                                             ix_ExternalReceiveRequestC := #sFB_RightAngledTransfer_361.qx_ExternalSendRequestD,
	                                             ix_ExternalReceiveRequestD := false,
	                                             ix_PECInfeedA := #iqUDT_WorkstationStatus."340".PEC_Eos.PEC,
	                                             ix_PECInfeedB := #iqUDT_WorkstationStatus."390".PEC_Eos.PEC,
	                                             ix_PECInfeedC := #iqUDT_WorkstationStatus."360".PEC_Eos.PEC,
	                                             ix_PECInfeedD := #iqUDT_WorkstationStatus."240".PEC_Eos.PEC,
	                                             qUDT_HMIRATStatus => #iqUDT_WorkstationStatus."371".RightAngledTransfer,
	                                             qUDT_HMIConveyorStatus => #iqUDT_WorkstationStatus."370".Conveyor,
	                                             qUDT_HMIPECStatus => #iqUDT_WorkstationStatus."370".PEC_Eos,
	                                             qUDT_RATStatus => #iqUDT_WorkstationCommonStatus."371",
	                                             qUDT_ConveyorStatus => #iqUDT_WorkstationCommonStatus."370",
	                                             qx_PopupControl => #qx_PopupControl371,
	                                             iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                             iqUDT_RATCommand := #iqUDT_WorkstationCommands."371".RightAngledTransfer,
	                                             iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."370".Conveyor,
	                                             iqUDT_RATStatistics := #iqUDT_WorkstationStatistics."371".RightAngledTransfer,
	                                             iqUDT_ConveyorStatistics := #iqUDT_WorkstationStatistics."370".Conveyor,
	                                             iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."370".PEC_Eos,
	                                             iqUDT_HandShakeConveyorA := #sUDT_Handshake_340,
	                                             iqUDT_HandShakeConveyorB := #sUDT_Handshake_370,
	                                             iqUDT_HandShakeConveyorC := #sUDT_Handshake_361,
	                                             iqUDT_HandShakeConveyorD := #sUDT_Handshake_371,
	                                             iqUDT_LowerConveyorInterface := #sUDT_Interface_370,
	                                             iqUDT_UpperConveyorInterface := #sUDT_Interface_371,
	                                             iqUDT_RATPositioning := #iqUDT_RATPositioning370,
	                                             iqUDT_BladeStopEoSInterface := #tUDT_DummyBladeStop,
	                                             iqUDT_BladeStopBoSInterface := #tUDT_DummyBladeStop);
	                
	            END_REGION
	            
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_371(iUDT_AixConfig := #iUDT_Configuration."371".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput370,
	                                                    ii_PositionSetpoint := #iqUDT_RATPositioning370.Upper.EndPosition,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 2,
	                                                    ix_StartPositioning := #iqUDT_RATPositioning370.Upper.Start,
	                                                    ix_ResetPosition := #iqUDT_RATPositioning370.Upper.ResetPosition,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."371".MCO_M01,
	                                                    qx_Positioned => #iqUDT_RATPositioning370.Upper.Done,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput370,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_371,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."371".MCO_M01);
	            END_REGION
	        END_REGION
	        
	        REGION 380
	            
	            REGION Displacement
	                
	                #sFB_Displacement380(#sUDT_Interface_380);
	                
	            END_REGION
	            
	            REGION Tracking
	                
	                #sFB_Tracking_380(iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."380".Conveyor.Common,
	                                  iqa_TrackingData := #sa_TrackingArray_380,
	                                  iqUDT_ConveyorInterface := #sUDT_Interface_380,
	                                  iqUDT_HandshakeUp := #sUDT_Handshake_360,
	                                  iqUDT_Handshake := #sUDT_Handshake_380);
	            END_REGION
	            
	            REGION EOS
	                
	                #sFB_PECUpdate_380(iUDT_PECUpdateConfiguration := #iUDT_Configuration."380".PEC_Eos,
	                                   iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."380".Conveyor.Common,
	                                   ix_PEC := #iUDT_MotorInput380.AllSensorPortInputs.LeftSensor,
	                                   ix_TeachingMode := FALSE,
	                                   qUDT_Status => #iqUDT_WorkstationStatus."380".PEC_Eos,
	                                   qi_GINwrite => #ti_dummy,
	                                   qx_PECFiltered => #tx_dummy,
	                                   iqa_TrackingData := #sa_TrackingArray_380,
	                                   iqUDT_ConveyorInterface := #sUDT_Interface_380,
	                                   iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                                   iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                                   iqa_FifoData := "DB_FIFOLostGIN".Data,
	                                   iqUDT_Statistics := #iqUDT_WorkstationStatistics."380".PEC_Eos);
	                
	            END_REGION
	            
	            REGION Conveyor
	                
	                #sUDT_Handshake_380.RTR := #iqUDT_WorkstationStatus."380".PEC_Eos.PEC;
	                
	                #sFB_Conveyor_380(iUDT_ConveyorConfiguration := #iUDT_Configuration."380".Conveyor,
	                                  idi_PECEoSDistance := #iUDT_Configuration."380".PEC_Eos.Distance,
	                                  idi_PECBoSDistance := 0,
	                                  ii_ExternalSpeed := 0,
	                                  ix_SafetyOk := #ix_SafetyOk,
	                                  ix_24vOk := #ix_24vOk,
	                                  ix_400vOk := #ix_400vOk,
	                                  ix_HardwareOk := #ix_HardwareOk,
	                                  ix_ReverseDirection := #sx_DirectionChange380,
	                                  ix_PECEoS := #iqUDT_WorkstationStatus."380".PEC_Eos.PEC,
	                                  ix_PECBoS := TRUE,
	                                  ix_ExternalRequestHold := false,
	                                  qUDT_HMIStatus => #iqUDT_WorkstationStatus."380".Conveyor,
	                                  qUDT_Status => #iqUDT_WorkstationCommonStatus."380",
	                                  iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                  iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."380".Conveyor,
	                                  iqUDT_ConveyorInterface := #sUDT_Interface_380,
	                                  iqUDT_HandShakeUp := #sUDT_Handshake_360,
	                                  iqUDT_HandShake := #sUDT_Handshake_380,
	                                  iqUDT_Statistics := #iqUDT_WorkstationStatistics."380".Conveyor);
	            END_REGION
	            
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_380(iUDT_AixConfig := #iUDT_Configuration."380".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput380,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 1,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."380".MCO_M01,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput380,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_380,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."380".MCO_M01);
	            END_REGION
	            
	            
	        END_REGION
	        
	        REGION 390
	            
	            REGION Displacement
	                
	                #sFB_Displacement390(#sUDT_Interface_390);
	                
	            END_REGION
	            
	            REGION Tracking
	                
	                #sFB_Tracking_390(iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."390".Conveyor.Common,
	                                  iqa_TrackingData := #sa_TrackingArray_390,
	                                  iqUDT_ConveyorInterface := #sUDT_Interface_390,
	                                  iqUDT_HandshakeUp := #sUDT_Handshake_370,
	                                  iqUDT_Handshake := #sUDT_Handshake_390);
	            END_REGION
	            
	            REGION EOS
	                
	                #sFB_PECUpdate_390(iUDT_PECUpdateConfiguration := #iUDT_Configuration."390".PEC_Eos,
	                                   iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."390".Conveyor.Common,
	                                   ix_PEC := #iUDT_MotorInput390.AllSensorPortInputs.LeftSensor,
	                                   ix_TeachingMode := FALSE,
	                                   qUDT_Status => #iqUDT_WorkstationStatus."390".PEC_Eos,
	                                   qi_GINwrite => #ti_dummy,
	                                   qx_PECFiltered => #tx_dummy,
	                                   iqa_TrackingData := #sa_TrackingArray_390,
	                                   iqUDT_ConveyorInterface := #sUDT_Interface_390,
	                                   iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                                   iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                                   iqa_FifoData := "DB_FIFOLostGIN".Data,
	                                   iqUDT_Statistics := #iqUDT_WorkstationStatistics."390".PEC_Eos);
	                
	            END_REGION
	            
	            REGION Conveyor
	                
	                #sUDT_Handshake_390.RTR := #iqUDT_WorkstationStatus."390".PEC_Eos.PEC;
	                
	                
	                #sFB_Conveyor_390(iUDT_ConveyorConfiguration := #iUDT_Configuration."390".Conveyor,
	                                  idi_PECEoSDistance := #iUDT_Configuration."390".PEC_Eos.Distance,
	                                  idi_PECBoSDistance := 0,
	                                  ii_ExternalSpeed := 0,
	                                  ix_SafetyOk := #ix_SafetyOk,
	                                  ix_24vOk := #ix_24vOk,
	                                  ix_400vOk := #ix_400vOk,
	                                  ix_HardwareOk := #ix_HardwareOk,
	                                  ix_ReverseDirection := #sx_DirectionChange390,
	                                  ix_PECEoS := #iqUDT_WorkstationStatus."390".PEC_Eos.PEC,
	                                  ix_PECBoS := TRUE,
	                                  ix_ExternalRequestHold := FALSE,
	                                  qUDT_HMIStatus => #iqUDT_WorkstationStatus."390".Conveyor,
	                                  qUDT_Status => #iqUDT_WorkstationCommonStatus."390",
	                                  iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                  iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."390".Conveyor,
	                                  iqUDT_ConveyorInterface := #sUDT_Interface_390,
	                                  iqUDT_HandShakeUp := #sUDT_Handshake_370,
	                                  iqUDT_HandShake := #sUDT_Handshake_390,
	                                  iqUDT_Statistics := #iqUDT_WorkstationStatistics."390".Conveyor);
	            END_REGION
	            
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_390(iUDT_AixConfig := #iUDT_Configuration."390".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput390,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 1,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."390".MCO_M01,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput390,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_390,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."390".MCO_M01);
	            END_REGION
	            
	            
	        END_REGION
	        REGION 230
	            
	            REGION Displacement
	                
	                #sFB_Displacement230(#sUDT_Interface_230);
	                
	            END_REGION
	            
	            REGION Tracking
	                
	                #sFB_Tracking_230(iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."230".Conveyor.Common,
	                                  iqa_TrackingData := #sa_TrackingArray_230,
	                                  iqUDT_ConveyorInterface := #sUDT_Interface_230,
	                                  iqUDT_HandshakeUp := #sUDT_Handshake_230,
	                                  iqUDT_Handshake := #sUDT_Handshake_230);
	            END_REGION
	            
	            REGION EOS
	                
	                #sFB_PECUpdate_230(iUDT_PECUpdateConfiguration := #iUDT_Configuration."230".PEC_Eos,
	                                   iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."230".Conveyor.Common,
	                                   ix_PEC := #iUDT_MotorInput230.AllSensorPortInputs.LeftSensor,
	                                   ix_TeachingMode := FALSE,
	                                   qUDT_Status => #iqUDT_WorkstationStatus."230".PEC_Eos,
	                                   qi_GINwrite => #ti_dummy,
	                                   qx_PECFiltered => #tx_dummy,
	                                   iqa_TrackingData := #sa_TrackingArray_230,
	                                   iqUDT_ConveyorInterface := #sUDT_Interface_230,
	                                   iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                                   iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                                   iqa_FifoData := "DB_FIFOLostGIN".Data,
	                                   iqUDT_Statistics := #iqUDT_WorkstationStatistics."230".PEC_Eos);
	                
	            END_REGION
	            
	            REGION Conveyor
	                #sUDT_Handshake_230.RTR := #sUDT_Handshake_230.RTR OR #iqUDT_WorkstationStatus."230".PEC_Eos.PEC;
	                
	                #sFB_Conveyor_230(iUDT_ConveyorConfiguration := #iUDT_Configuration."230".Conveyor,
	                                  idi_PECEoSDistance := #iUDT_Configuration."230".PEC_Eos.Distance,
	                                  idi_PECBoSDistance := 0,
	                                  ii_ExternalSpeed := 0,
	                                  ix_SafetyOk := #ix_SafetyOk,
	                                  ix_24vOk := #ix_24vOk,
	                                  ix_400vOk := #ix_400vOk,
	                                  ix_HardwareOk := #ix_HardwareOk,
	                                  ix_PECEoS := #iqUDT_WorkstationStatus."230".PEC_Eos.PEC,
	                                  ix_PECBoS := TRUE,
	                                  ix_ExternalRequestHold := #sx_Hold230,
	                                  qUDT_HMIStatus => #iqUDT_WorkstationStatus."230".Conveyor,
	                                  qUDT_Status => #iqUDT_WorkstationCommonStatus."230",
	                                  iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                  iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."230".Conveyor,
	                                  iqUDT_ConveyorInterface := #sUDT_Interface_230,
	                                  iqUDT_HandShakeUp := #sUDT_Handshake_230,
	                                  iqUDT_HandShake := #sUDT_Handshake_230,
	                                  iqUDT_Statistics := #iqUDT_WorkstationStatistics."230".Conveyor);
	            END_REGION
	            
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_230(iUDT_AixConfig := #iUDT_Configuration."230".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput230,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 1,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."230".MCO_M01,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput230,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_230,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."230".MCO_M01);
	            END_REGION
	            
	        END_REGION
	        
	        REGION 240
	            
	            REGION Displacement
	                
	                #sFB_Displacement240(#sUDT_Interface_240);
	                
	            END_REGION
	            
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_240(iUDT_AixConfig := #iUDT_Configuration."240".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput240,
	                                                    ii_PositionSetpoint := #iqUDT_RATPositioning240.Lower.EndPosition,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 1,
	                                                    ix_StartPositioning := #iqUDT_RATPositioning240.Lower.Start,
	                                                    ix_ResetPosition := #iqUDT_RATPositioning240.Lower.ResetPosition,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."240".MCO_M01,
	                                                    qx_Positioned => #iqUDT_RATPositioning240.Lower.Done,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput240,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_240,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."240".MCO_M01);
	            END_REGION
	            
	            
	        END_REGION
	        
	        REGION 241
	            
	            REGION Displacement
	                
	                #sFB_Displacement241(#sUDT_Interface_241);
	                
	            END_REGION
	            
	            REGION RAT
	                
	                #sFB_RightAngledTransfer_241(iUDT_Configuration := #iUDT_Configuration."241".RightAngledTransfer,
	                                             iUDT_LowerConveyorConfiguration := #iUDT_Configuration."240".Conveyor,
	                                             iUDT_UpperConveyorConfiguration := #iUDT_Configuration."241".Conveyor,
	                                             iUDT_PECConfiguration := #iUDT_Configuration."240".PEC_Eos,
	                                             ii_DestinationA := #si_240DestinationA,
	                                             ii_DestinationB := #si_240DestinationB,
	                                             ii_DestinationC := #si_240DestinationC,
	                                             ii_DestinationD := #si_240DestinationD,
	                                             ix_HardwareOk := #ix_HardwareOk,
	                                             ix_400vOk := #ix_400vOk,
	                                             ix_24vOk := #ix_24vOk,
	                                             ix_SafetyOk := #ix_SafetyOk,
	                                             ix_AirPressureOk := #ix_AirPressureOk,
	                                             ix_SectionIsDown := #ix_SectionIsDown241,
	                                             ix_SectionIsUp := #ix_SectionIsUp241,
	                                             ix_ConveyorAAuto := #iqUDT_WorkstationCommonStatus."230".AutoON,
	                                             ix_ConveyorBAuto := #iqUDT_WorkstationCommonStatus."250".AutoON,
	                                             ix_ConveyorCAuto := FALSE,
	                                             ix_ConveyorDAuto := #iqUDT_WorkstationCommonStatus."370".AutoON,
	                                             ix_PEC := #iUDT_MotorInput240.AllSensorPortInputs.LeftSensor,
	                                             ix_ExternalReceiveRequestA := NOT #iqUDT_WorkstationStatus."230".PEC_Eos.PEC AND NOT #sx_TransferOut380 AND NOT #sx_TransferOut390,
	                                             ix_ExternalReceiveRequestB := false,
	                                             ix_ExternalReceiveRequestC := false,
	                                             ix_ExternalReceiveRequestD := #sFB_RightAngledTransfer_371.qx_ExternalSendRequestD,//NOT #iUDT_MotorInput370.AllSensorPortInputs.LeftSensor AND (#sx_TransferOut380 OR #sx_TransferOut390 OR #iqx_ClearRightStation),,
	                                             ix_PECInfeedA := #iqUDT_WorkstationStatus."230".PEC_Eos.PEC,
	                                             ix_PECInfeedD := #iqUDT_WorkstationStatus."370".PEC_Eos.PEC,
	                                             qUDT_HMIRATStatus => #iqUDT_WorkstationStatus."241".RightAngledTransfer,
	                                             qUDT_HMIConveyorStatus => #iqUDT_WorkstationStatus."240".Conveyor,
	                                             qUDT_HMIPECStatus => #iqUDT_WorkstationStatus."240".PEC_Eos,
	                                             qUDT_RATStatus => #iqUDT_WorkstationCommonStatus."241",
	                                             qUDT_ConveyorStatus => #iqUDT_WorkstationCommonStatus."240",
	                                             qx_PopupControl => #qx_PopupControl241,
	                                             iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                             iqUDT_RATCommand := #iqUDT_WorkstationCommands."241".RightAngledTransfer,
	                                             iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."240".Conveyor,
	                                             iqUDT_RATStatistics := #iqUDT_WorkstationStatistics."241".RightAngledTransfer,
	                                             iqUDT_ConveyorStatistics := #iqUDT_WorkstationStatistics."240".Conveyor,
	                                             iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."240".PEC_Eos,
	                                             iqUDT_HandShakeConveyorA := #sUDT_Handshake_230,
	                                             iqUDT_HandShakeConveyorB := #sUDT_Handshake_240,
	                                             iqUDT_HandShakeConveyorC := #sUDT_Handshake_241,
	                                             iqUDT_HandShakeConveyorD := #sUDT_Handshake_371,
	                                             iqUDT_LowerConveyorInterface := #sUDT_Interface_240,
	                                             iqUDT_UpperConveyorInterface := #sUDT_Interface_241,
	                                             iqUDT_RATPositioning := #iqUDT_RATPositioning240,
	                                             iqUDT_BladeStopEoSInterface := #tUDT_DummyBladeStop,
	                                             iqUDT_BladeStopBoSInterface := #tUDT_DummyBladeStop);
	                
	            END_REGION
	            
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_241(iUDT_AixConfig := #iUDT_Configuration."241".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput240,
	                                                    ii_PositionSetpoint := #iqUDT_RATPositioning240.Upper.EndPosition,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 2,
	                                                    ix_StartPositioning := #iqUDT_RATPositioning240.Upper.Start,
	                                                    ix_ResetPosition := #iqUDT_RATPositioning240.Upper.ResetPosition,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."241".MCO_M01,
	                                                    qx_Positioned => #iqUDT_RATPositioning240.Upper.Done,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput240,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_241,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."241".MCO_M01);
	            END_REGION
	        END_REGION
	        
	        REGION 250
	            
	            REGION Displacement
	                
	                #sFB_Displacement250(#sUDT_Interface_250);
	                
	            END_REGION
	            
	            REGION EOS
	                
	                #sFB_PECUpdate_250(iUDT_PECUpdateConfiguration := #iUDT_Configuration."250".PEC_EoS,
	                                   iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."250".Conveyor.Common,
	                                   ix_PEC := #iUDT_MotorInput250.AllSensorPortInputs.LeftSensor,
	                                   ix_TeachingMode := FALSE,
	                                   qUDT_Status => #iqUDT_WorkstationStatus."250".PEC_EoS,
	                                   qi_GINwrite => #ti_dummy,
	                                   qx_PECFiltered => #tx_dummy,
	                                   iqa_TrackingData := #sa_TrackingArray_250,
	                                   iqUDT_ConveyorInterface := #sUDT_Interface_250,
	                                   iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                                   iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                                   iqa_FifoData := "DB_FIFOLostGIN".Data,
	                                   iqUDT_Statistics := #iqUDT_WorkstationStatistics."250".PEC_EoS);
	                
	            END_REGION
	            
	            REGION Conveyor
	                
	                #sUDT_Handshake_250.RTR := #sUDT_Handshake_250.RTR OR #iqUDT_WorkstationStatus."250".PEC_EoS.PEC;
	                
	                #sFB_Conveyor_250(iUDT_ConveyorConfiguration := #iUDT_Configuration."250".Conveyor,
	                                  idi_PECEoSDistance := #iUDT_Configuration."250".PEC_EoS.Distance,
	                                  idi_PECBoSDistance := 0,
	                                  ii_ExternalSpeed := 0,
	                                  ix_SafetyOk := #ix_SafetyOk,
	                                  ix_24vOk := #ix_24vOk,
	                                  ix_400vOk := #ix_400vOk,
	                                  ix_HardwareOk := #ix_HardwareOk,
	                                  ix_PECEoS := #iqUDT_WorkstationStatus."250".PEC_EoS.PEC,
	                                  ix_PECBoS := TRUE,
	                                  ix_ExternalRequestHold := false,
	                                  qUDT_HMIStatus => #iqUDT_WorkstationStatus."250".Conveyor,
	                                  qUDT_Status => #iqUDT_WorkstationCommonStatus."250",
	                                  iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                  iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."250".Conveyor,
	                                  iqUDT_ConveyorInterface := #sUDT_Interface_250,
	                                  iqUDT_HandShakeUp := #sUDT_Handshake_240,
	                                  iqUDT_HandShake := #sUDT_Handshake_250,
	                                  iqUDT_Statistics := #iqUDT_WorkstationStatistics."250".Conveyor);
	            END_REGION
	            
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_250(iUDT_AixConfig := #iUDT_Configuration."250".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput250,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 1,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."250".MCO_M01,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput250,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_250,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."250".MCO_M01);
	            END_REGION
	            
	            
	        END_REGION
	        
	        REGION 260
	            
	            
	            REGION Displacement
	                
	                #sFB_Displacement260(#sUDT_Interface_260);
	                
	            END_REGION
	            
	            REGION Conveyor
	                #sFB_Conveyor_260(iUDT_ConveyorConfiguration := #iUDT_Configuration."260".Conveyor,
	                                  idi_PECEoSDistance := 0,
	                                  idi_PECBoSDistance := 0,
	                                  ii_ExternalSpeed := 0,
	                                  ix_SafetyOk := #ix_SafetyOk,
	                                  ix_24vOk := #ix_24vOk,
	                                  ix_400vOk := #ix_400vOk,
	                                  ix_HardwareOk := #ix_HardwareOk,
	                                  ix_PECEoS := TRUE,
	                                  ix_PECBoS := TRUE,
	                                  ix_ExternalRequestHold := false,
	                                  qUDT_HMIStatus => #iqUDT_WorkstationStatus."260".Conveyor,
	                                  qUDT_Status => #iqUDT_WorkstationCommonStatus."260",
	                                  iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                  iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."260".Conveyor,
	                                  iqUDT_ConveyorInterface := #sUDT_Interface_260,
	                                  iqUDT_HandShakeUp := #sUDT_Handshake_250,
	                                  iqUDT_HandShake := #sUDT_Handshake_260,
	                                  iqUDT_Statistics := #iqUDT_WorkstationStatistics."260".Conveyor);
	            END_REGION
	            
	            REGION VFD
	                
	                #sFB_VfdNORDPPO4_260(iUDT_VFDConfig := #iUDT_Configuration."260".VFD,
	                                     iUDT_VFDInputs := #iUDT_MotorInput260,
	                                     iUDT_MotorData := #iUDT_MotorData260,
	                                     ix_24vOk := #ix_24vOk,
	                                     ix_400vOk := #ix_400vOk,
	                                     ix_QuickStopDisable := TRUE,
	                                     ix_SimulationModeActive := "DB_Memory".Simulation,
	                                     qUDT_HMIStatus => #iqUDT_WorkstationStatus."260".VFD,
	                                     qUDT_VFDOutputs => #qUDT_MotorOutput260,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface_260,
	                                     iqUDT_VFDStatistics := #iqUDT_WorkstationStatistics."260".VFD,
	                                     iqx_StartCommissioning := #iqx_StartComissioning260);
	                
	            END_REGION
	            
	            
	        END_REGION
	        
	        REGION 270
	            
	            REGION Displacement
	                
	                #sFB_Displacement270(#sUDT_Interface_270);
	                
	            END_REGION
	            
	            REGION EoS               
	                
	                #sFB_PEC_270(ix_PEC := #iUDT_MotorInput270.AllSensorPortInputs.LeftSensor,
	                             iUDT_PECConfiguration := #iUDT_Configuration."270".PEC_EoS,
	                             qUDT_HMIStatus => #iqUDT_WorkstationStatus."270".PEC_EoS,
	                             iqUDT_ConveyorInterface := #sUDT_Interface_270,
	                             iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."270".PEC_EoS);
	                
	            END_REGION
	            
	            REGION Conveyor
	                #sFB_Conveyor_270(iUDT_ConveyorConfiguration := #iUDT_Configuration."270".Conveyor,
	                                  idi_PECEoSDistance := #iUDT_Configuration."270".PEC_EoS.Distance,
	                                  idi_PECBoSDistance := 0,
	                                  ii_ExternalSpeed := 0,
	                                  ix_SafetyOk := #ix_SafetyOk,
	                                  ix_24vOk := #ix_24vOk,
	                                  ix_400vOk := #ix_400vOk,
	                                  ix_HardwareOk := #ix_HardwareOk,
	                                  ix_PECEoS := #iqUDT_WorkstationStatus."270".PEC_EoS.PEC,
	                                  ix_PECBoS := TRUE,
	                                  ix_ExternalRequestHold := false,
	                                  qUDT_HMIStatus => #iqUDT_WorkstationStatus."270".Conveyor,
	                                  qUDT_Status => #iqUDT_WorkstationCommonStatus."270",
	                                  iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                  iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."270".Conveyor,
	                                  iqUDT_ConveyorInterface := #sUDT_Interface_270,
	                                  iqUDT_HandShakeUp := #sUDT_Handshake_260,
	                                  iqUDT_HandShake := #sUDT_Handshake_270,
	                                  iqUDT_Statistics := #iqUDT_WorkstationStatistics."270".Conveyor);
	            END_REGION
	            
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_270(iUDT_AixConfig := #iUDT_Configuration."270".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput270,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 1,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."270".MCO_M01,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput270,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_270,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."270".MCO_M01);
	            END_REGION
	        END_REGION
	        
	        REGION 280
	            
	            REGION Displacement
	                
	                #sFB_Displacement280(#sUDT_Interface_280);
	                
	            END_REGION
	            
	            REGION EoS               
	                
	                #sFB_PEC_280(ix_PEC := #iUDT_MotorInput270.AllSensorPortInputs.RightSensor,
	                             iUDT_PECConfiguration := #iUDT_Configuration."280".PEC_EoS,
	                             qUDT_HMIStatus => #iqUDT_WorkstationStatus."280".PEC_EoS,
	                             iqUDT_ConveyorInterface := #sUDT_Interface_280,
	                             iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."280".PEC_EoS);
	                
	            END_REGION
	            
	            REGION Conveyor
	                #iqUDT_HandshakeDownstream280.RTR := #iqUDT_HandshakeDownstream280.RTR OR #iqUDT_WorkstationStatus."280".PEC_EoS.PEC;
	                #sFB_Conveyor_280(iUDT_ConveyorConfiguration := #iUDT_Configuration."280".Conveyor,
	                                  idi_PECEoSDistance := #iUDT_Configuration."280".PEC_EoS.Distance,
	                                  idi_PECBoSDistance := 0,
	                                  ii_ExternalSpeed := 0,
	                                  ix_SafetyOk := #ix_SafetyOk,
	                                  ix_24vOk := #ix_24vOk,
	                                  ix_400vOk := #ix_400vOk,
	                                  ix_HardwareOk := #ix_HardwareOk,
	                                  ix_PECEoS := #iqUDT_WorkstationStatus."280".PEC_EoS.PEC,
	                                  ix_PECBoS := TRUE,
	                                  ix_ExternalRequestHold := false,
	                                  qUDT_HMIStatus => #iqUDT_WorkstationStatus."280".Conveyor,
	                                  qUDT_Status => #iqUDT_WorkstationCommonStatus."280",
	                                  iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                  iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."280".Conveyor,
	                                  iqUDT_ConveyorInterface := #sUDT_Interface_280,
	                                  iqUDT_HandShakeUp := #sUDT_Handshake_270,
	                                  iqUDT_HandShake := #iqUDT_HandshakeDownstream280,
	                                  iqUDT_Statistics := #iqUDT_WorkstationStatistics."280".Conveyor);
	            END_REGION
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_280(iUDT_AixConfig := #iUDT_Configuration."280".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput270,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 2,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."280".MCO_M01,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput270,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_280,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."010".MCO_M01);
	            END_REGION
	        END_REGION
	    END_REGION
	END_IF;
	
	IF #iUDT_Configuration.GlobalConfig.LeftStationExists THEN
	    REGION Left Station
	        REGION Left Station Control
	            
	            //Triggers
	            #s_F_Trig_540(CLK := #iqUDT_WorkstationStatus."540".PEC_Eos.PEC);
	            #s_F_Trig_ClearLeft(CLK := #sx_ClearLeftStation);
	            
	            //If any request comes, start if possible
	            IF #iqUDT_WorkstationStatus."680".PEC_Eos.PEC
	                AND #ix_StationActive
	                AND NOT #sx_ActiveRequest680
	                AND NOT #sx_TransferOut680
	                AND NOT #sx_ClearLeftStation
	            THEN
	                #sx_ActiveRequest680 := TRUE;
	                
	            END_IF;
	            IF #iqUDT_WorkstationStatus."690".PEC_Eos.PEC
	                AND #ix_StationActive
	                AND NOT #sx_ActiveRequest690
	                AND NOT #sx_TransferOut690
	                AND NOT #sx_ClearLeftStation
	            THEN
	                #sx_ActiveRequest690 := TRUE;
	            END_IF;
	            
	            //Request in progress
	            IF #sx_ActiveRequest680 AND #sFB_RightAngledTransfer_651.qx_ExternalSendRequestB THEN
	                #sx_ReqInProgress680 := TRUE;
	            END_IF;
	            
	            IF #sx_ActiveRequest690 AND #sFB_RightAngledTransfer_641.qx_ExternalSendRequestB THEN
	                #sx_ReqInProgress690 := TRUE;
	            END_IF;
	            
	            //Request fulfilled
	            IF #sx_ActiveRequest690 AND NOT #iqUDT_WorkstationStatus."690".PEC_Eos.PEC
	            THEN
	                #sx_ActiveRequest690 := FALSE;
	                #sx_ReqInProgress690 := FALSE;
	            END_IF;
	            
	            IF #sx_ActiveRequest680 AND NOT #iqUDT_WorkstationStatus."680".PEC_Eos.PEC
	            THEN
	                #sx_ActiveRequest680 := FALSE;
	                #sx_ReqInProgress680 := FALSE;
	            END_IF;
	            
	            //Start transfering out 
	            IF #iqx_Done680
	                AND NOT #sx_TransferOut690
	                AND (#iqUDT_WorkstationStatus."540".PEC_Eos.PEC OR #sx_Hold530)
	                AND NOT #iqUDT_WorkstationStatus."680".PEC_Eos.PEC
	            THEN
	                #sx_TransferOut680 := TRUE;
	                #sx_Hold530 := TRUE;
	                #iqx_Done680 := FALSE;
	            END_IF;
	            
	            IF #iqx_Done690
	                AND NOT #sx_TransferOut680
	                AND (#iqUDT_WorkstationStatus."540".PEC_Eos.PEC OR #sx_Hold530)
	                AND NOT #iqUDT_WorkstationStatus."690".PEC_Eos.PEC
	            THEN
	                #sx_TransferOut690 := TRUE;
	                #sx_Hold530 := TRUE;
	                #iqx_Done690 := FALSE;
	            END_IF;
	            
	            //If transfer is in progress, set up directions and destinations  
	            
	            IF #sx_TransferOut680 THEN
	                #sx_DirectionChange680 := TRUE;
	            END_IF;
	            
	            IF #sx_TransferOut690 THEN
	                #sx_DirectionChange690 := TRUE;
	            END_IF;
	            
	            //If transfer is over set up directions and destinations  
	            IF NOT #sx_TransferOut680 AND NOT #sx_TransferOut690 THEN
	                #sx_Hold530 := FALSE;
	            END_IF;
	            
	            IF #sx_TransferOut680 AND #s_F_Trig_540.Q
	            THEN
	                #sx_TransferOut680 := FALSE;
	                #sx_DirectionChange680 := FALSE;
	            END_IF;
	            
	            IF #sx_TransferOut690 AND #s_F_Trig_540.Q
	            THEN
	                #sx_TransferOut690 := FALSE;
	                #sx_DirectionChange690 := FALSE;
	            END_IF;
	            
	            //Destinations from RAT 640
	            IF #sx_ActiveRequest690 AND NOT #sx_ReqInProgress690 THEN
	                #si_640DestinationA := 1;
	                #si_640DestinationB := 0;
	                #si_640DestinationC := 0;
	                #si_640DestinationD := 0;
	                
	            ELSIF #iqUDT_WorkstationStatus."650".PEC_Eos.PEC THEN
	                #si_640DestinationA := 2;
	                #si_640DestinationB := 0;
	                #si_640DestinationC := 0;
	                #si_640DestinationD := 0;
	            ELSE
	                #si_640DestinationA := 0;
	                #si_640DestinationB := 0;
	                #si_640DestinationC := 0;
	                #si_640DestinationD := 0;
	            END_IF;
	            
	            
	            //Destinations from RAT 650
	            IF #sx_ActiveRequest680 AND NOT #sx_ReqInProgress380 THEN
	                #si_650DestinationA := 0;
	                #si_650DestinationB := 0;
	                #si_650DestinationC := 1;
	                #si_650DestinationD := 0;
	            ELSE
	                
	                #si_650DestinationA := 0;
	                #si_650DestinationB := 0;
	                #si_650DestinationC := 0;
	                #si_650DestinationD := 0;
	            END_IF;
	            
	            //Other destinations (stay the same as long as station is operating)
	            #si_540DestinationA := 1;
	            #si_540DestinationB := 0;
	            #si_540DestinationC := 1;
	            #si_540DestinationD := 0;
	            
	            #si_660DestinationA := 1;
	            #si_660DestinationB := 2;
	            #si_660DestinationC := 0;
	            #si_660DestinationD := 0;
	            
	            #si_670DestinationA := 1;
	            #si_670DestinationB := 2;
	            #si_670DestinationC := 0;
	            #si_670DestinationD := 2;
	            
	        END_REGION
	        REGION Clear Left Station
	            //When clearing procedure is requested, set directions and destinations
	            IF NOT #ix_LeftStationActive THEN
	                
	                #sx_ClearLeftStation := TRUE;
	                
	                #sx_DirectionChange680 := TRUE;
	                #sx_DirectionChange690 := TRUE;
	                
	                #si_640DestinationA := 1;
	                #si_640DestinationB := 0;
	                #si_640DestinationC := 0;
	                #si_640DestinationD := 0;
	                
	                #si_650DestinationA := 0;
	                #si_650DestinationB := 0;
	                #si_650DestinationC := 1;
	                #si_650DestinationD := 0;
	                
	                #si_660DestinationA := 2;
	                #si_660DestinationB := 2;
	                #si_660DestinationC := 0;
	                #si_660DestinationD := 0;
	                
	                #si_670DestinationA := 2;
	                #si_670DestinationB := 2;
	                #si_670DestinationC := 0;
	                #si_670DestinationD := 2;
	            ELSE
	                #sx_ClearLeftStation := FALSE;
	            END_IF;
	            //When clearing procedure is done reset directions
	            IF #s_F_Trig_ClearLeft.Q THEN
	                #sx_DirectionChange680 := FALSE;
	                #sx_DirectionChange690 := FALSE;
	            END_IF;
	            
	        END_REGION
	        
	        REGION 610
	            
	            
	            REGION Displacement
	                
	                #sFB_Displacement610(#sUDT_Interface_610);
	                
	            END_REGION
	            
	            
	            REGION Conveyor
	                #sFB_Conveyor_610(iUDT_ConveyorConfiguration := #iUDT_Configuration."610".Conveyor,
	                                  idi_PECEoSDistance := 0,
	                                  idi_PECBoSDistance := 0,
	                                  ii_ExternalSpeed := 0,
	                                  ix_SafetyOk := #ix_SafetyOk,
	                                  ix_24vOk := #ix_24vOk,
	                                  ix_400vOk := #ix_400vOk,
	                                  ix_HardwareOk := #ix_HardwareOk,
	                                  ix_PECEoS := TRUE,
	                                  ix_PECBoS := TRUE,
	                                  ix_ExternalRequestHold := false,
	                                  qUDT_HMIStatus => #iqUDT_WorkstationStatus."610".Conveyor,
	                                  qUDT_Status => #iqUDT_WorkstationCommonStatus."610",
	                                  iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                  iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."610".Conveyor,
	                                  iqUDT_ConveyorInterface := #sUDT_Interface_610,
	                                  iqUDT_HandShakeUp := #iqUDT_HandshakeUpstream610,
	                                  iqUDT_HandShake := #sUDT_Handshake_610,
	                                  iqUDT_Statistics := #iqUDT_WorkstationStatistics."610".Conveyor);
	            END_REGION
	            
	            REGION VFD
	                
	                #sFB_VfdNORDPPO4_610(iUDT_VFDConfig := #iUDT_Configuration."610".VFD,
	                                     iUDT_VFDInputs := #iUDT_MotorInput610,
	                                     iUDT_MotorData := #iUDT_MotorData610,
	                                     ix_24vOk := #ix_24vOk,
	                                     ix_400vOk := #ix_400vOk,
	                                     ix_QuickStopDisable := TRUE,
	                                     ix_SimulationModeActive := "DB_Memory".Simulation,
	                                     qUDT_HMIStatus => #iqUDT_WorkstationStatus."610".VFD,
	                                     qUDT_VFDOutputs => #qUDT_MotorOutput610,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface_610,
	                                     iqUDT_VFDStatistics := #iqUDT_WorkstationStatistics."610".VFD,
	                                     iqx_StartCommissioning := #iqx_StartComissioning610);
	                
	                
	            END_REGION
	        END_REGION
	        
	        
	        REGION 620
	            
	            REGION Displacement
	                
	                #sFB_Displacement620(#sUDT_Interface_620);
	                
	            END_REGION
	            
	            REGION Tracking
	                
	                #sFB_Tracking_620(iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."620".Conveyor.Common,
	                                  iqa_TrackingData := #sa_TrackingArray_620,
	                                  iqUDT_ConveyorInterface := #sUDT_Interface_620,
	                                  iqUDT_HandshakeUp := #sUDT_Handshake_610,
	                                  iqUDT_Handshake := #sUDT_Handshake_620);
	            END_REGION
	            
	            REGION EOS
	                
	                #sFB_PECUpdate_620(iUDT_PECUpdateConfiguration := #iUDT_Configuration."620".PEC_Eos,
	                                   iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."620".Conveyor.Common,
	                                   ix_PEC := #iUDT_MotorInput620.AllSensorPortInputs.LeftSensor,
	                                   ix_TeachingMode := FALSE,
	                                   qUDT_Status => #iqUDT_WorkstationStatus."620".PEC_Eos,
	                                   qi_GINwrite => #ti_dummy,
	                                   qx_PECFiltered => #tx_dummy,
	                                   iqa_TrackingData := #sa_TrackingArray_620,
	                                   iqUDT_ConveyorInterface := #sUDT_Interface_620,
	                                   iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                                   iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                                   iqa_FifoData := "DB_FIFOLostGIN".Data,
	                                   iqUDT_Statistics := #iqUDT_WorkstationStatistics."620".PEC_Eos);
	                
	            END_REGION
	            
	            REGION Conveyor
	                #sFB_Conveyor_620(iUDT_ConveyorConfiguration := #iUDT_Configuration."620".Conveyor,
	                                  idi_PECEoSDistance := #iUDT_Configuration."620".PEC_Eos.Distance,
	                                  idi_PECBoSDistance := 0,
	                                  ii_ExternalSpeed := 0,
	                                  ix_SafetyOk := #ix_SafetyOk,
	                                  ix_24vOk := #ix_24vOk,
	                                  ix_400vOk := #ix_400vOk,
	                                  ix_HardwareOk := #ix_HardwareOk,
	                                  ix_PECEoS := #iqUDT_WorkstationStatus."620".PEC_Eos.PEC,
	                                  ix_PECBoS := TRUE,
	                                  ix_ExternalRequestHold := FALSE,
	                                  qUDT_HMIStatus => #iqUDT_WorkstationStatus."620".Conveyor,
	                                  qUDT_Status => #iqUDT_WorkstationCommonStatus."620",
	                                  iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                  iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."620".Conveyor,
	                                  iqUDT_ConveyorInterface := #sUDT_Interface_620,
	                                  iqUDT_HandShakeUp := #sUDT_Handshake_610,
	                                  iqUDT_HandShake := #sUDT_Handshake_620,
	                                  iqUDT_Statistics := #iqUDT_WorkstationStatistics."620".Conveyor);
	            END_REGION
	            
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_620(iUDT_AixConfig := #iUDT_Configuration."620".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput620,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 1,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."620".MCO_M01,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput620,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_620,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."620".MCO_M01);
	            END_REGION
	            
	            
	        END_REGION
	        
	        REGION 630
	            
	            REGION Displacement
	                
	                #sFB_Displacement630(#sUDT_Interface_630);
	                
	            END_REGION
	            
	            REGION Tracking
	                
	                #sFB_Tracking_630(iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."630".Conveyor.Common,
	                                  iqa_TrackingData := #sa_TrackingArray_630,
	                                  iqUDT_ConveyorInterface := #sUDT_Interface_630,
	                                  iqUDT_HandshakeUp := #sUDT_Handshake_620,
	                                  iqUDT_Handshake := #sUDT_Handshake_630);
	            END_REGION
	            
	            REGION EOS
	                
	                #sFB_PECUpdate_630(iUDT_PECUpdateConfiguration := #iUDT_Configuration."630".PEC_Eos,
	                                   iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."630".Conveyor.Common,
	                                   ix_PEC := #iUDT_MotorInput620.AllSensorPortInputs.RightSensor,
	                                   ix_TeachingMode := FALSE,
	                                   qUDT_Status => #iqUDT_WorkstationStatus."630".PEC_Eos,
	                                   qi_GINwrite => #ti_dummy,
	                                   qx_PECFiltered => #tx_dummy,
	                                   iqa_TrackingData := #sa_TrackingArray_630,
	                                   iqUDT_ConveyorInterface := #sUDT_Interface_630,
	                                   iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                                   iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                                   iqa_FifoData := "DB_FIFOLostGIN".Data,
	                                   iqUDT_Statistics := #iqUDT_WorkstationStatistics."630".PEC_Eos);
	                
	            END_REGION
	            
	            REGION Scanner
	                
	                #sFB_CognexDM260_630(iUDT_CognexDM260_IN := #iUDT_ScannerInput630,
	                                     qs_Barcode => #ts_Barcode630,
	                                     iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                     ix_Trigger := #sa_TrackingArray_630[60] > 0,
	                                     qUDT_CognexDM260_OUT => #qUDT_ScannerOutput630,
	                                     qw_RetVal => #tw_dummy);
	                
	            END_REGION
	            
	            REGION Conveyor
	                #sUDT_Handshake_630.RTR := #sUDT_Handshake_630.RTR OR #iqUDT_WorkstationStatus."630".PEC_Eos.PEC;
	                
	                #sFB_Conveyor_630(iUDT_ConveyorConfiguration := #iUDT_Configuration."630".Conveyor,
	                                  idi_PECEoSDistance := #iUDT_Configuration."630".PEC_Eos.Distance,
	                                  idi_PECBoSDistance := 0,
	                                  ii_ExternalSpeed := 0,
	                                  ix_SafetyOk := #ix_SafetyOk,
	                                  ix_24vOk := #ix_24vOk,
	                                  ix_400vOk := #ix_400vOk,
	                                  ix_HardwareOk := #ix_HardwareOk,
	                                  ix_PECEoS := #iqUDT_WorkstationStatus."630".PEC_Eos.PEC,
	                                  ix_PECBoS := TRUE,
	                                  ix_ExternalRequestHold := FALSE,
	                                  qUDT_HMIStatus => #iqUDT_WorkstationStatus."630".Conveyor,
	                                  qUDT_Status => #iqUDT_WorkstationCommonStatus."630",
	                                  iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                  iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."630".Conveyor,
	                                  iqUDT_ConveyorInterface := #sUDT_Interface_630,
	                                  iqUDT_HandShakeUp := #sUDT_Handshake_620,
	                                  iqUDT_HandShake := #sUDT_Handshake_630,
	                                  iqUDT_Statistics := #iqUDT_WorkstationStatistics."630".Conveyor);
	            END_REGION
	            
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_630(iUDT_AixConfig := #iUDT_Configuration."630".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput620,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 2,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."630".MCO_M01,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput620,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_630,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."630".MCO_M01);
	            END_REGION
	        END_REGION
	        
	        REGION 640
	            
	            REGION Displacement
	                
	                #sFB_Displacement640(#sUDT_Interface_640);
	                
	            END_REGION
	            
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_640(iUDT_AixConfig := #iUDT_Configuration."640".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput640,
	                                                    ii_PositionSetpoint := #iqUDT_RATPositioning640.Lower.EndPosition,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 1,
	                                                    ix_StartPositioning := #iqUDT_RATPositioning640.Lower.Start,
	                                                    ix_ResetPosition := #iqUDT_RATPositioning640.Lower.ResetPosition,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."640".MCO_M01,
	                                                    qx_Positioned => #iqUDT_RATPositioning640.Lower.Done,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput640,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_640,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."640".MCO_M01);
	            END_REGION
	            
	            
	        END_REGION
	        REGION 641
	            
	            REGION Displacement
	                
	                #sFB_Displacement641(#sUDT_Interface_641);
	                
	            END_REGION
	            
	            REGION RAT
	                
	                
	                #sFB_RightAngledTransfer_641(iUDT_Configuration := #iUDT_Configuration."641".RightAngledTransfer,
	                                             iUDT_LowerConveyorConfiguration := #iUDT_Configuration."640".Conveyor,
	                                             iUDT_UpperConveyorConfiguration := #iUDT_Configuration."641".Conveyor,
	                                             iUDT_PECConfiguration := #iUDT_Configuration."640".PEC_Eos,
	                                             ii_DestinationA := #si_640DestinationA,
	                                             ii_DestinationB := #si_640DestinationB,
	                                             ii_DestinationC := #si_640DestinationC,
	                                             ii_DestinationD := #si_640DestinationD,
	                                             ix_HardwareOk := #ix_HardwareOk,
	                                             ix_400vOk := #ix_400vOk,
	                                             ix_24vOk := #ix_24vOk,
	                                             ix_SafetyOk := #ix_SafetyOk,
	                                             ix_AirPressureOk := #ix_AirPressureOk,
	                                             ix_SectionIsDown := #ix_SectionIsDown641,
	                                             ix_SectionIsUp := #ix_SectionIsUp641,
	                                             ix_ConveyorAAuto := #iqUDT_WorkstationCommonStatus."630".AutoON,
	                                             ix_ConveyorBAuto := #iqUDT_WorkstationCommonStatus."670".AutoON,
	                                             ix_ConveyorCAuto := FALSE,
	                                             ix_ConveyorDAuto := #iqUDT_WorkstationCommonStatus."651".AutoON,
	                                             ix_PEC := #iUDT_MotorInput640.AllSensorPortInputs.LeftSensor,
	                                             ix_ExternalReceiveRequestA := NOT #iqUDT_WorkstationStatus."630".PEC_Eos.PEC,
	                                             ix_ExternalReceiveRequestB := false,
	                                             ix_ExternalReceiveRequestC := false,
	                                             ix_ExternalReceiveRequestD := false,
	                                             ix_PECInfeedA := #iqUDT_WorkstationStatus."630".PEC_Eos.PEC,
	                                             qUDT_HMIRATStatus => #iqUDT_WorkstationStatus."641".RightAngledTransfer,
	                                             qUDT_HMIConveyorStatus => #iqUDT_WorkstationStatus."640".Conveyor,
	                                             qUDT_HMIPECStatus => #iqUDT_WorkstationStatus."640".PEC_Eos,
	                                             qUDT_RATStatus => #iqUDT_WorkstationCommonStatus."641",
	                                             qUDT_ConveyorStatus => #iqUDT_WorkstationCommonStatus."640",
	                                             qx_PopupControl => #qx_PopupControl641,
	                                             iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                             iqUDT_RATCommand := #iqUDT_WorkstationCommands."641".RightAngledTransfer,
	                                             iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."640".Conveyor,
	                                             iqUDT_RATStatistics := #iqUDT_WorkstationStatistics."641".RightAngledTransfer,
	                                             iqUDT_ConveyorStatistics := #iqUDT_WorkstationStatistics."640".Conveyor,
	                                             iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."640".PEC_Eos,
	                                             iqUDT_HandShakeConveyorA := #sUDT_Handshake_630,
	                                             iqUDT_HandShakeConveyorB := #sUDT_Handshake_640,
	                                             iqUDT_HandShakeConveyorC := #sUDT_HandshakeUp_641,
	                                             iqUDT_HandShakeConveyorD := #sUDT_Handshake_641,
	                                             iqUDT_LowerConveyorInterface := #sUDT_Interface_640,
	                                             iqUDT_UpperConveyorInterface := #sUDT_Interface_641,
	                                             iqUDT_RATPositioning := #iqUDT_RATPositioning640,
	                                             iqUDT_BladeStopEoSInterface := #tUDT_DummyBladeStop,
	                                             iqUDT_BladeStopBoSInterface := #tUDT_DummyBladeStop);
	                
	            END_REGION
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_641(iUDT_AixConfig := #iUDT_Configuration."641".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput640,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 2,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."641".MCO_M01,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput640,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_641,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."641".MCO_M01);
	            END_REGION
	        END_REGION
	        
	        REGION 650
	            
	            REGION Displacement
	                
	                #sFB_Displacement650(#sUDT_Interface_650);
	                
	            END_REGION
	            
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_650(iUDT_AixConfig := #iUDT_Configuration."650".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput650,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 1,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."650".MCO_M01,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput650,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_650,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."650".MCO_M01);
	            END_REGION
	            
	        END_REGION
	        REGION 651   
	            
	            REGION Displacement
	                
	                #sFB_Displacement651(#sUDT_Interface_651);
	                
	            END_REGION
	            
	            REGION RAT
	                
	                #sFB_RightAngledTransfer_651(iUDT_Configuration := #iUDT_Configuration."651".RightAngledTransfer,
	                                             iUDT_LowerConveyorConfiguration := #iUDT_Configuration."650".Conveyor,
	                                             iUDT_UpperConveyorConfiguration := #iUDT_Configuration."651".Conveyor,
	                                             iUDT_PECConfiguration := #iUDT_Configuration."650".PEC_Eos,
	                                             ii_DestinationA := #si_650DestinationA,
	                                             ii_DestinationB := #si_650DestinationB,
	                                             ii_DestinationC := #si_650DestinationC,
	                                             ii_DestinationD := #si_650DestinationD,
	                                             ix_HardwareOk := #ix_HardwareOk,
	                                             ix_400vOk := #ix_400vOk,
	                                             ix_24vOk := #ix_24vOk,
	                                             ix_SafetyOk := #ix_SafetyOk,
	                                             ix_AirPressureOk := #ix_AirPressureOk,
	                                             ix_SectionIsDown := #ix_SectionIsDown651,
	                                             ix_SectionIsUp := #ix_SectionIsUp651,
	                                             ix_ConveyorAAuto := false,
	                                             ix_ConveyorBAuto := #iqUDT_WorkstationCommonStatus."660".AutoON,
	                                             ix_ConveyorCAuto := #iqUDT_WorkstationCommonStatus."641".AutoON,
	                                             ix_ConveyorDAuto := false,
	                                             ix_PEC := #iUDT_MotorInput650.AllSensorPortInputs.LeftSensor,
	                                             ix_ExternalReceiveRequestA := false,
	                                             ix_ExternalReceiveRequestB := false,
	                                             ix_ExternalReceiveRequestC := #sFB_RightAngledTransfer_641.qx_ExternalSendRequestD,
	                                             ix_ExternalReceiveRequestD := false,
	                                             ix_PECInfeedC := #iqUDT_WorkstationStatus."640".PEC_Eos.PEC,
	                                             qUDT_HMIRATStatus => #iqUDT_WorkstationStatus."651".RightAngledTransfer,
	                                             qUDT_HMIConveyorStatus => #iqUDT_WorkstationStatus."650".Conveyor,
	                                             qUDT_HMIPECStatus => #iqUDT_WorkstationStatus."650".PEC_Eos,
	                                             qUDT_RATStatus => #iqUDT_WorkstationCommonStatus."651",
	                                             qUDT_ConveyorStatus => #iqUDT_WorkstationCommonStatus."650",
	                                             qx_PopupControl => #qx_PopupControl651,
	                                             iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                             iqUDT_RATCommand := #iqUDT_WorkstationCommands."651".RightAngledTransfer,
	                                             iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."650".Conveyor,
	                                             iqUDT_RATStatistics := #iqUDT_WorkstationStatistics."651".RightAngledTransfer,
	                                             iqUDT_ConveyorStatistics := #iqUDT_WorkstationStatistics."650".Conveyor,
	                                             iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."650".PEC_Eos,
	                                             iqUDT_HandShakeConveyorA := #tUDT_dummyHandshake,
	                                             iqUDT_HandShakeConveyorB := #sUDT_Handshake_650,
	                                             iqUDT_HandShakeConveyorC := #sUDT_Handshake_641,
	                                             iqUDT_HandShakeConveyorD := #tUDT_dummyHandshake,
	                                             iqUDT_LowerConveyorInterface := #sUDT_Interface_650,
	                                             iqUDT_UpperConveyorInterface := #sUDT_Interface_651,
	                                             iqUDT_RATPositioning := #iqUDT_RATPositioning650,
	                                             iqUDT_BladeStopEoSInterface := #tUDT_DummyBladeStop,
	                                             iqUDT_BladeStopBoSInterface := #tUDT_DummyBladeStop);
	                
	            END_REGION
	            
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_651(iUDT_AixConfig := #iUDT_Configuration."651".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput650,
	                                                    ii_PositionSetpoint := #iqUDT_RATPositioning650.Upper.EndPosition,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 2,
	                                                    ix_StartPositioning := #iqUDT_RATPositioning650.Upper.Start,
	                                                    ix_ResetPosition := #iqUDT_RATPositioning650.Upper.ResetPosition,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."651".MCO_M01,
	                                                    qx_Positioned => #iqUDT_RATPositioning650.Upper.Done,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput650,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_651,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."651".MCO_M01);
	            END_REGION
	        END_REGION
	        
	        REGION 660
	            
	            REGION Displacement
	                
	                #sFB_Displacement660(#sUDT_Interface_660);
	                
	            END_REGION
	            
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_660(iUDT_AixConfig := #iUDT_Configuration."660".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput660,
	                                                    ii_PositionSetpoint := #iqUDT_RATPositioning660.Lower.EndPosition,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 1,
	                                                    ix_StartPositioning := #iqUDT_RATPositioning660.Lower.Start,
	                                                    ix_ResetPosition := #iqUDT_RATPositioning660.Lower.ResetPosition,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."660".MCO_M01,
	                                                    qx_Positioned => #iqUDT_RATPositioning660.Lower.Done,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput660,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_660,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."660".MCO_M01);
	            END_REGION
	            
	        END_REGION
	        REGION 661
	            
	            REGION Displacement
	                
	                #sFB_Displacement661(#sUDT_Interface_661);
	                
	            END_REGION
	            
	            REGION RAT
	                
	                #sFB_RightAngledTransfer_661(iUDT_Configuration := #iUDT_Configuration."661".RightAngledTransfer,
	                                             iUDT_LowerConveyorConfiguration := #iUDT_Configuration."660".Conveyor,
	                                             iUDT_UpperConveyorConfiguration := #iUDT_Configuration."661".Conveyor,
	                                             iUDT_PECConfiguration := #iUDT_Configuration."660".PEC_Eos,
	                                             ii_DestinationA := #si_660DestinationA,
	                                             ii_DestinationB := #si_660DestinationB,
	                                             ii_DestinationC := #si_660DestinationC,
	                                             ii_DestinationD := #si_660DestinationD,
	                                             ix_HardwareOk := #ix_HardwareOk,
	                                             ix_400vOk := #ix_400vOk,
	                                             ix_24vOk := #ix_24vOk,
	                                             ix_SafetyOk := #ix_SafetyOk,
	                                             ix_AirPressureOk := #ix_AirPressureOk,
	                                             ix_SectionIsDown := #ix_SectionIsDown661,
	                                             ix_SectionIsUp := #ix_SectionIsUp661,
	                                             ix_ConveyorAAuto := #iqUDT_WorkstationCommonStatus."650".AutoON,
	                                             ix_ConveyorBAuto := #iqUDT_WorkstationCommonStatus."680".AutoON,
	                                             ix_ConveyorCAuto := #iqUDT_WorkstationCommonStatus."671".AutoON,
	                                             ix_ConveyorDAuto := false,
	                                             ix_PEC := #iUDT_MotorInput660.AllSensorPortInputs.LeftSensor,
	                                             ix_ExternalReceiveRequestA := #sFB_RightAngledTransfer_651.qx_ExternalSendRequestB AND (#sx_ActiveRequest680 OR #sx_ClearLeftStation),
	                                             ix_ExternalReceiveRequestB := (#sx_TransferOut680 OR #sx_ClearLeftStation) AND NOT #iqUDT_WorkstationStatus."680".PEC_Eos.PEC,
	                                             ix_ExternalReceiveRequestC := false,
	                                             ix_ExternalReceiveRequestD := false,
	                                             ix_PECInfeedA := #iqUDT_WorkstationStatus."650".PEC_Eos.PEC,
	                                             ix_PECInfeedB := #iqUDT_WorkstationStatus."680".PEC_Eos.PEC,
	                                             qUDT_HMIRATStatus => #iqUDT_WorkstationStatus."661".RightAngledTransfer,
	                                             qUDT_HMIConveyorStatus => #iqUDT_WorkstationStatus."660".Conveyor,
	                                             qUDT_HMIPECStatus => #iqUDT_WorkstationStatus."660".PEC_Eos,
	                                             qUDT_RATStatus => #iqUDT_WorkstationCommonStatus."661",
	                                             qUDT_ConveyorStatus => #iqUDT_WorkstationCommonStatus."660",
	                                             qx_PopupControl => #qx_PopupControl661,
	                                             iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                             iqUDT_RATCommand := #iqUDT_WorkstationCommands."661".RightAngledTransfer,
	                                             iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."660".Conveyor,
	                                             iqUDT_RATStatistics := #iqUDT_WorkstationStatistics."661".RightAngledTransfer,
	                                             iqUDT_ConveyorStatistics := #iqUDT_WorkstationStatistics."660".Conveyor,
	                                             iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."660".PEC_Eos,
	                                             iqUDT_HandShakeConveyorA := #sUDT_Handshake_650,
	                                             iqUDT_HandShakeConveyorB := #sUDT_Handshake_660,
	                                             iqUDT_HandShakeConveyorC := #sUDT_HandshakeUp_661,
	                                             iqUDT_HandShakeConveyorD := #tUDT_dummyHandshake,
	                                             iqUDT_LowerConveyorInterface := #sUDT_Interface_660,
	                                             iqUDT_UpperConveyorInterface := #sUDT_Interface_661,
	                                             iqUDT_RATPositioning := #iqUDT_RATPositioning660,
	                                             iqUDT_BladeStopEoSInterface := #tUDT_DummyBladeStop,
	                                             iqUDT_BladeStopBoSInterface := #tUDT_DummyBladeStop);
	                
	            END_REGION
	            
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_661(iUDT_AixConfig := #iUDT_Configuration."661".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput660,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 2,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."661".MCO_M01,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput660,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_661,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."661".MCO_M01);
	            END_REGION
	        END_REGION
	        
	        REGION 670
	            
	            REGION Displacement
	                
	                #sFB_Displacement670(#sUDT_Interface_670);
	                
	            END_REGION
	            
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_670(iUDT_AixConfig := #iUDT_Configuration."670".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput670,
	                                                    ii_PositionSetpoint := #iqUDT_RATPositioning670.Lower.EndPosition,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 1,
	                                                    ix_StartPositioning := #iqUDT_RATPositioning670.Lower.Start,
	                                                    ix_ResetPosition := #iqUDT_RATPositioning670.Lower.ResetPosition,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."670".MCO_M01,
	                                                    qx_Positioned => #iqUDT_RATPositioning670.Lower.Done,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput670,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_670,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."670".MCO_M01);
	            END_REGION
	            
	        END_REGION
	        
	        REGION 671
	            
	            REGION Displacement
	                
	                #sFB_Displacement671(#sUDT_Interface_671);
	                
	            END_REGION
	            
	            REGION RAT
	                
	                #sFB_RightAngledTransfer_671(iUDT_Configuration := #iUDT_Configuration."671".RightAngledTransfer,
	                                             iUDT_LowerConveyorConfiguration := #iUDT_Configuration."670".Conveyor,
	                                             iUDT_UpperConveyorConfiguration := #iUDT_Configuration."671".Conveyor,
	                                             iUDT_PECConfiguration := #iUDT_Configuration."670".PEC_Eos,
	                                             ii_DestinationA := #si_670DestinationA,
	                                             ii_DestinationB := #si_670DestinationB,
	                                             ii_DestinationC := #si_670DestinationC,
	                                             ii_DestinationD := #si_670DestinationD,
	                                             ix_HardwareOk := #ix_HardwareOk,
	                                             ix_400vOk := #ix_400vOk,
	                                             ix_24vOk := #ix_24vOk,
	                                             ix_SafetyOk := #ix_SafetyOk,
	                                             ix_AirPressureOk := #ix_AirPressureOk,
	                                             ix_SectionIsDown := #ix_SectionIsDown671,
	                                             ix_SectionIsUp := #ix_SectionIsUp671,
	                                             ix_ConveyorAAuto := #iqUDT_WorkstationCommonStatus."630".AutoON,
	                                             ix_ConveyorBAuto := #iqUDT_WorkstationCommonStatus."670".AutoON,
	                                             ix_ConveyorCAuto := FALSE,
	                                             ix_ConveyorDAuto := #iqUDT_WorkstationCommonStatus."650".AutoON,
	                                             ix_PEC := #iUDT_MotorInput670.AllSensorPortInputs.LeftSensor,
	                                             ix_ExternalReceiveRequestA := #sFB_RightAngledTransfer_641.qx_ExternalSendRequestB,
	                                             ix_ExternalReceiveRequestB := (#sx_TransferOut690 OR #sx_ClearLeftStation) AND NOT #iqUDT_WorkstationStatus."690".PEC_Eos.PEC,
	                                             ix_ExternalReceiveRequestC := false,
	                                             ix_ExternalReceiveRequestD := #sFB_RightAngledTransfer_661.qx_ExternalSendRequestC,
	                                             ix_PECInfeedA := #iqUDT_WorkstationStatus."640".PEC_Eos.PEC,
	                                             ix_PECInfeedB := #iqUDT_WorkstationStatus."690".PEC_Eos.PEC,
	                                             ix_PECInfeedD := #iqUDT_WorkstationStatus."660".PEC_Eos.PEC,
	                                             qUDT_HMIRATStatus => #iqUDT_WorkstationStatus."671".RightAngledTransfer,
	                                             qUDT_HMIConveyorStatus => #iqUDT_WorkstationStatus."670".Conveyor,
	                                             qUDT_HMIPECStatus => #iqUDT_WorkstationStatus."670".PEC_Eos,
	                                             qUDT_RATStatus => #iqUDT_WorkstationCommonStatus."671",
	                                             qUDT_ConveyorStatus => #iqUDT_WorkstationCommonStatus."670",
	                                             qx_PopupControl => #qx_PopupControl671,
	                                             iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                             iqUDT_RATCommand := #iqUDT_WorkstationCommands."671".RightAngledTransfer,
	                                             iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."670".Conveyor,
	                                             iqUDT_RATStatistics := #iqUDT_WorkstationStatistics."671".RightAngledTransfer,
	                                             iqUDT_ConveyorStatistics := #iqUDT_WorkstationStatistics."670".Conveyor,
	                                             iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."670".PEC_Eos,
	                                             iqUDT_HandShakeConveyorA := #sUDT_Handshake_640,
	                                             iqUDT_HandShakeConveyorB := #sUDT_Handshake_670,
	                                             iqUDT_HandShakeConveyorC := #sUDT_HandshakeUp_671,
	                                             iqUDT_HandShakeConveyorD := #sUDT_HandshakeUp_661,
	                                             iqUDT_LowerConveyorInterface := #sUDT_Interface_670,
	                                             iqUDT_UpperConveyorInterface := #sUDT_Interface_671,
	                                             iqUDT_RATPositioning := #iqUDT_RATPositioning670,
	                                             iqUDT_BladeStopEoSInterface := #tUDT_DummyBladeStop,
	                                             iqUDT_BladeStopBoSInterface := #tUDT_DummyBladeStop);
	                
	            END_REGION
	            
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_671(iUDT_AixConfig := #iUDT_Configuration."671".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput670,
	                                                    ii_PositionSetpoint := #iqUDT_RATPositioning670.Upper.EndPosition,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 2,
	                                                    ix_StartPositioning := #iqUDT_RATPositioning670.Upper.Start,
	                                                    ix_ResetPosition := #iqUDT_RATPositioning670.Upper.ResetPosition,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."671".MCO_M01,
	                                                    qx_Positioned => #iqUDT_RATPositioning670.Upper.Done,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput670,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_671,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."671".MCO_M01);
	            END_REGION
	        END_REGION
	        
	        REGION 680
	            
	            REGION Displacement
	                
	                #sFB_Displacement680(#sUDT_Interface_680);
	                
	            END_REGION
	            
	            REGION Tracking
	                
	                #sFB_Tracking_680(iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."680".Conveyor.Common,
	                                  iqa_TrackingData := #sa_TrackingArray_680,
	                                  iqUDT_ConveyorInterface := #sUDT_Interface_680,
	                                  iqUDT_HandshakeUp := #sUDT_Handshake_660,
	                                  iqUDT_Handshake := #sUDT_Handshake_680);
	            END_REGION
	            
	            REGION EOS
	                
	                #sFB_PECUpdate_680(iUDT_PECUpdateConfiguration := #iUDT_Configuration."680".PEC_Eos,
	                                   iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."680".Conveyor.Common,
	                                   ix_PEC := #iUDT_MotorInput680.AllSensorPortInputs.LeftSensor,
	                                   ix_TeachingMode := FALSE,
	                                   qUDT_Status => #iqUDT_WorkstationStatus."680".PEC_Eos,
	                                   qi_GINwrite => #ti_dummy,
	                                   qx_PECFiltered => #tx_dummy,
	                                   iqa_TrackingData := #sa_TrackingArray_680,
	                                   iqUDT_ConveyorInterface := #sUDT_Interface_680,
	                                   iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                                   iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                                   iqa_FifoData := "DB_FIFOLostGIN".Data,
	                                   iqUDT_Statistics := #iqUDT_WorkstationStatistics."680".PEC_Eos);
	                
	            END_REGION
	            
	            REGION Conveyor
	                
	                #sUDT_Handshake_680.RTR := #iqUDT_WorkstationStatus."680".PEC_Eos.PEC;
	                
	                #sFB_Conveyor_680(iUDT_ConveyorConfiguration := #iUDT_Configuration."680".Conveyor,
	                                  idi_PECEoSDistance := #iUDT_Configuration."680".PEC_Eos.Distance,
	                                  idi_PECBoSDistance := 0,
	                                  ii_ExternalSpeed := 0,
	                                  ix_SafetyOk := #ix_SafetyOk,
	                                  ix_24vOk := #ix_24vOk,
	                                  ix_400vOk := #ix_400vOk,
	                                  ix_HardwareOk := #ix_HardwareOk,
	                                  ix_ReverseDirection := #sx_DirectionChange680,
	                                  ix_PECEoS := #iqUDT_WorkstationStatus."680".PEC_Eos.PEC,
	                                  ix_PECBoS := TRUE,
	                                  ix_ExternalRequestHold := false,
	                                  qUDT_HMIStatus => #iqUDT_WorkstationStatus."680".Conveyor,
	                                  qUDT_Status => #iqUDT_WorkstationCommonStatus."680",
	                                  iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                  iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."680".Conveyor,
	                                  iqUDT_ConveyorInterface := #sUDT_Interface_680,
	                                  iqUDT_HandShakeUp := #sUDT_Handshake_660,
	                                  iqUDT_HandShake := #sUDT_Handshake_680,
	                                  iqUDT_Statistics := #iqUDT_WorkstationStatistics."680".Conveyor);
	            END_REGION
	            
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_680(iUDT_AixConfig := #iUDT_Configuration."680".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput680,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 1,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."680".MCO_M01,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput680,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_680,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."680".MCO_M01);
	            END_REGION
	            
	        END_REGION
	        
	        REGION 690  
	            
	            REGION Displacement
	                
	                #sFB_Displacement690(#sUDT_Interface_690);
	                
	            END_REGION
	            
	            REGION Tracking
	                
	                #sFB_Tracking_690(iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."690".Conveyor.Common,
	                                  iqa_TrackingData := #sa_TrackingArray_690,
	                                  iqUDT_ConveyorInterface := #sUDT_Interface_690,
	                                  iqUDT_HandshakeUp := #sUDT_Handshake_670,
	                                  iqUDT_Handshake := #sUDT_Handshake_690);
	            END_REGION
	            
	            REGION EOS
	                
	                #sFB_PECUpdate_690(iUDT_PECUpdateConfiguration := #iUDT_Configuration."690".PEC_Eos,
	                                   iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."690".Conveyor.Common,
	                                   ix_PEC := #iUDT_MotorInput690.AllSensorPortInputs.LeftSensor,
	                                   ix_TeachingMode := FALSE,
	                                   qUDT_Status => #iqUDT_WorkstationStatus."690".PEC_Eos,
	                                   qi_GINwrite => #ti_dummy,
	                                   qx_PECFiltered => #tx_dummy,
	                                   iqa_TrackingData := #sa_TrackingArray_690,
	                                   iqUDT_ConveyorInterface := #sUDT_Interface_690,
	                                   iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                                   iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                                   iqa_FifoData := "DB_FIFOLostGIN".Data,
	                                   iqUDT_Statistics := #iqUDT_WorkstationStatistics."690".PEC_Eos);
	                
	            END_REGION
	            
	            REGION Conveyor
	                
	                #sUDT_Handshake_690.RTR := #iqUDT_WorkstationStatus."690".PEC_Eos.PEC;
	                
	                
	                #sFB_Conveyor_690(iUDT_ConveyorConfiguration := #iUDT_Configuration."690".Conveyor,
	                                  idi_PECEoSDistance := #iUDT_Configuration."690".PEC_Eos.Distance,
	                                  idi_PECBoSDistance := 0,
	                                  ii_ExternalSpeed := 0,
	                                  ix_SafetyOk := #ix_SafetyOk,
	                                  ix_24vOk := #ix_24vOk,
	                                  ix_400vOk := #ix_400vOk,
	                                  ix_HardwareOk := #ix_HardwareOk,
	                                  ix_ReverseDirection := #sx_DirectionChange690,
	                                  ix_PECEoS := #iqUDT_WorkstationStatus."690".PEC_Eos.PEC,
	                                  ix_PECBoS := TRUE,
	                                  ix_ExternalRequestHold := FALSE,
	                                  qUDT_HMIStatus => #iqUDT_WorkstationStatus."690".Conveyor,
	                                  qUDT_Status => #iqUDT_WorkstationCommonStatus."690",
	                                  iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                  iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."690".Conveyor,
	                                  iqUDT_ConveyorInterface := #sUDT_Interface_690,
	                                  iqUDT_HandShakeUp := #sUDT_Handshake_670,
	                                  iqUDT_HandShake := #sUDT_Handshake_690,
	                                  iqUDT_Statistics := #iqUDT_WorkstationStatistics."690".Conveyor);
	            END_REGION
	            
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_690(iUDT_AixConfig := #iUDT_Configuration."690".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput690,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 1,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."690".MCO_M01,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput690,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_690,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."690".MCO_M01);
	            END_REGION
	        END_REGION
	        
	        REGION 530
	            
	            REGION Displacement
	                
	                #sFB_Displacement530(#sUDT_Interface_530);
	                
	            END_REGION
	            
	            REGION Tracking
	                
	                #sFB_Tracking_530(iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."530".Conveyor.Common,
	                                  iqa_TrackingData := #sa_TrackingArray_530,
	                                  iqUDT_ConveyorInterface := #sUDT_Interface_530,
	                                  iqUDT_HandshakeUp := #sUDT_Handshake_530,
	                                  iqUDT_Handshake := #sUDT_Handshake_530);
	            END_REGION
	            
	            REGION EOS
	                
	                #sFB_PECUpdate_530(iUDT_PECUpdateConfiguration := #iUDT_Configuration."530".PEC_Eos,
	                                   iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."530".Conveyor.Common,
	                                   ix_PEC := #iUDT_MotorInput530.AllSensorPortInputs.LeftSensor,
	                                   ix_TeachingMode := FALSE,
	                                   qUDT_Status => #iqUDT_WorkstationStatus."530".PEC_Eos,
	                                   qi_GINwrite => #ti_dummy,
	                                   qx_PECFiltered => #tx_dummy,
	                                   iqa_TrackingData := #sa_TrackingArray_530,
	                                   iqUDT_ConveyorInterface := #sUDT_Interface_530,
	                                   iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                                   iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                                   iqa_FifoData := "DB_FIFOLostGIN".Data,
	                                   iqUDT_Statistics := #iqUDT_WorkstationStatistics."530".PEC_Eos);
	                
	            END_REGION
	            
	            REGION Conveyor
	                #sUDT_Handshake_530.RTR := #sUDT_Handshake_530.RTR OR #iqUDT_WorkstationStatus."530".PEC_Eos.PEC;
	                
	                #sFB_Conveyor_530(iUDT_ConveyorConfiguration := #iUDT_Configuration."530".Conveyor,
	                                  idi_PECEoSDistance := #iUDT_Configuration."530".PEC_Eos.Distance,
	                                  idi_PECBoSDistance := 0,
	                                  ii_ExternalSpeed := 0,
	                                  ix_SafetyOk := #ix_SafetyOk,
	                                  ix_24vOk := #ix_24vOk,
	                                  ix_400vOk := #ix_400vOk,
	                                  ix_HardwareOk := #ix_HardwareOk,
	                                  ix_PECEoS := #iqUDT_WorkstationStatus."530".PEC_Eos.PEC,
	                                  ix_PECBoS := TRUE,
	                                  ix_ExternalRequestHold := #sx_Hold530,
	                                  qUDT_HMIStatus => #iqUDT_WorkstationStatus."530".Conveyor,
	                                  qUDT_Status => #iqUDT_WorkstationCommonStatus."530",
	                                  iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                  iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."530".Conveyor,
	                                  iqUDT_ConveyorInterface := #sUDT_Interface_530,
	                                  iqUDT_HandShakeUp := #sUDT_Handshake_530,
	                                  iqUDT_HandShake := #sUDT_Handshake_530,
	                                  iqUDT_Statistics := #iqUDT_WorkstationStatistics."530".Conveyor);
	            END_REGION
	            
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_530(iUDT_AixConfig := #iUDT_Configuration."530".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput530,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 1,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."530".MCO_M01,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput530,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_530,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."530".MCO_M01);
	            END_REGION
	        END_REGION
	        
	        REGION 540
	            
	            REGION Displacement
	                
	                #sFB_Displacement540(#sUDT_Interface_540);
	                
	            END_REGION
	            
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_540(iUDT_AixConfig := #iUDT_Configuration."540".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput540,
	                                                    ii_PositionSetpoint := #iqUDT_RATPositioning540.Lower.EndPosition,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 1,
	                                                    ix_StartPositioning := #iqUDT_RATPositioning540.Lower.Start,
	                                                    ix_ResetPosition := #iqUDT_RATPositioning540.Lower.ResetPosition,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."540".MCO_M01,
	                                                    qx_Positioned => #iqUDT_RATPositioning540.Lower.Done,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput540,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_540,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."540".MCO_M01);
	            END_REGION
	            
	        END_REGION
	        REGION 541
	            
	            REGION Displacement
	                
	                #sFB_Displacement541(#sUDT_Interface_541);
	                
	            END_REGION
	            
	            REGION RAT
	                
	                #sFB_RightAngledTransfer_541(iUDT_Configuration := #iUDT_Configuration."541".RightAngledTransfer,
	                                             iUDT_LowerConveyorConfiguration := #iUDT_Configuration."540".Conveyor,
	                                             iUDT_UpperConveyorConfiguration := #iUDT_Configuration."541".Conveyor,
	                                             iUDT_PECConfiguration := #iUDT_Configuration."540".PEC,
	                                             ii_DestinationA := #si_540DestinationA,
	                                             ii_DestinationB := #si_540DestinationB,
	                                             ii_DestinationC := #si_540DestinationC,
	                                             ii_DestinationD := #si_540DestinationD,
	                                             ix_HardwareOk := #ix_HardwareOk,
	                                             ix_400vOk := #ix_400vOk,
	                                             ix_24vOk := #ix_24vOk,
	                                             ix_SafetyOk := #ix_SafetyOk,
	                                             ix_AirPressureOk := #ix_AirPressureOk,
	                                             ix_SectionIsDown := #ix_SectionIsDown541,
	                                             ix_SectionIsUp := #ix_SectionIsUp541,
	                                             ix_ConveyorAAuto := #iqUDT_WorkstationCommonStatus."530".AutoON,
	                                             ix_ConveyorBAuto := #iqUDT_WorkstationCommonStatus."550".AutoON,
	                                             ix_ConveyorCAuto := #iqUDT_WorkstationCommonStatus."670".AutoON,
	                                             ix_ConveyorDAuto := FALSE,
	                                             ix_PEC := #iUDT_MotorInput540.AllSensorPortInputs.LeftSensor,
	                                             ix_ExternalReceiveRequestA := NOT #iqUDT_WorkstationStatus."530".PEC_Eos.PEC AND NOT #sx_TransferOut380 AND NOT #sx_TransferOut390,
	                                             ix_ExternalReceiveRequestB := false,
	                                             ix_ExternalReceiveRequestC := #sFB_RightAngledTransfer_671.qx_ExternalSendRequestC,
	                                             ix_ExternalReceiveRequestD := false,
	                                             ix_PECInfeedA := #iqUDT_WorkstationStatus."530".PEC_Eos.PEC,
	                                             ix_PECInfeedC := #iqUDT_WorkstationStatus."670".PEC_Eos.PEC,
	                                             qUDT_HMIRATStatus => #iqUDT_WorkstationStatus."541".RightAngledTransfer,
	                                             qUDT_HMIConveyorStatus => #iqUDT_WorkstationStatus."540".Conveyor,
	                                             qUDT_HMIPECStatus => #iqUDT_WorkstationStatus."540".PEC_Eos,
	                                             qUDT_RATStatus => #iqUDT_WorkstationCommonStatus."541",
	                                             qUDT_ConveyorStatus => #iqUDT_WorkstationCommonStatus."540",
	                                             qx_PopupControl => #qx_PopupControl541,
	                                             iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                             iqUDT_RATCommand := #iqUDT_WorkstationCommands."541".RightAngledTransfer,
	                                             iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."540".Conveyor,
	                                             iqUDT_RATStatistics := #iqUDT_WorkstationStatistics."541".RightAngledTransfer,
	                                             iqUDT_ConveyorStatistics := #iqUDT_WorkstationStatistics."540".Conveyor,
	                                             iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."540".PEC_Eos,
	                                             iqUDT_HandShakeConveyorA := #sUDT_Handshake_530,
	                                             iqUDT_HandShakeConveyorB := #sUDT_Handshake_540,
	                                             iqUDT_HandShakeConveyorC := #sUDT_HandshakeUp_671,
	                                             iqUDT_HandShakeConveyorD := #tUDT_dummyHandshake,
	                                             iqUDT_LowerConveyorInterface := #sUDT_Interface_540,
	                                             iqUDT_UpperConveyorInterface := #sUDT_Interface_541,
	                                             iqUDT_RATPositioning := #iqUDT_RATPositioning540,
	                                             iqUDT_BladeStopEoSInterface := #tUDT_DummyBladeStop,
	                                             iqUDT_BladeStopBoSInterface := #tUDT_DummyBladeStop);
	                
	            END_REGION
	            
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_541(iUDT_AixConfig := #iUDT_Configuration."541".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput540,
	                                                    ii_PositionSetpoint := #iqUDT_RATPositioning540.Upper.EndPosition,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 2,
	                                                    ix_StartPositioning := #iqUDT_RATPositioning540.Upper.Start,
	                                                    ix_ResetPosition := #iqUDT_RATPositioning540.Upper.ResetPosition,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."541".MCO_M01,
	                                                    qx_Positioned => #iqUDT_RATPositioning540.Upper.Done,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput540,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_541,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."541".MCO_M01);
	            END_REGION
	            
	        END_REGION
	        
	        REGION 550
	            
	            REGION Displacement
	                
	                #sFB_Displacement550(#sUDT_Interface_550);
	                
	            END_REGION
	            
	            REGION Tracking
	                
	                #sFB_Tracking_550(iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."550".Conveyor.Common,
	                                  iqa_TrackingData := #sa_TrackingArray_550,
	                                  iqUDT_ConveyorInterface := #sUDT_Interface_550,
	                                  iqUDT_HandshakeUp := #sUDT_Handshake_540,
	                                  iqUDT_Handshake := #sUDT_Handshake_550);
	            END_REGION
	            
	            REGION EOS
	                
	                #sFB_PECUpdate_550(iUDT_PECUpdateConfiguration := #iUDT_Configuration."550".PEC_EoS,
	                                   iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."550".Conveyor.Common,
	                                   ix_PEC := #iUDT_MotorInput550.AllSensorPortInputs.LeftSensor,
	                                   ix_TeachingMode := FALSE,
	                                   qUDT_Status => #iqUDT_WorkstationStatus."550".PEC_EoS,
	                                   qi_GINwrite => #ti_dummy,
	                                   qx_PECFiltered => #tx_dummy,
	                                   iqa_TrackingData := #sa_TrackingArray_550,
	                                   iqUDT_ConveyorInterface := #sUDT_Interface_550,
	                                   iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                                   iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                                   iqa_FifoData := "DB_FIFOLostGIN".Data,
	                                   iqUDT_Statistics := #iqUDT_WorkstationStatistics."550".PEC_EoS);
	                
	            END_REGION
	            
	            REGION Conveyor
	                #sFB_Conveyor_550(iUDT_ConveyorConfiguration := #iUDT_Configuration."550".Conveyor,
	                                  idi_PECEoSDistance := #iUDT_Configuration."550".PEC_EoS.Distance,
	                                  idi_PECBoSDistance := 0,
	                                  ii_ExternalSpeed := 0,
	                                  ix_SafetyOk := #ix_SafetyOk,
	                                  ix_24vOk := #ix_24vOk,
	                                  ix_400vOk := #ix_400vOk,
	                                  ix_HardwareOk := #ix_HardwareOk,
	                                  ix_PECEoS := #iqUDT_WorkstationStatus."550".PEC_EoS.PEC,
	                                  ix_PECBoS := TRUE,
	                                  ix_ExternalRequestHold := false,
	                                  qUDT_HMIStatus => #iqUDT_WorkstationStatus."550".Conveyor,
	                                  qUDT_Status => #iqUDT_WorkstationCommonStatus."550",
	                                  iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                  iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."550".Conveyor,
	                                  iqUDT_ConveyorInterface := #sUDT_Interface_550,
	                                  iqUDT_HandShakeUp := #sUDT_Handshake_540,
	                                  iqUDT_HandShake := #sUDT_Handshake_550,
	                                  iqUDT_Statistics := #iqUDT_WorkstationStatistics."550".Conveyor);
	            END_REGION
	            
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_550(iUDT_AixConfig := #iUDT_Configuration."550".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput550,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 1,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."550".MCO_M01,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput550,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_550,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."550".MCO_M01);
	            END_REGION
	        END_REGION
	        
	        REGION 560
	            
	            
	            REGION Displacement
	                
	                #sFB_Displacement560(#sUDT_Interface_560);
	                
	            END_REGION
	            
	            REGION Conveyor
	                #sFB_Conveyor_560(iUDT_ConveyorConfiguration := #iUDT_Configuration."560".Conveyor,
	                                  idi_PECEoSDistance := 0,
	                                  idi_PECBoSDistance := 0,
	                                  ii_ExternalSpeed := 0,
	                                  ix_SafetyOk := #ix_SafetyOk,
	                                  ix_24vOk := #ix_24vOk,
	                                  ix_400vOk := #ix_400vOk,
	                                  ix_HardwareOk := #ix_HardwareOk,
	                                  ix_PECEoS := TRUE,
	                                  ix_PECBoS := TRUE,
	                                  ix_ExternalRequestHold := false,
	                                  qUDT_HMIStatus => #iqUDT_WorkstationStatus."560".Conveyor,
	                                  qUDT_Status => #iqUDT_WorkstationCommonStatus."560",
	                                  iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                  iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."560".Conveyor,
	                                  iqUDT_ConveyorInterface := #sUDT_Interface_560,
	                                  iqUDT_HandShakeUp := #sUDT_Handshake_550,
	                                  iqUDT_HandShake := #sUDT_Handshake_560,
	                                  iqUDT_Statistics := #iqUDT_WorkstationStatistics."560".Conveyor);
	            END_REGION
	            
	            REGION VFD
	                
	                #sFB_VfdNORDPPO4_560(iUDT_VFDConfig := #iUDT_Configuration."560".VFD,
	                                     iUDT_VFDInputs := #iUDT_MotorInput560,
	                                     iUDT_MotorData := #iUDT_MotorData560,
	                                     ix_24vOk := #ix_24vOk,
	                                     ix_400vOk := #ix_400vOk,
	                                     ix_QuickStopDisable := TRUE,
	                                     ix_SimulationModeActive := "DB_Memory".Simulation,
	                                     qUDT_HMIStatus => #iqUDT_WorkstationStatus."560".VFD,
	                                     qUDT_VFDOutputs => #qUDT_MotorOutput560,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface_560,
	                                     iqUDT_VFDStatistics := #iqUDT_WorkstationStatistics."560".VFD,
	                                     iqx_StartCommissioning := #iqx_StartComissioning560);
	                
	            END_REGION
	            
	        END_REGION
	        
	        REGION 570
	            
	            REGION Displacement
	                
	                #sFB_Displacement570(#sUDT_Interface_570);
	                
	            END_REGION
	            
	            REGION EoS               
	                
	                #sFB_PEC_570(ix_PEC := #iUDT_MotorInput570.AllSensorPortInputs.LeftSensor,
	                             iUDT_PECConfiguration := #iUDT_Configuration."570".PEC_EoS,
	                             qUDT_HMIStatus => #iqUDT_WorkstationStatus."570".PEC_EoS,
	                             iqUDT_ConveyorInterface := #sUDT_Interface_570,
	                             iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."570".PEC_EoS);
	                
	            END_REGION
	            
	            REGION Conveyor
	                #sFB_Conveyor_570(iUDT_ConveyorConfiguration := #iUDT_Configuration."570".Conveyor,
	                                  idi_PECEoSDistance := #iUDT_Configuration."570".PEC_EoS.Distance,
	                                  idi_PECBoSDistance := 0,
	                                  ii_ExternalSpeed := 0,
	                                  ix_SafetyOk := #ix_SafetyOk,
	                                  ix_24vOk := #ix_24vOk,
	                                  ix_400vOk := #ix_400vOk,
	                                  ix_HardwareOk := #ix_HardwareOk,
	                                  ix_PECEoS := #iqUDT_WorkstationStatus."570".PEC_EoS.PEC,
	                                  ix_PECBoS := TRUE,
	                                  ix_ExternalRequestHold := false,
	                                  qUDT_HMIStatus => #iqUDT_WorkstationStatus."570".Conveyor,
	                                  qUDT_Status => #iqUDT_WorkstationCommonStatus."570",
	                                  iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                  iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."570".Conveyor,
	                                  iqUDT_ConveyorInterface := #sUDT_Interface_570,
	                                  iqUDT_HandShakeUp := #sUDT_Handshake_560,
	                                  iqUDT_HandShake := #sUDT_Handshake_570,
	                                  iqUDT_Statistics := #iqUDT_WorkstationStatistics."570".Conveyor);
	            END_REGION
	            
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_570(iUDT_AixConfig := #iUDT_Configuration."570".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput570,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 1,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."570".MCO_M01,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput570,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_570,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."570".MCO_M01);
	            END_REGION
	        END_REGION
	        
	        REGION 580
	            
	            REGION Displacement
	                
	                #sFB_Displacement580(#sUDT_Interface_580);
	                
	            END_REGION
	            
	            REGION EoS               
	                
	                #sFB_PEC_580(ix_PEC := #iUDT_MotorInput570.AllSensorPortInputs.RightSensor,
	                             iUDT_PECConfiguration := #iUDT_Configuration."580".PEC_EoS,
	                             qUDT_HMIStatus => #iqUDT_WorkstationStatus."580".PEC_EoS,
	                             iqUDT_ConveyorInterface := #sUDT_Interface_580,
	                             iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."580".PEC_EoS);
	                
	            END_REGION
	            
	            REGION Conveyor
	                #iqUDT_HandshakeDownstream580.RTR := #iqUDT_HandshakeDownstream580.RTR OR #iqUDT_WorkstationStatus."580".PEC_EoS.PEC;
	                #sFB_Conveyor_580(iUDT_ConveyorConfiguration := #iUDT_Configuration."580".Conveyor,
	                                  idi_PECEoSDistance := #iUDT_Configuration."580".PEC_EoS.Distance,
	                                  idi_PECBoSDistance := 0,
	                                  ii_ExternalSpeed := 0,
	                                  ix_SafetyOk := #ix_SafetyOk,
	                                  ix_24vOk := #ix_24vOk,
	                                  ix_400vOk := #ix_400vOk,
	                                  ix_HardwareOk := #ix_HardwareOk,
	                                  ix_PECEoS := #iqUDT_WorkstationStatus."580".PEC_EoS.PEC,
	                                  ix_PECBoS := TRUE,
	                                  ix_ExternalRequestHold := false,
	                                  qUDT_HMIStatus => #iqUDT_WorkstationStatus."580".Conveyor,
	                                  qUDT_Status => #iqUDT_WorkstationCommonStatus."580",
	                                  iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                  iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."580".Conveyor,
	                                  iqUDT_ConveyorInterface := #sUDT_Interface_580,
	                                  iqUDT_HandShakeUp := #sUDT_Handshake_570,
	                                  iqUDT_HandShake := #iqUDT_HandshakeDownstream580,
	                                  iqUDT_Statistics := #iqUDT_WorkstationStatistics."580".Conveyor);
	            END_REGION
	            REGION MCO
	                #sFB_MCOConveyLinxAixController_580(iUDT_AixConfig := #iUDT_Configuration."580".MCO_M01,
	                                                    iUDT_AixInputsModule := #iUDT_MotorInput570,
	                                                    ix_24vOk := #ix_24vOk,
	                                                    ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                    ii_MotorPositionId := 2,
	                                                    qUDT_HMIStatus => #iqUDT_WorkstationStatus."580".MCO_M01,
	                                                    iqUDT_AixOutputsModule := #qUDT_MotorOutput570,
	                                                    iqUDT_ConveyorInterface := #sUDT_Interface_580,
	                                                    iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."580".MCO_M01);
	            END_REGION
	        END_REGION
	    END_REGION
	END_IF;
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_NerakLift"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 250
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_Configuration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_NerakLiftConfiguration";   // Configuration structure
      idi_PECEoSDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // PEC distance from the end of lift
      ix_SafetyOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when safety is ok
      ix_24VOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 24V supply is ok
      ix_400VOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 400V supply is ok
      ix_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when hardware is ok
      iudt_IOIn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_NerakLiftPI";   // Structure of inputs from IO Panel
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_NerakLiftStatus";   // HMI status structure
      qudt_IOOut { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_NerakLiftPO";   // Structure of outputs from IO Panel
      qx_Fault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Fault active
      qx_Ready { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Machine ready
      qx_ExternalDieback { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send external dieback to downstream conveyor
   END_VAR

   VAR_IN_OUT 
      iqUDT_CommonStatus : "UDT_CommonStatus";   // Common status structure
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
      iqUDT_HandshakeUp : "UDT_ConveyorHandshake";   // Upstream handshake structure
      iqUDT_Handshake : "UDT_ConveyorHandshake";   // Downstream handshake structure
      iqUDT_Interface : "UDT_ConveyorInterface";   // Interface structure
      iqUDT_ConveyorCommand : "UDT_ConveyorCommand";   // HMI commands structure
      iqUDT_Statistics : "UDT_NerakLiftStatistics";   // Statistics structure
   END_VAR

   VAR 
      sUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_NerakLiftStatus";   // HMI status structure
      sUDT_ConveyorConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorConfiguration" := (((), 0), (), (), (), 0, 200, (), (), FALSE);   // Conveyor configuration structure
      sFB_ConveyorControl { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Conveyor instance
      sFB_TimerOnOffDelay_B2Treshold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // B2 on off delay
      sFB_TimerOnOffDelay_B3Treshold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // B3 on off delay
      sFB_TimerOnOffDelay_B4Treshold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // B4 on off delay
      sFB_TimerOnOffDelay_B5Treshold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // B5 on off delay
      sFB_TimerOnOffDelay_B10Treshold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // B10 on off delay
      sFB_TimerOnOffDelay_B11Treshold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // B11 on off delay
      sR_TRIG_ProductFellDown {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // R_TRIG Product fell down for statistics
      sR_TRIG_CollisionDetected {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // R_TRIG collision detected for statistics
      sx_B2Filtered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // B2 sensor filtered
      sx_B3Filtered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Cumulative B3 sensors filtered
      sx_B4Filtered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // B4 sensor filtered
      sx_B5Filtered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // B5 sensor filtered
      sx_B10Filtered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // B10 sensor filtered
      sx_B11Filtered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // B11 sensor filtered
   END_VAR

   VAR_TEMP 
      tUDT_Statistics : "UDT_ConveyorStatistics";   // Temporary conveyor statistics structure
      tUDT_ConveyorHMIStatus : "UDT_ConveyorStatus";   // Temporary conveyor status structure
      tx_ExternalDieback : Bool;   // Upstream dieback control
      tx_Hold : Bool;   // Hold bit
      tx_GlobalResetMemory : Bool;   // Memory for global reset
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	20/02/2024  | 1.0       | K.Pokorski    | First release TIA 17         
	28/03/2024  | 1.1       | K. Pokorski   | Modifications after lift test
	16/08/2024  | 2.0       | J.Majer       | Block Interface IO changed to UDT type
	*)
	
	REGION 1 - Edge detection 
	    
	    #sR_TRIG_ProductFellDown(CLK := #sUDT_HMIStatus.Specific.ProductFellDown);
	    
	    #sR_TRIG_CollisionDetected(CLK := #sUDT_HMIStatus.Specific.CollisionDetected);
	    
	END_REGION
	
	REGION 2 - Filtering
	    
	    #sFB_TimerOnOffDelay_B2Treshold(iudi_OnDelayTime := #iUDT_Configuration.CollisionSensorDelayOn,
	                                    iudi_OffDelayTime := #iUDT_Configuration.CollisionSensorDelayOff,
	                                    ix_SignalToDelay := #iudt_IOIn.ix_B2_CollisionControl,
	                                    qx_DelayedSignal => #sx_B2Filtered);
	    
	    #sFB_TimerOnOffDelay_B3Treshold(iudi_OnDelayTime := #iUDT_Configuration.FallingThroughSensorDelayOn,
	                                    iudi_OffDelayTime := #iUDT_Configuration.FallingThroughSensorDelayOff,
	                                    ix_SignalToDelay := #iudt_IOIn."ix_B3.1FallingThrought" AND #iudt_IOIn."ix_B3.2FallingThrought" AND #iudt_IOIn."ix_B3.3FallingThrought",
	                                    qx_DelayedSignal => #sx_B3Filtered);
	    
	    #sFB_TimerOnOffDelay_B4Treshold(iudi_OnDelayTime := #iUDT_Configuration.TailbackControlFrontSensorDelayOn,
	                                    iudi_OffDelayTime := #iUDT_Configuration.TailbackControlFrontSensorDelayOff,
	                                    ix_SignalToDelay := #iudt_IOIn.ix_B4TailbackControlFront,
	                                    qx_DelayedSignal => #sx_B4Filtered);
	    
	    #sFB_TimerOnOffDelay_B5Treshold(iudi_OnDelayTime := #iUDT_Configuration.TailbackControlRearSensorDelayOn,
	                                    iudi_OffDelayTime := #iUDT_Configuration.TailbackControlRearSensorDelayOff,
	                                    ix_SignalToDelay := #iudt_IOIn.ix_B5TailbackControlBack,
	                                    qx_DelayedSignal => #sx_B5Filtered);
	    
	    #sFB_TimerOnOffDelay_B10Treshold(iudi_OnDelayTime := #iUDT_Configuration.PlatformPositionSensorDelayOn,
	                                     iudi_OffDelayTime := #iUDT_Configuration.PlatformPositionSensorDelayOff,
	                                     ix_SignalToDelay := #iudt_IOIn.ix_B10_PlatforninPosition,
	                                     qx_DelayedSignal => #sx_B10Filtered);
	    
	    #sFB_TimerOnOffDelay_B11Treshold(iudi_OnDelayTime := #iUDT_Configuration.CollisionSensorDelayOn,
	                                     iudi_OffDelayTime := #iUDT_Configuration.CollisionSensorDelayOff,
	                                     ix_SignalToDelay := #iudt_IOIn.ix_B11ColisionControl,
	                                     qx_DelayedSignal => #sx_B11Filtered);
	    
	END_REGION
	
	REGION 3 - Errors
	    
	    IF #iqUDT_EquipmentControl.Command.Reset OR #iudt_IOIn.ix_FaultReset
	    THEN
	        #sUDT_HMIStatus.Specific.CollisionDetected := FALSE;
	        #sUDT_HMIStatus.Specific.ProductFellDown := FALSE;
	    END_IF;
	    
	    IF NOT #sx_B2Filtered AND #sx_B11Filtered AND #iUDT_Configuration.Mode = 1
	        OR NOT #sx_B2Filtered AND #iUDT_Configuration.Mode = 2
	    THEN
	        #sUDT_HMIStatus.Specific.CollisionDetected := TRUE;
	    END_IF;
	    
	    IF NOT #sx_B3Filtered
	    THEN
	        #sUDT_HMIStatus.Specific.ProductFellDown := TRUE;
	    END_IF;
	    
	    IF #sUDT_HMIStatus.Specific.CollisionDetected
	        OR #sUDT_HMIStatus.Specific.ProductFellDown THEN
	        #iqUDT_Interface.InternalErrorPEC := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Conveyor control
	    
	    REGION 4.1 - Conveyor configuration
	        
	        #sUDT_ConveyorConfiguration.Common.Length := #iUDT_Configuration.Length;
	        #sUDT_ConveyorConfiguration.Forward_Direction.EnergySaveLenght := #iUDT_Configuration.EnergySaveLength;
	        #sUDT_ConveyorConfiguration.Forward_Direction.PEC_EoSDistanceOffset := #iUDT_Configuration.PEC_EoSDistanceOffset;
	        #sUDT_ConveyorConfiguration.Forward_Direction.FirstConveyorToStart := #iUDT_Configuration.FirstConveyorToStart;
	        #sUDT_ConveyorConfiguration.CascadeTimeOnDelay := #iUDT_Configuration.CascadeTimeOnDelay;
	        #sUDT_ConveyorConfiguration.SpeedSetpointNominal := #iUDT_Configuration.SpeedSetpointNominal;
	        #sUDT_ConveyorConfiguration.Energy := #iUDT_Configuration.Energy;
	        
	    END_REGION
	    
	    REGION 4.2 - Tailback control
	        
	        #tx_Hold := NOT #sx_B4Filtered AND NOT #sx_B5Filtered;
	        
	    END_REGION
	    
	    REGION 4.3 - Conveyor block call
	        
	        #tx_GlobalResetMemory := #iqUDT_EquipmentControl.Command.Reset;
	        #iqUDT_EquipmentControl.Command.Reset := #iqUDT_EquipmentControl.Command.Reset OR #iudt_IOIn.ix_FaultReset;
	        
	        #iqUDT_ConveyorCommand.ManualMode := #iudt_IOIn.ix_ManualMode;
	        #iqUDT_ConveyorCommand.ManualStartStop := FALSE;
	        #iqUDT_ConveyorCommand.ManualJog := #iudt_IOIn.ix_ManualUp OR #iudt_IOIn.ix_ManualDown;
	        
	        #iqUDT_ConveyorCommand.Reverse :=
	        (#iUDT_Configuration.Mode = 1 AND #iudt_IOIn.ix_ManualUp)
	        OR (#iUDT_Configuration.Mode = 2 AND #iudt_IOIn.ix_ManualDown);
	        
	        #sFB_ConveyorControl(iUDT_ConveyorConfiguration := #sUDT_ConveyorConfiguration,
	                             idi_PECEoSDistance := #idi_PECEoSDistance,
	                             idi_PECBoSDistance := 0,
	                             ii_ExternalSpeed := 0,
	                             ix_SafetyOk := #ix_SafetyOK,
	                             ix_24vOk := #ix_24VOk,
	                             ix_400vOk := #ix_400VOk,
	                             ix_HardwareOk := #ix_HardwareOk,
	                             ix_PECEoS := #sx_B5Filtered,
	                             ix_PECBoS := TRUE,
	                             ix_ReverseDirection := FALSE,
	                             ix_ExternalRequestDieBack := FALSE,
	                             ix_ExternalRequestHold := #tx_Hold,
	                             ix_ResetEnergySave := FALSE,
	                             qUDT_HMIStatus => #tUDT_ConveyorHMIStatus,
	                             qUDT_Status => #iqUDT_CommonStatus,
	                             iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                             iqUDT_ConveyorCommand := #iqUDT_ConveyorCommand,
	                             iqUDT_ConveyorInterface := #iqUDT_Interface,
	                             iqUDT_HandShakeUp := #iqUDT_HandshakeUp,
	                             iqUDT_HandShake := #iqUDT_Handshake,
	                             iqUDT_Statistics := #tUDT_Statistics);
	        
	        IF #iqUDT_CommonStatus.ManualRun
	            AND #iqUDT_Interface.SpeedSetpoint > 200
	        THEN
	            #iqUDT_Interface.SpeedSetpoint := 200;
	        END_IF;
	        
	        #iqUDT_EquipmentControl.Command.Reset := #tx_GlobalResetMemory;
	        #tx_ExternalDieback := TRUE;
	        IF #sx_B10Filtered THEN
	            #tx_ExternalDieback := false;
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 5 - Status
	    
	    #sUDT_HMIStatus.Status := #tUDT_ConveyorHMIStatus.Status;
	    #qUDT_HMIStatus := #sUDT_HMIStatus;
	    
	END_REGION
	
	REGION 6 - Statistics
	    
	    REGION 6.1 - Conveyor statistics mapping
	        
	        #iqUDT_Statistics.EnergySave := #tUDT_Statistics.EnergySave;
	        #iqUDT_Statistics.ConveyorStop := #tUDT_Statistics.ConveyorStop;
	        #iqUDT_Statistics.ConveyorDown := #tUDT_Statistics.ConveyorDown;
	        #iqUDT_Statistics.ConveyorUp := #tUDT_Statistics.ConveyorUp;
	        
	    END_REGION
	    
	    REGION 6.2 - Collision detected time
	        
	        IF #sUDT_HMIStatus.Specific.CollisionDetected OR #iqUDT_EquipmentControl.Command.ResetData  // Reset statistics
	        THEN
	            
	            "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,          // Reset statistics input
	                            ix_Activate := #sUDT_HMIStatus.Specific.CollisionDetected,         // Activate statistics functions input
	                            ix_RTrigActivate := #sR_TRIG_CollisionDetected.Q,                       // Statistics active trigger
	                            iqUDT_Statistics := #iqUDT_Statistics.CollisionDetected);               // Statistics values output
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 6.3 - Collision detected time
	        
	        IF #sUDT_HMIStatus.Specific.ProductFellDown OR #iqUDT_EquipmentControl.Command.ResetData  // Reset statistics
	        THEN
	            
	            "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,          // Reset statistics input
	                            ix_Activate := #sUDT_HMIStatus.Specific.ProductFellDown,         // Activate statistics functions input
	                            ix_RTrigActivate := #sR_TRIG_ProductFellDown.Q,                       // Statistics active trigger
	                            iqUDT_Statistics := #iqUDT_Statistics.ProductFellDown);               // Statistics values output
	            
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 7 - Outputs
	    
	    #qx_Fault := #iqUDT_CommonStatus.Error;
	    #qx_Ready := NOT #iqUDT_CommonStatus.Error;
	    #qx_ExternalDieback := #tx_ExternalDieback;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_TGWLift"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 272
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_TGWLiftConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_TGWLiftConfiguration";   // Lift configuration structure
      iUDT_010MotorInput { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdSEWSpeedPI";   // 010 SEW inputs structure
      iUDT_020MotorInput { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdSEWPositioningPI";   // 020 SEW Positioning structure
      is_ET200spPNDeviceName { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Name of ET200
      ix_010EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // End of the section - Lift conveyor
      ix_010BoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Begining of the section - Lift conveyor
      ix_010PECMiddle { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Middle of the section - Lift conveyor
      ix_010PECGapBegin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Gap Check Beginning
      ix_010PECGapEnd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Gap Check End
      iUDT_LiftPI { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_TGWLiftPI";   // Reading inputs from the input card
      ix_24vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 24VDC is healthy
      ix_400vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 400VAC is healthy
      ix_SafetyOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when safety is ok
      ix_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when hardware is ok
      ix_MaintSupport1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Lift supporting maintenance platform 1 retracted
      ix_MaintSupport2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Lift supporting maintenance platform 2 retracted
      ix_KeySwitchStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Key switch stop
      ix_LimitSwitchUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Limit switch up
      ix_LimitSwitchDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Limit switch down
   END_VAR

   VAR_OUTPUT 
      qUDT_010MotorOutput { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdSEWSpeedPO";   // 010 SEW outputs structure
      qUDT_020MotorOutput { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdSEWPositioningPO";   // 020 SEW positioning outputs structure
      qUDT_LiftPO { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_TGWLiftPO";   // writing outputs to the output card
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
      iqUDT_TGWLiftHMICommands : "UDT_TGWLiftHmiCommands";   // HMI commands structure for lift
      iqUDT_TGWLiftCommonStatus : "UDT_TGWLiftCommonStatus";   // Common status structure for 010 conveyor
      iqUDT_TGWLiftStatus : "UDT_TGWLiftStatus";   // Status TGW Lift structure
      iqUDT_TGWLiftStatistics : "UDT_TGWLiftStatistics";   // Statistics TGW Lift structure
      iqUDT_InfeedFullDownHMICommands : "UDT_ConveyorCommand";   // HMI commands structure for lower infeed conveyor
      iqUDT_OutfeedEmptyDownHMICommands : "UDT_ConveyorCommand";   // HMI commands structure for lower outfeed conveyor
      iqUDT_InfeedEmptyUpHMICommands : "UDT_ConveyorCommand";   // HMI commands structure for upper infeed conveyor
      iqUDT_OutfeedFullUpHMICommands : "UDT_ConveyorCommand";   // HMI commands structure for upper outfeed conveyor
      iqUDT_InfeedFullDownCommonStatus : "UDT_CommonStatus";   // Common status structure for full infeed conveyor
      iqUDT_OutfeedEmptyDownCommonStatus : "UDT_CommonStatus";   // Common status structure for empty outfeed conveyor
      iqUDT_InfeedEmptyUpCommonStatus : "UDT_CommonStatus";   // Common status structure for empty infeed
      iqUDT_OutfeedFullupCommonStatus : "UDT_CommonStatus";   // Common status structure for full outfeed conveyor
      iqUDT_InfeedFullDownHandShake : "UDT_ConveyorHandshake";   // Handshake structure for full infeed conveyor
      iqUDT_OutfeedEmptyDownHandShake : "UDT_ConveyorHandshake";   // Handshake structure for empty outfeed conveyor
      iqUDT_InfeedEmptyUpHandShake : "UDT_ConveyorHandshake";   // Handshake structure for empty infeed conveyor
      iqUDT_OutfeedFullUpHandShake : "UDT_ConveyorHandshake";   // Handshake structure for full outfeed conveyor
      iqUDT_OutfeedEmptyDownHandshakeUpstream : "UDT_ConveyorHandshake";   // HandshakeUp structure for empty outfeed conveyor
      iqUDT_OutfeedFullUpHandshakeUpstream : "UDT_ConveyorHandshake";   // HandshakeUp structure for full outfeed conveyor
   END_VAR

   VAR 
      sUDT_020VSUInterface { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VSUInterface";   // Interface structure for lift 020
      sUDT_010ConveyorInterface { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for conveyor 010
      sFB_010Displacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 010 conveyor
      sFB_010PECEoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye EoS handling for 010 conveyor
      sFB_010PECBoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye BoS handling for 010 conveyor
      sFB_LiftManualControl { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_LiftManualControl";   // Function block to control lift, infeeds and outfeeds manually
      sFB_010Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 010 conveyor
      sFB_010VfdSEWMOVICSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_VfdSEWMOVI-CSpeed";   // Function to interface with SEW-MoviCSpeed for  010
      sFB_020VfdSEWMOVICPositioning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_VfdSEWMOVI-CPositioning";   // Function to interface with SEW-MoviCPositioning for  020
      sFB_020RIOVSU { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_RIOVSU";   // Function block of RIO VSU
      sFB_020Lift { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Lift";   // Function block for lift control
      sFB_020VSULift { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_VSULift";   // Funcion block of VSU Lift
      sUDT_010HandshakeUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // HandshakeUp structure for 010
      sUDT_010Handshake { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 010
   END_VAR

   VAR_TEMP 
      tx_LiftConveyorDirection : Bool;   // Direction of lift conveyor
   END_VAR

   VAR CONSTANT 
      ci_LiftUp : Int := 2;   // Constant for indicating Lift up position
      ci_LiftDown : Int := 1;   // Constant for indicating Lift down position
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	06/08/2024  | 1.0       | R. Pieczonka  | Initial version
	12/08/2024  | 1.1       | R. Pieczonka  | Changing the block interface from struct to UDT types
	            |           | J.Majer       | Changing input & Outputs to UDT type
	*)
	
	
	REGION LFTxx-010
	    // Autostore picking station lift conveyor
	    // Function variant: TV11
	    
	    REGION Displacement
	        #sFB_010Displacement(#sUDT_010ConveyorInterface);
	        
	    END_REGION
	    
	    REGION EOS
	        #sFB_010PECEoS(ix_PEC := #ix_010EoS,
	                       iUDT_PECConfiguration := #iUDT_TGWLiftConfiguration."010".PEC_EoS,
	                       qUDT_HMIStatus => #iqUDT_TGWLiftStatus."010".PEC_EoS,
	                       iqUDT_ConveyorInterface := #sUDT_010ConveyorInterface,
	                       iqUDT_PECStatistics := #iqUDT_TGWLiftStatistics."010".PEC_EoS);
	        
	    END_REGION
	    
	    REGION BOS
	        #sFB_010PECBoS(ix_PEC := #ix_010BoS,
	                       iUDT_PECConfiguration := #iUDT_TGWLiftConfiguration."010".PEC_BoS,
	                       qUDT_HMIStatus => #iqUDT_TGWLiftStatus."010".PEC_BoS,
	                       iqUDT_ConveyorInterface := #sUDT_010ConveyorInterface,
	                       iqUDT_PECStatistics := #iqUDT_TGWLiftStatistics."010".PEC_BoS);
	        
	    END_REGION
	    
	    REGION Manual Control
	        #sFB_LiftManualControl(ix_ManualMode := #iUDT_LiftPI.ix_ManualMode,                                     // Manual mode
	                               ix_AutoMode := #iUDT_LiftPI.ix_AutoMode,                                         // Auto mode
	                               ix_UpPosition := #sUDT_020VSUInterface.PositionActual = #ci_LiftUp,
	                               ix_DownPosition := #sUDT_020VSUInterface.PositionActual = #ci_LiftDown,
	                               ix_LiftConveyorRight := #iUDT_LiftPI.ix_LiftConveyorFwd,
	                               ix_LiftConveyorLeft := #iUDT_LiftPI.ix_LiftConveyorRvs,
	                               ix_InfeedConveyor := #iUDT_LiftPI.ix_InfeedConveyor,
	                               ix_OutfeedConveyor := #iUDT_LiftPI.ix_OutfeedConveyor,
	                               iqUDT_LiftConveyorCommand := #iqUDT_TGWLiftHMICommands."010".Conveyor,
	                               iqUDT_LowerInfeedConveyorCommand := #iqUDT_InfeedFullDownHMICommands,
	                               iqUDT_LowerOutfeedConveyorCommand := #iqUDT_OutfeedEmptyDownHMICommands,
	                               iqUDT_UpperInfeedConveyorCommand := #iqUDT_InfeedEmptyUpHMICommands,
	                               iqUDT_UpperOutfeedConveyorCommand := #iqUDT_OutfeedFullUpHMICommands);
	        
	    END_REGION
	    
	    REGION Conveyor
	        
	        
	        #sFB_010Conveyor(iUDT_ConveyorConfiguration := #iUDT_TGWLiftConfiguration."010".Conveyor,
	                         idi_PECEoSDistance := #iUDT_TGWLiftConfiguration."010".PEC_EoS.Distance,
	                         idi_PECBoSDistance := #iUDT_TGWLiftConfiguration."010".PEC_BoS.Distance,
	                         ii_ExternalSpeed := 0,
	                         ix_SafetyOk := #ix_SafetyOk,
	                         ix_24vOk := #ix_24vOk AND #iUDT_LiftPI.ix_F1400ok,
	                         ix_400vOk := #ix_400vOk AND #iUDT_LiftPI.ix_F1002ok,
	                         ix_HardwareOk := #ix_HardwareOk,
	                         ix_PECEoS := #iqUDT_TGWLiftStatus."010".PEC_EoS.PEC,
	                         ix_PECBoS := #iqUDT_TGWLiftStatus."010".PEC_BoS.PEC,
	                         ix_ReverseDirection := #sFB_020Lift.qx_LiftConveyorDirection,
	                         ix_ExternalRequestHold := NOT (#sUDT_020VSUInterface.PositionActual = #ci_LiftUp OR #sUDT_020VSUInterface.PositionActual = #ci_LiftDown),
	                         qUDT_HMIStatus => #iqUDT_TGWLiftStatus."010".Conveyor,
	                         qUDT_Status => #iqUDT_TGWLiftCommonStatus."010",
	                         iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                         iqUDT_ConveyorCommand := #iqUDT_TGWLiftHMICommands."010".Conveyor,
	                         iqUDT_ConveyorInterface := #sUDT_010ConveyorInterface,
	                         iqUDT_HandShakeUp := #sUDT_010HandshakeUp,
	                         iqUDT_HandShake := #sUDT_010Handshake,
	                         iqUDT_Statistics := #iqUDT_TGWLiftStatistics."010".Conveyor);
	        
	        
	        
	    END_REGION
	    
	    REGION VFD
	        
	        #"sFB_010VfdSEWMOVICSpeed"(iUDT_VfdConfig := #iUDT_TGWLiftConfiguration."010".VFD,
	                                   iUDT_VfdInputs := #iUDT_010MotorInput,
	                                   ix_PowerOK := TRUE,
	                                   ix_SimulationModeActive := FALSE,
	                                   ix_QuickStopDisable := TRUE,
	                                   qUDT_HMIStatus => #iqUDT_TGWLiftStatus."010".VFD,
	                                   qUDT_VfdOutputs => #qUDT_010MotorOutput,
	                                   iqUDT_ConveyorInterface := #sUDT_010ConveyorInterface,
	                                   iqUDT_VfdStatistics := #iqUDT_TGWLiftStatistics."010".VFD);
	        
	    END_REGION
	    
	END_REGION
	
	REGION LFTxx-020
	    // Autostore picking station lift positioning
	    // Function variant: VL11
	    
	    REGION VSU RIO
	        #sFB_020RIOVSU(is_ET200spPNDeviceName := #is_ET200spPNDeviceName,
	                       ix_400VintOk := #ix_400vOk AND #iUDT_LiftPI.ix_F1002ok,
	                       ix_400VextOk := #iUDT_LiftPI.ix_MainSwitchCabinetOn AND #ix_400vOk AND #iUDT_LiftPI.ix_F1002ok,
	                       ix_BrakeSupplyOk := #ix_400vOk AND #iUDT_LiftPI.ix_F1002ok,
	                       ix_ThermalBrake := #iUDT_LiftPI.ix_OverTempBrakeRes,
	                       ix_24VOk := #ix_24vOk AND #iUDT_LiftPI.ix_F1400ok,
	                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                       ix_HardwareOk := #ix_HardwareOk,
	                       qUDT_HMIStatus => #iqUDT_TGWLiftStatus."020".VSU_RIO,
	                       iqUDT_Statistics := #iqUDT_TGWLiftStatistics."020".VSU_RIO,
	                       iqUDT_VSUInterface := #sUDT_020VSUInterface);
	        
	    END_REGION
	    
	    REGION Lift control
	        
	        // add BoS and EoS PEC to this block
	        
	        #sFB_020Lift(iUDT_LiftConveyorInterface := #sUDT_010ConveyorInterface,
	                     iUDT_VSUInterface := #sUDT_020VSUInterface,
	                     ix_SectionIsDown := #sUDT_020VSUInterface.PositionActual = #ci_LiftDown,
	                     ix_SectionIsUp := #sUDT_020VSUInterface.PositionActual = #ci_LiftUp,
	                     ix_PECLift := #ix_010PECMiddle,
	                     ix_ConveyorEmptyInAuto := #iqUDT_InfeedEmptyUpCommonStatus.AutoON,             // Infeed UP
	                     ix_ConveyorEmptyOutAuto := #iqUDT_OutfeedEmptyDownCommonStatus.AutoON,             // Outfeed Down
	                     ix_ConveyorFullInAuto := #iqUDT_InfeedFullDownCommonStatus.AutoON,             // Infeed DOWN
	                     ix_ConveyorFullOutAuto := #iqUDT_OutfeedFullupCommonStatus.AutoON,             // Outfeed UP
	                     qi_RequestedPosition => #sUDT_020VSUInterface.RequestedPosition,
	                     qx_TransportIdle => #sFB_020Lift.qx_TransportIdle,
	                     qx_LiftConveyorDirection => #tx_LiftConveyorDirection,
	                     iqUDT_LiftConveyorHandShakeUpstream := #sUDT_010HandshakeUp,
	                     iqUDT_LiftConveyorHandShake := #sUDT_010Handshake,
	                     iqUDT_InfeedEmptyUpHandShake := #iqUDT_InfeedEmptyUpHandShake,
	                     iqUDT_OutfeedEmptyDownHandShake := #iqUDT_OutfeedEmptyDownHandShake,
	                     iqUDT_InfeedFullDownHandShake := #iqUDT_InfeedFullDownHandShake,
	                     iqUDT_OutfeedFullUpHandShake := #iqUDT_OutfeedFullUpHandShake,
	                     iqUDT_OutfeedFullUpHandshakeUpstream := #iqUDT_OutfeedFullUpHandshakeUpstream,
	                     iqUDT_OutfeedEmptyDownHandshakeUpstream := #iqUDT_OutfeedEmptyDownHandshakeUpstream);
	        
	    END_REGION
	    
	    REGION VSU
	        
	        // add the EoS and BoS to the lift Status, remove from conveyor. Lift block will check the PEC and control the conveyor accordingly
	        
	        #sFB_020VSULift(iUDT_VSUConfig := #iUDT_TGWLiftConfiguration."020".VSU,
	                        ix_SafetyOk := #ix_SafetyOk,
	                        ix_BeltTear1 := #iUDT_LiftPI.ix_BeltTearLeft,
	                        ix_BeltTear2 := #iUDT_LiftPI.ix_BeltTearRight,
	                        ix_MaintSupport1 := #ix_MaintSupport1,
	                        ix_MaintSupport2 := #ix_MaintSupport2,
	                        ix_PosUp := #sUDT_020VSUInterface.PositionActual = #ci_LiftUp,
	                        ix_PosDown := #sUDT_020VSUInterface.PositionActual = #ci_LiftDown,
	                        ix_PECGapEnd := #ix_010PECGapEnd,
	                        ix_PECGapBegin := #ix_010PECGapBegin,
	                        ix_LimitSwitchUp := #ix_LimitSwitchUp,
	                        ix_LimitSwitchDown := #ix_LimitSwitchDown,
	                        ix_SafetyDoorDiagDown := #iUDT_LiftPI.ix_SafetyDoorDownDiag,
	                        ix_SafetyDoorDiagUp := #iUDT_LiftPI.ix_SafetyDoorUpDiag,
	                        ix_LCPAutoMode := #iUDT_LiftPI.ix_AutoMode,
	                        ix_LCPManualMode := #iUDT_LiftPI.ix_ManualMode,
	                        ix_LCPStop := #ix_KeySwitchStop,
	                        ix_LCPDown := #iUDT_LiftPI.ix_JogDown,
	                        ix_LCPUp := #iUDT_LiftPI.ix_JogUp,
	                        ix_LCPRef := #iUDT_LiftPI.ix_Reference,
	                        ix_TransportIdle := #sFB_020Lift.qx_TransportIdle,
	                        ix_HardwareOk := #ix_HardwareOk,
	                        ix_MaintenanceSwitchUp := #iUDT_LiftPI.ix_MaintenanceSwitchUpOn,
	                        ix_MainContactorFeedback := #iUDT_LiftPI.ix_MainContactorFeedbackOn,
	                        ix_OverTempBrakingResistor := #iUDT_LiftPI.ix_OverTempBrakeRes,
	                        qUDT_HMIStatus => #iqUDT_TGWLiftStatus."020".VSU,
	                        qUDT_Status => #iqUDT_TGWLiftCommonStatus."020",
	                        qx_MainContactorOn => #qUDT_LiftPO.qx_MainContactorOn,
	                        iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                        iqUDT_VSUCommand := #iqUDT_TGWLiftHMICommands."020".VSU,
	                        iqUDT_VSUInterface := #sUDT_020VSUInterface,
	                        iqUDT_Statistics := #iqUDT_TGWLiftStatistics."020".VSU);
	        
	    END_REGION
	    
	    REGION SEW VFD MOVI-C Positioning
	        
	        #"sFB_020VfdSEWMOVICPositioning"(iUDT_VfdConfig := #iUDT_TGWLiftConfiguration."020".VFD,
	                                         iUDT_VfdInputs := #iUDT_020MotorInput,
	                                         ix_MainPowerOk := TRUE,
	                                         ix_BackupPowerOk := TRUE,
	                                         ix_SimulationModeActive := "DB_Memory".Simulation,
	                                         qUDT_HMIStatus => #iqUDT_TGWLiftStatus."020".VFD,
	                                         qUDT_VfdOutputs => #qUDT_020MotorOutput,
	                                         iqUDT_VSUInterface := #sUDT_020VSUInterface,
	                                         iqUDT_VFDStatistics := #iqUDT_TGWLiftStatistics."020".VFD);
	        
	    END_REGION
	    
	    REGION Signaling
	        // Fault lamp 
	        #qUDT_LiftPO.qx_Fault :=
	        #iqUDT_TGWLiftCommonStatus."010".Error
	        OR #iqUDT_TGWLiftCommonStatus."010".SafetyStop
	        OR #iqUDT_TGWLiftCommonStatus."020".Error
	        OR #iqUDT_TGWLiftCommonStatus."020".SafetyStop
	        OR #iqUDT_InfeedEmptyUpCommonStatus.Error
	        OR #iqUDT_InfeedEmptyUpCommonStatus.SafetyStop
	        OR #iqUDT_InfeedFullDownCommonStatus.Error
	        OR #iqUDT_InfeedFullDownCommonStatus.SafetyStop
	        OR #iqUDT_OutfeedEmptyDownCommonStatus.Error
	        OR #iqUDT_OutfeedEmptyDownCommonStatus.SafetyStop
	        OR #iqUDT_OutfeedFullupCommonStatus.Error
	        OR #iqUDT_OutfeedFullupCommonStatus.SafetyStop
	        ;
	        
	    END_REGION
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_WSL"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 264
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_Configuration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_WSLConfiguration";   // Workstation configuration structure
      iUDT_MotorInput010 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 010 ConveyLinxAix inputs structure
      iUDT_MotorInput030 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 030 ConveyLinxAix inputs structure
      iUDT_MotorInput040 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 030 ConveyLinxAix inputs structure
      iUDT_MotorInput050 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 050 ConveyLinxAix inputs structure
      iUDT_MotorInput060 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 060 ConveyLinxAix inputs structure
      iUDT_MotorInput070 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 070 ConveyLinxAix inputs structure
      iUDT_MotorInput080 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 080 ConveyLinxAix inputs structure
      iUDT_MotorInput090 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 090 ConveyLinxAix inputs structure
      iUDT_MotorInput100 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 100 ConveyLinxAix inputs structure
      iUDT_MotorInput110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 110 ConveyLinxAix inputs structure
      iUDT_MotorInput120 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 120 ConveyLinxAix inputs structure
      iUDT_MotorInput210 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 210 ConveyLinxAix inputs structure
      iUDT_MotorInput220 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 220 ConveyLinxAix inputs structure
      iUDT_MotorInput230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 230 ConveyLinxAix inputs structure
      iUDT_MotorInput240 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 240 ConveyLinxAix inputs structure
      iUDT_MotorInput250 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 250 ConveyLinxAix inputs structure
      iUDT_MotorInput260 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 260 ConveyLinxAix inputs structure
      iUDT_MotorInput270 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 270 ConveyLinxAix inputs structure
      iUDT_MotorInput280 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 280 ConveyLinxAix inputs structure
      iUDT_MotorInput290 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 290 ConveyLinxAix inputs structure
      iUDT_MotorInput300 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 300 ConveyLinxAix inputs structure
      iUDT_MotorInput410 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 410 ConveyLinxAix inputs structure
      iUDT_MotorInput420 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 420 ConveyLinxAix inputs structure
      iUDT_MotorInput430 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 430 ConveyLinxAix inputs structure
      iUDT_MotorInput440 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 440 ConveyLinxAix inputs structure
      iUDT_MotorInput450 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 450 ConveyLinxAix inputs structure
      iUDT_MotorInput460 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 460 ConveyLinxAix inputs structure
      iUDT_MotorInput470 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 470 ConveyLinxAix inputs structure
      iUDT_MotorInput480 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 480 ConveyLinxAix inputs structure
      iUDT_MotorInput490 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 490 ConveyLinxAix inputs structure
      iUDT_MotorInput500 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 500 ConveyLinxAix inputs structure
      iUDT_MotorInput610 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 610 ConveyLinxAix inputs structure
      iUDT_MotorInput620 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 620 ConveyLinxAix inputs structure
      iUDT_MotorInput630 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 630 ConveyLinxAix inputs structure
      iUDT_MotorInput640 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 640 ConveyLinxAix inputs structure
      iUDT_ScannerInput280 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CognexDM260_IN";   // Cognex inputs structur
      iUDT_ScannerInput480 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CognexDM260_IN";
      ix_24vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 24VDC is healthy
      ix_400vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 400VAC is healthy
      ix_SafetyOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when safety is ok
      ix_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when hardware is ok
      ix_AirPressureOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when air pressure is ok
      ix_SectionIsUp121 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when section 121 is up
      ix_SectionIsDown121 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when section 121 is down
      ix_SectionIsUp221 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when section 221  is up
      ix_SectionIsDown221 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when section 221 is down
      ix_SectionIsUp291 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when section 291 is up
      ix_SectionIsDown291 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when section 291 is down
      ix_SectionIsUp421 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when section 421 is up
      ix_SectionIsDown421 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when section 421 is down
      ix_SectionIsUp491 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when section 491 is up
      ix_SectionIsDown491 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when section 491 is down
      ix_SectionIsUp611 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when section 611 is up
      ix_SectionIsDown611 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when section 611 is down
      ix_Done490 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE if action on right station is done and bin is ready to be send away
      ix_Done290 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE if action on left station is done and bin is ready to be send away
   END_VAR

   VAR_OUTPUT 
      qUDT_MotorOutput010 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 010 ConveyLinxAix outputs structure
      qUDT_MotorOutput030 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 030 ConveyLinxAix outputs structure
      qUDT_MotorOutput040 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 040 ConveyLinxAix outputs structure
      qUDT_MotorOutput050 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 050 ConveyLinxAix outputs structure
      qUDT_MotorOutput060 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 060 ConveyLinxAix outputs structure
      qUDT_MotorOutput070 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 070 ConveyLinxAix outputs structure
      qUDT_MotorOutput080 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 080 ConveyLinxAix outputs structure
      qUDT_MotorOutput090 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 090 ConveyLinxAix outputs structure
      qUDT_MotorOutput100 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 100 ConveyLinxAix outputs structure
      qUDT_MotorOutput110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 110 ConveyLinxAix outputs structure
      qUDT_MotorOutput120 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 120 ConveyLinxAix outputs structure
      qUDT_MotorOutput210 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 210 ConveyLinxAix outputs structure
      qUDT_MotorOutput220 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 220 ConveyLinxAix outputs structure
      qUDT_MotorOutput230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 230 ConveyLinxAix outputs structure
      qUDT_MotorOutput240 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 240 ConveyLinxAix outputs structure
      qUDT_MotorOutput250 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 250 ConveyLinxAix outputs structure
      qUDT_MotorOutput260 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 260 ConveyLinxAix outputs structure
      qUDT_MotorOutput270 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 270 ConveyLinxAix outputs structure
      qUDT_MotorOutput280 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 280 ConveyLinxAix outputs structure
      qUDT_MotorOutput290 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 290 ConveyLinxAix outputs structure
      qUDT_MotorOutput300 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 300 ConveyLinxAix outputs structure
      qUDT_MotorOutput410 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 410 ConveyLinxAix outputs structure
      qUDT_MotorOutput420 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 420 ConveyLinxAix outputs structure
      qUDT_MotorOutput430 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 430 ConveyLinxAix outputs structure
      qUDT_MotorOutput440 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 440 ConveyLinxAix outputs structure
      qUDT_MotorOutput450 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 450 ConveyLinxAix outputs structure
      qUDT_MotorOutput460 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 460 ConveyLinxAix outputs structure
      qUDT_MotorOutput470 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 470 ConveyLinxAix outputs structure
      qUDT_MotorOutput480 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 480 ConveyLinxAix outputs structure
      qUDT_MotorOutput490 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 490 ConveyLinxAix outputs structure
      qUDT_MotorOutput500 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 500 ConveyLinxAix outputs structure
      qUDT_MotorOutput610 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 610 ConveyLinxAix outputs structure
      qUDT_MotorOutput620 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 620 ConveyLinxAix outputs structure
      qUDT_MotorOutput630 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 630 ConveyLinxAix outputs structure
      qUDT_MotorOutput640 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullOut";   // 640 ConveyLinxAix outputs structure
      qUDT_ScannerOutput280 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CognexDM260_OUT";   // Cognex output structure
      qUDT_ScannerOutput480 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CognexDM260_OUT";
      qx_PopupControl121 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command up for section 121
      qx_PopupControl221 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command up for section 221
      qx_PopupControl291 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command up for section 291
      qx_PopupControl421 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command up for section 421
      qx_PopupControl491 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command up for section 491
      qx_PopupControl611 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command up for section 611
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
      iqUDT_HandshakeUpstream010 : "UDT_ConveyorHandshake";   // Upstream handshake structure for 010 conveyor
      iqUDT_HandshakeDownstream640 : "UDT_ConveyorHandshake";   // Downstream handshake structure for 640 conveyor
      iqUDT_WorkstationCommands : "UDT_WSLHmiCommands";   // Workstation command structure
      iqUDT_WorkstationStatistics : "UDT_WSLStatistics";   // Statistics structure
      iqUDT_WorkstationStatus : "UDT_WSLStatus";   // HMI Status structure
      iqUDT_WorkstationCommonStatus : "UDT_WSLCommonStatus";   // Common status structure
      iqUDT_RATPositioning120 : "UDT_RATPositioning";   // Structure including data for servo control RAT 121
      iqUDT_RATPositioning220 : "UDT_RATPositioning";   // Structure including data for servo control RAT 221
      iqUDT_RATPositioning290 : "UDT_RATPositioning";   // Structure including data for servo control RAT 291
      iqUDT_RATPositioning420 : "UDT_RATPositioning";   // Structure including data for servo control RAT 421
      iqUDT_RATPositioning490 : "UDT_RATPositioning";   // Structure including data for servo control RAT 491
      iqUDT_RATPositioning610 : "UDT_RATPositioning";   // Structure including data for servo control RAT 611
   END_VAR

   VAR 
      sFB_Displacement010 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 010 conveyor
      sFB_Displacement020 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 020 conveyor
      sFB_Displacement030 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 030 conveyor
      sFB_Displacement040 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 040 conveyor
      sFB_Displacement050 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 050 conveyor
      sFB_Displacement060 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 060 conveyor
      sFB_Displacement070 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 070 conveyor
      sFB_Displacement080 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 080 conveyor
      sFB_Displacement090 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 090 conveyor
      sFB_Displacement100 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 100 conveyor
      sFB_Displacement110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 110 conveyor
      sFB_Displacement120 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 120 conveyor
      sFB_Displacement121 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 121 conveyor
      sFB_Displacement210 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 210 conveyor
      sFB_Displacement220 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 220 conveyor
      sFB_Displacement221 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 221 conveyor
      sFB_Displacement230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 230 conveyor
      sFB_Displacement240 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 240 conveyor
      sFB_Displacement250 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 250 conveyor
      sFB_Displacement260 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 260 conveyor
      sFB_Displacement270 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 270 conveyor
      sFB_Displacement280 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 280 conveyor
      sFB_Displacement290 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 290 conveyor
      sFB_Displacement291 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 291 conveyor
      sFB_Displacement300 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 300 conveyor
      sFB_Displacement410 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 410 conveyor
      sFB_Displacement420 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 420 conveyor
      sFB_Displacement421 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 421 conveyor
      sFB_Displacement430 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 430 conveyor
      sFB_Displacement440 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 440 conveyor
      sFB_Displacement450 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 450 conveyor
      sFB_Displacement460 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 460 conveyor
      sFB_Displacement470 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 470 conveyor
      sFB_Displacement480 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 480 conveyor
      sFB_Displacement490 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 490 conveyor
      sFB_Displacement491 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 491 conveyor
      sFB_Displacement500 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 500 conveyor
      sFB_Displacement610 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 610 conveyor
      sFB_Displacement611 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 611 conveyor
      sFB_Displacement620 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 620 conveyor
      sFB_Displacement630 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 630 conveyor
      sFB_Displacement640 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 640 conveyor
      sUDT_Interface010 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 010 conveyor
      sUDT_Interface020 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 020 conveyor
      sUDT_Interface030 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 030 conveyor
      sUDT_Interface040 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 040 conveyor
      sUDT_Interface050 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 050 conveyor
      sUDT_Interface060 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 060 conveyor
      sUDT_Interface070 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 070 conveyor
      sUDT_Interface080 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 080 conveyor
      sUDT_Interface090 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 090 conveyor
      sUDT_Interface100 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 100 conveyor
      sUDT_Interface110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 110 conveyor
      sUDT_Interface120 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 120 conveyor
      sUDT_Interface121 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 121 conveyor
      sUDT_Interface210 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 210 conveyor
      sUDT_Interface220 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 220 conveyor
      sUDT_Interface221 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 221 conveyor
      sUDT_Interface230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 230 conveyor
      sUDT_Interface240 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 240 conveyor
      sUDT_Interface250 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 250 conveyor
      sUDT_Interface260 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 260 conveyor
      sUDT_Interface270 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 270 conveyor
      sUDT_Interface280 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 280 conveyor
      sUDT_Interface290 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 290 conveyor
      sUDT_Interface291 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 291 conveyor
      sUDT_Interface300 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 300 conveyor
      sUDT_Interface410 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 410 conveyor
      sUDT_Interface420 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 420 conveyor
      sUDT_Interface421 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 421 conveyor
      sUDT_Interface430 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 430 conveyor
      sUDT_Interface440 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 440 conveyor
      sUDT_Interface450 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 450 conveyor
      sUDT_Interface460 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 460 conveyor
      sUDT_Interface470 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 470 conveyor
      sUDT_Interface480 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 480 conveyor
      sUDT_Interface490 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 490 conveyor
      sUDT_Interface491 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 491 conveyor
      sUDT_Interface500 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 500 conveyor
      sUDT_Interface610 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 610 conveyor
      sUDT_Interface611 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 611 conveyor
      sUDT_Interface620 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 620 conveyor
      sUDT_Interface630 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 630 conveyor
      sUDT_Interface640 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 640 conveyor
      sUDT_Handshake010 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 010 conveyor
      sUDT_Handshake020 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 020 conveyor
      sUDT_Handshake030 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 030 conveyor
      sUDT_Handshake040 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 040 conveyor
      sUDT_Handshake050 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 050 conveyor
      sUDT_Handshake060 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 060 conveyor
      sUDT_Handshake070 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 070 conveyor
      sUDT_Handshake080 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 080 conveyor
      sUDT_Handshake090 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 090 conveyor
      sUDT_Handshake100 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 100 conveyor
      sUDT_Handshake110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 110 conveyor
      sUDT_Handshake120 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 120 conveyor
      sUDT_Handshake121 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 121 conveyor
      sUDT_HandshakeUp121 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // HandshakeUp structure for 121 conveyor
      sUDT_Handshake210 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 210 conveyor
      sUDT_Handshake220 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 220 conveyor
      sUDT_Handshake221 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 221 conveyor
      sUDT_Handshake230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 230 conveyor
      sUDT_Handshake240 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 240 conveyor
      sUDT_Handshake250 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 250 conveyor
      sUDT_Handshake260 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 260 conveyor
      sUDT_Handshake270 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 270 conveyor
      sUDT_Handshake280 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 280 conveyor
      sUDT_Handshake290 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 290 conveyor
      sUDT_Handshake291 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 291 conveyor
      sUDT_HandshakeUp291 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // HandshakeUp structure for 291 conveyor
      sUDT_Handshake300 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 300 conveyor
      sUDT_Handshake410 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 410 conveyor
      sUDT_Handshake420 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 420 conveyor
      sUDT_Handshake421 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 421 conveyor
      sUDT_Handshake430 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 430 conveyor
      sUDT_Handshake440 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 440 conveyor
      sUDT_Handshake450 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 450 conveyor
      sUDT_Handshake460 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 460 conveyor
      sUDT_Handshake470 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 470 conveyor
      sUDT_Handshake480 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 480 conveyor
      sUDT_Handshake490 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 490 conveyor
      sUDT_Handshake491 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 491 conveyor
      sUDT_Handshake500 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 500 conveyor
      sUDT_Handshake610 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 610 conveyor
      sUDT_Handshake611 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 611 conveyor
      sUDT_Handshake620 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 620 conveyor
      sUDT_Handshake630 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 630 conveyor
      sUDT_Handshake640 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 640 conveyor
      sFB_PEC010 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 010 conveyor
      sFB_PEC020 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 020 conveyor
      sFB_PEC040 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 040 conveyor
      sFB_PEC050 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 050 conveyor
      sFB_PEC060 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 060 conveyor
      sFB_PEC070 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 070 conveyor
      sFB_PEC080 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 080 conveyor
      sFB_PEC100 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 100 conveyor
      sFB_PEC110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 110 conveyor
      sFB_PEC120 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 120 conveyor
      sFB_PEC210 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 210 conveyor
      sFB_PEC220 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 220 conveyor
      sFB_PEC240 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 240 conveyor
      sFB_PEC250 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 250 conveyor
      sFB_PEC260 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 260 conveyor
      sFB_PEC280 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 280 conveyor
      sFB_PEC290 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 290 conveyor
      sFB_PEC300 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 3000 conveyor
      sFB_PEC410 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 410 conveyor
      sFB_PEC420 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 420 conveyor
      sFB_PEC440 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 440 conveyor
      sFB_PEC450 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 450 conveyor
      sFB_PEC460 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 460 conveyor
      sFB_PEC480 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 480 conveyor
      sFB_PEC490 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 490 conveyor
      sFB_PEC500 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 500 conveyor
      sFB_PEC610 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 610 conveyor
      sFB_PEC640 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 640 conveyor
      sFB_Conveyor010 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 010 conveyor
      sFB_Conveyor020 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 020 conveyor
      sFB_Conveyor030 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 030 conveyor
      sFB_Conveyor040 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 040 conveyor
      sFB_Conveyor050 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 050 conveyor
      sFB_Conveyor060 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 060 conveyor
      sFB_Conveyor070 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 070 conveyor
      sFB_Conveyor080 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 080 conveyor
      sFB_Conveyor090 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 090 conveyor
      sFB_Conveyor100 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 100 conveyor
      sFB_Conveyor110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 110 conveyor
      sFB_Conveyor210 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 210 conveyor
      sFB_Conveyor230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 230 conveyor
      sFB_Conveyor240 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 240 conveyor
      sFB_Conveyor250 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 250 conveyor
      sFB_Conveyor260 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 260 conveyor
      sFB_Conveyor270 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 270 conveyor
      sFB_Conveyor280 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 280 conveyor
      sFB_Conveyor300 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 300 conveyor
      sFB_Conveyor410 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 410 conveyor
      sFB_Conveyor430 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 430 conveyor
      sFB_Conveyor440 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 440 conveyor
      sFB_Conveyor450 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 450 conveyor
      sFB_Conveyor460 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 460 conveyor
      sFB_Conveyor470 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 470 conveyor
      sFB_Conveyor480 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 480 conveyor
      sFB_Conveyor500 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 500 conveyor
      sFB_Conveyor620 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 620 conveyor
      sFB_Conveyor630 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 630 conveyor
      sFB_Conveyor640 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 640 conveyor
      sFB_MCOConveyLinxAixController010 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 010
      sFB_MCOConveyLinxAixController020 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 020
      sFB_MCOConveyLinxAixController030 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 030
      sFB_MCOConveyLinxAixController040 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 040
      sFB_MCOConveyLinxAixController050 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 050
      sFB_MCOConveyLinxAixController060 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 060
      sFB_MCOConveyLinxAixController070 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 070
      sFB_MCOConveyLinxAixController080 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 080
      sFB_MCOConveyLinxAixController090 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 090
      sFB_MCOConveyLinxAixController100 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 100
      sFB_MCOConveyLinxAixController110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 110
      sFB_MCOConveyLinxAixController120 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 120
      sFB_MCOConveyLinxAixController121 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 121
      sFB_MCOConveyLinxAixController210 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 210
      sFB_MCOConveyLinxAixController220 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 220
      sFB_MCOConveyLinxAixController221 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 221
      sFB_MCOConveyLinxAixController230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 230
      sFB_MCOConveyLinxAixController240 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 240
      sFB_MCOConveyLinxAixController250 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 250
      sFB_MCOConveyLinxAixController260 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 260
      sFB_MCOConveyLinxAixController270 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 270
      sFB_MCOConveyLinxAixController280 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 280
      sFB_MCOConveyLinxAixController290 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 290
      sFB_MCOConveyLinxAixController291 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 291
      sFB_MCOConveyLinxAixController300 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 300
      sFB_MCOConveyLinxAixController410 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 410
      sFB_MCOConveyLinxAixController420 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 420
      sFB_MCOConveyLinxAixController421 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 421
      sFB_MCOConveyLinxAixController430 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 430
      sFB_MCOConveyLinxAixController440 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 440
      sFB_MCOConveyLinxAixController450 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 450
      sFB_MCOConveyLinxAixController460 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 460
      sFB_MCOConveyLinxAixController470 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 470
      sFB_MCOConveyLinxAixController480 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 480
      sFB_MCOConveyLinxAixController490 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 490
      sFB_MCOConveyLinxAixController491 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 491
      sFB_MCOConveyLinxAixController500 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 500
      sFB_MCOConveyLinxAixController610 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 610
      sFB_MCOConveyLinxAixController611 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 611
      sFB_MCOConveyLinxAixController620 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 620
      sFB_MCOConveyLinxAixController630 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 630
      sFB_MCOConveyLinxAixController640 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 630
      sFB_RightAngledTransfer121 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_RightAngledTransfer";   // Funtion to control 121 RAT
      sFB_RightAngledTransfer221 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_RightAngledTransfer";   // Funtion to control 221 RAT
      sFB_RightAngledTransfer291 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_RightAngledTransfer";   // Funtion to control 291 RAT
      sFB_RightAngledTransfer421 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_RightAngledTransfer";   // Funtion to control 421 RAT
      sFB_RightAngledTransfer491 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_RightAngledTransfer";   // Funtion to control 491 RAT
      sFB_RightAngledTransfer611 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_RightAngledTransfer";   // Funtion to control 611 RAT
      sFB_CountActiveInputs_Left { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_CountActiveInputs";   // Count free positions on left station
      sFB_CountActiveInputs_Right { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_CountActiveInputs";   // Count free positions on right station
      sFB_CognexDM280 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_CognexDM260";   // Cognex camera function block conveyor 280
      sFB_CognexDM480 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_CognexDM260";   // Cognex camera function block conveyor 480
      ss_Barcode280 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;
      ss_Barcode480 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;
      si_DestinationA121 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Destination for 121 RAT
      si_DestinationA291 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Destination for 291 RAT
      si_DestinationA491 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Destination for 491 RAT
      sx_LastFrom120Right { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Bit indicating that last divert on RAT 121 was to the right
   END_VAR

   VAR_TEMP 
      tUDT_dummyHandshake : "UDT_ConveyorHandshake";   // Dummy Handshake structure
      tUDT_DummyBladeStop : "UDT_ValveInterface";
      tw_dummy : Word;
      tx_dummy : Bool;   // Dummy bool
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:s
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	22/01/2024  | 0.1       | J.Majer       | Block interface and structure created
	23/02/2024  | 0.2       | R. Pieczonka  | Initial version
	26/02/2024  | 0.3       | S. Nieswiec   | Updated to new library blocks, added HardwareOk input
	18/03/2024  | 0.4       | S. Nieswiec   | Adjusting comments and variable names
	29/03/2024  | 0.5       | S.Nieswiec R. Pieczonka | Added MCOs, PEC changes etc.
	08/05/2024  | 0.6       | S.Nieswiec    | New MCO block
	08/05/2024  | 0.7       | K. Pokorski   | Added displacement
	15/05/2024  | 0.8       | S. Nieswiec   | Clean up, adjusting comments etc.
	08/06/2024  | 0.9       | S. Nieswiec   | New MCO, Displacement and RAT blocks, interface update
	14/06/2024  | 0.10      | S. Nieswiec   | Changed direct sensor inputs to statuses
	*)
	
	REGION 1 - Initial
	    
	    REGION 1.1 - Counters
	        
	        REGION 1.1.1 - Free slots at left station
	            IF #iUDT_Configuration.GlobalConfig.LeftStationExists THEN
	                #sFB_CountActiveInputs_Left(ix_Input1 := FALSE,//#iUDT_MotorInput440.AllSensorPortInputs.LeftSensor,
	                                            ix_Input2 := #iqUDT_WorkstationStatus."450".PEC_EoS.PEC,
	                                            ix_Input3 := #iqUDT_WorkstationStatus."460".PEC_EoS.PEC,
	                                            ix_Input4 := #iqUDT_WorkstationStatus."480".PEC_EoS.PEC,
	                                            ix_Input5 := #iqUDT_WorkstationStatus."421".PEC_EoS.PEC,
	                                            ix_Input6 := #iqUDT_WorkstationStatus."410".PEC_EoS.PEC);
	            END_IF;
	            
	        END_REGION
	        
	        REGION 1.1.2 - Free slots at right station
	            IF #iUDT_Configuration.GlobalConfig.RightStationExists THEN
	                #sFB_CountActiveInputs_Right(ix_Input1 := FALSE, //#iUDT_MotorInput240.AllSensorPortInputs.LeftSensor,
	                                             ix_Input2 := #iqUDT_WorkstationStatus."250".PEC_EoS.PEC,
	                                             ix_Input3 := #iqUDT_WorkstationStatus."260".PEC_EoS.PEC,
	                                             ix_Input4 := #iqUDT_WorkstationStatus."280".PEC_EoS.PEC,
	                                             ix_Input5 := #iqUDT_WorkstationStatus."221".PEC_EoS.PEC,
	                                             ix_Input6 := #iqUDT_WorkstationStatus."210".PEC_EoS.PEC);
	            END_IF;
	            
	        END_REGION
	    END_REGION
	    
	END_REGION
	
	REGION 2 - Destinations
	    // Reconsider that logic
	    // Destination FOR 121 RAT depending on existing stations, free spots on each side AND last divert destination
	    IF #iUDT_Configuration.GlobalConfig.LeftStationExists AND NOT #iUDT_Configuration.GlobalConfig.RightStationExists THEN
	        
	        #si_DestinationA121 := 2;
	        
	    ELSIF NOT #iUDT_Configuration.GlobalConfig.LeftStationExists AND #iUDT_Configuration.GlobalConfig.RightStationExists THEN
	        
	        #si_DestinationA121 := 1;
	        
	    ELSIF #iUDT_Configuration.GlobalConfig.LeftStationExists AND #iUDT_Configuration.GlobalConfig.RightStationExists THEN
	        
	        IF #sFB_RightAngledTransfer121.qx_ExternalSendRequestC THEN  //check where was last divert
	            #sx_LastFrom120Right := 1;
	        END_IF;
	        IF #sFB_RightAngledTransfer121.qx_ExternalSendRequestD THEN
	            #sx_LastFrom120Right := 0;
	        END_IF;
	        
	        IF #sFB_CountActiveInputs_Left.qi_ActiveInputsCount > #sFB_CountActiveInputs_Right.qi_ActiveInputsCount AND #iqUDT_WorkstationStatus."410".PEC_EoS.PEC
	            OR (#sFB_CountActiveInputs_Left.qi_ActiveInputsCount = #sFB_CountActiveInputs_Right.qi_ActiveInputsCount
	            AND #sx_LastFrom120Right
	            AND #sFB_CountActiveInputs_Left.qi_ActiveInputsCount <> 0
	            AND #iqUDT_WorkstationStatus."410".PEC_EoS.PEC)
	        THEN
	            #si_DestinationA121 := 2;
	            
	        ELSIF #sFB_CountActiveInputs_Right.qi_ActiveInputsCount <> 0
	            AND #iqUDT_WorkstationStatus."210".PEC_EoS.PEC THEN
	            #si_DestinationA121 := 1;
	        ELSE
	            #si_DestinationA121 := 0;
	        END_IF;
	    END_IF;
	    
	    //Destination for 291 RAT divert out of station after Done request
	    IF #ix_Done490 AND NOT #iqUDT_WorkstationStatus."291".PEC_EoS.PEC THEN
	        #si_DestinationA291 := 1;
	    ELSE
	        #si_DestinationA291 := 0;
	    END_IF;
	    
	    //Destination for 491 RAT RAT divert out of station after Done request
	    IF #ix_Done290 AND NOT #iqUDT_WorkstationStatus."491".PEC_EoS.PEC THEN
	        #si_DestinationA491 := 1;
	    ELSE
	        #si_DestinationA491 := 0;
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Middle line
	    REGION 010
	        
	        REGION Displacement
	            #sFB_Displacement010(#sUDT_Interface010);
	        END_REGION
	        
	        REGION EoS               
	            
	            #sFB_PEC010(ix_PEC := #iUDT_MotorInput010.AllSensorPortInputs.LeftSensor,
	                        iUDT_PECConfiguration := #iUDT_Configuration."010".PEC_EoS,
	                        qUDT_HMIStatus => #iqUDT_WorkstationStatus."010".PEC_EoS,
	                        iqUDT_ConveyorInterface := #sUDT_Interface010,
	                        iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."010".PEC_EoS);
	            
	        END_REGION
	        
	        REGION Conveyor
	            
	            #sFB_Conveyor010(iUDT_ConveyorConfiguration := #iUDT_Configuration."010".Conveyor,
	                             idi_PECEoSDistance := #iUDT_Configuration."010".PEC_EoS.Distance,
	                             idi_PECBoSDistance := 0,
	                             ii_ExternalSpeed := 0,
	                             ix_SafetyOk := #ix_SafetyOk,
	                             ix_24vOk := #ix_24vOk,
	                             ix_400vOk := #ix_400vOk,
	                             ix_HardwareOk := #ix_HardwareOk,
	                             ix_PECEoS := #iqUDT_WorkstationStatus."010".PEC_EoS.PEC,
	                             ix_PECBoS := TRUE,
	                             ix_ReverseDirection := FALSE,
	                             ix_ExternalRequestDieBack := FALSE,
	                             ix_ExternalRequestHold := FALSE,
	                             ix_ResetEnergySave := FALSE,
	                             qUDT_HMIStatus => #iqUDT_WorkstationStatus."010".Conveyor,
	                             qUDT_Status => #iqUDT_WorkstationCommonStatus."010",
	                             iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                             iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."010".Conveyor,
	                             iqUDT_ConveyorInterface := #sUDT_Interface010,
	                             iqUDT_HandShakeUp := #iqUDT_HandshakeUpstream010,
	                             iqUDT_HandShake := #sUDT_Handshake010,
	                             iqUDT_Statistics := #iqUDT_WorkstationStatistics."010".Conveyor);
	            
	        END_REGION
	        
	        REGION MCO
	            
	            #sFB_MCOConveyLinxAixController010(iUDT_AixConfig := #iUDT_Configuration."010".MCO_M01,
	                                               iUDT_AixInputsModule := #iUDT_MotorInput010,
	                                               ix_24vOk := #ix_24vOk,
	                                               ix_SimulationModeActive := "DB_Memory".Simulation,
	                                               ii_MotorPositionId := 1,
	                                               qUDT_HMIStatus => #iqUDT_WorkstationStatus."010".MCO_M01,
	                                               iqUDT_AixOutputsModule := #qUDT_MotorOutput010,
	                                               iqUDT_ConveyorInterface := #sUDT_Interface010,
	                                               iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."010".MCO_M01);
	        END_REGION
	        
	    END_REGION
	    
	    REGION 020
	        
	        REGION Displacement
	            #sFB_Displacement020(#sUDT_Interface020);
	        END_REGION
	        
	        REGION EoS               
	            
	            #sFB_PEC020(ix_PEC := #iUDT_MotorInput010.AllSensorPortInputs.RightSensor,
	                        iUDT_PECConfiguration := #iUDT_Configuration."020".PEC_EoS,
	                        qUDT_HMIStatus => #iqUDT_WorkstationStatus."020".PEC_EoS,
	                        iqUDT_ConveyorInterface := #sUDT_Interface020,
	                        iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."020".PEC_EoS);
	            
	        END_REGION
	        REGION Conveyor
	            
	            #sFB_Conveyor020(iUDT_ConveyorConfiguration := #iUDT_Configuration."020".Conveyor,
	                             idi_PECEoSDistance := #iUDT_Configuration."020".PEC_EoS.Distance,
	                             idi_PECBoSDistance := 0,
	                             ii_ExternalSpeed := 0,
	                             ix_SafetyOk := #ix_SafetyOk,
	                             ix_24vOk := #ix_24vOk,
	                             ix_400vOk := #ix_400vOk,
	                             ix_HardwareOk := #ix_HardwareOk,
	                             ix_PECEoS := #iqUDT_WorkstationStatus."020".PEC_EoS.PEC,
	                             ix_PECBoS := TRUE,
	                             ix_ReverseDirection := FALSE,
	                             ix_ExternalRequestDieBack := FALSE,
	                             ix_ExternalRequestHold := FALSE,
	                             ix_ResetEnergySave := FALSE,
	                             qUDT_HMIStatus => #iqUDT_WorkstationStatus."020".Conveyor,
	                             qUDT_Status => #iqUDT_WorkstationCommonStatus."020",
	                             iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                             iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."020".Conveyor,
	                             iqUDT_ConveyorInterface := #sUDT_Interface020,
	                             iqUDT_HandShakeUp := #sUDT_Handshake010,
	                             iqUDT_HandShake := #sUDT_Handshake020,
	                             iqUDT_Statistics := #iqUDT_WorkstationStatistics."020".Conveyor);
	            
	        END_REGION
	        
	        REGION MCO
	            
	            #sFB_MCOConveyLinxAixController020(iUDT_AixConfig := #iUDT_Configuration."020".MCO_M01,
	                                               iUDT_AixInputsModule := #iUDT_MotorInput010,
	                                               ix_24vOk := #ix_24vOk,
	                                               ix_SimulationModeActive := "DB_Memory".Simulation,
	                                               ii_MotorPositionId := 2,
	                                               qUDT_HMIStatus => #iqUDT_WorkstationStatus."020".MCO_M01,
	                                               iqUDT_AixOutputsModule := #qUDT_MotorOutput010,
	                                               iqUDT_ConveyorInterface := #sUDT_Interface020,
	                                               iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."020".MCO_M01);
	        END_REGION
	        
	    END_REGION
	    
	    REGION 030
	        
	        REGION Displacement
	            #sFB_Displacement030(#sUDT_Interface030);
	        END_REGION
	        
	        REGION Conveyor
	            
	            #sFB_Conveyor030(iUDT_ConveyorConfiguration := #iUDT_Configuration."030".Conveyor,
	                             idi_PECEoSDistance := 0,
	                             idi_PECBoSDistance := 0,
	                             ii_ExternalSpeed := 0,
	                             ix_SafetyOk := #ix_SafetyOk,
	                             ix_24vOk := #ix_24vOk,
	                             ix_400vOk := #ix_400vOk,
	                             ix_HardwareOk := #ix_HardwareOk,
	                             ix_PECEoS := TRUE,
	                             ix_PECBoS := TRUE,
	                             ix_ReverseDirection := FALSE,
	                             ix_ExternalRequestDieBack := FALSE,
	                             ix_ExternalRequestHold := FALSE,
	                             ix_ResetEnergySave := FALSE,
	                             qUDT_HMIStatus => #iqUDT_WorkstationStatus."030".Conveyor,
	                             qUDT_Status => #iqUDT_WorkstationCommonStatus."030",
	                             iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                             iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."030".Conveyor,
	                             iqUDT_ConveyorInterface := #sUDT_Interface030,
	                             iqUDT_HandShakeUp := #sUDT_Handshake020,
	                             iqUDT_HandShake := #sUDT_Handshake030,
	                             iqUDT_Statistics := #iqUDT_WorkstationStatistics."030".Conveyor);
	            
	        END_REGION
	        REGION MCO
	            
	            #sFB_MCOConveyLinxAixController030(iUDT_AixConfig := #iUDT_Configuration."030".MCO_M01,
	                                               iUDT_AixInputsModule := #iUDT_MotorInput030,
	                                               ix_24vOk := #ix_24vOk,
	                                               ix_SimulationModeActive := "DB_Memory".Simulation,
	                                               ii_MotorPositionId := 1,
	                                               qUDT_HMIStatus => #iqUDT_WorkstationStatus."030".MCO_M01,
	                                               iqUDT_AixOutputsModule := #qUDT_MotorOutput030,
	                                               iqUDT_ConveyorInterface := #sUDT_Interface030,
	                                               iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."030".MCO_M01);
	        END_REGION
	    END_REGION
	    
	    REGION 040
	        
	        REGION Displacement
	            #sFB_Displacement040(#sUDT_Interface040);
	        END_REGION
	        
	        REGION EoS               
	            
	            #sFB_PEC040(ix_PEC := #iUDT_MotorInput040.AllSensorPortInputs.LeftSensor,
	                        iUDT_PECConfiguration := #iUDT_Configuration."040".PEC_EoS,
	                        qUDT_HMIStatus => #iqUDT_WorkstationStatus."040".PEC_EoS,
	                        iqUDT_ConveyorInterface := #sUDT_Interface040,
	                        iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."040".PEC_EoS);
	            
	        END_REGION
	        REGION Conveyor
	            
	            #sFB_Conveyor040(iUDT_ConveyorConfiguration := #iUDT_Configuration."040".Conveyor,
	                             idi_PECEoSDistance := #iUDT_Configuration."040".PEC_EoS.Distance,
	                             idi_PECBoSDistance := 0,
	                             ii_ExternalSpeed := 0,
	                             ix_SafetyOk := #ix_SafetyOk,
	                             ix_24vOk := #ix_24vOk,
	                             ix_400vOk := #ix_400vOk,
	                             ix_HardwareOk := #ix_HardwareOk,
	                             ix_PECEoS := #iqUDT_WorkstationStatus."040".PEC_EoS.PEC,
	                             ix_PECBoS := TRUE,
	                             ix_ReverseDirection := FALSE,
	                             ix_ExternalRequestDieBack := FALSE,
	                             ix_ExternalRequestHold := FALSE,
	                             ix_ResetEnergySave := FALSE,
	                             qUDT_HMIStatus => #iqUDT_WorkstationStatus."040".Conveyor,
	                             qUDT_Status => #iqUDT_WorkstationCommonStatus."040",
	                             iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                             iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."040".Conveyor,
	                             iqUDT_ConveyorInterface := #sUDT_Interface040,
	                             iqUDT_HandShakeUp := #sUDT_Handshake030,
	                             iqUDT_HandShake := #sUDT_Handshake040,
	                             iqUDT_Statistics := #iqUDT_WorkstationStatistics."040".Conveyor);
	            
	        END_REGION
	        
	        REGION MCO
	            
	            #sFB_MCOConveyLinxAixController040(iUDT_AixConfig := #iUDT_Configuration."040".MCO_M01,
	                                               iUDT_AixInputsModule := #iUDT_MotorInput040,
	                                               ix_24vOk := #ix_24vOk,
	                                               ix_SimulationModeActive := "DB_Memory".Simulation,
	                                               ii_MotorPositionId := 1,
	                                               qUDT_HMIStatus => #iqUDT_WorkstationStatus."040".MCO_M01,
	                                               iqUDT_AixOutputsModule := #qUDT_MotorOutput040,
	                                               iqUDT_ConveyorInterface := #sUDT_Interface040,
	                                               iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."040".MCO_M01);
	        END_REGION
	    END_REGION
	    
	    REGION 050
	        
	        REGION Displacement
	            #sFB_Displacement050(#sUDT_Interface050);
	        END_REGION
	        
	        REGION EoS               
	            
	            #sFB_PEC050(ix_PEC := #iUDT_MotorInput050.AllSensorPortInputs.LeftSensor,
	                        iUDT_PECConfiguration := #iUDT_Configuration."050".PEC_EoS,
	                        qUDT_HMIStatus => #iqUDT_WorkstationStatus."050".PEC_EoS,
	                        iqUDT_ConveyorInterface := #sUDT_Interface050,
	                        iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."050".PEC_EoS);
	            
	        END_REGION
	        REGION Conveyor
	            
	            #sFB_Conveyor050(iUDT_ConveyorConfiguration := #iUDT_Configuration."050".Conveyor,
	                             idi_PECEoSDistance := #iUDT_Configuration."050".PEC_EoS.Distance,
	                             idi_PECBoSDistance := 0,
	                             ii_ExternalSpeed := 0,
	                             ix_SafetyOk := #ix_SafetyOk,
	                             ix_24vOk := #ix_24vOk,
	                             ix_400vOk := #ix_400vOk,
	                             ix_HardwareOk := #ix_HardwareOk,
	                             ix_PECEoS := #iqUDT_WorkstationStatus."050".PEC_EoS.PEC,
	                             ix_PECBoS := TRUE,
	                             ix_ReverseDirection := FALSE,
	                             ix_ExternalRequestDieBack := FALSE,
	                             ix_ExternalRequestHold := FALSE,
	                             ix_ResetEnergySave := FALSE,
	                             qUDT_HMIStatus => #iqUDT_WorkstationStatus."050".Conveyor,
	                             qUDT_Status => #iqUDT_WorkstationCommonStatus."050",
	                             iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                             iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."050".Conveyor,
	                             iqUDT_ConveyorInterface := #sUDT_Interface050,
	                             iqUDT_HandShakeUp := #sUDT_Handshake040,
	                             iqUDT_HandShake := #sUDT_Handshake050,
	                             iqUDT_Statistics := #iqUDT_WorkstationStatistics."050".Conveyor);
	            
	        END_REGION
	        
	        REGION MCO
	            
	            #sFB_MCOConveyLinxAixController050(iUDT_AixConfig := #iUDT_Configuration."050".MCO_M01,
	                                               iUDT_AixInputsModule := #iUDT_MotorInput050,
	                                               ix_24vOk := #ix_24vOk,
	                                               ix_SimulationModeActive := "DB_Memory".Simulation,
	                                               ii_MotorPositionId := 1,
	                                               qUDT_HMIStatus => #iqUDT_WorkstationStatus."050".MCO_M01,
	                                               iqUDT_AixOutputsModule := #qUDT_MotorOutput050,
	                                               iqUDT_ConveyorInterface := #sUDT_Interface050,
	                                               iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."050".MCO_M01);
	        END_REGION
	    END_REGION
	    
	    REGION 060
	        
	        REGION Displacement
	            #sFB_Displacement060(#sUDT_Interface060);
	        END_REGION
	        
	        REGION EoS               
	            
	            #sFB_PEC060(ix_PEC := #iUDT_MotorInput060.AllSensorPortInputs.LeftSensor,
	                        iUDT_PECConfiguration := #iUDT_Configuration."060".PEC_EoS,
	                        qUDT_HMIStatus => #iqUDT_WorkstationStatus."060".PEC_EoS,
	                        iqUDT_ConveyorInterface := #sUDT_Interface060,
	                        iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."060".PEC_EoS);
	            
	        END_REGION
	        REGION Conveyor
	            
	            #sFB_Conveyor060(iUDT_ConveyorConfiguration := #iUDT_Configuration."060".Conveyor,
	                             idi_PECEoSDistance := #iUDT_Configuration."060".PEC_EoS.Distance,
	                             idi_PECBoSDistance := 0,
	                             ii_ExternalSpeed := 0,
	                             ix_SafetyOk := #ix_SafetyOk,
	                             ix_24vOk := #ix_24vOk,
	                             ix_400vOk := #ix_400vOk,
	                             ix_HardwareOk := #ix_HardwareOk,
	                             ix_PECEoS := #iqUDT_WorkstationStatus."060".PEC_EoS.PEC,
	                             ix_PECBoS := TRUE,
	                             ix_ReverseDirection := FALSE,
	                             ix_ExternalRequestDieBack := FALSE,
	                             ix_ExternalRequestHold := FALSE,
	                             ix_ResetEnergySave := FALSE,
	                             qUDT_HMIStatus => #iqUDT_WorkstationStatus."060".Conveyor,
	                             qUDT_Status => #iqUDT_WorkstationCommonStatus."060",
	                             iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                             iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."060".Conveyor,
	                             iqUDT_ConveyorInterface := #sUDT_Interface060,
	                             iqUDT_HandShakeUp := #sUDT_Handshake050,
	                             iqUDT_HandShake := #sUDT_Handshake060,
	                             iqUDT_Statistics := #iqUDT_WorkstationStatistics."060".Conveyor);
	            
	        END_REGION
	        
	        REGION MCO
	            
	            #sFB_MCOConveyLinxAixController060(iUDT_AixConfig := #iUDT_Configuration."060".MCO_M01,
	                                               iUDT_AixInputsModule := #iUDT_MotorInput060,
	                                               ix_24vOk := #ix_24vOk,
	                                               ix_SimulationModeActive := "DB_Memory".Simulation,
	                                               ii_MotorPositionId := 1,
	                                               qUDT_HMIStatus => #iqUDT_WorkstationStatus."060".MCO_M01,
	                                               iqUDT_AixOutputsModule := #qUDT_MotorOutput060,
	                                               iqUDT_ConveyorInterface := #sUDT_Interface060,
	                                               iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."060".MCO_M01);
	        END_REGION
	    END_REGION
	    
	    REGION 070
	        
	        REGION Displacement
	            #sFB_Displacement070(#sUDT_Interface070);
	        END_REGION
	        
	        REGION EoS               
	            
	            #sFB_PEC070(ix_PEC := #iUDT_MotorInput070.AllSensorPortInputs.LeftSensor,
	                        iUDT_PECConfiguration := #iUDT_Configuration."070".PEC_EoS,
	                        qUDT_HMIStatus => #iqUDT_WorkstationStatus."070".PEC_EoS,
	                        iqUDT_ConveyorInterface := #sUDT_Interface070,
	                        iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."070".PEC_EoS);
	            
	        END_REGION
	        REGION Conveyor
	            
	            #sFB_Conveyor070(iUDT_ConveyorConfiguration := #iUDT_Configuration."070".Conveyor,
	                             idi_PECEoSDistance := #iUDT_Configuration."070".PEC_EoS.Distance,
	                             idi_PECBoSDistance := 0,
	                             ii_ExternalSpeed := 0,
	                             ix_SafetyOk := #ix_SafetyOk,
	                             ix_24vOk := #ix_24vOk,
	                             ix_400vOk := #ix_400vOk,
	                             ix_HardwareOk := #ix_HardwareOk,
	                             ix_PECEoS := #iqUDT_WorkstationStatus."070".PEC_EoS.PEC,
	                             ix_PECBoS := TRUE,
	                             ix_ReverseDirection := FALSE,
	                             ix_ExternalRequestDieBack := FALSE,
	                             ix_ExternalRequestHold := FALSE,
	                             ix_ResetEnergySave := FALSE,
	                             qUDT_HMIStatus => #iqUDT_WorkstationStatus."070".Conveyor,
	                             qUDT_Status => #iqUDT_WorkstationCommonStatus."070",
	                             iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                             iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."070".Conveyor,
	                             iqUDT_ConveyorInterface := #sUDT_Interface070,
	                             iqUDT_HandShakeUp := #sUDT_Handshake060,
	                             iqUDT_HandShake := #sUDT_Handshake070,
	                             iqUDT_Statistics := #iqUDT_WorkstationStatistics."070".Conveyor);
	            
	        END_REGION
	        
	        REGION MCO
	            
	            #sFB_MCOConveyLinxAixController070(iUDT_AixConfig := #iUDT_Configuration."070".MCO_M01,
	                                               iUDT_AixInputsModule := #iUDT_MotorInput070,
	                                               ix_24vOk := #ix_24vOk,
	                                               ix_SimulationModeActive := "DB_Memory".Simulation,
	                                               ii_MotorPositionId := 1,
	                                               qUDT_HMIStatus => #iqUDT_WorkstationStatus."070".MCO_M01,
	                                               iqUDT_AixOutputsModule := #qUDT_MotorOutput070,
	                                               iqUDT_ConveyorInterface := #sUDT_Interface070,
	                                               iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."070".MCO_M01);
	        END_REGION
	    END_REGION
	    
	    REGION 080
	        
	        REGION Displacement
	            #sFB_Displacement080(#sUDT_Interface080);
	        END_REGION
	        
	        REGION EoS               
	            
	            #sFB_PEC080(ix_PEC := #iUDT_MotorInput080.AllSensorPortInputs.LeftSensor,
	                        iUDT_PECConfiguration := #iUDT_Configuration."080".PEC_EoS,
	                        qUDT_HMIStatus => #iqUDT_WorkstationStatus."080".PEC_EoS,
	                        iqUDT_ConveyorInterface := #sUDT_Interface080,
	                        iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."080".PEC_EoS);
	            
	        END_REGION
	        REGION Conveyor
	            
	            #sFB_Conveyor080(iUDT_ConveyorConfiguration := #iUDT_Configuration."080".Conveyor,
	                             idi_PECEoSDistance := #iUDT_Configuration."080".PEC_EoS.Distance,
	                             idi_PECBoSDistance := 0,
	                             ii_ExternalSpeed := 0,
	                             ix_SafetyOk := #ix_SafetyOk,
	                             ix_24vOk := #ix_24vOk,
	                             ix_400vOk := #ix_400vOk,
	                             ix_HardwareOk := #ix_HardwareOk,
	                             ix_PECEoS := #iqUDT_WorkstationStatus."080".PEC_EoS.PEC,
	                             ix_PECBoS := TRUE,
	                             ix_ReverseDirection := FALSE,
	                             ix_ExternalRequestDieBack := FALSE,
	                             ix_ExternalRequestHold := FALSE,
	                             ix_ResetEnergySave := FALSE,
	                             qUDT_HMIStatus => #iqUDT_WorkstationStatus."080".Conveyor,
	                             qUDT_Status => #iqUDT_WorkstationCommonStatus."080",
	                             iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                             iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."080".Conveyor,
	                             iqUDT_ConveyorInterface := #sUDT_Interface080,
	                             iqUDT_HandShakeUp := #sUDT_Handshake070,
	                             iqUDT_HandShake := #sUDT_Handshake080,
	                             iqUDT_Statistics := #iqUDT_WorkstationStatistics."080".Conveyor);
	            
	        END_REGION
	        
	        REGION MCO
	            
	            #sFB_MCOConveyLinxAixController080(iUDT_AixConfig := #iUDT_Configuration."080".MCO_M01,
	                                               iUDT_AixInputsModule := #iUDT_MotorInput080,
	                                               ix_24vOk := #ix_24vOk,
	                                               ix_SimulationModeActive := "DB_Memory".Simulation,
	                                               ii_MotorPositionId := 1,
	                                               qUDT_HMIStatus => #iqUDT_WorkstationStatus."080".MCO_M01,
	                                               iqUDT_AixOutputsModule := #qUDT_MotorOutput080,
	                                               iqUDT_ConveyorInterface := #sUDT_Interface080,
	                                               iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."080".MCO_M01);
	        END_REGION
	    END_REGION
	    
	    REGION 090
	        
	        REGION Displacement
	            #sFB_Displacement090(#sUDT_Interface090);
	        END_REGION
	        
	        REGION Conveyor
	            
	            #sFB_Conveyor090(iUDT_ConveyorConfiguration := #iUDT_Configuration."090".Conveyor,
	                             idi_PECEoSDistance := 0,
	                             idi_PECBoSDistance := 0,
	                             ii_ExternalSpeed := 0,
	                             ix_SafetyOk := #ix_SafetyOk,
	                             ix_24vOk := #ix_24vOk,
	                             ix_400vOk := #ix_400vOk,
	                             ix_HardwareOk := #ix_HardwareOk,
	                             ix_PECEoS := TRUE,
	                             ix_PECBoS := TRUE,
	                             ix_ReverseDirection := FALSE,
	                             ix_ExternalRequestDieBack := FALSE,
	                             ix_ExternalRequestHold := FALSE,
	                             ix_ResetEnergySave := FALSE,
	                             qUDT_HMIStatus => #iqUDT_WorkstationStatus."090".Conveyor,
	                             qUDT_Status => #iqUDT_WorkstationCommonStatus."090",
	                             iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                             iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."090".Conveyor,
	                             iqUDT_ConveyorInterface := #sUDT_Interface090,
	                             iqUDT_HandShakeUp := #sUDT_Handshake080,
	                             iqUDT_HandShake := #sUDT_Handshake090,
	                             iqUDT_Statistics := #iqUDT_WorkstationStatistics."090".Conveyor);
	            
	        END_REGION
	        REGION MCO
	            
	            #sFB_MCOConveyLinxAixController090(iUDT_AixConfig := #iUDT_Configuration."090".MCO_M01,
	                                               iUDT_AixInputsModule := #iUDT_MotorInput090,
	                                               ix_24vOk := #ix_24vOk,
	                                               ix_SimulationModeActive := "DB_Memory".Simulation,
	                                               ii_MotorPositionId := 1,
	                                               qUDT_HMIStatus => #iqUDT_WorkstationStatus."090".MCO_M01,
	                                               iqUDT_AixOutputsModule := #qUDT_MotorOutput090,
	                                               iqUDT_ConveyorInterface := #sUDT_Interface090,
	                                               iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."090".MCO_M01);
	        END_REGION
	    END_REGION
	    
	    REGION 100
	        
	        REGION Displacement
	            #sFB_Displacement100(#sUDT_Interface100);
	        END_REGION
	        
	        REGION EoS               
	            
	            #sFB_PEC100(ix_PEC := #iUDT_MotorInput100.AllSensorPortInputs.LeftSensor,
	                        iUDT_PECConfiguration := #iUDT_Configuration."100".PEC_EoS,
	                        qUDT_HMIStatus => #iqUDT_WorkstationStatus."100".PEC_EoS,
	                        iqUDT_ConveyorInterface := #sUDT_Interface100,
	                        iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."100".PEC_EoS);
	            
	        END_REGION
	        REGION Conveyor
	            
	            #sFB_Conveyor100(iUDT_ConveyorConfiguration := #iUDT_Configuration."100".Conveyor,
	                             idi_PECEoSDistance := #iUDT_Configuration."100".PEC_EoS.Distance,
	                             idi_PECBoSDistance := 0,
	                             ii_ExternalSpeed := 0,
	                             ix_SafetyOk := #ix_SafetyOk,
	                             ix_24vOk := #ix_24vOk,
	                             ix_400vOk := #ix_400vOk,
	                             ix_HardwareOk := #ix_HardwareOk,
	                             ix_PECEoS := #iqUDT_WorkstationStatus."100".PEC_EoS.PEC,
	                             ix_PECBoS := TRUE,
	                             ix_ReverseDirection := FALSE,
	                             ix_ExternalRequestDieBack := FALSE,
	                             ix_ExternalRequestHold := FALSE,
	                             ix_ResetEnergySave := FALSE,
	                             qUDT_HMIStatus => #iqUDT_WorkstationStatus."100".Conveyor,
	                             qUDT_Status => #iqUDT_WorkstationCommonStatus."100",
	                             iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                             iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."100".Conveyor,
	                             iqUDT_ConveyorInterface := #sUDT_Interface100,
	                             iqUDT_HandShakeUp := #sUDT_Handshake090,
	                             iqUDT_HandShake := #sUDT_Handshake100,
	                             iqUDT_Statistics := #iqUDT_WorkstationStatistics."100".Conveyor);
	            
	        END_REGION
	        
	        REGION MCO
	            
	            #sFB_MCOConveyLinxAixController100(iUDT_AixConfig := #iUDT_Configuration."100".MCO_M01,
	                                               iUDT_AixInputsModule := #iUDT_MotorInput100,
	                                               ix_24vOk := #ix_24vOk,
	                                               ix_SimulationModeActive := "DB_Memory".Simulation,
	                                               ii_MotorPositionId := 1,
	                                               qUDT_HMIStatus => #iqUDT_WorkstationStatus."100".MCO_M01,
	                                               iqUDT_AixOutputsModule := #qUDT_MotorOutput100,
	                                               iqUDT_ConveyorInterface := #sUDT_Interface100,
	                                               iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."100".MCO_M01);
	        END_REGION
	    END_REGION
	    
	    REGION 110
	        
	        REGION Displacement
	            #sFB_Displacement110(#sUDT_Interface110);
	        END_REGION
	        
	        REGION EoS               
	            
	            #sFB_PEC110(ix_PEC := #iUDT_MotorInput110.AllSensorPortInputs.LeftSensor,
	                        iUDT_PECConfiguration := #iUDT_Configuration."110".PEC_EoS,
	                        qUDT_HMIStatus => #iqUDT_WorkstationStatus."110".PEC_EoS,
	                        iqUDT_ConveyorInterface := #sUDT_Interface110,
	                        iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."110".PEC_EoS);
	            
	        END_REGION
	        REGION Conveyor
	            
	            #sUDT_Handshake110.RTR := #sUDT_Handshake110.RTR OR #iqUDT_WorkstationStatus."110".PEC_EoS.PEC;
	            
	            #sFB_Conveyor110(iUDT_ConveyorConfiguration := #iUDT_Configuration."110".Conveyor,
	                             idi_PECEoSDistance := #iUDT_Configuration."110".PEC_EoS.Distance,
	                             idi_PECBoSDistance := 0,
	                             ii_ExternalSpeed := 0,
	                             ix_SafetyOk := #ix_SafetyOk,
	                             ix_24vOk := #ix_24vOk,
	                             ix_400vOk := #ix_400vOk,
	                             ix_HardwareOk := #ix_HardwareOk,
	                             ix_PECEoS := #iqUDT_WorkstationStatus."110".PEC_EoS.PEC,
	                             ix_PECBoS := TRUE,
	                             ix_ReverseDirection := FALSE,
	                             ix_ExternalRequestDieBack := FALSE,
	                             ix_ExternalRequestHold := FALSE,
	                             ix_ResetEnergySave := FALSE,
	                             qUDT_HMIStatus => #iqUDT_WorkstationStatus."110".Conveyor,
	                             qUDT_Status => #iqUDT_WorkstationCommonStatus."110",
	                             iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                             iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."110".Conveyor,
	                             iqUDT_ConveyorInterface := #sUDT_Interface110,
	                             iqUDT_HandShakeUp := #sUDT_Handshake100,
	                             iqUDT_HandShake := #sUDT_Handshake110,
	                             iqUDT_Statistics := #iqUDT_WorkstationStatistics."110".Conveyor);
	            
	        END_REGION
	        REGION MCO
	            
	            #sFB_MCOConveyLinxAixController110(iUDT_AixConfig := #iUDT_Configuration."110".MCO_M01,
	                                               iUDT_AixInputsModule := #iUDT_MotorInput110,
	                                               ix_24vOk := #ix_24vOk,
	                                               ix_SimulationModeActive := "DB_Memory".Simulation,
	                                               ii_MotorPositionId := 1,
	                                               qUDT_HMIStatus => #iqUDT_WorkstationStatus."110".MCO_M01,
	                                               iqUDT_AixOutputsModule := #qUDT_MotorOutput110,
	                                               iqUDT_ConveyorInterface := #sUDT_Interface110,
	                                               iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."110".MCO_M01);
	        END_REGION
	    END_REGION
	    
	    REGION 120
	        
	        REGION Displacement
	            #sFB_Displacement120(#sUDT_Interface120);
	        END_REGION
	        
	        REGION MCO
	            
	            #sFB_MCOConveyLinxAixController120(iUDT_AixConfig := #iUDT_Configuration."120".MCO_M01,
	                                               iUDT_AixInputsModule := #iUDT_MotorInput120,
	                                               ii_PositionSetpoint := #iqUDT_RATPositioning120.Lower.EndPosition,
	                                               ix_24vOk := #ix_24vOk,
	                                               ix_SimulationModeActive := "DB_Memory".Simulation,
	                                               ii_MotorPositionId := 1,
	                                               ix_StartPositioning := #iqUDT_RATPositioning120.Lower.Start,
	                                               ix_ResetPosition := #iqUDT_RATPositioning120.Lower.ResetPosition,
	                                               qUDT_HMIStatus => #iqUDT_WorkstationStatus."120".MCO_M01,
	                                               qx_Positioned => #iqUDT_RATPositioning120.Lower.Done,
	                                               iqUDT_AixOutputsModule := #qUDT_MotorOutput120,
	                                               iqUDT_ConveyorInterface := #sUDT_Interface120,
	                                               iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."120".MCO_M01);
	        END_REGION
	    END_REGION
	    
	    REGION 121
	        
	        REGION Displacement
	            #sFB_Displacement121(#sUDT_Interface121);
	        END_REGION
	        
	        REGION RAT
	            
	            #sFB_RightAngledTransfer121(iUDT_Configuration := #iUDT_Configuration."121".RightAngledTransfer,
	                                        iUDT_LowerConveyorConfiguration := #iUDT_Configuration."120".Conveyor,
	                                        iUDT_UpperConveyorConfiguration := #iUDT_Configuration."121".Conveyor,
	                                        iUDT_PECConfiguration := #iUDT_Configuration."120".PEC_EoS,
	                                        ii_DestinationA := #si_DestinationA121,
	                                        ii_DestinationB := 0,
	                                        ii_DestinationC := 0,
	                                        ii_DestinationD := 0,
	                                        ix_HardwareOk := #ix_HardwareOk,
	                                        ix_400vOk := #ix_400vOk,
	                                        ix_24vOk := #ix_24vOk,
	                                        ix_SafetyOk := #ix_SafetyOk,
	                                        ix_AirPressureOk := #ix_AirPressureOk,
	                                        ix_SectionIsDown := #ix_SectionIsDown121,
	                                        ix_SectionIsUp := #ix_SectionIsUp121,
	                                        ix_ConveyorAAuto := #iqUDT_WorkstationCommonStatus."110".AutoON,
	                                        ix_ConveyorBAuto := false,
	                                        ix_ConveyorCAuto := #iqUDT_WorkstationCommonStatus."210".AutoON,
	                                        ix_ConveyorDAuto := #iqUDT_WorkstationCommonStatus."410".AutoON,
	                                        ix_PEC := #iUDT_MotorInput120.AllSensorPortInputs.LeftSensor,
	                                        ix_ExternalReceiveRequestA := NOT #iqUDT_WorkstationStatus."110".PEC_EoS.PEC,
	                                        ix_ExternalReceiveRequestB := FALSE,
	                                        ix_ExternalReceiveRequestC := FALSE,
	                                        ix_ExternalReceiveRequestD := FALSE,
	                                        ix_PECInfeedA := #iqUDT_WorkstationStatus."110".PEC_EoS.PEC,
	                                        ix_PECInfeedB := false,
	                                        ix_PECInfeedC := false,
	                                        ix_PECInfeedD := false,
	                                        qUDT_HMIRATStatus => #iqUDT_WorkstationStatus."121".RightAngledTransfer,
	                                        qUDT_HMIConveyorStatus => #iqUDT_WorkstationStatus."120".Conveyor,
	                                        qUDT_HMIPECStatus => #iqUDT_WorkstationStatus."121".PEC_EoS,
	                                        qUDT_RATStatus => #iqUDT_WorkstationCommonStatus."121",
	                                        qUDT_ConveyorStatus => #iqUDT_WorkstationCommonStatus."120",
	                                        qx_PopupControl => #qx_PopupControl121,
	                                        qx_ExternalSendRequestA => #tx_dummy,
	                                        qx_ExternalSendRequestB => #tx_dummy,
	                                        qx_ExternalSendRequestC => #tx_dummy,
	                                        qx_ExternalSendRequestD => #tx_dummy,
	                                        iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                        iqUDT_RATCommand := #iqUDT_WorkstationCommands."121".RightAngledTransfer,
	                                        iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."120".Conveyor,
	                                        iqUDT_RATStatistics := #iqUDT_WorkstationStatistics."121".RightAngledTransfer,
	                                        iqUDT_ConveyorStatistics := #iqUDT_WorkstationStatistics."120".Conveyor,
	                                        iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."121".PEC_EoS,
	                                        iqUDT_HandShakeConveyorA := #sUDT_Handshake110,
	                                        iqUDT_HandShakeConveyorB := #tUDT_dummyHandshake,
	                                        iqUDT_HandShakeConveyorC := #sUDT_HandshakeUp121,
	                                        iqUDT_HandShakeConveyorD := #sUDT_Handshake121,
	                                        iqUDT_LowerConveyorInterface := #sUDT_Interface120,
	                                        iqUDT_UpperConveyorInterface := #sUDT_Interface121,
	                                        iqUDT_RATPositioning := #iqUDT_RATPositioning120,
	                                        iqUDT_BladeStopEoSInterface := #tUDT_DummyBladeStop,
	                                        iqUDT_BladeStopBoSInterface := #tUDT_DummyBladeStop);
	            
	        END_REGION
	        
	        REGION MCO
	            
	            #sFB_MCOConveyLinxAixController121(iUDT_AixConfig := #iUDT_Configuration."121".MCO_M01,
	                                               iUDT_AixInputsModule := #iUDT_MotorInput120,
	                                               ix_24vOk := #ix_24vOk,
	                                               ix_SimulationModeActive := "DB_Memory".Simulation,
	                                               ii_MotorPositionId := 2,
	                                               qUDT_HMIStatus => #iqUDT_WorkstationStatus."121".MCO_M01,
	                                               iqUDT_AixOutputsModule := #qUDT_MotorOutput120,
	                                               iqUDT_ConveyorInterface := #sUDT_Interface121,
	                                               iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."121".MCO_M01);
	        END_REGION
	        
	    END_REGION
	END_REGION
	
	REGION 4 - Right Station
	    IF #iUDT_Configuration.GlobalConfig.RightStationExists THEN
	        REGION 210
	            
	            REGION Displacement
	                #sFB_Displacement210(#sUDT_Interface210);
	            END_REGION
	            
	            REGION EoS               
	                
	                #sFB_PEC210(ix_PEC := #iUDT_MotorInput210.AllSensorPortInputs.LeftSensor,
	                            iUDT_PECConfiguration := #iUDT_Configuration."210".PEC_EoS,
	                            qUDT_HMIStatus => #iqUDT_WorkstationStatus."210".PEC_EoS,
	                            iqUDT_ConveyorInterface := #sUDT_Interface210,
	                            iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."210".PEC_EoS);
	                
	            END_REGION
	            REGION Conveyor
	                
	                #sUDT_Handshake210.RTR := #sUDT_Handshake210.RTR OR #iqUDT_WorkstationStatus."210".PEC_EoS.PEC;
	                
	                #sFB_Conveyor210(iUDT_ConveyorConfiguration := #iUDT_Configuration."210".Conveyor,
	                                 idi_PECEoSDistance := #iUDT_Configuration."210".PEC_EoS.Distance,
	                                 idi_PECBoSDistance := 0,
	                                 ii_ExternalSpeed := 0,
	                                 ix_SafetyOk := #ix_SafetyOk,
	                                 ix_24vOk := #ix_24vOk,
	                                 ix_400vOk := #ix_400vOk,
	                                 ix_HardwareOk := #ix_HardwareOk,
	                                 ix_PECEoS := #iqUDT_WorkstationStatus."210".PEC_EoS.PEC,
	                                 ix_PECBoS := TRUE,
	                                 ix_ReverseDirection := FALSE,
	                                 ix_ExternalRequestDieBack := FALSE,
	                                 ix_ExternalRequestHold := FALSE,
	                                 ix_ResetEnergySave := FALSE,
	                                 qUDT_HMIStatus => #iqUDT_WorkstationStatus."210".Conveyor,
	                                 qUDT_Status => #iqUDT_WorkstationCommonStatus."210",
	                                 iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                 iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."210".Conveyor,
	                                 iqUDT_ConveyorInterface := #sUDT_Interface210,
	                                 iqUDT_HandShakeUp := #sUDT_HandshakeUp121,
	                                 iqUDT_HandShake := #sUDT_Handshake210,
	                                 iqUDT_Statistics := #iqUDT_WorkstationStatistics."210".Conveyor);
	                
	            END_REGION
	            REGION MCO
	                
	                #sFB_MCOConveyLinxAixController210(iUDT_AixConfig := #iUDT_Configuration."210".MCO_M01,
	                                                   iUDT_AixInputsModule := #iUDT_MotorInput210,
	                                                   ix_24vOk := #ix_24vOk,
	                                                   ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                   ii_MotorPositionId := 1,
	                                                   qUDT_HMIStatus => #iqUDT_WorkstationStatus."210".MCO_M01,
	                                                   iqUDT_AixOutputsModule := #qUDT_MotorOutput210,
	                                                   iqUDT_ConveyorInterface := #sUDT_Interface210,
	                                                   iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."210".MCO_M01);
	            END_REGION
	        END_REGION
	        
	        REGION 220
	            
	            REGION Displacement
	                #sFB_Displacement220(#sUDT_Interface220);
	            END_REGION
	            
	            REGION MCO
	                
	                #sFB_MCOConveyLinxAixController220(iUDT_AixConfig := #iUDT_Configuration."220".MCO_M01,
	                                                   iUDT_AixInputsModule := #iUDT_MotorInput220,
	                                                   ix_24vOk := #ix_24vOk,
	                                                   ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                   ii_MotorPositionId := 1,
	                                                   qUDT_HMIStatus => #iqUDT_WorkstationStatus."220".MCO_M01,
	                                                   iqUDT_AixOutputsModule := #qUDT_MotorOutput220,
	                                                   iqUDT_ConveyorInterface := #sUDT_Interface220,
	                                                   iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."220".MCO_M01);
	            END_REGION
	        END_REGION
	        
	        REGION 221
	            
	            REGION Displacement
	                #sFB_Displacement221(#sUDT_Interface221);
	            END_REGION
	            
	            REGION RAT
	                
	                
	                #sFB_RightAngledTransfer221(iUDT_Configuration := #iUDT_Configuration."221".RightAngledTransfer,
	                                            iUDT_LowerConveyorConfiguration := #iUDT_Configuration."220".Conveyor,
	                                            iUDT_UpperConveyorConfiguration := #iUDT_Configuration."221".Conveyor,
	                                            iUDT_PECConfiguration := #iUDT_Configuration."220".PEC_EoS,
	                                            ii_DestinationA := 0,
	                                            ii_DestinationB := 0,
	                                            ii_DestinationC := 1,
	                                            ii_DestinationD := 0,
	                                            ix_HardwareOk := #ix_HardwareOk,
	                                            ix_400vOk := #ix_400vOk,
	                                            ix_24vOk := #ix_24vOk,
	                                            ix_SafetyOk := #ix_SafetyOk,
	                                            ix_AirPressureOk := #ix_AirPressureOk,
	                                            ix_SectionIsDown := #ix_SectionIsDown221,
	                                            ix_SectionIsUp := #ix_SectionIsUp221,
	                                            ix_ConveyorAAuto := FALSE,
	                                            ix_ConveyorBAuto := #iqUDT_WorkstationCommonStatus."230".AutoON,
	                                            ix_ConveyorCAuto := #iqUDT_WorkstationCommonStatus."210".AutoON,
	                                            ix_ConveyorDAuto := false,
	                                            ix_PEC := #iUDT_MotorInput220.AllSensorPortInputs.LeftSensor,
	                                            ix_ExternalReceiveRequestA := FALSE,
	                                            ix_ExternalReceiveRequestB := FALSE,
	                                            ix_ExternalReceiveRequestC := NOT #iqUDT_WorkstationStatus."210".PEC_EoS.PEC,
	                                            ix_ExternalReceiveRequestD := FALSE,
	                                            ix_PECInfeedC := #iqUDT_WorkstationStatus."210".PEC_EoS.PEC,
	                                            qUDT_HMIRATStatus => #iqUDT_WorkstationStatus."221".RightAngledTransfer,
	                                            qUDT_HMIConveyorStatus => #iqUDT_WorkstationStatus."220".Conveyor,
	                                            qUDT_HMIPECStatus => #iqUDT_WorkstationStatus."221".PEC_EoS,
	                                            qUDT_RATStatus => #iqUDT_WorkstationCommonStatus."221",
	                                            qUDT_ConveyorStatus => #iqUDT_WorkstationCommonStatus."220",
	                                            qx_PopupControl => #qx_PopupControl221,
	                                            qx_ExternalSendRequestA => #tx_dummy,
	                                            qx_ExternalSendRequestB => #tx_dummy,
	                                            qx_ExternalSendRequestC => #tx_dummy,
	                                            qx_ExternalSendRequestD => #tx_dummy,
	                                            iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                            iqUDT_RATCommand := #iqUDT_WorkstationCommands."221".RightAngledTransfer,
	                                            iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."220".Conveyor,
	                                            iqUDT_RATStatistics := #iqUDT_WorkstationStatistics."221".RightAngledTransfer,
	                                            iqUDT_ConveyorStatistics := #iqUDT_WorkstationStatistics."220".Conveyor,
	                                            iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."221".PEC_EoS,
	                                            iqUDT_HandShakeConveyorA := #tUDT_dummyHandshake,
	                                            iqUDT_HandShakeConveyorB := #sUDT_Handshake220,
	                                            iqUDT_HandShakeConveyorC := #sUDT_Handshake210,
	                                            iqUDT_HandShakeConveyorD := #tUDT_dummyHandshake,
	                                            iqUDT_LowerConveyorInterface := #sUDT_Interface220,
	                                            iqUDT_UpperConveyorInterface := #sUDT_Interface221,
	                                            iqUDT_RATPositioning := #iqUDT_RATPositioning220,
	                                            iqUDT_BladeStopEoSInterface := #tUDT_DummyBladeStop,
	                                            iqUDT_BladeStopBoSInterface := #tUDT_DummyBladeStop);
	                
	                
	            END_REGION
	            
	            REGION MCO
	                
	                #sFB_MCOConveyLinxAixController221(iUDT_AixConfig := #iUDT_Configuration."221".MCO_M01,
	                                                   iUDT_AixInputsModule := #iUDT_MotorInput220,
	                                                   ii_PositionSetpoint := #iqUDT_RATPositioning220.Upper.EndPosition,
	                                                   ix_24vOk := #ix_24vOk,
	                                                   ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                   ii_MotorPositionId := 2,
	                                                   ix_StartPositioning := #iqUDT_RATPositioning220.Upper.Start,
	                                                   ix_ResetPosition := #iqUDT_RATPositioning220.Upper.ResetPosition,
	                                                   qUDT_HMIStatus => #iqUDT_WorkstationStatus."221".MCO_M01,
	                                                   qx_Positioned => #iqUDT_RATPositioning220.Upper.Done,
	                                                   iqUDT_AixOutputsModule := #qUDT_MotorOutput220,
	                                                   iqUDT_ConveyorInterface := #sUDT_Interface221,
	                                                   iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."221".MCO_M01);
	            END_REGION
	            
	        END_REGION
	        
	        REGION 230
	            
	            REGION Displacement
	                #sFB_Displacement230(#sUDT_Interface230);
	            END_REGION
	            
	            REGION Conveyor
	                
	                #sFB_Conveyor230(iUDT_ConveyorConfiguration := #iUDT_Configuration."230".Conveyor,
	                                 idi_PECEoSDistance := 0,
	                                 idi_PECBoSDistance := 0,
	                                 ii_ExternalSpeed := 0,
	                                 ix_SafetyOk := #ix_SafetyOk,
	                                 ix_24vOk := #ix_24vOk,
	                                 ix_400vOk := #ix_400vOk,
	                                 ix_HardwareOk := #ix_HardwareOk,
	                                 ix_PECEoS := TRUE,
	                                 ix_PECBoS := TRUE,
	                                 ix_ReverseDirection := FALSE,
	                                 ix_ExternalRequestDieBack := FALSE,
	                                 ix_ExternalRequestHold := FALSE,
	                                 ix_ResetEnergySave := FALSE,
	                                 qUDT_HMIStatus => #iqUDT_WorkstationStatus."230".Conveyor,
	                                 qUDT_Status => #iqUDT_WorkstationCommonStatus."230",
	                                 iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                 iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."230".Conveyor,
	                                 iqUDT_ConveyorInterface := #sUDT_Interface230,
	                                 iqUDT_HandShakeUp := #sUDT_Handshake220,
	                                 iqUDT_HandShake := #sUDT_Handshake230,
	                                 iqUDT_Statistics := #iqUDT_WorkstationStatistics."230".Conveyor);
	                
	            END_REGION
	            
	            REGION MCO
	                
	                #sFB_MCOConveyLinxAixController230(iUDT_AixConfig := #iUDT_Configuration."230".MCO_M01,
	                                                   iUDT_AixInputsModule := #iUDT_MotorInput230,
	                                                   ix_24vOk := #ix_24vOk,
	                                                   ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                   ii_MotorPositionId := 1,
	                                                   qUDT_HMIStatus => #iqUDT_WorkstationStatus."230".MCO_M01,
	                                                   iqUDT_AixOutputsModule := #qUDT_MotorOutput230,
	                                                   iqUDT_ConveyorInterface := #sUDT_Interface230,
	                                                   iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."230".MCO_M01);
	            END_REGION
	        END_REGION
	        
	        REGION 240
	            
	            REGION Displacement
	                #sFB_Displacement240(#sUDT_Interface240);
	            END_REGION
	            
	            REGION EoS               
	                
	                #sFB_PEC240(ix_PEC := #iUDT_MotorInput240.AllSensorPortInputs.LeftSensor,
	                            iUDT_PECConfiguration := #iUDT_Configuration."240".PEC_EoS,
	                            qUDT_HMIStatus => #iqUDT_WorkstationStatus."240".PEC_EoS,
	                            iqUDT_ConveyorInterface := #sUDT_Interface240,
	                            iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."240".PEC_EoS);
	                
	            END_REGION
	            REGION Conveyor
	                
	                #sFB_Conveyor240(iUDT_ConveyorConfiguration := #iUDT_Configuration."240".Conveyor,
	                                 idi_PECEoSDistance := #iUDT_Configuration."240".PEC_EoS.Distance,
	                                 idi_PECBoSDistance := 0,
	                                 ii_ExternalSpeed := 0,
	                                 ix_SafetyOk := #ix_SafetyOk,
	                                 ix_24vOk := #ix_24vOk,
	                                 ix_400vOk := #ix_400vOk,
	                                 ix_HardwareOk := #ix_HardwareOk,
	                                 ix_PECEoS := #iqUDT_WorkstationStatus."240".PEC_EoS.PEC,
	                                 ix_PECBoS := TRUE,
	                                 ix_ReverseDirection := FALSE,
	                                 ix_ExternalRequestDieBack := FALSE,
	                                 ix_ExternalRequestHold := FALSE,
	                                 ix_ResetEnergySave := FALSE,
	                                 qUDT_HMIStatus => #iqUDT_WorkstationStatus."240".Conveyor,
	                                 qUDT_Status => #iqUDT_WorkstationCommonStatus."240",
	                                 iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                 iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."240".Conveyor,
	                                 iqUDT_ConveyorInterface := #sUDT_Interface240,
	                                 iqUDT_HandShakeUp := #sUDT_Handshake230,
	                                 iqUDT_HandShake := #"sUDT_Handshake240",
	                                 iqUDT_Statistics := #iqUDT_WorkstationStatistics."240".Conveyor);
	                
	            END_REGION
	            
	            REGION MCO
	                
	                #sFB_MCOConveyLinxAixController240(iUDT_AixConfig := #iUDT_Configuration."240".MCO_M01,
	                                                   iUDT_AixInputsModule := #iUDT_MotorInput240,
	                                                   ix_24vOk := #ix_24vOk,
	                                                   ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                   ii_MotorPositionId := 1,
	                                                   qUDT_HMIStatus => #iqUDT_WorkstationStatus."240".MCO_M01,
	                                                   iqUDT_AixOutputsModule := #qUDT_MotorOutput240,
	                                                   iqUDT_ConveyorInterface := #sUDT_Interface240,
	                                                   iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."240".MCO_M01);
	            END_REGION
	            
	        END_REGION
	        
	        REGION 250
	            
	            REGION Displacement
	                #sFB_Displacement250(#sUDT_Interface250);
	            END_REGION
	            
	            REGION EoS               
	                
	                #sFB_PEC250(ix_PEC := #iUDT_MotorInput250.AllSensorPortInputs.LeftSensor,
	                            iUDT_PECConfiguration := #iUDT_Configuration."250".PEC_EoS,
	                            qUDT_HMIStatus => #iqUDT_WorkstationStatus."250".PEC_EoS,
	                            iqUDT_ConveyorInterface := #sUDT_Interface250,
	                            iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."250".PEC_EoS);
	                
	            END_REGION
	            REGION Conveyor
	                
	                #sFB_Conveyor250(iUDT_ConveyorConfiguration := #iUDT_Configuration."250".Conveyor,
	                                 idi_PECEoSDistance := #iUDT_Configuration."250".PEC_EoS.Distance,
	                                 idi_PECBoSDistance := 0,
	                                 ii_ExternalSpeed := 0,
	                                 ix_SafetyOk := #ix_SafetyOk,
	                                 ix_24vOk := #ix_24vOk,
	                                 ix_400vOk := #ix_400vOk,
	                                 ix_HardwareOk := #ix_HardwareOk,
	                                 ix_PECEoS := #iqUDT_WorkstationStatus."250".PEC_EoS.PEC,
	                                 ix_PECBoS := TRUE,
	                                 ix_ReverseDirection := FALSE,
	                                 ix_ExternalRequestDieBack := FALSE,
	                                 ix_ExternalRequestHold := FALSE,
	                                 ix_ResetEnergySave := FALSE,
	                                 qUDT_HMIStatus => #iqUDT_WorkstationStatus."250".Conveyor,
	                                 qUDT_Status => #iqUDT_WorkstationCommonStatus."250",
	                                 iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                 iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."250".Conveyor,
	                                 iqUDT_ConveyorInterface := #sUDT_Interface250,
	                                 iqUDT_HandShakeUp := #"sUDT_Handshake240",
	                                 iqUDT_HandShake := #sUDT_Handshake250,
	                                 iqUDT_Statistics := #iqUDT_WorkstationStatistics."250".Conveyor);
	                
	            END_REGION
	            REGION MCO
	                
	                #sFB_MCOConveyLinxAixController250(iUDT_AixConfig := #iUDT_Configuration."250".MCO_M01,
	                                                   iUDT_AixInputsModule := #iUDT_MotorInput250,
	                                                   ix_24vOk := #ix_24vOk,
	                                                   ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                   ii_MotorPositionId := 1,
	                                                   qUDT_HMIStatus => #iqUDT_WorkstationStatus."250".MCO_M01,
	                                                   iqUDT_AixOutputsModule := #qUDT_MotorOutput250,
	                                                   iqUDT_ConveyorInterface := #sUDT_Interface250,
	                                                   iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."250".MCO_M01);
	            END_REGION
	        END_REGION
	        
	        REGION 260
	            
	            REGION Displacement
	                #sFB_Displacement260(#sUDT_Interface260);
	            END_REGION
	            
	            REGION EoS               
	                
	                #sFB_PEC260(ix_PEC := #iUDT_MotorInput260.AllSensorPortInputs.LeftSensor,
	                            iUDT_PECConfiguration := #iUDT_Configuration."260".PEC_EoS,
	                            qUDT_HMIStatus => #iqUDT_WorkstationStatus."260".PEC_EoS,
	                            iqUDT_ConveyorInterface := #sUDT_Interface260,
	                            iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."260".PEC_EoS);
	                
	            END_REGION
	            REGION Conveyor
	                
	                #sFB_Conveyor260(iUDT_ConveyorConfiguration := #iUDT_Configuration."260".Conveyor,
	                                 idi_PECEoSDistance := #iUDT_Configuration."260".PEC_EoS.Distance,
	                                 idi_PECBoSDistance := 0,
	                                 ii_ExternalSpeed := 0,
	                                 ix_SafetyOk := #ix_SafetyOk,
	                                 ix_24vOk := #ix_24vOk,
	                                 ix_400vOk := #ix_400vOk,
	                                 ix_HardwareOk := #ix_HardwareOk,
	                                 ix_PECEoS := #iqUDT_WorkstationStatus."260".PEC_EoS.PEC,
	                                 ix_PECBoS := TRUE,
	                                 ix_ReverseDirection := FALSE,
	                                 ix_ExternalRequestDieBack := FALSE,
	                                 ix_ExternalRequestHold := FALSE,
	                                 ix_ResetEnergySave := FALSE,
	                                 qUDT_HMIStatus => #iqUDT_WorkstationStatus."260".Conveyor,
	                                 qUDT_Status => #iqUDT_WorkstationCommonStatus."260",
	                                 iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                 iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."260".Conveyor,
	                                 iqUDT_ConveyorInterface := #sUDT_Interface260,
	                                 iqUDT_HandShakeUp := #sUDT_Handshake250,
	                                 iqUDT_HandShake := #sUDT_Handshake260,
	                                 iqUDT_Statistics := #iqUDT_WorkstationStatistics."260".Conveyor);
	                
	            END_REGION
	            
	            REGION MCO
	                
	                #sFB_MCOConveyLinxAixController260(iUDT_AixConfig := #iUDT_Configuration."260".MCO_M01,
	                                                   iUDT_AixInputsModule := #iUDT_MotorInput260,
	                                                   ix_24vOk := #ix_24vOk,
	                                                   ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                   ii_MotorPositionId := 1,
	                                                   qUDT_HMIStatus => #iqUDT_WorkstationStatus."260".MCO_M01,
	                                                   iqUDT_AixOutputsModule := #qUDT_MotorOutput260,
	                                                   iqUDT_ConveyorInterface := #sUDT_Interface260,
	                                                   iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."260".MCO_M01);
	            END_REGION
	        END_REGION
	        
	        REGION 270
	            
	            REGION Displacement
	                #sFB_Displacement270(#sUDT_Interface270);
	            END_REGION
	            
	            REGION Conveyor
	                
	                #sFB_Conveyor270(iUDT_ConveyorConfiguration := #iUDT_Configuration."270".Conveyor,
	                                 idi_PECEoSDistance := 0,
	                                 idi_PECBoSDistance := 0,
	                                 ii_ExternalSpeed := 0,
	                                 ix_SafetyOk := #ix_SafetyOk,
	                                 ix_24vOk := #ix_24vOk,
	                                 ix_400vOk := #ix_400vOk,
	                                 ix_HardwareOk := #ix_HardwareOk,
	                                 ix_PECEoS := TRUE,
	                                 ix_PECBoS := TRUE,
	                                 ix_ReverseDirection := FALSE,
	                                 ix_ExternalRequestDieBack := FALSE,
	                                 ix_ExternalRequestHold := FALSE,
	                                 ix_ResetEnergySave := FALSE,
	                                 qUDT_HMIStatus => #iqUDT_WorkstationStatus."270".Conveyor,
	                                 qUDT_Status => #iqUDT_WorkstationCommonStatus."270",
	                                 iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                 iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."270".Conveyor,
	                                 iqUDT_ConveyorInterface := #sUDT_Interface270,
	                                 iqUDT_HandShakeUp := #sUDT_Handshake260,
	                                 iqUDT_HandShake := #sUDT_Handshake270,
	                                 iqUDT_Statistics := #iqUDT_WorkstationStatistics."270".Conveyor);
	                
	            END_REGION
	            
	            REGION MCO
	                
	                #sFB_MCOConveyLinxAixController270(iUDT_AixConfig := #iUDT_Configuration."270".MCO_M01,
	                                                   iUDT_AixInputsModule := #iUDT_MotorInput270,
	                                                   ix_24vOk := #ix_24vOk,
	                                                   ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                   ii_MotorPositionId := 1,
	                                                   qUDT_HMIStatus => #iqUDT_WorkstationStatus."270".MCO_M01,
	                                                   iqUDT_AixOutputsModule := #qUDT_MotorOutput270,
	                                                   iqUDT_ConveyorInterface := #sUDT_Interface270,
	                                                   iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."270".MCO_M01);
	            END_REGION
	        END_REGION
	        
	        REGION 280
	            
	            REGION Displacement
	                #sFB_Displacement280(#sUDT_Interface280);
	            END_REGION
	            
	            REGION EoS               
	                
	                #sFB_PEC280(ix_PEC := #iUDT_MotorInput280.AllSensorPortInputs.LeftSensor,
	                            iUDT_PECConfiguration := #iUDT_Configuration."280".PEC_EoS,
	                            qUDT_HMIStatus => #iqUDT_WorkstationStatus."280".PEC_EoS,
	                            iqUDT_ConveyorInterface := #sUDT_Interface280,
	                            iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."280".PEC_EoS);
	                
	            END_REGION
	            
	            REGION Scanner
	                
	                #sFB_CognexDM280(iUDT_CognexDM260_IN := #iUDT_ScannerInput280,
	                                 iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                 ix_Trigger := NOT #iqUDT_WorkstationStatus."280".PEC_EoS.PEC,
	                                 qUDT_CognexDM260_OUT => #qUDT_ScannerOutput280,
	                                 qs_Barcode => #ss_Barcode280,
	                                 qw_RetVal => #tw_dummy);
	                
	            END_REGION
	            
	            REGION Conveyor
	                
	                #sUDT_Handshake280.RTR := #sUDT_Handshake280.RTR OR #iqUDT_WorkstationStatus."280".PEC_EoS.PEC;
	                
	                #sFB_Conveyor280(iUDT_ConveyorConfiguration := #iUDT_Configuration."280".Conveyor,
	                                 idi_PECEoSDistance := #iUDT_Configuration."280".PEC_EoS.Distance,
	                                 idi_PECBoSDistance := 0,
	                                 ii_ExternalSpeed := 0,
	                                 ix_SafetyOk := #ix_SafetyOk,
	                                 ix_24vOk := #ix_24vOk,
	                                 ix_400vOk := #ix_400vOk,
	                                 ix_HardwareOk := #ix_HardwareOk,
	                                 ix_PECEoS := #iqUDT_WorkstationStatus."280".PEC_EoS.PEC,
	                                 ix_PECBoS := TRUE,
	                                 ix_ReverseDirection := FALSE,
	                                 ix_ExternalRequestDieBack := FALSE,
	                                 ix_ExternalRequestHold := FALSE,
	                                 ix_ResetEnergySave := FALSE,
	                                 qUDT_HMIStatus => #iqUDT_WorkstationStatus."280".Conveyor,
	                                 qUDT_Status => #iqUDT_WorkstationCommonStatus."280",
	                                 iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                 iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."280".Conveyor,
	                                 iqUDT_ConveyorInterface := #sUDT_Interface280,
	                                 iqUDT_HandShakeUp := #sUDT_Handshake270,
	                                 iqUDT_HandShake := #sUDT_Handshake280,
	                                 iqUDT_Statistics := #iqUDT_WorkstationStatistics."280".Conveyor);
	                
	            END_REGION
	            
	            REGION MCO
	                
	                #sFB_MCOConveyLinxAixController280(iUDT_AixConfig := #iUDT_Configuration."280".MCO_M01,
	                                                   iUDT_AixInputsModule := #iUDT_MotorInput280,
	                                                   ix_24vOk := #ix_24vOk,
	                                                   ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                   ii_MotorPositionId := 1,
	                                                   qUDT_HMIStatus => #iqUDT_WorkstationStatus."280".MCO_M01,
	                                                   iqUDT_AixOutputsModule := #qUDT_MotorOutput280,
	                                                   iqUDT_ConveyorInterface := #sUDT_Interface280,
	                                                   iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."280".MCO_M01);
	            END_REGION
	        END_REGION
	        
	        
	        REGION 290
	            
	            REGION Displacement
	                #sFB_Displacement290(#sUDT_Interface290);
	            END_REGION
	            
	            REGION MCO
	                
	                #sFB_MCOConveyLinxAixController290(iUDT_AixConfig := #iUDT_Configuration."290".MCO_M01,
	                                                   iUDT_AixInputsModule := #iUDT_MotorInput290,
	                                                   ii_PositionSetpoint := #iqUDT_RATPositioning290.Lower.EndPosition,
	                                                   ix_24vOk := #ix_24vOk,
	                                                   ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                   ii_MotorPositionId := 1,
	                                                   ix_StartPositioning := #iqUDT_RATPositioning290.Lower.Start,
	                                                   ix_ResetPosition := #iqUDT_RATPositioning290.Lower.ResetPosition,
	                                                   qUDT_HMIStatus => #iqUDT_WorkstationStatus."290".MCO_M01,
	                                                   qx_Positioned => #iqUDT_RATPositioning290.Lower.Done,
	                                                   iqUDT_AixOutputsModule := #qUDT_MotorOutput290,
	                                                   iqUDT_ConveyorInterface := #sUDT_Interface290,
	                                                   iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."290".MCO_M01);
	            END_REGION
	        END_REGION
	        
	        REGION 291
	            
	            REGION Displacement
	                #sFB_Displacement291(#sUDT_Interface291);
	            END_REGION
	            
	            REGION RAT
	                
	                #sFB_RightAngledTransfer291(iUDT_Configuration := #iUDT_Configuration."291".RightAngledTransfer,
	                                            iUDT_LowerConveyorConfiguration := #iUDT_Configuration."290".Conveyor,
	                                            iUDT_UpperConveyorConfiguration := #iUDT_Configuration."291".Conveyor,
	                                            iUDT_PECConfiguration := #iUDT_Configuration."290".PEC_EoS,
	                                            ii_DestinationA := #si_DestinationA291,
	                                            ii_DestinationB := 0,
	                                            ii_DestinationC := 0,
	                                            ii_DestinationD := 0,
	                                            ix_HardwareOk := #ix_HardwareOk,
	                                            ix_400vOk := #ix_400vOk,
	                                            ix_24vOk := #ix_24vOk,
	                                            ix_SafetyOk := #ix_SafetyOk,
	                                            ix_AirPressureOk := #ix_AirPressureOk,
	                                            ix_SectionIsDown := #ix_SectionIsDown291,
	                                            ix_SectionIsUp := #ix_SectionIsUp291,
	                                            ix_ConveyorAAuto := #iqUDT_WorkstationCommonStatus."280".AutoON,
	                                            ix_ConveyorBAuto := FALSE,
	                                            ix_ConveyorCAuto := #iqUDT_WorkstationCommonStatus."300".AutoON,
	                                            ix_ConveyorDAuto := FALSE,
	                                            ix_PEC := #iUDT_MotorInput290.AllSensorPortInputs.LeftSensor,
	                                            ix_ExternalReceiveRequestA := NOT #iqUDT_WorkstationStatus."280".PEC_EoS.PEC,
	                                            ix_ExternalReceiveRequestB := FALSE,
	                                            ix_ExternalReceiveRequestC := FALSE,
	                                            ix_ExternalReceiveRequestD := FALSE,
	                                            ix_PECInfeedA := #iqUDT_WorkstationStatus."280".PEC_EoS.PEC,
	                                            qUDT_HMIRATStatus => #iqUDT_WorkstationStatus."291".RightAngledTransfer,
	                                            qUDT_HMIConveyorStatus => #iqUDT_WorkstationStatus."290".Conveyor,
	                                            qUDT_HMIPECStatus => #iqUDT_WorkstationStatus."291".PEC_EoS,
	                                            qUDT_RATStatus => #iqUDT_WorkstationCommonStatus."291",
	                                            qUDT_ConveyorStatus => #iqUDT_WorkstationCommonStatus."290",
	                                            qx_PopupControl => #qx_PopupControl291,
	                                            qx_ExternalSendRequestA => #tx_dummy,
	                                            qx_ExternalSendRequestB => #tx_dummy,
	                                            qx_ExternalSendRequestC => #tx_dummy,
	                                            qx_ExternalSendRequestD => #tx_dummy,
	                                            iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                            iqUDT_RATCommand := #iqUDT_WorkstationCommands."291".RightAngledTransfer,
	                                            iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."290".Conveyor,
	                                            iqUDT_RATStatistics := #iqUDT_WorkstationStatistics."291".RightAngledTransfer,
	                                            iqUDT_ConveyorStatistics := #iqUDT_WorkstationStatistics."290".Conveyor,
	                                            iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."291".PEC_EoS,
	                                            iqUDT_HandShakeConveyorA := #sUDT_Handshake280,
	                                            iqUDT_HandShakeConveyorB := #tUDT_dummyHandshake,
	                                            iqUDT_HandShakeConveyorC := #sUDT_HandshakeUp291,
	                                            iqUDT_HandShakeConveyorD := #tUDT_dummyHandshake,
	                                            iqUDT_LowerConveyorInterface := #sUDT_Interface290,
	                                            iqUDT_UpperConveyorInterface := #sUDT_Interface291,
	                                            iqUDT_RATPositioning := #iqUDT_RATPositioning290,
	                                            iqUDT_BladeStopEoSInterface := #tUDT_DummyBladeStop,
	                                            iqUDT_BladeStopBoSInterface := #tUDT_DummyBladeStop);
	                
	            END_REGION
	            
	            REGION MCO
	                
	                #sFB_MCOConveyLinxAixController291(iUDT_AixConfig := #iUDT_Configuration."291".MCO_M01,
	                                                   iUDT_AixInputsModule := #iUDT_MotorInput290,
	                                                   ix_24vOk := #ix_24vOk,
	                                                   ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                   ii_MotorPositionId := 2,
	                                                   qUDT_HMIStatus => #iqUDT_WorkstationStatus."291".MCO_M01,
	                                                   iqUDT_AixOutputsModule := #qUDT_MotorOutput290,
	                                                   iqUDT_ConveyorInterface := #sUDT_Interface291,
	                                                   iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."290".MCO_M01);
	            END_REGION
	            
	        END_REGION
	        
	        REGION 300
	            
	            REGION Displacement
	                #sFB_Displacement300(#sUDT_Interface300);
	            END_REGION
	            
	            REGION EoS               
	                
	                #sFB_PEC300(ix_PEC := #iUDT_MotorInput300.AllSensorPortInputs.LeftSensor,
	                            iUDT_PECConfiguration := #iUDT_Configuration."300".PEC_EoS,
	                            qUDT_HMIStatus => #iqUDT_WorkstationStatus."300".PEC_EoS,
	                            iqUDT_ConveyorInterface := #sUDT_Interface300,
	                            iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."300".PEC_EoS);
	                
	            END_REGION
	            REGION Conveyor
	                
	                #sUDT_Handshake300.RTR := #sUDT_Handshake300.RTR OR #iqUDT_WorkstationStatus."300".PEC_EoS.PEC;
	                
	                #sFB_Conveyor300(iUDT_ConveyorConfiguration := #iUDT_Configuration."300".Conveyor,
	                                 idi_PECEoSDistance := #iUDT_Configuration."300".PEC_EoS.Distance,
	                                 idi_PECBoSDistance := 0,
	                                 ii_ExternalSpeed := 0,
	                                 ix_SafetyOk := #ix_SafetyOk,
	                                 ix_24vOk := #ix_24vOk,
	                                 ix_400vOk := #ix_400vOk,
	                                 ix_HardwareOk := #ix_HardwareOk,
	                                 ix_PECEoS := #iqUDT_WorkstationStatus."300".PEC_EoS.PEC,
	                                 ix_PECBoS := TRUE,
	                                 ix_ReverseDirection := FALSE,
	                                 ix_ExternalRequestDieBack := FALSE,
	                                 ix_ExternalRequestHold := FALSE,
	                                 ix_ResetEnergySave := FALSE,
	                                 qUDT_HMIStatus => #iqUDT_WorkstationStatus."300".Conveyor,
	                                 qUDT_Status => #iqUDT_WorkstationCommonStatus."300",
	                                 iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                 iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."300".Conveyor,
	                                 iqUDT_ConveyorInterface := #sUDT_Interface300,
	                                 iqUDT_HandShakeUp := #sUDT_HandshakeUp291,
	                                 iqUDT_HandShake := #sUDT_Handshake300,
	                                 iqUDT_Statistics := #iqUDT_WorkstationStatistics."300".Conveyor);
	                
	            END_REGION
	            REGION MCO
	                
	                #sFB_MCOConveyLinxAixController300(iUDT_AixConfig := #iUDT_Configuration."300".MCO_M01,
	                                                   iUDT_AixInputsModule := #iUDT_MotorInput300,
	                                                   ix_24vOk := #ix_24vOk,
	                                                   ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                   ii_MotorPositionId := 1,
	                                                   qUDT_HMIStatus => #iqUDT_WorkstationStatus."300".MCO_M01,
	                                                   iqUDT_AixOutputsModule := #qUDT_MotorOutput300,
	                                                   iqUDT_ConveyorInterface := #sUDT_Interface300,
	                                                   iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."300".MCO_M01);
	            END_REGION
	        END_REGION
	    END_IF;
	END_REGION
	
	REGION 5 - Left Station
	    IF #iUDT_Configuration.GlobalConfig.LeftStationExists THEN
	        REGION 410
	            
	            REGION Displacement
	                #sFB_Displacement410(#sUDT_Interface410);
	            END_REGION
	            
	            REGION EoS               
	                
	                #sFB_PEC410(ix_PEC := #iUDT_MotorInput410.AllSensorPortInputs.LeftSensor,
	                            iUDT_PECConfiguration := #iUDT_Configuration."410".PEC_EoS,
	                            qUDT_HMIStatus => #iqUDT_WorkstationStatus."410".PEC_EoS,
	                            iqUDT_ConveyorInterface := #sUDT_Interface410,
	                            iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."410".PEC_EoS);
	                
	            END_REGION
	            REGION Conveyor
	                
	                #sUDT_Handshake410.RTR := #sUDT_Handshake410.RTR OR #iqUDT_WorkstationStatus."410".PEC_EoS.PEC;
	                
	                #sFB_Conveyor410(iUDT_ConveyorConfiguration := #iUDT_Configuration."410".Conveyor,
	                                 idi_PECEoSDistance := #iUDT_Configuration."410".PEC_EoS.Distance,
	                                 idi_PECBoSDistance := 0,
	                                 ii_ExternalSpeed := 0,
	                                 ix_SafetyOk := #ix_SafetyOk,
	                                 ix_24vOk := #ix_24vOk,
	                                 ix_400vOk := #ix_400vOk,
	                                 ix_HardwareOk := #ix_HardwareOk,
	                                 ix_PECEoS := #iqUDT_WorkstationStatus."410".PEC_EoS.PEC,
	                                 ix_PECBoS := TRUE,
	                                 ix_ReverseDirection := FALSE,
	                                 ix_ExternalRequestDieBack := FALSE,
	                                 ix_ExternalRequestHold := FALSE,
	                                 ix_ResetEnergySave := FALSE,
	                                 qUDT_HMIStatus => #iqUDT_WorkstationStatus."410".Conveyor,
	                                 qUDT_Status => #iqUDT_WorkstationCommonStatus."410",
	                                 iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                 iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."410".Conveyor,
	                                 iqUDT_ConveyorInterface := #sUDT_Interface410,
	                                 iqUDT_HandShakeUp := #sUDT_Handshake121,
	                                 iqUDT_HandShake := #sUDT_Handshake410,
	                                 iqUDT_Statistics := #iqUDT_WorkstationStatistics."410".Conveyor);
	                
	            END_REGION
	            REGION MCO
	                
	                #sFB_MCOConveyLinxAixController410(iUDT_AixConfig := #iUDT_Configuration."410".MCO_M01,
	                                                   iUDT_AixInputsModule := #iUDT_MotorInput410,
	                                                   ix_24vOk := #ix_24vOk,
	                                                   ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                   ii_MotorPositionId := 1,
	                                                   qUDT_HMIStatus => #iqUDT_WorkstationStatus."410".MCO_M01,
	                                                   iqUDT_AixOutputsModule := #qUDT_MotorOutput410,
	                                                   iqUDT_ConveyorInterface := #sUDT_Interface410,
	                                                   iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."410".MCO_M01);
	            END_REGION
	        END_REGION
	        
	        REGION 420
	            
	            REGION Displacement
	                #sFB_Displacement420(#sUDT_Interface420);
	            END_REGION
	            
	            REGION MCO
	                
	                #sFB_MCOConveyLinxAixController420(iUDT_AixConfig := #iUDT_Configuration."420".MCO_M01,
	                                                   iUDT_AixInputsModule := #iUDT_MotorInput420,
	                                                   ix_24vOk := #ix_24vOk,
	                                                   ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                   ii_MotorPositionId := 1,
	                                                   qUDT_HMIStatus => #iqUDT_WorkstationStatus."420".MCO_M01,
	                                                   iqUDT_AixOutputsModule := #qUDT_MotorOutput420,
	                                                   iqUDT_ConveyorInterface := #sUDT_Interface420,
	                                                   iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."420".MCO_M01);
	            END_REGION
	        END_REGION
	        
	        REGION 421
	            
	            REGION Displacement
	                #sFB_Displacement421(#sUDT_Interface421);
	            END_REGION
	            
	            REGION RAT
	                
	                #sFB_RightAngledTransfer421(iUDT_Configuration := #iUDT_Configuration."421".RightAngledTransfer,
	                                            iUDT_LowerConveyorConfiguration := #iUDT_Configuration."420".Conveyor,
	                                            iUDT_UpperConveyorConfiguration := #iUDT_Configuration."421".Conveyor,
	                                            iUDT_PECConfiguration := #iUDT_Configuration."420".PEC_EoS,
	                                            ii_DestinationA := 0,
	                                            ii_DestinationB := 0,
	                                            ii_DestinationC := 0,
	                                            ii_DestinationD := 1,
	                                            ix_HardwareOk := #ix_HardwareOk,
	                                            ix_400vOk := #ix_400vOk,
	                                            ix_24vOk := #ix_24vOk,
	                                            ix_SafetyOk := #ix_SafetyOk,
	                                            ix_AirPressureOk := #ix_AirPressureOk,
	                                            ix_SectionIsDown := #ix_SectionIsDown421,
	                                            ix_SectionIsUp := #ix_SectionIsUp421,
	                                            ix_ConveyorAAuto := FALSE,
	                                            ix_ConveyorBAuto := #iqUDT_WorkstationCommonStatus."430".AutoON,
	                                            ix_ConveyorCAuto := FALSE,
	                                            ix_ConveyorDAuto := #iqUDT_WorkstationCommonStatus."410".AutoON,
	                                            ix_PEC := #iUDT_MotorInput420.AllSensorPortInputs.LeftSensor,
	                                            ix_ExternalReceiveRequestA := FALSE,
	                                            ix_ExternalReceiveRequestB := FALSE,
	                                            ix_ExternalReceiveRequestC := FALSE,
	                                            ix_ExternalReceiveRequestD := NOT #iqUDT_WorkstationStatus."410".PEC_EoS.PEC,
	                                            ix_PECInfeedA := false,
	                                            ix_PECInfeedD := #iqUDT_WorkstationStatus."410".PEC_EoS.PEC,
	                                            qUDT_HMIRATStatus => #iqUDT_WorkstationStatus."421".RightAngledTransfer,
	                                            qUDT_HMIConveyorStatus => #iqUDT_WorkstationStatus."420".Conveyor,
	                                            qUDT_HMIPECStatus => #iqUDT_WorkstationStatus."421".PEC_EoS,
	                                            qUDT_RATStatus => #iqUDT_WorkstationCommonStatus."421",
	                                            qUDT_ConveyorStatus => #iqUDT_WorkstationCommonStatus."420",
	                                            qx_PopupControl => #qx_PopupControl421,
	                                            qx_ExternalSendRequestA => #tx_dummy,
	                                            qx_ExternalSendRequestB => #tx_dummy,
	                                            qx_ExternalSendRequestC => #tx_dummy,
	                                            qx_ExternalSendRequestD => #tx_dummy,
	                                            iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                            iqUDT_RATCommand := #iqUDT_WorkstationCommands."421".RightAngledTransfer,
	                                            iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."420".Conveyor,
	                                            iqUDT_RATStatistics := #iqUDT_WorkstationStatistics."421".RightAngledTransfer,
	                                            iqUDT_ConveyorStatistics := #iqUDT_WorkstationStatistics."420".Conveyor,
	                                            iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."421".PEC_EoS,
	                                            iqUDT_HandShakeConveyorA := #tUDT_dummyHandshake,
	                                            iqUDT_HandShakeConveyorB := #sUDT_Handshake420,
	                                            iqUDT_HandShakeConveyorC := #tUDT_dummyHandshake,
	                                            iqUDT_HandShakeConveyorD := #sUDT_Handshake410,
	                                            iqUDT_LowerConveyorInterface := #sUDT_Interface420,
	                                            iqUDT_UpperConveyorInterface := #sUDT_Interface421,
	                                            iqUDT_RATPositioning := #iqUDT_RATPositioning420,
	                                            iqUDT_BladeStopEoSInterface := #tUDT_DummyBladeStop,
	                                            iqUDT_BladeStopBoSInterface := #tUDT_DummyBladeStop);
	                
	            END_REGION
	            
	            REGION MCO
	                
	                #sFB_MCOConveyLinxAixController421(iUDT_AixConfig := #iUDT_Configuration."421".MCO_M01,
	                                                   iUDT_AixInputsModule := #iUDT_MotorInput420,
	                                                   ii_PositionSetpoint := #iqUDT_RATPositioning420.Upper.EndPosition,
	                                                   ix_24vOk := #ix_24vOk,
	                                                   ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                   ii_MotorPositionId := 2,
	                                                   ix_StartPositioning := #iqUDT_RATPositioning420.Upper.Start,
	                                                   ix_ResetPosition := #iqUDT_RATPositioning420.Upper.ResetPosition,
	                                                   qUDT_HMIStatus => #iqUDT_WorkstationStatus."421".MCO_M01,
	                                                   qx_Positioned => #iqUDT_RATPositioning420.Upper.Done,
	                                                   iqUDT_AixOutputsModule := #qUDT_MotorOutput420,
	                                                   iqUDT_ConveyorInterface := #sUDT_Interface421,
	                                                   iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."421".MCO_M01);
	            END_REGION
	            
	        END_REGION
	        
	        REGION 430
	            
	            REGION Displacement
	                #sFB_Displacement430(#sUDT_Interface430);
	            END_REGION
	            
	            REGION Conveyor
	                
	                #sFB_Conveyor430(iUDT_ConveyorConfiguration := #iUDT_Configuration."430".Conveyor,
	                                 idi_PECEoSDistance := 0,
	                                 idi_PECBoSDistance := 0,
	                                 ii_ExternalSpeed := 0,
	                                 ix_SafetyOk := #ix_SafetyOk,
	                                 ix_24vOk := #ix_24vOk,
	                                 ix_400vOk := #ix_400vOk,
	                                 ix_HardwareOk := #ix_HardwareOk,
	                                 ix_PECEoS := TRUE,
	                                 ix_PECBoS := TRUE,
	                                 ix_ReverseDirection := FALSE,
	                                 ix_ExternalRequestDieBack := FALSE,
	                                 ix_ExternalRequestHold := FALSE,
	                                 ix_ResetEnergySave := FALSE,
	                                 qUDT_HMIStatus => #iqUDT_WorkstationStatus."430".Conveyor,
	                                 qUDT_Status => #iqUDT_WorkstationCommonStatus."430",
	                                 iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                 iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."430".Conveyor,
	                                 iqUDT_ConveyorInterface := #sUDT_Interface430,
	                                 iqUDT_HandShakeUp := #sUDT_Handshake420,
	                                 iqUDT_HandShake := #sUDT_Handshake430,
	                                 iqUDT_Statistics := #iqUDT_WorkstationStatistics."430".Conveyor);
	                
	            END_REGION
	            REGION MCO
	                
	                #sFB_MCOConveyLinxAixController430(iUDT_AixConfig := #iUDT_Configuration."430".MCO_M01,
	                                                   iUDT_AixInputsModule := #iUDT_MotorInput430,
	                                                   ix_24vOk := #ix_24vOk,
	                                                   ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                   ii_MotorPositionId := 1,
	                                                   qUDT_HMIStatus => #iqUDT_WorkstationStatus."430".MCO_M01,
	                                                   iqUDT_AixOutputsModule := #qUDT_MotorOutput430,
	                                                   iqUDT_ConveyorInterface := #sUDT_Interface430,
	                                                   iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."430".MCO_M01);
	            END_REGION
	        END_REGION
	        
	        REGION 440
	            
	            REGION Displacement
	                #sFB_Displacement440(#sUDT_Interface440);
	            END_REGION
	            
	            REGION EoS               
	                
	                #sFB_PEC440(ix_PEC := #iUDT_MotorInput440.AllSensorPortInputs.LeftSensor,
	                            iUDT_PECConfiguration := #iUDT_Configuration."440".PEC_EoS,
	                            qUDT_HMIStatus => #iqUDT_WorkstationStatus."440".PEC_EoS,
	                            iqUDT_ConveyorInterface := #sUDT_Interface440,
	                            iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."440".PEC_EoS);
	                
	            END_REGION
	            REGION Conveyor
	                
	                #sFB_Conveyor440(iUDT_ConveyorConfiguration := #iUDT_Configuration."440".Conveyor,
	                                 idi_PECEoSDistance := #iUDT_Configuration."440".PEC_EoS.Distance,
	                                 idi_PECBoSDistance := 0,
	                                 ii_ExternalSpeed := 0,
	                                 ix_SafetyOk := #ix_SafetyOk,
	                                 ix_24vOk := #ix_24vOk,
	                                 ix_400vOk := #ix_400vOk,
	                                 ix_HardwareOk := #ix_HardwareOk,
	                                 ix_PECEoS := #iqUDT_WorkstationStatus."440".PEC_EoS.PEC,
	                                 ix_PECBoS := TRUE,
	                                 ix_ReverseDirection := FALSE,
	                                 ix_ExternalRequestDieBack := FALSE,
	                                 ix_ExternalRequestHold := FALSE,
	                                 ix_ResetEnergySave := FALSE,
	                                 qUDT_HMIStatus => #iqUDT_WorkstationStatus."440".Conveyor,
	                                 qUDT_Status => #iqUDT_WorkstationCommonStatus."440",
	                                 iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                 iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."440".Conveyor,
	                                 iqUDT_ConveyorInterface := #sUDT_Interface440,
	                                 iqUDT_HandShakeUp := #sUDT_Handshake430,
	                                 iqUDT_HandShake := #sUDT_Handshake440,
	                                 iqUDT_Statistics := #iqUDT_WorkstationStatistics."440".Conveyor);
	                
	            END_REGION
	            
	            REGION MCO
	                
	                #sFB_MCOConveyLinxAixController440(iUDT_AixConfig := #iUDT_Configuration."440".MCO_M01,
	                                                   iUDT_AixInputsModule := #iUDT_MotorInput440,
	                                                   ix_24vOk := #ix_24vOk,
	                                                   ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                   ii_MotorPositionId := 1,
	                                                   qUDT_HMIStatus => #iqUDT_WorkstationStatus."440".MCO_M01,
	                                                   iqUDT_AixOutputsModule := #qUDT_MotorOutput440,
	                                                   iqUDT_ConveyorInterface := #sUDT_Interface440,
	                                                   iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."440".MCO_M01);
	            END_REGION
	        END_REGION
	        
	        REGION 450
	            
	            REGION Displacement
	                #sFB_Displacement450(#sUDT_Interface450);
	            END_REGION
	            
	            REGION EoS               
	                
	                #sFB_PEC450(ix_PEC := #iUDT_MotorInput450.AllSensorPortInputs.LeftSensor,
	                            iUDT_PECConfiguration := #iUDT_Configuration."450".PEC_EoS,
	                            qUDT_HMIStatus => #iqUDT_WorkstationStatus."450".PEC_EoS,
	                            iqUDT_ConveyorInterface := #sUDT_Interface450,
	                            iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."450".PEC_EoS);
	                
	            END_REGION
	            REGION Conveyor
	                
	                #sFB_Conveyor450(iUDT_ConveyorConfiguration := #iUDT_Configuration."450".Conveyor,
	                                 idi_PECEoSDistance := #iUDT_Configuration."450".PEC_EoS.Distance,
	                                 idi_PECBoSDistance := 0,
	                                 ii_ExternalSpeed := 0,
	                                 ix_SafetyOk := #ix_SafetyOk,
	                                 ix_24vOk := #ix_24vOk,
	                                 ix_400vOk := #ix_400vOk,
	                                 ix_HardwareOk := #ix_HardwareOk,
	                                 ix_PECEoS := #iqUDT_WorkstationStatus."450".PEC_EoS.PEC,
	                                 ix_PECBoS := TRUE,
	                                 ix_ReverseDirection := FALSE,
	                                 ix_ExternalRequestDieBack := FALSE,
	                                 ix_ExternalRequestHold := FALSE,
	                                 ix_ResetEnergySave := FALSE,
	                                 qUDT_HMIStatus => #iqUDT_WorkstationStatus."450".Conveyor,
	                                 qUDT_Status => #iqUDT_WorkstationCommonStatus."450",
	                                 iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                 iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."450".Conveyor,
	                                 iqUDT_ConveyorInterface := #sUDT_Interface450,
	                                 iqUDT_HandShakeUp := #sUDT_Handshake440,
	                                 iqUDT_HandShake := #sUDT_Handshake450,
	                                 iqUDT_Statistics := #iqUDT_WorkstationStatistics."450".Conveyor);
	                
	            END_REGION
	            REGION MCO
	                
	                #sFB_MCOConveyLinxAixController450(iUDT_AixConfig := #iUDT_Configuration."450".MCO_M01,
	                                                   iUDT_AixInputsModule := #iUDT_MotorInput450,
	                                                   ix_24vOk := #ix_24vOk,
	                                                   ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                   ii_MotorPositionId := 1,
	                                                   qUDT_HMIStatus => #iqUDT_WorkstationStatus."450".MCO_M01,
	                                                   iqUDT_AixOutputsModule := #qUDT_MotorOutput450,
	                                                   iqUDT_ConveyorInterface := #sUDT_Interface450,
	                                                   iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."450".MCO_M01);
	            END_REGION
	        END_REGION
	        
	        REGION 460
	            
	            REGION Displacement
	                #sFB_Displacement460(#sUDT_Interface460);
	            END_REGION
	            
	            REGION EoS               
	                
	                #sFB_PEC460(ix_PEC := #iUDT_MotorInput460.AllSensorPortInputs.LeftSensor,
	                            iUDT_PECConfiguration := #iUDT_Configuration."460".PEC_EoS,
	                            qUDT_HMIStatus => #iqUDT_WorkstationStatus."460".PEC_EoS,
	                            iqUDT_ConveyorInterface := #sUDT_Interface460,
	                            iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."460".PEC_EoS);
	                
	            END_REGION
	            REGION Conveyor
	                
	                #sFB_Conveyor460(iUDT_ConveyorConfiguration := #iUDT_Configuration."460".Conveyor,
	                                 idi_PECEoSDistance := #iUDT_Configuration."460".PEC_EoS.Distance,
	                                 idi_PECBoSDistance := 0,
	                                 ii_ExternalSpeed := 0,
	                                 ix_SafetyOk := #ix_SafetyOk,
	                                 ix_24vOk := #ix_24vOk,
	                                 ix_400vOk := #ix_400vOk,
	                                 ix_HardwareOk := #ix_HardwareOk,
	                                 ix_PECEoS := #iqUDT_WorkstationStatus."460".PEC_EoS.PEC,
	                                 ix_PECBoS := TRUE,
	                                 ix_ReverseDirection := FALSE,
	                                 ix_ExternalRequestDieBack := FALSE,
	                                 ix_ExternalRequestHold := FALSE,
	                                 ix_ResetEnergySave := FALSE,
	                                 qUDT_HMIStatus => #iqUDT_WorkstationStatus."460".Conveyor,
	                                 qUDT_Status => #iqUDT_WorkstationCommonStatus."460",
	                                 iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                 iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."460".Conveyor,
	                                 iqUDT_ConveyorInterface := #sUDT_Interface460,
	                                 iqUDT_HandShakeUp := #sUDT_Handshake450,
	                                 iqUDT_HandShake := #sUDT_Handshake460,
	                                 iqUDT_Statistics := #iqUDT_WorkstationStatistics."460".Conveyor);
	                
	            END_REGION
	            
	            REGION MCO
	                
	                #sFB_MCOConveyLinxAixController460(iUDT_AixConfig := #iUDT_Configuration."460".MCO_M01,
	                                                   iUDT_AixInputsModule := #iUDT_MotorInput460,
	                                                   ix_24vOk := #ix_24vOk,
	                                                   ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                   ii_MotorPositionId := 1,
	                                                   qUDT_HMIStatus => #iqUDT_WorkstationStatus."460".MCO_M01,
	                                                   iqUDT_AixOutputsModule := #qUDT_MotorOutput460,
	                                                   iqUDT_ConveyorInterface := #sUDT_Interface460,
	                                                   iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."460".MCO_M01);
	            END_REGION
	        END_REGION
	        
	        REGION 470
	            
	            REGION Displacement
	                #sFB_Displacement470(#sUDT_Interface470);
	            END_REGION
	            
	            REGION Conveyor
	                
	                #sFB_Conveyor470(iUDT_ConveyorConfiguration := #iUDT_Configuration."470".Conveyor,
	                                 idi_PECEoSDistance := 0,
	                                 idi_PECBoSDistance := 0,
	                                 ii_ExternalSpeed := 0,
	                                 ix_SafetyOk := #ix_SafetyOk,
	                                 ix_24vOk := #ix_24vOk,
	                                 ix_400vOk := #ix_400vOk,
	                                 ix_HardwareOk := #ix_HardwareOk,
	                                 ix_PECEoS := TRUE,
	                                 ix_PECBoS := TRUE,
	                                 ix_ReverseDirection := FALSE,
	                                 ix_ExternalRequestDieBack := FALSE,
	                                 ix_ExternalRequestHold := FALSE,
	                                 ix_ResetEnergySave := FALSE,
	                                 qUDT_HMIStatus => #iqUDT_WorkstationStatus."470".Conveyor,
	                                 qUDT_Status => #iqUDT_WorkstationCommonStatus."470",
	                                 iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                 iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."470".Conveyor,
	                                 iqUDT_ConveyorInterface := #sUDT_Interface470,
	                                 iqUDT_HandShakeUp := #sUDT_Handshake460,
	                                 iqUDT_HandShake := #sUDT_Handshake470,
	                                 iqUDT_Statistics := #iqUDT_WorkstationStatistics."470".Conveyor);
	                
	            END_REGION
	            REGION MCO
	                
	                #sFB_MCOConveyLinxAixController470(iUDT_AixConfig := #iUDT_Configuration."470".MCO_M01,
	                                                   iUDT_AixInputsModule := #iUDT_MotorInput470,
	                                                   ix_24vOk := #ix_24vOk,
	                                                   ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                   ii_MotorPositionId := 1,
	                                                   qUDT_HMIStatus => #iqUDT_WorkstationStatus."470".MCO_M01,
	                                                   iqUDT_AixOutputsModule := #qUDT_MotorOutput470,
	                                                   iqUDT_ConveyorInterface := #sUDT_Interface470,
	                                                   iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."470".MCO_M01);
	            END_REGION
	        END_REGION
	        
	        REGION 480
	            
	            REGION Displacement
	                #sFB_Displacement480(#sUDT_Interface480);
	            END_REGION
	            
	            REGION EoS               
	                
	                #sFB_PEC480(ix_PEC := #iUDT_MotorInput480.AllSensorPortInputs.LeftSensor,
	                            iUDT_PECConfiguration := #iUDT_Configuration."480".PEC_EoS,
	                            qUDT_HMIStatus => #iqUDT_WorkstationStatus."480".PEC_EoS,
	                            iqUDT_ConveyorInterface := #sUDT_Interface480,
	                            iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."480".PEC_EoS);
	                
	            END_REGION
	            
	            REGION Scanner
	                
	                #sFB_CognexDM480(iUDT_CognexDM260_IN := #iUDT_ScannerInput480,
	                                 iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                 ix_Trigger := NOT #iqUDT_WorkstationStatus."480".PEC_EoS.PEC,
	                                 qUDT_CognexDM260_OUT => #qUDT_ScannerOutput480,
	                                 qs_Barcode => #ss_Barcode480,
	                                 qw_RetVal => #tw_dummy);
	                
	            END_REGION
	            
	            REGION Conveyor
	                
	                #sUDT_Handshake480.RTR := #sUDT_Handshake480.RTR OR #iqUDT_WorkstationStatus."480".PEC_EoS.PEC;
	                
	                #sFB_Conveyor480(iUDT_ConveyorConfiguration := #iUDT_Configuration."480".Conveyor,
	                                 idi_PECEoSDistance := #iUDT_Configuration."480".PEC_EoS.Distance,
	                                 idi_PECBoSDistance := 0,
	                                 ii_ExternalSpeed := 0,
	                                 ix_SafetyOk := #ix_SafetyOk,
	                                 ix_24vOk := #ix_24vOk,
	                                 ix_400vOk := #ix_400vOk,
	                                 ix_HardwareOk := #ix_HardwareOk,
	                                 ix_PECEoS := #iqUDT_WorkstationStatus."480".PEC_EoS.PEC,
	                                 ix_PECBoS := TRUE,
	                                 ix_ReverseDirection := FALSE,
	                                 ix_ExternalRequestDieBack := FALSE,
	                                 ix_ExternalRequestHold := FALSE,
	                                 ix_ResetEnergySave := FALSE,
	                                 qUDT_HMIStatus => #iqUDT_WorkstationStatus."480".Conveyor,
	                                 qUDT_Status => #iqUDT_WorkstationCommonStatus."480",
	                                 iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                 iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."480".Conveyor,
	                                 iqUDT_ConveyorInterface := #sUDT_Interface480,
	                                 iqUDT_HandShakeUp := #sUDT_Handshake470,
	                                 iqUDT_HandShake := #sUDT_Handshake480,
	                                 iqUDT_Statistics := #iqUDT_WorkstationStatistics."480".Conveyor);
	                
	            END_REGION
	            
	            REGION MCO
	                
	                #sFB_MCOConveyLinxAixController480(iUDT_AixConfig := #iUDT_Configuration."480".MCO_M01,
	                                                   iUDT_AixInputsModule := #iUDT_MotorInput480,
	                                                   ix_24vOk := #ix_24vOk,
	                                                   ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                   ii_MotorPositionId := 1,
	                                                   qUDT_HMIStatus => #iqUDT_WorkstationStatus."480".MCO_M01,
	                                                   iqUDT_AixOutputsModule := #qUDT_MotorOutput480,
	                                                   iqUDT_ConveyorInterface := #sUDT_Interface480,
	                                                   iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."480".MCO_M01);
	            END_REGION
	        END_REGION
	        
	        
	        REGION 490
	            
	            REGION Displacement
	                #sFB_Displacement490(#sUDT_Interface490);
	            END_REGION
	            
	            REGION MCO
	                
	                #sFB_MCOConveyLinxAixController490(iUDT_AixConfig := #iUDT_Configuration."490".MCO_M01,
	                                                   iUDT_AixInputsModule := #iUDT_MotorInput490,
	                                                   ii_PositionSetpoint := #iqUDT_RATPositioning490.Lower.EndPosition,
	                                                   ix_24vOk := #ix_24vOk,
	                                                   ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                   ii_MotorPositionId := 1,
	                                                   ix_StartPositioning := #iqUDT_RATPositioning490.Lower.Start,
	                                                   ix_ResetPosition := #iqUDT_RATPositioning490.Lower.ResetPosition,
	                                                   qUDT_HMIStatus => #iqUDT_WorkstationStatus."490".MCO_M01,
	                                                   qx_Positioned => #iqUDT_RATPositioning490.Lower.Done,
	                                                   iqUDT_AixOutputsModule := #qUDT_MotorOutput490,
	                                                   iqUDT_ConveyorInterface := #sUDT_Interface490,
	                                                   iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."490".MCO_M01);
	            END_REGION
	        END_REGION
	        
	        
	        REGION 491
	            
	            REGION Displacement
	                #sFB_Displacement491(#sUDT_Interface491);
	            END_REGION
	            
	            REGION RAT
	                
	                #sFB_RightAngledTransfer491(iUDT_Configuration := #iUDT_Configuration."491".RightAngledTransfer,
	                                            iUDT_LowerConveyorConfiguration := #iUDT_Configuration."490".Conveyor,
	                                            iUDT_UpperConveyorConfiguration := #iUDT_Configuration."491".Conveyor,
	                                            iUDT_PECConfiguration := #iUDT_Configuration."490".PEC_EoS,
	                                            ii_DestinationA := #si_DestinationA491,
	                                            ii_DestinationB := 0,
	                                            ii_DestinationC := 0,
	                                            ii_DestinationD := 0,
	                                            ix_HardwareOk := #ix_HardwareOk,
	                                            ix_400vOk := #ix_400vOk,
	                                            ix_24vOk := #ix_24vOk,
	                                            ix_SafetyOk := #ix_SafetyOk,
	                                            ix_AirPressureOk := #ix_AirPressureOk,
	                                            ix_SectionIsDown := #ix_SectionIsDown491,
	                                            ix_SectionIsUp := #ix_SectionIsUp491,
	                                            ix_ConveyorAAuto := #iqUDT_WorkstationCommonStatus."480".AutoON,
	                                            ix_ConveyorBAuto := FALSE,
	                                            ix_ConveyorCAuto := FALSE,
	                                            ix_ConveyorDAuto := #iqUDT_WorkstationCommonStatus."500".AutoON,
	                                            ix_PEC := #iUDT_MotorInput490.AllSensorPortInputs.LeftSensor,
	                                            ix_ExternalReceiveRequestA := NOT #iqUDT_WorkstationStatus."480".PEC_EoS.PEC,
	                                            ix_ExternalReceiveRequestB := FALSE,
	                                            ix_ExternalReceiveRequestC := FALSE,
	                                            ix_ExternalReceiveRequestD := FALSE,
	                                            ix_PECInfeedA := #iqUDT_WorkstationStatus."480".PEC_EoS.PEC,
	                                            qUDT_HMIRATStatus => #iqUDT_WorkstationStatus."491".RightAngledTransfer,
	                                            qUDT_HMIConveyorStatus => #iqUDT_WorkstationStatus."490".Conveyor,
	                                            qUDT_HMIPECStatus => #iqUDT_WorkstationStatus."491".PEC_EoS,
	                                            qUDT_RATStatus => #iqUDT_WorkstationCommonStatus."491",
	                                            qUDT_ConveyorStatus => #iqUDT_WorkstationCommonStatus."490",
	                                            qx_PopupControl => #qx_PopupControl491,
	                                            qx_ExternalSendRequestA => #tx_dummy,
	                                            qx_ExternalSendRequestB => #tx_dummy,
	                                            qx_ExternalSendRequestC => #tx_dummy,
	                                            qx_ExternalSendRequestD => #tx_dummy,
	                                            iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                            iqUDT_RATCommand := #iqUDT_WorkstationCommands."491".RAT,
	                                            iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."490".Conveyor,
	                                            iqUDT_RATStatistics := #iqUDT_WorkstationStatistics."491".RightAngledTransfer,
	                                            iqUDT_ConveyorStatistics := #iqUDT_WorkstationStatistics."490".Conveyor,
	                                            iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."491".PEC_EoS,
	                                            iqUDT_HandShakeConveyorA := #sUDT_Handshake480,
	                                            iqUDT_HandShakeConveyorB := #tUDT_dummyHandshake,
	                                            iqUDT_HandShakeConveyorC := #tUDT_dummyHandshake,
	                                            iqUDT_HandShakeConveyorD := #sUDT_Handshake491,
	                                            iqUDT_LowerConveyorInterface := #sUDT_Interface490,
	                                            iqUDT_UpperConveyorInterface := #sUDT_Interface491,
	                                            iqUDT_RATPositioning := #iqUDT_RATPositioning490,
	                                            iqUDT_BladeStopEoSInterface := #tUDT_DummyBladeStop,
	                                            iqUDT_BladeStopBoSInterface := #tUDT_DummyBladeStop);
	                
	                
	                
	            END_REGION
	            
	            REGION MCO
	                
	                #sFB_MCOConveyLinxAixController491(iUDT_AixConfig := #iUDT_Configuration."491".MCO_M01,
	                                                   iUDT_AixInputsModule := #iUDT_MotorInput490,
	                                                   ix_24vOk := #ix_24vOk,
	                                                   ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                   ii_MotorPositionId := 2,
	                                                   qUDT_HMIStatus => #iqUDT_WorkstationStatus."491".MCO_M01,
	                                                   iqUDT_AixOutputsModule := #qUDT_MotorOutput490,
	                                                   iqUDT_ConveyorInterface := #sUDT_Interface491,
	                                                   iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."491".MCO_M01);
	            END_REGION
	            
	        END_REGION
	        
	        REGION 500
	            
	            REGION Displacement
	                #sFB_Displacement500(#sUDT_Interface500);
	            END_REGION
	            
	            REGION EoS               
	                
	                #sFB_PEC500(ix_PEC := #iUDT_MotorInput500.AllSensorPortInputs.LeftSensor,
	                            iUDT_PECConfiguration := #iUDT_Configuration."500".PEC_EoS,
	                            qUDT_HMIStatus => #iqUDT_WorkstationStatus."500".PEC_EoS,
	                            iqUDT_ConveyorInterface := #sUDT_Interface500,
	                            iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."500".PEC_EoS);
	                
	            END_REGION
	            REGION Conveyor
	                
	                #sUDT_Handshake500.RTR := #sUDT_Handshake500.RTR OR #iqUDT_WorkstationStatus."500".PEC_EoS.PEC;
	                
	                #sFB_Conveyor500(iUDT_ConveyorConfiguration := #iUDT_Configuration."500".Conveyor,
	                                 idi_PECEoSDistance := #iUDT_Configuration."500".PEC_EoS.Distance,
	                                 idi_PECBoSDistance := 0,
	                                 ii_ExternalSpeed := 0,
	                                 ix_SafetyOk := #ix_SafetyOk,
	                                 ix_24vOk := #ix_24vOk,
	                                 ix_400vOk := #ix_400vOk,
	                                 ix_HardwareOk := #ix_HardwareOk,
	                                 ix_PECEoS := #iqUDT_WorkstationStatus."500".PEC_EoS.PEC,
	                                 ix_PECBoS := TRUE,
	                                 ix_ReverseDirection := FALSE,
	                                 ix_ExternalRequestDieBack := FALSE,
	                                 ix_ExternalRequestHold := FALSE,
	                                 ix_ResetEnergySave := FALSE,
	                                 qUDT_HMIStatus => #iqUDT_WorkstationStatus."500".Conveyor,
	                                 qUDT_Status => #iqUDT_WorkstationCommonStatus."500",
	                                 iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                 iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."500".Conveyor,
	                                 iqUDT_ConveyorInterface := #sUDT_Interface500,
	                                 iqUDT_HandShakeUp := #sUDT_Handshake491,
	                                 iqUDT_HandShake := #sUDT_Handshake500,
	                                 iqUDT_Statistics := #iqUDT_WorkstationStatistics."500".Conveyor);
	                
	            END_REGION
	            REGION MCO
	                
	                #sFB_MCOConveyLinxAixController500(iUDT_AixConfig := #iUDT_Configuration."500".MCO_M01,
	                                                   iUDT_AixInputsModule := #iUDT_MotorInput500,
	                                                   ix_24vOk := #ix_24vOk,
	                                                   ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                   ii_MotorPositionId := 1,
	                                                   qUDT_HMIStatus => #iqUDT_WorkstationStatus."500".MCO_M01,
	                                                   iqUDT_AixOutputsModule := #qUDT_MotorOutput500,
	                                                   iqUDT_ConveyorInterface := #sUDT_Interface500,
	                                                   iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."500".MCO_M01);
	            END_REGION
	        END_REGION
	    END_IF;
	END_REGION
	
	REGION 6 - Station Outfeed
	    REGION 610
	        
	        REGION Displacement
	            #sFB_Displacement610(#sUDT_Interface610);
	        END_REGION
	        
	        REGION MCO
	            
	            #sFB_MCOConveyLinxAixController610(iUDT_AixConfig := #iUDT_Configuration."610".MCO_M01,
	                                               iUDT_AixInputsModule := #iUDT_MotorInput610,
	                                               ix_24vOk := #ix_24vOk,
	                                               ix_SimulationModeActive := "DB_Memory".Simulation,
	                                               ii_MotorPositionId := 1,
	                                               qUDT_HMIStatus => #iqUDT_WorkstationStatus."610".MCO_M01,
	                                               iqUDT_AixOutputsModule := #qUDT_MotorOutput610,
	                                               iqUDT_ConveyorInterface := #sUDT_Interface610,
	                                               iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."610".MCO_M01);
	        END_REGION
	    END_REGION
	    
	    REGION 611
	        
	        REGION Displacement
	            #sFB_Displacement611(#sUDT_Interface611);
	        END_REGION
	        
	        REGION RAT
	            
	            #sFB_RightAngledTransfer611(iUDT_Configuration := #iUDT_Configuration."611".RightAngledTransfer,
	                                        iUDT_LowerConveyorConfiguration := #iUDT_Configuration."610".Conveyor,
	                                        iUDT_UpperConveyorConfiguration := #iUDT_Configuration."611".Conveyor,
	                                        iUDT_PECConfiguration := #iUDT_Configuration."610".PEC_EoS,
	                                        ii_DestinationA := 0,
	                                        ii_DestinationB := 0,
	                                        ii_DestinationC := 1,
	                                        ii_DestinationD := 1,
	                                        ix_HardwareOk := #ix_HardwareOk,
	                                        ix_400vOk := #ix_400vOk,
	                                        ix_24vOk := #ix_24vOk,
	                                        ix_SafetyOk := #ix_SafetyOk,
	                                        ix_AirPressureOk := #ix_AirPressureOk,
	                                        ix_SectionIsDown := #ix_SectionIsDown611,
	                                        ix_SectionIsUp := #ix_SectionIsUp611,
	                                        ix_ConveyorAAuto := TRUE,
	                                        ix_ConveyorBAuto := #iqUDT_WorkstationCommonStatus."620".AutoON,
	                                        ix_ConveyorCAuto := #iqUDT_WorkstationCommonStatus."500".AutoON,
	                                        ix_ConveyorDAuto := #iqUDT_WorkstationCommonStatus."300".AutoON,
	                                        ix_PEC := #iUDT_MotorInput610.AllSensorPortInputs.LeftSensor,
	                                        ix_ExternalReceiveRequestA := FALSE,
	                                        ix_ExternalReceiveRequestB := FALSE,
	                                        ix_ExternalReceiveRequestC := NOT #iqUDT_WorkstationStatus."500".PEC_EoS.PEC,
	                                        ix_ExternalReceiveRequestD := NOT #iqUDT_WorkstationStatus."300".PEC_EoS.PEC,
	                                        ix_PECInfeedC := #iqUDT_WorkstationStatus."500".PEC_EoS.PEC,
	                                        ix_PECInfeedD := #iqUDT_WorkstationStatus."300".PEC_EoS.PEC,
	                                        qUDT_HMIRATStatus => #iqUDT_WorkstationStatus."611".RightAngledTransfer,
	                                        qUDT_HMIConveyorStatus => #iqUDT_WorkstationStatus."610".Conveyor,
	                                        qUDT_HMIPECStatus => #iqUDT_WorkstationStatus."611".PEC_EoS,
	                                        qUDT_RATStatus => #iqUDT_WorkstationCommonStatus."611",
	                                        qUDT_ConveyorStatus => #iqUDT_WorkstationCommonStatus."610",
	                                        qx_PopupControl => #qx_PopupControl611,
	                                        qx_ExternalSendRequestA => #tx_dummy,
	                                        qx_ExternalSendRequestB => #tx_dummy,
	                                        qx_ExternalSendRequestC => #tx_dummy,
	                                        qx_ExternalSendRequestD => #tx_dummy,
	                                        iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                        iqUDT_RATCommand := #iqUDT_WorkstationCommands."611".RightAngledTransfer,
	                                        iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."610".Conveyor,
	                                        iqUDT_RATStatistics := #iqUDT_WorkstationStatistics."611".RightAngledTransfer,
	                                        iqUDT_ConveyorStatistics := #iqUDT_WorkstationStatistics."610".Conveyor,
	                                        iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."611".PEC_EoS,
	                                        iqUDT_HandShakeConveyorA := #tUDT_dummyHandshake,
	                                        iqUDT_HandShakeConveyorB := #sUDT_Handshake610,
	                                        iqUDT_HandShakeConveyorC := #sUDT_Handshake500,
	                                        iqUDT_HandShakeConveyorD := #sUDT_Handshake300,
	                                        iqUDT_LowerConveyorInterface := #sUDT_Interface610,
	                                        iqUDT_UpperConveyorInterface := #sUDT_Interface611,
	                                        iqUDT_RATPositioning := #iqUDT_RATPositioning610,
	                                        iqUDT_BladeStopEoSInterface := #tUDT_DummyBladeStop,
	                                        iqUDT_BladeStopBoSInterface := #tUDT_DummyBladeStop);
	            
	            
	            
	        END_REGION
	        
	        REGION MCO
	            
	            #sFB_MCOConveyLinxAixController611(iUDT_AixConfig := #iUDT_Configuration."611".MCO_M01,
	                                               iUDT_AixInputsModule := #iUDT_MotorInput610,
	                                               ii_PositionSetpoint := #iqUDT_RATPositioning610.Upper.EndPosition,
	                                               ix_24vOk := #ix_24vOk,
	                                               ix_SimulationModeActive := "DB_Memory".Simulation,
	                                               ii_MotorPositionId := 2,
	                                               ix_StartPositioning := #iqUDT_RATPositioning610.Upper.Start,
	                                               ix_ResetPosition := #iqUDT_RATPositioning610.Upper.ResetPosition,
	                                               qUDT_HMIStatus => #iqUDT_WorkstationStatus."611".MCO_M01,
	                                               qx_Positioned => #iqUDT_RATPositioning610.Upper.Done,
	                                               iqUDT_AixOutputsModule := #qUDT_MotorOutput610,
	                                               iqUDT_ConveyorInterface := #sUDT_Interface611,
	                                               iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."611".MCO_M01);
	        END_REGION
	        
	    END_REGION
	    
	    REGION 620
	        
	        REGION Displacement
	            #sFB_Displacement620(#sUDT_Interface620);
	        END_REGION
	        
	        REGION Conveyor
	            
	            #sFB_Conveyor620(iUDT_ConveyorConfiguration := #iUDT_Configuration."620".Conveyor,
	                             idi_PECEoSDistance := 0,
	                             idi_PECBoSDistance := 0,
	                             ii_ExternalSpeed := 0,
	                             ix_SafetyOk := #ix_SafetyOk,
	                             ix_24vOk := #ix_24vOk,
	                             ix_400vOk := #ix_400vOk,
	                             ix_HardwareOk := #ix_HardwareOk,
	                             ix_PECEoS := TRUE,
	                             ix_PECBoS := TRUE,
	                             ix_ReverseDirection := FALSE,
	                             ix_ExternalRequestDieBack := FALSE,
	                             ix_ExternalRequestHold := FALSE,
	                             ix_ResetEnergySave := FALSE,
	                             qUDT_HMIStatus => #iqUDT_WorkstationStatus."620".Conveyor,
	                             qUDT_Status => #iqUDT_WorkstationCommonStatus."620",
	                             iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                             iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."620".Conveyor,
	                             iqUDT_ConveyorInterface := #sUDT_Interface620,
	                             iqUDT_HandShakeUp := #sUDT_Handshake610,
	                             iqUDT_HandShake := #sUDT_Handshake620,
	                             iqUDT_Statistics := #iqUDT_WorkstationStatistics."620".Conveyor);
	            
	        END_REGION
	        
	        REGION MCO
	            
	            #sFB_MCOConveyLinxAixController620(iUDT_AixConfig := #iUDT_Configuration."620".MCO_M01,
	                                               iUDT_AixInputsModule := #iUDT_MotorInput620,
	                                               ix_24vOk := #ix_24vOk,
	                                               ix_SimulationModeActive := "DB_Memory".Simulation,
	                                               ii_MotorPositionId := 1,
	                                               qUDT_HMIStatus => #iqUDT_WorkstationStatus."620".MCO_M01,
	                                               iqUDT_AixOutputsModule := #qUDT_MotorOutput620,
	                                               iqUDT_ConveyorInterface := #sUDT_Interface620,
	                                               iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."620".MCO_M01);
	        END_REGION
	        
	    END_REGION
	    
	    REGION 630
	        
	        REGION Displacement
	            #sFB_Displacement630(#sUDT_Interface630);
	        END_REGION
	        
	        REGION Conveyor
	            
	            #sFB_Conveyor630(iUDT_ConveyorConfiguration := #iUDT_Configuration."630".Conveyor,
	                             idi_PECEoSDistance := 0,
	                             idi_PECBoSDistance := 0,
	                             ii_ExternalSpeed := 0,
	                             ix_SafetyOk := #ix_SafetyOk,
	                             ix_24vOk := #ix_24vOk,
	                             ix_400vOk := #ix_400vOk,
	                             ix_HardwareOk := #ix_HardwareOk,
	                             ix_PECEoS := TRUE,
	                             ix_PECBoS := TRUE,
	                             ix_ReverseDirection := FALSE,
	                             ix_ExternalRequestDieBack := FALSE,
	                             ix_ExternalRequestHold := FALSE,
	                             ix_ResetEnergySave := FALSE,
	                             qUDT_HMIStatus => #iqUDT_WorkstationStatus."630".Conveyor,
	                             qUDT_Status => #iqUDT_WorkstationCommonStatus."630",
	                             iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                             iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."630".Conveyor,
	                             iqUDT_ConveyorInterface := #sUDT_Interface630,
	                             iqUDT_HandShakeUp := #sUDT_Handshake620,
	                             iqUDT_HandShake := #sUDT_Handshake630,
	                             iqUDT_Statistics := #iqUDT_WorkstationStatistics."630".Conveyor);
	            
	        END_REGION
	        
	        REGION MCO
	            
	            #sFB_MCOConveyLinxAixController630(iUDT_AixConfig := #iUDT_Configuration."630".MCO_M01,
	                                               iUDT_AixInputsModule := #iUDT_MotorInput630,
	                                               ix_24vOk := #ix_24vOk,
	                                               ix_SimulationModeActive := "DB_Memory".Simulation,
	                                               ii_MotorPositionId := 1,
	                                               qUDT_HMIStatus => #iqUDT_WorkstationStatus."630".MCO_M01,
	                                               iqUDT_AixOutputsModule := #qUDT_MotorOutput630,
	                                               iqUDT_ConveyorInterface := #sUDT_Interface630,
	                                               iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."630".MCO_M01);
	        END_REGION
	    END_REGION
	    
	    REGION 640
	        
	        REGION Displacement
	            #sFB_Displacement640(#sUDT_Interface640);
	        END_REGION
	        
	        REGION EoS               
	            
	            #sFB_PEC640(ix_PEC := #iUDT_MotorInput640.AllSensorPortInputs.LeftSensor,
	                        iUDT_PECConfiguration := #iUDT_Configuration."640".PEC_EoS,
	                        qUDT_HMIStatus => #iqUDT_WorkstationStatus."640".PEC_EoS,
	                        iqUDT_ConveyorInterface := #sUDT_Interface640,
	                        iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."640".PEC_EoS);
	            
	        END_REGION
	        REGION Conveyor
	            
	            #sFB_Conveyor640(iUDT_ConveyorConfiguration := #iUDT_Configuration."640".Conveyor,
	                             idi_PECEoSDistance := #iUDT_Configuration."640".PEC_EoS.Distance,
	                             idi_PECBoSDistance := 0,
	                             ii_ExternalSpeed := 0,
	                             ix_SafetyOk := #ix_SafetyOk,
	                             ix_24vOk := #ix_24vOk,
	                             ix_400vOk := #ix_400vOk,
	                             ix_HardwareOk := #ix_HardwareOk,
	                             ix_PECEoS := #iqUDT_WorkstationStatus."640".PEC_EoS.PEC,
	                             ix_PECBoS := TRUE,
	                             ix_ReverseDirection := FALSE,
	                             ix_ExternalRequestDieBack := FALSE,
	                             ix_ExternalRequestHold := FALSE,
	                             ix_ResetEnergySave := FALSE,
	                             qUDT_HMIStatus => #iqUDT_WorkstationStatus."640".Conveyor,
	                             qUDT_Status => #iqUDT_WorkstationCommonStatus."640",
	                             iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                             iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."640".Conveyor,
	                             iqUDT_ConveyorInterface := #sUDT_Interface640,
	                             iqUDT_HandShakeUp := #sUDT_Handshake630,
	                             iqUDT_HandShake := #iqUDT_HandshakeDownstream640,
	                             iqUDT_Statistics := #iqUDT_WorkstationStatistics."640".Conveyor);
	            
	        END_REGION
	        
	        REGION MCO
	            
	            #sFB_MCOConveyLinxAixController640(iUDT_AixConfig := #iUDT_Configuration."640".MCO_M01,
	                                               iUDT_AixInputsModule := #iUDT_MotorInput640,
	                                               ix_24vOk := #ix_24vOk,
	                                               ix_SimulationModeActive := "DB_Memory".Simulation,
	                                               ii_MotorPositionId := 1,
	                                               qUDT_HMIStatus => #iqUDT_WorkstationStatus."640".MCO_M01,
	                                               iqUDT_AixOutputsModule := #qUDT_MotorOutput640,
	                                               iqUDT_ConveyorInterface := #sUDT_Interface640,
	                                               iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."640".MCO_M01);
	        END_REGION
	    END_REGION
	END_REGION
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_CaptureRATPosition"
TITLE = Capturing RAT position when product leave infeed belt
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'Kamil Pokorski'
VERSION : 1.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 260
// END_ATTRIBUTES
//This block should be used only in Cyclic interrupt. All connected IO must be periferal.
   VAR_INPUT 
      ix_InfeedPEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when RAT infeed PEC is clear
      ix_Request { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ii_MotorPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // RAT motor position (lower when infeeding on lower position, upper if infeeding on upper position)
   END_VAR

   VAR_IN_OUT 
      iqi_Position { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Captured position
   END_VAR

   VAR 
      sR_TRIG_InfeedPEC {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Detecting rising edge on infeed PEC
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	27/05/2024  | 1.0       | K.Pokorski    | Initial version
	*)
	
	#sR_TRIG_InfeedPEC(CLK := #ix_InfeedPEC);
	
	IF #sR_TRIG_InfeedPEC.Q AND #ix_Request THEN
	    #iqi_Position := #ii_MotorPosition;
	END_IF;
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_WSG"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 262
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_Configuration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_WSGConfiguration";   // Workstation configuration structure
      iUDT_MotorInput010 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 010 ConveyLinxAix inputs structure
      iUDT_MotorInput020 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 020 ConveyLinxAix inputs structure
      iUDT_MotorInput110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 110 ConveyLinxAix inputs structure
      iUDT_MotorInput130 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 130 ConveyLinxAix inputs structure
      iUDT_MotorInput140 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 140 ConveyLinxAix inputs structure
      iUDT_MotorInput150 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 150 ConveyLinxAix inputs structure
      iUDT_MotorInput170 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 170 ConveyLinxAix inputs structure
      iUDT_MotorInput190 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 190 ConveyLinxAix inputs structure
      iUDT_MotorInput210 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 210 ConveyLinxAix inputs structure
      iUDT_MotorInput220 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 220 ConveyLinxAix inputs structure
      iUDT_MotorInput230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 230 ConveyLinxAix inputs structure
      iUDT_MotorInput310 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 310 ConveyLinxAix inputs structure
      iUDT_MotorInput330 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 330 ConveyLinxAix inputs structure
      iUDT_MotorInput350 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 350 ConveyLinxAix inputs structure
      iUDT_MotorInput510 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 510 ConveyLinxAix inputs structure
      iUDT_MotorInput520 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 520 ConveyLinxAix inputs structure
      iUDT_MotorInput540 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 540 ConveyLinxAix inputs structure
      iUDT_MotorInput550 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 550 ConveyLinxAix inputs structure
      iUDT_MotorInput570 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 570 ConveyLinxAix inputs structure
      iUDT_MotorInput590 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 590 ConveyLinxAix inputs structure
      iUDT_MotorInput610 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 610 ConveyLinxAix inputs structure
      iUDT_MotorInput620 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 620 ConveyLinxAix inputs structure
      iUDT_MotorInput630 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 630 ConveyLinxAix inputs structure
      iUDT_MotorInput710 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 710 ConveyLinxAix inputs structure
      iUDT_MotorInput730 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 730 ConveyLinxAix inputs structure
      iUDT_MotorInput750 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 750 ConveyLinxAix inputs structure
      iUDT_ScannerInput130 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CognexDM260_IN";   // Cognex inputs structur
      iUDT_ScannerInput530 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_DataLogic_IN";
      ix_24vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 24VDC is healthy
      ix_400vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 400VAC is healthy
      ix_SafetyOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when safety is ok
      ix_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when hardware is ok
      ix_AirPressureOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when air pressure is ok
      ix_SectionIsUp021 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 141 section is up
      ix_SectionIsDown021 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 141 section is down
      ix_SectionIsUp141 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 141 section is up
      ix_SectionIsDown141 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 141 section is down
      ix_SectionIsUp211 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 211 section is up
      ix_SectionIsDown211 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 211 section is down
      ix_SectionIsUp221 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 221 section is up
      ix_SectionIsDown221 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 221 section is down
      ix_SectionIsUp541 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 541 section is up
      ix_SectionIsDown541 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 541 section is down
      ix_SectionIsUp611 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 611 section is up
      ix_SectionIsDown611 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 611 section is down
      ix_SectionIsUp621 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 621 section is up
      ix_SectionIsDown621 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 621 section is down
      ix_GateIsDown111 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 111 gate conveyor is down
      ix_MaintenanceRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Maintenance request
   END_VAR

   VAR_OUTPUT 
      qUDT_ScannerOutput130 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CognexDM260_OUT";   // Cognex output structure
      qudt_ScannerOutput530 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_DataLogic_OUT";
      qx_PopupControl021 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command up for section 021
      qx_PopupControl141 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command up for section 141
      qx_PopupControl211 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command up for section 211
      qx_PopupControl221 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command up for section 221
      qx_PopupControl541 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command up for section 541
      qx_PopupControl611 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command up for section 611
      qx_PopupControl621 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command up for section 621
      qx_ButtonLight { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Output signal confirming that gate conveyor can be lifted
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
      iqUDT_HandshakeUpstream010 : "UDT_ConveyorHandshake";   // Upstream handshake structure in forward direction for 010 conveyor
      iqUDT_HandshakeDownstream230 : "UDT_ConveyorHandshake";   // Handshake structure in forward direction for 230 conveyor
      iqUDT_HandshakeDownstream630 : "UDT_ConveyorHandshake";   // Handshake structure in forward direction for 630 conveyor
      iqUDT_UnknownGINRange : "UDT_UnknownGIN";   // Unknown GIN
      iqUDT_WorkstationCommands : "UDT_WSGHmiCommands";   // Workstation command structure
      iqUDT_WorkstationStatistics : "UDT_WSGStatistics";   // Statistics structure
      iqUDT_WorkstationStatus : "UDT_WSGStatus";   // HMI Status structure
      iqUDT_WorkstationCommonStatus : "UDT_WSGCommonStatus";   // Common status structure
      iqUDT_CommunicationWES : "UDT_WSGCommunicationWES";   // Structure with communication data to WMS
      iqUDT_MotorOutput010 : "UDT_AixPlcFullOut";   // 010 ConveyLinxAix outputs structure
      iqUDT_MotorOutput020 : "UDT_AixPlcFullOut";   // 020 ConveyLinxAix outputs structure
      iqUDT_MotorOutput110 : "UDT_AixPlcFullOut";   // 110 ConveyLinxAix outputs structure
      iqUDT_MotorOutput130 : "UDT_AixPlcFullOut";   // 130 ConveyLinxAix outputs structure
      iqUDT_MotorOutput140 : "UDT_AixPlcFullOut";   // 140 ConveyLinxAix outputs structure
      iqUDT_MotorOutput150 : "UDT_AixPlcFullOut";   // 150 ConveyLinxAix outputs structure
      iqUDT_MotorOutput170 : "UDT_AixPlcFullOut";   // 170 ConveyLinxAix outputs structure
      iqUDT_MotorOutput190 : "UDT_AixPlcFullOut";   // 190 ConveyLinxAix outputs structure
      iqUDT_MotorOutput210 : "UDT_AixPlcFullOut";   // 210 ConveyLinxAix outputs structure
      iqUDT_MotorOutput220 : "UDT_AixPlcFullOut";   // 220 ConveyLinxAix outputs structure
      iqUDT_MotorOutput230 : "UDT_AixPlcFullOut";   // 230 ConveyLinxAix outputs structure
      iqUDT_MotorOutput310 : "UDT_AixPlcFullOut";   // 310 ConveyLinxAix outputs structure
      iqUDT_MotorOutput330 : "UDT_AixPlcFullOut";   // 330 ConveyLinxAix outputs structure
      iqUDT_MotorOutput350 : "UDT_AixPlcFullOut";   // 350 ConveyLinxAix outputs structure
      iqUDT_MotorOutput510 : "UDT_AixPlcFullOut";   // 510 ConveyLinxAix outputs structure
      iqUDT_MotorOutput520 : "UDT_AixPlcFullOut";   // 520 ConveyLinxAix outputs structure
      iqUDT_MotorOutput540 : "UDT_AixPlcFullOut";   // 540 ConveyLinxAix outputs structure
      iqUDT_MotorOutput550 : "UDT_AixPlcFullOut";   // 550 ConveyLinxAix outputs structure
      iqUDT_MotorOutput570 : "UDT_AixPlcFullOut";   // 570 ConveyLinxAix outputs structure
      iqUDT_MotorOutput590 : "UDT_AixPlcFullOut";   // 590 ConveyLinxAix outputs structure
      iqUDT_MotorOutput610 : "UDT_AixPlcFullOut";   // 610 ConveyLinxAix outputs structure
      iqUDT_MotorOutput620 : "UDT_AixPlcFullOut";   // 620 ConveyLinxAix outputs structure
      iqUDT_MotorOutput630 : "UDT_AixPlcFullOut";   // 630 ConveyLinxAix outputs structure
      iqUDT_MotorOutput710 : "UDT_AixPlcFullOut";   // 710 ConveyLinxAix outputs structure
      iqUDT_MotorOutput730 : "UDT_AixPlcFullOut";   // 730 ConveyLinxAix outputs structure
      iqUDT_MotorOutput750 : "UDT_AixPlcFullOut";   // 750 ConveyLinxAix outputs structure
      iqUDT_RATPositioning020 : "UDT_RATPositioning";   // Structure including data for servo control RAT 020
      iqUDT_RATPositioning140 : "UDT_RATPositioning";   // Structure including data for servo control RAT 140
      iqUDT_RATPositioning210 : "UDT_RATPositioning";   // Structure including data for servo control RAT 210
      iqUDT_RATPositioning220 : "UDT_RATPositioning";   // Structure including data for servo control RAT 220
      iqUDT_RATPositioning540 : "UDT_RATPositioning";   // Structure including data for servo control RAT 540
      iqUDT_RATPositioning610 : "UDT_RATPositioning";   // Structure including data for servo control RAT 610
      iqUDT_RATPositioning620 : "UDT_RATPositioning";   // Structure including data for servo control RAT 620
   END_VAR

   VAR 
      sFB_Displacement010 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 010 conveyor
      sFB_Displacement020 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 020 conveyor
      sFB_Displacement021 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 021 conveyor
      sFB_Displacement110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 110 conveyor
      sFB_Displacement120 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 120 conveyor
      sFB_Displacement130 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 130 conveyor
      sFB_Displacement140 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 140 conveyor
      sFB_Displacement141 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 141 conveyor
      sFB_Displacement150 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 150 conveyor
      sFB_Displacement160 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 160 conveyor
      sFB_Displacement170 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 170 conveyor
      sFB_Displacement180 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 180 conveyor
      sFB_Displacement190 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 190 conveyor
      sFB_Displacement210 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 210 conveyor
      sFB_Displacement211 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 211 conveyor
      sFB_Displacement220 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 220 conveyor
      sFB_Displacement221 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 221 conveyor
      sFB_Displacement230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 230 conveyor
      sFB_Displacement310 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 310 conveyor
      sFB_Displacement320 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 320 conveyor
      sFB_Displacement330 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 330 conveyor
      sFB_Displacement340 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 340 conveyor
      sFB_Displacement350 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 350 conveyor
      sFB_Displacement510 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 510 conveyor
      sFB_Displacement520 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 520 conveyor
      sFB_Displacement530 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 530 conveyor
      sFB_Displacement540 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 540 conveyor
      sFB_Displacement541 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 541 conveyor
      sFB_Displacement550 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 550 conveyor
      sFB_Displacement560 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 560 conveyor
      sFB_Displacement570 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 570 conveyor
      sFB_Displacement580 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 580 conveyor
      sFB_Displacement590 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 590 conveyor
      sFB_Displacement610 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 610 conveyor
      sFB_Displacement611 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 611 conveyor
      sFB_Displacement620 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 620 conveyor
      sFB_Displacement621 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 621 conveyor
      sFB_Displacement630 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 630 conveyor
      sFB_Displacement710 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 710 conveyor
      sFB_Displacement720 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 720 conveyor
      sFB_Displacement730 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 730 conveyor
      sFB_Displacement740 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 740 conveyor
      sFB_Displacement750 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 750 conveyor
      sUDT_Interface010 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 010 conveyor
      sUDT_Interface020 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 020 conveyor
      sUDT_Interface021 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 021 conveyor
      sUDT_Interface110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 110 conveyor
      sUDT_Interface120 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 120 conveyor
      sUDT_Interface130 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 130 conveyor
      sUDT_Interface140 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 140 conveyor
      sUDT_Interface141 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 141 conveyor
      sUDT_Interface150 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 150 conveyor
      sUDT_Interface160 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 160 conveyor
      sUDT_Interface170 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 170 conveyor
      sUDT_Interface180 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 180 conveyor
      sUDT_Interface190 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 190 conveyor
      sUDT_Interface210 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 210 conveyor
      sUDT_Interface211 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 211 conveyor
      sUDT_Interface220 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 220 conveyor
      sUDT_Interface221 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 221 conveyor
      sUDT_Interface230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 230 conveyor
      sUDT_Interface310 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 310 conveyor
      sUDT_Interface320 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 320 conveyor
      sUDT_Interface330 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 330 conveyor
      sUDT_Interface340 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 340 conveyor
      sUDT_Interface350 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 350 conveyor
      sUDT_Interface510 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 510 conveyor
      sUDT_Interface520 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 520 conveyor
      sUDT_Interface530 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 530 conveyor
      sUDT_Interface540 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 540 conveyor
      sUDT_Interface541 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 541 conveyor
      sUDT_Interface550 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 550 conveyor
      sUDT_Interface560 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 560 conveyor
      sUDT_Interface570 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 570 conveyor
      sUDT_Interface580 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 580 conveyor
      sUDT_Interface590 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 590 conveyor
      sUDT_Interface610 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 610 conveyor
      sUDT_Interface611 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 611 conveyor
      sUDT_Interface620 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 620 conveyor
      sUDT_Interface621 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 621 conveyor
      sUDT_Interface630 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 630 conveyor
      sUDT_Interface710 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 710 conveyor
      sUDT_Interface720 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 720 conveyor
      sUDT_Interface730 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 730 conveyor
      sUDT_Interface740 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 740 conveyor
      sUDT_Interface750 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure 750 conveyor
      sFB_Tracking110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 110 conveyor
      sFB_Tracking120 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 120 conveyor
      sFB_Tracking130 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 130 conveyor
      sFB_Tracking150 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 150 conveyor
      sFB_Tracking160 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 160 conveyor
      sFB_Tracking170 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 170 conveyor
      sFB_Tracking180 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 180 conveyor
      sFB_Tracking190 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 190 conveyor
      sFB_Tracking520 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 520 conveyor
      sFB_Tracking530 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 530 conveyor
      sFB_Tracking550 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 550 conveyor
      sFB_Tracking560 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 560 conveyor
      sFB_Tracking570 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 570 conveyor
      sFB_Tracking580 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 580 conveyor
      sFB_Tracking590 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 590 conveyor
      sa_TrackingArray110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..2501] of Int;   // Tracking array for 110 conveyor
      sa_TrackingArray120 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..2501] of Int;   // Tracking array for 120 conveyor
      sa_TrackingArray130 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..2501] of Int;   // Tracking array for 130 conveyor
      sa_TrackingArray150 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..2501] of Int;   // Tracking array for 150 conveyor
      sa_TrackingArray160 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..2501] of Int;   // Tracking array for 160 conveyor
      sa_TrackingArray170 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..2501] of Int;   // Tracking array for 170 conveyor
      sa_TrackingArray180 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..2501] of Int;   // Tracking array for 180 conveyor
      sa_TrackingArray190 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..2501] of Int;   // Tracking array for 190 conveyor
      sa_TrackingArray520 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..2501] of Int;   // Tracking array for 520 conveyor
      sa_TrackingArray530 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..2501] of Int;   // Tracking array for 530 conveyor
      sa_TrackingArray550 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..2501] of Int;   // Tracking array for 550 conveyor
      sa_TrackingArray560 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..2501] of Int;   // Tracking array for 560 conveyor
      sa_TrackingArray570 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..2501] of Int;   // Tracking array for 570 conveyor
      sa_TrackingArray580 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..2501] of Int;   // Tracking array for 580 conveyor
      sa_TrackingArray590 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..2501] of Int;   // Tracking array for 590 conveyor
      sUDT_Handshake010 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 010 conveyor
      sUDT_HandshakeUp020 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // HandshakeUp structure for 020 conveyor
      sUDT_Handshake020 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 020 conveyor
      sUDT_Handshake110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 110 conveyor
      sUDT_Handshake120 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 120 conveyor
      sUDT_Handshake130 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 130 conveyor
      sUDT_Handshake140 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 140 conveyor
      sUDT_Handshake141 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 141 conveyor
      sUDT_Handshake150 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 150 conveyor
      sUDT_Handshake160 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 160 conveyor
      sUDT_Handshake170 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 170 conveyor
      sUDT_Handshake180 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 180 conveyor
      sUDT_Handshake190 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 190 conveyor
      sUDT_Handshake210 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 210 conveyor
      sUDT_Handshake211 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 211 conveyor
      sUDT_Handshake220 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 220 conveyor
      sUDT_Handshake221 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 221 conveyor
      sUDT_Handshake310 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 310 conveyor
      sUDT_Handshake320 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 320 conveyor
      sUDT_Handshake330 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 330 conveyor
      sUDT_Handshake340 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 340 conveyor
      sUDT_Handshake350 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 350 conveyor
      sUDT_Handshake510 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 510 conveyor
      sUDT_Handshake520 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 520 conveyor
      sUDT_Handshake530 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 530 conveyor
      sUDT_Handshake540 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 540 conveyor
      sUDT_Handshake541 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 541 conveyor
      sUDT_Handshake550 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 550 conveyor
      sUDT_Handshake560 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 560 conveyor
      sUDT_Handshake570 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 570 conveyor
      sUDT_Handshake580 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 580 conveyor
      sUDT_Handshake590 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 590 conveyor
      sUDT_Handshake610 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 610 conveyor
      sUDT_Handshake611 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 611 conveyor
      sUDT_Handshake620 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 620 conveyor
      sUDT_Handshake621 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 621 conveyor
      sUDT_Handshake710 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 710 conveyor
      sUDT_Handshake720 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 720 conveyor
      sUDT_Handshake730 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 730 conveyor
      sUDT_Handshake740 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 740 conveyor
      sUDT_Handshake750 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 750 conveyor
      sFB_PECUpdate110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 110 conveyor
      sFB_PECUpdate130 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 130 conveyor
      sFB_PECUpdate150 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 150 conveyor
      sFB_PECUpdate160 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 160 conveyor
      sFB_PECUpdate170 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 170 conveyor
      sFB_PECUpdate180 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 180 conveyor
      sFB_PECUpdate190 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 190 conveyor
      sFB_PECUpdate520 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 520 conveyor
      sFB_PECUpdate530 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 530 conveyor
      sFB_PECUpdate550 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 550 conveyor
      sFB_PECUpdate560 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 560 conveyor
      sFB_PECUpdate570 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 570 conveyor
      sFB_PECUpdate580 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 580 conveyor
      sFB_PECUpdate590 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 590 conveyor
      sFB_PEC010 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 010 conveyor
      sFB_PEC020 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 020 conveyor
      sFB_PEC310 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 310 conveyor
      sFB_PEC320 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 320 conveyor
      sFB_PEC330 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 330 conveyor
      sFB_PEC340 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 340 conveyor
      sFB_PEC350 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 350 conveyor
      sFB_PEC630 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 630 conveyor
      sFB_PEC710 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 710 conveyor
      sFB_PEC720 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 720 conveyor
      sFB_PEC730 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 730 conveyor
      sFB_PEC740 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 740 conveyor
      sFB_PEC750 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // Photoeye handling for 750 conveyor
      sFB_Conveyor010 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 010 conveyor
      sFB_Conveyor110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 110 conveyor
      sFB_Conveyor120 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 120 conveyor
      sFB_Conveyor130 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 130 conveyor
      sFB_Conveyor150 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 150 conveyor
      sFB_Conveyor160 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 160 conveyor
      sFB_Conveyor170 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 170 conveyor
      sFB_Conveyor180 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 180 conveyor
      sFB_Conveyor190 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 190 conveyor
      sFB_Conveyor230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 230 conveyor
      sFB_Conveyor310 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 310 conveyor
      sFB_Conveyor320 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 320 conveyor
      sFB_Conveyor330 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 330 conveyor
      sFB_Conveyor340 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 340 conveyor
      sFB_Conveyor350 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 350 conveyor
      sFB_Conveyor510 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 510 conveyor
      sFB_Conveyor520 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 520 conveyor
      sFB_Conveyor530 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 530 conveyor
      sFB_Conveyor550 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 550 conveyor
      sFB_Conveyor560 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 560 conveyor
      sFB_Conveyor570 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 570 conveyor
      sFB_Conveyor580 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 580 conveyor
      sFB_Conveyor590 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 590 conveyor
      sFB_Conveyor630 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 630 conveyor
      sFB_Conveyor710 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 710 conveyor
      sFB_Conveyor720 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 720 conveyor
      sFB_Conveyor730 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 730 conveyor
      sFB_Conveyor740 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 740 conveyor
      sFB_Conveyor750 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 750 conveyor
      sFB_RightAngledTransfer021 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_RightAngledTransfer";   // Funtion to control 021 RAT
      sFB_RightAngledTransfer141 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_RightAngledTransfer";   // Funtion to control 141 RAT
      sFB_RightAngledTransfer211 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_RightAngledTransfer";   // Funtion to control 211 RAT
      sFB_RightAngledTransfer221 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_RightAngledTransfer";   // Funtion to control 221 RAT
      sFB_RightAngledTransfer541 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_RightAngledTransfer";   // Funtion to control 541 RAT
      sFB_RightAngledTransfer611 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_RightAngledTransfer";   // Funtion to control 611 RAT
      sFB_RightAngledTransfer621 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_RightAngledTransfer";   // Funtion to control 621 RAT
      sFB_MCOConveyLinxAixController010 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 010
      sFB_MCOConveyLinxAixController020 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 020
      sFB_MCOConveyLinxAixController021 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 021
      sFB_MCOConveyLinxAixController110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 110
      sFB_MCOConveyLinxAixController120 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 120
      sFB_MCOConveyLinxAixController130 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 130
      sFB_MCOConveyLinxAixController140 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 140
      sFB_MCOConveyLinxAixController141 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 141
      sFB_MCOConveyLinxAixController150 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 150
      sFB_MCOConveyLinxAixController160 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 160
      sFB_MCOConveyLinxAixController170 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 170
      sFB_MCOConveyLinxAixController180 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 180
      sFB_MCOConveyLinxAixController190 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 190
      sFB_MCOConveyLinxAixController210 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 210
      sFB_MCOConveyLinxAixController211 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 211
      sFB_MCOConveyLinxAixController220 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 220
      sFB_MCOConveyLinxAixController221 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 221
      sFB_MCOConveyLinxAixController230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 230
      sFB_MCOConveyLinxAixController310 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 310
      sFB_MCOConveyLinxAixController320 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 320
      sFB_MCOConveyLinxAixController330 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 330
      sFB_MCOConveyLinxAixController340 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 340
      sFB_MCOConveyLinxAixController350 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 350
      sFB_MCOConveyLinxAixController510 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 510
      sFB_MCOConveyLinxAixController520 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 520
      sFB_MCOConveyLinxAixController530 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 530
      sFB_MCOConveyLinxAixController540 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 540
      sFB_MCOConveyLinxAixController541 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 541
      sFB_MCOConveyLinxAixController550 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 550
      sFB_MCOConveyLinxAixController560 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 560
      sFB_MCOConveyLinxAixController570 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 570
      sFB_MCOConveyLinxAixController580 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 580
      sFB_MCOConveyLinxAixController590 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 590
      sFB_MCOConveyLinxAixController610 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 610
      sFB_MCOConveyLinxAixController611 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 611
      sFB_MCOConveyLinxAixController620 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 620
      sFB_MCOConveyLinxAixController621 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 621
      sFB_MCOConveyLinxAixController630 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 630
      sFB_MCOConveyLinxAixController710 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 710
      sFB_MCOConveyLinxAixController720 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 720
      sFB_MCOConveyLinxAixController730 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 730
      sFB_MCOConveyLinxAixController740 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 740
      sFB_MCOConveyLinxAixController750 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 750
      sFB_CognexDM130 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_CognexDM260";
      sFB_CognexDM530 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_CognexDM260";
      sFB_DataLogicBlade200_530 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_DataLogicBlade";
      sFB_TimerOnOffDelay_GateIsDown111Filtered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Filtered GateIsDown signal
      sFB_TimerOnOffDelay_Hold310 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer for delayed hold of pushout conveyor 310
      sFB_TimerOnOffDelay_Hold320 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer for delayed hold of pushout conveyor 320
      sFB_TimerOnOffDelay_Hold330 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer for delayed hold of pushout conveyor 330
      sFB_TimerOnOffDelay_Hold340 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer for delayed hold of pushout conveyor 340
      sFB_TimerOnOffDelay_Hold350 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer for delayed hold of pushout conveyor 350
      sFB_TimerOnOffDelay_Hold710 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer for delayed hold of pushout conveyor 710
      sFB_TimerOnOffDelay_Hold720 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer for delayed hold of pushout conveyor 720
      sFB_TimerOnOffDelay_Hold730 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer for delayed hold of pushout conveyor 730
      sFB_TimerOnOffDelay_Hold740 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer for delayed hold of pushout conveyor 740
      sFB_TimerOnOffDelay_Hold750 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer for delayed hold of pushout conveyor 750
      sFB_TimerOnOffDelay_Detect310 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer for removing hold of pushout conveyor after pushout detection 310
      sFB_TimerOnOffDelay_Detect320 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer for removing hold of pushout conveyor after pushout detection 320
      sFB_TimerOnOffDelay_Detect330 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer for removing hold of pushout conveyor after pushout detection 330
      sFB_TimerOnOffDelay_Detect340 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer for removing hold of pushout conveyor after pushout detection 340
      sFB_TimerOnOffDelay_Detect710 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer for removing hold of pushout conveyor after pushout detection 710
      sFB_TimerOnOffDelay_Detect720 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer for removing hold of pushout conveyor after pushout detection 720
      sFB_TimerOnOffDelay_Detect730 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer for removing hold of pushout conveyor after pushout detection 730
      sFB_TimerOnOffDelay_Detect740 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer for removing hold of pushout conveyor after pushout detection 740
      sFB_CountActiveInputs_LeftStation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_CountActiveInputs";   // Counter for free positions on left station
      sFB_CountActiveInputs_RightStation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_CountActiveInputs";   // Counter for free positions on right station
      sFB_CountActiveInputs_LeftBuffer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_CountActiveInputs";   // Counter for free positions on left station buffer
      sFB_CountActiveInputs_RightBuffer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_CountActiveInputs";   // Counter for free positions on right station buffer
      sR_TRIG_PEC140 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising Edge on 140 conveyor
      sR_TRIG_PEC540 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising Edge on 540 conveyor
      sR_TRIG_B111 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising Edge Button Push
      si_DestinationC021 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // RAT 021 destination for C Infeed
      si_LeftDestinationC141 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Rat destination
      si_LeftEmptyStations { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Number of empty  stations
      si_RightDestinationC541 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Rat destination
      si_RightEmptyStations { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Number of empty stations
      sx_MaintenanceIsPerformed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE while maintenance is being performed
      sx_GateIsDown111Filtered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Filtered signal from gate conveyor sensor
      sx_ExternalRequestHoldGate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Hold signal for gate conveyors 110 and 120
      sx_LeftIndexing { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Indexing in progres
      sx_LeftPushOutActiveStation1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Push out is active on station 1
      sx_LeftPushOutActiveStation2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Push out is active on station 2
      sx_LeftPushOutActiveStation3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Push out is active on station 3
      sx_LeftPushOutActiveStation4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Push out is active on station 4
      sx_LeftPushOutActiveStation5 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Push out is active on station 5
      sx_LeftExternalRequestHold150 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External dieback request
      sx_LeftExternalRequestHold160 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External hold request
      sx_LeftExternalRequestHold170 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External hold request
      sx_LeftExternalRequestHold180 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External hold request
      sx_LeftExternalRequestHold190 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External hold request
      sx_LeftExternalRequestHold310 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External hold request
      sx_LeftExternalRequestHold320 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External hold request
      sx_LeftExternalRequestHold330 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External hold request
      sx_LeftExternalRequestHold340 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External hold request
      sx_LeftExternalRequestHold350 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External hold request
      sx_RightIndexing { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Indexing in progress
      sx_RightPushOutActiveStation1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Push out is active
      sx_RightPushOutActiveStation2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Push out is active
      sx_RightPushOutActiveStation3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Push out is active
      sx_RightPushOutActiveStation4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Push out is active
      sx_RightPushOutActiveStation5 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Push out is active
      sx_RightExternalRequestHold550 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External dieback request
      sx_RightExternalRequestHold560 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External hold request
      sx_RightExternalRequestHold570 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External hold request
      sx_RightExternalRequestHold580 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External hold request
      sx_RightExternalRequestHold590 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External hold request
      sx_RightExternalRequestHold710 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External hold request
      sx_RightExternalRequestHold720 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External hold request
      sx_RightExternalRequestHold730 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External hold request
      sx_RightExternalRequestHold740 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External hold request
      sx_RightExternalRequestHold750 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External hold request
   END_VAR

   VAR_TEMP 
      tUDT_DummyConveyorHandshake : "UDT_ConveyorHandshake";   // Dummy Handshake structure
      tUDT_DummyBladeStop : "UDT_ValveInterface";
      ts_Barcode130 : String;   // Temporal string for barcode read on conveyor 130
      ts_Barcode530 : String;   // Temporal string for barcode read on conveyor 530
      ti_GIN130 : Int;   // Temporal int for GIN to write barcode on conveyor 130
      ti_GIN530 : Int;   // Temporal int for GIN to write barcode on conveyor 530
      ti_dummy : Int;   // Dummy int
      tw_dummy : Word;   // Dummy word
      tx_dummy : Bool;   // Dummy bool
   END_VAR

   VAR CONSTANT 
      cudi_PushOutTime : UDInt := 5000;   // Time after pushout conveyors are hold
      cudi_DetectTime : UDInt := 2000;   // Time after the pushout conveyor starts
      cr_ClearTrackingModifier : Real := 0.12;   // Modifier for clearing tracking after pushout
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	15/02/2023  | 1.0       | R. Pieczonka  | Initial version
	22/02/2023  | 1.1       | S. Nieswiec   | Interface changes, RAT blocks instead of PushUpDivert, Gate Conveyor functionality, right side of station added
	06/03/2024  | 1.2       | S. Nieswiec   | Changes according to new layout
	19/03/2024  | 1.3       | S. Nieswiec   | Adjusting comments and variable names
	30/04/2024  | 1.4       | S. Nieswiec   | On site changes
	15/05/2024  | 1.5       | S. Nieswiec   | Station handshake changes, comments adjusted
	08/06/2024  | 1.6       | S. Nieswiec   | New MCO, Displacement and RAT blocks, interface update
	    
	*)
	
	REGION 1 - Initial Left Station
	    IF #iUDT_Configuration.GlobalConfig.LeftStationExists THEN
	        
	        REGION 1.1 - Triggers
	            
	            #sR_TRIG_PEC140(CLK := #iqUDT_WorkstationStatus."140".PEC_EoS.PEC);    //Rising Edge PEC on conveyor 140 for indexing into station count
	            #sR_TRIG_B111(CLK := #ix_MaintenanceRequest);      //Rising edge detection for maintenance button press
	            
	        END_REGION
	        
	        REGION 1.2 - Counters
	            REGION 1.2.1 - Count empty stations 
	                
	                //If there is no indexing procedure then count empty stations
	                
	                IF NOT #sx_LeftIndexing THEN
	                    
	                    #sFB_CountActiveInputs_LeftStation(ix_Input1 := #iqUDT_WorkstationStatus."150".PEC_EoS.PEC,
	                                                       ix_Input2 := #iqUDT_WorkstationStatus."160".PEC_EoS.PEC,
	                                                       ix_Input3 := #iqUDT_WorkstationStatus."170".PEC_EoS.PEC,
	                                                       ix_Input4 := #iqUDT_WorkstationStatus."180".PEC_EoS.PEC,
	                                                       ix_Input5 := #iqUDT_WorkstationStatus."190".PEC_EoS.PEC,
	                                                       qi_ActiveInputsCount => #si_LeftEmptyStations);
	                END_IF;
	            END_REGION
	            
	            REGION 1.2.2 - Count free spaces on left buffer
	                
	                // If there's no maintenance performed on lift, then count free spaces, if there is - set them to 0, cause we don't want to divert anyway
	                
	                IF NOT #sx_MaintenanceIsPerformed THEN
	                    #sFB_CountActiveInputs_LeftBuffer(ix_Input1 := #iqUDT_WorkstationStatus."110".PEC_EoS.PEC,
	                                                      ix_Input2 := #iqUDT_WorkstationStatus."120".PEC_EoS.PEC,
	                                                      ix_Input3 := #iqUDT_WorkstationStatus."140".PEC_EoS.PEC);
	                ELSIF #sx_MaintenanceIsPerformed THEN
	                    #sFB_CountActiveInputs_LeftBuffer.qi_ActiveInputsCount := 0;
	                END_IF;
	            END_REGION
	        END_REGION
	        
	        REGION 1.3 -  Timers
	            
	            REGION 1.3.1 - Delay pushout conveyors hold signals after pushout started
	                
	                #sFB_TimerOnOffDelay_Hold350(iudi_OnDelayTime := #cudi_PushOutTime,
	                                             ix_SignalToDelay := NOT #sx_LeftExternalRequestHold350
	                                             AND #iqUDT_WorkstationStatus."310".PEC_EoS.PEC
	                                             AND #iqUDT_WorkstationStatus."320".PEC_EoS.PEC
	                                             AND #iqUDT_WorkstationStatus."330".PEC_EoS.PEC
	                                             AND #iqUDT_WorkstationStatus."340".PEC_EoS.PEC
	                                             AND #iqUDT_WorkstationStatus."350".PEC_EoS.PEC,
	                                             ix_Enable := TRUE);
	                
	                #sFB_TimerOnOffDelay_Hold340(iudi_OnDelayTime := #cudi_PushOutTime,
	                                             ix_SignalToDelay := NOT #sx_LeftExternalRequestHold340
	                                             AND #iqUDT_WorkstationStatus."310".PEC_EoS.PEC
	                                             AND #iqUDT_WorkstationStatus."320".PEC_EoS.PEC
	                                             AND #iqUDT_WorkstationStatus."330".PEC_EoS.PEC
	                                             AND #iqUDT_WorkstationStatus."340".PEC_EoS.PEC,
	                                             ix_Enable := TRUE);
	                
	                #sFB_TimerOnOffDelay_Hold330(iudi_OnDelayTime := #cudi_PushOutTime,
	                                             ix_SignalToDelay := NOT #sx_LeftExternalRequestHold330
	                                             AND #iqUDT_WorkstationStatus."310".PEC_EoS.PEC
	                                             AND #iqUDT_WorkstationStatus."320".PEC_EoS.PEC
	                                             AND #iqUDT_WorkstationStatus."330".PEC_EoS.PEC,
	                                             ix_Enable := TRUE);
	                
	                #sFB_TimerOnOffDelay_Hold320(iudi_OnDelayTime := #cudi_PushOutTime,
	                                             ix_SignalToDelay := NOT #sx_LeftExternalRequestHold320
	                                             AND #iqUDT_WorkstationStatus."310".PEC_EoS.PEC
	                                             AND #iqUDT_WorkstationStatus."320".PEC_EoS.PEC,
	                                             ix_Enable := TRUE);
	                
	                #sFB_TimerOnOffDelay_Hold310(iudi_OnDelayTime := #cudi_PushOutTime,
	                                             ix_SignalToDelay := NOT #sx_LeftExternalRequestHold310
	                                             AND #iqUDT_WorkstationStatus."310".PEC_EoS.PEC,
	                                             ix_Enable := TRUE);
	                
	            END_REGION
	            
	            REGION 1.3.2 - Delayed start of pushout conveyors after pushout detection
	                #sFB_TimerOnOffDelay_Detect340(iudi_OnDelayTime := #cudi_DetectTime,
	                                               ix_SignalToDelay := NOT #iqUDT_WorkstationStatus."340".PEC_EoS.PEC,
	                                               ix_Enable := TRUE);
	                
	                #sFB_TimerOnOffDelay_Detect330(iudi_OnDelayTime := #cudi_DetectTime,
	                                               ix_SignalToDelay := NOT #iqUDT_WorkstationStatus."330".PEC_EoS.PEC,
	                                               ix_Enable := TRUE);
	                
	                #sFB_TimerOnOffDelay_Detect320(iudi_OnDelayTime := #cudi_DetectTime,
	                                               ix_SignalToDelay := NOT #iqUDT_WorkstationStatus."320".PEC_EoS.PEC,
	                                               ix_Enable := TRUE);
	                
	                #sFB_TimerOnOffDelay_Detect310(iudi_OnDelayTime := #cudi_DetectTime,
	                                               ix_SignalToDelay := NOT #iqUDT_WorkstationStatus."310".PEC_EoS.PEC,
	                                               ix_Enable := TRUE);
	            END_REGION
	            
	            REGION 1.3.3 - Gate conveyor proximity sensor filtered signal
	                
	                #sFB_TimerOnOffDelay_GateIsDown111Filtered(iudi_OnDelayTime := 500,
	                                                           iudi_OffDelayTime := 10,
	                                                           ix_SignalToDelay := #ix_GateIsDown111,
	                                                           qx_DelayedSignal => #sx_GateIsDown111Filtered);
	            END_REGION
	        END_REGION
	        
	    END_IF;
	END_REGION
	
	REGION 2 - Initial right station
	    
	    IF #iUDT_Configuration.GlobalConfig.RightStationExists THEN
	        
	        REGION 2.1 - Triggers
	            
	            #sR_TRIG_PEC540(CLK := #iqUDT_WorkstationStatus."540".PEC_EoS.PEC);   //Rising Edge PEC on conveyor 540 for indexing into station count
	            
	        END_REGION
	        
	        REGION 2.2 - Counters
	            
	            REGION 2.2.1 - Count empty stations on right side
	                
	                //If there is no indexing procedure then count empty stations
	                //
	                IF NOT #sx_RightIndexing THEN
	                    
	                    #sFB_CountActiveInputs_RightStation(ix_Input1 := #iqUDT_WorkstationStatus."550".PEC_EoS.PEC,
	                                                        ix_Input2 := #iqUDT_WorkstationStatus."560".PEC_EoS.PEC,
	                                                        ix_Input3 := #iqUDT_WorkstationStatus."570".PEC_EoS.PEC,
	                                                        ix_Input4 := #iqUDT_WorkstationStatus."580".PEC_EoS.PEC,
	                                                        ix_Input5 := #iqUDT_WorkstationStatus."590".PEC_EoS.PEC,
	                                                        qi_ActiveInputsCount => #si_RightEmptyStations);
	                END_IF;
	            END_REGION
	            
	            
	            
	            REGION 1.2.4 - Count free spaces on right buffer
	                
	                #sFB_CountActiveInputs_RightBuffer(ix_Input1 := #iqUDT_WorkstationStatus."520".PEC_EoS.PEC,
	                                                   ix_Input2 := #iqUDT_WorkstationStatus."530".PEC_EoS.PEC,
	                                                   ix_Input3 := #iqUDT_WorkstationStatus."540".PEC_EoS.PEC);
	            END_REGION
	            
	        END_REGION
	        
	        REGION 2.3 -  Timers
	            
	            REGION 2.3.1 - Right station timers for holding pushout conveyors after pushout
	                #sFB_TimerOnOffDelay_Hold750(iudi_OnDelayTime := #cudi_PushOutTime,
	                                             ix_SignalToDelay := NOT #sx_RightExternalRequestHold750
	                                             AND #iqUDT_WorkstationStatus."710".PEC_EoS.PEC
	                                             AND #iqUDT_WorkstationStatus."720".PEC_EoS.PEC
	                                             AND #iqUDT_WorkstationStatus."730".PEC_EoS.PEC
	                                             AND #iqUDT_WorkstationStatus."740".PEC_EoS.PEC
	                                             AND #iqUDT_WorkstationStatus."750".PEC_EoS.PEC,
	                                             ix_Enable := TRUE);
	                
	                #sFB_TimerOnOffDelay_Hold740(iudi_OnDelayTime := #cudi_PushOutTime,
	                                             ix_SignalToDelay := NOT #sx_RightExternalRequestHold740
	                                             AND #iqUDT_WorkstationStatus."710".PEC_EoS.PEC
	                                             AND #iqUDT_WorkstationStatus."720".PEC_EoS.PEC
	                                             AND #iqUDT_WorkstationStatus."730".PEC_EoS.PEC
	                                             AND #iqUDT_WorkstationStatus."740".PEC_EoS.PEC,
	                                             ix_Enable := TRUE);
	                
	                #sFB_TimerOnOffDelay_Hold730(iudi_OnDelayTime := #cudi_PushOutTime,
	                                             ix_SignalToDelay := NOT #sx_RightExternalRequestHold730
	                                             AND #iqUDT_WorkstationStatus."710".PEC_EoS.PEC
	                                             AND #iqUDT_WorkstationStatus."720".PEC_EoS.PEC
	                                             AND #iqUDT_WorkstationStatus."730".PEC_EoS.PEC,
	                                             ix_Enable := TRUE);
	                
	                #sFB_TimerOnOffDelay_Hold720(iudi_OnDelayTime := #cudi_PushOutTime,
	                                             ix_SignalToDelay := NOT #sx_RightExternalRequestHold720
	                                             AND #iqUDT_WorkstationStatus."710".PEC_EoS.PEC
	                                             AND #iqUDT_WorkstationStatus."720".PEC_EoS.PEC,
	                                             ix_Enable := TRUE);
	                
	                #sFB_TimerOnOffDelay_Hold710(iudi_OnDelayTime := #cudi_PushOutTime,
	                                             ix_SignalToDelay := NOT #sx_RightExternalRequestHold710
	                                             AND #iqUDT_WorkstationStatus."710".PEC_EoS.PEC,
	                                             ix_Enable := TRUE);
	            END_REGION
	            
	            REGION 2.3.2 - Right station delayed start of pushout conveyors
	                
	                #sFB_TimerOnOffDelay_Detect740(iudi_OnDelayTime := #cudi_DetectTime,
	                                               ix_SignalToDelay := NOT #iqUDT_WorkstationStatus."740".PEC_EoS.PEC,
	                                               ix_Enable := TRUE);
	                
	                #sFB_TimerOnOffDelay_Detect730(iudi_OnDelayTime := #cudi_DetectTime,
	                                               ix_SignalToDelay := NOT #iqUDT_WorkstationStatus."730".PEC_EoS.PEC,
	                                               ix_Enable := TRUE);
	                
	                #sFB_TimerOnOffDelay_Detect720(iudi_OnDelayTime := #cudi_DetectTime,
	                                               ix_SignalToDelay := NOT #iqUDT_WorkstationStatus."720".PEC_EoS.PEC,
	                                               ix_Enable := TRUE);
	                
	                #sFB_TimerOnOffDelay_Detect710(iudi_OnDelayTime := #cudi_DetectTime,
	                                               ix_SignalToDelay := NOT #iqUDT_WorkstationStatus."710".PEC_EoS.PEC,
	                                               ix_Enable := TRUE);
	            END_REGION
	            
	        END_REGION END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Maintenance
	    
	    IF #iUDT_Configuration.GlobalConfig.LeftStationExists THEN
	        
	        // hold gate conveyors after button press if no maintenance is performed
	        
	        IF #sx_GateIsDown111Filtered AND #sR_TRIG_B111.Q AND NOT #sx_MaintenanceIsPerformed THEN
	            
	            #sx_ExternalRequestHoldGate := TRUE;
	            #sx_MaintenanceIsPerformed := TRUE;
	            
	            // release gate conveyors if gate is down maintenance is performed after button press
	            
	        ELSIF #sx_GateIsDown111Filtered AND #sR_TRIG_B111.Q AND #sx_MaintenanceIsPerformed THEN
	            #sx_ExternalRequestHoldGate := FALSE;
	            #sx_MaintenanceIsPerformed := FALSE;
	            
	            // Hold conveyor if there is no maintenance perfomed and gate has been opened
	        ELSIF NOT #sx_GateIsDown111Filtered AND NOT #sx_MaintenanceIsPerformed THEN
	            #sx_ExternalRequestHoldGate := TRUE;
	        END_IF;
	        
	        IF #sx_MaintenanceIsPerformed AND #sx_GateIsDown111Filtered THEN
	            #qx_ButtonLight := TRUE;
	        ELSE
	            #qx_ButtonLight := FALSE;
	        END_IF;
	        
	        IF #iqUDT_EquipmentControl.Command.Reset AND #sx_GateIsDown111Filtered THEN   //reset hold and maintenance if gate is closed
	            #sx_ExternalRequestHoldGate := FALSE;
	            #sx_MaintenanceIsPerformed := FALSE;
	        END_IF;
	        
	    END_IF;
	END_REGION
	
	REGION 3 - Reset indexing 
	    IF #iqUDT_EquipmentControl.Command.Reset THEN
	        #sx_LeftIndexing := FALSE;
	        #sx_RightIndexing := FALSE;
	    END_IF;
	END_REGION
	
	REGION 4 - Middle line
	    REGION Middle RAT divert destinations
	        
	        //Set destination depending on station configuration
	        //If both are configured then divert depending on empty buffer spaces
	        //If buffer spaces count is the same divert to the currently indexed station
	        
	        IF #iUDT_Configuration.GlobalConfig.LeftStationExists AND NOT #iUDT_Configuration.GlobalConfig.RightStationExists THEN
	            
	            #si_DestinationC021 := 1;
	            
	        ELSIF NOT #iUDT_Configuration.GlobalConfig.LeftStationExists AND #iUDT_Configuration.GlobalConfig.RightStationExists THEN
	            
	            #si_DestinationC021 := 2;
	            
	        ELSIF #iUDT_Configuration.GlobalConfig.LeftStationExists AND #iUDT_Configuration.GlobalConfig.RightStationExists THEN
	            
	            IF #sFB_CountActiveInputs_LeftBuffer.qi_ActiveInputsCount > #sFB_CountActiveInputs_RightBuffer.qi_ActiveInputsCount THEN
	                #si_DestinationC021 := 1;
	                
	            ELSIF #sFB_CountActiveInputs_LeftBuffer.qi_ActiveInputsCount < #sFB_CountActiveInputs_RightBuffer.qi_ActiveInputsCount THEN
	                #si_DestinationC021 := 2;
	                
	            ELSIF #sFB_CountActiveInputs_LeftBuffer.qi_ActiveInputsCount = 0 AND #sFB_CountActiveInputs_RightBuffer.qi_ActiveInputsCount = 0 THEN
	                #si_DestinationC021 := 0;
	                
	            ELSIF #sFB_CountActiveInputs_LeftBuffer.qi_ActiveInputsCount = #sFB_CountActiveInputs_RightBuffer.qi_ActiveInputsCount THEN
	                
	                IF #sx_RightIndexing AND NOT #sx_LeftIndexing THEN
	                    
	                    #si_DestinationC021 := 2;
	                ELSIF NOT #sx_RightIndexing AND #sx_LeftIndexing THEN
	                    
	                    #si_DestinationC021 := 1;
	                    
	                END_IF;
	            END_IF;
	        END_IF;
	    END_REGION
	    
	    REGION 010
	        
	        REGION Displacement
	            
	            #sFB_Displacement010(#sUDT_Interface010);
	            
	        END_REGION
	        
	        REGION EOS
	            
	            #sFB_PEC010(ix_PEC := #iUDT_MotorInput010.AllSensorPortInputs.LeftSensor,
	                        iUDT_PECConfiguration := #iUDT_Configuration."010".PEC_Eos,
	                        qx_PECFiltered => #tx_dummy,
	                        qUDT_HMIStatus => #iqUDT_WorkstationStatus."010".PEC_EoS,
	                        iqUDT_ConveyorInterface := #sUDT_Interface010,
	                        iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."010".PEC_EoS);
	            
	        END_REGION
	        
	        REGION Conveyor
	            
	            #sUDT_Handshake010.RTR := #sUDT_Handshake010.RTR OR #iqUDT_WorkstationStatus."010".PEC_EoS.PEC;
	            
	            #sFB_Conveyor010(iUDT_ConveyorConfiguration := #iUDT_Configuration."010".Conveyor,
	                             idi_PECEoSDistance := #iUDT_Configuration."010".PEC_Eos.Distance,
	                             idi_PECBoSDistance := 0,
	                             ii_ExternalSpeed := 0,
	                             ix_SafetyOk := #ix_SafetyOk,
	                             ix_24vOk := #ix_24vOk,
	                             ix_400vOk := #ix_400vOk,
	                             ix_HardwareOk := #ix_HardwareOk,
	                             ix_PECEoS := #iqUDT_WorkstationStatus."010".PEC_EoS.PEC,
	                             ix_PECBoS := TRUE,
	                             ix_ReverseDirection := FALSE,
	                             ix_ExternalRequestDieBack := FALSE,
	                             ix_ExternalRequestHold := FALSE,
	                             ix_ResetEnergySave := FALSE,
	                             qUDT_HMIStatus => #iqUDT_WorkstationStatus."010".Conveyor,
	                             qUDT_Status => #iqUDT_WorkstationCommonStatus."010",
	                             iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                             iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."010".Conveyor,
	                             iqUDT_ConveyorInterface := #sUDT_Interface010,
	                             iqUDT_HandShakeUp := #iqUDT_HandshakeUpstream010,
	                             iqUDT_HandShake := #sUDT_Handshake010,
	                             iqUDT_Statistics := #iqUDT_WorkstationStatistics."010".Conveyor);
	        END_REGION
	        
	        REGION MCO
	            
	            #sFB_MCOConveyLinxAixController010(iUDT_AixConfig := #iUDT_Configuration."010".MCO_M01,
	                                               iUDT_AixInputsModule := #iUDT_MotorInput010,
	                                               ix_24vOk := #ix_24vOk,
	                                               ix_SimulationModeActive := "DB_Memory".Simulation,
	                                               ii_MotorPositionId := 1,
	                                               qUDT_HMIStatus => #iqUDT_WorkstationStatus."010".MCO_M01,
	                                               iqUDT_AixOutputsModule := #iqUDT_MotorOutput010,
	                                               iqUDT_ConveyorInterface := #sUDT_Interface010,
	                                               iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."010".MCO_M01);
	        END_REGION
	    END_REGION
	    
	    REGION 020
	        
	        REGION Displacement
	            
	            #sFB_Displacement020(#sUDT_Interface020);
	            
	        END_REGION
	        
	        REGION MCO
	            
	            #sFB_MCOConveyLinxAixController020(iUDT_AixConfig := #iUDT_Configuration."020".MCO_M01,
	                                               iUDT_AixInputsModule := #iUDT_MotorInput020,
	                                               ix_24vOk := #ix_24vOk,
	                                               ix_SimulationModeActive := "DB_Memory".Simulation,
	                                               ii_MotorPositionId := 1,
	                                               qUDT_HMIStatus => #iqUDT_WorkstationStatus."020".MCO_M01,
	                                               iqUDT_AixOutputsModule := #iqUDT_MotorOutput020,
	                                               iqUDT_ConveyorInterface := #sUDT_Interface020,
	                                               iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."020".MCO_M01);
	        END_REGION
	    END_REGION
	    
	    REGION 021
	        
	        REGION Displacement
	            
	            #sFB_Displacement021(#sUDT_Interface021);
	            
	        END_REGION
	        
	        REGION RAT
	            
	            #sFB_RightAngledTransfer021(iUDT_Configuration := #iUDT_Configuration."021".RightAngledTransfer,
	                                        iUDT_LowerConveyorConfiguration := #iUDT_Configuration."020".Conveyor,
	                                        iUDT_UpperConveyorConfiguration := #iUDT_Configuration."021".Conveyor,
	                                        iUDT_PECConfiguration := #iUDT_Configuration."020".PEC_EoS,
	                                        ii_DestinationA := 0,
	                                        ii_DestinationB := 0,
	                                        ii_DestinationC := #si_DestinationC021,
	                                        ii_DestinationD := 0,
	                                        ix_HardwareOk := #ix_HardwareOk,
	                                        ix_400vOk := #ix_400vOk,
	                                        ix_24vOk := #ix_24vOk,
	                                        ix_SafetyOk := #ix_SafetyOk,
	                                        ix_AirPressureOk := #ix_AirPressureOk,
	                                        ix_SectionIsDown := #ix_SectionIsDown021,
	                                        ix_SectionIsUp := #ix_SectionIsUp021,
	                                        ix_ConveyorAAuto := FALSE,
	                                        ix_ConveyorBAuto := false,
	                                        ix_ConveyorCAuto := #iqUDT_WorkstationCommonStatus."010".AutoON,
	                                        ix_ConveyorDAuto := false,
	                                        ix_PEC := #iUDT_MotorInput020.AllSensorPortInputs.LeftSensor,
	                                        ix_ExternalReceiveRequestA := FALSE,
	                                        ix_ExternalReceiveRequestB := FALSE,
	                                        ix_ExternalReceiveRequestC := NOT #iqUDT_WorkstationStatus."010".PEC_EoS.PEC,
	                                        ix_ExternalReceiveRequestD := FALSE,
	                                        ix_PECInfeedC := #iqUDT_WorkstationStatus."010".PEC_EoS.PEC,
	                                        qUDT_HMIRATStatus => #iqUDT_WorkstationStatus."021".RightAngledTransfer,
	                                        qUDT_HMIConveyorStatus => #iqUDT_WorkstationStatus."020".Conveyor,
	                                        qUDT_HMIPECStatus => #iqUDT_WorkstationStatus."020".PEC_EoS,
	                                        qUDT_RATStatus => #iqUDT_WorkstationCommonStatus."021",
	                                        qUDT_ConveyorStatus => #iqUDT_WorkstationCommonStatus."020",
	                                        qx_PopupControl => #qx_PopupControl021,
	                                        qx_ExternalSendRequestA => #tx_dummy,
	                                        qx_ExternalSendRequestB => #tx_dummy,
	                                        qx_ExternalSendRequestC => #tx_dummy,
	                                        qx_ExternalSendRequestD => #tx_dummy,
	                                        iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                        iqUDT_RATCommand := #iqUDT_WorkstationCommands."021".RAT,
	                                        iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."020".Conveyor,
	                                        iqUDT_RATStatistics := #iqUDT_WorkstationStatistics."021".RightAngledTransfer,
	                                        iqUDT_ConveyorStatistics := #iqUDT_WorkstationStatistics."020".Conveyor,
	                                        iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."020".PEC_EoS,
	                                        iqUDT_HandShakeConveyorA := #sUDT_HandshakeUp020,
	                                        iqUDT_HandShakeConveyorB := #sUDT_Handshake020,
	                                        iqUDT_HandShakeConveyorC := #sUDT_Handshake010,
	                                        iqUDT_HandShakeConveyorD := #tUDT_DummyConveyorHandshake,
	                                        iqUDT_LowerConveyorInterface := #sUDT_Interface020,
	                                        iqUDT_UpperConveyorInterface := #sUDT_Interface021,
	                                        iqUDT_RATPositioning := #iqUDT_RATPositioning020,
	                                        iqUDT_BladeStopEoSInterface := #tUDT_DummyBladeStop,
	                                        iqUDT_BladeStopBoSInterface := #tUDT_DummyBladeStop);
	            
	        END_REGION
	        
	        REGION MCO
	            
	            #sFB_MCOConveyLinxAixController021(iUDT_AixConfig := #iUDT_Configuration."021".MCO_M01,
	                                               iUDT_AixInputsModule := #iUDT_MotorInput020,
	                                               ii_PositionSetpoint := #iqUDT_RATPositioning020.Upper.EndPosition,
	                                               ix_24vOk := #ix_24vOk,
	                                               ix_SimulationModeActive := "DB_Memory".Simulation,
	                                               ii_MotorPositionId := 2,
	                                               ix_StartPositioning := #iqUDT_RATPositioning020.Upper.Start,
	                                               ix_ResetPosition := #iqUDT_RATPositioning020.Upper.ResetPosition,
	                                               qUDT_HMIStatus => #iqUDT_WorkstationStatus."021".MCO_M01,
	                                               qx_Positioned => #iqUDT_RATPositioning020.Upper.Done,
	                                               iqUDT_AixOutputsModule := #iqUDT_MotorOutput020,
	                                               iqUDT_ConveyorInterface := #sUDT_Interface021,
	                                               iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."021".MCO_M01);
	        END_REGION
	        
	    END_REGION
	    
	END_REGION
	
	REGION 5 - Left Station
	    IF #iUDT_Configuration.GlobalConfig.LeftStationExists THEN
	        
	        REGION 5.1 - Indexing 
	            
	            // Start indexing after request if there are empty stations and no pushout is active
	            
	            IF #iqUDT_CommunicationWES.LeftWorkstation.StartIndexing AND #si_LeftEmptyStations > 0
	                AND NOT (#sx_LeftPushOutActiveStation1
	                OR #sx_LeftPushOutActiveStation2
	                OR #sx_LeftPushOutActiveStation3
	                OR #sx_LeftPushOutActiveStation4
	                OR #sx_LeftPushOutActiveStation5) THEN
	                #sx_LeftIndexing := TRUE;
	            END_IF;
	            
	            IF NOT #sx_LeftIndexing THEN                           // If there is no indexing in progress
	                
	                #si_LeftDestinationC141 := 0;                     // Reset RAT destination
	                #sx_LeftExternalRequestHold150 := TRUE;           // Hold station conveyors 
	                #sx_LeftExternalRequestHold160 := TRUE;
	                #sx_LeftExternalRequestHold170 := TRUE;
	                #sx_LeftExternalRequestHold180 := TRUE;
	                #sx_LeftExternalRequestHold190 := TRUE;
	                
	            ELSE                                                // If there is indexing in progress
	                
	                IF #sR_TRIG_PEC140.Q AND #si_LeftEmptyStations > 0 THEN  //Count down empty stations after diverting a tote into station
	                    #si_LeftEmptyStations -= 1;
	                END_IF;
	                
	                #si_LeftDestinationC141 := 1;
	                #sx_LeftExternalRequestHold150 := FALSE;           // Release hold of station conveyors and set RAT destination
	                #sx_LeftExternalRequestHold160 := FALSE;
	                #sx_LeftExternalRequestHold170 := FALSE;
	                #sx_LeftExternalRequestHold180 := FALSE;
	                #sx_LeftExternalRequestHold190 := FALSE;
	                
	                IF
	                    NOT #iqUDT_WorkstationStatus."150".PEC_EoS.PEC       //End indexing when all totes are on position
	                    AND NOT #iqUDT_WorkstationStatus."160".PEC_EoS.PEC
	                    AND NOT #iqUDT_WorkstationStatus."170".PEC_EoS.PEC
	                    AND NOT #iqUDT_WorkstationStatus."180".PEC_EoS.PEC
	                    AND NOT #iqUDT_WorkstationStatus."190".PEC_EoS.PEC
	                    AND NOT (#sUDT_Interface150.ActualSpeed > 0) THEN
	                    
	                    #sx_LeftIndexing := FALSE;
	                    
	                END_IF;
	                
	            END_IF;
	            
	        END_REGION
	        
	        REGION 5.2 - Push Out
	            
	            REGION 5.2.0 Pushout conveyors hold
	                
	                IF #sFB_TimerOnOffDelay_Hold310.qx_DelayedSignal THEN
	                    #sx_LeftExternalRequestHold310 := TRUE;
	                END_IF;
	                
	                IF #sFB_TimerOnOffDelay_Hold320.qx_DelayedSignal THEN
	                    #sx_LeftExternalRequestHold320 := TRUE;
	                END_IF;
	                
	                IF #sFB_TimerOnOffDelay_Hold330.qx_DelayedSignal THEN
	                    #sx_LeftExternalRequestHold330 := TRUE;
	                END_IF;
	                
	                IF #sFB_TimerOnOffDelay_Hold340.qx_DelayedSignal THEN
	                    #sx_LeftExternalRequestHold340 := TRUE;
	                END_IF;
	                
	                IF #sFB_TimerOnOffDelay_Hold350.qx_DelayedSignal THEN
	                    #sx_LeftExternalRequestHold350 := TRUE;
	                END_IF;
	            END_REGION
	            
	            REGION 5.2.1 - Push Out Station 1
	                
	                // Start automatic pushout after request if there is no indexing procedure and a tote is present on first station
	                IF #iqUDT_CommunicationWES.LeftWorkstation.Station1.ReadyForPush AND NOT #sx_LeftIndexing
	                    AND NOT #iqUDT_WorkstationStatus."190".PEC_EoS.PEC THEN
	                    
	                    #sx_LeftPushOutActiveStation1 := TRUE;
	                END_IF;
	                
	                IF #sx_LeftPushOutActiveStation1 THEN
	                    #sx_LeftExternalRequestHold190 := FALSE;    //release hold
	                    
	                    IF #sFB_RightAngledTransfer211.qx_ExternalSendRequestB THEN   //after tote is already on RAT, hold the conveyor and end pushout procedure
	                        #sx_LeftExternalRequestHold190 := TRUE;
	                        #sx_LeftPushOutActiveStation1 := FALSE;
	                    END_IF;
	                END_IF;
	                
	            END_REGION
	            
	            REGION 5.2.2 - Push Out station 2
	                
	                IF #iqUDT_CommunicationWES.LeftWorkstation.Station2.ReadyForPush THEN //set pushout to active after request
	                    #sx_LeftPushOutActiveStation2 := TRUE;
	                END_IF;
	                
	                IF #sx_LeftPushOutActiveStation2              // After station is empty and tote has been detected on pushout conveyor release holds
	                    AND #iqUDT_WorkstationStatus."180".PEC_EoS.PEC
	                    AND #sFB_TimerOnOffDelay_Detect340.qx_DelayedSignal THEN
	                    
	                    #sx_LeftExternalRequestHold340 := FALSE;
	                    #sx_LeftExternalRequestHold350 := FALSE;
	                    
	                    FILL_BLK(IN := 0,                                 //clear tracking
	                             COUNT := REAL_TO_ULINT(DINT_TO_REAL(#iUDT_Configuration."180".Conveyor.Common.Length) * #cr_ClearTrackingModifier),
	                             OUT => #sa_TrackingArray180[0]);
	                    
	                    #sx_LeftPushOutActiveStation2 := FALSE;            //end pushout procedure
	                    
	                END_IF;
	                
	                
	            END_REGION
	            
	            REGION 5.2.3 - Push Out station 3
	                
	                IF #iqUDT_CommunicationWES.LeftWorkstation.Station3.ReadyForPush THEN        //set pushout to active after request
	                    #sx_LeftPushOutActiveStation3 := TRUE;
	                END_IF;
	                
	                IF #sx_LeftPushOutActiveStation3                             // After station is empty and tote has been detected on pushout conveyor release holds
	                    AND #iqUDT_WorkstationStatus."170".PEC_EoS.PEC
	                    AND #sFB_TimerOnOffDelay_Detect330.qx_DelayedSignal THEN
	                    
	                    #sx_LeftExternalRequestHold330 := FALSE;
	                    #sx_LeftExternalRequestHold340 := FALSE;
	                    #sx_LeftExternalRequestHold350 := FALSE;
	                    
	                    FILL_BLK(IN := 0,                                      //clear tracking
	                             COUNT := REAL_TO_ULINT(DINT_TO_REAL(#iUDT_Configuration."170".Conveyor.Common.Length) * #cr_ClearTrackingModifier),
	                             OUT => #sa_TrackingArray170[0]);
	                    
	                    #sx_LeftPushOutActiveStation3 := FALSE;                  //end pushout procedure
	                    
	                END_IF;
	            END_REGION
	            
	            REGION 5.2.4 - Push Out station 4
	                
	                IF #iqUDT_CommunicationWES.LeftWorkstation.Station4.ReadyForPush THEN         //set pushout to active after request
	                    #sx_LeftPushOutActiveStation4 := TRUE;
	                END_IF;
	                
	                IF #sx_LeftPushOutActiveStation4                           // After station is empty and tote has been detected on pushout conveyor release holds
	                    AND #iqUDT_WorkstationStatus."160".PEC_EoS.PEC
	                    AND #sFB_TimerOnOffDelay_Detect320.qx_DelayedSignal THEN
	                    
	                    #sx_LeftExternalRequestHold320 := FALSE;
	                    #sx_LeftExternalRequestHold330 := FALSE;
	                    #sx_LeftExternalRequestHold340 := FALSE;
	                    #sx_LeftExternalRequestHold350 := FALSE;
	                    
	                    FILL_BLK(IN := 0,                                     //clear tracking
	                             COUNT := REAL_TO_ULINT(DINT_TO_REAL(#iUDT_Configuration."160".Conveyor.Common.Length) * #cr_ClearTrackingModifier),
	                             OUT => #sa_TrackingArray160[0]);
	                    
	                    #sx_LeftPushOutActiveStation4 := FALSE;               //end pushout procedure
	                    
	                END_IF;
	                
	            END_REGION
	            
	            REGION 5.2.5 - Push Out station 5
	                
	                IF #iqUDT_CommunicationWES.LeftWorkstation.Station5.ReadyForPush THEN          //set pushout to active after request
	                    #sx_LeftPushOutActiveStation5 := TRUE;
	                END_IF;
	                
	                IF #sx_LeftPushOutActiveStation5                                   // After station is empty and tote has been detected on pushout conveyor release holds
	                    AND #iqUDT_WorkstationStatus."150".PEC_EoS.PEC
	                    AND #sFB_TimerOnOffDelay_Detect310.qx_DelayedSignal THEN
	                    
	                    #sx_LeftExternalRequestHold310 := FALSE;
	                    #sx_LeftExternalRequestHold320 := FALSE;
	                    #sx_LeftExternalRequestHold330 := FALSE;
	                    #sx_LeftExternalRequestHold340 := FALSE;
	                    #sx_LeftExternalRequestHold350 := FALSE;
	                    
	                    FILL_BLK(IN := 0,                                                 //clear tracking
	                             COUNT := REAL_TO_ULINT(DINT_TO_REAL(#iUDT_Configuration."150".Conveyor.Common.Length) * #cr_ClearTrackingModifier),
	                             OUT => #sa_TrackingArray150[0]);
	                    
	                    #sx_LeftPushOutActiveStation5 := FALSE;                     //end pushout procedure
	                END_IF;
	                
	            END_REGION
	        END_REGION
	        
	        REGION 5.3 WES communication
	            REGION 5.3.1 Lost track error
	                
	                IF NOT #sx_LeftIndexing
	                    AND NOT #sx_LeftPushOutActiveStation1
	                    AND #sa_TrackingArray190[30] >= 1000
	                    AND #iqUDT_WorkstationStatus."190".PEC_EoS.PEC THEN
	                    #iqUDT_CommunicationWES.LeftWorkstation.Station1.Error := TRUE
	                    ;
	                END_IF;
	                
	                IF NOT #sx_LeftIndexing
	                    AND NOT #sx_LeftPushOutActiveStation2
	                    AND #sa_TrackingArray180[30] >= 1000
	                    AND #iqUDT_WorkstationStatus."180".PEC_EoS.PEC THEN
	                    #iqUDT_CommunicationWES.LeftWorkstation.Station2.Error := TRUE;
	                END_IF;
	                
	                IF NOT #sx_LeftIndexing
	                    AND NOT #sx_LeftPushOutActiveStation3
	                    AND #sa_TrackingArray170[30] >= 1000
	                    AND #iqUDT_WorkstationStatus."170".PEC_EoS.PEC THEN
	                    #iqUDT_CommunicationWES.LeftWorkstation.Station3.Error := TRUE;
	                END_IF;
	                
	                IF NOT #sx_LeftIndexing
	                    AND NOT #sx_LeftPushOutActiveStation4
	                    AND #sa_TrackingArray160[30] >= 1000
	                    AND #iqUDT_WorkstationStatus."160".PEC_EoS.PEC THEN
	                    #iqUDT_CommunicationWES.LeftWorkstation.Station4.Error := TRUE;
	                END_IF;
	                
	                IF NOT #sx_LeftIndexing
	                    AND NOT #sx_LeftPushOutActiveStation5
	                    AND #sa_TrackingArray150[30] >= 1000
	                    AND #iqUDT_WorkstationStatus."150".PEC_EoS.PEC THEN
	                    #iqUDT_CommunicationWES.LeftWorkstation.Station5.Error := TRUE;
	                END_IF;
	                
	            END_REGION
	            
	            REGION 5.3.2 Reset lost errors
	                
	                IF #iqUDT_EquipmentControl.Command.Reset                   // Reset command received 
	                THEN
	                    #iqUDT_CommunicationWES.LeftWorkstation.Station1.Error := FALSE;
	                    #iqUDT_CommunicationWES.LeftWorkstation.Station2.Error := FALSE;
	                    #iqUDT_CommunicationWES.LeftWorkstation.Station3.Error := FALSE;
	                    #iqUDT_CommunicationWES.LeftWorkstation.Station4.Error := FALSE;
	                    #iqUDT_CommunicationWES.LeftWorkstation.Station5.Error := FALSE;
	                END_IF;
	                
	            END_REGION
	            
	            REGION 5.3.3 GIN at station
	                IF NOT #sx_LeftIndexing THEN
	                    IF NOT #sx_LeftPushOutActiveStation1 THEN
	                        #iqUDT_CommunicationWES.LeftWorkstation.Station1.Gin := #sa_TrackingArray190[23];
	                    END_IF;
	                    #iqUDT_CommunicationWES.LeftWorkstation.Station2.Gin := #sa_TrackingArray180[23];
	                    #iqUDT_CommunicationWES.LeftWorkstation.Station3.Gin := #sa_TrackingArray170[23];
	                    #iqUDT_CommunicationWES.LeftWorkstation.Station4.Gin := #sa_TrackingArray160[23];
	                    #iqUDT_CommunicationWES.LeftWorkstation.Station5.Gin := #sa_TrackingArray150[23];
	                END_IF;
	            END_REGION
	            
	            REGION 5.3.4 Barcode at station
	                //Write barcode to WES
	                
	                IF (#iqUDT_CommunicationWES.LeftWorkstation.Station1.Gin > 0) AND (#iqUDT_CommunicationWES.LeftWorkstation.Station1.Gin < 10000) THEN
	                    #iqUDT_CommunicationWES.LeftWorkstation.Station1.Barcode := "DB_GIN".GIN[#iqUDT_CommunicationWES.LeftWorkstation.Station1.Gin].WES.Barcode;
	                ELSE
	                    #iqUDT_CommunicationWES.LeftWorkstation.Station1.Barcode := '          ';
	                END_IF;
	                
	                IF (#iqUDT_CommunicationWES.LeftWorkstation.Station2.Gin > 0) AND (#iqUDT_CommunicationWES.LeftWorkstation.Station2.Gin < 10000) THEN
	                    #iqUDT_CommunicationWES.LeftWorkstation.Station2.Barcode := "DB_GIN".GIN[#iqUDT_CommunicationWES.LeftWorkstation.Station2.Gin].WES.Barcode;
	                ELSE
	                    #iqUDT_CommunicationWES.LeftWorkstation.Station2.Barcode := '          ';
	                END_IF;
	                
	                IF (#iqUDT_CommunicationWES.LeftWorkstation.Station3.Gin > 0) AND (#iqUDT_CommunicationWES.LeftWorkstation.Station3.Gin < 10000) THEN
	                    #iqUDT_CommunicationWES.LeftWorkstation.Station3.Barcode := "DB_GIN".GIN[#iqUDT_CommunicationWES.LeftWorkstation.Station3.Gin].WES.Barcode;
	                ELSE
	                    #iqUDT_CommunicationWES.LeftWorkstation.Station3.Barcode := '          ';
	                END_IF;
	                
	                IF (#iqUDT_CommunicationWES.LeftWorkstation.Station4.Gin > 0) AND (#iqUDT_CommunicationWES.LeftWorkstation.Station4.Gin < 10000) THEN
	                    #iqUDT_CommunicationWES.LeftWorkstation.Station4.Barcode := "DB_GIN".GIN[#iqUDT_CommunicationWES.LeftWorkstation.Station4.Gin].WES.Barcode;
	                ELSE
	                    #iqUDT_CommunicationWES.LeftWorkstation.Station4.Barcode := '          ';
	                END_IF;
	                
	                IF (#iqUDT_CommunicationWES.LeftWorkstation.Station5.Gin > 0) AND (#iqUDT_CommunicationWES.LeftWorkstation.Station5.Gin < 10000) THEN
	                    #iqUDT_CommunicationWES.LeftWorkstation.Station5.Barcode := "DB_GIN".GIN[#iqUDT_CommunicationWES.LeftWorkstation.Station5.Gin].WES.Barcode;
	                ELSE
	                    #iqUDT_CommunicationWES.LeftWorkstation.Station5.Barcode := '          ';
	                END_IF;
	                
	            END_REGION
	        END_REGION
	        
	        REGION 5.4 Function Block calls
	            REGION 110
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement110(#sUDT_Interface110);
	                    
	                END_REGION
	                
	                REGION Tracking
	                    #sFB_Tracking110(iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."110".Conveyor.Common,
	                                     iqa_TrackingData := #sa_TrackingArray110,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface110,
	                                     iqUDT_HandshakeUp := #sUDT_Handshake020,
	                                     iqUDT_Handshake := #sUDT_Handshake110);
	                    
	                END_REGION
	                
	                REGION EOS
	                    #sFB_PECUpdate110(iUDT_PECUpdateConfiguration := #iUDT_Configuration."110".PEC_Eos,
	                                      iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."110".Conveyor.Common,
	                                      ix_PEC := NOT #iUDT_MotorInput110.AllSensorPortInputs.LeftSensor,
	                                      ix_TeachingMode := FALSE,
	                                      qUDT_Status => #iqUDT_WorkstationStatus."110".PEC_EoS,
	                                      qi_GINwrite => #ti_dummy,
	                                      qx_PECFiltered => #tx_dummy,
	                                      iqUDT_ConveyorInterface := #sUDT_Interface110,
	                                      iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                                      iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                                      iqUDT_Statistics := #iqUDT_WorkstationStatistics."110".PEC_EoS,
	                                      iqa_TrackingData := #sa_TrackingArray110,
	                                      iqa_FifoData := "DB_FIFOLostGIN".Data);
	                    
	                END_REGION
	                
	                REGION Conveyor
	                    
	                    #sFB_Conveyor110(iUDT_ConveyorConfiguration := #iUDT_Configuration."110".Conveyor,
	                                     idi_PECEoSDistance := #iUDT_Configuration."110".PEC_Eos.Distance,
	                                     idi_PECBoSDistance := 0,
	                                     ii_ExternalSpeed := 0,
	                                     ix_SafetyOk := #ix_SafetyOk,
	                                     ix_24vOk := #ix_24vOk,
	                                     ix_400vOk := #ix_400vOk,
	                                     ix_HardwareOk := #ix_HardwareOk,
	                                     ix_PECEoS := #iqUDT_WorkstationStatus."110".PEC_EoS.PEC,
	                                     ix_PECBoS := TRUE,
	                                     ix_ReverseDirection := FALSE,
	                                     ix_ExternalRequestDieBack := FALSE,
	                                     ix_ExternalRequestHold := NOT #sx_GateIsDown111Filtered OR #sx_ExternalRequestHoldGate,
	                                     ix_ResetEnergySave := FALSE,
	                                     qUDT_HMIStatus => #iqUDT_WorkstationStatus."110".Conveyor,
	                                     qUDT_Status => #iqUDT_WorkstationCommonStatus."110",
	                                     iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                     iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."110".Conveyor,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface110,
	                                     iqUDT_HandShakeUp := #sUDT_Handshake020,
	                                     iqUDT_HandShake := #sUDT_Handshake110,
	                                     iqUDT_Statistics := #iqUDT_WorkstationStatistics."110".Conveyor);
	                    
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController110(iUDT_AixConfig := #iUDT_Configuration."110".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput110,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 1,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."110".MCO_M01,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput110,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface110,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."110".MCO_M01);
	                END_REGION
	            END_REGION
	            
	            REGION 120
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement120(#sUDT_Interface120);
	                    
	                END_REGION
	                
	                REGION Tracking
	                    
	                    #sFB_Tracking120(iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."120".Conveyor.Common,
	                                     iqa_TrackingData := #sa_TrackingArray120,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface120,
	                                     iqUDT_HandshakeUp := #sUDT_Handshake110,
	                                     iqUDT_Handshake := #sUDT_Handshake120);
	                    
	                END_REGION
	                
	                REGION Conveyor
	                    
	                    #sFB_Conveyor120(iUDT_ConveyorConfiguration := #iUDT_Configuration."120".Conveyor,
	                                     idi_PECEoSDistance := 0,
	                                     idi_PECBoSDistance := 0,
	                                     ii_ExternalSpeed := 0,
	                                     ix_SafetyOk := #ix_SafetyOk,
	                                     ix_24vOk := #ix_24vOk,
	                                     ix_400vOk := #ix_400vOk,
	                                     ix_HardwareOk := #ix_HardwareOk,
	                                     ix_PECEoS := #iqUDT_WorkstationStatus."120".PEC_EoS.PEC,
	                                     ix_PECBoS := TRUE,
	                                     ix_ReverseDirection := FALSE,
	                                     ix_ExternalRequestDieBack := FALSE,
	                                     ix_ExternalRequestHold := NOT #sx_GateIsDown111Filtered OR #sx_ExternalRequestHoldGate,
	                                     ix_ResetEnergySave := FALSE,
	                                     qUDT_HMIStatus => #iqUDT_WorkstationStatus."120".Conveyor,
	                                     qUDT_Status => #iqUDT_WorkstationCommonStatus."120",
	                                     iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                     iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."120".Conveyor,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface120,
	                                     iqUDT_HandShakeUp := #sUDT_Handshake110,
	                                     iqUDT_HandShake := #sUDT_Handshake120,
	                                     iqUDT_Statistics := #iqUDT_WorkstationStatistics."120".Conveyor);
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController120(iUDT_AixConfig := #iUDT_Configuration."120".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput110,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 2,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."120".MCO_M01,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput110,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface120,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."120".MCO_M01);
	                END_REGION
	                
	            END_REGION
	            
	            REGION 130
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement130(#sUDT_Interface130);
	                    
	                END_REGION
	                
	                REGION Tracking
	                    
	                    #sFB_Tracking130(iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."130".Conveyor.Common,
	                                     iqa_TrackingData := #sa_TrackingArray130,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface130,
	                                     iqUDT_HandshakeUp := #sUDT_Handshake120,
	                                     iqUDT_Handshake := #sUDT_Handshake130);
	                    
	                END_REGION
	                
	                REGION EOS
	                    #sFB_PECUpdate130(iUDT_PECUpdateConfiguration := #iUDT_Configuration."130".PEC_Eos,
	                                      iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."130".Conveyor.Common,
	                                      ix_PEC := NOT #iUDT_MotorInput130.AllSensorPortInputs.LeftSensor,
	                                      ix_TeachingMode := FALSE,
	                                      qUDT_Status => #iqUDT_WorkstationStatus."130".PEC_EoS,
	                                      qi_GINwrite => #ti_dummy,
	                                      qx_PECFiltered => #tx_dummy,
	                                      iqUDT_ConveyorInterface := #sUDT_Interface130,
	                                      iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                                      iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                                      iqUDT_Statistics := #iqUDT_WorkstationStatistics."130".PEC_EoS,
	                                      iqa_TrackingData := #sa_TrackingArray130,
	                                      iqa_FifoData := "DB_FIFOLostGIN".Data);
	                    
	                END_REGION
	                
	                REGION Scanner
	                    
	                    #sFB_CognexDM130(iUDT_CognexDM260_IN := #iUDT_ScannerInput130,
	                                     iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                     ix_Trigger := #sa_TrackingArray130[38] > 1000,
	                                     qUDT_CognexDM260_OUT => #qUDT_ScannerOutput130,
	                                     qs_Barcode => #ts_Barcode130,
	                                     qw_RetVal => #tw_dummy);
	                    
	                    IF #sa_TrackingArray130[38] > 0 THEN
	                        #ti_GIN130 := #sa_TrackingArray130[38];
	                        "DB_GIN".GIN[#ti_GIN130].WES.Barcode := #ts_Barcode130;
	                    END_IF;
	                    
	                END_REGION
	                
	                
	                REGION Conveyor
	                    
	                    // #sUDT_Handshake130.RTR := #iqUDT_WorkstationStatus."130".PEC_EoS.PEC OR
	                    // (#iqUDT_WorkstationStatus."140".PEC_EoS.PEC AND #sUDT_Interface140.ActualSpeed <> 0);
	                    
	                    #sFB_Conveyor130(iUDT_ConveyorConfiguration := #iUDT_Configuration."130".Conveyor,
	                                     idi_PECEoSDistance := #iUDT_Configuration."130".PEC_Eos.Distance,
	                                     idi_PECBoSDistance := 0,
	                                     ii_ExternalSpeed := 0,
	                                     ix_SafetyOk := #ix_SafetyOk,
	                                     ix_24vOk := #ix_24vOk,
	                                     ix_400vOk := #ix_400vOk,
	                                     ix_HardwareOk := #ix_HardwareOk,
	                                     ix_PECEoS := #iqUDT_WorkstationStatus."130".PEC_EoS.PEC,
	                                     ix_PECBoS := TRUE,
	                                     ix_ReverseDirection := FALSE,
	                                     ix_ExternalRequestDieBack := FALSE,
	                                     ix_ExternalRequestHold := FALSE,
	                                     ix_ResetEnergySave := FALSE,
	                                     qUDT_HMIStatus => #iqUDT_WorkstationStatus."130".Conveyor,
	                                     qUDT_Status => #iqUDT_WorkstationCommonStatus."130",
	                                     iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                     iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."130".Conveyor,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface130,
	                                     iqUDT_HandShakeUp := #sUDT_Handshake120,
	                                     iqUDT_HandShake := #sUDT_Handshake130,
	                                     iqUDT_Statistics := #iqUDT_WorkstationStatistics."130".Conveyor);
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController130(iUDT_AixConfig := #iUDT_Configuration."130".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput130,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 1,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."130".MCO_M01,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput130,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface130,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."130".MCO_M01);
	                END_REGION
	            END_REGION
	            
	            REGION 140
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement140(#sUDT_Interface140);
	                    
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController140(iUDT_AixConfig := #iUDT_Configuration."140".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput140,
	                                                       ii_PositionSetpoint := #iqUDT_RATPositioning140.Lower.EndPosition,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 1,
	                                                       ix_StartPositioning := #iqUDT_RATPositioning140.Lower.Start,
	                                                       ix_ResetPosition := #iqUDT_RATPositioning140.Lower.ResetPosition,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."140".MCO_M01,
	                                                       qx_Positioned => #iqUDT_RATPositioning140.Lower.Done,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput140,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface140,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."140".MCO_M01);
	                END_REGION
	            END_REGION
	            
	            REGION 141
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement141(#sUDT_Interface141);
	                    
	                END_REGION
	                
	                REGION RAT
	                    
	                    #sUDT_Handshake141.RTR := #sx_LeftIndexing AND
	                    (#iqUDT_WorkstationStatus."150".PEC_EoS.PEC AND #sUDT_Interface150.ActualSpeed <> 0);
	                    
	                    #sFB_RightAngledTransfer141(iUDT_Configuration := #iUDT_Configuration."141".RightAngledTransfer,
	                                                iUDT_LowerConveyorConfiguration := #iUDT_Configuration."140".Conveyor,
	                                                iUDT_UpperConveyorConfiguration := #iUDT_Configuration."141".Conveyor,
	                                                iUDT_PECConfiguration := #iUDT_Configuration."140".PEC_EoS,
	                                                ii_DestinationA := #si_LeftDestinationC141,
	                                                ii_DestinationB := 0,
	                                                ii_DestinationC := 0,
	                                                ii_DestinationD := 0,
	                                                ix_HardwareOk := #ix_HardwareOk,
	                                                ix_400vOk := #ix_400vOk,
	                                                ix_24vOk := #ix_24vOk,
	                                                ix_SafetyOk := #ix_SafetyOk,
	                                                ix_AirPressureOk := #ix_AirPressureOk,
	                                                ix_SectionIsDown := #ix_SectionIsDown141,
	                                                ix_SectionIsUp := #ix_SectionIsUp141,
	                                                ix_ConveyorAAuto := #iqUDT_WorkstationCommonStatus."130".AutoON,
	                                                ix_ConveyorBAuto := false,
	                                                ix_ConveyorCAuto := false,
	                                                ix_ConveyorDAuto := false,
	                                                ix_PEC := #iUDT_MotorInput140.AllSensorPortInputs.LeftSensor,
	                                                ix_ExternalReceiveRequestA := NOT #iqUDT_WorkstationStatus."130".PEC_EoS.PEC,
	                                                ix_ExternalReceiveRequestB := FALSE,
	                                                ix_ExternalReceiveRequestC := FALSE,
	                                                ix_ExternalReceiveRequestD := FALSE,
	                                                ix_PECInfeedA := #iqUDT_WorkstationStatus."130".PEC_EoS.PEC,
	                                                qUDT_HMIRATStatus => #iqUDT_WorkstationStatus."141".RightAngledTransfer,
	                                                qUDT_HMIConveyorStatus => #iqUDT_WorkstationStatus."140".Conveyor,
	                                                qUDT_HMIPECStatus => #iqUDT_WorkstationStatus."140".PEC_EoS,
	                                                qUDT_RATStatus => #iqUDT_WorkstationCommonStatus."141",
	                                                qUDT_ConveyorStatus => #iqUDT_WorkstationCommonStatus."140",
	                                                qx_PopupControl => #qx_PopupControl141,
	                                                qx_ExternalSendRequestA => #tx_dummy,
	                                                qx_ExternalSendRequestB => #tx_dummy,
	                                                qx_ExternalSendRequestC => #tx_dummy,
	                                                qx_ExternalSendRequestD => #tx_dummy,
	                                                iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                                iqUDT_RATCommand := #iqUDT_WorkstationCommands."141".RightAngledTransfer,
	                                                iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."140".Conveyor,
	                                                iqUDT_RATStatistics := #iqUDT_WorkstationStatistics."141".RightAngledTransfer,
	                                                iqUDT_ConveyorStatistics := #iqUDT_WorkstationStatistics."140".Conveyor,
	                                                iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."140".PEC_EoS,
	                                                iqUDT_HandShakeConveyorA := #sUDT_Handshake130,
	                                                iqUDT_HandShakeConveyorB := #tUDT_DummyConveyorHandshake,
	                                                iqUDT_HandShakeConveyorC := #sUDT_Handshake141,
	                                                iqUDT_HandShakeConveyorD := #tUDT_DummyConveyorHandshake,
	                                                iqUDT_LowerConveyorInterface := #sUDT_Interface140,
	                                                iqUDT_UpperConveyorInterface := #sUDT_Interface141,
	                                                iqUDT_RATPositioning := #iqUDT_RATPositioning140,
	                                                iqUDT_BladeStopEoSInterface := #tUDT_DummyBladeStop,
	                                                iqUDT_BladeStopBoSInterface := #tUDT_DummyBladeStop);
	                    
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController141(iUDT_AixConfig := #iUDT_Configuration."141".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput140,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 2,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."141".MCO_M01,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput140,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface141,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."141".MCO_M01);
	                END_REGION
	                
	            END_REGION
	            
	            REGION 150
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement150(#sUDT_Interface150);
	                    
	                END_REGION
	                
	                REGION Tracking
	                    
	                    #sFB_Tracking150(iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."150".Conveyor.Common,
	                                     iqa_TrackingData := #sa_TrackingArray150,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface150,
	                                     iqUDT_HandshakeUp := #sUDT_Handshake141,
	                                     iqUDT_Handshake := #sUDT_Handshake150);
	                END_REGION
	                
	                REGION EOS
	                    
	                    #sFB_PECUpdate150(iUDT_PECUpdateConfiguration := #iUDT_Configuration."150".PEC_Eos,
	                                      iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."150".Conveyor.Common,
	                                      ix_PEC := NOT #iUDT_MotorInput150.AllSensorPortInputs.LeftSensor,
	                                      ix_TeachingMode := FALSE,
	                                      qUDT_Status => #iqUDT_WorkstationStatus."150".PEC_EoS,
	                                      qi_GINwrite => #ti_dummy,
	                                      qx_PECFiltered => #tx_dummy,
	                                      iqa_TrackingData := #sa_TrackingArray150,
	                                      iqUDT_ConveyorInterface := #sUDT_Interface150,
	                                      iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                                      iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                                      iqa_FifoData := "DB_FIFOLostGIN".Data,
	                                      iqUDT_Statistics := #iqUDT_WorkstationStatistics."150".PEC_EoS);
	                    
	                END_REGION
	                
	                REGION Conveyor
	                    
	                    #sUDT_Handshake150.RTR := #sx_LeftIndexing AND
	                    ((#iqUDT_WorkstationStatus."160".PEC_EoS.PEC AND #sUDT_Interface160.ActualSpeed <> 0) OR #iqUDT_WorkstationStatus."150".PEC_EoS.PEC);
	                    
	                    #sFB_Conveyor150(iUDT_ConveyorConfiguration := #iUDT_Configuration."150".Conveyor,
	                                     idi_PECEoSDistance := #iUDT_Configuration."150".PEC_Eos.Distance,
	                                     idi_PECBoSDistance := 0,
	                                     ii_ExternalSpeed := 0,
	                                     ix_SafetyOk := #ix_SafetyOk,
	                                     ix_24vOk := #ix_24vOk,
	                                     ix_400vOk := #ix_400vOk,
	                                     ix_HardwareOk := #ix_HardwareOk,
	                                     ix_PECEoS := #iqUDT_WorkstationStatus."150".PEC_EoS.PEC,
	                                     ix_PECBoS := TRUE,
	                                     ix_ReverseDirection := FALSE,
	                                     ix_ExternalRequestDieBack := FALSE,
	                                     ix_ExternalRequestHold := #sx_LeftExternalRequestHold150,
	                                     ix_ResetEnergySave := FALSE,
	                                     qUDT_HMIStatus => #iqUDT_WorkstationStatus."150".Conveyor,
	                                     qUDT_Status => #iqUDT_WorkstationCommonStatus."150",
	                                     iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                     iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."150".Conveyor,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface150,
	                                     iqUDT_HandShakeUp := #sUDT_Handshake141,
	                                     iqUDT_HandShake := #sUDT_Handshake150,
	                                     iqUDT_Statistics := #iqUDT_WorkstationStatistics."150".Conveyor);
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController150(iUDT_AixConfig := #iUDT_Configuration."150".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput150,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 1,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."150".MCO_M01,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput150,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface150,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."150".MCO_M01);
	                END_REGION
	                
	            END_REGION
	            
	            REGION 160
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement160(#sUDT_Interface160);
	                    
	                END_REGION
	                
	                REGION Tracking
	                    
	                    #sFB_Tracking160(iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."160".Conveyor.Common,
	                                     iqa_TrackingData := #sa_TrackingArray160,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface160,
	                                     iqUDT_HandshakeUp := #sUDT_Handshake150,
	                                     iqUDT_Handshake := #sUDT_Handshake160);
	                END_REGION
	                
	                REGION EOS
	                    
	                    #sFB_PECUpdate160(iUDT_PECUpdateConfiguration := #iUDT_Configuration."160".PEC_Eos,
	                                      iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."160".Conveyor.Common,
	                                      ix_PEC := NOT #iUDT_MotorInput150.AllSensorPortInputs.RightSensor,
	                                      ix_TeachingMode := FALSE,
	                                      qUDT_Status => #iqUDT_WorkstationStatus."160".PEC_EoS,
	                                      qi_GINwrite => #ti_dummy,
	                                      qx_PECFiltered => #tx_dummy,
	                                      iqa_TrackingData := #sa_TrackingArray160,
	                                      iqUDT_ConveyorInterface := #sUDT_Interface160,
	                                      iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                                      iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                                      iqa_FifoData := "DB_FIFOLostGIN".Data,
	                                      iqUDT_Statistics := #iqUDT_WorkstationStatistics."160".PEC_EoS);
	                    
	                END_REGION
	                
	                REGION Conveyor
	                    
	                    #sUDT_Handshake160.RTR := #sx_LeftIndexing AND
	                    ((#iqUDT_WorkstationStatus."170".PEC_EoS.PEC AND #sUDT_Interface170.ActualSpeed <> 0) OR #iqUDT_WorkstationStatus."160".PEC_EoS.PEC);
	                    
	                    #sFB_Conveyor160(iUDT_ConveyorConfiguration := #iUDT_Configuration."160".Conveyor,
	                                     idi_PECEoSDistance := #iUDT_Configuration."160".PEC_Eos.Distance,
	                                     idi_PECBoSDistance := 0,
	                                     ii_ExternalSpeed := 0,
	                                     ix_SafetyOk := #ix_SafetyOk,
	                                     ix_24vOk := #ix_24vOk,
	                                     ix_400vOk := #ix_400vOk,
	                                     ix_HardwareOk := #ix_HardwareOk,
	                                     ix_PECEoS := #iqUDT_WorkstationStatus."160".PEC_EoS.PEC,
	                                     ix_PECBoS := TRUE,
	                                     ix_ReverseDirection := FALSE,
	                                     ix_ExternalRequestDieBack := FALSE,
	                                     ix_ExternalRequestHold := #sx_LeftExternalRequestHold160,
	                                     ix_ResetEnergySave := FALSE,
	                                     qUDT_HMIStatus => #iqUDT_WorkstationStatus."160".Conveyor,
	                                     qUDT_Status => #iqUDT_WorkstationCommonStatus."160",
	                                     iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                     iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."160".Conveyor,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface160,
	                                     iqUDT_HandShakeUp := #sUDT_Handshake150,
	                                     iqUDT_HandShake := #sUDT_Handshake160,
	                                     iqUDT_Statistics := #iqUDT_WorkstationStatistics."160".Conveyor);
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController160(iUDT_AixConfig := #iUDT_Configuration."160".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput150,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 2,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."160".MCO_M01,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput150,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface160,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."160".MCO_M01);
	                END_REGION
	            END_REGION
	            
	            REGION 170
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement170(#sUDT_Interface170);
	                    
	                END_REGION
	                
	                REGION Tracking
	                    
	                    #sFB_Tracking170(iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."170".Conveyor.Common,
	                                     iqa_TrackingData := #sa_TrackingArray170,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface170,
	                                     iqUDT_HandshakeUp := #sUDT_Handshake160,
	                                     iqUDT_Handshake := #sUDT_Handshake170);
	                END_REGION
	                
	                REGION EOS
	                    
	                    #sFB_PECUpdate170(iUDT_PECUpdateConfiguration := #iUDT_Configuration."170".PEC_Eos,
	                                      iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."170".Conveyor.Common,
	                                      ix_PEC := NOT #iUDT_MotorInput170.AllSensorPortInputs.LeftSensor,
	                                      ix_TeachingMode := FALSE,
	                                      qUDT_Status => #iqUDT_WorkstationStatus."170".PEC_EoS,
	                                      qi_GINwrite => #ti_dummy,
	                                      qx_PECFiltered => #tx_dummy,
	                                      iqa_TrackingData := #sa_TrackingArray170,
	                                      iqUDT_ConveyorInterface := #sUDT_Interface170,
	                                      iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                                      iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                                      iqa_FifoData := "DB_FIFOLostGIN".Data,
	                                      iqUDT_Statistics := #iqUDT_WorkstationStatistics."170".PEC_EoS);
	                    
	                END_REGION
	                
	                REGION Conveyor
	                    
	                    #sUDT_Handshake170.RTR := #sx_LeftIndexing AND
	                    ((#iqUDT_WorkstationStatus."180".PEC_EoS.PEC AND #sUDT_Interface180.ActualSpeed <> 0) OR #iqUDT_WorkstationStatus."170".PEC_EoS.PEC);
	                    
	                    #sFB_Conveyor170(iUDT_ConveyorConfiguration := #iUDT_Configuration."170".Conveyor,
	                                     idi_PECEoSDistance := #iUDT_Configuration."170".PEC_Eos.Distance,
	                                     idi_PECBoSDistance := 0,
	                                     ii_ExternalSpeed := 0,
	                                     ix_SafetyOk := #ix_SafetyOk,
	                                     ix_24vOk := #ix_24vOk,
	                                     ix_400vOk := #ix_400vOk,
	                                     ix_HardwareOk := #ix_HardwareOk,
	                                     ix_PECEoS := #iqUDT_WorkstationStatus."170".PEC_EoS.PEC,
	                                     ix_PECBoS := TRUE,
	                                     ix_ExternalRequestHold := #sx_LeftExternalRequestHold170,
	                                     qUDT_HMIStatus => #iqUDT_WorkstationStatus."170".Conveyor,
	                                     qUDT_Status => #iqUDT_WorkstationCommonStatus."170",
	                                     iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                     iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."170".Conveyor,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface170,
	                                     iqUDT_HandShakeUp := #sUDT_Handshake160,
	                                     iqUDT_HandShake := #sUDT_Handshake170,
	                                     iqUDT_Statistics := #iqUDT_WorkstationStatistics."170".Conveyor);
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController170(iUDT_AixConfig := #iUDT_Configuration."170".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput170,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 1,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."170".MCO_M01,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput170,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface170,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."170".MCO_M01);
	                END_REGION
	            END_REGION
	            
	            REGION 180
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement180(#sUDT_Interface180);
	                    
	                END_REGION
	                
	                REGION Tracking
	                    
	                    #sFB_Tracking180(iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."180".Conveyor.Common,
	                                     iqa_TrackingData := #sa_TrackingArray180,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface180,
	                                     iqUDT_HandshakeUp := #sUDT_Handshake170,
	                                     iqUDT_Handshake := #sUDT_Handshake180);
	                END_REGION
	                
	                REGION EOS
	                    
	                    #sFB_PECUpdate180(iUDT_PECUpdateConfiguration := #iUDT_Configuration."180".PEC_Eos,
	                                      iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."180".Conveyor.Common,
	                                      ix_PEC := NOT #iUDT_MotorInput170.AllSensorPortInputs.RightSensor,
	                                      ix_TeachingMode := FALSE,
	                                      qUDT_Status => #iqUDT_WorkstationStatus."180".PEC_EoS,
	                                      qi_GINwrite => #ti_dummy,
	                                      qx_PECFiltered => #tx_dummy,
	                                      iqa_TrackingData := #sa_TrackingArray180,
	                                      iqUDT_ConveyorInterface := #sUDT_Interface180,
	                                      iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                                      iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                                      iqa_FifoData := "DB_FIFOLostGIN".Data,
	                                      iqUDT_Statistics := #iqUDT_WorkstationStatistics."180".PEC_EoS);
	                    
	                END_REGION
	                
	                REGION Conveyor
	                    
	                    #sUDT_Handshake180.RTR := #sx_LeftIndexing AND
	                    ((#iqUDT_WorkstationStatus."190".PEC_EoS.PEC AND #sUDT_Interface190.ActualSpeed <> 0) OR #iqUDT_WorkstationStatus."180".PEC_EoS.PEC);
	                    
	                    #sFB_Conveyor180(iUDT_ConveyorConfiguration := #iUDT_Configuration."180".Conveyor,
	                                     idi_PECEoSDistance := #iUDT_Configuration."180".PEC_Eos.Distance,
	                                     idi_PECBoSDistance := 0,
	                                     ii_ExternalSpeed := 0,
	                                     ix_SafetyOk := #ix_SafetyOk,
	                                     ix_24vOk := #ix_24vOk,
	                                     ix_400vOk := #ix_400vOk,
	                                     ix_HardwareOk := #ix_HardwareOk,
	                                     ix_PECEoS := #iqUDT_WorkstationStatus."180".PEC_EoS.PEC,
	                                     ix_PECBoS := TRUE,
	                                     ix_ReverseDirection := FALSE,
	                                     ix_ExternalRequestDieBack := FALSE,
	                                     ix_ExternalRequestHold := #sx_LeftExternalRequestHold180,
	                                     ix_ResetEnergySave := FALSE,
	                                     qUDT_HMIStatus => #iqUDT_WorkstationStatus."180".Conveyor,
	                                     qUDT_Status => #iqUDT_WorkstationCommonStatus."180",
	                                     iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                     iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."180".Conveyor,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface180,
	                                     iqUDT_HandShakeUp := #sUDT_Handshake170,
	                                     iqUDT_HandShake := #sUDT_Handshake180,
	                                     iqUDT_Statistics := #iqUDT_WorkstationStatistics."180".Conveyor);
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController180(iUDT_AixConfig := #iUDT_Configuration."180".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput170,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 2,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."180".MCO_M01,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput170,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface180,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."180".MCO_M01);
	                END_REGION
	                
	            END_REGION
	            
	            REGION 190
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement190(#sUDT_Interface190);
	                    
	                END_REGION
	                
	                REGION Tracking
	                    
	                    #sFB_Tracking190(iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."190".Conveyor.Common,
	                                     iqa_TrackingData := #sa_TrackingArray190,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface190,
	                                     iqUDT_HandshakeUp := #sUDT_Handshake180,
	                                     iqUDT_Handshake := #sUDT_Handshake190);
	                END_REGION
	                
	                REGION EOS
	                    
	                    #sFB_PECUpdate190(iUDT_PECUpdateConfiguration := #iUDT_Configuration."190".PEC_Eos,
	                                      iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."190".Conveyor.Common,
	                                      ix_PEC := NOT #iUDT_MotorInput190.AllSensorPortInputs.LeftSensor,
	                                      ix_TeachingMode := FALSE,
	                                      qUDT_Status => #iqUDT_WorkstationStatus."190".PEC_EoS,
	                                      qi_GINwrite => #ti_dummy,
	                                      qx_PECFiltered => #tx_dummy,
	                                      iqa_TrackingData := #sa_TrackingArray190,
	                                      iqUDT_ConveyorInterface := #sUDT_Interface190,
	                                      iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                                      iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                                      iqa_FifoData := "DB_FIFOLostGIN".Data,
	                                      iqUDT_Statistics := #iqUDT_WorkstationStatistics."190".PEC_EoS);
	                    
	                END_REGION
	                
	                REGION Conveyor
	                    
	                    #sUDT_Handshake190.RTR := (#sx_LeftIndexing AND #iqUDT_WorkstationStatus."190".PEC_EoS.PEC)
	                    OR (#sx_LeftPushOutActiveStation1 AND #iqUDT_WorkstationStatus."210".PEC_EoS.PEC AND #sUDT_Interface211.ActualSpeed <> 0);
	                    
	                    #sFB_Conveyor190(iUDT_ConveyorConfiguration := #iUDT_Configuration."190".Conveyor,
	                                     idi_PECEoSDistance := #iUDT_Configuration."190".PEC_Eos.Distance,
	                                     idi_PECBoSDistance := 0,
	                                     ii_ExternalSpeed := 0,
	                                     ix_SafetyOk := #ix_SafetyOk,
	                                     ix_24vOk := #ix_24vOk,
	                                     ix_400vOk := #ix_400vOk,
	                                     ix_HardwareOk := #ix_HardwareOk,
	                                     ix_PECEoS := #iqUDT_WorkstationStatus."190".PEC_EoS.PEC,
	                                     ix_PECBoS := TRUE,
	                                     ix_ReverseDirection := FALSE,
	                                     ix_ExternalRequestDieBack := FALSE,
	                                     ix_ExternalRequestHold := #sx_LeftExternalRequestHold190,
	                                     ix_ResetEnergySave := FALSE,
	                                     qUDT_HMIStatus => #iqUDT_WorkstationStatus."190".Conveyor,
	                                     qUDT_Status => #iqUDT_WorkstationCommonStatus."190",
	                                     iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                     iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."190".Conveyor,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface190,
	                                     iqUDT_HandShakeUp := #sUDT_Handshake180,
	                                     iqUDT_HandShake := #sUDT_Handshake190,
	                                     iqUDT_Statistics := #iqUDT_WorkstationStatistics."190".Conveyor);
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController190(iUDT_AixConfig := #iUDT_Configuration."190".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput190,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 1,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."190".MCO_M01,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput190,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface190,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."190".MCO_M01);
	                END_REGION
	            END_REGION
	            
	            REGION 210
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement210(#sUDT_Interface210);
	                    
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController210(iUDT_AixConfig := #iUDT_Configuration."210".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput210,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 1,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."210".MCO_M01,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput210,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface210,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."210".MCO_M01);
	                END_REGION
	            END_REGION
	            
	            REGION 211
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement211(#sUDT_Interface211);
	                    
	                END_REGION
	                
	                REGION RAT
	                    
	                    #sFB_RightAngledTransfer211(iUDT_Configuration := #iUDT_Configuration."211".RightAngledTransfer,
	                                                iUDT_LowerConveyorConfiguration := #iUDT_Configuration."210".Conveyor,
	                                                iUDT_UpperConveyorConfiguration := #iUDT_Configuration."211".Conveyor,
	                                                iUDT_PECConfiguration := #iUDT_Configuration."210".PEC_EoS,
	                                                ii_DestinationA := 0,
	                                                ii_DestinationB := 0,
	                                                ii_DestinationC := 1,
	                                                ii_DestinationD := 0,
	                                                ix_HardwareOk := #ix_HardwareOk,
	                                                ix_400vOk := #ix_400vOk,
	                                                ix_24vOk := #ix_24vOk,
	                                                ix_SafetyOk := #ix_SafetyOk,
	                                                ix_AirPressureOk := #ix_AirPressureOk,
	                                                ix_SectionIsDown := #ix_SectionIsDown211,
	                                                ix_SectionIsUp := #ix_SectionIsUp211,
	                                                ix_ConveyorAAuto := false,
	                                                ix_ConveyorBAuto := false,
	                                                ix_ConveyorCAuto := #iqUDT_WorkstationCommonStatus."190".AutoON,
	                                                ix_ConveyorDAuto := false,
	                                                ix_PEC := #iUDT_MotorInput210.AllSensorPortInputs.LeftSensor,
	                                                ix_ExternalReceiveRequestA := FALSE,
	                                                ix_ExternalReceiveRequestB := FALSE,
	                                                ix_ExternalReceiveRequestC := #sx_LeftPushOutActiveStation1,
	                                                ix_ExternalReceiveRequestD := FALSE,
	                                                ix_PECInfeedC := #iqUDT_WorkstationStatus."190".PEC_EoS.PEC,
	                                                qUDT_HMIRATStatus => #iqUDT_WorkstationStatus."211".RightAngledTransfer,
	                                                qUDT_HMIConveyorStatus => #iqUDT_WorkstationStatus."210".Conveyor,
	                                                qUDT_HMIPECStatus => #iqUDT_WorkstationStatus."210".PEC_EoS,
	                                                qUDT_RATStatus => #iqUDT_WorkstationCommonStatus."211",
	                                                qUDT_ConveyorStatus => #iqUDT_WorkstationCommonStatus."210",
	                                                qx_PopupControl => #qx_PopupControl211,
	                                                qx_ExternalSendRequestA => #tx_dummy,
	                                                qx_ExternalSendRequestB => #tx_dummy,
	                                                qx_ExternalSendRequestC => #tx_dummy,
	                                                qx_ExternalSendRequestD => #tx_dummy,
	                                                iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                                iqUDT_RATCommand := #iqUDT_WorkstationCommands."211".RightAngledTransfer,
	                                                iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."210".Conveyor,
	                                                iqUDT_RATStatistics := #iqUDT_WorkstationStatistics."211".RightAngledTransfer,
	                                                iqUDT_ConveyorStatistics := #iqUDT_WorkstationStatistics."210".Conveyor,
	                                                iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."210".PEC_EoS,
	                                                iqUDT_HandShakeConveyorA := #tUDT_DummyConveyorHandshake,
	                                                iqUDT_HandShakeConveyorB := #sUDT_Handshake210,
	                                                iqUDT_HandShakeConveyorC := #sUDT_Handshake190,
	                                                iqUDT_HandShakeConveyorD := #tUDT_DummyConveyorHandshake,
	                                                iqUDT_LowerConveyorInterface := #sUDT_Interface210,
	                                                iqUDT_UpperConveyorInterface := #sUDT_Interface211,
	                                                iqUDT_RATPositioning := #iqUDT_RATPositioning210,
	                                                iqUDT_BladeStopEoSInterface := #tUDT_DummyBladeStop,
	                                                iqUDT_BladeStopBoSInterface := #tUDT_DummyBladeStop);
	                    
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController211(iUDT_AixConfig := #iUDT_Configuration."211".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput210,
	                                                       ii_PositionSetpoint := #iqUDT_RATPositioning210.Upper.EndPosition,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 2,
	                                                       ix_StartPositioning := #iqUDT_RATPositioning210.Upper.Start,
	                                                       ix_ResetPosition := #iqUDT_RATPositioning210.Upper.ResetPosition,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."211".MCO_M01,
	                                                       qx_Positioned => #iqUDT_RATPositioning210.Upper.Done,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput210,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface211,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."211".MCO_M01);
	                END_REGION
	                
	            END_REGION
	            
	            REGION 220
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement220(#sUDT_Interface220);
	                    
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController220(iUDT_AixConfig := #iUDT_Configuration."220".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput220,
	                                                       ii_PositionSetpoint := #iqUDT_RATPositioning220.Lower.EndPosition,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 1,
	                                                       ix_StartPositioning := #iqUDT_RATPositioning220.Lower.Start,
	                                                       ix_ResetPosition := #iqUDT_RATPositioning220.Lower.ResetPosition,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."220".MCO_M01,
	                                                       qx_Positioned => #iqUDT_RATPositioning220.Lower.Done,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput220,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface220,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."220".MCO_M01);
	                END_REGION
	            END_REGION
	            
	            REGION 221
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement221(#sUDT_Interface221);
	                    
	                END_REGION
	                
	                REGION RAT
	                    
	                    #sFB_RightAngledTransfer221(iUDT_Configuration := #iUDT_Configuration."221".RightAngledTransfer,
	                                                iUDT_LowerConveyorConfiguration := #iUDT_Configuration."220".Conveyor,
	                                                iUDT_UpperConveyorConfiguration := #iUDT_Configuration."221".Conveyor,
	                                                iUDT_PECConfiguration := #iUDT_Configuration."220".PEC_EoS,
	                                                ii_DestinationA := 1,
	                                                ii_DestinationB := 0,
	                                                ii_DestinationC := 1,
	                                                ii_DestinationD := 0,
	                                                ix_HardwareOk := #ix_HardwareOk,
	                                                ix_400vOk := #ix_400vOk,
	                                                ix_24vOk := #ix_24vOk,
	                                                ix_SafetyOk := #ix_SafetyOk,
	                                                ix_AirPressureOk := #ix_AirPressureOk,
	                                                ix_SectionIsDown := #ix_SectionIsDown221,
	                                                ix_SectionIsUp := #ix_SectionIsUp221,
	                                                ix_ConveyorAAuto := #iqUDT_WorkstationCommonStatus."210".AutoON,
	                                                ix_ConveyorBAuto := false,
	                                                ix_ConveyorCAuto := #iqUDT_WorkstationCommonStatus."350".AutoON,
	                                                ix_ConveyorDAuto := false,
	                                                ix_PEC := #iUDT_MotorInput220.AllSensorPortInputs.LeftSensor,
	                                                ix_ExternalReceiveRequestA := NOT #iqUDT_WorkstationStatus."210".PEC_EoS.PEC,
	                                                ix_ExternalReceiveRequestB := FALSE,
	                                                ix_ExternalReceiveRequestC := NOT #iqUDT_WorkstationStatus."350".PEC_EoS.PEC,
	                                                ix_ExternalReceiveRequestD := TRUE,
	                                                ix_PECInfeedA := #iqUDT_WorkstationStatus."210".PEC_EoS.PEC,
	                                                ix_PECInfeedC := #iqUDT_WorkstationStatus."350".PEC_EoS.PEC,
	                                                qUDT_HMIRATStatus => #iqUDT_WorkstationStatus."221".RightAngledTransfer,
	                                                qUDT_HMIConveyorStatus => #iqUDT_WorkstationStatus."220".Conveyor,
	                                                qUDT_HMIPECStatus => #iqUDT_WorkstationStatus."220".PEC_EoS,
	                                                qUDT_RATStatus => #iqUDT_WorkstationCommonStatus."221",
	                                                qUDT_ConveyorStatus => #iqUDT_WorkstationCommonStatus."220",
	                                                qx_PopupControl => #qx_PopupControl221,
	                                                qx_ExternalSendRequestA => #tx_dummy,
	                                                qx_ExternalSendRequestB => #tx_dummy,
	                                                qx_ExternalSendRequestC => #tx_dummy,
	                                                qx_ExternalSendRequestD => #tx_dummy,
	                                                iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                                iqUDT_RATCommand := #iqUDT_WorkstationCommands."221".RightAngledTransfer,
	                                                iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."220".Conveyor,
	                                                iqUDT_RATStatistics := #iqUDT_WorkstationStatistics."221".RightAngledTransfer,
	                                                iqUDT_ConveyorStatistics := #iqUDT_WorkstationStatistics."220".Conveyor,
	                                                iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."220".PEC_EoS,
	                                                iqUDT_HandShakeConveyorA := #sUDT_Handshake210,
	                                                iqUDT_HandShakeConveyorB := #sUDT_Handshake220,
	                                                iqUDT_HandShakeConveyorC := #sUDT_Handshake350,
	                                                iqUDT_HandShakeConveyorD := #tUDT_DummyConveyorHandshake,
	                                                iqUDT_LowerConveyorInterface := #sUDT_Interface220,
	                                                iqUDT_UpperConveyorInterface := #sUDT_Interface221,
	                                                iqUDT_RATPositioning := #iqUDT_RATPositioning220,
	                                                iqUDT_BladeStopEoSInterface := #tUDT_DummyBladeStop,
	                                                iqUDT_BladeStopBoSInterface := #tUDT_DummyBladeStop);
	                    
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController221(iUDT_AixConfig := #iUDT_Configuration."221".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput220,
	                                                       ii_PositionSetpoint := #iqUDT_RATPositioning220.Upper.EndPosition,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 2,
	                                                       ix_StartPositioning := #iqUDT_RATPositioning220.Upper.Start,
	                                                       ix_ResetPosition := #iqUDT_RATPositioning220.Upper.ResetPosition,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."221".MCO_M01,
	                                                       qx_Positioned => #iqUDT_RATPositioning220.Upper.Done,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput220,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface221,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."221".MCO_M01);
	                END_REGION
	            END_REGION
	            
	            REGION 230
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement230(#sUDT_Interface230);
	                    
	                END_REGION
	                
	                REGION Conveyor 
	                    
	                    #sFB_Conveyor230(iUDT_ConveyorConfiguration := #iUDT_Configuration."230".Conveyor,
	                                     idi_PECEoSDistance := 0,
	                                     idi_PECBoSDistance := 0,
	                                     ii_ExternalSpeed := 0,
	                                     ix_SafetyOk := #ix_SafetyOk,
	                                     ix_24vOk := #ix_24vOk,
	                                     ix_400vOk := #ix_400vOk,
	                                     ix_HardwareOk := #ix_HardwareOk,
	                                     ix_PECEoS := TRUE,
	                                     ix_PECBoS := TRUE,
	                                     ix_ReverseDirection := FALSE,
	                                     ix_ExternalRequestDieBack := FALSE,
	                                     ix_ExternalRequestHold := FALSE,
	                                     ix_ResetEnergySave := FALSE,
	                                     qUDT_HMIStatus => #iqUDT_WorkstationStatus."230".Conveyor,
	                                     qUDT_Status => #iqUDT_WorkstationCommonStatus."230",
	                                     iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                     iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."230".Conveyor,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface230,
	                                     iqUDT_HandShakeUp := #sUDT_Handshake220,
	                                     iqUDT_HandShake := #iqUDT_HandshakeDownstream230,
	                                     iqUDT_Statistics := #iqUDT_WorkstationStatistics."230".Conveyor);
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController230(iUDT_AixConfig := #iUDT_Configuration."230".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput230,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 1,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."230".MCO_M01,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput230,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface230,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."230".MCO_M01);
	                END_REGION
	            END_REGION
	            
	            REGION 310
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement310(#sUDT_Interface310);
	                    
	                END_REGION
	                
	                REGION EOS
	                    #sFB_PEC310(ix_PEC := NOT #iUDT_MotorInput310.AllSensorPortInputs.LeftSensor,
	                                iUDT_PECConfiguration := #iUDT_Configuration."310".PEC_Eos,
	                                qx_PECFiltered => #tx_dummy,
	                                qUDT_HMIStatus => #iqUDT_WorkstationStatus."310".PEC_EoS,
	                                iqUDT_ConveyorInterface := #sUDT_Interface310,
	                                iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."310".PEC_EoS);
	                    
	                END_REGION
	                
	                REGION Conveyor
	                    
	                    #sFB_Conveyor310(iUDT_ConveyorConfiguration := #iUDT_Configuration."310".Conveyor,
	                                     idi_PECEoSDistance := #iUDT_Configuration."310".PEC_Eos.Distance,
	                                     idi_PECBoSDistance := 0,
	                                     ii_ExternalSpeed := 0,
	                                     ix_SafetyOk := #ix_SafetyOk,
	                                     ix_24vOk := #ix_24vOk,
	                                     ix_400vOk := #ix_400vOk,
	                                     ix_HardwareOk := #ix_HardwareOk,
	                                     ix_PECEoS := #iqUDT_WorkstationStatus."310".PEC_EoS.PEC,
	                                     ix_PECBoS := TRUE,
	                                     ix_ReverseDirection := FALSE,
	                                     ix_ExternalRequestDieBack := FALSE,
	                                     ix_ExternalRequestHold := #sx_LeftExternalRequestHold310,
	                                     ix_ResetEnergySave := FALSE,
	                                     qUDT_HMIStatus => #iqUDT_WorkstationStatus."310".Conveyor,
	                                     qUDT_Status => #iqUDT_WorkstationCommonStatus."310",
	                                     iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                     iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."310".Conveyor,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface310,
	                                     iqUDT_HandShakeUp := #tUDT_DummyConveyorHandshake,
	                                     iqUDT_HandShake := #sUDT_Handshake310,
	                                     iqUDT_Statistics := #iqUDT_WorkstationStatistics."310".Conveyor);
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController310(iUDT_AixConfig := #iUDT_Configuration."310".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput310,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 1,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."310".MCO_M01,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput310,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface310,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."310".MCO_M01);
	                END_REGION
	                
	            END_REGION
	            
	            REGION 320
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement320(#sUDT_Interface320);
	                    
	                END_REGION
	                
	                REGION EOS
	                    #sFB_PEC320(ix_PEC := NOT #iUDT_MotorInput310.AllSensorPortInputs.RightSensor,
	                                iUDT_PECConfiguration := #iUDT_Configuration."320".PEC_Eos,
	                                qx_PECFiltered => #tx_dummy,
	                                qUDT_HMIStatus => #iqUDT_WorkstationStatus."320".PEC_EoS,
	                                iqUDT_ConveyorInterface := #sUDT_Interface320,
	                                iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."320".PEC_EoS);
	                    
	                    
	                END_REGION
	                
	                REGION Conveyor
	                    
	                    #sFB_Conveyor320(iUDT_ConveyorConfiguration := #iUDT_Configuration."320".Conveyor,
	                                     idi_PECEoSDistance := #iUDT_Configuration."320".PEC_Eos.Distance,
	                                     idi_PECBoSDistance := 0,
	                                     ii_ExternalSpeed := 0,
	                                     ix_SafetyOk := #ix_SafetyOk,
	                                     ix_24vOk := #ix_24vOk,
	                                     ix_400vOk := #ix_400vOk,
	                                     ix_HardwareOk := #ix_HardwareOk,
	                                     ix_PECEoS := #iqUDT_WorkstationStatus."320".PEC_EoS.PEC,
	                                     ix_PECBoS := TRUE,
	                                     ix_ReverseDirection := FALSE,
	                                     ix_ExternalRequestDieBack := FALSE,
	                                     ix_ExternalRequestHold := #sx_LeftExternalRequestHold320,
	                                     ix_ResetEnergySave := FALSE,
	                                     qUDT_HMIStatus => #iqUDT_WorkstationStatus."320".Conveyor,
	                                     qUDT_Status => #iqUDT_WorkstationCommonStatus."320",
	                                     iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                     iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."320".Conveyor,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface320,
	                                     iqUDT_HandShakeUp := #sUDT_Handshake310,
	                                     iqUDT_HandShake := #sUDT_Handshake320,
	                                     iqUDT_Statistics := #iqUDT_WorkstationStatistics."320".Conveyor);
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController320(iUDT_AixConfig := #iUDT_Configuration."320".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput310,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 2,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."320".MCO_M01,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput310,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface320,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."320".MCO_M01);
	                END_REGION
	                
	            END_REGION
	            
	            REGION 330
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement330(#sUDT_Interface330);
	                    
	                END_REGION
	                
	                REGION EOS
	                    #sFB_PEC330(ix_PEC := NOT #iUDT_MotorInput330.AllSensorPortInputs.LeftSensor,
	                                iUDT_PECConfiguration := #iUDT_Configuration."330".PEC_Eos,
	                                qx_PECFiltered => #tx_dummy,
	                                qUDT_HMIStatus => #iqUDT_WorkstationStatus."330".PEC_EoS,
	                                iqUDT_ConveyorInterface := #sUDT_Interface330,
	                                iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."330".PEC_EoS);
	                    
	                    
	                END_REGION
	                
	                REGION Conveyor
	                    
	                    #sFB_Conveyor330(iUDT_ConveyorConfiguration := #iUDT_Configuration."330".Conveyor,
	                                     idi_PECEoSDistance := #iUDT_Configuration."330".PEC_Eos.Distance,
	                                     idi_PECBoSDistance := 0,
	                                     ii_ExternalSpeed := 0,
	                                     ix_SafetyOk := #ix_SafetyOk,
	                                     ix_24vOk := #ix_24vOk,
	                                     ix_400vOk := #ix_400vOk,
	                                     ix_HardwareOk := #ix_HardwareOk,
	                                     ix_PECEoS := #iqUDT_WorkstationStatus."330".PEC_EoS.PEC,
	                                     ix_PECBoS := TRUE,
	                                     ix_ReverseDirection := FALSE,
	                                     ix_ExternalRequestDieBack := FALSE,
	                                     ix_ExternalRequestHold := #sx_LeftExternalRequestHold330,
	                                     ix_ResetEnergySave := FALSE,
	                                     qUDT_HMIStatus => #iqUDT_WorkstationStatus."330".Conveyor,
	                                     qUDT_Status => #iqUDT_WorkstationCommonStatus."330",
	                                     iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                     iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."330".Conveyor,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface330,
	                                     iqUDT_HandShakeUp := #sUDT_Handshake320,
	                                     iqUDT_HandShake := #sUDT_Handshake330,
	                                     iqUDT_Statistics := #iqUDT_WorkstationStatistics."330".Conveyor);
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController330(iUDT_AixConfig := #iUDT_Configuration."330".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput330,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 1,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."330".MCO_M01,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput330,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface330,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."330".MCO_M01);
	                END_REGION
	            END_REGION
	            
	            REGION 340
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement340(#sUDT_Interface340);
	                    
	                END_REGION
	                
	                REGION EOS
	                    #sFB_PEC340(ix_PEC := NOT #iUDT_MotorInput330.AllSensorPortInputs.RightSensor,
	                                iUDT_PECConfiguration := #iUDT_Configuration."340".PEC_Eos,
	                                qx_PECFiltered => #tx_dummy,
	                                qUDT_HMIStatus => #iqUDT_WorkstationStatus."340".PEC_EoS,
	                                iqUDT_ConveyorInterface := #sUDT_Interface340,
	                                iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."340".PEC_EoS);
	                    
	                    
	                END_REGION
	                
	                
	                REGION Conveyor
	                    
	                    #sFB_Conveyor340(iUDT_ConveyorConfiguration := #iUDT_Configuration."340".Conveyor,
	                                     idi_PECEoSDistance := #iUDT_Configuration."340".PEC_Eos.Distance,
	                                     idi_PECBoSDistance := 0,
	                                     ii_ExternalSpeed := 0,
	                                     ix_SafetyOk := #ix_SafetyOk,
	                                     ix_24vOk := #ix_24vOk,
	                                     ix_400vOk := #ix_400vOk,
	                                     ix_HardwareOk := #ix_HardwareOk,
	                                     ix_PECEoS := #iqUDT_WorkstationStatus."340".PEC_EoS.PEC,
	                                     ix_PECBoS := TRUE,
	                                     ix_ReverseDirection := FALSE,
	                                     ix_ExternalRequestDieBack := FALSE,
	                                     ix_ExternalRequestHold := #sx_LeftExternalRequestHold340,
	                                     ix_ResetEnergySave := FALSE,
	                                     qUDT_HMIStatus => #iqUDT_WorkstationStatus."340".Conveyor,
	                                     qUDT_Status => #iqUDT_WorkstationCommonStatus."340",
	                                     iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                     iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."340".Conveyor,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface340,
	                                     iqUDT_HandShakeUp := #sUDT_Handshake330,
	                                     iqUDT_HandShake := #sUDT_Handshake340,
	                                     iqUDT_Statistics := #iqUDT_WorkstationStatistics."340".Conveyor);
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController340(iUDT_AixConfig := #iUDT_Configuration."340".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput330,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 2,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."340".MCO_M01,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput330,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface340,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."340".MCO_M01);
	                END_REGION
	            END_REGION
	            
	            REGION 350
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement350(#sUDT_Interface350);
	                    
	                END_REGION
	                
	                REGION EOS
	                    #sFB_PEC350(ix_PEC := NOT #iUDT_MotorInput350.AllSensorPortInputs.LeftSensor,
	                                iUDT_PECConfiguration := #iUDT_Configuration."350".PEC_Eos,
	                                qx_PECFiltered => #tx_dummy,
	                                qUDT_HMIStatus => #iqUDT_WorkstationStatus."350".PEC_EoS,
	                                iqUDT_ConveyorInterface := #sUDT_Interface350,
	                                iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."350".PEC_EoS);
	                    
	                END_REGION
	                
	                REGION Conveyor
	                    
	                    #sUDT_Handshake350.RTR := #sUDT_Handshake350.RTR OR #iqUDT_WorkstationStatus."350".PEC_EoS.PEC;
	                    
	                    #sFB_Conveyor350(iUDT_ConveyorConfiguration := #iUDT_Configuration."350".Conveyor,
	                                     idi_PECEoSDistance := #iUDT_Configuration."350".PEC_Eos.Distance,
	                                     idi_PECBoSDistance := 0,
	                                     ii_ExternalSpeed := 0,
	                                     ix_SafetyOk := #ix_SafetyOk,
	                                     ix_24vOk := #ix_24vOk,
	                                     ix_400vOk := #ix_400vOk,
	                                     ix_HardwareOk := #ix_HardwareOk,
	                                     ix_PECEoS := #iqUDT_WorkstationStatus."350".PEC_EoS.PEC,
	                                     ix_PECBoS := TRUE,
	                                     ix_ReverseDirection := FALSE,
	                                     ix_ExternalRequestDieBack := FALSE,
	                                     ix_ExternalRequestHold := #sx_LeftExternalRequestHold350,
	                                     ix_ResetEnergySave := FALSE,
	                                     qUDT_HMIStatus => #iqUDT_WorkstationStatus."350".Conveyor,
	                                     qUDT_Status => #iqUDT_WorkstationCommonStatus."350",
	                                     iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                     iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."350".Conveyor,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface350,
	                                     iqUDT_HandShakeUp := #sUDT_Handshake340,
	                                     iqUDT_HandShake := #sUDT_Handshake350,
	                                     iqUDT_Statistics := #iqUDT_WorkstationStatistics."350".Conveyor);
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController350(iUDT_AixConfig := #iUDT_Configuration."350".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput350,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 1,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."350".MCO_M01,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput350,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface350,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."350".MCO_M01);
	                END_REGION
	            END_REGION
	        END_REGION
	    END_IF;
	END_REGION
	
	REGION 6 - Right station
	    IF #iUDT_Configuration.GlobalConfig.RightStationExists THEN
	        
	        REGION 6.1 - Indexing 
	            
	            // Start indexing after request if there are empty stations and no pushout is active
	            IF #iqUDT_CommunicationWES.RightWorkstation.StartIndexing AND #si_RightEmptyStations > 0
	                AND NOT (#sx_RightPushOutActiveStation1
	                OR #sx_RightPushOutActiveStation2
	                OR #sx_RightPushOutActiveStation3
	                OR #sx_RightPushOutActiveStation4
	                OR #sx_RightPushOutActiveStation5) THEN
	                
	                #sx_RightIndexing := TRUE;
	            END_IF;
	            
	            IF NOT #sx_RightIndexing THEN                                      // If there is no indexing in progress
	                
	                #si_RightDestinationC541 := 0;                                // Reset RAT destination
	                #sx_RightExternalRequestHold550 := TRUE;                      // Hold station conveyors
	                #sx_RightExternalRequestHold560 := TRUE;
	                #sx_RightExternalRequestHold570 := TRUE;
	                #sx_RightExternalRequestHold580 := TRUE;
	                #sx_RightExternalRequestHold590 := TRUE;
	                
	            ELSE
	                
	                IF #sR_TRIG_PEC540.Q AND #si_RightEmptyStations > 0 THEN       //Count down empty stations after diverting a tote into station
	                    #si_RightEmptyStations -= 1;
	                END_IF;
	                
	                #si_RightDestinationC541 := 1;                               // Set RAT destination
	                #sx_RightExternalRequestHold550 := FALSE;                    // Release hold of station conveyors
	                #sx_RightExternalRequestHold560 := FALSE;
	                #sx_RightExternalRequestHold570 := FALSE;
	                #sx_RightExternalRequestHold580 := FALSE;
	                #sx_RightExternalRequestHold590 := FALSE;
	                
	                IF                                                           //End indexing when all totes are on position
	                    NOT #iqUDT_WorkstationStatus."550".PEC_EoS.PEC
	                    AND NOT #iqUDT_WorkstationStatus."560".PEC_EoS.PEC
	                    AND NOT #iqUDT_WorkstationStatus."570".PEC_EoS.PEC
	                    AND NOT #iqUDT_WorkstationStatus."580".PEC_EoS.PEC
	                    AND NOT #iqUDT_WorkstationStatus."590".PEC_EoS.PEC
	                    AND NOT (#sUDT_Interface550.ActualSpeed > 0) THEN
	                    
	                    #sx_RightIndexing := FALSE;
	                    
	                END_IF;
	            END_IF;
	            
	        END_REGION
	        
	        REGION 6.2 - Push Out
	            
	            REGION 6.2.0 - Pushout conveyors hold
	                IF #sFB_TimerOnOffDelay_Hold710.qx_DelayedSignal THEN
	                    #sx_RightExternalRequestHold710 := TRUE;
	                END_IF;
	                
	                IF #sFB_TimerOnOffDelay_Hold720.qx_DelayedSignal THEN
	                    #sx_RightExternalRequestHold720 := TRUE;
	                END_IF;
	                
	                IF #sFB_TimerOnOffDelay_Hold730.qx_DelayedSignal THEN
	                    #sx_RightExternalRequestHold730 := TRUE;
	                END_IF;
	                
	                IF #sFB_TimerOnOffDelay_Hold740.qx_DelayedSignal THEN
	                    #sx_RightExternalRequestHold740 := TRUE;
	                END_IF;
	                
	                IF #sFB_TimerOnOffDelay_Hold750.qx_DelayedSignal THEN
	                    #sx_RightExternalRequestHold750 := TRUE;
	                END_IF;
	            END_REGION
	            
	            REGION 6.2.1 - Push Out Station 1
	                
	                // Start automatic pushout after request if there is no indexing procedure and a tote is present on first station
	                IF #iqUDT_CommunicationWES.RightWorkstation.Station1.ReadyForPush AND NOT #sx_RightIndexing
	                    AND NOT #iqUDT_WorkstationStatus."590".PEC_EoS.PEC THEN
	                    
	                    #sx_RightPushOutActiveStation1 := TRUE;
	                END_IF;
	                
	                IF #sx_RightPushOutActiveStation1 THEN                         //release hold
	                    #sx_RightExternalRequestHold590 := FALSE;
	                    
	                    IF #sFB_RightAngledTransfer611.qx_ExternalSendRequestB THEN    //after tote is already on RAT, hold the conveyor and end pushout procedure
	                        #sx_RightExternalRequestHold590 := TRUE;
	                        #sx_RightPushOutActiveStation1 := FALSE;
	                    END_IF;
	                END_IF;
	                
	            END_REGION
	            
	            REGION 6.2.2 - Push Out station 2
	                
	                IF #iqUDT_CommunicationWES.RightWorkstation.Station2.ReadyForPush THEN        //set pushout to active after request
	                    #sx_RightPushOutActiveStation2 := TRUE;
	                END_IF;
	                
	                IF #sx_RightPushOutActiveStation2                               // After station is empty and tote has been detected on pushout conveyor release holds
	                    AND #iqUDT_WorkstationStatus."580".PEC_EoS.PEC
	                    AND #sFB_TimerOnOffDelay_Detect740.qx_DelayedSignal THEN
	                    
	                    #sx_RightExternalRequestHold740 := FALSE;
	                    #sx_RightExternalRequestHold750 := FALSE;
	                    
	                    FILL_BLK(IN := 0,                                             //clear tracking
	                             COUNT := REAL_TO_ULINT(DINT_TO_REAL(#iUDT_Configuration."580".Conveyor.Common.Length) * #cr_ClearTrackingModifier),
	                             OUT => #sa_TrackingArray580[0]);
	                    
	                    #sx_RightPushOutActiveStation2 := FALSE;                       //end pushout procedure
	                    
	                END_IF;
	                
	                
	            END_REGION
	            
	            REGION 6.2.3 - Push Out station 3
	                
	                IF #iqUDT_CommunicationWES.RightWorkstation.Station3.ReadyForPush THEN          //set pushout to active after request
	                    #sx_RightPushOutActiveStation3 := TRUE;
	                END_IF;
	                
	                IF #sx_RightPushOutActiveStation3
	                    AND #iqUDT_WorkstationStatus."570".PEC_EoS.PEC
	                    AND #sFB_TimerOnOffDelay_Detect730.qx_DelayedSignal THEN                // After station is empty and tote has been detected on pushout conveyor release holds
	                    
	                    #sx_RightExternalRequestHold730 := FALSE;
	                    #sx_RightExternalRequestHold740 := FALSE;
	                    #sx_RightExternalRequestHold750 := FALSE;
	                    
	                    FILL_BLK(IN := 0,                                                         //clear tracking
	                             COUNT := REAL_TO_ULINT(DINT_TO_REAL(#iUDT_Configuration."570".Conveyor.Common.Length) * #cr_ClearTrackingModifier),
	                             OUT => #sa_TrackingArray570[0]);
	                    
	                    #sx_RightPushOutActiveStation3 := FALSE;                              //end pushout procedure
	                    
	                END_IF;
	            END_REGION
	            
	            REGION 6.2.4 - Push Out station 4
	                
	                IF #iqUDT_CommunicationWES.RightWorkstation.Station4.ReadyForPush THEN              //set pushout to active after request
	                    #sx_RightPushOutActiveStation4 := TRUE;
	                END_IF;
	                
	                IF #sx_RightPushOutActiveStation4
	                    AND #iqUDT_WorkstationStatus."560".PEC_EoS.PEC
	                    AND #sFB_TimerOnOffDelay_Detect720.qx_DelayedSignal THEN                // After station is empty and tote has been detected on pushout conveyor release holds
	                    
	                    #sx_RightExternalRequestHold720 := FALSE;
	                    #sx_RightExternalRequestHold730 := FALSE;
	                    #sx_RightExternalRequestHold740 := FALSE;
	                    #sx_RightExternalRequestHold750 := FALSE;
	                    
	                    FILL_BLK(IN := 0,                                                      //clear tracking
	                             COUNT := REAL_TO_ULINT(DINT_TO_REAL(#iUDT_Configuration."560".Conveyor.Common.Length) * #cr_ClearTrackingModifier),
	                             OUT => #sa_TrackingArray560[0]);
	                    
	                    #sx_RightPushOutActiveStation4 := FALSE;                          //end pushout procedure
	                    
	                END_IF;
	                
	            END_REGION
	            
	            REGION 6.2.5 - Push Out station 5
	                
	                IF #iqUDT_CommunicationWES.RightWorkstation.Station5.ReadyForPush THEN          //set pushout to active after request
	                    #sx_RightPushOutActiveStation5 := TRUE;
	                END_IF;
	                
	                IF #sx_RightPushOutActiveStation5
	                    AND #iqUDT_WorkstationStatus."550".PEC_EoS.PEC
	                    AND #sFB_TimerOnOffDelay_Detect710.qx_DelayedSignal THEN                // After station is empty and tote has been detected on pushout conveyor release holds
	                    
	                    #sx_RightExternalRequestHold710 := FALSE;
	                    #sx_RightExternalRequestHold720 := FALSE;
	                    #sx_RightExternalRequestHold730 := FALSE;
	                    #sx_RightExternalRequestHold740 := FALSE;
	                    #sx_RightExternalRequestHold750 := FALSE;
	                    
	                    FILL_BLK(IN := 0,                                            //clear tracking
	                             COUNT := REAL_TO_ULINT(DINT_TO_REAL(#iUDT_Configuration."550".Conveyor.Common.Length) * #cr_ClearTrackingModifier),
	                             OUT => #sa_TrackingArray550[0]);
	                    
	                    #sx_RightPushOutActiveStation5 := FALSE;                      //end pushout procedure
	                END_IF;
	                
	            END_REGION
	            
	        END_REGION
	        
	        REGION 6.3 WES Communication
	            REGION 6.3.1 Lost track error
	                
	                IF NOT #sx_RightIndexing
	                    AND NOT #sx_RightPushOutActiveStation1
	                    AND #sa_TrackingArray590[30] >= 1000
	                    AND #iqUDT_WorkstationStatus."590".PEC_EoS.PEC THEN
	                    #iqUDT_CommunicationWES.RightWorkstation.Station1.Error := TRUE;
	                END_IF;
	                
	                IF NOT #sx_RightIndexing
	                    AND NOT #sx_RightPushOutActiveStation2
	                    AND #sa_TrackingArray580[30] >= 1000
	                    AND #iqUDT_WorkstationStatus."580".PEC_EoS.PEC THEN
	                    #iqUDT_CommunicationWES.RightWorkstation.Station2.Error := TRUE;
	                END_IF;
	                
	                IF NOT #sx_RightIndexing
	                    AND NOT #sx_RightPushOutActiveStation3
	                    AND #sa_TrackingArray570[30] >= 1000
	                    AND #iqUDT_WorkstationStatus."570".PEC_EoS.PEC THEN
	                    #iqUDT_CommunicationWES.RightWorkstation.Station3.Error := TRUE;
	                END_IF;
	                
	                IF NOT #sx_RightIndexing
	                    AND NOT #sx_RightPushOutActiveStation4
	                    AND #sa_TrackingArray560[30] >= 1000
	                    AND #iqUDT_WorkstationStatus."560".PEC_EoS.PEC THEN
	                    #iqUDT_CommunicationWES.RightWorkstation.Station4.Error := TRUE;
	                END_IF;
	                
	                IF NOT #sx_RightIndexing
	                    AND NOT #sx_RightPushOutActiveStation5
	                    AND #sa_TrackingArray550[30] >= 1000
	                    AND #iqUDT_WorkstationStatus."550".PEC_EoS.PEC THEN
	                    #iqUDT_CommunicationWES.RightWorkstation.Station5.Error := TRUE;
	                END_IF;
	                
	            END_REGION
	            
	            REGION 6.3.2 Reset lost errors
	                
	                IF #iqUDT_EquipmentControl.Command.Reset                   // Reset command received 
	                THEN
	                    #iqUDT_CommunicationWES.RightWorkstation.Station1.Error := FALSE;
	                    #iqUDT_CommunicationWES.RightWorkstation.Station2.Error := FALSE;
	                    #iqUDT_CommunicationWES.RightWorkstation.Station3.Error := FALSE;
	                    #iqUDT_CommunicationWES.RightWorkstation.Station4.Error := FALSE;
	                    #iqUDT_CommunicationWES.RightWorkstation.Station5.Error := FALSE;
	                END_IF;
	                
	            END_REGION
	            
	            REGION 6.3.3 GIN at station
	                IF NOT #sx_RightIndexing THEN
	                    IF NOT #sx_RightPushOutActiveStation1 THEN
	                        #iqUDT_CommunicationWES.RightWorkstation.Station1.Gin := #sa_TrackingArray590[23];
	                    END_IF;
	                    #iqUDT_CommunicationWES.RightWorkstation.Station2.Gin := #sa_TrackingArray580[23];
	                    #iqUDT_CommunicationWES.RightWorkstation.Station3.Gin := #sa_TrackingArray570[23];
	                    #iqUDT_CommunicationWES.RightWorkstation.Station4.Gin := #sa_TrackingArray560[23];
	                    #iqUDT_CommunicationWES.RightWorkstation.Station5.Gin := #sa_TrackingArray550[23];
	                END_IF;
	            END_REGION
	            
	            REGION 6.3.4 Barcode at station
	                //Write barcode to WES
	                
	                IF (#iqUDT_CommunicationWES.RightWorkstation.Station1.Gin > 0) AND (#iqUDT_CommunicationWES.RightWorkstation.Station1.Gin < 10000) THEN
	                    #iqUDT_CommunicationWES.RightWorkstation.Station1.Barcode := "DB_GIN".GIN[#iqUDT_CommunicationWES.RightWorkstation.Station1.Gin].WES.Barcode;
	                ELSE
	                    #iqUDT_CommunicationWES.RightWorkstation.Station1.Barcode := '          ';
	                END_IF;
	                
	                IF (#iqUDT_CommunicationWES.RightWorkstation.Station2.Gin > 0) AND (#iqUDT_CommunicationWES.RightWorkstation.Station2.Gin < 10000) THEN
	                    #iqUDT_CommunicationWES.RightWorkstation.Station2.Barcode := "DB_GIN".GIN[#iqUDT_CommunicationWES.RightWorkstation.Station2.Gin].WES.Barcode;
	                ELSE
	                    #iqUDT_CommunicationWES.RightWorkstation.Station2.Barcode := '          ';
	                END_IF;
	                
	                IF (#iqUDT_CommunicationWES.RightWorkstation.Station3.Gin > 0) AND (#iqUDT_CommunicationWES.RightWorkstation.Station3.Gin < 10000) THEN
	                    #iqUDT_CommunicationWES.RightWorkstation.Station3.Barcode := "DB_GIN".GIN[#iqUDT_CommunicationWES.RightWorkstation.Station3.Gin].WES.Barcode;
	                ELSE
	                    #iqUDT_CommunicationWES.RightWorkstation.Station3.Barcode := '          ';
	                END_IF;
	                
	                IF (#iqUDT_CommunicationWES.RightWorkstation.Station4.Gin > 0) AND (#iqUDT_CommunicationWES.RightWorkstation.Station4.Gin < 10000) THEN
	                    #iqUDT_CommunicationWES.RightWorkstation.Station4.Barcode := "DB_GIN".GIN[#iqUDT_CommunicationWES.RightWorkstation.Station4.Gin].WES.Barcode;
	                ELSE
	                    #iqUDT_CommunicationWES.RightWorkstation.Station4.Barcode := '          ';
	                END_IF;
	                
	                IF (#iqUDT_CommunicationWES.RightWorkstation.Station5.Gin > 0) AND (#iqUDT_CommunicationWES.RightWorkstation.Station5.Gin < 10000) THEN
	                    #iqUDT_CommunicationWES.RightWorkstation.Station5.Barcode := "DB_GIN".GIN[#iqUDT_CommunicationWES.RightWorkstation.Station5.Gin].WES.Barcode;
	                ELSE
	                    #iqUDT_CommunicationWES.RightWorkstation.Station5.Barcode := '          ';
	                END_IF;
	                
	            END_REGION
	            
	            
	        END_REGION
	        
	        REGION 6.4 - Function block calls
	            REGION 510
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement510(#sUDT_Interface510);
	                    
	                END_REGION
	                
	                REGION Conveyor
	                    
	                    #sFB_Conveyor510(iUDT_ConveyorConfiguration := #iUDT_Configuration."510".Conveyor,
	                                     idi_PECEoSDistance := 0,
	                                     idi_PECBoSDistance := 0,
	                                     ii_ExternalSpeed := 0,
	                                     ix_SafetyOk := #ix_SafetyOk,
	                                     ix_24vOk := #ix_24vOk,
	                                     ix_400vOk := #ix_400vOk,
	                                     ix_HardwareOk := #ix_HardwareOk,
	                                     ix_PECEoS := TRUE,
	                                     ix_PECBoS := TRUE,
	                                     ix_ReverseDirection := FALSE,
	                                     ix_ExternalRequestDieBack := FALSE,
	                                     ix_ExternalRequestHold := FALSE,
	                                     ix_ResetEnergySave := FALSE,
	                                     qUDT_HMIStatus => #iqUDT_WorkstationStatus."510".Conveyor,
	                                     qUDT_Status => #iqUDT_WorkstationCommonStatus."510",
	                                     iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                     iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."510".Conveyor,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface510,
	                                     iqUDT_HandShakeUp := #sUDT_HandshakeUp020,
	                                     iqUDT_HandShake := #sUDT_Handshake510,
	                                     iqUDT_Statistics := #iqUDT_WorkstationStatistics."510".Conveyor);
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController510(iUDT_AixConfig := #iUDT_Configuration."510".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput510,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 1,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."510".MCO_M01,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput510,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface510,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."510".MCO_M01);
	                END_REGION
	            END_REGION
	            
	            REGION 520
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement520(#sUDT_Interface520);
	                    
	                END_REGION
	                
	                REGION Tracking
	                    #sFB_Tracking520(iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."520".Conveyor.Common,
	                                     iqa_TrackingData := #sa_TrackingArray520,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface520,
	                                     iqUDT_HandshakeUp := #sUDT_Handshake510,
	                                     iqUDT_Handshake := #sUDT_Handshake520);
	                    
	                END_REGION
	                
	                
	                REGION EOS
	                    
	                    #sFB_PECUpdate520(iUDT_PECUpdateConfiguration := #iUDT_Configuration."520".PEC_Eos,
	                                      iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."520".Conveyor.Common,
	                                      ix_PEC := #iUDT_MotorInput520.AllSensorPortInputs.LeftSensor,
	                                      ix_TeachingMode := FALSE,
	                                      qUDT_Status => #iqUDT_WorkstationStatus."520".PEC_EoS,
	                                      qi_GINwrite => #ti_dummy,
	                                      qx_PECFiltered => #tx_dummy,
	                                      iqUDT_ConveyorInterface := #sUDT_Interface520,
	                                      iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                                      iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                                      iqUDT_Statistics := #iqUDT_WorkstationStatistics."520".PEC_EoS,
	                                      iqa_TrackingData := #sa_TrackingArray520,
	                                      iqa_FifoData := "DB_FIFOLostGIN".Data);
	                    
	                END_REGION
	                
	                REGION Conveyor
	                    
	                    #sFB_Conveyor520(iUDT_ConveyorConfiguration := #iUDT_Configuration."520".Conveyor,
	                                     idi_PECEoSDistance := #iUDT_Configuration."520".PEC_Eos.Distance,
	                                     idi_PECBoSDistance := 0,
	                                     ii_ExternalSpeed := 0,
	                                     ix_SafetyOk := #ix_SafetyOk,
	                                     ix_24vOk := #ix_24vOk,
	                                     ix_400vOk := #ix_400vOk,
	                                     ix_HardwareOk := #ix_HardwareOk,
	                                     ix_PECEoS := #iqUDT_WorkstationStatus."520".PEC_EoS.PEC,
	                                     ix_PECBoS := TRUE,
	                                     ix_ReverseDirection := FALSE,
	                                     ix_ExternalRequestDieBack := FALSE,
	                                     ix_ExternalRequestHold := FALSE,
	                                     ix_ResetEnergySave := FALSE,
	                                     qUDT_HMIStatus => #iqUDT_WorkstationStatus."520".Conveyor,
	                                     qUDT_Status => #iqUDT_WorkstationCommonStatus."520",
	                                     iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                     iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."520".Conveyor,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface520,
	                                     iqUDT_HandShakeUp := #sUDT_Handshake510,
	                                     iqUDT_HandShake := #sUDT_Handshake520,
	                                     iqUDT_Statistics := #iqUDT_WorkstationStatistics."520".Conveyor);
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController520(iUDT_AixConfig := #iUDT_Configuration."520".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput520,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 1,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."520".MCO_M01,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput520,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface520,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."520".MCO_M01);
	                END_REGION
	            END_REGION
	            
	            REGION 530
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement530(#sUDT_Interface530);
	                    
	                END_REGION
	                
	                REGION Tracking
	                    
	                    #sFB_Tracking530(iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."530".Conveyor.Common,
	                                     iqa_TrackingData := #sa_TrackingArray530,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface530,
	                                     iqUDT_HandshakeUp := #sUDT_Handshake520,
	                                     iqUDT_Handshake := #sUDT_Handshake530);
	                    
	                END_REGION
	                
	                REGION EOS
	                    
	                    #sFB_PECUpdate530(iUDT_PECUpdateConfiguration := #iUDT_Configuration."530".PEC_Eos,
	                                      iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."530".Conveyor.Common,
	                                      ix_PEC := #iUDT_MotorInput520.AllSensorPortInputs.RightSensor,
	                                      ix_TeachingMode := FALSE,
	                                      qUDT_Status => #iqUDT_WorkstationStatus."530".PEC_EoS,
	                                      qi_GINwrite => #ti_dummy,
	                                      qx_PECFiltered => #tx_dummy,
	                                      iqUDT_ConveyorInterface := #sUDT_Interface530,
	                                      iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                                      iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                                      iqUDT_Statistics := #iqUDT_WorkstationStatistics."530".PEC_EoS,
	                                      iqa_TrackingData := #sa_TrackingArray530,
	                                      iqa_FifoData := "DB_FIFOLostGIN".Data);
	                    
	                END_REGION
	                
	                REGION Scanner
	                    
	                    // #sFB_CognexCamera260_530(iUDT_CognexDM260_IN       := #iUDT_ScannerInput530,
	                    //                          iUDT_EquipmentControl:=#iqUDT_EquipmentControl,
	                    //                          ix_Trigger                := #sa_TrackingArray_130[38]>1000,
	                    //                          qUDT_CognexDM260_OUT      => #qUDT_ScannerOutput530,
	                    //                          qs_Barcode                => #ts_Barcode530,
	                    //                          qw_RetVal                 => #tw_dummy);00
	                    //  
	                    
	                    // IF #sa_TrackingArray_530[38] > 0 THEN
	                    //     #ti_GIN := #sa_TrackingArray_530[38];
	                    //     "DB_GIN".GIN[#ti_GIN].WES.Barcode := #ts_Barcode530;
	                    // END_IF;
	                    // 
	                    
	                    
	                    #sFB_DataLogicBlade200_530(iUDT_DataLogic := #iUDT_ScannerInput530,
	                                               ix_trigger := #sa_TrackingArray530[27] > 0,
	                                               qUDT_DataLogic => #qudt_ScannerOutput530,
	                                               qs_Barcode => #ts_Barcode530,
	                                               qw_RetVal => #tw_dummy,
	                                               iqUDT_EquipmentControl := #iqUDT_EquipmentControl);
	                    
	                    IF #sa_TrackingArray530[47] > 0 THEN
	                        #ti_GIN530 := #sa_TrackingArray530[47];
	                        "DB_GIN".GIN[#ti_GIN530].WES.Barcode := #ts_Barcode530;
	                    END_IF;
	                    
	                END_REGION
	                
	                REGION Conveyor
	                    
	                    #sUDT_Handshake530.RTR := #iqUDT_WorkstationStatus."530".PEC_EoS.PEC OR
	                    (#iqUDT_WorkstationStatus."540".PEC_EoS.PEC AND #sUDT_Interface540.ActualSpeed <> 0);
	                    
	                    #sFB_Conveyor530(iUDT_ConveyorConfiguration := #iUDT_Configuration."530".Conveyor,
	                                     idi_PECEoSDistance := #iUDT_Configuration."530".PEC_Eos.Distance,
	                                     idi_PECBoSDistance := 0,
	                                     ii_ExternalSpeed := 0,
	                                     ix_SafetyOk := #ix_SafetyOk,
	                                     ix_24vOk := #ix_24vOk,
	                                     ix_400vOk := #ix_400vOk,
	                                     ix_HardwareOk := #ix_HardwareOk,
	                                     ix_PECEoS := #iqUDT_WorkstationStatus."530".PEC_EoS.PEC,
	                                     ix_PECBoS := TRUE,
	                                     ix_ReverseDirection := FALSE,
	                                     ix_ExternalRequestDieBack := FALSE,
	                                     ix_ExternalRequestHold := FALSE,
	                                     ix_ResetEnergySave := FALSE,
	                                     qUDT_HMIStatus => #iqUDT_WorkstationStatus."530".Conveyor,
	                                     qUDT_Status => #iqUDT_WorkstationCommonStatus."530",
	                                     iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                     iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."530".Conveyor,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface530,
	                                     iqUDT_HandShakeUp := #sUDT_Handshake520,
	                                     iqUDT_HandShake := #sUDT_Handshake530,
	                                     iqUDT_Statistics := #iqUDT_WorkstationStatistics."530".Conveyor);
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController530(iUDT_AixConfig := #iUDT_Configuration."530".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput520,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 2,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."530".MCO_M01,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput520,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface530,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."530".MCO_M01);
	                END_REGION
	                
	            END_REGION
	            
	            REGION 540
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement540(#sUDT_Interface540);
	                    
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController540(iUDT_AixConfig := #iUDT_Configuration."540".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput540,
	                                                       ii_PositionSetpoint := #iqUDT_RATPositioning540.Lower.EndPosition,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 1,
	                                                       ix_StartPositioning := #iqUDT_RATPositioning540.Lower.Start,
	                                                       ix_ResetPosition := #iqUDT_RATPositioning540.Lower.ResetPosition,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."540".MCO_M01,
	                                                       qx_Positioned => #iqUDT_RATPositioning540.Lower.Done,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput540,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface540,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."540".MCO_M01);
	                END_REGION
	            END_REGION
	            
	            REGION 541
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement541(#sUDT_Interface541);
	                    
	                END_REGION
	                
	                REGION RAT
	                    #sUDT_Handshake541.RTR := #sx_RightIndexing AND
	                    (#iqUDT_WorkstationStatus."550".PEC_EoS.PEC AND #sUDT_Interface550.ActualSpeed <> 0);
	                    
	                    #sFB_RightAngledTransfer541(iUDT_Configuration := #iUDT_Configuration."541".RightAngledTransfer,
	                                                iUDT_LowerConveyorConfiguration := #iUDT_Configuration."540".Conveyor,
	                                                iUDT_UpperConveyorConfiguration := #iUDT_Configuration."541".Conveyor,
	                                                iUDT_PECConfiguration := #iUDT_Configuration."540".PEC_EoS,
	                                                ii_DestinationA := #si_RightDestinationC541,
	                                                ii_DestinationB := 0,
	                                                ii_DestinationC := 0,
	                                                ii_DestinationD := 0,
	                                                ix_HardwareOk := #ix_HardwareOk,
	                                                ix_400vOk := #ix_400vOk,
	                                                ix_24vOk := #ix_24vOk,
	                                                ix_SafetyOk := #ix_SafetyOk,
	                                                ix_AirPressureOk := #ix_AirPressureOk,
	                                                ix_SectionIsDown := #ix_SectionIsDown541,
	                                                ix_SectionIsUp := #ix_SectionIsUp541,
	                                                ix_ConveyorAAuto := #iqUDT_WorkstationCommonStatus."530".AutoON,
	                                                ix_ConveyorBAuto := false,
	                                                ix_ConveyorCAuto := false,
	                                                ix_ConveyorDAuto := false,
	                                                ix_PEC := #iUDT_MotorInput540.AllSensorPortInputs.LeftSensor,
	                                                ix_ExternalReceiveRequestA := NOT #iqUDT_WorkstationStatus."530".PEC_EoS.PEC,
	                                                ix_ExternalReceiveRequestB := FALSE,
	                                                ix_ExternalReceiveRequestC := FALSE,
	                                                ix_ExternalReceiveRequestD := FALSE,
	                                                ix_PECInfeedA := #iqUDT_WorkstationStatus."530".PEC_EoS.PEC,
	                                                qUDT_HMIRATStatus => #iqUDT_WorkstationStatus."541".RightAngledTransfer,
	                                                qUDT_HMIConveyorStatus => #iqUDT_WorkstationStatus."540".Conveyor,
	                                                qUDT_HMIPECStatus => #iqUDT_WorkstationStatus."540".PEC_EoS,
	                                                qUDT_RATStatus => #iqUDT_WorkstationCommonStatus."541",
	                                                qUDT_ConveyorStatus => #iqUDT_WorkstationCommonStatus."540",
	                                                qx_PopupControl => #qx_PopupControl541,
	                                                qx_ExternalSendRequestA => #tx_dummy,
	                                                qx_ExternalSendRequestB => #tx_dummy,
	                                                qx_ExternalSendRequestC => #tx_dummy,
	                                                qx_ExternalSendRequestD => #tx_dummy,
	                                                iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                                iqUDT_RATCommand := #iqUDT_WorkstationCommands."541".RightAngledTransfer,
	                                                iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."540".Conveyor,
	                                                iqUDT_RATStatistics := #iqUDT_WorkstationStatistics."541".RightAngledTransfer,
	                                                iqUDT_ConveyorStatistics := #iqUDT_WorkstationStatistics."540".Conveyor,
	                                                iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."540".PEC_EoS,
	                                                iqUDT_HandShakeConveyorA := #sUDT_Handshake530,
	                                                iqUDT_HandShakeConveyorB := #sUDT_Handshake540,
	                                                iqUDT_HandShakeConveyorC := #tUDT_DummyConveyorHandshake,
	                                                iqUDT_HandShakeConveyorD := #sUDT_Handshake541,
	                                                iqUDT_LowerConveyorInterface := #sUDT_Interface540,
	                                                iqUDT_UpperConveyorInterface := #sUDT_Interface541,
	                                                iqUDT_RATPositioning := #iqUDT_RATPositioning540,
	                                                iqUDT_BladeStopEoSInterface := #tUDT_DummyBladeStop,
	                                                iqUDT_BladeStopBoSInterface := #tUDT_DummyBladeStop);
	                    
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController541(iUDT_AixConfig := #iUDT_Configuration."541".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput540,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 2,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."541".MCO_M01,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput540,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface541,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."541".MCO_M01);
	                END_REGION
	                
	            END_REGION
	            
	            REGION 550
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement550(#sUDT_Interface550);
	                    
	                END_REGION
	                
	                REGION Tracking
	                    
	                    #sFB_Tracking550(iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."550".Conveyor.Common,
	                                     iqa_TrackingData := #sa_TrackingArray550,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface550,
	                                     iqUDT_HandshakeUp := #sUDT_Handshake541,
	                                     iqUDT_Handshake := #sUDT_Handshake550);
	                END_REGION
	                
	                REGION EOS
	                    
	                    #sFB_PECUpdate550(iUDT_PECUpdateConfiguration := #iUDT_Configuration."550".PEC_Eos,
	                                      iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."550".Conveyor.Common,
	                                      ix_PEC := NOT #iUDT_MotorInput550.AllSensorPortInputs.LeftSensor,
	                                      ix_TeachingMode := FALSE,
	                                      qUDT_Status => #iqUDT_WorkstationStatus."550".PEC_EoS,
	                                      qi_GINwrite => #ti_dummy,
	                                      qx_PECFiltered => #tx_dummy,
	                                      iqa_TrackingData := #sa_TrackingArray550,
	                                      iqUDT_ConveyorInterface := #sUDT_Interface550,
	                                      iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                                      iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                                      iqa_FifoData := "DB_FIFOLostGIN".Data,
	                                      iqUDT_Statistics := #iqUDT_WorkstationStatistics."550".PEC_EoS);
	                    
	                END_REGION
	                
	                REGION Conveyor
	                    
	                    #sUDT_Handshake550.RTR := #sx_RightIndexing AND
	                    ((#iqUDT_WorkstationStatus."560".PEC_EoS.PEC AND #sUDT_Interface560.ActualSpeed <> 0) OR #iqUDT_WorkstationStatus."550".PEC_EoS.PEC);
	                    
	                    #sFB_Conveyor550(iUDT_ConveyorConfiguration := #iUDT_Configuration."550".Conveyor,
	                                     idi_PECEoSDistance := #iUDT_Configuration."550".PEC_Eos.Distance,
	                                     idi_PECBoSDistance := 0,
	                                     ii_ExternalSpeed := 0,
	                                     ix_SafetyOk := #ix_SafetyOk,
	                                     ix_24vOk := #ix_24vOk,
	                                     ix_400vOk := #ix_400vOk,
	                                     ix_HardwareOk := #ix_HardwareOk,
	                                     ix_PECEoS := #iqUDT_WorkstationStatus."550".PEC_EoS.PEC,
	                                     ix_PECBoS := TRUE,
	                                     ix_ReverseDirection := FALSE,
	                                     ix_ExternalRequestDieBack := FALSE,
	                                     ix_ExternalRequestHold := #sx_RightExternalRequestHold550,
	                                     ix_ResetEnergySave := FALSE,
	                                     qUDT_HMIStatus => #iqUDT_WorkstationStatus."550".Conveyor,
	                                     qUDT_Status => #iqUDT_WorkstationCommonStatus."550",
	                                     iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                     iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."550".Conveyor,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface550,
	                                     iqUDT_HandShakeUp := #sUDT_Handshake541,
	                                     iqUDT_HandShake := #sUDT_Handshake550,
	                                     iqUDT_Statistics := #iqUDT_WorkstationStatistics."550".Conveyor);
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController550(iUDT_AixConfig := #iUDT_Configuration."550".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput550,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 1,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."550".MCO_M01,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput550,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface550,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."550".MCO_M01);
	                END_REGION
	            END_REGION
	            
	            REGION 560
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement560(#sUDT_Interface560);
	                    
	                END_REGION
	                
	                REGION Tracking
	                    
	                    #sFB_Tracking560(iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."560".Conveyor.Common,
	                                     iqa_TrackingData := #sa_TrackingArray560,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface560,
	                                     iqUDT_HandshakeUp := #sUDT_Handshake550,
	                                     iqUDT_Handshake := #sUDT_Handshake560);
	                END_REGION
	                
	                REGION EOS
	                    
	                    #sFB_PECUpdate560(iUDT_PECUpdateConfiguration := #iUDT_Configuration."560".PEC_Eos,
	                                      iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."560".Conveyor.Common,
	                                      ix_PEC := NOT #iUDT_MotorInput550.AllSensorPortInputs.RightSensor,
	                                      ix_TeachingMode := FALSE,
	                                      qUDT_Status => #iqUDT_WorkstationStatus."560".PEC_EoS,
	                                      qi_GINwrite => #ti_dummy,
	                                      qx_PECFiltered => #tx_dummy,
	                                      iqa_TrackingData := #sa_TrackingArray560,
	                                      iqUDT_ConveyorInterface := #sUDT_Interface560,
	                                      iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                                      iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                                      iqa_FifoData := "DB_FIFOLostGIN".Data,
	                                      iqUDT_Statistics := #iqUDT_WorkstationStatistics."560".PEC_EoS);
	                    
	                END_REGION
	                
	                REGION Conveyor
	                    
	                    #sUDT_Handshake560.RTR := #sx_RightIndexing AND
	                    ((#iqUDT_WorkstationStatus."570".PEC_EoS.PEC AND #sUDT_Interface570.ActualSpeed <> 0) OR #iqUDT_WorkstationStatus."560".PEC_EoS.PEC);
	                    
	                    #sFB_Conveyor560(iUDT_ConveyorConfiguration := #iUDT_Configuration."560".Conveyor,
	                                     idi_PECEoSDistance := #iUDT_Configuration."560".PEC_Eos.Distance,
	                                     idi_PECBoSDistance := 0,
	                                     ii_ExternalSpeed := 0,
	                                     ix_SafetyOk := #ix_SafetyOk,
	                                     ix_24vOk := #ix_24vOk,
	                                     ix_400vOk := #ix_400vOk,
	                                     ix_HardwareOk := #ix_HardwareOk,
	                                     ix_PECEoS := #iqUDT_WorkstationStatus."560".PEC_EoS.PEC,
	                                     ix_PECBoS := TRUE,
	                                     ix_ReverseDirection := FALSE,
	                                     ix_ExternalRequestDieBack := FALSE,
	                                     ix_ExternalRequestHold := #sx_RightExternalRequestHold560,
	                                     ix_ResetEnergySave := FALSE,
	                                     qUDT_HMIStatus => #iqUDT_WorkstationStatus."560".Conveyor,
	                                     qUDT_Status => #iqUDT_WorkstationCommonStatus."560",
	                                     iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                     iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."560".Conveyor,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface560,
	                                     iqUDT_HandShakeUp := #sUDT_Handshake550,
	                                     iqUDT_HandShake := #sUDT_Handshake560,
	                                     iqUDT_Statistics := #iqUDT_WorkstationStatistics."560".Conveyor);
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController560(iUDT_AixConfig := #iUDT_Configuration."560".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput550,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 2,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."560".MCO_M01,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput550,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface560,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."560".MCO_M01);
	                END_REGION
	                
	            END_REGION
	            
	            REGION 570
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement570(#sUDT_Interface570);
	                    
	                END_REGION
	                
	                REGION Tracking
	                    
	                    #sFB_Tracking570(iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."570".Conveyor.Common,
	                                     iqa_TrackingData := #sa_TrackingArray570,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface570,
	                                     iqUDT_HandshakeUp := #sUDT_Handshake560,
	                                     iqUDT_Handshake := #sUDT_Handshake570);
	                END_REGION
	                
	                REGION EOS
	                    
	                    #sFB_PECUpdate570(iUDT_PECUpdateConfiguration := #iUDT_Configuration."570".PEC_Eos,
	                                      iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."570".Conveyor.Common,
	                                      ix_PEC := NOT #iUDT_MotorInput570.AllSensorPortInputs.LeftSensor,
	                                      ix_TeachingMode := FALSE,
	                                      qUDT_Status => #iqUDT_WorkstationStatus."570".PEC_EoS,
	                                      qi_GINwrite => #ti_dummy,
	                                      qx_PECFiltered => #tx_dummy,
	                                      iqa_TrackingData := #sa_TrackingArray570,
	                                      iqUDT_ConveyorInterface := #sUDT_Interface570,
	                                      iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                                      iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                                      iqa_FifoData := "DB_FIFOLostGIN".Data,
	                                      iqUDT_Statistics := #iqUDT_WorkstationStatistics."570".PEC_EoS);
	                    
	                END_REGION
	                
	                REGION Conveyor
	                    
	                    #sUDT_Handshake570.RTR := #sx_RightIndexing AND
	                    ((#iqUDT_WorkstationStatus."580".PEC_EoS.PEC AND #sUDT_Interface580.ActualSpeed <> 0) OR #iqUDT_WorkstationStatus."570".PEC_EoS.PEC);
	                    
	                    #sFB_Conveyor570(iUDT_ConveyorConfiguration := #iUDT_Configuration."570".Conveyor,
	                                     idi_PECEoSDistance := #iUDT_Configuration."570".PEC_Eos.Distance,
	                                     idi_PECBoSDistance := 0,
	                                     ii_ExternalSpeed := 0,
	                                     ix_SafetyOk := #ix_SafetyOk,
	                                     ix_24vOk := #ix_24vOk,
	                                     ix_400vOk := #ix_400vOk,
	                                     ix_HardwareOk := #ix_HardwareOk,
	                                     ix_PECEoS := #iqUDT_WorkstationStatus."570".PEC_EoS.PEC,
	                                     ix_PECBoS := TRUE,
	                                     ix_ExternalRequestHold := #sx_RightExternalRequestHold570,
	                                     qUDT_HMIStatus => #iqUDT_WorkstationStatus."570".Conveyor,
	                                     qUDT_Status => #iqUDT_WorkstationCommonStatus."570",
	                                     iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                     iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."570".Conveyor,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface570,
	                                     iqUDT_HandShakeUp := #sUDT_Handshake560,
	                                     iqUDT_HandShake := #sUDT_Handshake570,
	                                     iqUDT_Statistics := #iqUDT_WorkstationStatistics."570".Conveyor);
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController570(iUDT_AixConfig := #iUDT_Configuration."570".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput570,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 1,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."570".MCO_M01,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput570,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface570,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."570".MCO_M01);
	                END_REGION
	            END_REGION
	            
	            REGION 580
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement580(#sUDT_Interface580);
	                    
	                END_REGION
	                
	                REGION Tracking
	                    
	                    #sFB_Tracking580(iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."580".Conveyor.Common,
	                                     iqa_TrackingData := #sa_TrackingArray580,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface580,
	                                     iqUDT_HandshakeUp := #sUDT_Handshake570,
	                                     iqUDT_Handshake := #sUDT_Handshake580);
	                END_REGION
	                
	                REGION EOS
	                    
	                    #sFB_PECUpdate580(iUDT_PECUpdateConfiguration := #iUDT_Configuration."580".PEC_Eos,
	                                      iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."580".Conveyor.Common,
	                                      ix_PEC := NOT #iUDT_MotorInput570.AllSensorPortInputs.RightSensor,
	                                      ix_TeachingMode := FALSE,
	                                      qUDT_Status => #iqUDT_WorkstationStatus."580".PEC_EoS,
	                                      qi_GINwrite => #ti_dummy,
	                                      qx_PECFiltered => #tx_dummy,
	                                      iqa_TrackingData := #sa_TrackingArray580,
	                                      iqUDT_ConveyorInterface := #sUDT_Interface580,
	                                      iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                                      iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                                      iqa_FifoData := "DB_FIFOLostGIN".Data,
	                                      iqUDT_Statistics := #iqUDT_WorkstationStatistics."580".PEC_EoS);
	                    
	                END_REGION
	                
	                REGION Conveyor
	                    
	                    #sUDT_Handshake580.RTR := #sx_RightIndexing AND
	                    ((#iqUDT_WorkstationStatus."590".PEC_EoS.PEC AND #sUDT_Interface590.ActualSpeed <> 0) OR #iqUDT_WorkstationStatus."580".PEC_EoS.PEC);
	                    
	                    #sFB_Conveyor580(iUDT_ConveyorConfiguration := #iUDT_Configuration."580".Conveyor,
	                                     idi_PECEoSDistance := #iUDT_Configuration."580".PEC_Eos.Distance,
	                                     idi_PECBoSDistance := 0,
	                                     ii_ExternalSpeed := 0,
	                                     ix_SafetyOk := #ix_SafetyOk,
	                                     ix_24vOk := #ix_24vOk,
	                                     ix_400vOk := #ix_400vOk,
	                                     ix_HardwareOk := #ix_HardwareOk,
	                                     ix_PECEoS := #iqUDT_WorkstationStatus."580".PEC_EoS.PEC,
	                                     ix_PECBoS := TRUE,
	                                     ix_ReverseDirection := FALSE,
	                                     ix_ExternalRequestDieBack := FALSE,
	                                     ix_ExternalRequestHold := #sx_RightExternalRequestHold580,
	                                     ix_ResetEnergySave := FALSE,
	                                     qUDT_HMIStatus => #iqUDT_WorkstationStatus."580".Conveyor,
	                                     qUDT_Status => #iqUDT_WorkstationCommonStatus."580",
	                                     iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                     iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."580".Conveyor,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface580,
	                                     iqUDT_HandShakeUp := #sUDT_Handshake570,
	                                     iqUDT_HandShake := #sUDT_Handshake580,
	                                     iqUDT_Statistics := #iqUDT_WorkstationStatistics."580".Conveyor);
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController580(iUDT_AixConfig := #iUDT_Configuration."580".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput570,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 2,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."580".MCO_M01,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput570,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface580,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."580".MCO_M01);
	                END_REGION
	                
	            END_REGION
	            
	            REGION 590
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement590(#sUDT_Interface590);
	                    
	                END_REGION
	                
	                REGION Tracking
	                    
	                    #sFB_Tracking590(iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."590".Conveyor.Common,
	                                     iqa_TrackingData := #sa_TrackingArray590,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface590,
	                                     iqUDT_HandshakeUp := #sUDT_Handshake580,
	                                     iqUDT_Handshake := #sUDT_Handshake590);
	                END_REGION
	                
	                REGION EOS
	                    
	                    #sFB_PECUpdate590(iUDT_PECUpdateConfiguration := #iUDT_Configuration."590".PEC_Eos,
	                                      iUDT_ConveyorCommonConfiguration := #iUDT_Configuration."590".Conveyor.Common,
	                                      ix_PEC := NOT #iUDT_MotorInput590.AllSensorPortInputs.LeftSensor,
	                                      ix_TeachingMode := FALSE,
	                                      qUDT_Status => #iqUDT_WorkstationStatus."590".PEC_EoS,
	                                      qi_GINwrite => #ti_dummy,
	                                      qx_PECFiltered => #tx_dummy,
	                                      iqa_TrackingData := #sa_TrackingArray590,
	                                      iqUDT_ConveyorInterface := #sUDT_Interface590,
	                                      iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                                      iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                                      iqa_FifoData := "DB_FIFOLostGIN".Data,
	                                      iqUDT_Statistics := #iqUDT_WorkstationStatistics."590".PEC_EoS);
	                    
	                END_REGION
	                
	                REGION Conveyor
	                    
	                    #sUDT_Handshake590.RTR := (#sx_RightIndexing AND #iqUDT_WorkstationStatus."590".PEC_EoS.PEC)
	                    OR (#sx_RightPushOutActiveStation1 AND #iqUDT_WorkstationStatus."610".PEC_EoS.PEC AND #sUDT_Interface611.ActualSpeed <> 0);
	                    
	                    #sFB_Conveyor590(iUDT_ConveyorConfiguration := #iUDT_Configuration."590".Conveyor,
	                                     idi_PECEoSDistance := #iUDT_Configuration."590".PEC_Eos.Distance,
	                                     idi_PECBoSDistance := 0,
	                                     ii_ExternalSpeed := 0,
	                                     ix_SafetyOk := #ix_SafetyOk,
	                                     ix_24vOk := #ix_24vOk,
	                                     ix_400vOk := #ix_400vOk,
	                                     ix_HardwareOk := #ix_HardwareOk,
	                                     ix_PECEoS := #iqUDT_WorkstationStatus."590".PEC_EoS.PEC,
	                                     ix_PECBoS := TRUE,
	                                     ix_ReverseDirection := FALSE,
	                                     ix_ExternalRequestDieBack := FALSE,
	                                     ix_ExternalRequestHold := #sx_RightExternalRequestHold590,
	                                     ix_ResetEnergySave := FALSE,
	                                     qUDT_HMIStatus => #iqUDT_WorkstationStatus."590".Conveyor,
	                                     qUDT_Status => #iqUDT_WorkstationCommonStatus."590",
	                                     iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                     iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."590".Conveyor,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface590,
	                                     iqUDT_HandShakeUp := #sUDT_Handshake580,
	                                     iqUDT_HandShake := #sUDT_Handshake590,
	                                     iqUDT_Statistics := #iqUDT_WorkstationStatistics."590".Conveyor);
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController590(iUDT_AixConfig := #iUDT_Configuration."590".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput590,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 1,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."590".MCO_M01,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput590,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface590,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."590".MCO_M01);
	                END_REGION
	            END_REGION
	            
	            REGION 610
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement610(#sUDT_Interface610);
	                    
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController610(iUDT_AixConfig := #iUDT_Configuration."610".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput610,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 1,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."610".MCO_M01,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput610,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface610,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."610".MCO_M01);
	                END_REGION
	            END_REGION
	            
	            REGION 611
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement611(#sUDT_Interface611);
	                    
	                END_REGION
	                
	                REGION RAT
	                    
	                    #sFB_RightAngledTransfer611(iUDT_Configuration := #iUDT_Configuration."611".RightAngledTransfer,
	                                                iUDT_LowerConveyorConfiguration := #iUDT_Configuration."610".Conveyor,
	                                                iUDT_UpperConveyorConfiguration := #iUDT_Configuration."611".Conveyor,
	                                                iUDT_PECConfiguration := #iUDT_Configuration."610".PEC_EoS,
	                                                ii_DestinationA := 0,
	                                                ii_DestinationB := 0,
	                                                ii_DestinationC := 0,
	                                                ii_DestinationD := 1,
	                                                ix_HardwareOk := #ix_HardwareOk,
	                                                ix_400vOk := #ix_400vOk,
	                                                ix_24vOk := #ix_24vOk,
	                                                ix_SafetyOk := #ix_SafetyOk,
	                                                ix_AirPressureOk := #ix_AirPressureOk,
	                                                ix_SectionIsDown := #ix_SectionIsDown611,
	                                                ix_SectionIsUp := #ix_SectionIsUp611,
	                                                ix_ConveyorAAuto := false,
	                                                ix_ConveyorBAuto := false,
	                                                ix_ConveyorCAuto := FALSE,
	                                                ix_ConveyorDAuto := #iqUDT_WorkstationCommonStatus."590".AutoON,
	                                                ix_PEC := #iUDT_MotorInput610.AllSensorPortInputs.LeftSensor,
	                                                ix_ExternalReceiveRequestA := FALSE,
	                                                ix_ExternalReceiveRequestB := FALSE,
	                                                ix_ExternalReceiveRequestC := FALSE,
	                                                ix_ExternalReceiveRequestD := #sx_RightPushOutActiveStation1,
	                                                ix_PECInfeedD := #iqUDT_WorkstationStatus."590".PEC_EoS.PEC,
	                                                qUDT_HMIRATStatus => #iqUDT_WorkstationStatus."611".RightAngledTransfer,
	                                                qUDT_HMIConveyorStatus => #iqUDT_WorkstationStatus."610".Conveyor,
	                                                qUDT_HMIPECStatus => #iqUDT_WorkstationStatus."610".PEC_EoS,
	                                                qUDT_RATStatus => #iqUDT_WorkstationCommonStatus."611",
	                                                qUDT_ConveyorStatus => #iqUDT_WorkstationCommonStatus."610",
	                                                qx_PopupControl => #qx_PopupControl611,
	                                                qx_ExternalSendRequestA => #tx_dummy,
	                                                qx_ExternalSendRequestB => #tx_dummy,
	                                                qx_ExternalSendRequestC => #tx_dummy,
	                                                qx_ExternalSendRequestD => #tx_dummy,
	                                                iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                                iqUDT_RATCommand := #iqUDT_WorkstationCommands."611".RightAngledTransfer,
	                                                iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."610".Conveyor,
	                                                iqUDT_RATStatistics := #iqUDT_WorkstationStatistics."611".RightAngledTransfer,
	                                                iqUDT_ConveyorStatistics := #iqUDT_WorkstationStatistics."610".Conveyor,
	                                                iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."610".PEC_EoS,
	                                                iqUDT_HandShakeConveyorA := #tUDT_DummyConveyorHandshake,
	                                                iqUDT_HandShakeConveyorB := #sUDT_Handshake610,
	                                                iqUDT_HandShakeConveyorC := #sUDT_Handshake590,
	                                                iqUDT_HandShakeConveyorD := #tUDT_DummyConveyorHandshake,
	                                                iqUDT_LowerConveyorInterface := #sUDT_Interface610,
	                                                iqUDT_UpperConveyorInterface := #sUDT_Interface611,
	                                                iqUDT_RATPositioning := #iqUDT_RATPositioning610,
	                                                iqUDT_BladeStopEoSInterface := #tUDT_DummyBladeStop,
	                                                iqUDT_BladeStopBoSInterface := #tUDT_DummyBladeStop);
	                    
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController611(iUDT_AixConfig := #iUDT_Configuration."611".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput610,
	                                                       ii_PositionSetpoint := #iqUDT_RATPositioning610.Upper.EndPosition,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 2,
	                                                       ix_StartPositioning := #iqUDT_RATPositioning610.Upper.Start,
	                                                       ix_ResetPosition := #iqUDT_RATPositioning610.Upper.ResetPosition,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."611".MCO_M01,
	                                                       qx_Positioned => #iqUDT_RATPositioning610.Upper.Done,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput610,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface611,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."611".MCO_M01);
	                END_REGION
	                
	            END_REGION
	            
	            REGION 620
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement620(#sUDT_Interface620);
	                    
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController620(iUDT_AixConfig := #iUDT_Configuration."620".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput620,
	                                                       ii_PositionSetpoint := #iqUDT_RATPositioning620.Lower.EndPosition,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 1,
	                                                       ix_StartPositioning := #iqUDT_RATPositioning620.Lower.Start,
	                                                       ix_ResetPosition := #iqUDT_RATPositioning620.Lower.ResetPosition,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."620".MCO_M01,
	                                                       qx_Positioned => #iqUDT_RATPositioning620.Lower.Done,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput620,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface620,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."620".MCO_M01);
	                END_REGION
	            END_REGION
	            
	            REGION 621
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement621(#sUDT_Interface621);
	                    
	                END_REGION
	                
	                REGION RAT
	                    
	                    #sFB_RightAngledTransfer621(iUDT_Configuration := #iUDT_Configuration."621".RightAngledTransfer,
	                                                iUDT_LowerConveyorConfiguration := #iUDT_Configuration."620".Conveyor,
	                                                iUDT_UpperConveyorConfiguration := #iUDT_Configuration."621".Conveyor,
	                                                iUDT_PECConfiguration := #iUDT_Configuration."620".PEC_EoS,
	                                                ii_DestinationA := 1,
	                                                ii_DestinationB := 0,
	                                                ii_DestinationC := 0,
	                                                ii_DestinationD := 1,
	                                                ix_HardwareOk := #ix_HardwareOk,
	                                                ix_400vOk := #ix_400vOk,
	                                                ix_24vOk := #ix_24vOk,
	                                                ix_SafetyOk := #ix_SafetyOk,
	                                                ix_AirPressureOk := #ix_AirPressureOk,
	                                                ix_SectionIsDown := #ix_SectionIsDown621,
	                                                ix_SectionIsUp := #ix_SectionIsUp621,
	                                                ix_ConveyorAAuto := #iqUDT_WorkstationCommonStatus."610".AutoON,
	                                                ix_ConveyorBAuto := false,
	                                                ix_ConveyorCAuto := false,
	                                                ix_ConveyorDAuto := #iqUDT_WorkstationCommonStatus."750".AutoON,
	                                                ix_PEC := #iUDT_MotorInput620.AllSensorPortInputs.LeftSensor,
	                                                ix_ExternalReceiveRequestA := NOT #iqUDT_WorkstationStatus."610".PEC_EoS.PEC,
	                                                ix_ExternalReceiveRequestB := FALSE,
	                                                ix_ExternalReceiveRequestC := FALSE,
	                                                ix_ExternalReceiveRequestD := NOT #iqUDT_WorkstationStatus."750".PEC_EoS.PEC,
	                                                ix_PECInfeedA := #iqUDT_WorkstationStatus."610".PEC_EoS.PEC,
	                                                ix_PECInfeedD := #iqUDT_WorkstationStatus."750".PEC_EoS.PEC,
	                                                qUDT_HMIRATStatus => #iqUDT_WorkstationStatus."621".RightAngledTransfer,
	                                                qUDT_HMIConveyorStatus => #iqUDT_WorkstationStatus."620".Conveyor,
	                                                qUDT_HMIPECStatus => #iqUDT_WorkstationStatus."620".PEC_EoS,
	                                                qUDT_RATStatus => #iqUDT_WorkstationCommonStatus."621",
	                                                qUDT_ConveyorStatus => #iqUDT_WorkstationCommonStatus."620",
	                                                qx_PopupControl => #qx_PopupControl621,
	                                                qx_ExternalSendRequestA => #tx_dummy,
	                                                qx_ExternalSendRequestB => #tx_dummy,
	                                                qx_ExternalSendRequestC => #tx_dummy,
	                                                qx_ExternalSendRequestD => #tx_dummy,
	                                                iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                                iqUDT_RATCommand := #iqUDT_WorkstationCommands."621".RightAngledTransfer,
	                                                iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."620".Conveyor,
	                                                iqUDT_RATStatistics := #iqUDT_WorkstationStatistics."621".RightAngledTransfer,
	                                                iqUDT_ConveyorStatistics := #iqUDT_WorkstationStatistics."620".Conveyor,
	                                                iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."620".PEC_EoS,
	                                                iqUDT_HandShakeConveyorA := #sUDT_Handshake610,
	                                                iqUDT_HandShakeConveyorB := #sUDT_Handshake620,
	                                                iqUDT_HandShakeConveyorC := #tUDT_DummyConveyorHandshake,
	                                                iqUDT_HandShakeConveyorD := #sUDT_Handshake750,
	                                                iqUDT_LowerConveyorInterface := #sUDT_Interface620,
	                                                iqUDT_UpperConveyorInterface := #sUDT_Interface621,
	                                                iqUDT_RATPositioning := #iqUDT_RATPositioning620,
	                                                iqUDT_BladeStopEoSInterface := #tUDT_DummyBladeStop,
	                                                iqUDT_BladeStopBoSInterface := #tUDT_DummyBladeStop);
	                    
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController621(iUDT_AixConfig := #iUDT_Configuration."621".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput620,
	                                                       ii_PositionSetpoint := #iqUDT_RATPositioning620.Upper.EndPosition,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 2,
	                                                       ix_StartPositioning := #iqUDT_RATPositioning620.Upper.Start,
	                                                       ix_ResetPosition := #iqUDT_RATPositioning620.Upper.ResetPosition,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."621".MCO_M01,
	                                                       qx_Positioned => #iqUDT_RATPositioning620.Upper.Done,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput620,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface621,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."621".MCO_M01);
	                END_REGION
	                
	            END_REGION
	            
	            REGION 630
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement630(#sUDT_Interface630);
	                    
	                END_REGION
	                
	                REGION Conveyor 
	                    
	                    #sFB_Conveyor630(iUDT_ConveyorConfiguration := #iUDT_Configuration."630".Conveyor,
	                                     idi_PECEoSDistance := 0,
	                                     idi_PECBoSDistance := 0,
	                                     ii_ExternalSpeed := 0,
	                                     ix_SafetyOk := #ix_SafetyOk,
	                                     ix_24vOk := #ix_24vOk,
	                                     ix_400vOk := #ix_400vOk,
	                                     ix_HardwareOk := #ix_HardwareOk,
	                                     ix_PECEoS := TRUE,
	                                     ix_PECBoS := TRUE,
	                                     ix_ReverseDirection := FALSE,
	                                     ix_ExternalRequestDieBack := FALSE,
	                                     ix_ExternalRequestHold := FALSE,
	                                     ix_ResetEnergySave := FALSE,
	                                     qUDT_HMIStatus => #iqUDT_WorkstationStatus."630".Conveyor,
	                                     qUDT_Status => #iqUDT_WorkstationCommonStatus."630",
	                                     iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                     iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."630".Conveyor,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface630,
	                                     iqUDT_HandShakeUp := #sUDT_Handshake620,
	                                     iqUDT_HandShake := #iqUDT_HandshakeDownstream630,
	                                     iqUDT_Statistics := #iqUDT_WorkstationStatistics."630".Conveyor);
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController630(iUDT_AixConfig := #iUDT_Configuration."630".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput630,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 1,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."630".MCO_M01,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput630,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface630,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."630".MCO_M01);
	                END_REGION
	            END_REGION
	            
	            REGION 710
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement710(#sUDT_Interface710);
	                    
	                END_REGION
	                
	                REGION EOS
	                    #sFB_PEC710(ix_PEC := NOT #iUDT_MotorInput710.AllSensorPortInputs.LeftSensor,
	                                iUDT_PECConfiguration := #iUDT_Configuration."710".PEC_Eos,
	                                qx_PECFiltered => #tx_dummy,
	                                qUDT_HMIStatus => #iqUDT_WorkstationStatus."710".PEC_EoS,
	                                iqUDT_ConveyorInterface := #sUDT_Interface710,
	                                iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."710".PEC_EoS);
	                    
	                END_REGION
	                
	                REGION Conveyor
	                    
	                    #sFB_Conveyor710(iUDT_ConveyorConfiguration := #iUDT_Configuration."710".Conveyor,
	                                     idi_PECEoSDistance := #iUDT_Configuration."710".PEC_Eos.Distance,
	                                     idi_PECBoSDistance := 0,
	                                     ii_ExternalSpeed := 0,
	                                     ix_SafetyOk := #ix_SafetyOk,
	                                     ix_24vOk := #ix_24vOk,
	                                     ix_400vOk := #ix_400vOk,
	                                     ix_HardwareOk := #ix_HardwareOk,
	                                     ix_PECEoS := #iqUDT_WorkstationStatus."710".PEC_EoS.PEC,
	                                     ix_PECBoS := TRUE,
	                                     ix_ReverseDirection := FALSE,
	                                     ix_ExternalRequestDieBack := FALSE,
	                                     ix_ExternalRequestHold := #sx_RightExternalRequestHold710,
	                                     ix_ResetEnergySave := FALSE,
	                                     qUDT_HMIStatus => #iqUDT_WorkstationStatus."710".Conveyor,
	                                     qUDT_Status => #iqUDT_WorkstationCommonStatus."710",
	                                     iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                     iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."710".Conveyor,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface710,
	                                     iqUDT_HandShakeUp := #tUDT_DummyConveyorHandshake,
	                                     iqUDT_HandShake := #sUDT_Handshake710,
	                                     iqUDT_Statistics := #iqUDT_WorkstationStatistics."710".Conveyor);
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController710(iUDT_AixConfig := #iUDT_Configuration."710".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput710,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 1,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."710".MCO_M01,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput710,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface710,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."710".MCO_M01);
	                END_REGION
	                
	            END_REGION
	            
	            REGION 720
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement720(#sUDT_Interface720);
	                    
	                END_REGION
	                
	                REGION EOS
	                    #sFB_PEC720(ix_PEC := NOT #iUDT_MotorInput710.AllSensorPortInputs.RightSensor,
	                                iUDT_PECConfiguration := #iUDT_Configuration."720".PEC_Eos,
	                                qx_PECFiltered => #tx_dummy,
	                                qUDT_HMIStatus => #iqUDT_WorkstationStatus."720".PEC_EoS,
	                                iqUDT_ConveyorInterface := #sUDT_Interface720,
	                                iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."720".PEC_EoS);
	                    
	                    
	                END_REGION
	                
	                REGION Conveyor
	                    
	                    #sFB_Conveyor720(iUDT_ConveyorConfiguration := #iUDT_Configuration."720".Conveyor,
	                                     idi_PECEoSDistance := #iUDT_Configuration."720".PEC_Eos.Distance,
	                                     idi_PECBoSDistance := 0,
	                                     ii_ExternalSpeed := 0,
	                                     ix_SafetyOk := #ix_SafetyOk,
	                                     ix_24vOk := #ix_24vOk,
	                                     ix_400vOk := #ix_400vOk,
	                                     ix_HardwareOk := #ix_HardwareOk,
	                                     ix_PECEoS := #iqUDT_WorkstationStatus."720".PEC_EoS.PEC,
	                                     ix_PECBoS := TRUE,
	                                     ix_ReverseDirection := FALSE,
	                                     ix_ExternalRequestDieBack := FALSE,
	                                     ix_ExternalRequestHold := #sx_RightExternalRequestHold720,
	                                     ix_ResetEnergySave := FALSE,
	                                     qUDT_HMIStatus => #iqUDT_WorkstationStatus."720".Conveyor,
	                                     qUDT_Status => #iqUDT_WorkstationCommonStatus."720",
	                                     iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                     iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."720".Conveyor,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface720,
	                                     iqUDT_HandShakeUp := #sUDT_Handshake710,
	                                     iqUDT_HandShake := #sUDT_Handshake720,
	                                     iqUDT_Statistics := #iqUDT_WorkstationStatistics."720".Conveyor);
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController720(iUDT_AixConfig := #iUDT_Configuration."720".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput710,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 2,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."720".MCO_M01,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput710,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface720,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."720".MCO_M01);
	                END_REGION
	                
	            END_REGION
	            
	            REGION 730
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement730(#sUDT_Interface730);
	                    
	                END_REGION
	                
	                REGION EOS
	                    #sFB_PEC730(ix_PEC := NOT #iUDT_MotorInput730.AllSensorPortInputs.LeftSensor,
	                                iUDT_PECConfiguration := #iUDT_Configuration."730".PEC_Eos,
	                                qx_PECFiltered => #tx_dummy,
	                                qUDT_HMIStatus => #iqUDT_WorkstationStatus."730".PEC_EoS,
	                                iqUDT_ConveyorInterface := #sUDT_Interface730,
	                                iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."730".PEC_EoS);
	                    
	                    
	                END_REGION
	                
	                REGION Conveyor
	                    
	                    #sFB_Conveyor730(iUDT_ConveyorConfiguration := #iUDT_Configuration."730".Conveyor,
	                                     idi_PECEoSDistance := #iUDT_Configuration."730".PEC_Eos.Distance,
	                                     idi_PECBoSDistance := 0,
	                                     ii_ExternalSpeed := 0,
	                                     ix_SafetyOk := #ix_SafetyOk,
	                                     ix_24vOk := #ix_24vOk,
	                                     ix_400vOk := #ix_400vOk,
	                                     ix_HardwareOk := #ix_HardwareOk,
	                                     ix_PECEoS := #iqUDT_WorkstationStatus."730".PEC_EoS.PEC,
	                                     ix_PECBoS := TRUE,
	                                     ix_ReverseDirection := FALSE,
	                                     ix_ExternalRequestDieBack := FALSE,
	                                     ix_ExternalRequestHold := #sx_RightExternalRequestHold730,
	                                     ix_ResetEnergySave := FALSE,
	                                     qUDT_HMIStatus => #iqUDT_WorkstationStatus."730".Conveyor,
	                                     qUDT_Status => #iqUDT_WorkstationCommonStatus."730",
	                                     iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                     iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."730".Conveyor,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface730,
	                                     iqUDT_HandShakeUp := #sUDT_Handshake720,
	                                     iqUDT_HandShake := #sUDT_Handshake730,
	                                     iqUDT_Statistics := #iqUDT_WorkstationStatistics."730".Conveyor);
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController730(iUDT_AixConfig := #iUDT_Configuration."730".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput730,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 1,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."730".MCO_M01,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput730,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface730,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."730".MCO_M01);
	                END_REGION
	            END_REGION
	            
	            REGION 740
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement740(#sUDT_Interface740);
	                    
	                END_REGION
	                
	                REGION EOS
	                    #sFB_PEC740(ix_PEC := NOT #iUDT_MotorInput730.AllSensorPortInputs.RightSensor,
	                                iUDT_PECConfiguration := #iUDT_Configuration."740".PEC_Eos,
	                                qx_PECFiltered => #tx_dummy,
	                                qUDT_HMIStatus => #iqUDT_WorkstationStatus."740".PEC_EoS,
	                                iqUDT_ConveyorInterface := #sUDT_Interface740,
	                                iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."740".PEC_EoS);
	                    
	                    
	                END_REGION
	                
	                
	                REGION Conveyor
	                    
	                    #sFB_Conveyor740(iUDT_ConveyorConfiguration := #iUDT_Configuration."740".Conveyor,
	                                     idi_PECEoSDistance := #iUDT_Configuration."740".PEC_Eos.Distance,
	                                     idi_PECBoSDistance := 0,
	                                     ii_ExternalSpeed := 0,
	                                     ix_SafetyOk := #ix_SafetyOk,
	                                     ix_24vOk := #ix_24vOk,
	                                     ix_400vOk := #ix_400vOk,
	                                     ix_HardwareOk := #ix_HardwareOk,
	                                     ix_PECEoS := #iqUDT_WorkstationStatus."740".PEC_EoS.PEC,
	                                     ix_PECBoS := TRUE,
	                                     ix_ReverseDirection := FALSE,
	                                     ix_ExternalRequestDieBack := FALSE,
	                                     ix_ExternalRequestHold := #sx_RightExternalRequestHold740,
	                                     ix_ResetEnergySave := FALSE,
	                                     qUDT_HMIStatus => #iqUDT_WorkstationStatus."740".Conveyor,
	                                     qUDT_Status => #iqUDT_WorkstationCommonStatus."740",
	                                     iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                     iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."740".Conveyor,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface740,
	                                     iqUDT_HandShakeUp := #sUDT_Handshake730,
	                                     iqUDT_HandShake := #sUDT_Handshake740,
	                                     iqUDT_Statistics := #iqUDT_WorkstationStatistics."740".Conveyor);
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController740(iUDT_AixConfig := #iUDT_Configuration."740".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput730,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 2,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."740".MCO_M01,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput730,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface740,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."740".MCO_M01);
	                END_REGION
	                
	            END_REGION
	            
	            REGION 750
	                
	                REGION Displacement
	                    
	                    #sFB_Displacement750(#sUDT_Interface750);
	                    
	                END_REGION
	                
	                REGION EOS
	                    #sFB_PEC750(ix_PEC := NOT #iUDT_MotorInput750.AllSensorPortInputs.LeftSensor,
	                                iUDT_PECConfiguration := #iUDT_Configuration."750".PEC_Eos,
	                                qx_PECFiltered => #tx_dummy,
	                                qUDT_HMIStatus => #iqUDT_WorkstationStatus."750".PEC_EoS,
	                                iqUDT_ConveyorInterface := #sUDT_Interface750,
	                                iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."750".PEC_EoS);
	                    
	                END_REGION
	                
	                REGION Conveyor
	                    
	                    #sUDT_Handshake750.RTR := #sUDT_Handshake750.RTR OR #iqUDT_WorkstationStatus."750".PEC_EoS.PEC;
	                    
	                    #sFB_Conveyor750(iUDT_ConveyorConfiguration := #iUDT_Configuration."750".Conveyor,
	                                     idi_PECEoSDistance := #iUDT_Configuration."750".PEC_Eos.Distance,
	                                     idi_PECBoSDistance := 0,
	                                     ii_ExternalSpeed := 0,
	                                     ix_SafetyOk := #ix_SafetyOk,
	                                     ix_24vOk := #ix_24vOk,
	                                     ix_400vOk := #ix_400vOk,
	                                     ix_HardwareOk := #ix_HardwareOk,
	                                     ix_PECEoS := #iqUDT_WorkstationStatus."750".PEC_EoS.PEC,
	                                     ix_PECBoS := TRUE,
	                                     ix_ReverseDirection := FALSE,
	                                     ix_ExternalRequestDieBack := FALSE,
	                                     ix_ExternalRequestHold := #sx_RightExternalRequestHold750,
	                                     ix_ResetEnergySave := FALSE,
	                                     qUDT_HMIStatus => #iqUDT_WorkstationStatus."750".Conveyor,
	                                     qUDT_Status => #iqUDT_WorkstationCommonStatus."750",
	                                     iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                     iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."750".Conveyor,
	                                     iqUDT_ConveyorInterface := #sUDT_Interface750,
	                                     iqUDT_HandShakeUp := #sUDT_Handshake740,
	                                     iqUDT_HandShake := #sUDT_Handshake750,
	                                     iqUDT_Statistics := #iqUDT_WorkstationStatistics."750".Conveyor);
	                END_REGION
	                
	                REGION MCO
	                    
	                    #sFB_MCOConveyLinxAixController750(iUDT_AixConfig := #iUDT_Configuration."750".MCO_M01,
	                                                       iUDT_AixInputsModule := #iUDT_MotorInput750,
	                                                       ix_24vOk := #ix_24vOk,
	                                                       ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                       ii_MotorPositionId := 1,
	                                                       qUDT_HMIStatus => #iqUDT_WorkstationStatus."750".MCO_M01,
	                                                       iqUDT_AixOutputsModule := #iqUDT_MotorOutput750,
	                                                       iqUDT_ConveyorInterface := #sUDT_Interface750,
	                                                       iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."750".MCO_M01);
	                END_REGION
	            END_REGION
	        END_REGION
	        
	    END_IF;
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_WSR"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 270
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_MotorInput010 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 010 ConveyLinxAix inputs structure
      iUDT_MotorInput030 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 030 ConveyLinxAix inputs structure
      iUDT_MotorInput040 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 040 ConveyLinxAix inputs structure
      iUDT_MotorInput050 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 050 ConveyLinxAix inputs structure
      iUDT_MotorInput070 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 070 ConveyLinxAix inputs structure
      iUDT_MotorInput110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 110 ConveyLinxAix inputs structure
      iUDT_MotorInput130 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 130 ConveyLinxAix inputs structure
      iUDT_MotorInput140 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 140 ConveyLinxAix inputs structure
      iUDT_MotorInput150 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 150 ConveyLinxAix inputs structure
      iUDT_MotorInput170 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 170 ConveyLinxAix inputs structure
      iUDT_MotorInput210 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 210 ConveyLinxAix inputs structure
      iUDT_MotorInput230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 230 ConveyLinxAix inputs structure
      iUDT_MotorInput240 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 240 ConveyLinxAix inputs structure
      iUDT_MotorInput250 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 250 ConveyLinxAix inputs structure
      iUDT_MotorInput270 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // 270 ConveyLinxAix inputs structure
      ix_24vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 24VDC is healthy
      ix_400vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 400VAC is healthy
      ix_SafetyOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when safety is ok
      ix_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when  hardware is ok
      ix_AirPressureOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when air pressure is ok
      ix_SectionisUp041 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 041 section is up
      ix_SectionisDown041 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 041 section is down
      ix_SectionisUp141 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 141 section is up
      ix_SectionisDown141 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 141 section is down
      ix_SectionisUp241 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 241 section is up
      ix_SectionisDown241 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 041 section is down
      ix_BladeStopisUp040 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 040 blade stop is up
      ix_BladeStopisDown040 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 040 blade stop is down
      ix_BladeStopisUp140 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 140 blade stop is up
      ix_BladeStopisDown140 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 140 blade stop is down
      ix_StationActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_OUTPUT 
      qx_PopupControl041 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command up for section 041
      qx_PopupControl141 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command up for section 141
      qx_PopupControl241 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command up for section 241
      qx_BladeStopControl040 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command up for blade stop 040
      qx_BladeStopControl140 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command up for blade stop 140
   END_VAR

   VAR_IN_OUT 
      iqUDT_Configuration : "UDT_WSRConfiguration";   // Workstation configuration structure
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
      iqUDT_HandshakeUpstream010 : "UDT_ConveyorHandshake";   // Upstream handshake structure in forward direction for 010 conveyor
      iqUDT_HandshakeUpstream110 : "UDT_ConveyorHandshake";   // Upstream handshake structure in forward direction for 110 conveyor
      iqUDT_HandshakeDownstream270 : "UDT_ConveyorHandshake";   // Handshake structure in forward direction for 270 conveyor
      iqUDT_UnknownGINRange : "UDT_UnknownGIN";   // Unknown GIN
      iqUDT_WorkstationCommands : "UDT_WSRHmiCommands";   // Workstation command structure
      iqUDT_WorkstationStatistics : "UDT_WSRStatistics";   // Statistics structure
      iqUDT_WorkstationStatus : "UDT_WSRStatus";   // HMI Status structure
      iqUDT_WorkstationCommonStatus : "UDT_WSRCommonStatus";   // Common status structure
      iqa_EmptyFifoHeader : "UDT_FifoHeader";
      iqa_EmptyFifoData : Array[*] of Int;
      iqa_PartialFifoHeader : "UDT_FifoHeader";
      iqa_PartialFifoData : Array[*] of Int;
      iqUDT_EmptyBuffer : "UDT_WSRBufferState";
      iqUDT_PartialBuffer : "UDT_WSRBufferState";
      iqi_Request030 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Request empty - 1 Request partialy - 2
      iqi_Request130 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Request empty - 1 Request partialy - 2
      iqx_ReleaseBin050 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      iqx_ReleaseBin060 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      iqx_ReleaseBin070 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      iqx_ReleaseBin150 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      iqx_ReleaseBin160 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      iqx_ReleaseBin170 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      iqUDT_MotorOutput010 : "UDT_AixPlcFullOut";   // 010 ConveyLinxAix outputs structure
      iqUDT_MotorOutput030 : "UDT_AixPlcFullOut";   // 030 ConveyLinxAix outputs structure
      iqUDT_MotorOutput040 : "UDT_AixPlcFullOut";   // 040 ConveyLinxAix outputs structure
      iqUDT_MotorOutput050 : "UDT_AixPlcFullOut";   // 050 ConveyLinxAix outputs structure
      iqUDT_MotorOutput070 : "UDT_AixPlcFullOut";   // 070 ConveyLinxAix outputs structure
      iqUDT_MotorOutput110 : "UDT_AixPlcFullOut";   // 110 ConveyLinxAix outputs structure
      iqUDT_MotorOutput130 : "UDT_AixPlcFullOut";   // 130 ConveyLinxAix outputs structure
      iqUDT_MotorOutput140 : "UDT_AixPlcFullOut";   // 140 ConveyLinxAix outputs structure
      iqUDT_MotorOutput150 : "UDT_AixPlcFullOut";   // 150 ConveyLinxAix outputs structure
      iqUDT_MotorOutput170 : "UDT_AixPlcFullOut";   // 170 ConveyLinxAix outputs structure
      iqUDT_MotorOutput210 : "UDT_AixPlcFullOut";   // 210 ConveyLinxAix outputs structure
      iqUDT_MotorOutput230 : "UDT_AixPlcFullOut";   // 230 ConveyLinxAix outputs structure
      iqUDT_MotorOutput240 : "UDT_AixPlcFullOut";   // 240 ConveyLinxAix outputs structure
      iqUDT_MotorOutput250 : "UDT_AixPlcFullOut";   // 250 ConveyLinxAix outputs structure
      iqUDT_MotorOutput270 : "UDT_AixPlcFullOut";   // 270 ConveyLinxAix outputs structure
      iqUDT_RATPositioning040 : "UDT_RATPositioning";   // Structure including data for servo control RAT 041
      iqUDT_RATPositioning140 : "UDT_RATPositioning";   // Structure including data for servo control RAT 141
      iqUDT_RATPositioning240 : "UDT_RATPositioning";   // Structure including data for servo control RAT 241
   END_VAR

   VAR 
      sFB_Displacement010 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 010 conveyor
      sFB_Displacement020 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 020 conveyor
      sFB_Displacement030 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 030 conveyor
      sFB_Displacement040 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 040 conveyor
      sFB_Displacement041 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 041 conveyor
      sFB_Displacement050 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 050 conveyor
      sFB_Displacement060 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 060 conveyor
      sFB_Displacement070 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 070 conveyor
      sFB_Displacement080 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 080 conveyor
      sFB_Displacement110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 110 conveyor
      sFB_Displacement120 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 120 conveyor
      sFB_Displacement130 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 130 conveyor
      sFB_Displacement140 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 140 conveyor
      sFB_Displacement141 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 141 conveyor
      sFB_Displacement150 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 150 conveyor
      sFB_Displacement160 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 160 conveyor
      sFB_Displacement170 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 170 conveyor
      sFB_Displacement180 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 180 conveyor
      sFB_Displacement210 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 210 conveyor
      sFB_Displacement220 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 220 conveyor
      sFB_Displacement230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 230 conveyor
      sFB_Displacement240 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 240 conveyor
      sFB_Displacement241 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 241 conveyor
      sFB_Displacement250 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 250 conveyor
      sFB_Displacement260 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 260 conveyor
      sFB_Displacement270 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Displacement calculation for 270 conveyor
      sUDT_Interface_010 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 010 conveyor
      sUDT_Interface_020 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 020 conveyor
      sUDT_Interface_030 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 030 conveyor
      sUDT_Interface_040 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 040 conveyor
      sUDT_Interface_041 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 041 conveyor
      sUDT_Interface_050 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 050 conveyor
      sUDT_Interface_060 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 060 conveyor
      sUDT_Interface_070 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 070 conveyor
      sUDT_Interface_080 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 080 conveyor
      sUDT_Interface_110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 110 conveyor
      sUDT_Interface_120 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 120 conveyor
      sUDT_Interface_130 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 130 conveyor
      sUDT_Interface_140 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 140 conveyor
      sUDT_Interface_141 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 141 conveyor
      sUDT_Interface_150 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 150 conveyor
      sUDT_Interface_160 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 160 conveyor
      sUDT_Interface_170 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 170 conveyor
      sUDT_Interface_180 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 180 conveyor
      sUDT_Interface_210 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 210 conveyor
      sUDT_Interface_220 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 220 conveyor
      sUDT_Interface_230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 230 conveyor
      sUDT_Interface_240 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 240 conveyor
      sUDT_Interface_241 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 241 conveyor
      sUDT_Interface_250 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 250 conveyor
      sUDT_Interface_260 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 260 conveyor
      sUDT_Interface_270 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Interface structure for 270 conveyor
      sUDT_Interface_040_BladeStopEoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ValveInterface";   // Interface structure for 040 blade stop
      sUDT_Interface_140_BladeStopEoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ValveInterface";   // Interface structure for 140 blade stop
      sFB_Tracking_010 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 010 conveyor
      sFB_Tracking_020 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 020 conveyor
      sFB_Tracking_030 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 030 conveyor
      sFB_Tracking_050 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 050 conveyor
      sFB_Tracking_060 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 060 conveyor
      sFB_Tracking_070 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 070 conveyor
      sFB_Tracking_110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 110 conveyor
      sFB_Tracking_120 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 120 conveyor
      sFB_Tracking_130 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 130 conveyor
      sFB_Tracking_150 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 150 conveyor
      sFB_Tracking_160 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 160 conveyor
      sFB_Tracking_170 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 170 conveyor
      sFB_Tracking_210 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 210 conveyor
      sFB_Tracking_220 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 220 conveyor
      sFB_Tracking_230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 230 conveyor
      sFB_Tracking_250 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 250 conveyor
      sFB_Tracking_260 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 260 conveyor
      sFB_Tracking_270 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Tracking";   // Tracking function for 270 conveyor
      sa_TrackingArray_010 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..100] of Int;   // Tracking array for 010 conveyor
      sa_TrackingArray_020 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..100] of Int;   // Tracking array for 020 conveyor
      sa_TrackingArray_030 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..100] of Int;   // Tracking array for 030 conveyor
      sa_TrackingArray_050 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..100] of Int;   // Tracking array for 050 conveyor
      sa_TrackingArray_060 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..100] of Int;   // Tracking array for 060 conveyor
      sa_TrackingArray_070 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..100] of Int;   // Tracking array for 070 conveyor
      sa_TrackingArray_110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..100] of Int;   // Tracking array for 110 conveyor
      sa_TrackingArray_120 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..100] of Int;   // Tracking array for 120 conveyor
      sa_TrackingArray_130 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..100] of Int;   // Tracking array for 130 conveyor
      sa_TrackingArray_150 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..100] of Int;   // Tracking array for 150 conveyor
      sa_TrackingArray_160 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..100] of Int;   // Tracking array for 160 conveyor
      sa_TrackingArray_170 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..100] of Int;   // Tracking array for 170 conveyor
      sa_TrackingArray_210 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..100] of Int;   // Tracking array for 210 conveyor
      sa_TrackingArray_220 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..100] of Int;   // Tracking array for 220 conveyor
      sa_TrackingArray_230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..100] of Int;   // Tracking array for 230 conveyor
      sa_TrackingArray_250 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..100] of Int;   // Tracking array for 250 conveyor
      sa_TrackingArray_260 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..100] of Int;   // Tracking array for 260 conveyor
      sa_TrackingArray_270 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..100] of Int;   // Tracking array for 270 conveyor
      sUDT_Handshake_010 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 010 conveyor
      sUDT_Handshake_020 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 020 conveyor
      sUDT_Handshake_030 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 030 conveyor
      sUDT_Handshake_040 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 040 conveyor
      sUDT_Handshake_041 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 041 conveyor
      sUDT_HandshakeUp_041 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 041 conveyor
      sUDT_Handshake_050 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 050 conveyor
      sUDT_Handshake_060 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 060 conveyor
      sUDT_Handshake_070 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 070 conveyor
      sUDT_Handshake_080 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 080 conveyor
      sUDT_HandshakeUp_080 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 080 conveyor
      sUDT_Handshake_110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 110 conveyor
      sUDT_Handshake_120 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 120 conveyor
      sUDT_Handshake_130 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 130 conveyor
      sUDT_Handshake_140 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 140 conveyor
      sUDT_Handshake_141 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 141 conveyor
      sUDT_Handshake_150 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 150 conveyor
      sUDT_Handshake_160 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 160 conveyor
      sUDT_Handshake_170 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 170 conveyor
      sUDT_Handshake_180 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 180 conveyor
      sUDT_HandshakeUp_180 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 180 conveyor
      sUDT_HandshakeUp_210 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 210 conveyor
      sUDT_Handshake_210 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 210 conveyor
      sUDT_Handshake_220 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 220 conveyor
      sUDT_Handshake_230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 230 conveyor
      sUDT_Handshake_240 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 240 conveyor
      sUDT_Handshake_241 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 241 conveyor
      sUDT_Handshake_250 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 250 conveyor
      sUDT_Handshake_260 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   // Handshake structure for 260 conveyor
      sFB_PECUpdate_010 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 010 conveyor
      sFB_PECUpdate_020 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 020 conveyor
      sFB_PECUpdate_030 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 030 conveyor
      sFB_PECUpdate_050 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 050 conveyor
      sFB_PECUpdate_060 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 060 conveyor
      sFB_PECUpdate_070 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 070 conveyor
      sFB_PECUpdate_110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 110 conveyor
      sFB_PECUpdate_120 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 120 conveyor
      sFB_PECUpdate_130 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 130 conveyor
      sFB_PECUpdate_150 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 150 conveyor
      sFB_PECUpdate_160 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 160 conveyor
      sFB_PECUpdate_170 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 170 conveyor
      sFB_PECUpdate_210 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 210 conveyor
      sFB_PECUpdate_220 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 220 conveyor
      sFB_PECUpdate_230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 230 conveyor
      sFB_PECUpdate_250 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 250 conveyor
      sFB_PECUpdate_260 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 260 conveyor
      sFB_PECUpdate_270 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECUpdate";   // Photoeye handling for 270 conveyor
      sFB_Conveyor_010 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 010 conveyor
      sFB_Conveyor_020 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 020 conveyor
      sFB_Conveyor_030 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 030 conveyor
      sFB_Conveyor_050 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 050 conveyor
      sFB_Conveyor_060 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 060 conveyor
      sFB_Conveyor_070 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 070 conveyor
      sFB_Conveyor_080 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 080 conveyor
      sFB_Conveyor_110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 110 conveyor
      sFB_Conveyor_120 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 120 conveyor
      sFB_Conveyor_130 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 130 conveyor
      sFB_Conveyor_150 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 150 conveyor
      sFB_Conveyor_160 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 160 conveyor
      sFB_Conveyor_170 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 170 conveyor
      sFB_Conveyor_180 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 180 conveyor
      sFB_Conveyor_210 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 210 conveyor
      sFB_Conveyor_220 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 220 conveyor
      sFB_Conveyor_230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 230 conveyor
      sFB_Conveyor_250 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 250 conveyor
      sFB_Conveyor_260 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 260 conveyor
      sFB_Conveyor_270 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Conveyor";   // Function block to control the 270 conveyor
      sFB_MCOConveyLinxAixController_010 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 010
      sFB_MCOConveyLinxAixController_020 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 010
      sFB_MCOConveyLinxAixController_030 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 030
      sFB_MCOConveyLinxAixController_040 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 040
      sFB_MCOConveyLinxAixController_041 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 040
      sFB_MCOConveyLinxAixController_050 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 050
      sFB_MCOConveyLinxAixController_060 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 050
      sFB_MCOConveyLinxAixController_070 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 070
      sFB_MCOConveyLinxAixController_080 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 070
      sFB_MCOConveyLinxAixController_110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 110
      sFB_MCOConveyLinxAixController_120 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 110
      sFB_MCOConveyLinxAixController_130 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 130
      sFB_MCOConveyLinxAixController_140 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 140
      sFB_MCOConveyLinxAixController_141 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 140
      sFB_MCOConveyLinxAixController_150 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 150
      sFB_MCOConveyLinxAixController_160 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 110
      sFB_MCOConveyLinxAixController_170 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 170
      sFB_MCOConveyLinxAixController_180 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 070
      sFB_MCOConveyLinxAixController_210 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 210
      sFB_MCOConveyLinxAixController_220 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 110
      sFB_MCOConveyLinxAixController_230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 230
      sFB_MCOConveyLinxAixController_240 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 240
      sFB_MCOConveyLinxAixController_241 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 240
      sFB_MCOConveyLinxAixController_250 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 250
      sFB_MCOConveyLinxAixController_260 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 110
      sFB_MCOConveyLinxAixController_270 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MCOConveyLinxAixController";   // Function to interface with ConveyLinx Aix Controller for 270
      sFB_BladeStopEoS_040 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Valve";   // Function block to control the 040 blade stop
      sFB_BladeStopEoS_140 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Valve";   // Function block to control the 140 blade stop
      sFB_RightAngledTransfer_041 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_RightAngledTransfer";   // Funtion to control 041 RAT
      sFB_RightAngledTransfer_141 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_RightAngledTransfer";   // Funtion to control 141 RAT
      sFB_RightAngledTransfer_241 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_RightAngledTransfer";   // Funtion to control 241 RAT
      sFB_OperationTimeout { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Function block to generate operation timeout
      sF_TRIG_ParcelArrived1X0 {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Parcel arrived on target detection 150
      sF_TRIG_ParcelArrived0X0 {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Parcel arrived on target detection 050
      sF_TRIG_ParcelArrived2X0 {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Parcel arrived on target detection 250
      sR_TRIG_NewParcel010 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : R_TRIG;
      sR_TRIG_NewParcel110 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : R_TRIG;
      si_EmptyBinRequiredCounter0X0 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Number of available empty bin request to 050 conveyor
      si_EmptyBinRequiredCounter1X0 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Number of available empty bin request to 150 conveyor
      si_PartialyBinRequiredCounter0X0 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Number of available partialy bin request to 050 conveyor
      si_PartialyBinRequiredCounter1X0 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Number of available partialy bin request to 050 conveyor
      si_040DestinationA { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 040 RAT A destination value
      si_040DestinationB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 040 RAT B destination value
      si_040DestinationC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 040 RAT C destination value
      si_040DestinationD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 040 RAT D destination value
      si_140DestinationA { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 140 RAT A destination value
      si_140DestinationB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 140 RAT B destination value
      si_140DestinationC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 140 RAT C destination value
      si_140DestinationD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 140 RAT D destination value
      si_240DestinationA { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 240 RAT A destination value
      si_240DestinationB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 240 RAT B destination value
      si_240DestinationC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 240 RAT C destination value
      si_240DestinationD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 240 RAT D destination value
      sx_NoOperationInProgress { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // No transfer active
      sx_Enable0X0In { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Enable 030 infeed
      sx_Enable1X0In { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Enable 130 infeed
      sx_Enable2X0In { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Enable 230 infeed
      si_SendTo0X0 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send to 050 active
      si_SendTo1X0 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send to 150 active
      si_SendTo2X0 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send to 250 active
      sx_Hold130 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Hold 130 conveyor active
      sx_Hold030 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Hold 030 conveyor active
      sx_Hold020 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Hold 020 conveyor active
      sx_Hold120 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Hold 120 conveyor active
      sx_Hold230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Hold 230 conveyor active
      sx_Hold220 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Hold 220 conveyor active
      si_ReqestNewEmptyBin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_ReqestNewPartialBin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_LastGIN010 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_LastGIN110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      sR_TRIG_EmptyBinReceived {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_PartialBinReceived {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_PartialBinReceived_1 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_PartialBinReceived_2 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_PartialBinReceived_3 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_PartialBinReceived_4 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_PartialBinReceived_5 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_PartialBinReceived_6 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_PartialBinReceived_7 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_PartialBinReceived_8 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_PartialBinReceived_9 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_PartialBinReceived_10 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_PartialBinReceived_11 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_PartialBinReceived_12 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_PartialBinReceived_13 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_PartialBinReceived_14 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_PartialBinReceived_15 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_PartialBinReceived_16 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_PartialBinReceived_17 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_PartialBinReceived_18 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_PartialBinReceived_19 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_PartialBinReceived_20 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_PartialBinReceived_21 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_PartialBinReceived_22 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_PartialBinReceived_23 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_PartialBinReceived_24 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_PartialBinReceived_25 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_PartialBinReceived_26 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_PartialBinReceived_27 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_PartialBinReceived_28 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_PartialBinReceived_29 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_PartialBinReceived_30 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_InicializeWS {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sF_TRIG_StationDeactivated {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;
      sx_Counter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      sx_StartClearing { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_Hold080 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_ReleaseBinHoldLeft { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_ReleaseBinHoldRight { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sFB_TimerOnOffDelayReceiveBin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      si_BinReleaseDistanceLeft { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_BinReleaseDistanceRight { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      sx_Hold050 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_Hold060 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_Hold070 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_Hold150 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_Hold160 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_Hold170 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_Hold180 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_BinReleaseLeft { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_BinReleaseRight { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sFB_TimerOnOffDelay210 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sFB_TimerOnOffDelay220 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sFB_TimerOnOffDelay230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sx_LastReleaseLeft { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_LastReleaseRight { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_Clear050 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_Clear060 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_Clear070 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_Clear150 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_Clear160 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_Clear170 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_TEMP 
      tUDT_DummyInterface : "UDT_ConveyorInterface";   // Dummy interface structure
      tUDT_DummyVFDStatistics : "UDT_VfdStatistics";   // Dummy statistics structure
      tUDT_dummyHandshake : "UDT_ConveyorHandshake";   // Dummy handshake structure
      tUDT_FifoStatusEmpty : "UDT_FifoStatus";
      tUDT_FifoStatusPartial : "UDT_FifoStatus";
      tUDT_DummyBladeStop : "UDT_ValveInterface";
      tx_Enable : Bool;   // Enable bit
      tx_Error : Bool;
      tx_Warning : Bool;
      ts_Barcode : String;
      ti_NumberOfBinInQueue : Int;
      tx_ArraySize : Int;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	12/02/2023  | 4.0       | K.Pokorski    | First Release TIA 17.5
	08/06/2023  | 4.1       | S.Nieswiec    | New RAT, MCO, Displacement
	*)
	
	REGION Station flow control
	    
	    REGION Timeout
	        
	        #sFB_OperationTimeout(iudi_OnDelayTime := #iqUDT_Configuration.GlobalConfig.OperationTimeout,
	                              ix_SignalToDelay := NOT #sx_NoOperationInProgress
	                              AND #iqUDT_WorkstationCommonStatus."030".AutoON
	                              AND #iqUDT_WorkstationCommonStatus."130".AutoON
	                              AND #iqUDT_WorkstationCommonStatus."230".AutoON
	                              AND #iqUDT_WorkstationCommonStatus."040".AutoON
	                              AND #iqUDT_WorkstationCommonStatus."041".AutoON
	                              AND #iqUDT_WorkstationCommonStatus."140".AutoON
	                              AND #iqUDT_WorkstationCommonStatus."141".AutoON
	                              AND #iqUDT_WorkstationCommonStatus."240".AutoON
	                              AND #iqUDT_WorkstationCommonStatus."241".AutoON
	                              AND #iqUDT_WorkstationCommonStatus."050".AutoON
	                              AND #iqUDT_WorkstationCommonStatus."150".AutoON
	                              AND #iqUDT_WorkstationCommonStatus."250".AutoON);
	        
	    END_REGION
	    
	    REGION Request bin to workstation
	        // If new request from outside is received incerase counter. Counter is stored until parcel is send to proper destination. After inccreasing counter, reset request. 
	        // Request 1 mean empty bin is required. Request 2 mean partialy full bin is required
	        
	        IF #iqi_Request030 = 1 THEN
	            
	            #si_EmptyBinRequiredCounter0X0 += 1;
	            #iqi_Request030 := 0;
	            
	        ELSIF #iqi_Request030 = 2 THEN
	            
	            #si_PartialyBinRequiredCounter0X0 += 1;
	            #iqi_Request030 := 0;
	            
	        END_IF;
	        
	        IF #iqi_Request130 = 1 THEN
	            
	            #si_EmptyBinRequiredCounter1X0 += 1;
	            #iqi_Request130 := 0;
	            
	        ELSIF #iqi_Request130 = 2 THEN
	            
	            #si_PartialyBinRequiredCounter1X0 += 1;
	            #iqi_Request130 := 0;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Send Bin form 0X0
	        
	        // When no operation is proceed check if any operation is required. If yes then send bin with destination and start sending procedure. 
	        
	        IF #sx_NoOperationInProgress AND NOT #iqUDT_WorkstationStatus."030".PEC_EoS.PEC THEN
	            
	            IF #iqUDT_WorkstationStatus."050".PEC_EoS.PEC AND #si_EmptyBinRequiredCounter0X0 >= 1 AND #iqUDT_Configuration.GlobalConfig.LeftStationAvailable AND #ix_StationActive THEN
	                
	                #sx_Enable0X0In := TRUE;
	                
	                #si_040DestinationA := 1;
	                #si_040DestinationB := 0;
	                #si_040DestinationC := 0;
	                #si_040DestinationD := 0;
	                
	                #si_140DestinationA := 0;
	                #si_140DestinationB := 0;
	                #si_140DestinationC := 0;
	                #si_140DestinationD := 0;
	                
	                #si_240DestinationA := 0;
	                #si_240DestinationB := 0;
	                #si_240DestinationC := 0;
	                #si_240DestinationD := 0;
	                
	                #sx_Hold030 := FALSE;
	                #sx_Hold130 := TRUE;
	                #sx_Hold020 := TRUE;
	                
	                #sx_NoOperationInProgress := FALSE;
	                #si_EmptyBinRequiredCounter0X0 -= 1;
	                #si_SendTo0X0 := TRUE;
	                
	                #si_ReqestNewEmptyBin += 1;
	                
	            ELSIF #iqUDT_WorkstationStatus."150".PEC_EoS.PEC AND #si_EmptyBinRequiredCounter1X0 >= 1 AND #iqUDT_Configuration.GlobalConfig.RightStationAvailable AND #ix_StationActive THEN
	                
	                #sx_Enable0X0In := TRUE;
	                
	                #si_040DestinationA := 2;
	                #si_040DestinationB := 0;
	                #si_040DestinationC := 0;
	                #si_040DestinationD := 0;
	                
	                #si_140DestinationA := 0;
	                #si_140DestinationB := 0;
	                #si_140DestinationC := 2;
	                #si_140DestinationD := 0;
	                
	                #si_240DestinationA := 0;
	                #si_240DestinationB := 0;
	                #si_240DestinationC := 0;
	                #si_240DestinationD := 2;
	                
	                #sx_Hold030 := FALSE;
	                #sx_Hold130 := TRUE;
	                #sx_Hold020 := TRUE;
	                
	                #sx_NoOperationInProgress := FALSE;
	                #si_EmptyBinRequiredCounter1X0 -= 1;
	                #si_SendTo1X0 := True;
	                
	                #si_ReqestNewEmptyBin += 1;
	                
	            END_IF;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Send Bin form 1X0
	        
	        // When no operation is proceed check if any operation is required. If yes then send bin with destination and start sending procedure. 
	        IF #sx_NoOperationInProgress AND NOT #iqUDT_WorkstationStatus."130".PEC_EoS.PEC THEN
	            
	            IF #iqUDT_WorkstationStatus."050".PEC_EoS.PEC AND #si_PartialyBinRequiredCounter0X0 >= 1 AND #iqUDT_Configuration.GlobalConfig.LeftStationAvailable AND #ix_StationActive THEN
	                
	                #sx_Enable1X0In := TRUE;
	                
	                #si_040DestinationA := 0;
	                #si_040DestinationB := 0;
	                #si_040DestinationC := 0;
	                #si_040DestinationD := 1;
	                
	                #si_140DestinationA := 1;
	                #si_140DestinationB := 0;
	                #si_140DestinationC := 0;
	                #si_140DestinationD := 0;
	                
	                #si_240DestinationA := 0;
	                #si_240DestinationB := 0;
	                #si_240DestinationC := 1;
	                #si_240DestinationD := 0;
	                
	                #sx_Hold130 := FALSE;
	                #sx_Hold030 := TRUE;
	                #sx_Hold120 := TRUE;
	                
	                #sx_NoOperationInProgress := FALSE;
	                #si_PartialyBinRequiredCounter0X0 -= 1;
	                #si_SendTo0X0 := TRUE;
	                
	                #si_ReqestNewPartialBin += 1;
	                
	            ELSIF #iqUDT_WorkstationStatus."150".PEC_EoS.PEC AND #si_PartialyBinRequiredCounter1X0 >= 1 AND #iqUDT_Configuration.GlobalConfig.RightStationAvailable AND #ix_StationActive THEN
	                
	                #sx_Enable1X0In := TRUE;
	                #si_040DestinationA := 0;
	                #si_040DestinationB := 0;
	                #si_040DestinationC := 0;
	                #si_040DestinationD := 0;
	                
	                #si_140DestinationA := 2;
	                #si_140DestinationB := 0;
	                #si_140DestinationC := 0;
	                #si_140DestinationD := 0;
	                
	                #si_240DestinationA := 0;
	                #si_240DestinationB := 0;
	                #si_240DestinationC := 0;
	                #si_240DestinationD := 0;
	                
	                
	                #sx_Hold130 := FALSE;
	                #sx_Hold030 := TRUE;
	                #sx_Hold120 := TRUE;
	                
	                #sx_NoOperationInProgress := FALSE;
	                #si_PartialyBinRequiredCounter1X0 -= 1;
	                #si_SendTo1X0 := TRUE;
	                
	                #si_ReqestNewPartialBin += 1;
	                
	            END_IF;
	            
	        END_IF;
	        
	        
	        
	    END_REGION
	    
	    REGION Send Bin form 2X0
	        
	        // When no operation is proceed check if any operation is required. If yes then send bin with destination and start sending procedure. 
	        
	        IF #sx_NoOperationInProgress AND NOT #iqUDT_WorkstationStatus."230".PEC_EoS.PEC AND #iqUDT_WorkstationStatus."250".PEC_EoS.PEC AND #ix_StationActive THEN
	            
	            
	            #sx_Enable2X0In := TRUE;
	            
	            
	            #si_040DestinationA := 0;
	            #si_040DestinationB := 0;
	            #si_040DestinationC := 0;
	            #si_040DestinationD := 0;
	            
	            #si_140DestinationA := 0;
	            #si_140DestinationB := 0;
	            #si_140DestinationC := 0;
	            #si_140DestinationD := 0;
	            
	            #si_240DestinationA := 3;
	            #si_240DestinationB := 0;
	            #si_240DestinationC := 0;
	            #si_240DestinationD := 0;
	            
	            
	            //  #sx_Hold130 := TRUE;
	            //   #sx_Hold030 := TRUE;
	            #sx_Hold230 := FALSE;
	            #sx_Hold220 := TRUE;
	            
	            
	            #sx_NoOperationInProgress := FALSE;
	            #si_SendTo2X0 := TRUE;
	            
	        END_IF;
	        
	        
	        
	    END_REGION
	    
	    REGION Send bin to outfeed from work place
	        #sFB_TimerOnOffDelay210(iudi_OnDelayTime := 4000,
	                                ix_SignalToDelay := #iqUDT_WorkstationStatus."210".PEC_EoS.PEC);
	        #sFB_TimerOnOffDelay220(iudi_OnDelayTime := 4000,
	                                ix_SignalToDelay := #iqUDT_WorkstationStatus."220".PEC_EoS.PEC);
	        #sFB_TimerOnOffDelay230(iudi_OnDelayTime := 4000,
	                                ix_SignalToDelay := #iqUDT_WorkstationStatus."230".PEC_EoS.PEC);
	        
	        IF NOT #sx_LastReleaseLeft
	            OR (NOT #iqx_ReleaseBin150
	            AND NOT #iqx_ReleaseBin160
	            AND NOT #iqx_ReleaseBin170)
	        THEN
	            IF (#iqx_ReleaseBin050
	                OR #iqx_ReleaseBin060
	                OR #iqx_ReleaseBin070)
	                AND NOT #sx_BinReleaseLeft
	                AND NOT #sx_BinReleaseRight
	                AND #sFB_TimerOnOffDelay210.qx_DelayedSignal
	                AND #sFB_TimerOnOffDelay220.qx_DelayedSignal
	                AND #sFB_TimerOnOffDelay230.qx_DelayedSignal
	            THEN
	                #sx_BinReleaseLeft := TRUE;
	                #sx_LastReleaseLeft := TRUE;
	                
	                IF #iqx_ReleaseBin050 THEN
	                    #sx_Clear050 := TRUE;
	                    #iqx_ReleaseBin050 := FALSE;
	                    #tx_ArraySize := "FC_GetNrOfArrayEl"(#sa_TrackingArray_050);
	                    FILL_BLK(IN := 0,
	                             COUNT := INT_TO_ULINT(#tx_ArraySize),
	                             OUT => #sa_TrackingArray_050[0]);
	                END_IF;
	                
	                IF #iqx_ReleaseBin060 THEN
	                    #sx_Clear060 := TRUE;
	                    #iqx_ReleaseBin060 := FALSE;
	                    #tx_ArraySize := "FC_GetNrOfArrayEl"(#sa_TrackingArray_060);
	                    FILL_BLK(IN := 0,
	                             COUNT := INT_TO_ULINT(#tx_ArraySize),
	                             OUT => #sa_TrackingArray_060[0]);
	                END_IF;
	                
	                IF #iqx_ReleaseBin070 THEN
	                    #sx_Clear070 := TRUE;
	                    #iqx_ReleaseBin070 := FALSE;
	                    #tx_ArraySize := "FC_GetNrOfArrayEl"(#sa_TrackingArray_070);
	                    FILL_BLK(IN := 0,
	                             COUNT := INT_TO_ULINT(#tx_ArraySize),
	                             OUT => #sa_TrackingArray_070[0]);
	                END_IF;
	            END_IF;
	            
	        END_IF;
	        
	        IF (#iqx_ReleaseBin150
	            OR #iqx_ReleaseBin160
	            OR #iqx_ReleaseBin170)
	            AND NOT #sx_BinReleaseLeft
	            AND NOT #sx_BinReleaseRight
	            AND #sFB_TimerOnOffDelay210.qx_DelayedSignal
	            AND #sFB_TimerOnOffDelay220.qx_DelayedSignal
	            AND #sFB_TimerOnOffDelay230.qx_DelayedSignal
	            
	        THEN
	            #sx_BinReleaseRight := TRUE;
	            #sx_LastReleaseLeft := FALSE;
	            
	            IF #iqx_ReleaseBin150 THEN
	                #sx_Clear150 := TRUE;
	                #iqx_ReleaseBin150 := FALSE;
	                #tx_ArraySize := "FC_GetNrOfArrayEl"(#sa_TrackingArray_150);
	                FILL_BLK(IN := 0,
	                         COUNT := INT_TO_ULINT(#tx_ArraySize),
	                         OUT => #sa_TrackingArray_150[0]);
	            END_IF;
	            
	            IF #iqx_ReleaseBin160 THEN
	                #sx_Clear160 := TRUE;
	                #iqx_ReleaseBin160 := FALSE;
	                #tx_ArraySize := "FC_GetNrOfArrayEl"(#sa_TrackingArray_160);
	                FILL_BLK(IN := 0,
	                         COUNT := INT_TO_ULINT(#tx_ArraySize),
	                         OUT => #sa_TrackingArray_160[0]);
	            END_IF;
	            
	            IF #iqx_ReleaseBin170 THEN
	                #sx_Clear170 := TRUE;
	                #iqx_ReleaseBin170 := FALSE;
	                #tx_ArraySize := "FC_GetNrOfArrayEl"(#sa_TrackingArray_170);
	                FILL_BLK(IN := 0,
	                         COUNT := INT_TO_ULINT(#tx_ArraySize),
	                         OUT => #sa_TrackingArray_170[0]);
	            END_IF;
	            
	            
	        END_IF;
	        
	        //Send from left station
	        IF #sx_BinReleaseLeft AND #iqUDT_WorkstationStatus."210".PEC_EoS.PEC
	            AND #iqUDT_WorkstationStatus."220".PEC_EoS.PEC
	            AND #iqUDT_WorkstationStatus."230".PEC_EoS.PEC
	        THEN
	            
	            #sx_Hold080 := FALSE;
	            #sx_ReleaseBinHoldLeft := TRUE;
	            #si_BinReleaseDistanceLeft := #iqUDT_Configuration.GlobalConfig.BinReleaseDistance;
	        END_IF;
	        IF NOT #sx_BinReleaseLeft AND NOT #sx_StartClearing THEN
	            #sx_Hold080 := true;
	        END_IF;
	        
	        
	        IF #sx_BinReleaseLeft
	            AND (NOT #iqUDT_WorkstationStatus."210".PEC_EoS.PEC OR NOT #sx_Clear070)
	            AND (NOT #iqUDT_WorkstationStatus."220".PEC_EoS.PEC OR NOT #sx_Clear060)
	            AND (NOT #iqUDT_WorkstationStatus."230".PEC_EoS.PEC OR NOT #sx_Clear050)
	        THEN
	            
	            #si_BinReleaseDistanceLeft -= ABS(#sUDT_Interface_080.Displacement);
	            
	            IF #si_BinReleaseDistanceLeft <= 0 THEN
	                
	                #sx_Hold080 := TRUE;
	                #sx_ReleaseBinHoldLeft := FALSE;
	                #sx_BinReleaseLeft := FALSE;
	                #sx_Clear050 := false;
	                #sx_Clear060 := false;
	                #sx_Clear070 := false;
	                #si_EmptyBinRequiredCounter0X0 := 2;
	                #si_PartialyBinRequiredCounter0X0 := 1;
	                
	                IF NOT #iqUDT_WorkstationStatus."050".PEC_EoS.PEC THEN
	                    IF #sa_TrackingArray_050[#iqUDT_Configuration."050".PEC_EoS.Distance / 10 - 2] > #iqUDT_Configuration.GlobalConfig.GINRangeStart
	                        AND #sa_TrackingArray_050[#iqUDT_Configuration."050".PEC_EoS.Distance / 10 - 2] < ((#iqUDT_Configuration.GlobalConfig.GINRangeStart + #iqUDT_Configuration.GlobalConfig.GINRangeEnd) / 2) THEN
	                        IF #si_EmptyBinRequiredCounter0X0 > 0 THEN
	                            #si_EmptyBinRequiredCounter0X0 -= 1;
	                        END_IF;
	                    ELSE
	                        
	                        IF #si_PartialyBinRequiredCounter0X0 > 0 THEN
	                            #si_PartialyBinRequiredCounter0X0 -= 1;
	                        ELSE
	                            IF #si_EmptyBinRequiredCounter0X0 > 0 THEN
	                                #si_EmptyBinRequiredCounter0X0 -= 1;
	                            END_IF;
	                            
	                            
	                        END_IF;
	                        
	                    END_IF;
	                    
	                    
	                END_IF;
	                IF NOT #iqUDT_WorkstationStatus."060".PEC_EoS.PEC THEN
	                    IF #sa_TrackingArray_060[#iqUDT_Configuration."060".PEC_EoS.Distance / 10 - 2] > #iqUDT_Configuration.GlobalConfig.GINRangeStart
	                        AND #sa_TrackingArray_060[#iqUDT_Configuration."060".PEC_EoS.Distance / 10 - 2] < ((#iqUDT_Configuration.GlobalConfig.GINRangeStart + #iqUDT_Configuration.GlobalConfig.GINRangeEnd) / 2) THEN
	                        IF #si_EmptyBinRequiredCounter0X0 > 0 THEN
	                            #si_EmptyBinRequiredCounter0X0 -= 1;
	                        END_IF;
	                    ELSE
	                        
	                        IF #si_PartialyBinRequiredCounter0X0 > 0 THEN
	                            #si_PartialyBinRequiredCounter0X0 -= 1;
	                        ELSE
	                            IF #si_EmptyBinRequiredCounter0X0 > 0 THEN
	                                #si_EmptyBinRequiredCounter0X0 -= 1;
	                            END_IF;
	                            
	                            
	                        END_IF;
	                        
	                    END_IF;
	                    
	                    
	                END_IF;
	                IF NOT #iqUDT_WorkstationStatus."070".PEC_EoS.PEC THEN
	                    IF #sa_TrackingArray_070[#iqUDT_Configuration."070".PEC_EoS.Distance / 10 - 2] > #iqUDT_Configuration.GlobalConfig.GINRangeStart
	                        AND #sa_TrackingArray_070[#iqUDT_Configuration."070".PEC_EoS.Distance / 10 - 2] < ((#iqUDT_Configuration.GlobalConfig.GINRangeStart + #iqUDT_Configuration.GlobalConfig.GINRangeEnd) / 2) THEN
	                        IF #si_EmptyBinRequiredCounter0X0 > 0 THEN
	                            #si_EmptyBinRequiredCounter0X0 -= 1;
	                        END_IF;
	                    ELSE
	                        
	                        IF #si_PartialyBinRequiredCounter0X0 > 0 THEN
	                            #si_PartialyBinRequiredCounter0X0 -= 1;
	                        ELSE
	                            IF #si_EmptyBinRequiredCounter0X0 > 0 THEN
	                                #si_EmptyBinRequiredCounter0X0 -= 1;
	                            END_IF;
	                            
	                            
	                        END_IF;
	                        
	                    END_IF;
	                    
	                    
	                END_IF;
	            END_IF;
	            
	        END_IF;
	        
	        
	        //Send from right station
	        IF #sx_BinReleaseRight AND #iqUDT_WorkstationStatus."210".PEC_EoS.PEC
	            AND #iqUDT_WorkstationStatus."220".PEC_EoS.PEC
	            AND #iqUDT_WorkstationStatus."230".PEC_EoS.PEC
	        THEN
	            
	            #sx_Hold180 := FALSE;
	            #sx_ReleaseBinHoldRight := TRUE;
	            #si_BinReleaseDistanceRight := #iqUDT_Configuration.GlobalConfig.BinReleaseDistance;
	        END_IF;
	        IF NOT #sx_BinReleaseRight AND NOT #sx_StartClearing THEN
	            #sx_Hold180 := true;
	        END_IF;
	        
	        
	        IF #sx_BinReleaseRight
	            AND (NOT #iqUDT_WorkstationStatus."210".PEC_EoS.PEC OR NOT #sx_Clear170)
	            AND (NOT #iqUDT_WorkstationStatus."220".PEC_EoS.PEC OR NOT #sx_Clear160)
	            AND (NOT #iqUDT_WorkstationStatus."230".PEC_EoS.PEC OR NOT #sx_Clear150)
	        THEN
	            
	            #si_BinReleaseDistanceRight -= ABS(#sUDT_Interface_180.Displacement);
	            
	            IF #si_BinReleaseDistanceRight <= 0 THEN
	                
	                #sx_Hold180 := TRUE;
	                #sx_ReleaseBinHoldRight := FALSE;
	                #sx_BinReleaseRight := FALSE;
	                #sx_Clear150 := false;
	                #sx_Clear160 := false;
	                #sx_Clear170 := false;
	                #si_EmptyBinRequiredCounter1X0 := 2;
	                #si_PartialyBinRequiredCounter1X0 := 1;
	                
	                IF NOT #iqUDT_WorkstationStatus."150".PEC_EoS.PEC THEN
	                    IF #sa_TrackingArray_150[#iqUDT_Configuration."150".PEC_EoS.Distance / 10 - 2] > #iqUDT_Configuration.GlobalConfig.GINRangeStart
	                        AND #sa_TrackingArray_150[#iqUDT_Configuration."150".PEC_EoS.Distance / 10 - 2] < ((#iqUDT_Configuration.GlobalConfig.GINRangeStart + #iqUDT_Configuration.GlobalConfig.GINRangeEnd) / 2) THEN
	                        IF #si_EmptyBinRequiredCounter1X0 > 0 THEN
	                            #si_EmptyBinRequiredCounter1X0 -= 1;
	                        END_IF;
	                    ELSE
	                        
	                        IF #si_PartialyBinRequiredCounter1X0 > 0 THEN
	                            #si_PartialyBinRequiredCounter1X0 -= 1;
	                        ELSE
	                            IF #si_EmptyBinRequiredCounter1X0 > 0 THEN
	                                #si_EmptyBinRequiredCounter1X0 -= 1;
	                            END_IF;
	                            
	                            
	                        END_IF;
	                        
	                    END_IF;
	                    
	                    
	                END_IF;
	                IF NOT #iqUDT_WorkstationStatus."160".PEC_EoS.PEC THEN
	                    IF #sa_TrackingArray_160[#iqUDT_Configuration."160".PEC_EoS.Distance / 10 - 2] > #iqUDT_Configuration.GlobalConfig.GINRangeStart
	                        AND #sa_TrackingArray_160[#iqUDT_Configuration."160".PEC_EoS.Distance / 10 - 2] < ((#iqUDT_Configuration.GlobalConfig.GINRangeStart + #iqUDT_Configuration.GlobalConfig.GINRangeEnd) / 2) THEN
	                        IF #si_EmptyBinRequiredCounter1X0 > 0 THEN
	                            #si_EmptyBinRequiredCounter1X0 -= 1;
	                        END_IF;
	                    ELSE
	                        
	                        IF #si_PartialyBinRequiredCounter1X0 > 0 THEN
	                            #si_PartialyBinRequiredCounter1X0 -= 1;
	                        ELSE
	                            IF #si_EmptyBinRequiredCounter1X0 > 0 THEN
	                                #si_EmptyBinRequiredCounter1X0 -= 1;
	                            END_IF;
	                            
	                            
	                        END_IF;
	                        
	                    END_IF;
	                    
	                    
	                END_IF;
	                IF NOT #iqUDT_WorkstationStatus."170".PEC_EoS.PEC THEN
	                    IF #sa_TrackingArray_170[#iqUDT_Configuration."170".PEC_EoS.Distance / 10 - 2] > #iqUDT_Configuration.GlobalConfig.GINRangeStart
	                        AND #sa_TrackingArray_170[#iqUDT_Configuration."170".PEC_EoS.Distance / 10 - 2] < ((#iqUDT_Configuration.GlobalConfig.GINRangeStart + #iqUDT_Configuration.GlobalConfig.GINRangeEnd) / 2) THEN
	                        IF #si_EmptyBinRequiredCounter1X0 > 0 THEN
	                            #si_EmptyBinRequiredCounter1X0 -= 1;
	                        END_IF;
	                    ELSE
	                        
	                        IF #si_PartialyBinRequiredCounter1X0 > 0 THEN
	                            #si_PartialyBinRequiredCounter1X0 -= 1;
	                        ELSE
	                            IF #si_EmptyBinRequiredCounter1X0 > 0 THEN
	                                #si_EmptyBinRequiredCounter1X0 -= 1;
	                            END_IF;
	                            
	                            
	                        END_IF;
	                        
	                    END_IF;
	                    
	                    
	                END_IF;
	            END_IF;
	            
	        END_IF;
	        
	        
	        //     //Send from right station
	        //     IF #sx_BinReleaseRight AND #iqUDT_WorkstationStatus."210".PEC_EoS.PEC
	        //         AND #iqUDT_WorkstationStatus."220".PEC_EoS.PEC
	        //         AND #iqUDT_WorkstationStatus."230".PEC_EoS.PEC
	        //     THEN
	        
	        //         #sx_Hold180 := FALSE;
	        //         #sx_ReleaseBinHoldRight := TRUE;
	        //         #sx_Hold170 := TRUE;
	        //         #si_BinReleaseDistanceRight := #iUDT_Configuration.GlobalConfig.BinReleaseDistance;
	        //     END_IF;
	        //     IF NOT #sx_BinReleaseRight THEN
	        //         #sx_Hold180 := true;
	        //     END_IF;
	        
	        
	        //     IF #sx_BinReleaseRight
	        //         AND (NOT #iqUDT_WorkstationStatus."210".PEC_EoS.PEC
	        //         OR NOT #iqUDT_WorkstationStatus."220".PEC_EoS.PEC
	        //         OR NOT #iqUDT_WorkstationStatus."230".PEC_EoS.PEC)
	        //     THEN
	        
	        //         #si_BinReleaseDistanceRight -= ABS(#sUDT_Interface_180.Displacement);
	        
	        //         IF #si_BinReleaseDistanceRight <= 0 THEN
	        
	        //             #sx_Hold180 := TRUE;
	        //             #sx_ReleaseBinHoldRight := FALSE;
	        //             #sx_Hold170 := FALSE;
	        //             #sx_BinReleaseRight := FALSE;
	        
	        //         END_IF;
	        //     END_IF;
	        // END_IF;
	        
	    END_REGION
	    
	    
	    REGION Clearing sequence when workstation is deativated
	        
	        #sF_TRIG_StationDeactivated(CLK := #ix_StationActive);
	        
	        
	        
	        IF #sF_TRIG_StationDeactivated.Q THEN
	            
	            #sx_Enable1X0In := TRUE;
	            #sx_Enable0X0In := TRUE;
	            #sx_Enable2X0In := TRUE;
	            #si_040DestinationA := 2;
	            #si_040DestinationB := 0;
	            #si_040DestinationC := 0;
	            #si_040DestinationD := 0;
	            
	            #si_140DestinationA := 1;
	            #si_140DestinationB := 0;
	            #si_140DestinationC := 0;
	            #si_140DestinationD := 0;
	            
	            #si_240DestinationA := 3;
	            #si_240DestinationB := 0;
	            #si_240DestinationC := 3;
	            #si_240DestinationD := 3;
	            
	            
	            #sx_Hold130 := FALSE;
	            #sx_Hold030 := FALSE;
	            #sx_Hold120 := FALSE;
	            #sx_Hold020 := FALSE;
	            #sx_Hold220 := FALSE;
	            #sx_Hold230 := FALSE;
	            #sx_Hold080 := FALSE;
	            #sx_Hold180 := FALSE;
	            #sx_StartClearing := TRUE;
	            #sx_NoOperationInProgress := FALSE;
	            
	        END_IF;
	        
	        
	    END_REGION
	    
	    REGION Finish operation
	        
	        #sF_TRIG_ParcelArrived0X0(CLK := #iqUDT_WorkstationStatus."050".PEC_EoS.PEC);
	        #sF_TRIG_ParcelArrived1X0(CLK := #iqUDT_WorkstationStatus."150".PEC_EoS.PEC);
	        #sF_TRIG_ParcelArrived2X0(CLK := #iqUDT_WorkstationStatus."250".PEC_EoS.PEC);
	        
	        // Check if operation if finished. If yes then set operation in progress bit 
	        IF #si_SendTo0X0 AND #sF_TRIG_ParcelArrived0X0.Q OR #sFB_OperationTimeout.qx_DelayedSignal THEN
	            
	            #si_SendTo0X0 := FALSE;
	            
	        END_IF;
	        
	        
	        IF #si_SendTo1X0 AND #sF_TRIG_ParcelArrived1X0.Q OR #sFB_OperationTimeout.qx_DelayedSignal THEN
	            
	            #si_SendTo1X0 := FALSE;
	            
	        END_IF;
	        
	        IF #si_SendTo2X0 AND #sF_TRIG_ParcelArrived2X0.Q OR #sFB_OperationTimeout.qx_DelayedSignal THEN
	            
	            #si_SendTo2X0 := FALSE;
	            
	        END_IF;
	        
	        
	        IF NOT #si_SendTo0X0 AND NOT #si_SendTo1X0 AND NOT #si_SendTo2X0 AND NOT #sx_StartClearing
	            AND #sUDT_Interface_040.ActualSpeed = 0
	            AND #sUDT_Interface_041.ActualSpeed = 0
	            AND #sUDT_Interface_140.ActualSpeed = 0
	            AND #sUDT_Interface_141.ActualSpeed = 0
	            AND #sUDT_Interface_240.ActualSpeed = 0
	            AND #sUDT_Interface_241.ActualSpeed = 0
	        THEN
	            
	            #sx_NoOperationInProgress := TRUE;
	            #si_040DestinationA := 0;
	            #si_040DestinationB := 0;
	            #si_040DestinationC := 0;
	            #si_040DestinationD := 0;
	            
	            #si_140DestinationA := 0;
	            #si_140DestinationB := 0;
	            #si_140DestinationC := 0;
	            #si_140DestinationD := 0;
	            
	            #si_240DestinationA := 0;
	            #si_240DestinationB := 0;
	            #si_240DestinationC := 0;
	            #si_240DestinationD := 0;
	            
	            #sx_Hold030 := FALSE;
	            #sx_Hold130 := FALSE;
	            #sx_Hold020 := FALSE;
	            #sx_Hold120 := FALSE;
	            #sx_Hold230 := FALSE;
	            #sx_Hold220 := FALSE;
	            
	            #sx_Enable0X0In := FALSE;
	            #sx_Enable1X0In := FALSE;
	            #sx_Enable2X0In := FALSE;
	            
	        END_IF;
	        
	        
	    END_REGION
	    
	    
	    
	    REGION Workstation inicializaction
	        
	        #sR_TRIG_InicializeWS(CLK := #ix_StationActive);
	        
	        IF #sR_TRIG_InicializeWS.Q THEN
	            
	            #sx_StartClearing := FALSE;
	            IF #iqUDT_WorkstationStatus."010".PEC_EoS.PEC THEN
	                
	                #si_ReqestNewEmptyBin += 1;
	                
	            END_IF;
	            
	            IF #iqUDT_WorkstationStatus."020".PEC_EoS.PEC THEN
	                
	                #si_ReqestNewEmptyBin += 1;
	                
	            END_IF;
	            
	            IF #iqUDT_WorkstationStatus."030".PEC_EoS.PEC THEN
	                
	                #si_ReqestNewEmptyBin += 1;
	                
	            END_IF;
	            
	            IF #iqUDT_WorkstationStatus."110".PEC_EoS.PEC THEN
	                
	                #si_ReqestNewPartialBin += 1;
	                
	            END_IF;
	            
	            IF #iqUDT_WorkstationStatus."120".PEC_EoS.PEC THEN
	                
	                #si_ReqestNewPartialBin += 1;
	                
	            END_IF;
	            
	            IF #iqUDT_WorkstationStatus."130".PEC_EoS.PEC THEN
	                
	                #si_ReqestNewPartialBin += 1;
	                
	            END_IF;
	            
	            #si_EmptyBinRequiredCounter0X0 := 2;
	            #si_EmptyBinRequiredCounter1X0 := 2;
	            #si_PartialyBinRequiredCounter0X0 := 1;
	            #si_PartialyBinRequiredCounter1X0 := 1;
	            
	            REGION 050 Workposition inicialization
	                IF NOT #iqUDT_WorkstationStatus."050".PEC_EoS.PEC THEN
	                    IF #sa_TrackingArray_050[#iqUDT_Configuration."050".PEC_EoS.Distance / 10 - 2] > #iqUDT_Configuration.GlobalConfig.GINRangeStart
	                        AND #sa_TrackingArray_050[#iqUDT_Configuration."050".PEC_EoS.Distance / 10 - 2] < ((#iqUDT_Configuration.GlobalConfig.GINRangeStart + #iqUDT_Configuration.GlobalConfig.GINRangeEnd) / 2) THEN
	                        IF #si_EmptyBinRequiredCounter0X0 > 0 THEN
	                            #si_EmptyBinRequiredCounter0X0 -= 1;
	                        END_IF;
	                    ELSE
	                        
	                        IF #si_PartialyBinRequiredCounter0X0 > 0 THEN
	                            #si_PartialyBinRequiredCounter0X0 -= 1;
	                        ELSE
	                            IF #si_EmptyBinRequiredCounter0X0 > 0 THEN
	                                #si_EmptyBinRequiredCounter0X0 -= 1;
	                            END_IF;
	                            
	                            
	                        END_IF;
	                        
	                    END_IF;
	                    
	                    
	                END_IF;
	            END_REGION
	            
	            REGION 060 Workposition inicialization
	                IF NOT #iqUDT_WorkstationStatus."060".PEC_EoS.PEC THEN
	                    IF #sa_TrackingArray_060[#iqUDT_Configuration."060".PEC_EoS.Distance / 10 - 2] > #iqUDT_Configuration.GlobalConfig.GINRangeStart
	                        AND #sa_TrackingArray_060[#iqUDT_Configuration."060".PEC_EoS.Distance / 10 - 2] < ((#iqUDT_Configuration.GlobalConfig.GINRangeStart + #iqUDT_Configuration.GlobalConfig.GINRangeEnd) / 2) THEN
	                        IF #si_EmptyBinRequiredCounter0X0 > 0 THEN
	                            #si_EmptyBinRequiredCounter0X0 -= 1;
	                        END_IF;
	                    ELSE
	                        
	                        IF #si_PartialyBinRequiredCounter0X0 > 0 THEN
	                            #si_PartialyBinRequiredCounter0X0 -= 1;
	                        ELSE
	                            IF #si_EmptyBinRequiredCounter0X0 > 0 THEN
	                                #si_EmptyBinRequiredCounter0X0 -= 1;
	                            END_IF;
	                            
	                            
	                        END_IF;
	                        
	                    END_IF;
	                    
	                    
	                END_IF;
	            END_REGION
	            
	            REGION 070 Workposition inicialization
	                IF NOT #iqUDT_WorkstationStatus."070".PEC_EoS.PEC THEN
	                    IF #sa_TrackingArray_070[#iqUDT_Configuration."070".PEC_EoS.Distance / 10 - 2] > #iqUDT_Configuration.GlobalConfig.GINRangeStart
	                        AND #sa_TrackingArray_070[#iqUDT_Configuration."070".PEC_EoS.Distance / 10 - 2] < ((#iqUDT_Configuration.GlobalConfig.GINRangeStart + #iqUDT_Configuration.GlobalConfig.GINRangeEnd) / 2) THEN
	                        IF #si_EmptyBinRequiredCounter0X0 > 0 THEN
	                            #si_EmptyBinRequiredCounter0X0 -= 1;
	                        END_IF;
	                    ELSE
	                        
	                        IF #si_PartialyBinRequiredCounter0X0 > 0 THEN
	                            #si_PartialyBinRequiredCounter0X0 -= 1;
	                        ELSE
	                            IF #si_EmptyBinRequiredCounter0X0 > 0 THEN
	                                #si_EmptyBinRequiredCounter0X0 -= 1;
	                            END_IF;
	                            
	                            
	                        END_IF;
	                        
	                    END_IF;
	                    
	                    
	                END_IF;
	            END_REGION
	            
	            REGION 150 Workposition inicialization
	                IF NOT #iqUDT_WorkstationStatus."150".PEC_EoS.PEC
	                THEN
	                    IF (#sa_TrackingArray_150[#iqUDT_Configuration."150".PEC_EoS.Distance / 10 / 10 - 2] > #iqUDT_Configuration.GlobalConfig.GINRangeStart
	                        AND #sa_TrackingArray_150[#iqUDT_Configuration."150".PEC_EoS.Distance / 10 - 2] < ((#iqUDT_Configuration.GlobalConfig.GINRangeStart + #iqUDT_Configuration.GlobalConfig.GINRangeEnd) / 2))
	                    THEN
	                        IF #si_EmptyBinRequiredCounter1X0 > 0 THEN
	                            #si_EmptyBinRequiredCounter1X0 -= 1;
	                        END_IF;
	                    ELSE
	                        
	                        IF #si_PartialyBinRequiredCounter1X0 > 0 THEN
	                            #si_PartialyBinRequiredCounter1X0 -= 1;
	                        ELSE
	                            IF #si_EmptyBinRequiredCounter1X0 > 0 THEN
	                                #si_EmptyBinRequiredCounter1X0 -= 1;
	                            END_IF;
	                            
	                            
	                        END_IF;
	                        
	                    END_IF;
	                    
	                    
	                END_IF;
	            END_REGION
	            
	            REGION 160 Workposition inicialization
	                IF NOT #iqUDT_WorkstationStatus."160".PEC_EoS.PEC THEN
	                    IF #sa_TrackingArray_160[#iqUDT_Configuration."160".PEC_EoS.Distance / 10 - 2] > #iqUDT_Configuration.GlobalConfig.GINRangeStart
	                        AND #sa_TrackingArray_160[#iqUDT_Configuration."160".PEC_EoS.Distance / 10 - 2] < ((#iqUDT_Configuration.GlobalConfig.GINRangeStart + #iqUDT_Configuration.GlobalConfig.GINRangeEnd) / 2) THEN
	                        IF #si_EmptyBinRequiredCounter1X0 > 0 THEN
	                            #si_EmptyBinRequiredCounter1X0 -= 1;
	                        END_IF;
	                    ELSE
	                        
	                        IF #si_PartialyBinRequiredCounter1X0 > 0 THEN
	                            #si_PartialyBinRequiredCounter1X0 -= 1;
	                        ELSE
	                            IF #si_EmptyBinRequiredCounter1X0 > 0 THEN
	                                #si_EmptyBinRequiredCounter1X0 -= 1;
	                            END_IF;
	                            
	                            
	                        END_IF;
	                        
	                    END_IF;
	                    
	                    
	                END_IF;
	            END_REGION
	            
	            REGION 170 Workposition inicialization
	                IF NOT #iqUDT_WorkstationStatus."170".PEC_EoS.PEC THEN
	                    IF #sa_TrackingArray_170[#iqUDT_Configuration."170".PEC_EoS.Distance / 10 - 2] > #iqUDT_Configuration.GlobalConfig.GINRangeStart
	                        AND #sa_TrackingArray_170[#iqUDT_Configuration."170".PEC_EoS.Distance / 10 - 2] < ((#iqUDT_Configuration.GlobalConfig.GINRangeStart + #iqUDT_Configuration.GlobalConfig.GINRangeEnd) / 2) THEN
	                        IF #si_EmptyBinRequiredCounter1X0 > 0 THEN
	                            #si_EmptyBinRequiredCounter1X0 -= 1;
	                        END_IF;
	                    ELSE
	                        
	                        IF #si_PartialyBinRequiredCounter1X0 > 0 THEN
	                            #si_PartialyBinRequiredCounter1X0 -= 1;
	                        ELSE
	                            IF #si_EmptyBinRequiredCounter1X0 > 0 THEN
	                                #si_EmptyBinRequiredCounter1X0 -= 1;
	                            END_IF;
	                            
	                            
	                        END_IF;
	                        
	                    END_IF;
	                    
	                    
	                END_IF;
	            END_REGION
	            
	        END_IF;
	        
	    END_REGION
	    
	    
	    REGION Request empty bin to buffer
	        
	        IF #si_ReqestNewEmptyBin > 0 THEN
	            
	            #ti_NumberOfBinInQueue := 0;
	            IF #iqUDT_EmptyBuffer.BufferState1.BinRequest THEN
	                #ti_NumberOfBinInQueue += 1;
	            END_IF;
	            IF #iqUDT_EmptyBuffer.BufferState2.BinRequest THEN
	                #ti_NumberOfBinInQueue += 1;
	            END_IF;
	            IF #iqUDT_EmptyBuffer.BufferState3.BinRequest THEN
	                #ti_NumberOfBinInQueue += 1;
	            END_IF;
	            IF NOT #iqUDT_WorkstationStatus."010".PEC_EoS.PEC THEN
	                #ti_NumberOfBinInQueue += 1;
	            END_IF;
	            IF NOT #iqUDT_WorkstationStatus."020".PEC_EoS.PEC THEN
	                #ti_NumberOfBinInQueue += 1;
	            END_IF;
	            IF NOT #iqUDT_WorkstationStatus."030".PEC_EoS.PEC THEN
	                #ti_NumberOfBinInQueue += 1;
	            END_IF;
	            
	            IF #ti_NumberOfBinInQueue < 3 THEN
	                
	                "FC_Fifo"(ic_Mode := 'S',
	                          qUDT_Status => #tUDT_FifoStatusEmpty,
	                          qx_Error => #tx_Error,
	                          qx_Warning => #tx_Warning,
	                          iqv_Data := #iqUDT_Configuration.GlobalConfig.DestinationEmpty,
	                          iqUDT_FifoHeader := #iqa_EmptyFifoHeader,
	                          iqv_DataBuffer := #iqa_EmptyFifoData);
	                
	                IF NOT #tUDT_FifoStatusEmpty.FifoFull THEN
	                    
	                    "FC_Fifo"(ic_Mode := 'W',
	                              qUDT_Status => #tUDT_FifoStatusEmpty,
	                              qx_Error => #tx_Error,
	                              qx_Warning => #tx_Warning,
	                              iqv_Data := #iqUDT_Configuration.GlobalConfig.DestinationEmpty,
	                              iqUDT_FifoHeader := #iqa_EmptyFifoHeader,
	                              iqv_DataBuffer := #iqa_EmptyFifoData);
	                    
	                    IF NOT #iqUDT_EmptyBuffer.BufferState1.BinRequest THEN
	                        #iqUDT_EmptyBuffer.BufferState1.BinRequest := TRUE;
	                    ELSIF NOT #iqUDT_EmptyBuffer.BufferState2.BinRequest THEN
	                        #iqUDT_EmptyBuffer.BufferState2.BinRequest := TRUE;
	                    ELSE
	                        #iqUDT_EmptyBuffer.BufferState3.BinRequest := TRUE;
	                    END_IF;
	                    
	                    #si_ReqestNewEmptyBin -= 1;
	                    #iqUDT_EmptyBuffer.Destination := #iqUDT_Configuration.GlobalConfig.DestinationEmpty;
	                END_IF;
	                
	                
	                
	            END_IF;
	            
	        END_IF;
	        
	        
	    END_REGION
	    
	    REGION Request partial bin to buffer
	        
	        IF #si_ReqestNewPartialBin > 0 THEN
	            
	            #ti_NumberOfBinInQueue := 0;
	            IF #iqUDT_PartialBuffer.BufferState1.BinRequest THEN
	                #ti_NumberOfBinInQueue += 1;
	            END_IF;
	            IF #iqUDT_PartialBuffer.BufferState2.BinRequest THEN
	                #ti_NumberOfBinInQueue += 1;
	            END_IF;
	            IF #iqUDT_PartialBuffer.BufferState3.BinRequest THEN
	                #ti_NumberOfBinInQueue += 1;
	            END_IF;
	            IF NOT #iqUDT_WorkstationStatus."110".PEC_EoS.PEC THEN
	                #ti_NumberOfBinInQueue += 1;
	            END_IF;
	            IF NOT #iqUDT_WorkstationStatus."120".PEC_EoS.PEC THEN
	                #ti_NumberOfBinInQueue += 1;
	            END_IF;
	            IF NOT #iqUDT_WorkstationStatus."130".PEC_EoS.PEC THEN
	                #ti_NumberOfBinInQueue += 1;
	            END_IF;
	            
	            IF #ti_NumberOfBinInQueue < 3 THEN
	                
	                
	                
	                "FC_Fifo"(ic_Mode := 'S',
	                          qUDT_Status => #tUDT_FifoStatusPartial,
	                          qx_Error => #tx_Error,
	                          qx_Warning => #tx_Warning,
	                          iqv_Data := #iqUDT_Configuration.GlobalConfig.DestinationPartialy,
	                          iqUDT_FifoHeader := #iqa_PartialFifoHeader,
	                          iqv_DataBuffer := #iqa_PartialFifoData);
	                
	                IF NOT #tUDT_FifoStatusPartial.FifoFull THEN
	                    
	                    "FC_Fifo"(ic_Mode := 'W',
	                              qUDT_Status => #tUDT_FifoStatusPartial,
	                              qx_Error => #tx_Error,
	                              qx_Warning => #tx_Warning,
	                              iqv_Data := #iqUDT_Configuration.GlobalConfig.DestinationPartialy,
	                              iqUDT_FifoHeader := #iqa_PartialFifoHeader,
	                              iqv_DataBuffer := #iqa_PartialFifoData);
	                    
	                    IF NOT #iqUDT_PartialBuffer.BufferState1.BinRequest THEN
	                        #iqUDT_PartialBuffer.BufferState1.BinRequest := TRUE;
	                    ELSIF NOT #iqUDT_PartialBuffer.BufferState2.BinRequest THEN
	                        #iqUDT_PartialBuffer.BufferState2.BinRequest := TRUE;
	                    ELSE
	                        #iqUDT_PartialBuffer.BufferState3.BinRequest := TRUE;
	                    END_IF;
	                    
	                    #si_ReqestNewPartialBin -= 1;
	                    #iqUDT_PartialBuffer.Destination := #iqUDT_Configuration.GlobalConfig.DestinationPartialy;
	                    
	                END_IF;
	                
	            END_IF;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Ordered bin monitoring 
	        
	        IF "DB_Memory".OS_2sec THEN
	            
	            IF #iqUDT_EmptyBuffer.BufferState1.BinSend THEN
	                #iqUDT_EmptyBuffer.BufferState1.WaintingTime += 2;
	                
	                IF #iqUDT_EmptyBuffer.BufferState1.WaintingTime > #iqUDT_Configuration.GlobalConfig.BinOrderTimeout THEN
	                    
	                    #iqUDT_EmptyBuffer.BufferState1 := #iqUDT_EmptyBuffer.BufferState2;
	                    #iqUDT_EmptyBuffer.BufferState2 := #iqUDT_EmptyBuffer.BufferState3;
	                    
	                    #iqUDT_EmptyBuffer.BufferState3.BinSend := FALSE;
	                    #iqUDT_EmptyBuffer.BufferState3.BinRequest := FALSE;
	                    #iqUDT_EmptyBuffer.BufferState3.UpcomingBarcode := '';
	                    #iqUDT_EmptyBuffer.BufferState3.WaintingTime := 0;
	                    
	                    
	                    #ti_NumberOfBinInQueue := 0;
	                    IF #iqUDT_EmptyBuffer.BufferState1.BinRequest THEN
	                        #ti_NumberOfBinInQueue += 1;
	                    END_IF;
	                    IF #iqUDT_EmptyBuffer.BufferState2.BinRequest THEN
	                        #ti_NumberOfBinInQueue += 1;
	                    END_IF;
	                    IF NOT #iqUDT_WorkstationStatus."010".PEC_EoS.PEC THEN
	                        #ti_NumberOfBinInQueue += 1;
	                    END_IF;
	                    IF NOT #iqUDT_WorkstationStatus."020".PEC_EoS.PEC THEN
	                        #ti_NumberOfBinInQueue += 1;
	                    END_IF;
	                    IF NOT #iqUDT_WorkstationStatus."030".PEC_EoS.PEC THEN
	                        #ti_NumberOfBinInQueue += 1;
	                    END_IF;
	                    
	                    IF #ti_NumberOfBinInQueue < 3 THEN
	                        #si_ReqestNewEmptyBin += 1;
	                    END_IF;
	                    
	                    
	                END_IF;
	                
	            END_IF;
	            
	            IF #iqUDT_EmptyBuffer.BufferState2.BinSend THEN
	                #iqUDT_EmptyBuffer.BufferState2.WaintingTime += 2;
	                
	                IF #iqUDT_EmptyBuffer.BufferState2.WaintingTime > #iqUDT_Configuration.GlobalConfig.BinOrderTimeout THEN
	                    
	                    #iqUDT_EmptyBuffer.BufferState2 := #iqUDT_EmptyBuffer.BufferState3;
	                    
	                    #iqUDT_EmptyBuffer.BufferState3.BinSend := FALSE;
	                    #iqUDT_EmptyBuffer.BufferState3.BinRequest := FALSE;
	                    #iqUDT_EmptyBuffer.BufferState3.UpcomingBarcode := '';
	                    #iqUDT_EmptyBuffer.BufferState3.WaintingTime := 0;
	                    
	                    #si_ReqestNewEmptyBin += 1;
	                    
	                END_IF;
	                
	            END_IF;
	            
	            IF #iqUDT_EmptyBuffer.BufferState3.BinSend THEN
	                #iqUDT_EmptyBuffer.BufferState3.WaintingTime += 2;
	                
	                IF #iqUDT_EmptyBuffer.BufferState3.WaintingTime > #iqUDT_Configuration.GlobalConfig.BinOrderTimeout THEN
	                    
	                    #iqUDT_EmptyBuffer.BufferState3.BinSend := FALSE;
	                    #iqUDT_EmptyBuffer.BufferState3.BinRequest := FALSE;
	                    #iqUDT_EmptyBuffer.BufferState3.UpcomingBarcode := '';
	                    #iqUDT_EmptyBuffer.BufferState3.WaintingTime := 0;
	                    #si_ReqestNewEmptyBin += 1;
	                    
	                END_IF;
	                
	            END_IF;
	            
	            IF #iqUDT_PartialBuffer.BufferState1.BinSend THEN
	                #iqUDT_PartialBuffer.BufferState1.WaintingTime += 2;
	                
	                IF #iqUDT_PartialBuffer.BufferState1.WaintingTime > #iqUDT_Configuration.GlobalConfig.BinOrderTimeout THEN
	                    
	                    #iqUDT_PartialBuffer.BufferState1 := #iqUDT_PartialBuffer.BufferState2;
	                    #iqUDT_PartialBuffer.BufferState2 := #iqUDT_PartialBuffer.BufferState3;
	                    #iqUDT_PartialBuffer.BufferState3.BinSend := FALSE;
	                    #iqUDT_PartialBuffer.BufferState3.BinRequest := FALSE;
	                    #iqUDT_PartialBuffer.BufferState3.UpcomingBarcode := '';
	                    #iqUDT_PartialBuffer.BufferState3.WaintingTime := 0;
	                    
	                    
	                    #ti_NumberOfBinInQueue := 0;
	                    IF #iqUDT_PartialBuffer.BufferState1.BinRequest THEN
	                        #ti_NumberOfBinInQueue += 1;
	                    END_IF;
	                    IF #iqUDT_PartialBuffer.BufferState2.BinRequest THEN
	                        #ti_NumberOfBinInQueue += 1;
	                    END_IF;
	                    IF NOT #iqUDT_WorkstationStatus."110".PEC_EoS.PEC THEN
	                        #ti_NumberOfBinInQueue += 1;
	                    END_IF;
	                    IF NOT #iqUDT_WorkstationStatus."120".PEC_EoS.PEC THEN
	                        #ti_NumberOfBinInQueue += 1;
	                    END_IF;
	                    IF NOT #iqUDT_WorkstationStatus."130".PEC_EoS.PEC THEN
	                        #ti_NumberOfBinInQueue += 1;
	                    END_IF;
	                    
	                    IF #ti_NumberOfBinInQueue < 3 THEN
	                        #si_ReqestNewPartialBin += 1;
	                    END_IF;
	                    
	                END_IF;
	                
	            END_IF;
	            
	            
	            IF #iqUDT_PartialBuffer.BufferState2.BinSend THEN
	                #iqUDT_PartialBuffer.BufferState2.WaintingTime += 2;
	                IF #iqUDT_PartialBuffer.BufferState2.WaintingTime > #iqUDT_Configuration.GlobalConfig.BinOrderTimeout THEN
	                    
	                    #iqUDT_PartialBuffer.BufferState2 := #iqUDT_PartialBuffer.BufferState3;
	                    
	                    #iqUDT_PartialBuffer.BufferState3.BinSend := FALSE;
	                    #iqUDT_PartialBuffer.BufferState3.BinRequest := FALSE;
	                    #iqUDT_PartialBuffer.BufferState3.UpcomingBarcode := '';
	                    #iqUDT_PartialBuffer.BufferState3.WaintingTime := 0;
	                    
	                    #si_ReqestNewPartialBin += 1;
	                    
	                END_IF;
	                
	            END_IF;
	            
	            IF #iqUDT_PartialBuffer.BufferState3.BinSend THEN
	                #iqUDT_PartialBuffer.BufferState3.WaintingTime += 2;
	                
	                IF #iqUDT_PartialBuffer.BufferState3.WaintingTime > #iqUDT_Configuration.GlobalConfig.BinOrderTimeout THEN
	                    
	                    #iqUDT_PartialBuffer.BufferState3.BinSend := FALSE;
	                    #iqUDT_PartialBuffer.BufferState3.BinRequest := FALSE;
	                    #iqUDT_PartialBuffer.BufferState3.UpcomingBarcode := '';
	                    #iqUDT_PartialBuffer.BufferState3.WaintingTime := 0;
	                    #si_ReqestNewPartialBin += 1;
	                    
	                END_IF;
	            END_IF;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Ordered product confirmation
	        
	        REGION Empty
	            
	            #sR_TRIG_EmptyBinReceived(CLK := #sa_TrackingArray_010[#iqUDT_Configuration."010".PEC_EoS.Distance / 10 - 1] <> 0);
	            
	            IF #sR_TRIG_EmptyBinReceived.Q THEN
	                
	                IF #iqUDT_EmptyBuffer.BufferState1.BinSend AND "DB_GIN".GIN[#sa_TrackingArray_010[#iqUDT_Configuration."010".PEC_EoS.Distance / 10 - 1]].WES.Barcode = #iqUDT_EmptyBuffer.BufferState1.UpcomingBarcode THEN
	                    
	                    #iqUDT_EmptyBuffer.BufferState1 := #iqUDT_EmptyBuffer.BufferState2;
	                    #iqUDT_EmptyBuffer.BufferState2 := #iqUDT_EmptyBuffer.BufferState3;
	                    
	                    #iqUDT_EmptyBuffer.BufferState3.BinSend := FALSE;
	                    #iqUDT_EmptyBuffer.BufferState3.BinRequest := FALSE;
	                    #iqUDT_EmptyBuffer.BufferState3.UpcomingBarcode := '';
	                    #iqUDT_EmptyBuffer.BufferState3.WaintingTime := 0;
	                END_IF;
	                
	                
	                IF #iqUDT_EmptyBuffer.BufferState2.BinSend AND "DB_GIN".GIN[#sa_TrackingArray_010[#iqUDT_Configuration."010".PEC_EoS.Distance / 10 - 1]].WES.Barcode = #iqUDT_EmptyBuffer.BufferState2.UpcomingBarcode THEN
	                    
	                    #iqUDT_EmptyBuffer.BufferState2 := #iqUDT_EmptyBuffer.BufferState3;
	                    
	                    #iqUDT_EmptyBuffer.BufferState3.BinSend := FALSE;
	                    #iqUDT_EmptyBuffer.BufferState3.BinRequest := FALSE;
	                    #iqUDT_EmptyBuffer.BufferState3.UpcomingBarcode := '';
	                    #iqUDT_EmptyBuffer.BufferState3.WaintingTime := 0;
	                END_IF;
	                
	                
	                IF #iqUDT_EmptyBuffer.BufferState3.BinSend AND "DB_GIN".GIN[#sa_TrackingArray_010[#iqUDT_Configuration."010".PEC_EoS.Distance / 10 - 1]].WES.Barcode = #iqUDT_EmptyBuffer.BufferState3.UpcomingBarcode THEN
	                    
	                    #iqUDT_EmptyBuffer.BufferState3.BinSend := FALSE;
	                    #iqUDT_EmptyBuffer.BufferState3.BinRequest := FALSE;
	                    #iqUDT_EmptyBuffer.BufferState3.UpcomingBarcode := '';
	                    #iqUDT_EmptyBuffer.BufferState3.WaintingTime := 0;
	                END_IF;
	                
	            END_IF;
	            
	        END_REGION
	        
	        REGION Partialy
	            
	            
	            #sR_TRIG_PartialBinReceived(CLK := #sa_TrackingArray_110[#iqUDT_Configuration."110".PEC_EoS.Distance / 10 - 1] <> 0);
	            
	            IF #sR_TRIG_PartialBinReceived.Q THEN
	                
	                IF #iqUDT_PartialBuffer.BufferState1.BinSend AND "DB_GIN".GIN[#sa_TrackingArray_110[#iqUDT_Configuration."110".PEC_EoS.Distance / 10 - 1]].WES.Barcode = #iqUDT_PartialBuffer.BufferState1.UpcomingBarcode THEN
	                    
	                    #iqUDT_PartialBuffer.BufferState1 := #iqUDT_PartialBuffer.BufferState2;
	                    #iqUDT_PartialBuffer.BufferState2 := #iqUDT_PartialBuffer.BufferState3;
	                    
	                    #iqUDT_PartialBuffer.BufferState3.BinSend := FALSE;
	                    #iqUDT_PartialBuffer.BufferState3.BinRequest := FALSE;
	                    #iqUDT_PartialBuffer.BufferState3.UpcomingBarcode := '';
	                    #iqUDT_PartialBuffer.BufferState3.WaintingTime := 0;
	                END_IF;
	                
	                
	                IF #iqUDT_PartialBuffer.BufferState2.BinSend AND "DB_GIN".GIN[#sa_TrackingArray_110[#iqUDT_Configuration."110".PEC_EoS.Distance / 10 - 1]].WES.Barcode = #iqUDT_PartialBuffer.BufferState2.UpcomingBarcode THEN
	                    
	                    #iqUDT_PartialBuffer.BufferState2 := #iqUDT_PartialBuffer.BufferState3;
	                    
	                    #iqUDT_PartialBuffer.BufferState3.BinSend := FALSE;
	                    #iqUDT_PartialBuffer.BufferState3.BinRequest := FALSE;
	                    #iqUDT_PartialBuffer.BufferState3.UpcomingBarcode := '';
	                    #iqUDT_PartialBuffer.BufferState3.WaintingTime := 0;
	                END_IF;
	                
	                
	                IF #iqUDT_PartialBuffer.BufferState3.BinSend AND "DB_GIN".GIN[#sa_TrackingArray_110[#iqUDT_Configuration."110".PEC_EoS.Distance / 10 - 1]].WES.Barcode = #iqUDT_PartialBuffer.BufferState3.UpcomingBarcode THEN
	                    
	                    #iqUDT_PartialBuffer.BufferState3.BinSend := FALSE;
	                    #iqUDT_PartialBuffer.BufferState3.BinRequest := FALSE;
	                    #iqUDT_PartialBuffer.BufferState3.UpcomingBarcode := '';
	                    #iqUDT_PartialBuffer.BufferState3.WaintingTime := 0;
	                END_IF;
	                
	            END_IF;
	            
	        END_REGION
	        
	        
	    END_REGION
	    
	END_REGION
	
	REGION 010
	    
	    REGION Change GIN range
	        
	        #sR_TRIG_NewParcel010(CLK := #iqUDT_HandshakeUpstream010.GIN <> 0);
	        
	        IF #sR_TRIG_NewParcel010.Q THEN
	            
	            #si_LastGIN010 += 1;
	            
	            IF #si_LastGIN010 < #iqUDT_Configuration.GlobalConfig.GINRangeStart
	                OR #si_LastGIN010 > ((#iqUDT_Configuration.GlobalConfig.GINRangeStart + #iqUDT_Configuration.GlobalConfig.GINRangeEnd) / 2)
	            THEN
	                #si_LastGIN010 := #iqUDT_Configuration.GlobalConfig.GINRangeStart;
	            END_IF;
	            #ts_Barcode := "DB_GIN".GIN[#iqUDT_HandshakeUpstream010.GIN].WES.Barcode;
	            #iqUDT_HandshakeUpstream010.GIN := #si_LastGIN010;
	            "DB_GIN".GIN[#iqUDT_HandshakeUpstream010.GIN] := "DB_GINDefault".GIN[#iqUDT_Configuration."010".PEC_EoS.DefaultGIN];
	            "DB_GIN".GIN[#iqUDT_HandshakeUpstream010.GIN].WES.Barcode := #ts_Barcode;
	        END_IF;
	        
	    END_REGION
	    
	    REGION Displacement
	        #sFB_Displacement010(#sUDT_Interface_010);
	    END_REGION
	    
	    REGION Tracking
	        
	        #sFB_Tracking_010(iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."010".Conveyor.Common,
	                          iqa_TrackingData := #sa_TrackingArray_010,
	                          iqUDT_ConveyorInterface := #sUDT_Interface_010,
	                          iqUDT_HandshakeUp := #iqUDT_HandshakeUpstream010,
	                          iqUDT_Handshake := #sUDT_Handshake_010);
	        
	    END_REGION
	    
	    REGION EoS
	        
	        #sFB_PECUpdate_010(iUDT_PECUpdateConfiguration := #iqUDT_Configuration."010".PEC_EoS,
	                           iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."010".Conveyor.Common,
	                           ix_PEC := #iUDT_MotorInput010.AllSensorPortInputs.LeftSensor,
	                           ix_TeachingMode := FALSE,
	                           qUDT_Status => #iqUDT_WorkstationStatus."010".PEC_EoS,
	                           iqUDT_ConveyorInterface := #sUDT_Interface_010,
	                           iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                           iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                           iqUDT_Statistics := #iqUDT_WorkstationStatistics."010".PEC_EoS,
	                           iqa_TrackingData := #sa_TrackingArray_010,
	                           iqa_FifoData := "DB_FIFOLostGIN".Data);
	        
	    END_REGION
	    
	    REGION Conveyor
	        
	        #sFB_Conveyor_010(iUDT_ConveyorConfiguration := #iqUDT_Configuration."010".Conveyor,
	                          idi_PECEoSDistance := #iqUDT_Configuration."010".PEC_EoS.Distance,
	                          idi_PECBoSDistance := 0,
	                          ii_ExternalSpeed := 0,
	                          ix_SafetyOk := #ix_SafetyOk,
	                          ix_24vOk := #ix_24vOk,
	                          ix_400vOk := #ix_400vOk,
	                          ix_HardwareOk := TRUE,
	                          ix_PECEoS := #iqUDT_WorkstationStatus."010".PEC_EoS.PEC,
	                          ix_PECBoS := TRUE,
	                          ix_ReverseDirection := FALSE,
	                          ix_ExternalRequestDieBack := (#sUDT_Interface_020.ActualSpeed = 0 AND NOT #iqUDT_WorkstationStatus."010".PEC_EoS.PEC),
	                          ix_ExternalRequestHold := FALSE,
	                          ix_ResetEnergySave := FALSE,
	                          qUDT_HMIStatus => #iqUDT_WorkstationStatus."010".Conveyor,
	                          qUDT_Status => #iqUDT_WorkstationCommonStatus."010",
	                          iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                          iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."010".Conveyor,
	                          iqUDT_ConveyorInterface := #sUDT_Interface_010,
	                          iqUDT_HandShakeUp := #iqUDT_HandshakeUpstream010,
	                          iqUDT_HandShake := #sUDT_Handshake_010,
	                          iqUDT_Statistics := #iqUDT_WorkstationStatistics."010".Conveyor);
	        
	        // #iqUDT_HandshakeUpstream010.RTR := #iqUDT_HandshakeUpstream010.RTR AND #iqUDT_WorkstationStatus."010".PEC_EoS.PEC;
	        
	    END_REGION
	    
	    REGION MCO
	        
	        #sFB_MCOConveyLinxAixController_010(iUDT_AixConfig := #iqUDT_Configuration."010".MCO_M01,
	                                            iUDT_AixInputsModule := #iUDT_MotorInput010,
	                                            ix_24vOk := #ix_24vOk,
	                                            ix_SimulationModeActive := "DB_Memory".Simulation,
	                                            ii_MotorPositionId := 1,
	                                            qUDT_HMIStatus => #iqUDT_WorkstationStatus."010".MCO_M01,
	                                            iqUDT_AixOutputsModule := #iqUDT_MotorOutput010,
	                                            iqUDT_ConveyorInterface := #sUDT_Interface_010,
	                                            iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."010".MCO_M01);
	    END_REGION
	    
	END_REGION
	
	REGION 020
	    
	    REGION Displacement
	        #sFB_Displacement020(#sUDT_Interface_020);
	    END_REGION
	    
	    REGION Tracking
	        
	        #sFB_Tracking_020(iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."020".Conveyor.Common,
	                          iqa_TrackingData := #sa_TrackingArray_020,
	                          iqUDT_ConveyorInterface := #sUDT_Interface_020,
	                          iqUDT_HandshakeUp := #sUDT_Handshake_010,
	                          iqUDT_Handshake := #sUDT_Handshake_020);
	        
	    END_REGION
	    
	    REGION EoS
	        
	        #sFB_PECUpdate_020(iUDT_PECUpdateConfiguration := #iqUDT_Configuration."020".PEC_EoS,
	                           iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."020".Conveyor.Common,
	                           ix_PEC := #iUDT_MotorInput010.AllSensorPortInputs.RightSensor,
	                           ix_TeachingMode := FALSE,
	                           qUDT_Status => #iqUDT_WorkstationStatus."020".PEC_EoS,
	                           iqUDT_ConveyorInterface := #sUDT_Interface_020,
	                           iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                           iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                           iqUDT_Statistics := #iqUDT_WorkstationStatistics."020".PEC_EoS,
	                           iqa_TrackingData := #sa_TrackingArray_020,
	                           iqa_FifoData := "DB_FIFOLostGIN".Data);
	        
	        
	        
	        
	    END_REGION
	    
	    REGION Conveyor
	        
	        #sFB_Conveyor_020(iUDT_ConveyorConfiguration := #iqUDT_Configuration."020".Conveyor,
	                          idi_PECEoSDistance := #iqUDT_Configuration."020".PEC_EoS.Distance,
	                          idi_PECBoSDistance := 0,
	                          ii_ExternalSpeed := 0,
	                          ix_SafetyOk := #ix_SafetyOk,
	                          ix_24vOk := #ix_24vOk,
	                          ix_400vOk := #ix_400vOk,
	                          ix_HardwareOk := TRUE,
	                          ix_PECEoS := #iqUDT_WorkstationStatus."020".PEC_EoS.PEC,
	                          ix_PECBoS := TRUE,
	                          ix_ReverseDirection := FALSE,
	                          ix_ExternalRequestDieBack := #sx_Hold020 OR (#sUDT_Interface_030.ActualSpeed = 0 AND NOT #iqUDT_WorkstationStatus."020".PEC_EoS.PEC),
	                          ix_ExternalRequestHold := FALSE,
	                          ix_ResetEnergySave := FALSE,
	                          qUDT_HMIStatus => #iqUDT_WorkstationStatus."020".Conveyor,
	                          qUDT_Status => #iqUDT_WorkstationCommonStatus."020",
	                          iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                          iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."020".Conveyor,
	                          iqUDT_ConveyorInterface := #sUDT_Interface_020,
	                          iqUDT_HandShakeUp := #sUDT_Handshake_010,
	                          iqUDT_HandShake := #sUDT_Handshake_020,
	                          iqUDT_Statistics := #iqUDT_WorkstationStatistics."020".Conveyor);
	        
	    END_REGION
	    
	    REGION MCO
	        
	        #sFB_MCOConveyLinxAixController_020(iUDT_AixConfig := #iqUDT_Configuration."020".MCO_M01,
	                                            iUDT_AixInputsModule := #iUDT_MotorInput010,
	                                            ix_24vOk := #ix_24vOk,
	                                            ix_SimulationModeActive := "DB_Memory".Simulation,
	                                            ii_MotorPositionId := 2,
	                                            qUDT_HMIStatus => #iqUDT_WorkstationStatus."020".MCO_M01,
	                                            iqUDT_AixOutputsModule := #iqUDT_MotorOutput010,
	                                            iqUDT_ConveyorInterface := #sUDT_Interface_020,
	                                            iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."020".MCO_M01);
	    END_REGION
	    
	END_REGION
	
	REGION 030
	    
	    REGION Displacement
	        #sFB_Displacement030(#sUDT_Interface_030);
	    END_REGION
	    
	    REGION Tracking
	        
	        #sFB_Tracking_030(iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."030".Conveyor.Common,
	                          iqa_TrackingData := #sa_TrackingArray_030,
	                          iqUDT_ConveyorInterface := #sUDT_Interface_030,
	                          iqUDT_HandshakeUp := #sUDT_Handshake_020,
	                          iqUDT_Handshake := #sUDT_Handshake_030);
	        
	    END_REGION
	    
	    REGION EoS
	        
	        #sFB_PECUpdate_030(iUDT_PECUpdateConfiguration := #iqUDT_Configuration."030".PEC_EoS,
	                           iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."030".Conveyor.Common,
	                           ix_PEC := #iUDT_MotorInput030.AllSensorPortInputs.LeftSensor,
	                           ix_TeachingMode := FALSE,
	                           qUDT_Status => #iqUDT_WorkstationStatus."030".PEC_EoS,
	                           iqUDT_ConveyorInterface := #sUDT_Interface_030,
	                           iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                           iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                           iqUDT_Statistics := #iqUDT_WorkstationStatistics."030".PEC_EoS,
	                           iqa_TrackingData := #sa_TrackingArray_030,
	                           iqa_FifoData := "DB_FIFOLostGIN".Data);
	        
	        
	        
	        
	    END_REGION
	    
	    REGION Conveyor
	        
	        #sUDT_Handshake_030.RTR := #sUDT_Handshake_030.RTR AND NOT #sx_Hold030 OR #iqUDT_WorkstationStatus."030".PEC_EoS.PEC;
	        
	        
	        #sFB_Conveyor_030(iUDT_ConveyorConfiguration := #iqUDT_Configuration."030".Conveyor,
	                          idi_PECEoSDistance := #iqUDT_Configuration."030".PEC_EoS.Distance,
	                          idi_PECBoSDistance := 0,
	                          ii_ExternalSpeed := 0,
	                          ix_SafetyOk := #ix_SafetyOk,
	                          ix_24vOk := #ix_24vOk,
	                          ix_400vOk := #ix_400vOk,
	                          ix_HardwareOk := TRUE,
	                          ix_PECEoS := #iqUDT_WorkstationStatus."030".PEC_EoS.PEC,
	                          ix_PECBoS := TRUE,
	                          ix_ReverseDirection := FALSE,
	                          ix_ExternalRequestDieBack := FALSE,
	                          ix_ExternalRequestHold := #sx_Hold030,
	                          ix_ResetEnergySave := FALSE,
	                          qUDT_HMIStatus => #iqUDT_WorkstationStatus."030".Conveyor,
	                          qUDT_Status => #iqUDT_WorkstationCommonStatus."030",
	                          iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                          iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."030".Conveyor,
	                          iqUDT_ConveyorInterface := #sUDT_Interface_030,
	                          iqUDT_HandShakeUp := #sUDT_Handshake_020,
	                          iqUDT_HandShake := #sUDT_Handshake_030,
	                          iqUDT_Statistics := #iqUDT_WorkstationStatistics."030".Conveyor);
	        
	    END_REGION
	    
	    REGION MCO
	        
	        #sFB_MCOConveyLinxAixController_030(iUDT_AixConfig := #iqUDT_Configuration."030".MCO_M01,
	                                            iUDT_AixInputsModule := #iUDT_MotorInput030,
	                                            ix_24vOk := #ix_24vOk,
	                                            ix_SimulationModeActive := "DB_Memory".Simulation,
	                                            ii_MotorPositionId := 1,
	                                            qUDT_HMIStatus => #iqUDT_WorkstationStatus."030".MCO_M01,
	                                            iqUDT_AixOutputsModule := #iqUDT_MotorOutput030,
	                                            iqUDT_ConveyorInterface := #sUDT_Interface_030,
	                                            iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."030".MCO_M01);
	    END_REGION
	    
	END_REGION
	
	REGION 040
	    
	    REGION Displacement
	        #sFB_Displacement040(#sUDT_Interface_040);
	    END_REGION
	    
	    REGION MCO
	        
	        #sFB_MCOConveyLinxAixController_040(iUDT_AixConfig := #iqUDT_Configuration."040".MCO_M01,
	                                            iUDT_AixInputsModule := #iUDT_MotorInput040,
	                                            ii_PositionSetpoint := #iqUDT_RATPositioning040.Lower.EndPosition,
	                                            ix_24vOk := #ix_24vOk,
	                                            ix_SimulationModeActive := "DB_Memory".Simulation,
	                                            ii_MotorPositionId := 1,
	                                            ix_StartPositioning := #iqUDT_RATPositioning040.Lower.Start,
	                                            ix_ResetPosition := #iqUDT_RATPositioning040.Lower.ResetPosition,
	                                            qUDT_HMIStatus => #iqUDT_WorkstationStatus."040".MCO_M01,
	                                            qx_Positioned => #iqUDT_RATPositioning040.Lower.Done,
	                                            iqUDT_AixOutputsModule := #iqUDT_MotorOutput040,
	                                            iqUDT_ConveyorInterface := #sUDT_Interface_040,
	                                            iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."040".MCO_M01);
	    END_REGION
	    
	    REGION BladeStopEoS
	        
	        IF #iqUDT_Configuration.GlobalConfig.LeftStationAvailable THEN
	            
	            #sFB_BladeStopEoS_040(iUDT_Configuration := #iqUDT_Configuration."040".BladeStopEoS,
	                                  ix_IsOpened := #ix_BladeStopisUp040,
	                                  ix_IsClosed := #ix_BladeStopisDown040,
	                                  ix_AirPressureOk := TRUE,
	                                  qx_Open => #qx_BladeStopControl040,
	                                  qUDT_HMIStatus => #iqUDT_WorkstationStatus."040".BladeStopEoS,
	                                  qUDT_Statistics => #iqUDT_WorkstationStatistics."040".BladeStopEoS,
	                                  iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                  iqUDT_HMICommand := #iqUDT_WorkstationCommands."040".BladeStopEoS,
	                                  iqUDT_Interface := #sUDT_Interface_040_BladeStopEoS);
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 041
	    
	    REGION Displacement
	        #sFB_Displacement041(#sUDT_Interface_041);
	    END_REGION
	    
	    REGION RAT
	        
	        #iqUDT_Configuration."041".RightAngledTransfer.BladeStopEoS := #iqUDT_Configuration.GlobalConfig.LeftStationAvailable;
	        
	        #sFB_RightAngledTransfer_041(iUDT_Configuration := #iqUDT_Configuration."041".RightAngledTransfer,
	                                     iUDT_LowerConveyorConfiguration := #iqUDT_Configuration."040".Conveyor,
	                                     iUDT_UpperConveyorConfiguration := #iqUDT_Configuration."041".Conveyor,
	                                     iUDT_PECConfiguration := #iqUDT_Configuration."040".PEC_EoS,
	                                     ii_DestinationA := #si_040DestinationA,
	                                     ii_DestinationB := #si_040DestinationB,
	                                     ii_DestinationC := #si_040DestinationC,
	                                     ii_DestinationD := #si_040DestinationD,
	                                     ix_HardwareOk := TRUE,
	                                     ix_400vOk := #ix_400vOk,
	                                     ix_24vOk := #ix_24vOk,
	                                     ix_SafetyOk := #ix_SafetyOk,
	                                     ix_AirPressureOk := #ix_AirPressureOk,
	                                     ix_SectionIsDown := #ix_SectionisDown041,
	                                     ix_SectionIsUp := #ix_SectionisUp041,
	                                     ix_ConveyorAAuto := #iqUDT_WorkstationCommonStatus."030".AutoON,
	                                     ix_ConveyorBAuto := #iqUDT_WorkstationCommonStatus."050".AutoON,
	                                     ix_ConveyorCAuto := FALSE,
	                                     ix_ConveyorDAuto := #iqUDT_WorkstationCommonStatus."241".AutoON,
	                                     ix_PEC := #iUDT_MotorInput040.AllSensorPortInputs.LeftSensor,
	                                     ix_ExternalReceiveRequestA := NOT #iqUDT_WorkstationStatus."030".PEC_EoS.PEC AND #sx_Enable0X0In,
	                                     ix_ExternalReceiveRequestB := false,
	                                     ix_ExternalReceiveRequestC := false,
	                                     ix_ExternalReceiveRequestD := #sFB_RightAngledTransfer_241.qx_ExternalSendRequestD,
	                                     ix_PECInfeedA := #iqUDT_WorkstationStatus."030".PEC_EoS.PEC,
	                                     ix_PECInfeedD := #iqUDT_WorkstationStatus."240".PEC_EoS.PEC,
	                                     qUDT_HMIRATStatus => #iqUDT_WorkstationStatus."041".RightAngledTransfer,
	                                     qUDT_HMIConveyorStatus => #iqUDT_WorkstationStatus."040".Conveyor,
	                                     qUDT_HMIPECStatus => #iqUDT_WorkstationStatus."040".PEC_EoS,
	                                     qUDT_RATStatus => #iqUDT_WorkstationCommonStatus."041",
	                                     qUDT_ConveyorStatus => #iqUDT_WorkstationCommonStatus."040",
	                                     qx_PopupControl => #qx_PopupControl041,
	                                     iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                     iqUDT_RATCommand := #iqUDT_WorkstationCommands."041".RightAngledTransfer,
	                                     iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."040".Conveyor,
	                                     iqUDT_RATStatistics := #iqUDT_WorkstationStatistics."041".RightAngledTransfer,
	                                     iqUDT_ConveyorStatistics := #iqUDT_WorkstationStatistics."040".Conveyor,
	                                     iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."040".PEC_EoS,
	                                     iqUDT_HandShakeConveyorA := #sUDT_Handshake_030,
	                                     iqUDT_HandShakeConveyorB := #sUDT_Handshake_040,
	                                     iqUDT_HandShakeConveyorC := #sUDT_HandshakeUp_041,
	                                     iqUDT_HandShakeConveyorD := #sUDT_Handshake_041,
	                                     iqUDT_LowerConveyorInterface := #sUDT_Interface_040,
	                                     iqUDT_UpperConveyorInterface := #sUDT_Interface_041,
	                                     iqUDT_RATPositioning := #iqUDT_RATPositioning040,
	                                     iqUDT_BladeStopEoSInterface := #sUDT_Interface_040_BladeStopEoS,
	                                     iqUDT_BladeStopBoSInterface := #tUDT_DummyBladeStop);
	        
	    END_REGION
	    
	    REGION MCO
	        
	        #sFB_MCOConveyLinxAixController_041(iUDT_AixConfig := #iqUDT_Configuration."041".MCO_M01,
	                                            iUDT_AixInputsModule := #iUDT_MotorInput040,
	                                            ii_PositionSetpoint := #iqUDT_RATPositioning040.Upper.EndPosition,
	                                            ix_24vOk := #ix_24vOk,
	                                            ix_SimulationModeActive := "DB_Memory".Simulation,
	                                            ii_MotorPositionId := 2,
	                                            ix_StartPositioning := #iqUDT_RATPositioning040.Upper.Start,
	                                            qUDT_HMIStatus => #iqUDT_WorkstationStatus."041".MCO_M01,
	                                            qx_Positioned => #iqUDT_RATPositioning040.Upper.Done,
	                                            iqUDT_AixOutputsModule := #iqUDT_MotorOutput040,
	                                            iqUDT_ConveyorInterface := #sUDT_Interface_041,
	                                            iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."041".MCO_M01);
	    END_REGION
	    
	END_REGION
	
	IF #iqUDT_Configuration.GlobalConfig.LeftStationAvailable THEN
	    
	    REGION 050
	        
	        REGION Displacement
	            #sFB_Displacement050(#sUDT_Interface_050);
	        END_REGION
	        
	        REGION Tracking
	            
	            #sFB_Tracking_050(iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."050".Conveyor.Common,
	                              iqa_TrackingData := #sa_TrackingArray_050,
	                              iqUDT_ConveyorInterface := #sUDT_Interface_050,
	                              iqUDT_HandshakeUp := #sUDT_Handshake_040,
	                              iqUDT_Handshake := #sUDT_Handshake_050);
	            
	        END_REGION
	        
	        REGION EoS
	            
	            #sFB_PECUpdate_050(iUDT_PECUpdateConfiguration := #iqUDT_Configuration."050".PEC_EoS,
	                               iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."050".Conveyor.Common,
	                               ix_PEC := NOT #iUDT_MotorInput050.AllSensorPortInputs.LeftSensor,
	                               ix_TeachingMode := FALSE,
	                               qUDT_Status => #iqUDT_WorkstationStatus."050".PEC_EoS,
	                               iqUDT_ConveyorInterface := #sUDT_Interface_050,
	                               iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                               iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                               iqUDT_Statistics := #iqUDT_WorkstationStatistics."050".PEC_EoS,
	                               iqa_TrackingData := #sa_TrackingArray_050,
	                               iqa_FifoData := "DB_FIFOLostGIN".Data);
	            
	        END_REGION
	        
	        REGION Conveyor
	            
	            //#sUDT_Handshake_050.RTR := TRUE;
	            
	            #sUDT_Handshake_050.RTR := (#iqUDT_WorkstationStatus."060".PEC_EoS.PEC AND #sUDT_Interface_060.ActualSpeed <> 0)
	            OR (#iqUDT_WorkstationStatus."050".PEC_EoS.PEC);
	            
	            #sFB_Conveyor_050(iUDT_ConveyorConfiguration := #iqUDT_Configuration."050".Conveyor,
	                              idi_PECEoSDistance := #iqUDT_Configuration."050".PEC_EoS.Distance,
	                              idi_PECBoSDistance := 0,
	                              ii_ExternalSpeed := 0,
	                              ix_SafetyOk := #ix_SafetyOk,
	                              ix_24vOk := #ix_24vOk,
	                              ix_400vOk := #ix_400vOk,
	                              ix_HardwareOk := TRUE,
	                              ix_PECEoS := #iqUDT_WorkstationStatus."050".PEC_EoS.PEC,
	                              ix_PECBoS := TRUE,
	                              ix_ReverseDirection := FALSE,
	                              ix_ExternalRequestDieBack := FALSE,
	                              ix_ExternalRequestHold := #sx_ReleaseBinHoldLeft,//NOT #tx_Enable,
	                              ix_ResetEnergySave := FALSE,
	                              qUDT_HMIStatus => #iqUDT_WorkstationStatus."050".Conveyor,
	                              qUDT_Status => #iqUDT_WorkstationCommonStatus."050",
	                              iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                              iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."050".Conveyor,
	                              iqUDT_ConveyorInterface := #sUDT_Interface_050,
	                              iqUDT_HandShakeUp := #sUDT_Handshake_040,
	                              iqUDT_HandShake := #sUDT_Handshake_050,
	                              iqUDT_Statistics := #iqUDT_WorkstationStatistics."050".Conveyor);
	            
	        END_REGION
	        
	        REGION MCO
	            
	            #sFB_MCOConveyLinxAixController_050(iUDT_AixConfig := #iqUDT_Configuration."050".MCO_M01,
	                                                iUDT_AixInputsModule := #iUDT_MotorInput050,
	                                                ix_24vOk := #ix_24vOk,
	                                                ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                ii_MotorPositionId := 1,
	                                                qUDT_HMIStatus => #iqUDT_WorkstationStatus."050".MCO_M01,
	                                                iqUDT_AixOutputsModule := #iqUDT_MotorOutput050,
	                                                iqUDT_ConveyorInterface := #sUDT_Interface_050,
	                                                iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."050".MCO_M01);
	        END_REGION
	        
	    END_REGION
	    
	    REGION 060
	        
	        REGION Displacement
	            #sFB_Displacement060(#sUDT_Interface_060);
	        END_REGION
	        
	        REGION Tracking
	            
	            #sFB_Tracking_060(iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."060".Conveyor.Common,
	                              iqa_TrackingData := #sa_TrackingArray_060,
	                              iqUDT_ConveyorInterface := #sUDT_Interface_060,
	                              iqUDT_HandshakeUp := #sUDT_Handshake_050,
	                              iqUDT_Handshake := #sUDT_Handshake_060);
	            
	        END_REGION
	        
	        REGION EoS
	            
	            #sFB_PECUpdate_060(iUDT_PECUpdateConfiguration := #iqUDT_Configuration."060".PEC_EoS,
	                               iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."060".Conveyor.Common,
	                               ix_PEC := NOT #iUDT_MotorInput050.AllSensorPortInputs.RightSensor,
	                               ix_TeachingMode := FALSE,
	                               qUDT_Status => #iqUDT_WorkstationStatus."060".PEC_EoS,
	                               iqUDT_ConveyorInterface := #sUDT_Interface_060,
	                               iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                               iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                               iqUDT_Statistics := #iqUDT_WorkstationStatistics."060".PEC_EoS,
	                               iqa_TrackingData := #sa_TrackingArray_060,
	                               iqa_FifoData := "DB_FIFOLostGIN".Data);
	            
	        END_REGION
	        
	        REGION Conveyor
	            
	            // #sUDT_Handshake_060.RTR := TRUE;
	            
	            #sUDT_Handshake_060.RTR := (#iqUDT_WorkstationStatus."070".PEC_EoS.PEC AND #sUDT_Interface_070.ActualSpeed <> 0)
	            OR (#iqUDT_WorkstationStatus."060".PEC_EoS.PEC);
	            
	            #sFB_Conveyor_060(iUDT_ConveyorConfiguration := #iqUDT_Configuration."060".Conveyor,
	                              idi_PECEoSDistance := #iqUDT_Configuration."060".PEC_EoS.Distance,
	                              idi_PECBoSDistance := 0,
	                              ii_ExternalSpeed := 0,
	                              ix_SafetyOk := #ix_SafetyOk,
	                              ix_24vOk := #ix_24vOk,
	                              ix_400vOk := #ix_400vOk,
	                              ix_HardwareOk := TRUE,
	                              ix_PECEoS := #iqUDT_WorkstationStatus."060".PEC_EoS.PEC,
	                              ix_PECBoS := TRUE,
	                              ix_ReverseDirection := FALSE,
	                              ix_ExternalRequestDieBack := FALSE,
	                              ix_ExternalRequestHold := #sx_ReleaseBinHoldLeft,//NOT #tx_Enable,//(NOT #iqUDT_WorkstationStatus."035"."036".PEC_EoS.PEC AND NOT #iqUDT_WorkstationStatus."030"."031".PEC_EoS.PEC) OR (#sUDT_Interface_036.ActualSpeed = 0 AND #iqUDT_WorkstationStatus."030"."031".PEC_EoS.PEC),
	                              ix_ResetEnergySave := FALSE,
	                              qUDT_HMIStatus => #iqUDT_WorkstationStatus."060".Conveyor,
	                              qUDT_Status => #iqUDT_WorkstationCommonStatus."060",
	                              iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                              iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."060".Conveyor,
	                              iqUDT_ConveyorInterface := #sUDT_Interface_060,
	                              iqUDT_HandShakeUp := #sUDT_Handshake_050,
	                              iqUDT_HandShake := #sUDT_Handshake_060,
	                              iqUDT_Statistics := #iqUDT_WorkstationStatistics."060".Conveyor);
	            
	        END_REGION
	        
	        REGION MCO
	            
	            #sFB_MCOConveyLinxAixController_060(iUDT_AixConfig := #iqUDT_Configuration."060".MCO_M01,
	                                                iUDT_AixInputsModule := #iUDT_MotorInput050,
	                                                ix_24vOk := #ix_24vOk,
	                                                ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                ii_MotorPositionId := 2,
	                                                qUDT_HMIStatus => #iqUDT_WorkstationStatus."060".MCO_M01,
	                                                iqUDT_AixOutputsModule := #iqUDT_MotorOutput050,
	                                                iqUDT_ConveyorInterface := #sUDT_Interface_060,
	                                                iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."060".MCO_M01);
	        END_REGION
	        
	    END_REGION
	    
	    REGION 070
	        
	        REGION Displacement
	            #sFB_Displacement070(#sUDT_Interface_070);
	        END_REGION
	        
	        REGION Tracking
	            
	            #sFB_Tracking_070(iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."070".Conveyor.Common,
	                              iqa_TrackingData := #sa_TrackingArray_070,
	                              iqUDT_ConveyorInterface := #sUDT_Interface_070,
	                              iqUDT_HandshakeUp := #sUDT_Handshake_060,
	                              iqUDT_Handshake := #sUDT_Handshake_070);
	            
	        END_REGION
	        
	        REGION EoS
	            
	            #sFB_PECUpdate_070(iUDT_PECUpdateConfiguration := #iqUDT_Configuration."070".PEC_EoS,
	                               iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."070".Conveyor.Common,
	                               ix_PEC := NOT #iUDT_MotorInput070.AllSensorPortInputs.LeftSensor,
	                               ix_TeachingMode := FALSE,
	                               qUDT_Status => #iqUDT_WorkstationStatus."070".PEC_EoS,
	                               iqUDT_ConveyorInterface := #sUDT_Interface_070,
	                               iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                               iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                               iqUDT_Statistics := #iqUDT_WorkstationStatistics."070".PEC_EoS,
	                               iqa_TrackingData := #sa_TrackingArray_070,
	                               iqa_FifoData := "DB_FIFOLostGIN".Data);
	            
	        END_REGION
	        
	        REGION Conveyor
	            
	            #sUDT_Handshake_070.RTR := #iqUDT_WorkstationStatus."070".PEC_EoS.PEC;
	            
	            #sFB_Conveyor_070(iUDT_ConveyorConfiguration := #iqUDT_Configuration."070".Conveyor,
	                              idi_PECEoSDistance := #iqUDT_Configuration."070".PEC_EoS.Distance,
	                              idi_PECBoSDistance := 0,
	                              ii_ExternalSpeed := 0,
	                              ix_SafetyOk := #ix_SafetyOk,
	                              ix_24vOk := #ix_24vOk,
	                              ix_400vOk := #ix_400vOk,
	                              ix_HardwareOk := TRUE,
	                              ix_PECEoS := #iqUDT_WorkstationStatus."070".PEC_EoS.PEC,
	                              ix_PECBoS := TRUE,
	                              ix_ReverseDirection := FALSE,
	                              ix_ExternalRequestDieBack := FALSE,
	                              ix_ExternalRequestHold := #sx_ReleaseBinHoldLeft,
	                              ix_ResetEnergySave := FALSE,
	                              qUDT_HMIStatus => #iqUDT_WorkstationStatus."070".Conveyor,
	                              qUDT_Status => #iqUDT_WorkstationCommonStatus."070",
	                              iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                              iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."070".Conveyor,
	                              iqUDT_ConveyorInterface := #sUDT_Interface_070,
	                              iqUDT_HandShakeUp := #sUDT_Handshake_060,
	                              iqUDT_HandShake := #sUDT_Handshake_070,
	                              iqUDT_Statistics := #iqUDT_WorkstationStatistics."070".Conveyor);
	            
	        END_REGION
	        
	        REGION MCO
	            
	            #sFB_MCOConveyLinxAixController_070(iUDT_AixConfig := #iqUDT_Configuration."070".MCO_M01,
	                                                iUDT_AixInputsModule := #iUDT_MotorInput070,
	                                                ix_24vOk := #ix_24vOk,
	                                                ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                ii_MotorPositionId := 1,
	                                                qUDT_HMIStatus => #iqUDT_WorkstationStatus."070".MCO_M01,
	                                                iqUDT_AixOutputsModule := #iqUDT_MotorOutput070,
	                                                iqUDT_ConveyorInterface := #sUDT_Interface_070,
	                                                iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."070".MCO_M01);
	        END_REGION
	        
	    END_REGION
	    
	END_IF;
	
	REGION 080
	    
	    REGION Displacement
	        #sFB_Displacement080(#sUDT_Interface_080);
	    END_REGION
	    
	    REGION Conveyor
	        
	        #sUDT_Handshake_080.RTR := TRUE;
	        
	        #sFB_Conveyor_080(iUDT_ConveyorConfiguration := #iqUDT_Configuration."080".Conveyor,
	                          idi_PECEoSDistance := 0,
	                          idi_PECBoSDistance := 0,
	                          ii_ExternalSpeed := 0,
	                          ix_SafetyOk := #ix_SafetyOk,
	                          ix_24vOk := #ix_24vOk,
	                          ix_400vOk := #ix_400vOk,
	                          ix_HardwareOk := TRUE,
	                          ix_PECEoS := TRUE,
	                          ix_PECBoS := TRUE,
	                          ix_ReverseDirection := FALSE,
	                          ix_ExternalRequestDieBack := FALSE,
	                          ix_ExternalRequestHold := #sx_Hold080,
	                          ix_ResetEnergySave := FALSE,
	                          qUDT_HMIStatus => #iqUDT_WorkstationStatus."080".Conveyor,
	                          qUDT_Status => #iqUDT_WorkstationCommonStatus."080",
	                          iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                          iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."080".Conveyor,
	                          iqUDT_ConveyorInterface := #sUDT_Interface_080,
	                          iqUDT_HandShakeUp := #sUDT_HandshakeUp_080,
	                          iqUDT_HandShake := #sUDT_Handshake_080,
	                          iqUDT_Statistics := #iqUDT_WorkstationStatistics."080".Conveyor);
	        
	    END_REGION
	    
	    REGION MCO
	        
	        #sFB_MCOConveyLinxAixController_080(iUDT_AixConfig := #iqUDT_Configuration."080".MCO_M01,
	                                            iUDT_AixInputsModule := #iUDT_MotorInput070,
	                                            ix_24vOk := #ix_24vOk,
	                                            ix_SimulationModeActive := "DB_Memory".Simulation,
	                                            ii_MotorPositionId := 2,
	                                            qUDT_HMIStatus => #iqUDT_WorkstationStatus."080".MCO_M01,
	                                            iqUDT_AixOutputsModule := #iqUDT_MotorOutput070,
	                                            iqUDT_ConveyorInterface := #sUDT_Interface_080,
	                                            iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."080".MCO_M01);
	    END_REGION
	    
	END_REGION
	
	REGION 110
	    
	    REGION Change GIN range
	        
	        #sR_TRIG_NewParcel110(CLK := #iqUDT_HandshakeUpstream110.GIN <> 0);
	        
	        IF #sR_TRIG_NewParcel110.Q THEN
	            
	            #si_LastGIN110 += 1;
	            
	            IF #si_LastGIN110 < ((#iqUDT_Configuration.GlobalConfig.GINRangeStart + #iqUDT_Configuration.GlobalConfig.GINRangeEnd) / 2) + 1
	                OR #si_LastGIN110 > #iqUDT_Configuration.GlobalConfig.GINRangeEnd
	            THEN
	                #si_LastGIN110 := ((#iqUDT_Configuration.GlobalConfig.GINRangeStart + #iqUDT_Configuration.GlobalConfig.GINRangeEnd) / 2) + 1;
	            END_IF;
	            #ts_Barcode := "DB_GIN".GIN[#iqUDT_HandshakeUpstream110.GIN].WES.Barcode;
	            #iqUDT_HandshakeUpstream110.GIN := #si_LastGIN110;
	            
	            "DB_GIN".GIN[#iqUDT_HandshakeUpstream110.GIN] := "DB_GINDefault".GIN[#iqUDT_Configuration."110".PEC_EoS.DefaultGIN];
	            "DB_GIN".GIN[#iqUDT_HandshakeUpstream110.GIN].WES.Barcode := #ts_Barcode;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Displacement
	        #sFB_Displacement110(#sUDT_Interface_110);
	    END_REGION
	    
	    REGION Tracking
	        
	        #sFB_Tracking_110(iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."110".Conveyor.Common,
	                          iqa_TrackingData := #sa_TrackingArray_110,
	                          iqUDT_ConveyorInterface := #sUDT_Interface_110,
	                          iqUDT_HandshakeUp := #iqUDT_HandshakeUpstream110,
	                          iqUDT_Handshake := #sUDT_Handshake_110);
	        
	    END_REGION
	    
	    REGION EoS
	        
	        #sFB_PECUpdate_110(iUDT_PECUpdateConfiguration := #iqUDT_Configuration."110".PEC_EoS,
	                           iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."110".Conveyor.Common,
	                           ix_PEC := #iUDT_MotorInput110.AllSensorPortInputs.LeftSensor,
	                           ix_TeachingMode := FALSE,
	                           qUDT_Status => #iqUDT_WorkstationStatus."110".PEC_EoS,
	                           iqUDT_ConveyorInterface := #sUDT_Interface_110,
	                           iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                           iqUDT_FifoHeader := "DB_FIFOLostGIN".Header_3,
	                           iqUDT_Statistics := #iqUDT_WorkstationStatistics."110".PEC_EoS,
	                           iqa_TrackingData := #sa_TrackingArray_110,
	                           iqa_FifoData := "DB_FIFOLostGIN".Data_3);
	        
	    END_REGION
	    
	    REGION Conveyor
	        
	        #sFB_Conveyor_110(iUDT_ConveyorConfiguration := #iqUDT_Configuration."110".Conveyor,
	                          idi_PECEoSDistance := #iqUDT_Configuration."110".PEC_EoS.Distance,
	                          idi_PECBoSDistance := 0,
	                          ii_ExternalSpeed := 0,
	                          ix_SafetyOk := #ix_SafetyOk,
	                          ix_24vOk := #ix_24vOk,
	                          ix_400vOk := #ix_400vOk,
	                          ix_HardwareOk := TRUE,
	                          ix_PECEoS := #iqUDT_WorkstationStatus."110".PEC_EoS.PEC,
	                          ix_PECBoS := TRUE,
	                          ix_ReverseDirection := FALSE,
	                          ix_ExternalRequestDieBack := (#sUDT_Interface_120.ActualSpeed = 0 AND NOT #iqUDT_WorkstationStatus."110".PEC_EoS.PEC),
	                          ix_ExternalRequestHold := FALSE,
	                          ix_ResetEnergySave := FALSE,
	                          qUDT_HMIStatus => #iqUDT_WorkstationStatus."110".Conveyor,
	                          qUDT_Status => #iqUDT_WorkstationCommonStatus."110",
	                          iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                          iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."110".Conveyor,
	                          iqUDT_ConveyorInterface := #sUDT_Interface_110,
	                          iqUDT_HandShakeUp := #iqUDT_HandshakeUpstream110,
	                          iqUDT_HandShake := #sUDT_Handshake_110,
	                          iqUDT_Statistics := #iqUDT_WorkstationStatistics."110".Conveyor);
	        
	        //  #iqUDT_HandshakeUpstream110.RTR := #iqUDT_HandshakeUpstream110.RTR AND #iqUDT_WorkstationStatus."110".PEC_EoS.PEC;
	        
	        
	    END_REGION
	    
	    REGION MCO
	        
	        #sFB_MCOConveyLinxAixController_110(iUDT_AixConfig := #iqUDT_Configuration."110".MCO_M01,
	                                            iUDT_AixInputsModule := #iUDT_MotorInput110,
	                                            ix_24vOk := #ix_24vOk,
	                                            ix_SimulationModeActive := "DB_Memory".Simulation,
	                                            ii_MotorPositionId := 1,
	                                            qUDT_HMIStatus => #iqUDT_WorkstationStatus."110".MCO_M01,
	                                            iqUDT_AixOutputsModule := #iqUDT_MotorOutput110,
	                                            iqUDT_ConveyorInterface := #sUDT_Interface_110,
	                                            iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."110".MCO_M01);
	    END_REGION
	    
	END_REGION
	
	REGION 120
	    
	    REGION Displacement
	        #sFB_Displacement120(#sUDT_Interface_120);
	    END_REGION
	    
	    REGION Tracking
	        
	        #sFB_Tracking_120(iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."120".Conveyor.Common,
	                          iqa_TrackingData := #sa_TrackingArray_120,
	                          iqUDT_ConveyorInterface := #sUDT_Interface_120,
	                          iqUDT_HandshakeUp := #sUDT_Handshake_110,
	                          iqUDT_Handshake := #sUDT_Handshake_120);
	        
	    END_REGION
	    
	    REGION EoS
	        
	        #sFB_PECUpdate_120(iUDT_PECUpdateConfiguration := #iqUDT_Configuration."120".PEC_EoS,
	                           iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."120".Conveyor.Common,
	                           ix_PEC := #iUDT_MotorInput110.AllSensorPortInputs.RightSensor,
	                           ix_TeachingMode := FALSE,
	                           qUDT_Status => #iqUDT_WorkstationStatus."120".PEC_EoS,
	                           iqUDT_ConveyorInterface := #sUDT_Interface_120,
	                           iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                           iqUDT_FifoHeader := "DB_FIFOLostGIN".Header_1,
	                           iqUDT_Statistics := #iqUDT_WorkstationStatistics."120".PEC_EoS,
	                           iqa_TrackingData := #sa_TrackingArray_120,
	                           iqa_FifoData := "DB_FIFOLostGIN".Data_1);
	        
	    END_REGION
	    
	    REGION Conveyor
	        
	        #sFB_Conveyor_120(iUDT_ConveyorConfiguration := #iqUDT_Configuration."120".Conveyor,
	                          idi_PECEoSDistance := #iqUDT_Configuration."120".PEC_EoS.Distance,
	                          idi_PECBoSDistance := 0,
	                          ii_ExternalSpeed := 0,
	                          ix_SafetyOk := #ix_SafetyOk,
	                          ix_24vOk := #ix_24vOk,
	                          ix_400vOk := #ix_400vOk,
	                          ix_HardwareOk := TRUE,
	                          ix_PECEoS := #iqUDT_WorkstationStatus."120".PEC_EoS.PEC,
	                          ix_PECBoS := TRUE,
	                          ix_ReverseDirection := FALSE,
	                          ix_ExternalRequestDieBack := #sx_Hold120 OR (#sUDT_Interface_130.ActualSpeed = 0 AND NOT #iqUDT_WorkstationStatus."120".PEC_EoS.PEC),
	                          ix_ExternalRequestHold := FALSE,
	                          ix_ResetEnergySave := FALSE,
	                          qUDT_HMIStatus => #iqUDT_WorkstationStatus."120".Conveyor,
	                          qUDT_Status => #iqUDT_WorkstationCommonStatus."120",
	                          iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                          iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."120".Conveyor,
	                          iqUDT_ConveyorInterface := #sUDT_Interface_120,
	                          iqUDT_HandShakeUp := #sUDT_Handshake_110,
	                          iqUDT_HandShake := #sUDT_Handshake_120,
	                          iqUDT_Statistics := #iqUDT_WorkstationStatistics."120".Conveyor);
	        
	    END_REGION
	    
	    REGION MCO
	        
	        #sFB_MCOConveyLinxAixController_120(iUDT_AixConfig := #iqUDT_Configuration."120".MCO_M01,
	                                            iUDT_AixInputsModule := #iUDT_MotorInput110,
	                                            ix_24vOk := #ix_24vOk,
	                                            ix_SimulationModeActive := "DB_Memory".Simulation,
	                                            ii_MotorPositionId := 2,
	                                            qUDT_HMIStatus => #iqUDT_WorkstationStatus."120".MCO_M01,
	                                            iqUDT_AixOutputsModule := #iqUDT_MotorOutput110,
	                                            iqUDT_ConveyorInterface := #sUDT_Interface_120,
	                                            iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."120".MCO_M01);
	    END_REGION
	    
	END_REGION
	
	REGION 130
	    
	    REGION Displacement
	        #sFB_Displacement130(#sUDT_Interface_130);
	    END_REGION
	    
	    REGION Tracking
	        
	        #sFB_Tracking_130(iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."130".Conveyor.Common,
	                          iqa_TrackingData := #sa_TrackingArray_130,
	                          iqUDT_ConveyorInterface := #sUDT_Interface_130,
	                          iqUDT_HandshakeUp := #sUDT_Handshake_120,
	                          iqUDT_Handshake := #sUDT_Handshake_130);
	        
	    END_REGION
	    
	    REGION EoS
	        
	        #sFB_PECUpdate_130(iUDT_PECUpdateConfiguration := #iqUDT_Configuration."130".PEC_EoS,
	                           iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."130".Conveyor.Common,
	                           ix_PEC := #iUDT_MotorInput130.AllSensorPortInputs.LeftSensor,
	                           ix_TeachingMode := FALSE,
	                           qUDT_Status => #iqUDT_WorkstationStatus."130".PEC_EoS,
	                           iqUDT_ConveyorInterface := #sUDT_Interface_130,
	                           iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                           iqUDT_FifoHeader := "DB_FIFOLostGIN".Header_2,
	                           iqUDT_Statistics := #iqUDT_WorkstationStatistics."130".PEC_EoS,
	                           iqa_TrackingData := #sa_TrackingArray_130,
	                           iqa_FifoData := "DB_FIFOLostGIN".Data_2);
	        
	    END_REGION
	    
	    REGION Conveyor
	        
	        #sUDT_Handshake_130.RTR := #sUDT_Handshake_130.RTR AND NOT #sx_Hold130 OR #iqUDT_WorkstationStatus."130".PEC_EoS.PEC;
	        
	        #sFB_Conveyor_130(iUDT_ConveyorConfiguration := #iqUDT_Configuration."130".Conveyor,
	                          idi_PECEoSDistance := #iqUDT_Configuration."130".PEC_EoS.Distance,
	                          idi_PECBoSDistance := 0,
	                          ii_ExternalSpeed := 0,
	                          ix_SafetyOk := #ix_SafetyOk,
	                          ix_24vOk := #ix_24vOk,
	                          ix_400vOk := #ix_400vOk,
	                          ix_HardwareOk := TRUE,
	                          ix_PECEoS := #iqUDT_WorkstationStatus."130".PEC_EoS.PEC,
	                          ix_PECBoS := TRUE,
	                          ix_ReverseDirection := FALSE,
	                          ix_ExternalRequestDieBack := FALSE,
	                          ix_ExternalRequestHold := #sx_Hold130,
	                          ix_ResetEnergySave := FALSE,
	                          qUDT_HMIStatus => #iqUDT_WorkstationStatus."130".Conveyor,
	                          qUDT_Status => #iqUDT_WorkstationCommonStatus."130",
	                          iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                          iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."130".Conveyor,
	                          iqUDT_ConveyorInterface := #sUDT_Interface_130,
	                          iqUDT_HandShakeUp := #sUDT_Handshake_120,
	                          iqUDT_HandShake := #sUDT_Handshake_130,
	                          iqUDT_Statistics := #iqUDT_WorkstationStatistics."130".Conveyor);
	        
	        
	    END_REGION
	    
	    REGION MCO
	        
	        #sFB_MCOConveyLinxAixController_130(iUDT_AixConfig := #iqUDT_Configuration."130".MCO_M01,
	                                            iUDT_AixInputsModule := #iUDT_MotorInput130,
	                                            ix_24vOk := #ix_24vOk,
	                                            ix_SimulationModeActive := "DB_Memory".Simulation,
	                                            ii_MotorPositionId := 1,
	                                            qUDT_HMIStatus => #iqUDT_WorkstationStatus."130".MCO_M01,
	                                            iqUDT_AixOutputsModule := #iqUDT_MotorOutput130,
	                                            iqUDT_ConveyorInterface := #sUDT_Interface_130,
	                                            iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."130".MCO_M01);
	    END_REGION
	    
	END_REGION
	
	REGION 140
	    
	    REGION Displacement
	        #sFB_Displacement140(#sUDT_Interface_140);
	    END_REGION
	    
	    REGION MCO
	        
	        #sFB_MCOConveyLinxAixController_140(iUDT_AixConfig := #iqUDT_Configuration."140".MCO_M01,
	                                            iUDT_AixInputsModule := #iUDT_MotorInput140,
	                                            ii_PositionSetpoint := #iqUDT_RATPositioning140.Lower.EndPosition,
	                                            ix_24vOk := #ix_24vOk,
	                                            ix_SimulationModeActive := "DB_Memory".Simulation,
	                                            ii_MotorPositionId := 1,
	                                            ix_StartPositioning := #iqUDT_RATPositioning140.Lower.Start,
	                                            ix_ResetPosition := #iqUDT_RATPositioning140.Lower.ResetPosition,
	                                            qUDT_HMIStatus => #iqUDT_WorkstationStatus."140".MCO_M01,
	                                            qx_Positioned => #iqUDT_RATPositioning140.Lower.Done,
	                                            iqUDT_AixOutputsModule := #iqUDT_MotorOutput140,
	                                            iqUDT_ConveyorInterface := #sUDT_Interface_140,
	                                            iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."140".MCO_M01);
	    END_REGION
	    
	    REGION BladeStopEoS
	        
	        IF #iqUDT_Configuration.GlobalConfig.RightStationAvailable THEN
	            
	            #sFB_BladeStopEoS_140(iUDT_Configuration := #iqUDT_Configuration."140".BladeStopEoS,
	                                  ix_IsOpened := #ix_BladeStopisUp140,
	                                  ix_IsClosed := #ix_BladeStopisDown140,
	                                  ix_AirPressureOk := TRUE,
	                                  qx_Open => #qx_BladeStopControl140,
	                                  qUDT_HMIStatus => #iqUDT_WorkstationStatus."140".BladeStopEoS,
	                                  qUDT_Statistics => #iqUDT_WorkstationStatistics."140".BladeStopEoS,
	                                  iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                  iqUDT_HMICommand := #iqUDT_WorkstationCommands."140".BladeStopEoS,
	                                  iqUDT_Interface := #sUDT_Interface_140_BladeStopEoS);
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 141
	    
	    REGION Displacement
	        #sFB_Displacement141(#sUDT_Interface_141);
	    END_REGION
	    
	    REGION RAT
	        
	        #iqUDT_Configuration."141".RightAngledTransfer.BladeStopEoS := #iqUDT_Configuration.GlobalConfig.RightStationAvailable;
	        
	        #sFB_RightAngledTransfer_141(iUDT_Configuration := #iqUDT_Configuration."141".RightAngledTransfer,
	                                     iUDT_LowerConveyorConfiguration := #iqUDT_Configuration."140".Conveyor,
	                                     iUDT_UpperConveyorConfiguration := #iqUDT_Configuration."141".Conveyor,
	                                     iUDT_PECConfiguration := #iqUDT_Configuration."140".PEC_EoS,
	                                     ii_DestinationA := #si_140DestinationA,
	                                     ii_DestinationB := #si_140DestinationB,
	                                     ii_DestinationC := #si_140DestinationC,
	                                     ii_DestinationD := #si_140DestinationD,
	                                     ix_HardwareOk := TRUE,
	                                     ix_400vOk := #ix_400vOk,
	                                     ix_24vOk := #ix_24vOk,
	                                     ix_SafetyOk := #ix_SafetyOk,
	                                     ix_AirPressureOk := #ix_AirPressureOk,
	                                     ix_SectionIsDown := #ix_SectionisDown141,
	                                     ix_SectionIsUp := #ix_SectionisUp141,
	                                     ix_ConveyorAAuto := #iqUDT_WorkstationCommonStatus."130".AutoON,
	                                     ix_ConveyorBAuto := #iqUDT_WorkstationCommonStatus."150".AutoON,
	                                     ix_ConveyorCAuto := #iqUDT_WorkstationCommonStatus."241".AutoON,
	                                     ix_ConveyorDAuto := FALSE,
	                                     ix_PEC := #iUDT_MotorInput140.AllSensorPortInputs.LeftSensor,
	                                     ix_ExternalReceiveRequestA := NOT #iqUDT_WorkstationStatus."130".PEC_EoS.PEC AND #sx_Enable1X0In,
	                                     ix_ExternalReceiveRequestB := false,
	                                     ix_ExternalReceiveRequestC := #sFB_RightAngledTransfer_241.qx_ExternalSendRequestC,
	                                     ix_ExternalReceiveRequestD := false,
	                                     ix_PECInfeedA := #iqUDT_WorkstationStatus."130".PEC_EoS.PEC,
	                                     ix_PECInfeedC := #iqUDT_WorkstationStatus."240".PEC_EoS.PEC,
	                                     qUDT_HMIRATStatus => #iqUDT_WorkstationStatus."141".RightAngledTransfer,
	                                     qUDT_HMIConveyorStatus => #iqUDT_WorkstationStatus."140".Conveyor,
	                                     qUDT_HMIPECStatus => #iqUDT_WorkstationStatus."140".PEC_EoS,
	                                     qUDT_RATStatus => #iqUDT_WorkstationCommonStatus."141",
	                                     qUDT_ConveyorStatus => #iqUDT_WorkstationCommonStatus."140",
	                                     qx_PopupControl => #qx_PopupControl141,
	                                     iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                     iqUDT_RATCommand := #iqUDT_WorkstationCommands."141".RightAngledTransfer,
	                                     iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."140".Conveyor,
	                                     iqUDT_RATStatistics := #iqUDT_WorkstationStatistics."141".RightAngledTransfer,
	                                     iqUDT_ConveyorStatistics := #iqUDT_WorkstationStatistics."140".Conveyor,
	                                     iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."140".PEC_EoS,
	                                     iqUDT_HandShakeConveyorA := #sUDT_Handshake_130,
	                                     iqUDT_HandShakeConveyorB := #sUDT_Handshake_140,
	                                     iqUDT_HandShakeConveyorC := #sUDT_Handshake_241,
	                                     iqUDT_HandShakeConveyorD := #sUDT_Handshake_141,
	                                     iqUDT_LowerConveyorInterface := #sUDT_Interface_140,
	                                     iqUDT_UpperConveyorInterface := #sUDT_Interface_141,
	                                     iqUDT_RATPositioning := #iqUDT_RATPositioning140,
	                                     iqUDT_BladeStopEoSInterface := #sUDT_Interface_140_BladeStopEoS,
	                                     iqUDT_BladeStopBoSInterface := #tUDT_DummyBladeStop);
	        
	    END_REGION
	    
	    REGION MCO
	        
	        #sFB_MCOConveyLinxAixController_141(iUDT_AixConfig := #iqUDT_Configuration."141".MCO_M01,
	                                            iUDT_AixInputsModule := #iUDT_MotorInput140,
	                                            ii_PositionSetpoint := #iqUDT_RATPositioning140.Upper.EndPosition,
	                                            ix_24vOk := #ix_24vOk,
	                                            ix_SimulationModeActive := "DB_Memory".Simulation,
	                                            ii_MotorPositionId := 2,
	                                            ix_StartPositioning := #iqUDT_RATPositioning140.Upper.Start,
	                                            qUDT_HMIStatus => #iqUDT_WorkstationStatus."141".MCO_M01,
	                                            qx_Positioned => #iqUDT_RATPositioning140.Upper.Done,
	                                            iqUDT_AixOutputsModule := #iqUDT_MotorOutput140,
	                                            iqUDT_ConveyorInterface := #sUDT_Interface_141,
	                                            iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."141".MCO_M01);
	    END_REGION
	    
	END_REGION
	
	IF #iqUDT_Configuration.GlobalConfig.RightStationAvailable THEN
	    
	    REGION 150
	        
	        REGION Displacement
	            #sFB_Displacement150(#sUDT_Interface_150);
	        END_REGION
	        
	        REGION Tracking
	            
	            #sFB_Tracking_150(iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."150".Conveyor.Common,
	                              iqa_TrackingData := #sa_TrackingArray_150,
	                              iqUDT_ConveyorInterface := #sUDT_Interface_150,
	                              iqUDT_HandshakeUp := #sUDT_Handshake_140,
	                              iqUDT_Handshake := #sUDT_Handshake_150);
	            
	        END_REGION
	        
	        REGION EoS
	            
	            #sFB_PECUpdate_150(iUDT_PECUpdateConfiguration := #iqUDT_Configuration."150".PEC_EoS,
	                               iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."150".Conveyor.Common,
	                               ix_PEC := NOT #iUDT_MotorInput150.AllSensorPortInputs.LeftSensor,
	                               ix_TeachingMode := FALSE,
	                               qUDT_Status => #iqUDT_WorkstationStatus."150".PEC_EoS,
	                               iqUDT_ConveyorInterface := #sUDT_Interface_150,
	                               iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                               iqUDT_FifoHeader := "DB_FIFOLostGIN".Header_4,
	                               iqUDT_Statistics := #iqUDT_WorkstationStatistics."150".PEC_EoS,
	                               iqa_TrackingData := #sa_TrackingArray_150,
	                               iqa_FifoData := "DB_FIFOLostGIN".Data_4);
	            
	            
	            
	            
	        END_REGION
	        
	        REGION Conveyor
	            
	            #sUDT_Handshake_150.RTR := true;
	            // #tx_Enable := (#iqUDT_WorkstationStatus."160".PEC_EoS.PEC AND #sUDT_Interface_160.ActualSpeed <> 0)
	            // OR (#iqUDT_WorkstationStatus."150".PEC_EoS.PEC);
	            #sUDT_Handshake_150.RTR := (#iqUDT_WorkstationStatus."160".PEC_EoS.PEC AND #sUDT_Interface_160.ActualSpeed <> 0)
	            OR (#iqUDT_WorkstationStatus."150".PEC_EoS.PEC);
	            #sFB_Conveyor_150(iUDT_ConveyorConfiguration := #iqUDT_Configuration."150".Conveyor,
	                              idi_PECEoSDistance := #iqUDT_Configuration."150".PEC_EoS.Distance,
	                              idi_PECBoSDistance := 0,
	                              ii_ExternalSpeed := 0,
	                              ix_SafetyOk := #ix_SafetyOk,
	                              ix_24vOk := #ix_24vOk,
	                              ix_400vOk := #ix_400vOk,
	                              ix_HardwareOk := TRUE,
	                              ix_PECEoS := #iqUDT_WorkstationStatus."150".PEC_EoS.PEC,
	                              ix_PECBoS := TRUE,
	                              ix_ReverseDirection := FALSE,
	                              ix_ExternalRequestDieBack := FALSE,
	                              ix_ExternalRequestHold := #sx_ReleaseBinHoldRight,//NOT #tx_Enable,
	                              ix_ResetEnergySave := FALSE,
	                              qUDT_HMIStatus => #iqUDT_WorkstationStatus."150".Conveyor,
	                              qUDT_Status => #iqUDT_WorkstationCommonStatus."150",
	                              iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                              iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."150".Conveyor,
	                              iqUDT_ConveyorInterface := #sUDT_Interface_150,
	                              iqUDT_HandShakeUp := #sUDT_Handshake_140,
	                              iqUDT_HandShake := #sUDT_Handshake_150,
	                              iqUDT_Statistics := #iqUDT_WorkstationStatistics."150".Conveyor);
	            
	        END_REGION
	        
	        REGION MCO
	            
	            #sFB_MCOConveyLinxAixController_150(iUDT_AixConfig := #iqUDT_Configuration."150".MCO_M01,
	                                                iUDT_AixInputsModule := #iUDT_MotorInput150,
	                                                ix_24vOk := #ix_24vOk,
	                                                ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                ii_MotorPositionId := 1,
	                                                qUDT_HMIStatus => #iqUDT_WorkstationStatus."150".MCO_M01,
	                                                iqUDT_AixOutputsModule := #iqUDT_MotorOutput150,
	                                                iqUDT_ConveyorInterface := #sUDT_Interface_150,
	                                                iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."150".MCO_M01);
	        END_REGION
	        
	    END_REGION
	    
	    REGION 160
	        
	        REGION Displacement
	            #sFB_Displacement160(#sUDT_Interface_160);
	        END_REGION
	        
	        REGION Tracking 
	            
	            #sFB_Tracking_160(iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."160".Conveyor.Common,
	                              iqa_TrackingData := #sa_TrackingArray_160,
	                              iqUDT_ConveyorInterface := #sUDT_Interface_160,
	                              iqUDT_HandshakeUp := #sUDT_Handshake_150,
	                              iqUDT_Handshake := #sUDT_Handshake_160);
	            
	        END_REGION
	        
	        REGION EoS
	            
	            #sFB_PECUpdate_160(iUDT_PECUpdateConfiguration := #iqUDT_Configuration."160".PEC_EoS,
	                               iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."160".Conveyor.Common,
	                               ix_PEC := NOT #iUDT_MotorInput150.AllSensorPortInputs.RightSensor,
	                               ix_TeachingMode := FALSE,
	                               qUDT_Status => #iqUDT_WorkstationStatus."160".PEC_EoS,
	                               iqUDT_ConveyorInterface := #sUDT_Interface_160,
	                               iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                               iqUDT_FifoHeader := "DB_FIFOLostGIN".Header_5,
	                               iqUDT_Statistics := #iqUDT_WorkstationStatistics."160".PEC_EoS,
	                               iqa_TrackingData := #sa_TrackingArray_160,
	                               iqa_FifoData := "DB_FIFOLostGIN".Data_5);
	            
	            
	            
	            
	        END_REGION
	        
	        REGION Conveyor
	            
	            // #sUDT_Handshake_160.RTR := true;
	            // #tx_Enable := (#iqUDT_WorkstationStatus."170".PEC_EoS.PEC AND #sUDT_Interface_170.ActualSpeed <> 0)
	            //  OR (#iqUDT_WorkstationStatus."160".PEC_EoS.PEC);
	            #sUDT_Handshake_160.RTR := (#iqUDT_WorkstationStatus."170".PEC_EoS.PEC AND #sUDT_Interface_170.ActualSpeed <> 0)
	            OR (#iqUDT_WorkstationStatus."160".PEC_EoS.PEC);
	            
	            
	            #sFB_Conveyor_160(iUDT_ConveyorConfiguration := #iqUDT_Configuration."160".Conveyor,
	                              idi_PECEoSDistance := #iqUDT_Configuration."160".PEC_EoS.Distance,
	                              idi_PECBoSDistance := 0,
	                              ii_ExternalSpeed := 0,
	                              ix_SafetyOk := #ix_SafetyOk,
	                              ix_24vOk := #ix_24vOk,
	                              ix_400vOk := #ix_400vOk,
	                              ix_HardwareOk := TRUE,
	                              ix_PECEoS := #iqUDT_WorkstationStatus."160".PEC_EoS.PEC,
	                              ix_PECBoS := TRUE,
	                              ix_ReverseDirection := FALSE,
	                              ix_ExternalRequestDieBack := FALSE,
	                              ix_ExternalRequestHold := #sx_ReleaseBinHoldRight,//NOT #tx_Enable,//NOT #iqUDT_WorkstationStatus."160"."132".PEC_EoS.PEC AND NOT #iqUDT_WorkstationStatus."135"."136".PEC_EoS.PEC AND NOT (#sUDT_Interface_170.ActualSpeed <> 0),
	                              ix_ResetEnergySave := FALSE,
	                              qUDT_HMIStatus => #iqUDT_WorkstationStatus."160".Conveyor,
	                              qUDT_Status => #iqUDT_WorkstationCommonStatus."160",
	                              iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                              iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."160".Conveyor,
	                              iqUDT_ConveyorInterface := #sUDT_Interface_160,
	                              iqUDT_HandShakeUp := #sUDT_Handshake_150,
	                              iqUDT_HandShake := #sUDT_Handshake_160,
	                              iqUDT_Statistics := #iqUDT_WorkstationStatistics."160".Conveyor);
	            
	        END_REGION
	        
	        REGION MCO
	            
	            #sFB_MCOConveyLinxAixController_160(iUDT_AixConfig := #iqUDT_Configuration."160".MCO_M01,
	                                                iUDT_AixInputsModule := #iUDT_MotorInput150,
	                                                ix_24vOk := #ix_24vOk,
	                                                ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                ii_MotorPositionId := 2,
	                                                qUDT_HMIStatus => #iqUDT_WorkstationStatus."160".MCO_M01,
	                                                iqUDT_AixOutputsModule := #iqUDT_MotorOutput150,
	                                                iqUDT_ConveyorInterface := #sUDT_Interface_160,
	                                                iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."160".MCO_M01);
	        END_REGION
	        
	    END_REGION
	    
	    REGION 170
	        
	        REGION Displacement
	            #sFB_Displacement170(#sUDT_Interface_170);
	        END_REGION
	        
	        REGION Tracking
	            
	            #sFB_Tracking_170(iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."170".Conveyor.Common,
	                              iqa_TrackingData := #sa_TrackingArray_170,
	                              iqUDT_ConveyorInterface := #sUDT_Interface_170,
	                              iqUDT_HandshakeUp := #sUDT_Handshake_160,
	                              iqUDT_Handshake := #sUDT_Handshake_170);
	            
	        END_REGION
	        
	        REGION EoS
	            
	            #sFB_PECUpdate_170(iUDT_PECUpdateConfiguration := #iqUDT_Configuration."170".PEC_EoS,
	                               iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."170".Conveyor.Common,
	                               ix_PEC := NOT #iUDT_MotorInput170.AllSensorPortInputs.RightSensor,
	                               ix_TeachingMode := FALSE,
	                               qUDT_Status => #iqUDT_WorkstationStatus."170".PEC_EoS,
	                               iqUDT_ConveyorInterface := #sUDT_Interface_170,
	                               iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                               iqUDT_FifoHeader := "DB_FIFOLostGIN".Header_6,
	                               iqUDT_Statistics := #iqUDT_WorkstationStatistics."170".PEC_EoS,
	                               iqa_TrackingData := #sa_TrackingArray_170,
	                               iqa_FifoData := "DB_FIFOLostGIN".Data_6);
	            
	        END_REGION
	        
	        REGION Conveyor
	            
	            
	            
	            #sUDT_Handshake_170.RTR := #iqUDT_WorkstationStatus."170".PEC_EoS.PEC;
	            
	            #sFB_Conveyor_170(iUDT_ConveyorConfiguration := #iqUDT_Configuration."170".Conveyor,
	                              idi_PECEoSDistance := #iqUDT_Configuration."170".PEC_EoS.Distance,
	                              idi_PECBoSDistance := 0,
	                              ii_ExternalSpeed := 0,
	                              ix_SafetyOk := #ix_SafetyOk,
	                              ix_24vOk := #ix_24vOk,
	                              ix_400vOk := #ix_400vOk,
	                              ix_HardwareOk := TRUE,
	                              ix_PECEoS := #iqUDT_WorkstationStatus."170".PEC_EoS.PEC,
	                              ix_PECBoS := TRUE,
	                              ix_ReverseDirection := FALSE,
	                              ix_ExternalRequestDieBack := FALSE,
	                              ix_ExternalRequestHold := #sx_ReleaseBinHoldRight,
	                              ix_ResetEnergySave := FALSE,
	                              qUDT_HMIStatus => #iqUDT_WorkstationStatus."170".Conveyor,
	                              qUDT_Status => #iqUDT_WorkstationCommonStatus."170",
	                              iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                              iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."170".Conveyor,
	                              iqUDT_ConveyorInterface := #sUDT_Interface_170,
	                              iqUDT_HandShakeUp := #sUDT_Handshake_160,
	                              iqUDT_HandShake := #sUDT_Handshake_170,
	                              iqUDT_Statistics := #iqUDT_WorkstationStatistics."170".Conveyor);
	            
	        END_REGION
	        
	        REGION MCO
	            
	            #sFB_MCOConveyLinxAixController_170(iUDT_AixConfig := #iqUDT_Configuration."170".MCO_M01,
	                                                iUDT_AixInputsModule := #iUDT_MotorInput170,
	                                                ix_24vOk := #ix_24vOk,
	                                                ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                ii_MotorPositionId := 1,
	                                                qUDT_HMIStatus => #iqUDT_WorkstationStatus."170".MCO_M01,
	                                                iqUDT_AixOutputsModule := #iqUDT_MotorOutput170,
	                                                iqUDT_ConveyorInterface := #sUDT_Interface_170,
	                                                iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."170".MCO_M01);
	        END_REGION
	    END_REGION
	    
	    REGION 180
	        
	        REGION Displacement
	            #sFB_Displacement180(#sUDT_Interface_180);
	        END_REGION
	        
	        REGION Conveyor
	            
	            #sUDT_Handshake_180.RTR := TRUE;
	            
	            #sFB_Conveyor_080(iUDT_ConveyorConfiguration := #iqUDT_Configuration."180".Conveyor,
	                              idi_PECEoSDistance := 0,
	                              idi_PECBoSDistance := 0,
	                              ii_ExternalSpeed := 0,
	                              ix_SafetyOk := #ix_SafetyOk,
	                              ix_24vOk := #ix_24vOk,
	                              ix_400vOk := #ix_400vOk,
	                              ix_HardwareOk := TRUE,
	                              ix_PECEoS := TRUE,
	                              ix_PECBoS := TRUE,
	                              ix_ReverseDirection := FALSE,
	                              ix_ExternalRequestDieBack := FALSE,
	                              ix_ExternalRequestHold := #sx_Hold180,
	                              ix_ResetEnergySave := FALSE,
	                              qUDT_HMIStatus => #iqUDT_WorkstationStatus."180".Conveyor,
	                              qUDT_Status => #iqUDT_WorkstationCommonStatus."180",
	                              iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                              iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."180".Conveyor,
	                              iqUDT_ConveyorInterface := #sUDT_Interface_180,
	                              iqUDT_HandShakeUp := #sUDT_HandshakeUp_180,
	                              iqUDT_HandShake := #sUDT_Handshake_180,
	                              iqUDT_Statistics := #iqUDT_WorkstationStatistics."180".Conveyor);
	            
	        END_REGION
	        
	        REGION MCO
	            
	            #sFB_MCOConveyLinxAixController_180(iUDT_AixConfig := #iqUDT_Configuration."180".MCO_M01,
	                                                iUDT_AixInputsModule := #iUDT_MotorInput170,
	                                                ix_24vOk := #ix_24vOk,
	                                                ix_SimulationModeActive := "DB_Memory".Simulation,
	                                                ii_MotorPositionId := 2,
	                                                qUDT_HMIStatus => #iqUDT_WorkstationStatus."180".MCO_M01,
	                                                iqUDT_AixOutputsModule := #iqUDT_MotorOutput170,
	                                                iqUDT_ConveyorInterface := #sUDT_Interface_180,
	                                                iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."180".MCO_M01);
	        END_REGION
	        
	    END_REGION
	END_IF;
	REGION 210
	    
	    REGION Displacement
	        #sFB_Displacement210(#sUDT_Interface_210);
	    END_REGION
	    
	    REGION Tracking
	        
	        #sFB_Tracking_210(iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."210".Conveyor.Common,
	                          iqa_TrackingData := #sa_TrackingArray_210,
	                          iqUDT_ConveyorInterface := #sUDT_Interface_210,
	                          iqUDT_HandshakeUp := #sUDT_HandshakeUp_210,
	                          iqUDT_Handshake := #sUDT_Handshake_210);
	        
	    END_REGION
	    
	    REGION EoS
	        
	        #sFB_PECUpdate_210(iUDT_PECUpdateConfiguration := #iqUDT_Configuration."210".PEC_EoS,
	                           iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."210".Conveyor.Common,
	                           ix_PEC := NOT #iUDT_MotorInput210.AllSensorPortInputs.LeftSensor,
	                           ix_TeachingMode := FALSE,
	                           qUDT_Status => #iqUDT_WorkstationStatus."210".PEC_EoS,
	                           iqUDT_ConveyorInterface := #sUDT_Interface_210,
	                           iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                           iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                           iqUDT_Statistics := #iqUDT_WorkstationStatistics."210".PEC_EoS,
	                           iqa_TrackingData := #sa_TrackingArray_210,
	                           iqa_FifoData := "DB_FIFOLostGIN".Data);
	        
	    END_REGION
	    
	    REGION Conveyor
	        
	        #sFB_Conveyor_210(iUDT_ConveyorConfiguration := #iqUDT_Configuration."210".Conveyor,
	                          idi_PECEoSDistance := #iqUDT_Configuration."210".PEC_EoS.Distance,
	                          idi_PECBoSDistance := 0,
	                          ii_ExternalSpeed := 0,
	                          ix_SafetyOk := #ix_SafetyOk,
	                          ix_24vOk := #ix_24vOk,
	                          ix_400vOk := #ix_400vOk,
	                          ix_HardwareOk := TRUE,
	                          ix_PECEoS := #iqUDT_WorkstationStatus."210".PEC_EoS.PEC,
	                          ix_PECBoS := TRUE,
	                          ix_ReverseDirection := FALSE,
	                          ix_ExternalRequestDieBack := FALSE,
	                          ix_ExternalRequestHold := #sx_ReleaseBinHoldLeft OR #sx_ReleaseBinHoldRight OR NOT #sUDT_Handshake_210.RTR,
	                          ix_ResetEnergySave := FALSE,
	                          qUDT_HMIStatus => #iqUDT_WorkstationStatus."210".Conveyor,
	                          qUDT_Status => #iqUDT_WorkstationCommonStatus."210",
	                          iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                          iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."210".Conveyor,
	                          iqUDT_ConveyorInterface := #sUDT_Interface_210,
	                          iqUDT_HandShakeUp := #sUDT_HandshakeUp_210,
	                          iqUDT_HandShake := #sUDT_Handshake_210,
	                          iqUDT_Statistics := #iqUDT_WorkstationStatistics."210".Conveyor);
	        
	    END_REGION
	    
	    REGION MCO
	        
	        #sFB_MCOConveyLinxAixController_210(iUDT_AixConfig := #iqUDT_Configuration."210".MCO_M01,
	                                            iUDT_AixInputsModule := #iUDT_MotorInput210,
	                                            ix_24vOk := #ix_24vOk,
	                                            ix_SimulationModeActive := "DB_Memory".Simulation,
	                                            ii_MotorPositionId := 1,
	                                            qUDT_HMIStatus => #iqUDT_WorkstationStatus."210".MCO_M01,
	                                            iqUDT_AixOutputsModule := #iqUDT_MotorOutput210,
	                                            iqUDT_ConveyorInterface := #sUDT_Interface_210,
	                                            iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."210".MCO_M01);
	    END_REGION
	    
	END_REGION
	
	REGION 220
	    
	    REGION Displacement
	        #sFB_Displacement220(#sUDT_Interface_220);
	    END_REGION
	    
	    REGION Tracking
	        
	        #sFB_Tracking_220(iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."220".Conveyor.Common,
	                          iqa_TrackingData := #sa_TrackingArray_220,
	                          iqUDT_ConveyorInterface := #sUDT_Interface_220,
	                          iqUDT_HandshakeUp := #sUDT_Handshake_210,
	                          iqUDT_Handshake := #sUDT_Handshake_220);
	        
	    END_REGION
	    
	    REGION EoS
	        
	        #sFB_PECUpdate_220(iUDT_PECUpdateConfiguration := #iqUDT_Configuration."220".PEC_EoS,
	                           iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."220".Conveyor.Common,
	                           ix_PEC := NOT #iUDT_MotorInput210.AllSensorPortInputs.RightSensor,
	                           ix_TeachingMode := FALSE,
	                           qUDT_Status => #iqUDT_WorkstationStatus."220".PEC_EoS,
	                           iqUDT_ConveyorInterface := #sUDT_Interface_220,
	                           iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                           iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                           iqUDT_Statistics := #iqUDT_WorkstationStatistics."220".PEC_EoS,
	                           iqa_TrackingData := #sa_TrackingArray_220,
	                           iqa_FifoData := "DB_FIFOLostGIN".Data);
	        
	        
	        
	        
	    END_REGION
	    
	    REGION Conveyor
	        
	        #sFB_Conveyor_220(iUDT_ConveyorConfiguration := #iqUDT_Configuration."220".Conveyor,
	                          idi_PECEoSDistance := #iqUDT_Configuration."220".PEC_EoS.Distance,
	                          idi_PECBoSDistance := 0,
	                          ii_ExternalSpeed := 0,
	                          ix_SafetyOk := #ix_SafetyOk,
	                          ix_24vOk := #ix_24vOk,
	                          ix_400vOk := #ix_400vOk,
	                          ix_HardwareOk := TRUE,
	                          ix_PECEoS := #iqUDT_WorkstationStatus."220".PEC_EoS.PEC,
	                          ix_PECBoS := TRUE,
	                          ix_ReverseDirection := FALSE,
	                          ix_ExternalRequestDieBack := FALSE,
	                          ix_ExternalRequestHold := #sx_Hold220 OR #sx_ReleaseBinHoldLeft OR #sx_ReleaseBinHoldRight,
	                          ix_ResetEnergySave := FALSE,
	                          qUDT_HMIStatus => #iqUDT_WorkstationStatus."220".Conveyor,
	                          qUDT_Status => #iqUDT_WorkstationCommonStatus."220",
	                          iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                          iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."220".Conveyor,
	                          iqUDT_ConveyorInterface := #sUDT_Interface_220,
	                          iqUDT_HandShakeUp := #sUDT_Handshake_210,
	                          iqUDT_HandShake := #sUDT_Handshake_220,
	                          iqUDT_Statistics := #iqUDT_WorkstationStatistics."220".Conveyor);
	        
	    END_REGION
	    
	    REGION MCO
	        
	        #sFB_MCOConveyLinxAixController_220(iUDT_AixConfig := #iqUDT_Configuration."220".MCO_M01,
	                                            iUDT_AixInputsModule := #iUDT_MotorInput210,
	                                            ix_24vOk := #ix_24vOk,
	                                            ix_SimulationModeActive := "DB_Memory".Simulation,
	                                            ii_MotorPositionId := 2,
	                                            qUDT_HMIStatus => #iqUDT_WorkstationStatus."220".MCO_M01,
	                                            iqUDT_AixOutputsModule := #iqUDT_MotorOutput210,
	                                            iqUDT_ConveyorInterface := #sUDT_Interface_220,
	                                            iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."220".MCO_M01);
	    END_REGION
	    
	    
	END_REGION
	
	REGION 230
	    
	    REGION Displacement
	        #sFB_Displacement230(#sUDT_Interface_230);
	    END_REGION
	    
	    REGION Tracking
	        
	        #sFB_Tracking_230(iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."230".Conveyor.Common,
	                          iqa_TrackingData := #sa_TrackingArray_230,
	                          iqUDT_ConveyorInterface := #sUDT_Interface_230,
	                          iqUDT_HandshakeUp := #sUDT_Handshake_220,
	                          iqUDT_Handshake := #sUDT_Handshake_230);
	        
	    END_REGION
	    
	    REGION EoS
	        
	        #sFB_PECUpdate_230(iUDT_PECUpdateConfiguration := #iqUDT_Configuration."230".PEC_EoS,
	                           iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."230".Conveyor.Common,
	                           ix_PEC := NOT #iUDT_MotorInput230.AllSensorPortInputs.LeftSensor,
	                           ix_TeachingMode := FALSE,
	                           qUDT_Status => #iqUDT_WorkstationStatus."230".PEC_EoS,
	                           iqUDT_ConveyorInterface := #sUDT_Interface_230,
	                           iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                           iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                           iqUDT_Statistics := #iqUDT_WorkstationStatistics."230".PEC_EoS,
	                           iqa_TrackingData := #sa_TrackingArray_230,
	                           iqa_FifoData := "DB_FIFOLostGIN".Data);
	        
	        
	        
	        
	    END_REGION
	    
	    REGION Conveyor
	        #sUDT_Handshake_230.RTR := #sUDT_Handshake_230.RTR OR #iqUDT_WorkstationStatus."230".PEC_EoS.PEC;
	        #sFB_Conveyor_230(iUDT_ConveyorConfiguration := #iqUDT_Configuration."230".Conveyor,
	                          idi_PECEoSDistance := #iqUDT_Configuration."230".PEC_EoS.Distance,
	                          idi_PECBoSDistance := 0,
	                          ii_ExternalSpeed := 0,
	                          ix_SafetyOk := #ix_SafetyOk,
	                          ix_24vOk := #ix_24vOk,
	                          ix_400vOk := #ix_400vOk,
	                          ix_HardwareOk := TRUE,
	                          ix_PECEoS := #iqUDT_WorkstationStatus."230".PEC_EoS.PEC,
	                          ix_PECBoS := TRUE,
	                          ix_ReverseDirection := FALSE,
	                          ix_ExternalRequestDieBack := FALSE,
	                          ix_ExternalRequestHold := #sx_Hold230 OR #sx_ReleaseBinHoldLeft OR #sx_ReleaseBinHoldRight,
	                          ix_ResetEnergySave := FALSE,
	                          qUDT_HMIStatus => #iqUDT_WorkstationStatus."230".Conveyor,
	                          qUDT_Status => #iqUDT_WorkstationCommonStatus."230",
	                          iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                          iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."230".Conveyor,
	                          iqUDT_ConveyorInterface := #sUDT_Interface_230,
	                          iqUDT_HandShakeUp := #sUDT_Handshake_220,
	                          iqUDT_HandShake := #sUDT_Handshake_230,
	                          iqUDT_Statistics := #iqUDT_WorkstationStatistics."230".Conveyor);
	        
	    END_REGION
	    
	    REGION MCO
	        
	        #sFB_MCOConveyLinxAixController_230(iUDT_AixConfig := #iqUDT_Configuration."230".MCO_M01,
	                                            iUDT_AixInputsModule := #iUDT_MotorInput230,
	                                            ix_24vOk := #ix_24vOk,
	                                            ix_SimulationModeActive := "DB_Memory".Simulation,
	                                            ii_MotorPositionId := 1,
	                                            qUDT_HMIStatus => #iqUDT_WorkstationStatus."230".MCO_M01,
	                                            iqUDT_AixOutputsModule := #iqUDT_MotorOutput230,
	                                            iqUDT_ConveyorInterface := #sUDT_Interface_230,
	                                            iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."230".MCO_M01);
	    END_REGION
	    
	END_REGION
	
	REGION 240
	    
	    REGION Displacement
	        #sFB_Displacement240(#sUDT_Interface_240);
	    END_REGION
	    
	    REGION MCO
	        
	        #sFB_MCOConveyLinxAixController_240(iUDT_AixConfig := #iqUDT_Configuration."240".MCO_M01,
	                                            iUDT_AixInputsModule := #iUDT_MotorInput240,
	                                            ii_PositionSetpoint := #iqUDT_RATPositioning240.Lower.EndPosition,
	                                            ix_24vOk := #ix_24vOk,
	                                            ix_SimulationModeActive := "DB_Memory".Simulation,
	                                            ii_MotorPositionId := 1,
	                                            ix_StartPositioning := #iqUDT_RATPositioning240.Lower.Start,
	                                            ix_ResetPosition := #iqUDT_RATPositioning240.Lower.ResetPosition,
	                                            qUDT_HMIStatus => #iqUDT_WorkstationStatus."240".MCO_M01,
	                                            qx_Positioned => #iqUDT_RATPositioning240.Lower.Done,
	                                            iqUDT_AixOutputsModule := #iqUDT_MotorOutput240,
	                                            iqUDT_ConveyorInterface := #sUDT_Interface_240,
	                                            iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."240".MCO_M01);
	    END_REGION
	    
	END_REGION
	
	REGION 241
	    
	    REGION Displacement
	        #sFB_Displacement241(#sUDT_Interface_241);
	    END_REGION
	    
	    REGION RAT
	        
	        #sFB_RightAngledTransfer_241(iUDT_Configuration := #iqUDT_Configuration."241".RightAngledTransfer,
	                                     iUDT_LowerConveyorConfiguration := #iqUDT_Configuration."240".Conveyor,
	                                     iUDT_UpperConveyorConfiguration := #iqUDT_Configuration."241".Conveyor,
	                                     iUDT_PECConfiguration := #iqUDT_Configuration."240".PEC_EoS,
	                                     ii_DestinationA := #si_240DestinationA,
	                                     ii_DestinationB := #si_240DestinationB,
	                                     ii_DestinationC := #si_240DestinationC,
	                                     ii_DestinationD := #si_240DestinationD,
	                                     ix_HardwareOk := TRUE,
	                                     ix_400vOk := #ix_400vOk,
	                                     ix_24vOk := #ix_24vOk,
	                                     ix_SafetyOk := #ix_SafetyOk,
	                                     ix_AirPressureOk := #ix_AirPressureOk,
	                                     ix_SectionIsDown := #ix_SectionisDown241,
	                                     ix_SectionIsUp := #ix_SectionisUp241,
	                                     ix_ConveyorAAuto := #iqUDT_WorkstationCommonStatus."230".AutoON,
	                                     ix_ConveyorBAuto := #iqUDT_WorkstationCommonStatus."250".AutoON,
	                                     ix_ConveyorCAuto := #iqUDT_WorkstationCommonStatus."141".AutoON,
	                                     ix_ConveyorDAuto := #iqUDT_WorkstationCommonStatus."041".AutoON,
	                                     ix_PEC := #iUDT_MotorInput240.AllSensorPortInputs.LeftSensor,
	                                     ix_ExternalReceiveRequestA := NOT #iqUDT_WorkstationStatus."230".PEC_EoS.PEC AND #sx_Enable2X0In,
	                                     ix_ExternalReceiveRequestB := false,
	                                     ix_ExternalReceiveRequestC := #sFB_RightAngledTransfer_141.qx_ExternalSendRequestC,
	                                     ix_ExternalReceiveRequestD := #sFB_RightAngledTransfer_041.qx_ExternalSendRequestD,
	                                     ix_PECInfeedA := #iqUDT_WorkstationStatus."230".PEC_EoS.PEC,
	                                     ix_PECInfeedC := #iqUDT_WorkstationStatus."140".PEC_EoS.PEC,
	                                     ix_PECInfeedD := #iqUDT_WorkstationStatus."040".PEC_EoS.PEC,
	                                     qUDT_HMIRATStatus => #iqUDT_WorkstationStatus."241".RightAngledTransfer,
	                                     qUDT_HMIConveyorStatus => #iqUDT_WorkstationStatus."240".Conveyor,
	                                     qUDT_HMIPECStatus => #iqUDT_WorkstationStatus."240".PEC_EoS,
	                                     qUDT_RATStatus => #iqUDT_WorkstationCommonStatus."241",
	                                     qUDT_ConveyorStatus => #iqUDT_WorkstationCommonStatus."240",
	                                     qx_PopupControl => #qx_PopupControl241,
	                                     iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                                     iqUDT_RATCommand := #iqUDT_WorkstationCommands."241".RightAngledTransfer,
	                                     iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."240".Conveyor,
	                                     iqUDT_RATStatistics := #iqUDT_WorkstationStatistics."241".RightAngledTransfer,
	                                     iqUDT_ConveyorStatistics := #iqUDT_WorkstationStatistics."240".Conveyor,
	                                     iqUDT_PECStatistics := #iqUDT_WorkstationStatistics."240".PEC_EoS,
	                                     iqUDT_HandShakeConveyorA := #sUDT_Handshake_230,
	                                     iqUDT_HandShakeConveyorB := #sUDT_Handshake_240,
	                                     iqUDT_HandShakeConveyorC := #sUDT_Handshake_241,
	                                     iqUDT_HandShakeConveyorD := #sUDT_Handshake_041,
	                                     iqUDT_LowerConveyorInterface := #sUDT_Interface_240,
	                                     iqUDT_UpperConveyorInterface := #sUDT_Interface_241,
	                                     iqUDT_RATPositioning := #iqUDT_RATPositioning240,
	                                     iqUDT_BladeStopEoSInterface := #tUDT_DummyBladeStop,
	                                     iqUDT_BladeStopBoSInterface := #tUDT_DummyBladeStop);
	        
	    END_REGION
	    
	    REGION MCO
	        
	        #sFB_MCOConveyLinxAixController_241(iUDT_AixConfig := #iqUDT_Configuration."241".MCO_M01,
	                                            iUDT_AixInputsModule := #iUDT_MotorInput240,
	                                            ii_PositionSetpoint := #iqUDT_RATPositioning240.Upper.EndPosition,
	                                            ix_24vOk := #ix_24vOk,
	                                            ix_SimulationModeActive := "DB_Memory".Simulation,
	                                            ii_MotorPositionId := 2,
	                                            ix_StartPositioning := #iqUDT_RATPositioning240.Upper.Start,
	                                            ix_ResetPosition := #iqUDT_RATPositioning240.Upper.ResetPosition,
	                                            qUDT_HMIStatus => #iqUDT_WorkstationStatus."241".MCO_M01,
	                                            qx_Positioned => #iqUDT_RATPositioning240.Upper.Done,
	                                            iqUDT_AixOutputsModule := #iqUDT_MotorOutput240,
	                                            iqUDT_ConveyorInterface := #sUDT_Interface_241,
	                                            iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."241".MCO_M01);
	    END_REGION
	    
	END_REGION
	
	REGION 250
	    
	    REGION Displacement
	        #sFB_Displacement250(#sUDT_Interface_250);
	    END_REGION
	    
	    REGION Tracking
	        
	        #sFB_Tracking_250(iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."250".Conveyor.Common,
	                          iqa_TrackingData := #sa_TrackingArray_250,
	                          iqUDT_ConveyorInterface := #sUDT_Interface_250,
	                          iqUDT_HandshakeUp := #sUDT_Handshake_240,
	                          iqUDT_Handshake := #sUDT_Handshake_250);
	        
	    END_REGION
	    
	    REGION EoS
	        
	        #sFB_PECUpdate_250(iUDT_PECUpdateConfiguration := #iqUDT_Configuration."250".PEC_EoS,
	                           iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."250".Conveyor.Common,
	                           ix_PEC := #iUDT_MotorInput250.AllSensorPortInputs.LeftSensor,
	                           ix_TeachingMode := FALSE,
	                           qUDT_Status => #iqUDT_WorkstationStatus."250".PEC_EoS,
	                           iqUDT_ConveyorInterface := #sUDT_Interface_250,
	                           iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                           iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                           iqUDT_Statistics := #iqUDT_WorkstationStatistics."250".PEC_EoS,
	                           iqa_TrackingData := #sa_TrackingArray_250,
	                           iqa_FifoData := "DB_FIFOLostGIN".Data);
	        
	        
	        
	        
	    END_REGION
	    
	    REGION Conveyor
	        
	        #sFB_Conveyor_250(iUDT_ConveyorConfiguration := #iqUDT_Configuration."250".Conveyor,
	                          idi_PECEoSDistance := 0,
	                          idi_PECBoSDistance := 0,
	                          ii_ExternalSpeed := 0,
	                          ix_SafetyOk := #ix_SafetyOk,
	                          ix_24vOk := #ix_24vOk,
	                          ix_400vOk := #ix_400vOk,
	                          ix_HardwareOk := TRUE,
	                          ix_PECEoS := #iqUDT_WorkstationStatus."250".PEC_EoS.PEC,
	                          ix_PECBoS := TRUE,
	                          ix_ReverseDirection := FALSE,
	                          ix_ExternalRequestDieBack := FALSE,
	                          ix_ExternalRequestHold := FALSE,
	                          ix_ResetEnergySave := FALSE,
	                          qUDT_HMIStatus => #iqUDT_WorkstationStatus."250".Conveyor,
	                          qUDT_Status => #iqUDT_WorkstationCommonStatus."250",
	                          iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                          iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."250".Conveyor,
	                          iqUDT_ConveyorInterface := #sUDT_Interface_250,
	                          iqUDT_HandShakeUp := #sUDT_Handshake_240,
	                          iqUDT_HandShake := #sUDT_Handshake_250,
	                          iqUDT_Statistics := #iqUDT_WorkstationStatistics."250".Conveyor);
	        
	    END_REGION
	    
	    REGION MCO
	        
	        #sFB_MCOConveyLinxAixController_250(iUDT_AixConfig := #iqUDT_Configuration."250".MCO_M01,
	                                            iUDT_AixInputsModule := #iUDT_MotorInput250,
	                                            ix_24vOk := #ix_24vOk,
	                                            ix_SimulationModeActive := "DB_Memory".Simulation,
	                                            ii_MotorPositionId := 1,
	                                            qUDT_HMIStatus => #iqUDT_WorkstationStatus."250".MCO_M01,
	                                            iqUDT_AixOutputsModule := #iqUDT_MotorOutput250,
	                                            iqUDT_ConveyorInterface := #sUDT_Interface_250,
	                                            iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."250".MCO_M01);
	    END_REGION
	    
	END_REGION
	
	REGION 260
	    
	    REGION Displacement
	        #sFB_Displacement260(#sUDT_Interface_260);
	    END_REGION
	    
	    REGION Tracking
	        
	        #sFB_Tracking_260(iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."260".Conveyor.Common,
	                          iqa_TrackingData := #sa_TrackingArray_260,
	                          iqUDT_ConveyorInterface := #sUDT_Interface_260,
	                          iqUDT_HandshakeUp := #sUDT_Handshake_250,
	                          iqUDT_Handshake := #sUDT_Handshake_260);
	        
	    END_REGION
	    
	    REGION EoS
	        
	        #sFB_PECUpdate_260(iUDT_PECUpdateConfiguration := #iqUDT_Configuration."260".PEC_EoS,
	                           iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."260".Conveyor.Common,
	                           ix_PEC := #iUDT_MotorInput250.AllSensorPortInputs.RightSensor,
	                           ix_TeachingMode := FALSE,
	                           qUDT_Status => #iqUDT_WorkstationStatus."260".PEC_EoS,
	                           iqUDT_ConveyorInterface := #sUDT_Interface_260,
	                           iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                           iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                           iqUDT_Statistics := #iqUDT_WorkstationStatistics."260".PEC_EoS,
	                           iqa_TrackingData := #sa_TrackingArray_260,
	                           iqa_FifoData := "DB_FIFOLostGIN".Data);
	        
	        
	        
	        
	    END_REGION
	    
	    REGION Conveyor
	        
	        #sFB_Conveyor_260(iUDT_ConveyorConfiguration := #iqUDT_Configuration."260".Conveyor,
	                          idi_PECEoSDistance := 0,
	                          idi_PECBoSDistance := 0,
	                          ii_ExternalSpeed := 0,
	                          ix_SafetyOk := #ix_SafetyOk,
	                          ix_24vOk := #ix_24vOk,
	                          ix_400vOk := #ix_400vOk,
	                          ix_HardwareOk := TRUE,
	                          ix_PECEoS := #iqUDT_WorkstationStatus."260".PEC_EoS.PEC,
	                          ix_PECBoS := TRUE,
	                          ix_ReverseDirection := FALSE,
	                          ix_ExternalRequestDieBack := FALSE,
	                          ix_ExternalRequestHold := FALSE,
	                          ix_ResetEnergySave := FALSE,
	                          qUDT_HMIStatus => #iqUDT_WorkstationStatus."260".Conveyor,
	                          qUDT_Status => #iqUDT_WorkstationCommonStatus."260",
	                          iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                          iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."260".Conveyor,
	                          iqUDT_ConveyorInterface := #sUDT_Interface_260,
	                          iqUDT_HandShakeUp := #sUDT_Handshake_250,
	                          iqUDT_HandShake := #sUDT_Handshake_260,
	                          iqUDT_Statistics := #iqUDT_WorkstationStatistics."260".Conveyor);
	        
	    END_REGION
	    
	    REGION MCO
	        
	        #sFB_MCOConveyLinxAixController_260(iUDT_AixConfig := #iqUDT_Configuration."260".MCO_M01,
	                                            iUDT_AixInputsModule := #iUDT_MotorInput250,
	                                            ix_24vOk := #ix_24vOk,
	                                            ix_SimulationModeActive := "DB_Memory".Simulation,
	                                            ii_MotorPositionId := 2,
	                                            qUDT_HMIStatus => #iqUDT_WorkstationStatus."260".MCO_M01,
	                                            iqUDT_AixOutputsModule := #iqUDT_MotorOutput250,
	                                            iqUDT_ConveyorInterface := #sUDT_Interface_260,
	                                            iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."260".MCO_M01);
	    END_REGION
	    
	END_REGION
	
	REGION 270
	    
	    REGION Displacement
	        #sFB_Displacement270(#sUDT_Interface_270);
	    END_REGION
	    
	    REGION Tracking
	        
	        #sFB_Tracking_270(iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."270".Conveyor.Common,
	                          iqa_TrackingData := #sa_TrackingArray_270,
	                          iqUDT_ConveyorInterface := #sUDT_Interface_270,
	                          iqUDT_HandshakeUp := #sUDT_Handshake_260,
	                          iqUDT_Handshake := #iqUDT_HandshakeDownstream270);
	        
	    END_REGION
	    
	    REGION EoS
	        
	        #sFB_PECUpdate_270(iUDT_PECUpdateConfiguration := #iqUDT_Configuration."270".PEC_EoS,
	                           iUDT_ConveyorCommonConfiguration := #iqUDT_Configuration."270".Conveyor.Common,
	                           ix_PEC := #iUDT_MotorInput270.AllSensorPortInputs.LeftSensor,
	                           ix_TeachingMode := FALSE,
	                           qUDT_Status => #iqUDT_WorkstationStatus."270".PEC_EoS,
	                           iqUDT_ConveyorInterface := #sUDT_Interface_270,
	                           iqUDT_UnknownGINRange := #iqUDT_UnknownGINRange,
	                           iqUDT_FifoHeader := "DB_FIFOLostGIN".Header,
	                           iqUDT_Statistics := #iqUDT_WorkstationStatistics."270".PEC_EoS,
	                           iqa_TrackingData := #sa_TrackingArray_270,
	                           iqa_FifoData := "DB_FIFOLostGIN".Data);
	        
	    END_REGION
	    
	    REGION Conveyor
	        
	        #iqUDT_HandshakeDownstream270.RTR := #iqUDT_HandshakeDownstream270.RTR OR #iqUDT_WorkstationStatus."270".PEC_EoS.PEC;
	        
	        #sFB_Conveyor_270(iUDT_ConveyorConfiguration := #iqUDT_Configuration."270".Conveyor,
	                          idi_PECEoSDistance := #iqUDT_Configuration."270".PEC_EoS.Distance,
	                          idi_PECBoSDistance := 0,
	                          ii_ExternalSpeed := 0,
	                          ix_SafetyOk := #ix_SafetyOk,
	                          ix_24vOk := #ix_24vOk,
	                          ix_400vOk := #ix_400vOk,
	                          ix_HardwareOk := TRUE,
	                          ix_PECEoS := #iqUDT_WorkstationStatus."270".PEC_EoS.PEC,
	                          ix_PECBoS := TRUE,
	                          ix_ReverseDirection := FALSE,
	                          ix_ExternalRequestDieBack := FALSE,
	                          ix_ExternalRequestHold := FALSE,
	                          ix_ResetEnergySave := FALSE,
	                          qUDT_HMIStatus => #iqUDT_WorkstationStatus."270".Conveyor,
	                          qUDT_Status => #iqUDT_WorkstationCommonStatus."270",
	                          iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                          iqUDT_ConveyorCommand := #iqUDT_WorkstationCommands."270".Conveyor,
	                          iqUDT_ConveyorInterface := #sUDT_Interface_270,
	                          iqUDT_HandShakeUp := #sUDT_Handshake_260,
	                          iqUDT_HandShake := #iqUDT_HandshakeDownstream270,
	                          iqUDT_Statistics := #iqUDT_WorkstationStatistics."270".Conveyor);
	        
	    END_REGION
	    
	    REGION MCO
	        
	        #sFB_MCOConveyLinxAixController_270(iUDT_AixConfig := #iqUDT_Configuration."270".MCO_M01,
	                                            iUDT_AixInputsModule := #iUDT_MotorInput270,
	                                            ix_24vOk := #ix_24vOk,
	                                            ix_SimulationModeActive := "DB_Memory".Simulation,
	                                            ii_MotorPositionId := 1,
	                                            qUDT_HMIStatus => #iqUDT_WorkstationStatus."270".MCO_M01,
	                                            iqUDT_AixOutputsModule := #iqUDT_MotorOutput270,
	                                            iqUDT_ConveyorInterface := #sUDT_Interface_270,
	                                            iqUDT_MCOStatistics := #iqUDT_WorkstationStatistics."270".MCO_M01);
	    END_REGION
	    
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_PushUpDivert"
TITLE = FB_PushUpDivert
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 199
// END_ATTRIBUTES
//Function to control a divert left/right/straight. A product is diverted based on GIN data. A conveyor, part of the diverter, will move up or down to change the direction. Moving up and down control is done by this block.
   VAR_INPUT 
      iUDT_DivertConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PushUpDivertConfiguration";   // Configuration structure
      ii_Gin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Gin found by position block
      ii_DisplacementLower { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Actual displacement of the lower conveyor
      ii_DisplacementUpper { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Actual displacement of the upper conveyor
      ix_AirPressureOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Air pressure circuit healthy
      ix_SafetyOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when safety is ok
      ix_24vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 24VDC is healthy
      ix_400vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 400VAC is healthy
      ix_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when  hardware is Ok
      ix_PecTrigger { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when trigger is not occupied
      ix_PECLeft { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when left outfeed PEC is not occupied
      ix_PECRight { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when right outfeed PEC is not occupied
      ix_SectionIsUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when section is up
      ix_SectionIsDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when section is down
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PushUpDivertStatus";   // HMI status structure
      qUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   // Common status structure
      qUDT_LowerConveyorInterface { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Interface lower conveyor
         Hold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Hold the conveyor
         RunFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Run conveyor forward
         RunRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Run conveyor reverse
      END_STRUCT;
      qUDT_UpperConveyorInterface { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Interface upper conveyor
         Hold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Hold the conveyor
         RunFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Run conveyor forward
         RunRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Run conveyor reverse
      END_STRUCT;
      qx_SectionUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Output to control section up
      qx_SectionDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Output to control section down
   END_VAR

   VAR_IN_OUT 
      iqa_TrackingMainData : Array[*] of Int;   // Data tracking main conveyor
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
      iqUDT_DivertCommand : "UDT_PushUpDivertCommand";   // Conveyor command stucture
      iqUDT_Statistics : "UDT_ConveyorStatistics";   // Statistics structure
      iqUDT_HandShakeLowerConveyor : "UDT_ConveyorHandshake";
      iqUDT_HandShakeUpperConveyor : "UDT_ConveyorHandshake";
      iqUDT_HandShakeLeftConveyor : "UDT_ConveyorHandshake";   // Handshake structure in forward direction left
      iqUDT_HandShakerightConveyor : "UDT_ConveyorHandshake";   // Handshake structure in reverse direction right
      iqi_RequestedPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Handshake requested position from destination block
   END_VAR

   VAR 
      sUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Common status structure
      sFB_PECTriggerOnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer to filter PEC signal
      sFB_PECLeftOnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer to filter PEC signal
      sFB_PECRightOnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer to filter PEC signal
      sFB_UpMonitor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer to monitor divert took too long to move to upper position
      sFB_DownMonitor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sR_TRIG_ManualMode {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger manual mode
      sF_TRIG_ManualMode {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger manual mode
      sR_TRIG_PrestartManual {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge of manual prestart
      sR_TRIG_RunManual {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge run conveyor in manual mode
      sR_TRIG_ManualGoUp {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge run conveyor in manual mode
      sR_TRIG_ManualGoDown {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger manual jog
      sF_TRIG_Jog {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger manual mode jog
      sR_TRIG_PECLeft {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger PEC left outfeed side
      sR_TRIG_PECRight {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger PEC right outfeed side
      sR_TRIG_DeviceUpTime {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger device up time
      sR_TRIG_DeviceStopped {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge of stop
      sR_TRIG_DeviceDownTime {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger device down
      sdi_Divertposition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Calculated: position in tracking to initiate divert
      si_Gin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // New GIN found
      si_length { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length of the parcel
      si_Direction { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Direction from decisionpoint
      si_OldDirection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Last direction from decisionpoint
      si_Position { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Position counter
      sx_PECTriggerFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Signal filtered with on and off delay
      sx_PECLeftFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Signal filtered with on and off delay
      sx_PECRightFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Signal filtered with on and off delay
      sx_Active { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Divert sequence is activated for parcel
      sx_MoveSectionUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Step move divert to upper position
      sx_MoveSectionDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Step move divert to lower position
      sx_TransportActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Step transport is activated
      sx_Ready { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor Ready to operate in Automatic mode
      sx_AutomaticActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Running in automatic
      sx_PreStartManual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Pre conditions to run conveyor in manual mode
      sx_ManualModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual mode active
      sx_ManualRunning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor running in manual mode
      sx_ManualGoUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual control go Up
      sx_ManualGoDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual control go down
      sx_ManUP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual go up
      sx_ManDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual go down
      sx_ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Commissioning: configuration of parameters is wrong
      sx_LeftRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request left outfeed position for actual parcel
      sx_RightRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request right outfeed position for actual parcel
      sx_DivertUpRunTimeErr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // It is taking too long to move divert up
      sx_DivertDownRunTimeErr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // It is taking too long to move divert down
      sx_UpTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Device is up
      sx_DownTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Device is down
      sx_StoppedTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Device is stopped
   END_VAR

   VAR_TEMP 
      ta_ConfigErr : Array[0..10] of Bool;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	13/02/2023  | 1.0       | F.Baten       | Initial version
	*)
	
	REGION 1 - Initial
	    REGION 1.1 - First PLC cycle
	        
	        IF "DB_Memory".FirstScan
	        THEN
	            #sx_AutomaticActive := FALSE;                               // switch of automatic active
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 1.2 - Triggers
	        
	        // Rising edge trigger manual mode
	        #sR_TRIG_ManualMode(CLK := #iqUDT_DivertCommand.ManualMode
	                            OR #iqUDT_EquipmentControl.Command.ManualMode);
	        
	        // Falling edge trigger manual mode
	        #sF_TRIG_ManualMode(CLK := #iqUDT_DivertCommand.ManualMode
	                            OR #iqUDT_EquipmentControl.Command.ManualMode);
	        
	        // Rising edge trigger PEC Left side
	        #sR_TRIG_PECLeft(CLK := #sx_PECLeftFiltered);
	        
	        // Rising edge trigger PEC right side
	        #sR_TRIG_PECRight(CLK := #sx_PECRightFiltered);
	        
	        // Rising edge trigger to start in manual mode
	        #sR_TRIG_RunManual(CLK := #iqUDT_DivertCommand.ManualStartStop);
	        
	        // Rising edge trigger to go up in manual mode
	        #sR_TRIG_ManualGoUp(CLK := #iqUDT_DivertCommand.ManualUp);
	        
	        // Rising edge trigger to go down in manual mode
	        #sR_TRIG_ManualGoDown(CLK := #iqUDT_DivertCommand.ManualDown);
	        
	        // Rising edge equipment uptime
	        #sR_TRIG_DeviceUpTime(CLK := #sx_UpTime);
	        
	        //Rising edge equipment stopped
	        #sR_TRIG_DeviceStopped(CLK := #sx_StoppedTime);
	        
	        // Rising edge equipment conveyor downtime
	        #sR_TRIG_DeviceDownTime(CLK := #sx_DownTime);
	    END_REGION
	    
	    REGION 1.3 - Timers
	        // Statement section REGION
	        #sFB_PECTriggerOnOffDelay(iudi_OnDelayTime := #iUDT_DivertConfiguration.PECTriggerTimeOnDelay,      // Off delay time to filter PEC signal
	                                  iudi_OffDelayTime := #iUDT_DivertConfiguration.PECTriggerTimeOffDelay,    // On delay time to filter PEC signal
	                                  ix_SignalToDelay := #ix_PecTrigger,                                       // PEC input signal
	                                  ix_Enable := TRUE,
	                                  qx_DelayedSignal => #sx_PECTriggerFiltered);                              // PEC signal filtered
	        
	        #sFB_PECLeftOnOffDelay(iudi_OnDelayTime := #iUDT_DivertConfiguration.PECLeftTimeOnDelay,            // Off delay time to filter PEC signal
	                               iudi_OffDelayTime := #iUDT_DivertConfiguration.PECLeftTimeOffDelay,          // On delay time to filter PEC signal
	                               ix_SignalToDelay := #ix_PECLeft,                                             // PEC input signal
	                               ix_Enable := TRUE,
	                               qx_DelayedSignal => #sx_PECLeftFiltered);                                    // PEC signal filtered
	        
	        #sFB_PECRightOnOffDelay(iudi_OnDelayTime := #iUDT_DivertConfiguration.PECRightTimeOnDelay,          // Off delay time to filter PEC signal
	                                iudi_OffDelayTime := #iUDT_DivertConfiguration.PECRightTimeOffDelay,        // On delay time to filter PEC signal
	                                ix_SignalToDelay := #ix_PECRight,                                           // PEC input signal
	                                ix_Enable := TRUE,
	                                qx_DelayedSignal => #sx_PECRightFiltered);                                  // PEC signal filtered
	        
	        #sFB_UpMonitor(iudi_OnDelayTime := #iUDT_DivertConfiguration.DivertMonitorUpOnDelay,                // Off delay time
	                       iudi_OffDelayTime := #iUDT_DivertConfiguration.DivertMonitorUPOffDelay,              // On delay time
	                       ix_SignalToDelay := #sx_AutomaticActive
	                       AND #sx_MoveSectionUp
	                       AND NOT #ix_SectionIsUp,                                                             // input signal
	                       ix_Enable := TRUE,
	                       qx_DelayedSignal => #sx_DivertUpRunTimeErr);                                         // signal filtered
	        
	        #sFB_DownMonitor(iudi_OnDelayTime := #iUDT_DivertConfiguration.DivertMonitorDownOnDelay,            // Off delay time to filter PEC signal
	                         iudi_OffDelayTime := #iUDT_DivertConfiguration.DivertMonitorDownOffDelay,          // On delay time to filter PEC signal
	                         ix_SignalToDelay := #sx_AutomaticActive
	                         AND #sx_MoveSectionDown
	                         AND NOT #ix_SectionIsDown,                                                         // PEC input signal
	                         ix_Enable := TRUE,
	                         qx_DelayedSignal => #sx_DivertDownRunTimeErr);                                     // PEC signal filtered
	        
	    END_REGION
	    
	    REGION 1.4 - Conditions Up - Down - Stopped
	        //Used for statistics
	        
	        #sx_UpTime := (#sx_AutomaticActive                              // Automatic active
	        AND #sx_Ready);                                                 // Ready active
	        
	        #sx_DownTime := (NOT #sx_ManualModeActive                       // Not in manual mode
	        AND #sUDT_Status.Error                                          // in error 
	        AND NOT #sx_Ready);                                             // Conveyor not ready
	        
	        #sx_StoppedTime := (NOT #sx_AutomaticActive AND #sx_Ready);
	        
	    END_REGION
	    
	END_REGION
	
	REGION 2 - Errors
	    
	    REGION 2.1 - Reset errors
	        
	        IF #iqUDT_EquipmentControl.Command.Reset                        // Reset
	        THEN
	            
	            IF #qUDT_HMIStatus.Specific.ErrRuntime                      // It took too long to move divert up or down
	            THEN
	                
	                #qUDT_HMIStatus.Specific.ErrRuntime := FALSE;           // reset error
	                
	            END_IF;
	            
	            IF #qUDT_HMIStatus.Specific.ErrAirpressureNotOk             // Airpressure is not ok
	            THEN
	                
	                #qUDT_HMIStatus.Specific.ErrAirpressureNotOk := FALSE;  // reset error
	                
	            END_IF;
	            
	            IF #qUDT_HMIStatus.Specific.ErrOverrun                      // It took too long to move divert up or down
	            THEN
	                
	                #qUDT_HMIStatus.Specific.ErrOverrun := FALSE;           // reset error
	                
	            END_IF;
	            
	            IF #sx_DivertUpRunTimeErr                                   // It took too long to move up
	                AND #sx_MoveSectionUp                                   // It took too long to move down
	            THEN
	                #si_Gin := 0;                                           // Reset the GIN to write 
	                #sx_MoveSectionDown := TRUE;                            // Set move down
	                #sx_MoveSectionUp := FALSE;                             // Reset move up
	            END_IF;
	            
	            IF #sx_DivertUpRunTimeErr                                   // It took too long to move up
	                AND #sx_MoveSectionDown                                 // It took too long to move down
	            THEN
	                #sx_MoveSectionDown := FALSE;
	            END_IF;
	        END_IF;
	    END_REGION
	    
	    REGION 2.2 - Set errors
	        
	        // Runtime delay error
	        IF #sx_DivertUpRunTimeErr                                       // It took too long to move up
	            OR #sx_DivertDownRunTimeErr                                 // It took too long to move down
	        THEN
	            
	            #qUDT_HMIStatus.Specific.ErrRuntime := TRUE;                // Set error runtime error
	        END_IF;
	        
	        // Airpressure not ok
	        IF NOT #ix_AirPressureOk                                        // Airpressure is not signalling              
	            AND (#sx_LeftRequest OR #sx_RightRequest)                   // If there is request to move to the left or right position      
	        THEN
	            #qUDT_HMIStatus.Specific.ErrAirpressureNotOk := TRUE;       // Set error airpressure
	        END_IF;
	        
	        // configuration errors
	        #ta_ConfigErr[1] := #iUDT_DivertConfiguration."Conveyor length" = 0;
	        #ta_ConfigErr[2] := #iUDT_DivertConfiguration.ParcelDefaultLength = 0;
	        
	        #sx_ConfigurationError := #iUDT_DivertConfiguration.SizeDivert  // Set the configuration error bit (No status!!)
	        AND (#ta_ConfigErr[1] OR #ta_ConfigErr[2]);
	        
	        
	    END_REGION
	    
	    REGION 2.3 - Warning
	        
	        #qUDT_HMIStatus.Specific.WarnAirPressure := NOT #ix_AirPressureOk;  // Airpressure is not signalling
	        
	    END_REGION
	    
	    
	    REGION 2.4 - Common Error
	        
	        #sUDT_Status.Error := #qUDT_HMIStatus.Specific.ErrRuntime                              // Direction verification found the Direction fault, stop the parcel
	        OR #qUDT_HMIStatus.Specific.ErrAirpressureNotOk                     // Upper jam PEC detected WHILE going Up
	        OR #qUDT_HMIStatus.Specific.ErrOverrun                              // Parcel travelled too far to divert
	        OR #sx_ConfigurationError;                                          // Configuration error, check values
	        
	    END_REGION
	    
	    REGION 2.5 - Common Warning
	        
	        #sUDT_Status.Warning := #qUDT_HMIStatus.Specific.WarnAirPressure;   // Airpressure is not signalling
	        
	    END_REGION
	    
	END_REGION
	
	REGION 3 - Check conditions to set Equipment ready
	    
	    //Conditions to set bit sx_Ready to operate 
	    
	    #sx_Ready := NOT #sUDT_Status.Error                                 // Error present
	    AND #ix_SafetyOk                                                    // Safety signalling OK
	    AND #ix_24vOk                                                       // 24V signalling OK
	    AND #ix_400vOk;                                                     // 400v signalling OK 
	    
	END_REGION
	
	REGION 4 - Stop Equipment
	    
	    // Conditions to stop conveyor
	    IF (#sF_TRIG_Jog.Q                                                  // Trigger when conveyor stops jogging by HMI
	        AND #sx_ManualModeActive)                                       // Manual mode is active
	        
	        OR (NOT #iqUDT_EquipmentControl.Command.AutomaticOn             // Conveyor stops if the bit AutomaticOn from control block is false
	        AND NOT #sx_ManualModeActive)                                   // Manual mode active bit
	        
	        OR (NOT #sx_Ready                                               // Bit conveyor ready to run in automatic mode
	        AND NOT #sx_ManualModeActive)                                   // Manual mode active
	        
	        OR #sR_TRIG_ManualMode.Q                                        // Trigger when manual mode is set on
	        OR #sF_TRIG_ManualMode.Q                                        // Trigger when manual mode is set off
	        
	        OR NOT #ix_SafetyOk
	        
	    THEN
	        //  Order to stop VFD
	        
	        #sx_AutomaticActive := FALSE;                                   // Automatic mode is disable
	        
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Start
	    
	    REGION 5.1 - Set Automatic active
	        
	        // The conditions to set the bit "startReceived" are: 
	        // - Divert not in manual mode.
	        // - Divert ready to run.
	        // - Bit AutomaticOn from control block must be on.
	        // - Bit start form control block on.
	        
	        IF #iqUDT_EquipmentControl.Command.Start
	            AND #iqUDT_EquipmentControl.Command.AutomaticOn
	            AND NOT #sx_ManualModeActive
	            AND #sx_Ready
	        THEN
	            #sx_AutomaticActive := TRUE;                                // Diverter active automatic mode
	        END_IF;
	        
	    END_REGION
	    
	    REGION 5.2 - Restart request
	        #iqUDT_EquipmentControl.Request.RestartRequired := NOT #sx_AutomaticActive
	        AND NOT #sx_ManualModeActive
	        AND #sx_Ready;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 6 - Manual mode
	    
	    REGION 6.1 - Manual mode force disable
	        
	        // Manual mode bits inputs can be reset in case of malfunction
	        IF #iqUDT_EquipmentControl.Command.DisableManualMode
	        THEN
	            #iqUDT_DivertCommand.ManualMode := FALSE;
	            #iqUDT_EquipmentControl.Command.ManualMode := False;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 6.2 - Manual mode activation 
	        
	        // Manual mode is active if it is active from hmi or by control block  
	        #sx_ManualModeActive := #iqUDT_EquipmentControl.Command.ManualMode
	        OR #iqUDT_DivertCommand.ManualMode;
	        
	    END_REGION
	    
	    REGION 6.3 - Reset manual commands 
	        //When the system is not any more in manual mode or when fatal error occurs the HMI commands should be reset
	        IF NOT #ix_SafetyOk
	            OR NOT #ix_24vOk                                            // 24V error status
	            OR NOT #ix_400vOk                                           // 400V error status
	            OR NOT #ix_HardwareOk                                       // Profinet error status
	            OR NOT #sx_ManualModeActive
	        THEN
	            #iqUDT_DivertCommand.ManualDown := FALSE;
	            #iqUDT_DivertCommand.ManualUp := FALSE;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 6.4 - Start/Stop
	        
	        // Pre start conditions to run in manual mode
	        #sx_PreStartManual := #sx_ManualModeActive                      // Manual mode active bit
	        AND #ix_SafetyOk                                                // Safety healthy bit
	        AND #ix_HardwareOk;                                             // Profinet comunication 
	        
	        
	        
	        #sR_TRIG_PrestartManual(CLK := #sx_PreStartManual);
	        // If manual command is active to one side, first button ha sto be released to accept new
	        #sx_ManUP := (#sR_TRIG_ManualGoUp.Q AND NOT #sx_ManDown) OR
	        (#sx_ManUP AND #iqUDT_DivertCommand.ManualUp);
	        
	        #sx_ManDown := (#sR_TRIG_ManualGoDown.Q AND NOT #sx_ManUP) OR
	        (#sx_ManDown AND #iqUDT_DivertCommand.ManualDown);
	        
	        // Do signal request (horn sounding before movement)
	        IF #sx_PreStartManual                                           // Pre start conditions to run in manual mode
	            AND (#sR_TRIG_ManualGoUp.Q AND #sx_ManUP)                   // Trigger when conveyor start running in manual mode
	            OR (#sR_TRIG_ManualGoDown.Q AND #sx_ManDown)
	        THEN
	            
	            #iqUDT_EquipmentControl.Request.SignalingRequest := TRUE;   // Request signaling to control block before conveyor run in manual mode
	            
	        END_IF;
	        
	        // Go up in manual mode
	        #sx_ManualGoUp := #sx_PreStartManual                            // Pre start conditions to run in manual mode
	        AND (NOT #iqUDT_EquipmentControl.Request.SignalingRequest       // Signaling request done
	        OR #sx_ManualRunning)
	        AND #sx_ManUP;                                                  // Manual mode start TO run
	        
	        // Go down in manual mode
	        #sx_ManualGoDown := #sx_PreStartManual                          // Pre start conditions to run in manual mode
	        AND (NOT #iqUDT_EquipmentControl.Request.SignalingRequest       // Signaling request done
	        OR #sx_ManualRunning)
	        AND #sx_ManDown;                                                // Manual mode start to run
	        
	        #sx_ManualRunning := #sx_ManualGoUp
	        OR #sx_ManualGoDown;
	        
	    END_REGION
	END_REGION
	
	REGION 7 - Automatic mode
	    
	    REGION 7.1 - Direction from decision point
	        IF #iqi_RequestedPosition <> 0 AND NOT (#sx_LeftRequest OR #sx_RightRequest)                                 // Position is received from decision block
	        THEN
	            #si_Direction := #iqi_RequestedPosition;                    // Copy the input to the memory
	            #si_Gin := #ii_Gin;                                         // Copy the found GIN number
	            #si_OldDirection := #si_Direction;
	            // As we found a divert decision we need to calculate the divert position if its based on position and not time
	            // 
	            IF #iUDT_DivertConfiguration.SizeDivert
	            THEN
	                // Divert position is center of the divert section + half of the parcel. 
	                // 
	                #si_length := "DB_GIN".GIN[#si_Gin].General.Length;
	                IF #si_length <= 0 THEN
	                    #si_length := #iUDT_DivertConfiguration.ParcelDefaultLength;
	                END_IF;
	                
	                // Use dimension of parcel in GIN record 
	                #sdi_Divertposition := (((#iUDT_DivertConfiguration."Conveyor length" / 10) - (#si_length)) / 2) + #iUDT_DivertConfiguration.PositionOffset;
	                
	            END_IF;
	            
	            #iqi_RequestedPosition := 0;                                // Reset requested position again as all is handled
	            
	        END_IF;
	    END_REGION
	    
	    REGION 7.2 - Position left / right / straight on            
	        // 1 = Left, 2 = Right and 99 = Default 
	        // 
	        IF #si_Direction = 1                                            // If the position "left" is equal to the request 
	            AND #sx_Ready                                               // Ready to operate, No errors active
	            AND #sx_AutomaticActive                                     // Automaticly started
	        THEN
	            #sx_RightRequest := FALSE;                                  // Reset right command
	            #sx_LeftRequest := TRUE;                                    // Set left command
	            #si_Position := 0;                                          // Reset position
	            #si_Direction := 0;                                         // Reset the memory
	        END_IF;
	        
	        IF #si_Direction = 2                                            // If the position "right" is equal to the request 
	            AND #sx_Ready                                               // Ready to operate, No errors active
	            AND #sx_AutomaticActive                                     // Automaticly started
	        THEN
	            #sx_RightRequest := TRUE;                                   // Set right command
	            #sx_LeftRequest := FALSE;                                   // Reset left command
	            #si_Position := 0;                                          // Reset position
	            #si_Direction := 0;                                         // Reset the memory
	        END_IF;
	        
	        IF #si_Direction = 99                                           // If the position "straight" is equal to the request 
	            AND #sx_Ready                                               // Ready to operate, No errors active
	            AND #sx_AutomaticActive                                     // Automaticly started
	        THEN
	            #si_Direction := 0;                                         // Reset the memory
	        END_IF;
	    END_REGION
	    
	    REGION 7.3 - Sequence
	        REGION 7.3.1 - Sequence step 1: move up
	            
	            // Once decided to go left or right the diverter has to move to upper position when the parcel is in divert position
	            
	            IF #sx_AutomaticActive                                      // The divert is automaticly started
	                AND #sx_Ready                                           // Ready to run / no errors
	                AND (#sx_LeftRequest OR #sx_RightRequest)               // If there is request to move to the left or right position 
	                AND NOT #ix_SectionIsUp                                 // And not in upper position
	                AND NOT #sx_Active                                      // Sequence is not yet activated
	                AND ((NOT #iUDT_DivertConfiguration.SizeDivert          // Not diverting on parcel size but on PEC                          
	                AND (#si_Position >= #iUDT_DivertConfiguration.LengthIn)) // NOT diverting on parcel size but on PEC
	                OR (#iUDT_DivertConfiguration.SizeDivert                // Diverting on parcel size
	                AND (#iqa_TrackingMainData[#sdi_Divertposition] = #si_Gin
	                AND #iqa_TrackingMainData[#sdi_Divertposition] <> 0))  // GIN at divertposition
	                OR (#si_Position >= #iUDT_DivertConfiguration."Conveyor length"))
	            THEN
	                #sx_Active := TRUE;                                 // Sequence is activated
	                #sx_MoveSectionUp := TRUE;                          // Set position to be 1 = Up
	            END_IF;
	            
	            IF #sx_AutomaticActive                                      // The divert is automaticly started
	                AND #sx_Ready                                           // Ready to run / no errors
	                AND (#sx_LeftRequest OR #sx_RightRequest)               // If there is request to move to the left or right position 
	                AND NOT #ix_SectionIsUp                                 // And not in upper position
	                AND NOT #sx_Active                                      // Sequence is not yet activated
	                AND ((#si_Position >= #iUDT_DivertConfiguration."Conveyor length")
	                )
	            THEN
	                #qUDT_HMIStatus.Specific.ErrOverrun := True;        // Set error, parcel went too far and can not be deverted (Stop main conveyor)
	                #sx_MoveSectionDown := FALSE;                           // Reset move down
	                #sx_LeftRequest := FALSE;                               // Reset requests fom position 
	                #sx_RightRequest := FALSE;                              // Reset requests fom position 
	                #sx_Active := FALSE;                                    // End of sequence
	            END_IF;
	        END_REGION
	        
	        REGION 7.3.2 - Sequence step 2: start transport in desired direction
	            
	            // As the divert is up, the transport will start
	            
	            IF #sx_AutomaticActive                                      // The divert is automaticly started
	                AND #sx_Ready                                           // Ready to run / no errors
	                AND #sx_MoveSectionUp                                   // Step move section up
	                AND #ix_SectionIsUp                                     // And in upper position
	            THEN
	                
	                FILL_BLK(IN := 0,                                       // Clear tracking area for divert on main conveyor 
	                         COUNT := DINT_TO_ULINT(#iUDT_DivertConfiguration."Conveyor length" / 10),
	                         OUT => #iqa_TrackingMainData[0]);
	                
	                #sx_TransportActive := TRUE;                            // Set transport
	                #sx_MoveSectionUp := FALSE;                             // Reset move up
	                #si_Position := 0;                                      // Reset position
	                
	            END_IF;
	        END_REGION
	        
	        REGION 7.3.3 - Sequence step 3: Parcel transport finished, move down
	            
	            // The transport has cleared the photoeye on the downstream conveyor, move down
	            
	            IF #sx_AutomaticActive                                      // The divert is automaticly started
	                AND #sx_Ready                                           // Ready to run / no errors
	                AND #sx_TransportActive                                 // Step transport parcel
	                AND ((NOT #iUDT_DivertConfiguration.SizeDivert          // Not diverting on parcel size but on PEC                          
	                AND (#si_Position >= #iUDT_DivertConfiguration.LengthOut)) // NOT diverting on parcel size but on PEC
	                OR
	                (#iUDT_DivertConfiguration.SizeDivert                   // Diverting on parcel size
	                AND ((#sx_LeftRequest AND #sR_TRIG_PECLeft.Q)           // Active transport to left, parcel cleared PEC
	                OR (#sx_RightRequest AND #sR_TRIG_PECRight.Q))          // Active transport to right, parcel cleared PEC
	                OR (#si_Position >= #iUDT_DivertConfiguration.LengthOut)))
	            THEN
	                #si_Gin := 0;                                           // Reset the GIN to write
	                #sx_MoveSectionDown := TRUE;                            // Set move down
	                #sx_TransportActive := FALSE;                           // Reset transport 
	                
	            END_IF;
	        END_REGION
	        
	        REGION 7.3.4 - Sequence step 4: Divert is down
	            
	            // The divert is down now reset requests
	            
	            IF #sx_AutomaticActive                                      // The divert is automaticly started
	                AND #sx_Ready                                           // Ready to run / no errors
	                AND #sx_MoveSectionDown                                 // Step transport parcel
	                AND #ix_SectionIsDown
	            THEN
	                #sx_MoveSectionDown := FALSE;                           // Reset move down
	                #sx_LeftRequest := FALSE;                               // Reset requests fom position 
	                #sx_RightRequest := FALSE;                              // Reset requests fom position 
	                #sx_Active := FALSE;                                    // End of sequence
	            END_IF;
	        END_REGION
	    END_REGION
	    
	    REGION 7.4 - Calculate position
	        // When transport is active displacement is added to position counter 
	        
	        IF NOT #sx_PECTriggerFiltered
	            AND (#sx_LeftRequest OR #sx_RightRequest)
	            AND (#qUDT_LowerConveyorInterface.RunFwd OR #qUDT_LowerConveyorInterface.RunRvs)
	        THEN
	            #si_Position += ABS(#ii_DisplacementLower);
	        END_IF;
	        
	        IF #sx_PECTriggerFiltered
	            AND (#qUDT_UpperConveyorInterface.RunFwd OR #qUDT_UpperConveyorInterface.RunRvs)
	        THEN
	            #si_Position += ABS(#ii_DisplacementUpper);
	        END_IF;
	    END_REGION
	END_REGION
	
	REGION 8 - Outputs
	    // Statement section REGION
	    
	    REGION 8.1 - Lifting device
	        
	        #qx_SectionDown := (#sx_AutomaticActive AND (#sx_MoveSectionDown OR (NOT #sx_Active AND NOT #ix_SectionIsDown))
	        OR (#sx_ManualModeActive AND #sx_ManualGoDown));
	        #qx_SectionUp := (#sx_AutomaticActive AND #sx_MoveSectionUp)
	        OR (#sx_ManualModeActive AND #sx_ManualGoUp);
	        
	    END_REGION
	    
	    REGION 8.2 - Rollerconveyor
	        
	        // Conveyor receives always RTR signal to run
	        #iqUDT_HandShakeLowerConveyor.RTR := TRUE;
	        
	        // Run forward 
	        // 
	        #qUDT_LowerConveyorInterface.RunFwd := #sx_AutomaticActive
	        AND NOT #sx_Active
	        AND #ix_SectionIsDown;
	        
	        // Hold signal to conveyor
	        #qUDT_LowerConveyorInterface.Hold := NOT #qUDT_LowerConveyorInterface.RunFwd AND NOT #qUDT_LowerConveyorInterface.RunRvs;
	        
	    END_REGION
	    
	    REGION 8.3 - Divert belt conveyor
	        // Conveyor running to left 
	        #qUDT_UpperConveyorInterface.RunFwd := #sx_AutomaticActive
	        AND #sx_LeftRequest
	        AND #iqUDT_HandShakeLeftConveyor.RTR
	        AND #sx_TransportActive;
	        
	        // Conveyor running to right
	        #qUDT_UpperConveyorInterface.RunRvs := #sx_AutomaticActive
	        AND #sx_RightRequest
	        AND #iqUDT_HandShakerightConveyor.RTR
	        AND #sx_TransportActive;
	        
	        // Hold signal to conveyor
	        #qUDT_UpperConveyorInterface.Hold := NOT #qUDT_UpperConveyorInterface.RunFwd AND NOT #qUDT_UpperConveyorInterface.RunRvs;
	    END_REGION
	    
	    REGION 8.3 - handshake outfeed conveyors 
	        
	        // Outfeed conveyor left side
	        #iqUDT_HandShakeLeftConveyor.RTS := #sx_TransportActive AND #sx_LeftRequest;
	        #iqUDT_HandShakeLeftConveyor.TIP := #qUDT_UpperConveyorInterface.RunFwd;
	        IF #iqUDT_HandShakeLeftConveyor.RTS
	        THEN
	            #iqUDT_HandShakeLeftConveyor.GIN := #si_Gin;
	            #iqUDT_HandShakeLeftConveyor.NrOfPosToShift := 1;
	        ELSE
	            #iqUDT_HandShakeLeftConveyor.GIN := 0;
	            #iqUDT_HandShakeLeftConveyor.NrOfPosToShift := 0;
	        END_IF;
	        
	        // Outfeed conveyor right side
	        
	        #iqUDT_HandShakerightConveyor.RTS := #sx_TransportActive AND #sx_RightRequest;
	        #iqUDT_HandShakerightConveyor.TIP := #qUDT_UpperConveyorInterface.RunFwd;
	        IF #iqUDT_HandShakerightConveyor.RTS
	        THEN
	            #iqUDT_HandShakerightConveyor.GIN := #si_Gin;
	            #iqUDT_HandShakerightConveyor.NrOfPosToShift := 1;
	        ELSE
	            #iqUDT_HandShakerightConveyor.GIN := 0;
	            #iqUDT_HandShakerightConveyor.NrOfPosToShift := 0;
	        END_IF;
	    END_REGION
	END_REGION
	
	REGION 9 - Statistics
	    
	    REGION 9.1 - Device up time
	        
	        IF #sx_UpTime OR #iqUDT_EquipmentControl.Command.ResetData                          // Reset statistics
	        THEN
	            
	            "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData, // Reset statistics input
	                            ix_Activate := #sx_UpTime,
	                            ix_RTrigActivate := #sR_TRIG_DeviceUpTime.Q,                   // Statistics active trigger
	                            iqUDT_Statistics := #iqUDT_Statistics.ConveyorUp);             // Statistics values output
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 9.2 - Device down time
	        
	        // Conveyor down is when conveyor is not in manual mode and has an error
	        IF #sx_DownTime OR #iqUDT_EquipmentControl.Command.ResetData OR #sUDT_Status.SafetyStop     // Reset statistics
	        THEN
	            
	            "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData, // Reset statistics input
	                            ix_Activate := #sx_DownTime OR #sUDT_Status.SafetyStop,   // Activate statistics functions input
	                            ix_RTrigActivate := #sR_TRIG_DeviceDownTime.Q,                 // Statistics active trigger
	                            iqUDT_Statistics := #iqUDT_Statistics.ConveyorDown);           // Statistics values output
	            
	        END_IF;
	    END_REGION
	    
	    REGION 9.3 - Device stop time
	        
	        IF #sx_StoppedTime OR #iqUDT_EquipmentControl.Command.ResetData                     // Reset statistics
	        THEN
	            
	            "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData, // Reset statistics input
	                            ix_Activate := #sx_StoppedTime,                           // Activate statistics functions input
	                            ix_RTrigActivate := #sR_TRIG_DeviceStopped.Q,                  // Statistics active trigger
	                            iqUDT_Statistics := #iqUDT_Statistics.ConveyorStop);           // Statistics values output
	            
	        END_IF;
	    END_REGION
	END_REGION
	
	
	
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_CrossOver"
TITLE = FB_CrossOver
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 196
// END_ATTRIBUTES
//Function to control a merge left/right/straight. A conveyor, part of the merge, will move up or down to change the direction. Moving up and down control is done by this block. 
   VAR_INPUT 
      iUDT_Configuration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CrossoverConfiguration";   // Configuration structure
      ii_DisplacementRoller { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Actual displacement of the rollerconveyor
      ii_DisplacementBelt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Actual displacement of the beltconveyor
      ix_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when  hardware is Ok
      ix_400vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 400VAC is healthy
      ix_24vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 24VDC is healthy
      ix_SafetyOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when safety is ok
      ix_AirPressureOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Air pressure circuit healthy
      ix_SectionIsDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when section is down
      ix_SectionIsUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when section is up
      ix_Conveyor1Auto { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor is started in auto
      ix_Conveyor2Auto { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor is started in auto
      ix_Conveyor3Auto { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor is started in auto
      ix_Conveyor4Auto { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor is started in auto
      ix_PECOutfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True when outfeed PEC is not occupied
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_Crossoverstatus";   // HMI status structure
      qUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   // Common status structure
      qUDT_RollerConveyorInterface { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Interface roller conveyor
         Hold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Hold the conveyor
         RunFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Run conveyor forward
         RunRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Run conveyor reverse
      END_STRUCT;
      qUDT_BeltConveyorInterface { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Interface belt conveyor
         Hold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Hold the conveyor
         RunFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Run conveyor forward
         RunRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Run conveyor reverse
      END_STRUCT;
      qx_SectionUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Output to control section up
      qx_SectionDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Output to control section down
   END_VAR

   VAR_IN_OUT 
      iqa_TrackingDataRoller : Array[*] of Int;   // Tracking data
      iqa_TrackingDataBelt : Array[*] of Int;   // Tracking data
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
      iqUDT_CrossOverCommand : "UDT_CrossoverCommand";   // Conveyor command stucture
      iqUDT_Statistics : "UDT_ConveyorStatistics";   // Statistics structure
      iqUDT_HandShakeRollerConveyor : "UDT_ConveyorHandshake";
      iqUDT_HandShakeBeltConveyor : "UDT_ConveyorHandshake";
      iqUDT_HandShakeConveyor1 : "UDT_ConveyorHandshake";   // Handshake structure low level conveyor
      iqUDT_HandShakeConveyor2 : "UDT_ConveyorHandshake";   // Handshake structure low level conveyor
      iqUDT_HandShakeConveyor3 : "UDT_ConveyorHandshake";   // Handshake structure high level conveyor
      iqUDT_HandShakeConveyor4 : "UDT_ConveyorHandshake";   // Handshake structure high level conveyor
   END_VAR

   VAR 
      sa_FiFo { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..#ci_FiFoLength] of Int;   // FiFo for
      sUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Common status structure
      sUDT_StatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Common status structure
      sFB_UpMonitor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer to monitor divert took too long to move to upper position
      sFB_DownMonitor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sFB_PECOutfeedOnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sR_TRIG_RTSConveyor1 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger RTS signal from infeed
      sR_TRIG_RTSConveyor2 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger RTS signal from infeed
      sR_TRIG_RTSConveyor3 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger RTS signal from infeed
      sR_TRIG_RTSConveyor4 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger RTS signal from infeed
      sF_TRIG_Transport {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger transport
      sR_TRIG_ManualMode {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger manual mode
      sF_TRIG_ManualMode {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger manual mode
      sR_TRIG_PrestartManual {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge of manual prestart
      sR_TRIG_ManualGoUp {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge run conveyor in manual mode
      sR_TRIG_ManualGoDown {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger manual jog
      sR_TRIG_PecOutfeed {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge of reverse direction
      sF_TRIG_Jog {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger manual mode jog
      sR_TRIG_DeviceUpTime {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger conveyor up time
      sR_TRIG_DeviceStopped {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge of stop
      sR_TRIG_DeviceDownTime {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger conveyor down
      si_Step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Active infeed
      si_LoopArrayCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // FiFo process counter
      si_Gin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // New GIN found
      si_Length { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length of the product
      si_Stopposition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Position to stop
      si_Position { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Position counter
      sx_PECOutfeedFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Signal filtered with on and off delay
      sx_PECLeftFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Signal filtered with on and off delay
      sx_PECRightFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Signal filtered with on and off delay
      sx_Active { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Device sequence is activated for parcel
      sx_DataReceived { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Handshake from upstream conveyor
      sx_InfeedCHK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Step Infeed check
      sx_MoveSectionUpinfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Step move device to upper position
      sx_MoveSectionUpOutfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Step move device to upper position
      sx_MoveSectionUpEnd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Step move device to upper position
      sx_MoveSectionDownInfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Step move device to lower position
      sx_MoveSectionDownOutfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Step move device to lower position
      sx_MoveSectiondownEnd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Step move device to lower position
      sx_BeltTransportIn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Step transport is activated
      sx_BeltTransportOut { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Step transport is activated
      sx_RollerTransportIn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Step transport is activated
      sx_RollerTransportOut { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Step transport is activated
      sx_RollerRTR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Lower deck RTR signal
      sx_BeltRTR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Upper deck RTR signal
      sx_Ready { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor Ready to operate in Automatic mode
      sx_AutomaticActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Running in automatic
      sx_PreStartManual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Pre conditions to run conveyor in manual mode
      sx_ManualModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual mode active
      sx_ManualRunning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor running in manual mode
      sx_ManualGoUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual control go Up
      sx_ManualGoDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual control go down
      sx_ManUP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual go up
      sx_ManDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual go down
      sx_ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Commissioning: configuration of parameters is wrong
      sx_OutfeedLowlevel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The outfeedis low level
      sx_OutfeedHighlevel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The outfeedis high level
      sx_NoHighLevelInfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // None of the high level conveyors isinfeed
      sx_NoLowLevelInfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // None of the low level conveyors isinfeed
      sx_LeftRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request left outfeed position for actual parcel
      sx_RightRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request right outfeed position for actual parcel
      sx_DivertUpRunTimeErr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // It is taking too long to move divert up
      sx_DivertDownRunTimeErr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // It is taking too long to move divert down
      sx_UpTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Device is up
      sx_DownTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Device is down
      sx_StoppedTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Device is stopped
   END_VAR

   VAR_TEMP 
      ta_ConfigErr : Array[0..10] of Bool;
   END_VAR

   VAR CONSTANT 
      ci_FiFoLength : Int := 10;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	01/03/2023  | 1.0       | F.Baten       | Initial version
	*)
	
	REGION 1 - Initial
	    REGION 1.1 - First PLC cycle
	        
	        IF "DB_Memory".FirstScan
	        THEN
	            #sx_AutomaticActive := FALSE;                                       // switch of automatic activ
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 1.2 - Triggers
	        
	        // Rising edge trigger manual mode
	        #sR_TRIG_ManualMode(CLK := #iqUDT_CrossOverCommand.ManualMode
	                            OR #iqUDT_EquipmentControl.Command.ManualMode);
	        
	        // Falling edge trigger manual mode
	        #sF_TRIG_ManualMode(CLK := #iqUDT_CrossOverCommand.ManualMode
	                            OR #iqUDT_EquipmentControl.Command.ManualMode);
	        
	        // Rising edge trigger to start in manual mode
	        #sR_TRIG_ManualGoUp(CLK := #iqUDT_CrossOverCommand.ManualUp);
	        
	        // Rising edge trigger manual mode jog
	        #sR_TRIG_ManualGoDown(CLK := #iqUDT_CrossOverCommand.ManualDown);
	        
	        // Rising edge PEC outfeed
	        #sR_TRIG_PecOutfeed(CLK := #sx_PECOutfeedFiltered);
	        
	        // Infeed conveyor is ready to send
	        #sR_TRIG_RTSConveyor1(CLK := #iUDT_Configuration.Conveyor1.IsInfeed AND #iqUDT_HandShakeConveyor1.RTS AND #ix_Conveyor1Auto);
	        #sR_TRIG_RTSConveyor2(CLK := #iUDT_Configuration.Conveyor2.IsInfeed AND #iqUDT_HandShakeConveyor2.RTS AND #ix_Conveyor2Auto);
	        #sR_TRIG_RTSConveyor3(CLK := #iUDT_Configuration.Conveyor3.IsInfeed AND #iqUDT_HandShakeConveyor3.RTS AND #ix_Conveyor3Auto);
	        #sR_TRIG_RTSConveyor4(CLK := #iUDT_Configuration.Conveyor4.IsInfeed AND #iqUDT_HandShakeConveyor4.RTS AND #ix_Conveyor4Auto);
	        
	        // Rising edge equipment uptime
	        #sR_TRIG_DeviceUpTime(CLK := #sx_UpTime);
	        
	        //Rising edge equipment stopped
	        #sR_TRIG_DeviceStopped(CLK := #sx_StoppedTime);
	        
	        // Rising edge equipment conveyor downtime
	        #sR_TRIG_DeviceDownTime(CLK := #sx_DownTime);
	    END_REGION
	    
	    REGION 1.3 - Timers
	        // Statement section REGION
	        #sFB_PECOutfeedOnOffDelay(iudi_OnDelayTime := #iUDT_Configuration.OutfeedTimeOnDelay,         // Off delay time to filter PEC signal
	                                  iudi_OffDelayTime := #iUDT_Configuration.OutfeedTimeOffDelay,     // On delay time to filter PEC signal
	                                  ix_SignalToDelay := #ix_PECOutfeed,                               // PEC input signal
	                                  ix_Enable := TRUE,
	                                  qx_DelayedSignal => #sx_PECOutfeedFiltered);                      // PEC signal filtered
	        
	        #sFB_UpMonitor(iudi_OnDelayTime := #iUDT_Configuration.LiftRuntimeUpOnDelay,                // Off delay time
	                       iudi_OffDelayTime := #iUDT_Configuration.LiftRuntimeUpOffDelay,              // On delay time
	                       ix_SignalToDelay := #sx_AutomaticActive
	                       AND #sx_MoveSectionUpinfeed
	                       AND NOT #ix_SectionIsUp,                                                     // input signal
	                       ix_Enable := TRUE,
	                       qx_DelayedSignal => #sx_DivertUpRunTimeErr);                                 // Signal filtered
	        
	        #sFB_DownMonitor(iudi_OnDelayTime := #iUDT_Configuration.LiftRuntimeDownOnDelay,            // Off delay time to filter PEC signal
	                         iudi_OffDelayTime := #iUDT_Configuration.LiftRuntimeDownOffDelay,          // On delay time to filter PEC signal
	                         ix_SignalToDelay := #sx_MoveSectionDownInfeed AND NOT #ix_SectionIsDown,   // Input signal
	                         ix_Enable := TRUE,
	                         qx_DelayedSignal => #sx_DivertDownRunTimeErr);                             // Signal filtered
	        
	    END_REGION
	    
	    REGION 1.4 - Conditions Up - Down - Stopped
	        //Used for statistics
	        
	        #sx_UpTime := (#sx_AutomaticActive                                  // Automatic active
	        AND #sx_Ready);                                                     // Ready active
	        
	        #sx_DownTime := (NOT #sx_ManualModeActive                           // Not in manual mode
	        AND #sUDT_Status.Error                                              // in error 
	        AND NOT #sx_Ready);                                                 // Conveyor not ready
	        
	        #sx_StoppedTime := (NOT #sx_AutomaticActive AND #sx_Ready);
	        
	    END_REGION
	END_REGION
	
	
	REGION 2 - Error / warning
	    
	    REGION 2.1 - Reset errors
	        
	        IF #iqUDT_EquipmentControl.Command.Reset                        // Reset
	        THEN
	            
	            IF #qUDT_HMIStatus.Specific.ErrRuntime                      // It took too long to move divert up or down
	            THEN
	                
	                #qUDT_HMIStatus.Specific.ErrRuntime := FALSE;            // reset error
	                
	            END_IF;
	            
	            IF #qUDT_HMIStatus.Specific.ErrAirpressureNotOk             // Airpressure is not ok
	            THEN
	                
	                #qUDT_HMIStatus.Specific.ErrAirpressureNotOk := FALSE; // reset error
	                
	            END_IF;
	        END_IF;
	    END_REGION
	    
	    REGION 2.2 - Set errors
	        
	        // Runtime delay error
	        IF #sx_DivertUpRunTimeErr                                       // It took too long to move up
	            OR #sx_DivertDownRunTimeErr                                 // It took too long to move down
	        THEN
	            #qUDT_HMIStatus.Specific.ErrRuntime := TRUE;                // Set error runtime error
	        END_IF;
	        
	        // Airpressure not ok
	        IF NOT #ix_AirPressureOk                                        // Airpressure is not signalling              
	            AND (#sx_LeftRequest OR #sx_RightRequest)                   // If there is request to move to the left or right position      
	        THEN
	            #qUDT_HMIStatus.Specific.ErrAirpressureNotOk := TRUE;       // Set error airpressure
	        END_IF;
	        
	        // configuration errors
	        #ta_ConfigErr[1] := 1 <> (BOOL_TO_INT(#iUDT_Configuration.Conveyor1.IsOutfeed) + BOOL_TO_INT(#iUDT_Configuration.Conveyor2.IsOutfeed) + BOOL_TO_INT(#iUDT_Configuration.Conveyor3.IsOutfeed) + BOOL_TO_INT(#iUDT_Configuration.Conveyor4.IsOutfeed));
	        #sx_ConfigurationError := (#ta_ConfigErr[1] OR #ta_ConfigErr[2] OR #ta_ConfigErr[3] OR #ta_ConfigErr[4] OR #ta_ConfigErr[5] OR #ta_ConfigErr[6]);
	        
	    END_REGION
	    
	    REGION 2.3 - Warning
	        
	        #qUDT_HMIStatus.Specific.WarnAirPressure := NOT #ix_AirPressureOk;  // Airpressure is not signalling
	        
	    END_REGION
	    
	    
	    REGION 2.4 - Common Error
	        
	        #sUDT_Status.Error := #qUDT_HMIStatus.Specific.ErrRuntime           // Direction verification found the Direction fault, stop the parcel
	        OR #qUDT_HMIStatus.Specific.ErrAirpressureNotOk                     // Upper jam PEC detected WHILE going Up
	        OR #qUDT_HMIStatus.Specific.ErrOverrun                              // Parcel travelled too far to divert
	        OR #sx_ConfigurationError;                                          // Configuration error, check values
	        
	    END_REGION
	    
	    REGION 2.5 - Common Warning
	        
	        #sUDT_Status.Warning := #qUDT_HMIStatus.Specific.WarnAirPressure;   // Airpressure is not signalling
	        
	    END_REGION
	    
	END_REGION
	
	REGION 3 - Check conditions to set Equipment ready
	    
	    //Conditions to set bit sx_Ready to operate 
	    
	    #sx_Ready := NOT #sUDT_Status.Error                                 // Error present
	    AND #ix_SafetyOk                                                    // Safety signalling OK
	    AND #ix_24vOk                                                       // 24V signalling OK
	    AND #ix_400vOk;                                                     // 400v signalling OK 
	    
	END_REGION
	
	REGION 4 - Stop Equipment
	    
	    // Conditions to stop conveyor
	    IF (#sF_TRIG_Jog.Q                                                  // Trigger when conveyor stops jogging by HMI
	        AND #sx_ManualModeActive)                                       // Manual mode is active
	        
	        OR (NOT #iqUDT_EquipmentControl.Command.AutomaticOn             // Conveyor stops if the bit AutomaticOn from control block is false
	        AND NOT #sx_ManualModeActive)                                   // Manual mode active bit
	        
	        OR (NOT #sx_Ready                                               // Bit conveyor ready to run in automatic mode
	        AND NOT #sx_ManualModeActive)                                   // Manual mode active
	        
	        OR #sR_TRIG_ManualMode.Q                                        // Trigger when manual mode is set on
	        OR #sF_TRIG_ManualMode.Q                                        // Trigger when manual mode is set off
	        
	        OR NOT #ix_SafetyOk
	        
	    THEN
	        //  Order to stop VFD
	        #qUDT_RollerConveyorInterface.RunFwd := FALSE;                       // Set false order to VFD run in forward direction
	        #qUDT_RollerConveyorInterface.RunRvs := FALSE;                       // Set false order to VFD run in reverse direction
	        
	        #sx_AutomaticActive := FALSE;                                   // Automatic mode is disable
	        
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Start
	    
	    REGION 5.1 - Set Automatic active
	        
	        // The conditions to set the bit "startReceived" are: 
	        // - Divert not in manual mode.
	        // - Divert ready to run.
	        // - Bit AutomaticOn from control block must be on.
	        // - Bit start form control block on.
	        
	        IF #iqUDT_EquipmentControl.Command.Start
	            AND #iqUDT_EquipmentControl.Command.AutomaticOn
	            AND NOT #sx_ManualModeActive
	            AND #sx_Ready
	        THEN
	            #sx_AutomaticActive := TRUE;                                // Diverter active automatic mode
	        END_IF;
	        
	    END_REGION
	    
	    REGION 5.2 - Restart request
	        #iqUDT_EquipmentControl.Request.RestartRequired := NOT #sx_AutomaticActive
	        AND NOT #sx_ManualModeActive
	        AND #sx_Ready;
	        
	    END_REGION
	    
	    
	END_REGION
	
	REGION 6 - Manual mode
	    
	    REGION 6.1 - Manual mode force disable
	        
	        // Manual mode bits inputs can be reset in case of malfunction
	        IF #iqUDT_EquipmentControl.Command.DisableManualMode
	        THEN
	            #iqUDT_CrossOverCommand.ManualMode := FALSE;
	            #iqUDT_EquipmentControl.Command.ManualMode := False;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 6.2 - Manual mode activation 
	        
	        // Manual mode is active if it is active from hmi or by control block  
	        #sx_ManualModeActive := #iqUDT_CrossOverCommand.ManualMode
	        OR #iqUDT_EquipmentControl.Command.ManualMode;
	        
	    END_REGION
	    
	    REGION 6.3 - Reset manual commands 
	        //When the system is not any more in manual mode or when fatal error occurs the HMI commands should be reset
	        IF NOT #ix_SafetyOk
	            OR NOT #ix_24vOk                                            // 24V error status
	            OR NOT #ix_400vOk                                           // 400V error status
	            OR NOT #ix_HardwareOk                                       // Profinet error status
	            OR NOT #sx_ManualModeActive
	        THEN
	            #iqUDT_CrossOverCommand.ManualDown := FALSE;
	            #iqUDT_CrossOverCommand.ManualUp := FALSE;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 6.4 - Start/Stop
	        
	        // Pre start conditions to run in manual mode
	        #sx_PreStartManual := #sx_ManualModeActive                      // Manual mode active bit
	        AND #ix_SafetyOk                                                // Safety healthy bit
	        AND #ix_HardwareOk;                                             // Profinet comunication 
	        
	        
	        
	        #sR_TRIG_PrestartManual(CLK := #sx_PreStartManual);
	        // If manual command is active to one side, first button ha sto be released to accept new
	        #sx_ManUP := (#sR_TRIG_ManualGoUp.Q AND NOT #sx_ManDown) OR
	        (#sx_ManUP AND #iqUDT_CrossOverCommand.ManualUp);
	        
	        #sx_ManDown := (#sR_TRIG_ManualGoDown.Q AND NOT #sx_ManUP) OR
	        (#sx_ManDown AND #iqUDT_CrossOverCommand.ManualDown);
	        
	        // Do signal request (horn sounding before movement)
	        IF #sx_PreStartManual                                           // Pre start conditions to run in manual mode
	            AND (#sR_TRIG_ManualGoUp.Q AND #sx_ManUP)                  // Trigger when conveyor start running in manual mode
	            OR (#sR_TRIG_ManualGoDown.Q AND #sx_ManDown)
	        THEN
	            
	            #iqUDT_EquipmentControl.Request.SignalingRequest := TRUE;   // Request signaling to control block before conveyor run in manual mode
	            
	        END_IF;
	        
	        // Go up in manual mode
	        #sx_ManualGoUp := #sx_PreStartManual                            // Pre start conditions to run in manual mode
	        AND (NOT #iqUDT_EquipmentControl.Request.SignalingRequest       // Signaling request done
	        OR #sx_ManualRunning)
	        AND #sx_ManUP; // #iqUDT_CrossOverCommand.ManualUp;                           // Manual mode start TO run
	        
	        // Go down in manual mode
	        #sx_ManualGoDown := #sx_PreStartManual                          // Pre start conditions to run in manual mode
	        AND (NOT #iqUDT_EquipmentControl.Request.SignalingRequest       // Signaling request done
	        OR #sx_ManualRunning)
	        AND #sx_ManDown;//#iqUDT_CrossOverCommand.ManualDown;                         // Manual mode start to run
	        
	        #sx_ManualRunning := #sx_ManualGoUp
	        OR #sx_ManualGoDown;
	        
	    END_REGION
	    
	END_REGION
	
	
	REGION 7 - Automatic mode
	    REGION 7.1 - Determine outfeed level and update FiFo
	        
	        #sx_OutfeedLowlevel := #iUDT_Configuration.Conveyor1.IsOutfeed OR #iUDT_Configuration.Conveyor2.IsOutfeed;
	        #sx_OutfeedHighlevel := #iUDT_Configuration.Conveyor3.IsOutfeed OR #iUDT_Configuration.Conveyor3.IsOutfeed;
	        #sx_NoHighLevelInfeed := NOT #iUDT_Configuration.Conveyor3.IsInfeed AND NOT #iUDT_Configuration.Conveyor4.IsInfeed;
	        #sx_NoLowLevelInfeed := NOT #iUDT_Configuration.Conveyor1.IsInfeed AND NOT #iUDT_Configuration.Conveyor2.IsInfeed;
	        
	        FOR #si_LoopArrayCount := 1 TO (#ci_FiFoLength - 1) BY 1 DO     // Set loop to process
	            IF #sa_FiFo[#si_LoopArrayCount] = 0                         // Do when actual value is '0'
	            THEN
	                #sa_FiFo[#si_LoopArrayCount] := #sa_FiFo[#si_LoopArrayCount + 1];   // copy next entry to actual
	                #sa_FiFo[#si_LoopArrayCount + 1] := 0;                  // Reset next entry
	            END_IF;
	        END_FOR;
	        // Get double entry out 
	        IF #sx_Active                                                   // When Sequence is activated
	        THEN
	            IF (#sa_FiFo[2] <> 0)                                       // Entry 2 is not equal to '0'
	                AND (#sa_FiFo[2] = #sa_FiFo[3])                         // Entry 2 is equal to 3
	            THEN
	                #sa_FiFo[3] := 0;                                       // remove entry 3
	            ELSIF
	                (#sa_FiFo[2] <> 0)                                      // Entry 2 is not equal to '0'
	                AND (#sa_FiFo[2] = #sa_FiFo[4])                         // Entry 2 is equal to 4
	            THEN
	                #sa_FiFo[4] := 0;                                       // Remove entry 4
	            END_IF;
	        END_IF;
	    END_REGION
	    
	    
	    REGION 7.2 - FiFo handling
	        // When an infeed signals RTS it is put in the FiFo then the FiFo is shifted.
	        
	        IF #sR_TRIG_RTSConveyor1.Q                                      // Signal received from infeed 1
	        THEN
	            #sa_FiFo[#ci_FiFoLength] := 1;                              // Set last FiFo entry to 1
	            
	            FOR #si_LoopArrayCount := 1 TO (#ci_FiFoLength - 1) BY 1 DO // Set loop to process
	                IF #sa_FiFo[#si_LoopArrayCount] = 0                     // Do when actual value is '0'
	                THEN
	                    #sa_FiFo[#si_LoopArrayCount] := #sa_FiFo[#si_LoopArrayCount + 1];   // copy next entry to actual
	                    #sa_FiFo[#si_LoopArrayCount + 1] := 0;              // Reset next entry
	                END_IF;
	            END_FOR;
	        END_IF;
	        
	        IF #sR_TRIG_RTSConveyor2.Q                                      // Signal received from infeed 2
	        THEN
	            #sa_FiFo[#ci_FiFoLength] := 2;                              // Set last FiFo entry to 2
	            
	            FOR #si_LoopArrayCount := 1 TO (#ci_FiFoLength - 1) BY 1 DO // Set loop to process
	                IF #sa_FiFo[#si_LoopArrayCount] = 0                     // Do when actual value is '0'
	                THEN
	                    #sa_FiFo[#si_LoopArrayCount] := #sa_FiFo[#si_LoopArrayCount + 1];   // copy next entry to actual
	                    #sa_FiFo[#si_LoopArrayCount + 1] := 0;              // Reset next entry
	                END_IF;
	            END_FOR;
	        END_IF;
	        
	        IF #sR_TRIG_RTSConveyor3.Q                                      // Signal received from infeed 3
	        THEN
	            #sa_FiFo[#ci_FiFoLength] := 3;                              // Set last FiFo entry to 3
	            
	            FOR #si_LoopArrayCount := 1 TO (#ci_FiFoLength - 1) BY 1 DO // Set loop to process
	                IF #sa_FiFo[#si_LoopArrayCount] = 0                     // Do when actual value is '0'
	                THEN
	                    #sa_FiFo[#si_LoopArrayCount] := #sa_FiFo[#si_LoopArrayCount + 1];   // copy next entry to actual
	                    #sa_FiFo[#si_LoopArrayCount + 1] := 0;              // Reset next entry
	                END_IF;
	            END_FOR;
	        END_IF;
	        
	        IF #sR_TRIG_RTSConveyor4.Q                                      // Signal received from infeed 4
	        THEN
	            #sa_FiFo[#ci_FiFoLength] := 4;                              // Set last FiFo entry to 4
	            
	            FOR #si_LoopArrayCount := 1 TO (#ci_FiFoLength - 1) BY 1 DO // Set loop to process
	                IF #sa_FiFo[#si_LoopArrayCount] = 0                     // Do when actual value is '0'
	                THEN
	                    #sa_FiFo[#si_LoopArrayCount] := #sa_FiFo[#si_LoopArrayCount + 1];   // copy next entry to actual
	                    #sa_FiFo[#si_LoopArrayCount + 1] := 0;              // Reset next entry
	                END_IF;
	            END_FOR;
	        END_IF;
	    END_REGION
	    
	    REGION 7.3.1 - Start sequence, infeed conveyor request 
	        // If FiFo has an entry which is matching request, the request is rewarded and the sequence is started  
	        IF NOT #sx_Active                                               // Not activated yet
	            AND #sa_FiFo[1] <> 0                                        // There is a request in FiFo 1
	        THEN // Save GIN from active infeed
	            IF #sa_FiFo[1] = 1                                          // Conveyor 1 is infeed
	                AND #iqUDT_HandShakeConveyor1.RTS
	            THEN
	                #iqUDT_HandShakeConveyor1.NrOfPosToShift := 0;          // reset number of positions to shift
	                #sx_InfeedCHK := TRUE;                                  // Infeed is checked
	                #sx_Active := TRUE;                                     // Sequence is started
	                #si_Conveyor := 1;                                      // Set active infeed
	                #sa_FiFo[1] := 0;                                       // Reset entry 1
	                #si_Step := 1;
	                
	            ELSIF #sa_FiFo[1] = 2                                       // Conveyor 2 is infeed
	                AND #iqUDT_HandShakeConveyor2.RTS
	            THEN
	                #iqUDT_HandShakeConveyor2.NrOfPosToShift := 0;          // reset number of positions to shift
	                #sx_InfeedCHK := TRUE;                                  // Infeed is checked
	                #sx_Active := TRUE;                                     // Sequence is started
	                #si_Conveyor := 2;                                      // Set active infeed
	                #sa_FiFo[1] := 0;                                       // Reset entry 1
	                #si_Step := 1;
	                
	            ELSIF #sa_FiFo[1] = 3                                       // Conveyor 3 is infeed
	                AND #iqUDT_HandShakeConveyor3.RTS
	            THEN
	                #iqUDT_HandShakeConveyor3.NrOfPosToShift := 0;          // reset number of positions to shift
	                #sx_InfeedCHK := TRUE;                                  // Infeed is checked
	                #sx_Active := TRUE;                                     // Sequence is started
	                #si_Conveyor := 3;                                      // Set active infeed
	                #sa_FiFo[1] := 0;                                       // Reset entry 1
	                #si_Step := 1;
	                
	            ELSIF #sa_FiFo[1] = 4                                       // Conveyor 4 is infeed
	                AND #iqUDT_HandShakeConveyor4.RTS
	            THEN
	                #iqUDT_HandShakeConveyor4.NrOfPosToShift := 0;          // reset number of positions to shift
	                #sx_InfeedCHK := TRUE;                                  // Infeed is checked
	                #sx_Active := TRUE;                                     // Sequence is started
	                #si_Conveyor := 4;                                      // Set active infeed
	                #sa_FiFo[1] := 0;                                       // Reset entry 1
	                #si_Step := 1;
	                
	            ELSE
	                #sa_FiFo[1] := 0;                                       // No infeed request was matching
	            END_IF;
	        END_IF;
	        
	        // As Gin is received when tip starts, length then is looked-up.  At first it is filled with a default length.
	        IF NOT #sx_DataReceived THEN
	            #si_Length := (#iUDT_Configuration.ParcelDefaultLength / 10);
	        END_IF;
	        
	        IF #si_Conveyor = 1                                         // Conveyor 1 is infeed
	            AND (#iqUDT_HandShakeConveyor1.GIN <> 0)                // Gin in handshake is not empty
	            AND NOT #sx_DataReceived
	        THEN
	            #si_Gin := #iqUDT_HandShakeConveyor1.GIN;               // Memorise GIN
	            #si_Length := "DB_GIN".GIN[#si_Gin].General.Length;     // Get length from Gin
	            IF #si_Length > 0 THEN
	                #sx_DataReceived := TRUE;
	            END_IF;
	            
	        ELSIF #si_Conveyor = 2                                      // Conveyor 1 is infeed
	            AND (#iqUDT_HandShakeConveyor2.GIN <> 0)                // Gin in handshake is not empty
	            AND NOT #sx_DataReceived
	        THEN
	            #si_Gin := #iqUDT_HandShakeConveyor2.GIN;               // Memorise GIN
	            #si_Length := "DB_GIN".GIN[#si_Gin].General.Length;     // Get length from Gin
	            IF #si_Length > 0 THEN
	                #sx_DataReceived := TRUE;
	            END_IF;
	            
	        ELSIF #si_Conveyor = 3                                      // Conveyor 1 is infeed
	            AND (#iqUDT_HandShakeConveyor3.GIN <> 0)                // Gin in handshake is not empty
	            AND NOT #sx_DataReceived
	        THEN
	            #si_Gin := #iqUDT_HandShakeConveyor3.GIN;               // Memorise GIN
	            #si_Length := "DB_GIN".GIN[#si_Gin].General.Length;     // Get length from Gin    
	            IF #si_Length > 0 THEN
	                #sx_DataReceived := TRUE;
	            END_IF;
	            
	        ELSIF #si_Conveyor = 4                                      // Conveyor 1 is infeed
	            AND (#iqUDT_HandShakeConveyor4.GIN <> 0)                // Gin in handshake is not empty
	            AND NOT #sx_DataReceived
	        THEN
	            #si_Gin := #iqUDT_HandShakeConveyor4.GIN;               // Memorise GIN
	            #si_Length := "DB_GIN".GIN[#si_Gin].General.Length;     // Get length from Gin  
	            IF #si_Length > 0 THEN
	                #sx_DataReceived := TRUE;
	            END_IF;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 7.3.2 - Infeed checked, go to infeed level
	        
	        IF #sx_AutomaticActive                                          // The device is automaticly started
	            AND #sx_Ready                                               // The device is ready to opereate
	            AND #sx_Active                                              // The sequence is started
	            AND #sx_InfeedCHK                                           // Step infeed check is active
	            AND ((#si_Conveyor = 1) OR #si_Conveyor = 2)                // Infeed is on low level
	        THEN
	            #sx_MoveSectionDownInfeed := TRUE;                          // Move section down
	            #sx_InfeedCHK := FALSE;                                     // Reset step infeed check
	            #si_Step := 2;
	            
	        ELSIF #sx_AutomaticActive                                       // The device is automaticly started
	            AND #sx_Ready                                               // The device is ready to opereate
	            AND #sx_Active                                              // The sequence is started
	            AND #sx_InfeedCHK                                           // Step infeed check is active
	            AND ((#si_Conveyor = 3) OR #si_Conveyor = 4)                // Infeed is on high level
	        THEN
	            #sx_MoveSectionUpinfeed := TRUE;                            // Move section up
	            #sx_InfeedCHK := FALSE;                                     // Reset step infeed check
	            #si_Step := 2;
	        END_IF;
	    END_REGION
	    
	    REGION 7.3.3 - At infeed level, start infeed transport
	        
	        IF #sx_AutomaticActive                                          // The device is automaticly started
	            AND #sx_Ready                                               // The device is ready to opereate
	            AND #sx_Active                                              // The sequence is started
	            AND #ix_SectionIsDown                                       // Section is actual down
	            AND #sx_MoveSectionDownInfeed                               // Step move down to infeed was activated 
	        THEN
	            #sx_MoveSectionDownInfeed := FALSE;                         // Reset step move down to infeed level
	            #si_Position := 0;                                          // Reset position counter
	            #si_Stopposition := 2;
	            #si_Gin := 0;
	            #sx_RollerTransportIn := TRUE;                              // Start infeed roller transport
	            #sx_RollerRTR := TRUE;                                      // Set RTR to infeed until TIP gets active
	            #si_Step := 3;
	            
	        ELSIF #sx_AutomaticActive                                       // The device is automaticly started
	            AND #sx_Ready                                               // The device is ready to opereate
	            AND #sx_Active                                              // The sequence is started
	            AND #ix_SectionIsUp
	            AND #sx_MoveSectionUpinfeed                                 // Step move up to infeed was activated 
	        THEN
	            #sx_MoveSectionUpinfeed := FALSE;                           // Reset step move up to infeed level
	            #si_Position := 0;                                          // Reset position counter
	            #sx_BeltTransportIn := TRUE;                                // Start infeed belt transport
	            #sx_BeltRTR := TRUE;                                        // Set RTR to infeed until TIP gets active
	            #si_Step := 3;
	            
	        END_IF;
	    END_REGION
	    
	    REGION 7.3.4 - Stop transport, move to outfeed level
	        // First stop connveyor position is calculated.
	        // Half of the length of the conveyor (middle) + or - half of the pack/parcel length (middle) + a factor to adjust.
	        // The + or - depends on the transporting direction.
	        IF (#sx_RollerTransportIn OR #sx_BeltTransportIn)
	        THEN
	            
	            IF #si_Conveyor = 1 AND (#si_Gin <> 0)                      // Infeed is from conveyor infeed 1
	            THEN
	                IF #iUDT_Configuration.RollerConveyor.Runfwd
	                THEN
	                    #si_Stopposition := (((#iUDT_Configuration.RollerConveyor.ConveyorLength / 10 - #si_Length) / 2) - #iUDT_Configuration.RollerConveyor.LengthFrom1);
	                ELSE
	                    #si_Stopposition := (((#iUDT_Configuration.RollerConveyor.ConveyorLength / 10 + #si_Length) / 2) + #iUDT_Configuration.RollerConveyor.LengthFrom1);
	                END_IF;
	                
	            ELSIF #si_Conveyor = 2 AND (#si_Gin <> 0)                   // Infeed is from conveyor infeed 2
	            THEN
	                IF #iUDT_Configuration.RollerConveyor.Runfwd
	                THEN
	                    #si_Stopposition := (((#iUDT_Configuration.RollerConveyor.ConveyorLength / 10 - #si_Length) / 2) - #iUDT_Configuration.RollerConveyor.LengthFrom2);
	                ELSE
	                    #si_Stopposition := (((#iUDT_Configuration.RollerConveyor.ConveyorLength / 10 + #si_Length) / 2) + #iUDT_Configuration.RollerConveyor.LengthFrom2);
	                END_IF;
	                
	            ELSIF #si_Conveyor = 3 AND (#si_Gin <> 0)                  // Infeed is from conveyor infeed 2
	            THEN
	                IF #iUDT_Configuration.BeltConveyor.Runfwd
	                THEN
	                    #si_Stopposition := (((#iUDT_Configuration.BeltConveyor.ConveyorLength / 10 - #si_Length) / 2) - #iUDT_Configuration.BeltConveyor.LengthFrom3);
	                ELSE
	                    #si_Stopposition := (((#iUDT_Configuration.BeltConveyor.ConveyorLength / 10 + #si_Length) / 2) + #iUDT_Configuration.BeltConveyor.LengthFrom3);
	                END_IF;
	                
	            ELSIF #si_Conveyor = 4 AND (#si_Gin <> 0)                   // Infeed is from conveyor infeed 2
	            THEN
	                IF #iUDT_Configuration.BeltConveyor.Runfwd
	                THEN
	                    #si_Stopposition := (((#iUDT_Configuration.BeltConveyor.ConveyorLength / 10 + #si_Length) / 2) + #iUDT_Configuration.BeltConveyor.LengthFrom4);
	                ELSE
	                    #si_Stopposition := (((#iUDT_Configuration.BeltConveyor.ConveyorLength / 10 - #si_Length) / 2) - #iUDT_Configuration.BeltConveyor.LengthFrom4);
	                END_IF;
	            END_IF;
	            
	            // Stop position cant exceed conveyor dimensions
	            IF #si_Conveyor = 1 OR #si_Conveyor = 2
	            THEN
	                IF #si_Stopposition > (#iUDT_Configuration.RollerConveyor.ConveyorLength / 10) - 2
	                THEN
	                    #si_Stopposition := (#iUDT_Configuration.RollerConveyor.ConveyorLength / 10) - 2;
	                END_IF;
	            ELSIF #si_Conveyor = 3 OR #si_Conveyor = 4
	            THEN
	                IF #si_Stopposition > (#iUDT_Configuration.BeltConveyor.ConveyorLength / 10) - 2
	                THEN
	                    #si_Stopposition := (#iUDT_Configuration.BeltConveyor.ConveyorLength / 10) - 2;
	                END_IF;
	            END_IF;
	            
	            IF #si_Stopposition < 2
	            THEN
	                #si_Stopposition := 2;
	            END_IF;
	        END_IF;
	        
	        
	        IF #sx_AutomaticActive                                          // The device is automaticly started
	            AND #sx_Ready                                               // The device is ready to opereate
	            AND #sx_Active                                              // The sequence is started
	            AND #sx_RollerTransportIn                                   // Step infeed roller transport is active
	            AND (((#iqa_TrackingDataRoller[#si_Stopposition] <> 0)        // Value is not 0
	            AND (#iqa_TrackingDataRoller[#si_Stopposition] = #si_Gin))  // The value in the tracking is equal to the GIN
	            OR (#si_Position >= #iUDT_Configuration.OutfeedLength))    // Actual position counter reached desired position 
	        THEN
	            #sx_RollerTransportIn := FALSE;                             // Reset step infeed rollertransport
	            #si_Position := 0;
	            #sx_MoveSectionDownOutfeed := #sx_OutfeedLowlevel;          // Depending on outfeed conveyor section is moved to outfeed level
	            #sx_MoveSectionUpOutfeed := #sx_OutfeedHighlevel;           // Depending on outfeed conveyor section is moved to outfeed level
	            #si_Step := 4;
	            
	            FILL_BLK(IN := 0,                                        // Clear tracking area for divert on main conveyor 
	                     COUNT := DINT_TO_ULINT(#iUDT_Configuration.RollerConveyor.ConveyorLength / 10),
	                     OUT => #iqa_TrackingDataRoller[0]);
	            
	        ELSIF #sx_AutomaticActive                                       // The device is automaticly started
	            AND #sx_Ready                                               // The device is ready to opereate
	            AND #sx_Active                                              // The sequence is started
	            AND #sx_BeltTransportIn                                     // Step infeed belt transport is active
	            AND (((#iqa_TrackingDataBelt[#si_Stopposition] <> 0)          // Value is not 0
	            AND (#iqa_TrackingDataBelt[#si_Stopposition] = #si_Gin))    // The value in the tracking is equal to the GIN
	            OR (#si_Position >= #iUDT_Configuration.OutfeedLength))    // Actual position counter reached desired position  
	        THEN
	            #sx_BeltTransportIn := FALSE;                               // Reset step infeed belttransport
	            #si_Position := 0;                                          // Reset position counter
	            #sx_MoveSectionDownOutfeed := #sx_OutfeedLowlevel;          // Depending on outfeed conveyor section is moved to outfeed level
	            #sx_MoveSectionUpOutfeed := #sx_OutfeedHighlevel;           // Depending on outfeed conveyor section is moved to outfeed level
	            #si_Step := 4;
	            
	            FILL_BLK(IN := 0,                                        // Clear tracking area for divert on main conveyor 
	                     COUNT := DINT_TO_ULINT(#iUDT_Configuration.BeltConveyor.ConveyorLength / 10),
	                     OUT => #iqa_TrackingDataBelt[0]);
	        END_IF;
	    END_REGION
	    
	    REGION 7.3.5 - At outfeed level, start outfeed transport
	        IF #sx_AutomaticActive                                          // The device is automaticly started
	            AND #sx_Ready                                               // The device is ready to opereate
	            AND #sx_Active                                              // The sequence is started
	            AND #sx_MoveSectionDownOutfeed                              // Step move down to outfeed is active
	            AND #ix_SectionIsDown                                       // Section is actual down
	            
	        THEN
	            #sx_MoveSectionDownOutfeed := FALSE;                        // Reset step move down to outfeed
	            #si_Position := 0;                                          // Reset position counter
	            #sx_RollerTransportOut := TRUE;                             // Start outfeed roller transport
	            #si_Step := 5;
	            
	        ELSIF #sx_AutomaticActive                                       // The device is automaticly started
	            AND #sx_Ready                                               // The device is ready to opereate
	            AND #sx_Active                                              // The sequence is startede
	            AND #sx_MoveSectionUpOutfeed                                // Step move up to outfeed is active
	            AND #ix_SectionIsUp                                         // Section is actual up
	        THEN
	            #sx_MoveSectionUpOutfeed := FALSE;                          // Reset step move up to outfeed
	            #si_Position := 0;                                          // Reset position counter
	            #sx_BeltTransportOut := TRUE;                               // Start outfeed belt transport
	            #si_Step := 5;
	            
	        END_IF;
	    END_REGION
	    
	    REGION 7.3.6 - End sequence
	        IF #sx_AutomaticActive                                          // The device is automaticly started
	            AND #sx_Ready                                               // The device is ready to opereate
	            AND #sx_Active                                              // The sequence is started
	            AND (#sx_RollerTransportOut OR #sx_BeltTransportOut)        // Outfeed transport is active
	            AND (#sR_TRIG_PecOutfeed.Q OR (#si_Position > #iUDT_Configuration.OutfeedLength)) // Actual position counter reached desired position 
	            
	        THEN
	            IF #sx_NoHighLevelInfeed                                    // If there is no high level infeed configured
	                AND #ix_SectionIsUp                                     // Section is actual up    
	            THEN
	                #sx_MoveSectiondownEnd := TRUE;                         // Then move down to infeed
	            END_IF;
	            IF #sx_NoLowLevelInfeed                                     // IF there is no low level infeed configured
	                AND #ix_SectionIsDown                                   // Section is actual down    
	            THEN
	                #sx_MoveSectionUpEnd := TRUE;                           // Then move down to infeed
	            END_IF;
	            
	            #sx_RollerTransportOut := FALSE;                            // Reset step outfeed roller transport
	            #sx_BeltTransportOut := FALSE;                              // Reset step outfeed belt transport
	            #si_Gin := 0;                                               // Reset save Gin number
	            #si_Conveyor := 0;                                          // Reset FiFo to be updated
	            #sx_Active := FALSE;                                        // Not active anymore
	            #sx_DataReceived := FALSE;
	            
	            #si_Step := 0;
	        END_IF;
	        
	        IF #sx_MoveSectionUpEnd                                         // Reset Up request when up
	            AND #ix_SectionIsUp
	        THEN
	            #sx_MoveSectionUpEnd := False;
	        END_IF;
	        
	        IF #sx_MoveSectiondownEnd                                       // Reset down request when down
	            AND #ix_SectionIsDown
	        THEN
	            #sx_MoveSectiondownEnd := False;
	        END_IF;
	    END_REGION
	    
	    REGION 7.4 - Calculate position
	        // When transport is active displacement is added to position counter 
	        IF #qUDT_RollerConveyorInterface.RunFwd OR #qUDT_RollerConveyorInterface.RunRvs
	        THEN
	            #si_Position += ABS(#ii_DisplacementRoller);
	        END_IF;
	        
	        IF #qUDT_BeltConveyorInterface.RunFwd OR #qUDT_BeltConveyorInterface.RunRvs
	        THEN
	            #si_Position += ABS(#ii_DisplacementBelt);
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 8 - Output
	    REGION 8.1 - Lifting device
	        
	        #qx_SectionDown := (#sx_AutomaticActive
	        AND
	        ((#sx_MoveSectionDownInfeed OR #sx_MoveSectionDownOutfeed OR #sx_MoveSectiondownEnd))
	        OR (#sx_ManualModeActive AND #sx_ManualGoDown));
	        
	        #qx_SectionUp := (#sx_AutomaticActive
	        AND
	        ((#sx_MoveSectionUpinfeed OR #sx_MoveSectionUpOutfeed OR #sx_MoveSectionUpEnd))
	        OR (#sx_ManualModeActive AND #sx_ManualGoUp));
	        
	    END_REGION
	    
	    REGION 8.2 - Rollerconveyor
	        // Conveyor receives always RTR signal to run
	        #iqUDT_HandShakeRollerConveyor.RTR := TRUE;
	        
	        // Run forward 
	        // 
	        #qUDT_RollerConveyorInterface.RunFwd :=
	        (#iUDT_Configuration.RollerConveyor.Runfwd                      // Standard direction forward
	        AND ((#sx_RollerTransportIn AND (#si_Conveyor = 1))             // Transport in and transporting from infeed 1
	        OR (#sx_RollerTransportOut AND #iUDT_Configuration.Conveyor2.IsOutfeed AND #iqUDT_HandShakeConveyor2.RTR)))   // Transport out and 2 is outfeed
	        
	        OR
	        (NOT #iUDT_Configuration.RollerConveyor.Runfwd                  // Standard direction is reverse
	        AND ((#sx_RollerTransportIn AND (#si_Conveyor = 2))             // Transport in and transporting from infeed 2
	        OR (#sx_RollerTransportOut AND #iUDT_Configuration.Conveyor1.IsOutfeed AND #iqUDT_HandShakeConveyor1.RTR)));     // Transport out and 1 is outfeed
	        
	        
	        // Run reverse 
	        // 
	        #qUDT_RollerConveyorInterface.RunRvs :=
	        (#iUDT_Configuration.RollerConveyor.Runfwd                      // Standard direction forward
	        AND ((#sx_RollerTransportIn AND (#si_Conveyor = 2))             // Transport in and transporting from infeed 2
	        OR (#sx_RollerTransportOut AND #iUDT_Configuration.Conveyor1.IsOutfeed AND #iqUDT_HandShakeConveyor1.RTR)))     // Transport out and 1 is outfeed
	        
	        OR
	        (NOT #iUDT_Configuration.RollerConveyor.Runfwd                  // Standard direction is reverse
	        AND ((#sx_RollerTransportIn AND (#si_Conveyor = 1))             // Transport in and transporting from infeed 1
	        OR (#sx_RollerTransportOut AND #iUDT_Configuration.Conveyor2.IsOutfeed AND #iqUDT_HandShakeConveyor2.RTR)));     // Transport out and 2 is outfeed
	        
	        
	        // Hold signal to conveyor
	        #qUDT_RollerConveyorInterface.Hold := NOT #qUDT_RollerConveyorInterface.RunFwd AND NOT #qUDT_RollerConveyorInterface.RunRvs;
	        
	        // Handshake to rollerconveyor
	        #iqUDT_HandShakeRollerConveyor.GIN := 0;
	        #iqUDT_HandShakeRollerConveyor.NrOfPosToShift := 0;
	        
	        // When transporting in, corresponding data from infeed is copied to outfeed
	        IF #sx_RollerTransportIn AND (#si_Conveyor = 1)
	        THEN
	            #iqUDT_HandShakeRollerConveyor.GIN := #iqUDT_HandShakeConveyor1.GIN;
	            #iqUDT_HandShakeRollerConveyor.NrOfPosToShift += #iqUDT_HandShakeConveyor1.NrOfPosToShift;
	            
	        ELSIF #sx_RollerTransportIn AND (#si_Conveyor = 2)
	        THEN
	            #iqUDT_HandShakeRollerConveyor.GIN := #iqUDT_HandShakeConveyor2.GIN;
	            #iqUDT_HandShakeRollerConveyor.NrOfPosToShift += #iqUDT_HandShakeConveyor2.NrOfPosToShift;
	            
	        END_IF;
	        #iqUDT_HandShakeConveyor1.NrOfPosToShift := 0;
	        #iqUDT_HandShakeConveyor2.NrOfPosToShift := 0;
	    END_REGION
	    
	    REGION 8.3 - Beltconveyor
	        
	        #iqUDT_HandShakeBeltConveyor.RTR := TRUE;
	        
	        // Run forward : When standard direction is forward and receiving transport from direction 3 or outfeed transport to direction 4
	        //              Or standard direction is reverse and receiving transport from direction 4 or outfeed transport to direction 3
	        #qUDT_BeltConveyorInterface.RunFwd :=
	        (#iUDT_Configuration.BeltConveyor.Runfwd
	        AND ((#sx_BeltTransportIn AND (#si_Conveyor = 3))
	        OR (#sx_BeltTransportOut AND #iUDT_Configuration.Conveyor4.IsOutfeed AND #iqUDT_HandShakeConveyor4.RTR)))
	        OR
	        (NOT #iUDT_Configuration.BeltConveyor.Runfwd
	        AND ((#sx_BeltTransportIn AND (#si_Conveyor = 4))
	        OR (#sx_BeltTransportOut AND #iUDT_Configuration.Conveyor3.IsOutfeed AND #iqUDT_HandShakeConveyor3.RTR)));
	        
	        
	        // Run reverse : When standard direction is reverse and receiving transport from direction 3 or outfeed transport to direction 4
	        //              Or standard direction is forward and receiving transport from direction 4 or outfeed transport to direction 3
	        #qUDT_BeltConveyorInterface.RunRvs :=
	        (#iUDT_Configuration.BeltConveyor.Runfwd
	        AND ((#sx_BeltTransportIn AND (#si_Conveyor = 4))
	        OR (#sx_BeltTransportOut AND #iUDT_Configuration.Conveyor3.IsOutfeed AND #iqUDT_HandShakeConveyor3.RTR)))
	        OR
	        (NOT #iUDT_Configuration.BeltConveyor.Runfwd
	        AND ((#sx_BeltTransportIn AND (#si_Conveyor = 3))
	        OR (#sx_BeltTransportOut AND #iUDT_Configuration.Conveyor4.IsOutfeed AND #iqUDT_HandShakeConveyor4.RTR)));
	        
	        // Hold signal to conveyor
	        #qUDT_BeltConveyorInterface.Hold := NOT #qUDT_BeltConveyorInterface.RunFwd AND NOT #qUDT_BeltConveyorInterface.RunRvs;
	        
	        
	        #iqUDT_HandShakeBeltConveyor.GIN := 0;
	        #iqUDT_HandShakeBeltConveyor.NrOfPosToShift := 0;
	        
	        // When transporting in, corresponding data from infeed is copied to outfeed
	        IF #sx_BeltTransportIn AND (#si_Conveyor = 3)
	        THEN
	            #iqUDT_HandShakeBeltConveyor.GIN := #iqUDT_HandShakeConveyor3.GIN;
	            #iqUDT_HandShakeBeltConveyor.NrOfPosToShift += #iqUDT_HandShakeConveyor3.NrOfPosToShift;
	            
	        ELSIF #sx_BeltTransportIn AND (#si_Conveyor = 4)
	        THEN
	            #iqUDT_HandShakeBeltConveyor.GIN := #iqUDT_HandShakeConveyor4.GIN;
	            #iqUDT_HandShakeBeltConveyor.NrOfPosToShift += #iqUDT_HandShakeConveyor4.NrOfPosToShift;
	            
	        END_IF;
	        #iqUDT_HandShakeConveyor3.NrOfPosToShift := 0;
	        #iqUDT_HandShakeConveyor4.NrOfPosToShift := 0;
	    END_REGION
	    
	    
	    REGION 8.4 - Handshake in-outfeed conveyors 
	        
	        IF #iUDT_Configuration.Conveyor1.IsInfeed
	        THEN
	            // Infeed conveyor low level
	            #iqUDT_HandShakeConveyor1.CascadeStartUp := #sx_AutomaticActive;
	            #iqUDT_HandShakeConveyor1.RTR := ((#sx_RollerRTR OR #iqUDT_HandShakeConveyor1.TIP) AND (#si_Conveyor = 1));
	            #iqUDT_HandShakeConveyor1.ResetEnergySave := false;
	            IF #iqUDT_HandShakeConveyor1.TIP
	            THEN
	                #sx_RollerRTR := False;
	            END_IF;
	        ELSE
	            // Outfeed conveyor low level 
	            #iqUDT_HandShakeConveyor1.RTS := #sx_RollerTransportOut;
	            #iqUDT_HandShakeConveyor1.TIP := #qUDT_RollerConveyorInterface.RunFwd OR #qUDT_RollerConveyorInterface.RunRvs;
	            IF #sx_RollerTransportOut
	            THEN
	                #iqUDT_HandShakeConveyor1.GIN := #si_Gin;
	                #iqUDT_HandShakeConveyor1.NrOfPosToShift := 1;
	            ELSE
	                #iqUDT_HandShakeConveyor1.GIN := 0;
	                #iqUDT_HandShakeConveyor1.NrOfPosToShift := 0;
	            END_IF;
	        END_IF;
	        
	        IF #iUDT_Configuration.Conveyor2.IsInfeed
	        THEN
	            // Infeed conveyor low level
	            #iqUDT_HandShakeConveyor2.CascadeStartUp := #sx_AutomaticActive;
	            #iqUDT_HandShakeConveyor2.RTR := ((#sx_RollerRTR OR #iqUDT_HandShakeConveyor2.TIP) AND (#si_Conveyor = 2));
	            #iqUDT_HandShakeConveyor2.ResetEnergySave := false;
	            IF #iqUDT_HandShakeConveyor2.TIP
	            THEN
	                #sx_RollerRTR := False;
	            END_IF;
	        ELSE
	            // Outfeed conveyor low level
	            #iqUDT_HandShakeConveyor2.RTS := #sx_RollerTransportOut;
	            #iqUDT_HandShakeConveyor2.TIP := #qUDT_RollerConveyorInterface.RunFwd OR #qUDT_RollerConveyorInterface.RunRvs;
	            IF #sx_RollerTransportOut
	            THEN
	                #iqUDT_HandShakeConveyor2.GIN := #si_Gin;
	                #iqUDT_HandShakeConveyor2.NrOfPosToShift := 1;
	            ELSE
	                #iqUDT_HandShakeConveyor2.GIN := 0;
	                #iqUDT_HandShakeConveyor2.NrOfPosToShift := 0;
	            END_IF;
	        END_IF;
	        
	        IF #iUDT_Configuration.Conveyor3.IsInfeed
	        THEN
	            // Infeed conveyor high level
	            #iqUDT_HandShakeConveyor3.CascadeStartUp := #sx_AutomaticActive;
	            #iqUDT_HandShakeConveyor3.RTR := ((#sx_BeltRTR OR #iqUDT_HandShakeConveyor3.TIP) AND (#si_Conveyor = 3));
	            #iqUDT_HandShakeConveyor3.ResetEnergySave := false;
	            IF #iqUDT_HandShakeConveyor3.TIP
	            THEN
	                #sx_BeltRTR := False;
	            END_IF;
	        ELSE
	            // Outfeed conveyor high level 
	            #iqUDT_HandShakeConveyor3.RTS := #sx_BeltTransportOut;
	            #iqUDT_HandShakeConveyor3.TIP := #qUDT_BeltConveyorInterface.RunFwd OR #qUDT_BeltConveyorInterface.RunRvs;
	            IF #sx_BeltTransportOut
	            THEN
	                #iqUDT_HandShakeConveyor3.GIN := #si_Gin;
	                #iqUDT_HandShakeConveyor3.NrOfPosToShift := 1;
	            ELSE
	                #iqUDT_HandShakeConveyor3.GIN := 0;
	                #iqUDT_HandShakeConveyor3.NrOfPosToShift := 0;
	            END_IF;
	            
	        END_IF;
	        
	        IF #iUDT_Configuration.Conveyor4.IsInfeed
	        THEN
	            // Infeed conveyor high level
	            #iqUDT_HandShakeConveyor4.CascadeStartUp := #sx_AutomaticActive;
	            #iqUDT_HandShakeConveyor4.RTR := ((#sx_BeltRTR OR #iqUDT_HandShakeConveyor4.TIP) AND (#si_Conveyor = 4));
	            #iqUDT_HandShakeConveyor4.ResetEnergySave := false;
	            IF #iqUDT_HandShakeConveyor4.TIP
	            THEN
	                #sx_BeltRTR := False;
	            END_IF;
	        ELSE
	            // Outfeed conveyor high level 
	            #iqUDT_HandShakeConveyor4.RTS := #sx_BeltTransportOut;
	            #iqUDT_HandShakeConveyor4.TIP := #qUDT_BeltConveyorInterface.RunFwd OR #qUDT_BeltConveyorInterface.RunRvs;
	            IF #sx_BeltTransportOut
	            THEN
	                #iqUDT_HandShakeConveyor4.GIN := #si_Gin;
	                #iqUDT_HandShakeConveyor4.NrOfPosToShift := 1;
	            ELSE
	                #iqUDT_HandShakeConveyor4.GIN := 0;
	                #iqUDT_HandShakeConveyor4.NrOfPosToShift := 0;
	            END_IF;
	            
	        END_IF;
	    END_REGION
	    
	END_REGION
	
	REGION 9 - Statistics
	    
	    REGION 9.1 - Device up time
	        
	        IF #sx_UpTime OR #iqUDT_EquipmentControl.Command.ResetData      // Reset statistics
	        THEN
	            
	            "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,  // Reset statistics input
	                            ix_Activate := #sx_UpTime,
	                            ix_RTrigActivate := #sR_TRIG_DeviceUpTime.Q,            // Statistics active trigger
	                            iqUDT_Statistics := #iqUDT_Statistics.ConveyorUp);      // Statistics values output
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 9.2 - Device down time
	        
	        // Conveyor down is when conveyor is not in manual mode and has an error
	        IF #sx_DownTime OR #iqUDT_EquipmentControl.Command.ResetData OR #sUDT_Status.SafetyStop     // Reset statistics
	        THEN
	            
	            "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,  // Reset statistics input
	                            ix_Activate := #sx_DownTime OR #sUDT_Status.SafetyStop, // Activate statistics functions input
	                            ix_RTrigActivate := #sR_TRIG_DeviceDownTime.Q,          // Statistics active trigger
	                            iqUDT_Statistics := #iqUDT_Statistics.ConveyorDown);    // Statistics values output
	            
	        END_IF;
	    END_REGION
	    
	    REGION 9.3 - Device stop time
	        
	        IF #sx_StoppedTime OR #iqUDT_EquipmentControl.Command.ResetData // Reset statistics
	        THEN
	            
	            "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,  // Reset statistics input
	                            ix_Activate := #sx_StoppedTime,                         // Activate statistics functions input
	                            ix_RTrigActivate := #sR_TRIG_DeviceStopped.Q,           // Statistics active trigger
	                            iqUDT_Statistics := #iqUDT_Statistics.ConveyorStop);    // Statistics values output
	            
	        END_IF;
	    END_REGION
	    
	END_REGION
	
	REGION 10 - Report to control block    
	    // Function to manage report between control block and conveyor block
	    "FC_EquipmentReport"(iUDT_Status := #sUDT_Status,
	                         iqUDT_Control := #iqUDT_EquipmentControl);
	    
	END_REGION
	
	REGION 11 - Internal errors and warnings reset
	    
	END_REGION
	
	
	
	
	
	
	
	
	
	
END_FUNCTION_BLOCK

