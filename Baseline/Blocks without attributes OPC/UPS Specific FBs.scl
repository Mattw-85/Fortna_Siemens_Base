TYPE "UDT_CommonStatus"
TITLE = UDT_CommonStatus
VERSION : 0.1
//User-defined structure of common statuses.
   STRUCT
      SafetyStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Emergancy stop
      Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // An error is active
      Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // A warning is active
      ManualRun { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Running in manual mode
      Manual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // In manual mode
      Halted { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Halted
      Dieback { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // In dieback
      Stopped { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stopped
      Running { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Running
      EnergySave { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // In energy saving mode
      AutoON { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Automatic started
   END_STRUCT;

END_TYPE

TYPE "UDT_GINStandard"
VERSION : 0.1
   STRUCT
      Destination : Array[0..20] of DInt;   // Destination
      Identification : Struct   // Barcode identification
         GoodRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Barcode read was succesful
         NoRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Barcode read was unsuccesful
         MultiRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Multiple Barcodes were detected
         Barcode : Array[0..10] of Char;   // Barcode values
      END_STRUCT;
      GinAssigned { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // GIN is assigned to package
      Lost { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Lost in tracking
      Length : Int;   // Length in mm
      Width : Int;   // Width in mm
      Height : Int;   // Height in mm
      Weight : DInt;   // Weight in g
      PkgTooLong { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is too long
      PkgTooSmall { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is too small
      PkgTooHigh { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is too high
      PkgOverWeight { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is over weight
      TrailingGap : Int;   // Trailing gap size in cm between the package
      LeadingGap : Int;   // Leading gap size in cm between the package
      NrOfRecirculations : Int;   // Number of recirculations
      DestReqSend { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Destination request sent to high level
      DestRcv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Destination received from high level
      SortStatus : Struct   // Sort status of the package
         DivertDestination : Int;   // Destination to which the package is diverted
         GoodDivert { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package diverted
         FailedDivert { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package failed to divert
         NoDivert : Bool := TRUE;   // Divert is not activated
         NoDivertCause : Struct   // Cause for no divert
            ChuteJam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Chute is jammed
            ChuteFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Chute is full
            NoRTR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Downstream conveyor is not ready to receive
            DestDisabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Destination is disabled
            TrayDisabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Tray is disabled
            SorterNotAtSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sorter is not at speed
            LeadingGapError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Gap size with downstream parcel is not enough
            TrailingGapError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Gap size with upstream parcel is not enough
            PkgTooHigh { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is too high to divert
            PkgTooLong { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is too long to divert
            DestNotReachable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sort destionation is not reachable
            InvalidDest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sort destination is invalid
            DestTooLate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Destination too late
            NoDestRcv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Destination not received from high level
         END_STRUCT;
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_GINFedEx"
VERSION : 0.1
   STRUCT
      Timestamp : String[17];   // Local time timestamp
      TimeZoneDesignator : String[5];   // Time zone designator
      PackageEntrancePoint : String[14];   // Entrance point, where LLC starts tracking the parcel.
      PackageEntranceState : String[1];   // Entrance state
      PackageExitPoint : String[14];   // Exit point name, where LLC reports the last known tracking point.
      PackageExitState : String[1];   // Exit point state when LLC reports the last known tracking point.
      PalletType : String[2];   // Pallet code for different type of pallets on the market
      Mask : String[1];   // Flag to indicate that a pallet has been mask.
      CellNumber : String[4];   // Tray/Cell number (for loop sorters) or generated by LLC (on line sorters).
      CellsOccupied : String[1];   // Cells occupied by the piece for loop sorters.
      ImageID : String[6];   // Image ID number created by the ADC system.
      ScanUnitType : String[1];   // Scan unit type
      ADCSystemID : String[15];   // Number assigned by the ADC system
      PackageID : String[15];   // Number assigned by the LLC system
      LLCSystemID : String[15];
      HLCPackageID : String[10];   // Unique number for the specific package during it stays in HLC system.
      HLCResultCode : String[16];   // Result code based on processing of the scan event messages.
      ShipmentID : String[6];   // Consignment id of the parcel.
      WeightStatus : String[1];   // Status to indicate if the parcel/pallet has weight on the system.
      ActualDestination : String[6];   // Location code value that describes the actual disposition of the package.
      Destination1 : String[6];   // Location code value that describes where the package should go (Diverter Number).
      Destination2 : String[6];   // Location code value that describes where the package should go (Diverter Number).
      Destination3 : String[6];   // Location code value that describes where the package should go (Diverter Number).
      Destination4 : String[6];   // Location code value that describes where the package should go (Diverter Number).
      Destination5 : String[6];   // Location code value that describes where the package should go (Diverter Number).
      CutOffTimeDestination1 : String[5];   // Cut Off Time in Local Time.
      CutOffTimeDestination2 : String[5];   // Cut Off Time in Local Time.
      CutOffTimeDestination3 : String[5];   // Cut Off Time in Local Time.
      CutOffTimeDestination4 : String[5];   // Cut Off Time in Local Time.
      CutOffTimeDestination5 : String[5];   // Cut Off Time in Local Time.
      ReasonCode1 : String[8];   // Management Code value that describes the result of attempting to route the package to the Destination
      ReasonCode2 : String[8];   // Management Code value that describes the result of attempting to route the package to the Destination
      ReasonCode3 : String[8];   // Management Code value that describes the result of attempting to route the package to the Destination
      ReasonCode4 : String[8];   // Management Code value that describes the result of attempting to route the package to the Destination
      ReasonCode5 : String[8];   // Management Code value that describes the result of attempting to route the package to the Destination
      HLCDataText : String[20];   // Free text for future use.
      Customs : String[1];   // Need to be checked by customs
      DIMSystemID : String[15];   // Identifier of dimensioning system.
      DIMStatus : String[5];   // Basic diagnostic information from the dimensioning system at the moment of the measurement.
      PackageDimLength : String[6];   // Length dimension of package in resolution of dim system.
      PackageDimWidth : String[6];   // Width dimension of package in resolution of dim system.
      PackageDimHeight : String[6];   // Height dimension of package in resolution of dim system.
      DIMUOM : String[2];   // Unit of measure of the package dimensions.
      DimLFTstatusCode : String[8];   // Dimension LFT status code.
      DimConfidence : String[2];   // The level of assurance for the correct dimensions.
      DimensionSource : String[1];   // For combined camera/laser dim acquisition devices. It indicates type of capturing mode
      AlibiDims : String[25];   // Alibi for Dimensions
      SCLSystemID : String[15];   // Identifier of weight scale.
      SCLStatus : String[5];   // Basic diagnostic information from the weight scale system.
      SCLWT : String[6];   // Scale weight of package in resolution of scale system.
      SCLWTUOM : String[2];   // Unit of measurement for Weight
      SCLLFTStatusCode : String[2];   // Scale LFT status code.
      AlibiWeight : String[25];   // Alibi for Weight
      ReasonCode : String[1];   // This code should be used when the SI message has some defect.
      Stackable : String[1];   // If stackable recognition is enabled, Y or N
      Stickerstype : String[2];   // When optical recognition is used to sort
      FlyingDocument : String[1];   // Status to confirm if the document/flyer is prone to fly off the sorter.
      ModeofOperation : String[1];   // Camera Tunnel operational mode format:
      CameraHeadstatus : String[2];   // Diagnostic information on camera/laser heads performing barcode reads.
      PackageDataTruncated : String[1];   // Y = Full length of barcode data exceeds 9999 bytes, data truncated
      TotalBarcodeDataLength : String[4];   // Length of all barcode data that was sent in bytes;
      Barcode1Identification : String[3];   // Barcode identifier code.
      Barcode1status : String[2];   // Barcode confidence factor
      Barcode1datalength : String[4];   // String length of barcode data in bytes; inclusive of this field. Use 0054 as a fixed value
      Barcode1data : String[50];   // Highest priority barcode
      Barcode2Identification : String[3];   // Barcode identifier code.
      Barcode2status : String[2];   // Barcode confidence factor
      Barcode2datalength : String[4];   // String length of barcode data in bytes; inclusive of this field. Use 0054 as a fixed value
      Barcode2data : String[50];   // Highest priority barcode
      Barcode3Identification : String[3];   // Barcode identifier code.
      Barcode3status : String[2];   // Barcode confidence factor
      Barcode3datalength : String[4];   // String length of barcode data in bytes; inclusive of this field. Use 0054 as a fixed value
      Barcode3data : String[50];   // Highest priority barcode
      BarcodeIdentification : String[3];   // Barcode identifier code.
      Barcodestatus : String[2];   // Barcode confidence factor
      Barcodedatalength : String[4];   // String length of barcode data in bytes
      Barcodedata : String[50];   // Sortation barcode
      CustomerID : DInt;   // 6 digits SequentialID (NNNNNN)
      AreaNumber : String[2];   // Package Sequence ID "Area Number"
      PurgeEnabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Purge enabled for parcel: destination overwritten with Purge destination
   END_STRUCT;

END_TYPE

TYPE "UDT_GINUPS"
VERSION : 0.1
   STRUCT
      TRKNUM : String[18];   // Tracking number
      PKGUID : String[32];   // Package ID
      MSGID : String[32];   // Message ID
      Length : Int;   // Camera Length in mm
      Width : Int;   // Camera Width in mm
      Height : Int;   // Camera Height in mm
      Weight : DInt;   // Weight in g
      IDCreated { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 1, Bit 0 - PLCID created or TrayID Read
      DimDataRcv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 1, Bit 1 - Package Dimensional Data Received via Camera Scan Data Message
      PkgWrongInduct { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 1, Bit 2 - Package Did NOT Induct Properly (Non-Tray Systems)
      IDCalcFromCamID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 2, Bit 0 - PLCID/TrayID Calculated From CamID
      UnknownParcelID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 2, Bit 4 - Unknown Parcel ID
      UndefinedProblem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 2, Bit 5 - Un-Defined Problem
      UnrecognizedCmd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 2, Bit 6 - Un-recognized command
      SorterInMainteneceMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 2, Bit 7 - Sorter in Maintenance/Commissioning Mode
      DestUserSusp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 3, Bit 3 - Destination User Suspended
      SorterNotSynch { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 3, Bit 6 - Sorter NOT Synchronized (Tilt Tray Systems)
      PkgDetAtVerCheckPoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 4, Bit 0 - Package Detected at Verification Check Point
      ChuteFullAftrAlterDest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 4, Bit 7 - Preferred chute full after passed alternate destination
      ChuteNotAvailAfterAlterDest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 5, Bit 0 - Preferred chute not available after passed alternate destination
      PLCRedirected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 5, Bit 2 - PLC Redirected
      ThreatParcel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Threat parcel
   END_STRUCT;

END_TYPE

TYPE "UDT_GINDHL"
VERSION : 0.1
   STRUCT
      ObjectID : String[10];   // Object ID
      VID : String[16];   // Virtual Item Identifier (VID)
      PieceID : String[40];   // Piece ID barcodes
      SortStrategy : String[1];   // Sort Strategy 1 - Highest priority available , 2 - Nearest
      ParcelReject { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Parcel reject
      Destination : Array[1..6] of Struct   // Destination
         ID : UInt;   // ID
         SortCommandActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sort command
         ParcelSorted { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parcel sorted
         Rejected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parcel rejected
         Reason : Int;   // Reason
      END_STRUCT;
      ParcelLocation : Struct   // Parcel Location
         Current : UInt;   // Current
         Last : UInt;   // Last
         Sort : UInt;   // Sort
      END_STRUCT;
      MFCMessage : Struct   // MFC Sort messages
         Sent : Struct   // Messages sent from the PLC to the MFC system
            SortResult { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Sort Result
            VIDResponse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message VID Response
            ScanReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Scan Reset
            XrayResult { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Xray result
            ParcelRegInfo { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Xray registration info
         END_STRUCT;
         Received : Struct   // Messages received from the MFC system to the PLC
            RejectParcel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Reject Parcel
            Destination { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Destination
            DestinationResent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Destination Resent
            TemporaryParcelIdentifier { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Temporary Parcel Identifier
            XrayRegistrationInfo { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         END_STRUCT;
      END_STRUCT;
      Xray : Struct   // Xray data structure
         RoutingCode : String[2];   // Routing code
         Group : String[1];   // The group field is used to identify the group of the operator decisions came from in a
         Level : String[1];   // Level field is used to identify which level the operator decision came from in a
         Result : String[1];   // Results can be indicated with the following:A = Accept, R = Reject, U = Unavailable (Timeout), Z = High Threat
         BagIDMessage : Struct   // Message from PLC to Xray
            MessagePrepared { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message is prepared and ready to send
            WrongMessageStructure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message has wrong structure
            Sent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message sent by PLC to Xray
            SentTime : String;   // Time when message sent by PLC to Xray
            NotSent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message was not sent from the PLC
            Received { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message received by Xray
            TimeReceived : String;   // Time when message received by Xray
            NotReceived { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message did not reach Xray
         END_STRUCT;
         DecisionMessage : Struct   // Message from Xray to PLC
            Received { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message received by PLC
            ReceivedTime : String;   // The message received by PLC
            NotReceivedOnTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message did not reach PLC
         END_STRUCT;
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_GINWCS"
VERSION : 0.1
   STRUCT
      ActionTaken : String;   // Location code value that describes the actual disposition of the package
      Destination1 : String[20];   // Location code value that describes where the package should go (Diverter Number)
      Destination2 : String[20];   // Location code value that describes where the package should go (Diverter Number)
      Destination3 : String[20];   // Location code value that describes where the package should go (Diverter Number)
      Destination4 : String[20];   // Location code value that describes where the package should go (Diverter Number)
      Destination5 : String[20];   // Location code value that describes where the package should go (Diverter Number)
      ReasonCode : String[2];   // Management Code value that describes the result of attempting to route the package to the Destination
      Barcode1 : String;   // Barcode identifier code
      Barcode2 : String;
      Barcode3 : String;
      Barcode4 : String;
   END_STRUCT;

END_TYPE

TYPE "UDT_GINWES"
VERSION : 0.1
   STRUCT
      Barcode : String[40];
   END_STRUCT;

END_TYPE

TYPE "UDT_UPSHealth"
TITLE = UDT_Health
VERSION : 0.1
//User-defined structure of UPS health message data.
   STRUCT
      "Type" : String;
      Failure : DInt;
      Model : String;
      Error : Bool;
   END_STRUCT;

END_TYPE

TYPE "UDT_FifoStatus"
TITLE = UDT_FifoStatus
VERSION : 0.1
//
//User-defined structure of FC_Fifo function status.
//Version History:
//Date              | Version   | Author         | Remark
//24/05/2019  | 0.1           | K.Pokorski   | first release MHSE TIA 15.1
//24/05/2019  | 0.2           | K.Pokorski   | first release MHSE TIA 15.1
//
   STRUCT
      InvalidMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid mode selected
      InvalidMaxNrOfEntries { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid maximum number of entries or buffer is not an array
      InvalidTotalEntriesStored { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid total number of entries
      InvalidNextEntryToWrite { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid number of next entry to write
      InvalidNextEntryToRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid number of next entry to read
      InvalidDataType { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message and buffer element data type inconsistent
      FifoPreFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 90 % of FIFO data buffer capacity reached
      FifoFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO data buffer full
   END_STRUCT;

END_TYPE

DATA_BLOCK "DB_Memory"
TITLE = DB_Memory
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
VERSION : 3.0
NON_RETAIN
   VAR 
      ClockByte { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // System clock byte
      Clock_10Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 10 Hz system clock bit
      Clock_5Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 5 Hz system clock bit
      "Clock_2.5Hz" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 2.5 Hz system clock bit
      Clock_2Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 2 Hz system clock bit
      "Clock_1.25Hz" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1.25 Hz system clock bit
      Clock_1Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 Hz system clock bit
      "Clock_0.625Hz" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0.625 Hz system clock bit
      "Clock_0.5Hz" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0.5 Hz system clock bit
      SystemByte { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // System byte
      OSClockByte { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // One shot of clock pulse
      "OS_0.1sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 0.1 sec
      "OS_0.2sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 0.2 sec
      "OS_0.4sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 0.4 sec
      "OS_0.5sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 0.5 sec
      "OS_0.8sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 0.8 sec
      OS_1sec { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 1 sec
      "OS_1.6sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 1.6 sec
      OS_2sec { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 2 sec
      PrevCycleTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Previous PLC cycle Time
      RuntimeMem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Runtime memory
      FirstScan { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // First scan bit
      DiagStatusUpdate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Diagnostic status update
      AlwaysTrue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Always True bit
      AlwaysFalse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Always False bit
      CommissioningFalse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Commissioning always false
      CommissioningTrue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Commissioning always true
      ReconnectCommand { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reconnect command
      ScanMainRack { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Trigger to check main rack confiuration
      ScanProfinet { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Scan profinet bit
      Simulation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Simulation
      PN1OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet ok
      "Local~PROFINET_IO-System" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IO System
      "Local~PROFINET_IO-System_1" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 1
      "Local~PROFINET_IO-System_2" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 2
      "Local~PROFINET_IO-System_3" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 3
      "Local~PROFINET_IO-System_4" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 4
      "Local~PROFINET_IO-System_5" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 5
      "Local~PROFINET_IO-System_6" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 6
      "Local~PROFINET_IO-System_7" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 7
      "Local~PROFINET_IO-System_8" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 8
      "Local~PROFINET_IO-System_9" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 9
   END_VAR


BEGIN

END_DATA_BLOCK

TYPE "UDT_GIN"
VERSION : 0.1
   STRUCT
      General { S7_SetPoint := 'False'} : "UDT_GINStandard";
      FedEx { S7_SetPoint := 'False'} : "UDT_GINFedEx";
      UPS { S7_SetPoint := 'False'} : "UDT_GINUPS";
      DHL { S7_SetPoint := 'False'} : "UDT_GINDHL";
      WCS { S7_SetPoint := 'False'} : "UDT_GINWCS";
      WES { S7_SetPoint := 'False'} : "UDT_GINWES";
   END_STRUCT;

END_TYPE

TYPE "UDT_FifoHeader"
TITLE = UDT_FifoHeader
VERSION : 0.1
//User-defined structure of FIFO register header information.
   STRUCT
      Status : Struct   // Status bits
         Empty { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO Empty
         Prefull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO Prefull
         Full { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO Full
      END_STRUCT;
      NextEntryToRead : Int;   // Next FIFO entry to read
      NextEntryToWrite : Int;   // Next FIFO entry to write
      MaxNrOfEntries : Int;   // Maximum number of FIFO entries
      TotalEntriesStored : Int;   // Total number of FIFO entries
   END_STRUCT;

END_TYPE

TYPE "UDT_EventStatistic"
TITLE = UDT_EventStatistic
VERSION : 0.1
//User-defined structure of event statistic data.
   STRUCT
      NumberOfTimes : DInt;   // Number of times the event occurred since last reset
      LastEventSeconds : DInt;   // Number of seconds of the current or last event
      TotalEventSeconds : DInt;   // Total number of seconds the event occurred since last reset
   END_STRUCT;

END_TYPE

TYPE "UDT_EquipmentControl"
TITLE = UDT_EquipmentControl
VERSION : 0.1
//User-defined structure of equipment control commands.
   STRUCT
      Command : Struct   // Control command
         Start { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start conveyor
         Stop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stop conveyor
         Reset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Faults reset
         ResetData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Statistics reset
         ManualMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual mode required
         DisableManualMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disable manual mode
         AutomaticOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // System is started in automatic mode
         StopRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      END_STRUCT;
      Report { S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Conveyors state
      Request : Struct   // Request from equipment
         RestartRequired { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Restart required from system control
         SignalingRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Beeper required
         InhibitStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      END_STRUCT;
   END_STRUCT;

END_TYPE

FUNCTION "FC_GetNrOfArrayEl" : Int
TITLE = FC_GetNrOfArrayEl
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 19
// END_ATTRIBUTES
//Function to get the number of array elements.
   VAR_INPUT 
      iv_Array : Variant;   // Input array
   END_VAR

   VAR_TEMP 
      ti_NrOfArrayEl : Int;   // Number of array elements
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	27/08/2019  | 2.1       | K.Pokorski    | Comments adjusted
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – Number of an array elements
	    
	    IF IS_ARRAY(#iv_Array)                                                  // Input variable is an array
	    THEN
	        
	        #ti_NrOfArrayEl := UDINT_TO_INT(CountOfElements(#iv_Array));
	        
	        // Reset array length if the input variable isn't an array
	    ELSE
	        
	        #ti_NrOfArrayEl := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 – Return output
	    
	    #FC_GetNrOfArrayEl := #ti_NrOfArrayEl;
	    
	END_REGION
	
END_FUNCTION

TYPE "UDT_UPSScanData2"
TITLE = UDT_ScanData2
VERSION : 0.1
//User-defined structure of UPS SCAN_DATA2 data.
   STRUCT
      MSGID : String;
      CONFLICT_CODE : String;
      BARCODE_ZIP : String;
      BARCODE_TRACK : String;
      BARCODE_PTN : String;
      MAXI_ZIPCODE : String;
      MAXI_COUNTRY : String;
      MAXI_SERVICE : String;
      MAXI_TRACK : String;
      MAXI_SHIPPER : String;
      LENGTH1 : String;
      LENGTH2 : String;
      HEIGHT : String;
      VERTEX : String;
      ORIENTATION : String;
      OVERHANG : String;
      WEIGHT : String;
      APPENDED_DATA : Struct
         Constant_1 : String := '1';
         FRAME_ID : String;
         DIMENSION : String;
         PACKAGE_NUMBER : String;
         BARCODE_1 : String;
         DESCRIPTION_1 : String;
         BARCODE_2 : String;
         DESCRIPTION_2 : String;
         BARCODE_3 : String;
         DESCRIPTION_3 : String;
         Constant_4 : String := '4';
         SCALE_WEIGHT : String;
         Constant_5 : String := '5';
         GIRTH : String;
         Constant_6 : String := '6';
         ERROR_CODE : String;
      END_STRUCT;
   END_STRUCT;

END_TYPE

DATA_BLOCK "DB_GIN"
TITLE = DB_GIN
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
NON_RETAIN
//Data block to store parcels informations.
   VAR 
      GIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Array[1..1] of "UDT_GIN";   // GIN informations - for project remove unneeded customers and extend array bound range to 9999
   END_VAR


BEGIN

END_DATA_BLOCK

TYPE "UDT_UPSMessage"
VERSION : 0.1
   STRUCT
      SCN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[15];   // Sender Client Name
      SCT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[8];   // Sender Client Type
      RCN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[15];   // Receiver Client Name
      RCT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[8];   // Receiver Client Type
      MT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Message type
      Data { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..35] of String[32];   // Buffer for message data fields
   END_STRUCT;

END_TYPE

TYPE "UDT_UPSExternalReader"
VERSION : 0.1
   STRUCT
      NameIdentifier : String := 'CAMERA';   // Device name idetifier
      IPAddress : String[15];
      State : Bool;
      HealthMessage { S7_SetPoint := 'False'} : "UDT_UPSHealth";   // Health message data
      ScanData2Message { S7_SetPoint := 'False'} : "UDT_UPSScanData2";   // ScanData2 message data
   END_STRUCT;

END_TYPE

TYPE "UDT_Connection"
TITLE = UDT_Connection
VERSION : 0.1
//User-defined structure of connection parameters.
   STRUCT
      ActiveEstablished : Bool := FALSE;   // 0 – Passive connection establishment; 1 – Active connection establishment
      Interface_ID : HW_ANY := 64;   // Interface ID of CPU Ethernet interface
      ID : CONN_OUC;   // Unique ID as system reference for the connection
      IP : Array[1..4] of Int;   // IP address
      Port : UInt;   // Port number of the communication partner
      ConTimeout : DInt;   // Maximum waiting time for response from the communication partner [ms]
   END_STRUCT;

END_TYPE

TYPE "UDT_Message"
TITLE = UDT_Message
VERSION : 0.1
//User-defined structure of the message characters array.
   STRUCT
      Character : Array[0..499] of Char;   // Message character
   END_STRUCT;

END_TYPE

TYPE "UDT_TCPIPConnectStatistics"
TITLE = UDT_TCPIPConnectStatistics
VERSION : 0.1
//User-defined structure of FB_TCPIPConnect function block statistics.
   STRUCT
      ConnectionLost { S7_SetPoint := 'False'} : "UDT_EventStatistic";   // Connection lost statistics
   END_STRUCT;

END_TYPE

DATA_BLOCK "DB_HMIStatusConfiguration"
TITLE = DB_HMIStatusConfiguration
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
VERSION : 3.0
NON_RETAIN
   VAR 
      FireAlarm : Int;   // Fire alarm active
      SafetyStop : Int;   // Safety stop error status
      Error : Int;   // Error status
      Warning : Int;   // Warning status
      ManualRun : Int;   // Manual run status
      Manual : Int;   // Manual status
      Halted : Int;   // Halted status
      Dieback : Int;   // Die back status
      Stopped : Int;   // Stopped status
      Running : Int;   // Running status
      EnergySave : Int;   // Energy save status
      CommunicationError : Int;   // Communication error status
      CBError : Int;   // CB error status
      ProfinetError : Int;   // Profinet error status
      HardwareError : Int;   // Hardware error status
      VFDNotHealthy : Int;   // VFD noth healthy status
      VFDError : Int;   // VFD error status
      PECJam : Int;   // PEC jam status
      ChuteFull : Int;   // Chute full status
      EncoderError : Int;   // Encoder error status
      TrackingError : Int;   // Tracking error status
      DimensionError : Int;   // Dimension error status
      OperationalError : Int;   // Operational error status
      AutoON : Int;   // Automatic is on
      ChuteHalfFull : Int;   // Disable by operator
      DisableByManagement : Int;   // Disable by management
      GateOpen : Int;   // Manual operated gate is open
      GateClosed : Int;   // Manual operated gate is closed
      GateClosedAndNoOperatorPresent : Int;   // Manual operated gate is closed and no operator is present
      PositionChangeOngoing : Int;   // Lifting device or arm diverter changing position
      BufferMode : Int;   // BufferMode Active
      ContinuousMode : Int;   // ContinuousMode Active
      LabbelingMode : Int;   // LabbelingMode Active
   END_VAR


BEGIN
   FireAlarm := 1;
   SafetyStop := 3;
   Error := 5;
   Warning := 7;
   ManualRun := 9;
   Manual := 11;
   Halted := 13;
   Dieback := 15;
   Stopped := 17;
   Running := 19;
   EnergySave := 21;
   CommunicationError := 23;
   CBError := 25;
   ProfinetError := 27;
   HardwareError := 29;
   VFDNotHealthy := 31;
   VFDError := 33;
   PECJam := 35;
   ChuteFull := 37;
   EncoderError := 39;
   TrackingError := 41;
   DimensionError := 43;
   OperationalError := 45;
   AutoON := 47;
   ChuteHalfFull := 49;
   DisableByManagement := 51;
   GateOpen := 53;
   GateClosed := 55;
   GateClosedAndNoOperatorPresent := 57;
   PositionChangeOngoing := 59;
   BufferMode := 61;
   ContinuousMode := 63;
   LabbelingMode := 65;

END_DATA_BLOCK

FUNCTION "FC_EquipmentReport" : Void
TITLE = FC_Equipment_Report
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 16
// END_ATTRIBUTES
//Function to generate equipment report.
   VAR_INPUT 
      iUDT_Status : "UDT_CommonStatus";   // Status structure
   END_VAR

   VAR_IN_OUT 
      iqUDT_Control : "UDT_EquipmentControl";   // Equipment control
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | F.Baten       | first release MHS TIA 15.1
	17/06/2019  | 0.3       | L.Klar        | Manual mode added to "UDT_EquipmentControl"
	17/07/2019  | 0.4       | A.Nowak       | Add all statuses and comments
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	27/08/2019  | 2.1       | K.Pokorski    | Comments adjusted
	16/09/2019  | 2.2       | K.Pokorski    | Equipment error free condition added to "Restart required" status
	06/10/2019  | 2.3       | S. Deukar     | Updated accoring to new UDT equipment report
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	05/02/2024  | 3.1       | L.Klar        | Auto On extention added 
	13/03/2024  | 4.0       | S. Nieswiec   | Added to baseline
	*)
	
	REGION 1 - Equipment report update
	    
	    // Extension of stopped equipment report with the stopped status
	    #iqUDT_Control.Report.Stopped := #iUDT_Status.Stopped
	    OR #iqUDT_Control.Report.Stopped;
	    
	    // Extension of started equipment report with the started status
	    #iqUDT_Control.Report.Running := #iUDT_Status.Running
	    OR #iqUDT_Control.Report.Running;
	    
	    // Extension of energy save equipment report with the energy save status
	    #iqUDT_Control.Report.EnergySave := #iUDT_Status.EnergySave
	    OR #iqUDT_Control.Report.EnergySave;
	    
	    // Extension of warning equipment report with the warning status
	    #iqUDT_Control.Report.Warning := #iUDT_Status.Warning
	    OR #iqUDT_Control.Report.Warning;
	    
	    // Extension of manual mode equipment report with the manual mode status
	    #iqUDT_Control.Report.Manual := #iUDT_Status.Manual
	    OR #iqUDT_Control.Report.Manual;
	    
	    // Extension of error equipment report with the error status
	    #iqUDT_Control.Report.Error := #iUDT_Status.Error
	    OR #iqUDT_Control.Report.Error;
	    
	    // Extension of safety stop equipment report with the safety stop status
	    #iqUDT_Control.Report.SafetyStop := #iUDT_Status.SafetyStop
	    OR #iqUDT_Control.Report.SafetyStop;
	    
	    // Extension of Auto On equipment report with the Auto On status
	    #iqUDT_Control.Report.AutoON := #iUDT_Status.AutoON
	    OR #iqUDT_Control.Report.AutoON;
	    
	    // Extension of restart required equipment report with the restart required and no equipment error statuses
	    #iqUDT_Control.Request.RestartRequired := #iUDT_Status.Stopped
	    AND NOT #iUDT_Status.Error
	    OR #iqUDT_Control.Request.RestartRequired;
	    
	END_REGION
END_FUNCTION

FUNCTION "FC_Statistics" : Void
TITLE = FC_Statistics
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 26
// END_ATTRIBUTES
//Function to calculate statistics.
   VAR_INPUT 
      ix_Reset : Bool;   // Reset statistics data
      ix_Activate : Bool;   // Activete statistics counters
      ix_RTrigActivate : Bool;   // Activation rise trigger
   END_VAR

   VAR_IN_OUT 
      iqUDT_Statistics : "UDT_EventStatistic";   // Statistic structure
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | C. Leite      | first release MHS TIA 15.1
	17/07/2019  | 0.2       | A.Nowak       | Add comments
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	27/08/2019  | 2.1       | M.Kurpiers    | Comments adjusted
	04/11/2019  | 2.2       | L.Klar        | 1 second pulse changed from memory bit to DB variable
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Number of events
	    
	    IF (#ix_RTrigActivate)      // Event occured                                
	    THEN
	        
	        // Increment the number of times the event occurred and clear the time of the current or last event
	        #iqUDT_Statistics.NumberOfTimes += 1;
	        #iqUDT_Statistics.LastEventSeconds := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Event time
	    
	    // 1 shot every 1 sec and activate statistic counter 
	    IF ("DB_Memory".OS_1sec AND #ix_Activate)
	    THEN
	        
	        // Increment the time of the current or last event and the time of all events that occured
	        #iqUDT_Statistics.LastEventSeconds += 1;
	        #iqUDT_Statistics.TotalEventSeconds += 1;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Data reset
	    
	    
	    IF (#ix_Reset)                                            // Reset statistics data                                          
	    THEN
	        
	        IF (NOT #ix_Activate)                                 // Statistic counter isn't activate                                
	        THEN
	            
	            // Clear statistics data
	            #iqUDT_Statistics.NumberOfTimes := 0;
	            #iqUDT_Statistics.LastEventSeconds := 0;
	            #iqUDT_Statistics.TotalEventSeconds := 0;
	            
	        ELSE
	            
	            // Write 1 to the number of times the event occurred and clear times  
	            #iqUDT_Statistics.NumberOfTimes := 1;
	            #iqUDT_Statistics.LastEventSeconds := 0;
	            #iqUDT_Statistics.TotalEventSeconds := 0;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
END_FUNCTION

FUNCTION_BLOCK "FB_TimerOnOffDelay"
TITLE = FB_TimerOnOffDelay
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 32
// END_ATTRIBUTES
//Function block to generate on/off signal delay.
   VAR_INPUT 
      iudi_OnDelayTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // On delay time [ms]
      iudi_OffDelayTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Off delay time [ms]
      ix_SignalToDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Input signal to be delayed
      ix_Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;   // Timer Enable
   END_VAR

   VAR_OUTPUT 
      qlr_ActualTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Actual time
      qx_DelayedSignal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Delayed signal output
   END_VAR

   VAR 
      s_R_TRIG_Signal {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Siemens "R_Trig" - to prepare the rising edge trigger on "ix_SignalToDelay" signal
      s_F_TRIG_Signal {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Siemens "F_Trig" - to prepare the falling edge trigger on "ix_SignalToDelay" signal
   END_VAR
   VAR RETAIN
      slr_ActualDelayTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Actual delay time [ms]
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	26/08/2019  | 2.1       | M.Kurpiers    | Comments adjusted
	04/11/2019  | 2.2       | L.Klar        | Prevoius cycle scan changed from memory to DB variable
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION Step 1 – Input signal edge detection 
	    
	    #s_R_TRIG_Signal(CLK := #ix_SignalToDelay);
	    
	    
	    #s_F_TRIG_Signal(CLK := #ix_SignalToDelay);
	    
	END_REGION
	
	REGION Step 2 – Actual delay time initialization
	    
	    IF (#s_R_TRIG_Signal.Q OR #s_F_TRIG_Signal.Q)           // Input signal changed        
	    THEN
	        
	        #slr_ActualDelayTime := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION Step 3 – On/Off delay time calculation
	    
	    
	    IF (#ix_SignalToDelay                                       // Signal to be delayed is active
	        AND #ix_Enable)                                         // Ttimer enabled                   
	    THEN
	        
	        // Timer on
	        IF (#slr_ActualDelayTime >= #iudi_OnDelayTime)
	        THEN
	            
	            #qx_DelayedSignal := TRUE;
	            
	        ELSE
	            
	            #slr_ActualDelayTime += "DB_Memory".PrevCycleTime;
	            
	        END_IF;
	        
	    END_IF;
	    
	    // Timer off
	    IF (NOT #ix_SignalToDelay                                   // Signal to delay is not active
	        AND #ix_Enable)                                         // Timer is enabled                  
	    THEN
	        
	        IF (#slr_ActualDelayTime >= #iudi_OffDelayTime)
	        THEN
	            
	            #qx_DelayedSignal := FALSE;
	            
	        ELSE
	            
	            #slr_ActualDelayTime += "DB_Memory".PrevCycleTime;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION Step 4 – Actual time
	    
	    #qlr_ActualTime := #slr_ActualDelayTime;
	    
	END_REGION
END_FUNCTION_BLOCK

TYPE "UDT_TCPIPConnectStatus"
TITLE = UDT_TCPIPConnectStatus
VERSION : 0.1
//User-defined structure of FB_TCPIPConnect function block status.
   STRUCT
      Status : Int;   // Status number
      Specific : Struct   // Specific status structure
         ErrorCode : Struct   // Error code structure
            TCON : Word;   // Siemens TCON error code - Check documetation
            TDISCON : Word;   // Siemens TDISCON error code - Check documetation
            TDIAG : Word;   // Siemens TDIAG error code - Check documetation
         END_STRUCT;
         Connected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Connected
         CommunicationFault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Communication fault
      END_STRUCT;
   END_STRUCT;

END_TYPE

FUNCTION "FC_Fifo" : Void
TITLE = FC_Fifo
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 17
// END_ATTRIBUTES
//Function for controlling FIFO register.
   VAR_INPUT 
      ic_Mode : Char;   // Mode selector: "W" - Write; "R" - Read; "C" - Clear (Reset) "S" - Status
   END_VAR

   VAR_OUTPUT 
      qUDT_Status : "UDT_FifoStatus";   // FIFO status structure
      qx_Error : Bool;   // Collective error output
      qx_Warning : Bool;   // Collective warning output
   END_VAR

   VAR_IN_OUT 
      iqv_Data : Variant;   // Data
      iqUDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqv_DataBuffer : Variant;   // FIFO data buffer
   END_VAR

   VAR_TEMP 
      tUDT_Status : "UDT_FifoStatus";   // Status structure
      ti_MoveBLKErrorCode : Int;   // Move_BLK_Variant function return
      tx_HeaderValid : Bool;   // Header valid
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	14/06/2019  | 0.2       | A.Nowak       | Replacement of instruction if for direct write into variable - Region 3 , 4.1 , 4.2 , 4.3 , 4.4 , 8.1  , 8.2 
	17/07/2019  | 0.3       | L.Klar        | Status handling changed
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	23/08/2019  | 2.1       | K.Pokorski    | Comments corrected
	27/08/2019  | 2.2       | M.Kurpiers    | Comments adjusted
	27/09/2019  | 2.3       | K.Pokorski    | Variant input included
	01/10/2019  | 2.4       | A.Nowak       | Correct comments and rename regions
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – Diagnostic bits initialization
	    
	    // Clear FIFO statuses
	    #tUDT_Status.FifoFull := FALSE;
	    #tUDT_Status.FifoPreFull := FALSE;
	    
	END_REGION
	
	REGION 2 – Array's information
	    
	    // If buffer elements type is invalid, set the error 
	    #tUDT_Status.InvalidDataType := NOT (TypeOf(#iqv_Data) = TypeOfElements(#iqv_DataBuffer));
	    
	END_REGION
	
	REGION 3 – Mode validation
	    
	    // Set the mode invalid if selected mode isn't one of the following: W- Write, R - Read, C - Clear, S - Status
	    #tUDT_Status.InvalidMode := #ic_Mode <> 'W'
	    AND #ic_Mode <> 'R'
	    AND #ic_Mode <> 'C'
	    AND #ic_Mode <> 'S';
	    
	END_REGION
	
	REGION 4 – The header settings checking
	    
	    // The correct mode has been selected and data type is valid
	    IF (NOT #tUDT_Status.InvalidMode
	        AND NOT #tUDT_Status.InvalidDataType)
	    THEN
	        
	        REGION 4.1 – The number of maximum FIFO entries validation 
	            
	            // Write the number of array's elements to FIFO header
	            #iqUDT_FifoHeader.MaxNrOfEntries := "FC_GetNrOfArrayEl"(#iqv_DataBuffer);
	            
	            // Set the invalid maximum number of entries error 
	            #tUDT_Status.InvalidMaxNrOfEntries := #iqUDT_FifoHeader.MaxNrOfEntries <= 0;
	            
	        END_REGION
	        
	        REGION 4.2 – The number of total FIFO entries validation
	            
	            // Set the invalid total number of entries error 
	            #tUDT_Status.InvalidTotalEntriesStored := #iqUDT_FifoHeader.TotalEntriesStored < 0        // The total number of entries is lower than 0
	            OR #iqUDT_FifoHeader.TotalEntriesStored > #iqUDT_FifoHeader.MaxNrOfEntries;               // The total number of entries is greater than the maximum number of entries
	            
	        END_REGION
	        
	        REGION 4.3 – The number of the next entry to write 
	            
	            // Set the invalid next entry to write
	            #tUDT_Status.InvalidNextEntryToWrite := #iqUDT_FifoHeader.NextEntryToWrite < 0            // The number of next entry to write is lower than 0  
	            OR #iqUDT_FifoHeader.NextEntryToWrite >= #iqUDT_FifoHeader.MaxNrOfEntries;                // The number of next entry to write is greater or equal to the maximum number of entries 
	            
	        END_REGION
	        
	        REGION 4.4 – The number of the next entry to read 
	            
	            // Set the invalid next entry to read
	            #tUDT_Status.InvalidNextEntryToRead := #iqUDT_FifoHeader.NextEntryToRead < 0              // The number of next entry to read is lower than 0 
	            OR #iqUDT_FifoHeader.NextEntryToRead >= #iqUDT_FifoHeader.MaxNrOfEntries;                 // The number of next entry to read is greater or equal to the maximum nr of entries 
	            
	        END_REGION
	        
	        REGION 4.5 – FIFO header validation summary
	            
	            // Create collective header error
	            #tx_HeaderValid := NOT #tUDT_Status.InvalidMaxNrOfEntries
	            AND NOT #tUDT_Status.InvalidTotalEntriesStored
	            AND NOT #tUDT_Status.InvalidNextEntryToWrite
	            AND NOT #tUDT_Status.InvalidNextEntryToRead;
	            
	        END_REGION
	        
	    END_IF;
	    
	END_REGION
	
	REGION 5 – Writing the data into the FIFO buffer
	    
	    IF (#ic_Mode = 'W'                                                                          // Write mode selected                                                               
	        AND #tx_HeaderValid                                                                     // FIFO header valid 
	        AND NOT #tUDT_Status.InvalidDataType)                                                  // Buffer data type valid
	    THEN
	        
	        
	        IF (#iqUDT_FifoHeader.TotalEntriesStored < #iqUDT_FifoHeader.MaxNrOfEntries)          // Checking total number of stored entries                
	        THEN
	            
	            // Move input data to FIFO data buffer  
	            #ti_MoveBLKErrorCode := MOVE_BLK_VARIANT(SRC := #iqv_Data,
	                                                     COUNT := 1,
	                                                     SRC_INDEX := 0,
	                                                     DEST_INDEX := #iqUDT_FifoHeader.NextEntryToWrite,
	                                                     DEST => #iqv_DataBuffer);
	            
	            // Increment the number of the next entry to write 
	            #iqUDT_FifoHeader.NextEntryToWrite += 1;
	            
	            // Increment the total number of stored entries 
	            #iqUDT_FifoHeader.TotalEntriesStored += 1;
	            
	            
	            IF (#iqUDT_FifoHeader.NextEntryToWrite >= #iqUDT_FifoHeader.MaxNrOfEntries)       // Check the number of the next entry to write                             
	            THEN
	                
	                #iqUDT_FifoHeader.NextEntryToWrite := 0;
	                
	            END_IF;
	            
	        ELSE
	            
	            #tUDT_Status.FifoFull := TRUE;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 6 – Reading the data from the FIFO data buffer
	    
	    IF (#ic_Mode = 'R'                                                                  // Read mode selected    
	        AND #tx_HeaderValid                                                             // FIFO header valid 
	        AND NOT #tUDT_Status.InvalidDataType)                                           // Buffer data type valid                                                
	    THEN
	        
	        IF (#iqUDT_FifoHeader.TotalEntriesStored > 0)                                   // Checking total number of stored entries                                                     
	        THEN
	            
	            // Move the FIFO data to the data output
	            #ti_MoveBLKErrorCode := MOVE_BLK_VARIANT(SRC := #iqv_DataBuffer,
	                                                     COUNT := 1,
	                                                     SRC_INDEX := #iqUDT_FifoHeader.NextEntryToRead,
	                                                     DEST_INDEX := 0,
	                                                     DEST => #iqv_Data);
	            
	            // Increment the number of the next entry to read
	            #iqUDT_FifoHeader.NextEntryToRead += 1;
	            
	            // Decrement the total number of stored entries
	            #iqUDT_FifoHeader.TotalEntriesStored -= 1;
	            
	            IF (#iqUDT_FifoHeader.NextEntryToRead >= #iqUDT_FifoHeader.MaxNrOfEntries)  // Check the number of the next entry to read                 
	            THEN
	                
	                #iqUDT_FifoHeader.NextEntryToRead := 0;
	                
	            END_IF;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 7 – Clearing the FIFO header
	    
	    IF (#ic_Mode = 'C'                      // Clear mode selected  
	        AND #tx_HeaderValid)                // FIFO header valid                         
	    THEN
	        
	        #iqUDT_FifoHeader.TotalEntriesStored := 0;
	        #iqUDT_FifoHeader.NextEntryToWrite := 0;
	        #iqUDT_FifoHeader.NextEntryToRead := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 8 – FIFO management status update
	    
	    IF (#tx_HeaderValid)                   // The header is valid                                     
	    THEN
	        
	        REGION 8.1 – FIFO Empty
	            
	            // Set the FIFO empty status bit
	            #iqUDT_FifoHeader.Status.Empty := #iqUDT_FifoHeader.TotalEntriesStored = 0;
	            
	        END_REGION
	        
	        REGION 8.2 – FIFO Full
	            
	            // Set the FIFO full status bit 
	            #iqUDT_FifoHeader.Status.Full := #iqUDT_FifoHeader.TotalEntriesStored = #iqUDT_FifoHeader.MaxNrOfEntries;
	            
	        END_REGION
	        
	        REGION 8.3 – FIFO Pre-full
	            
	            IF (#iqUDT_FifoHeader.TotalEntriesStored >= 0.9 * #iqUDT_FifoHeader.MaxNrOfEntries)       // Checking if the number of total stored entries is greater or equal to 90% of the max number of entries     
	            THEN
	                
	                // Set the FIFO pre-full status 
	                #iqUDT_FifoHeader.Status.Prefull := TRUE;
	                #tUDT_Status.FifoPreFull := TRUE;
	                
	            ELSE
	                
	                #iqUDT_FifoHeader.Status.Prefull := FALSE;
	                
	            END_IF;
	            
	        END_REGION
	        
	    END_IF;
	    
	END_REGION
	
	REGION 9 – Status
	    
	    REGION 9.1 – Common status update
	        
	        // Collective error output
	        #qx_Error := NOT #tx_HeaderValid
	        OR #tUDT_Status.InvalidMode
	        OR #tUDT_Status.FifoFull
	        OR #tUDT_Status.InvalidDataType;
	        
	        // Collective warning output              
	        #qx_Warning := #tUDT_Status.FifoPreFull;
	        
	    END_REGION
	    
	    REGION 9.2 – Status update
	        
	        // Update the outer status structure with internal status structure
	        #qUDT_Status := #tUDT_Status;
	        
	    END_REGION
	    
	END_REGION
END_FUNCTION

TYPE "UDT_TCPIPReceiveStatistics"
TITLE = UDT_TCPIPReceiveStatistics
VERSION : 0.1
//User-defined structure of FB_TCPIPReceive function block statistics.
   STRUCT
      InvalidMsg : UInt;   // Invalid message received
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_Pulse"
TITLE = FB_Pulse
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 26
// END_ATTRIBUTES
//Function block to generate custom pulse signal.
   VAR_INPUT 
      iudi_PulseTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Pulse time [ms]
   END_VAR

   VAR_OUTPUT 
      qx_Pulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Pulse output
   END_VAR

   VAR 
      R_TRIG {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Siemens "R_Trig" - to prepare rising edge trigger on "sx_Pulse" signal
      slr_ActualPulseTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Actual pulse time [ms]
      sx_Pulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Pulse signal
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | K.Pokorski    | first release MHS TIA 15.1
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	27/08/2019  | 2.1       | K.Pokorski    | Comments adjusted
	04/11/2019  | 2.2       | L.Klar        | Prevoius cycle scan changed from memory to DB variable
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Pulse calculation
	    
	    // Pulse timer on
	    IF (#iudi_PulseTime <= #slr_ActualPulseTime)
	    THEN
	        
	        #sx_Pulse := TRUE;
	        #slr_ActualPulseTime := 0;
	        
	    ELSE
	        
	        #slr_ActualPulseTime += "DB_Memory".PrevCycleTime;
	        #sx_Pulse := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Pulse output
	    
	    #R_TRIG(CLK := #sx_Pulse,
	            Q => #qx_Pulse);
	    
	END_REGION
END_FUNCTION_BLOCK

TYPE "UDT_UPSHeartbeatStatistics"
TITLE = UDT_HeartbeatStatistics
VERSION : 0.1
//User-defined structure of FB_Heartbeat function block statistics.
   STRUCT
      ConLost : UDInt;   // Statistics of connection lost
   END_STRUCT;

END_TYPE

TYPE "UDT_UPSMSGIDCounters"
VERSION : 0.1
   STRUCT
      Heartbeat : DInt;   // Heartbeat MSGID counter
      IDFWD : DInt;   // IDFWD MSGID counter
      SORTCONF : DInt;   // SORTCONF MSGID counter
      PLCINFO : DInt;   // PLCINFO MSGID counter
      SORT : DInt;   // SORT MSGID counter
      HB : DInt;   // HB MSGID counter
   END_STRUCT;

END_TYPE

TYPE "UDT_UPSDecodeStatistics"
TITLE = UDT_DecodeStatistics
VERSION : 0.1
//User-defined structure of FB_Decode function block statistics.
   STRUCT
      InvalidMsg : UDInt;   // Counter of incorrectly decoded messages
      HBNotObserved : UDInt;   // Statistics of HB not observed in a preset time
   END_STRUCT;

END_TYPE

TYPE "UDT_UPSCIPStatistics"
VERSION : 0.1
   STRUCT
      CIP24VDCFault : "UDT_EventStatistic";   // 24V fault
      CIPCircuitBreakerTripped : "UDT_EventStatistic";   // Circuit breaker tripped
      WeighingScaleFault : "UDT_EventStatistic";   // Weighing scale fault
      SS_Camera { S7_SetPoint := 'True'} : DInt;   // Number of times camera switch change over
      SS_XLE { S7_SetPoint := 'True'} : DInt;   // Number of times XLE switch change over
   END_STRUCT;

END_TYPE

FUNCTION "FC_SeparateMsg" : Void
TITLE = FC_SeparateMsg
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 25
// END_ATTRIBUTES
//Function to separate the delimited message.
   VAR_INPUT 
      iUDT_Message : "UDT_Message";   // Character string to be separated
      ii_Position : Int;   // Start position
      ic_Delimiter : Char;   // Delimiter
      ic_EndSign : Char;   // End of the message sign
   END_VAR

   VAR_OUTPUT 
      qs_Msg : String;   // Separated part of the message
      qui_Length : UInt;   // Length of the separated message
      qx_EndMsg : Bool;   // End message sign found
      qx_NoSeparationSign : Bool;   // Separation sign not detected
   END_VAR

   VAR_TEMP 
      ti_i : Int;   // Loop counter
      tui_NrOfConvChar : UInt;   // Number of converted message characters
      ti_SizeOfMsg : Int;   // Message array size
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | K.Pokorski    | first release MHS TIA 15.1
	14/06/2019  | 0.2       | K.Pokorski    | "ii_Position" input, "qx_NoSeparationSign" output added, additional logic programmed 
	17/06/2019  | 0.3       | L.Klar        | "iqi_Position" deleted
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	26/07/2019  | 2.1       | M.Kurpiers    | Comments adjusted
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – Maximum number of the message characters
	    
	    #ti_SizeOfMsg := "FC_GetNrOfArrayEl"(iv_Array := #iUDT_Message.Character);
	    
	END_REGION
	
	REGION 2 – Message separation
	    
	    IF (#ii_Position <= #ti_SizeOfMsg - 1)                                        // Position is lower than size of a message array                                      
	    THEN
	        
	        // Delimiter and end sign search loop
	        FOR #ti_i := #ii_Position TO #ti_SizeOfMsg - 1 DO
	            
	            
	            IF (#iUDT_Message.Character[#ti_i] = #ic_Delimiter                    // Check if delimiter and the end of the message was found                   
	                OR #iUDT_Message.Character[#ti_i] = #ic_EndSign)
	                
	            THEN
	                
	                // Message length minus start position from INT to UInt conversion
	                #tui_NrOfConvChar := INT_TO_UINT(IN := (#ti_i - #ii_Position));
	                
	                IF #tui_NrOfConvChar <> 0
	                THEN
	                    // Character array into the message character string conversion
	                    Chars_TO_Strg(Chars := #iUDT_Message.Character,
	                                  pChars := #ii_Position,
	                                  Cnt := #tui_NrOfConvChar,
	                                  Strg => #qs_Msg);
	                    
	                ELSE
	                    #qs_Msg := '';
	                END_IF;
	                
	                // Length of the separated message part
	                #qui_Length := #tui_NrOfConvChar;
	                
	                // Separation sign not detected
	                #qx_NoSeparationSign := FALSE;
	                
	                
	                IF (#iUDT_Message.Character[#ti_i] = #ic_EndSign)                   // End of the message sign detected              
	                THEN
	                    
	                    #qx_EndMsg := TRUE;
	                    
	                ELSE
	                    
	                    #qx_EndMsg := FALSE;
	                    
	                END_IF;
	                // Exit the loop if end sign was found
	                EXIT;
	                
	                
	            ELSIF (#ti_i = #ti_SizeOfMsg - 1)                                         // Separate sign is not detected                                     
	            THEN
	                
	                // End of the message and no separation sign detected bits are set
	                #qs_Msg := '';
	                #qui_Length := 0;
	                #qx_EndMsg := TRUE;
	                #qx_NoSeparationSign := TRUE;
	                
	            END_IF;
	            
	        END_FOR;
	        // Clear variables if delimiter and end sign wasn't found    
	    ELSE
	        
	        #qs_Msg := '';
	        #qui_Length := 0;
	        #qx_EndMsg := TRUE;
	        #qx_NoSeparationSign := TRUE;
	        
	    END_IF;
	    
	END_REGION
END_FUNCTION

TYPE "UDT_UPSFlowControlHMI"
VERSION : 0.1
   STRUCT
      Setpoint : Int;   // Setpoint value from HMI
      CalculatedFlow : Int;   // Current calculated value to HMI
      CommandToDisable : Bool;   // Command from HMI to disable
      DisabledStatus : Bool;   // Disabled Status
   END_STRUCT;

END_TYPE

TYPE "UDT_UPSFlowRateCountingRegisters"
VERSION : 0.1
   STRUCT
      iCR : Array[1..60] of Int;   // Counting Register
   END_STRUCT;

END_TYPE

FUNCTION "FC_UPSScanData2" : Void
TITLE = FC_Health
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : UPS_SpecificCommunication
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 35
// END_ATTRIBUTES
//Function to decode the UPS HEALTH message.
   VAR_INPUT 
      iUDT_Message : "UDT_UPSMessage";   // Sorted message
   END_VAR

   VAR_OUTPUT 
      qx_Error : Bool;   // Error
   END_VAR

   VAR_IN_OUT 
      iqa_ExternalReaders : Array[*] of "UDT_UPSExternalReader";   // Health structure
   END_VAR

   VAR_TEMP 
      ti_i : Int;   // Loop counter
      ti_j : Int;   // Loop counter
      ti_ExternalReadersArrayLength : Int;   // External readers array length
      ti_ExternalReadersArrayLowBound : Int;   // External readers array low bound
      tusi_PackageNr : Int;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | K.Pokorski    | first release MHS TIA 15.1
	14/06/2019  | 0.2       | A.Nowak       | Replacement of instruction if for direct write into variable - Region 3  
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	23/08/2019  | 2.1       | K.Pokorski    | Comments simplified
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	01/07/2020  | 3.1       | L.Klar        | Block changed to fit new SCAN DATA 2 message template
	14/12/2020  | 3.2       | L.Klar        | ID created bit added
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – Initialization
	    
	    #ti_ExternalReadersArrayLength := "FC_GetNrOfArrayEl"(#iqa_ExternalReaders);
	    #ti_ExternalReadersArrayLowBound := DINT_TO_INT(LOWER_BOUND(ARR := #iqa_ExternalReaders, DIM := 1));
	    
	END_REGION
	
	REGION 2 – Message handling
	    
	    // Loop used to find message sender (external reader) in configured array
	    FOR #ti_i := #ti_ExternalReadersArrayLowBound TO #ti_ExternalReadersArrayLowBound + #ti_ExternalReadersArrayLength - 1 DO
	        
	        IF (#iUDT_Message.SCT = #iqa_ExternalReaders[#ti_i].NameIdentifier)
	        THEN
	            
	            #iqa_ExternalReaders[#ti_i].ScanData2Message.MSGID := #iUDT_Message.Data[1];
	            #iqa_ExternalReaders[#ti_i].ScanData2Message.CONFLICT_CODE := #iUDT_Message.Data[2];
	            #iqa_ExternalReaders[#ti_i].ScanData2Message.BARCODE_ZIP := #iUDT_Message.Data[3];
	            #iqa_ExternalReaders[#ti_i].ScanData2Message.BARCODE_TRACK := #iUDT_Message.Data[4];
	            #iqa_ExternalReaders[#ti_i].ScanData2Message.BARCODE_PTN := #iUDT_Message.Data[5];
	            #iqa_ExternalReaders[#ti_i].ScanData2Message.MAXI_ZIPCODE := #iUDT_Message.Data[6];
	            #iqa_ExternalReaders[#ti_i].ScanData2Message.MAXI_COUNTRY := #iUDT_Message.Data[7];
	            #iqa_ExternalReaders[#ti_i].ScanData2Message.MAXI_SERVICE := #iUDT_Message.Data[8];
	            #iqa_ExternalReaders[#ti_i].ScanData2Message.MAXI_TRACK := #iUDT_Message.Data[9];
	            #iqa_ExternalReaders[#ti_i].ScanData2Message.MAXI_SHIPPER := #iUDT_Message.Data[10];
	            #iqa_ExternalReaders[#ti_i].ScanData2Message.LENGTH1 := #iUDT_Message.Data[11];
	            #iqa_ExternalReaders[#ti_i].ScanData2Message.LENGTH2 := #iUDT_Message.Data[12];
	            #iqa_ExternalReaders[#ti_i].ScanData2Message.HEIGHT := #iUDT_Message.Data[13];
	            #iqa_ExternalReaders[#ti_i].ScanData2Message.VERTEX := #iUDT_Message.Data[14];
	            #iqa_ExternalReaders[#ti_i].ScanData2Message.ORIENTATION := #iUDT_Message.Data[15];
	            #iqa_ExternalReaders[#ti_i].ScanData2Message.OVERHANG := #iUDT_Message.Data[16];
	            #iqa_ExternalReaders[#ti_i].ScanData2Message.WEIGHT := #iUDT_Message.Data[17];
	            #iqa_ExternalReaders[#ti_i].ScanData2Message.APPENDED_DATA.Constant_1 := #iUDT_Message.Data[18];
	            #iqa_ExternalReaders[#ti_i].ScanData2Message.APPENDED_DATA.FRAME_ID := #iUDT_Message.Data[19];
	            #iqa_ExternalReaders[#ti_i].ScanData2Message.APPENDED_DATA.DIMENSION := #iUDT_Message.Data[20];
	            #iqa_ExternalReaders[#ti_i].ScanData2Message.APPENDED_DATA.PACKAGE_NUMBER := #iUDT_Message.Data[21];
	            #iqa_ExternalReaders[#ti_i].ScanData2Message.APPENDED_DATA.BARCODE_1 := #iUDT_Message.Data[22];
	            #iqa_ExternalReaders[#ti_i].ScanData2Message.APPENDED_DATA.DESCRIPTION_1 := #iUDT_Message.Data[23];
	            #iqa_ExternalReaders[#ti_i].ScanData2Message.APPENDED_DATA.BARCODE_2 := #iUDT_Message.Data[24];
	            #iqa_ExternalReaders[#ti_i].ScanData2Message.APPENDED_DATA.DESCRIPTION_2 := #iUDT_Message.Data[25];
	            #iqa_ExternalReaders[#ti_i].ScanData2Message.APPENDED_DATA.BARCODE_3 := #iUDT_Message.Data[26];
	            #iqa_ExternalReaders[#ti_i].ScanData2Message.APPENDED_DATA.DESCRIPTION_3 := #iUDT_Message.Data[27];
	            #iqa_ExternalReaders[#ti_i].ScanData2Message.APPENDED_DATA.Constant_4 := #iUDT_Message.Data[28];
	            #iqa_ExternalReaders[#ti_i].ScanData2Message.APPENDED_DATA.SCALE_WEIGHT := #iUDT_Message.Data[29];
	            #iqa_ExternalReaders[#ti_i].ScanData2Message.APPENDED_DATA.Constant_5 := #iUDT_Message.Data[30];
	            #iqa_ExternalReaders[#ti_i].ScanData2Message.APPENDED_DATA.GIRTH := #iUDT_Message.Data[31];
	            #iqa_ExternalReaders[#ti_i].ScanData2Message.APPENDED_DATA.Constant_6 := #iUDT_Message.Data[32];
	            #iqa_ExternalReaders[#ti_i].ScanData2Message.APPENDED_DATA.ERROR_CODE := #iUDT_Message.Data[33];
	            
	            FOR #ti_j := 1 TO 32 DO
	                
	                IF #iUDT_Message.Data[#ti_j] = '1' THEN
	                    
	                    #tusi_PackageNr := STRING_TO_INT(MID(IN := #iUDT_Message.Data[#ti_j + 1], L := 4, P := 3));
	                    
	                    
	                    IF #tusi_PackageNr > 0 AND #tusi_PackageNr < 9999
	                    THEN
	                        "DB_GIN".GIN[#tusi_PackageNr].UPS.IDCreated := TRUE;
	                    END_IF;
	                    EXIT;
	                    
	                END_IF;
	            END_FOR;
	            
	            #qx_Error := FALSE;
	            EXIT;
	            
	        ELSE
	            #qx_Error := TRUE;
	        END_IF;
	    END_FOR;
	    
	END_REGION
END_FUNCTION

FUNCTION "FC_UPSHealth" : Void
TITLE = FC_Health
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : UPS_SpecificCommunication
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 33
// END_ATTRIBUTES
//Function to decode the UPS HEALTH message.
   VAR_INPUT 
      iUDT_Message : "UDT_UPSMessage";   // Sorted message
   END_VAR

   VAR_OUTPUT 
      qx_Error : Bool;   // Error
   END_VAR

   VAR_IN_OUT 
      iqa_ExternalReaders : Array[*] of "UDT_UPSExternalReader";   // Health structure
   END_VAR

   VAR_TEMP 
      ti_Failure : DInt;   // External reader failure mask
      ti_i : Int;   // Loop counter
      ti_ExternalReadersArrayLength : Int;   // External readers array length
      ti_ExternalReadersArrayLowBound : Int;   // External readers array low bound
   END_VAR

   VAR CONSTANT 
      cs_CAM : String := 'CAM';   // Camera
      cs_DWS : String := 'DWS';   // Scale
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | K.Pokorski    | first release MHS TIA 15.1
	14/06/2019  | 0.2       | A.Nowak       | Replacement of instruction if for direct write into variable - Region 3  
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	23/08/2019  | 2.1       | K.Pokorski    | Comments simplified
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	01/07/2020  | 3.1       | L.Klar        | Block changed to fit new HEALHT message template
	22/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – Initialization
	    
	    #ti_Failure := 0;
	    
	    #ti_ExternalReadersArrayLength := "FC_GetNrOfArrayEl"(#iqa_ExternalReaders);
	    #ti_ExternalReadersArrayLowBound := DINT_TO_INT(LOWER_BOUND(ARR := #iqa_ExternalReaders, DIM := 1));
	END_REGION
	
	REGION 2 – Message handling
	    
	    // Loop used to find message sender (external reader) in configured array
	    FOR #ti_i := #ti_ExternalReadersArrayLowBound TO #ti_ExternalReadersArrayLowBound + #ti_ExternalReadersArrayLength - 1 DO
	        
	        IF (#iUDT_Message.SCT = #iqa_ExternalReaders[#ti_i].NameIdentifier)
	        THEN
	            
	            // Device type
	            IF #iUDT_Message.Data[4] = '1'
	            THEN
	                #iqa_ExternalReaders[#ti_i].HealthMessage.Type := #cs_DWS;
	            ELSIF #iUDT_Message.Data[4] = '2'
	            THEN
	                #iqa_ExternalReaders[#ti_i].HealthMessage.Type := #cs_CAM;
	            END_IF;
	            
	            // Device failure mask
	            STRG_VAL(IN := #iUDT_Message.Data[5],
	                     FORMAT := 16#0,
	                     P := 1,
	                     OUT => #ti_Failure);
	            
	            #iqa_ExternalReaders[#ti_i].HealthMessage.Failure := #ti_Failure;
	            
	            // Device model
	            #iqa_ExternalReaders[#ti_i].HealthMessage.Model := #iUDT_Message.Data[6];
	            
	            // Device error 
	            #iqa_ExternalReaders[#ti_i].HealthMessage.Error := #ti_Failure > 0;
	            #qx_Error := FALSE;
	            EXIT;
	            
	        ELSE
	            #qx_Error := TRUE;
	        END_IF;
	    END_FOR;
	    
	END_REGION
END_FUNCTION

TYPE "UDT_UPSCIPStatus"
VERSION : 0.1
   STRUCT
      Status : Int;   // Status number
      Specific : Struct
         CIP24VDCError : Bool;   // CIP 24VDC error
         CIPCircuitBreakerTripped : Bool;   // CIP Circuit Breaker Tripped
         XLE_SwitchError : Bool;   // XLE switched while stystem was ruuning
         Camera_SwitchError : Bool;   // Camera switched while stystem was ruuning
         WeighingScaleFault : Bool;   // Weighing Scale Fault
         CameraTunel1 : Bool;   // Camera Tunel 1 Selected
         CameraTunel2 : Bool;   // Camera Tunel 2 Selected
         XLEBackUp : Bool;   // XLE BackUp selected
         XLEPrimary : Bool;   // XLE Primary selected
      END_STRUCT;
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_UPSAcknowledge"
TITLE = FB_Acknowledge
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : UPS_SpecificCommunication
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 48
// END_ATTRIBUTES
//Function block to prepare and send the UPS Acknowledge message. 
   VAR_INPUT 
      iUDT_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_UPSMessage";   // Message structure
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective error output
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective warning output
   END_VAR

   VAR_IN_OUT 
      iqUDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqa_FifoData : Array[*] of "UDT_Message";   // FIFO data
   END_VAR

   VAR 
      ss_MT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[20];   // Message type character string
      ss_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Message character string
      s_UDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Message";   // Message character array
      sa_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //   FIFO error
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //   FIFO warning
      END_STRUCT;
      sui_ArrayOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Offset for writing in the array
      si_MaxMsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum message length
   END_VAR

   VAR CONSTANT 
      cs_ACK : String := 'ACK-';   // Message type
      cs_CRLF : String := '$R$L';   // Termination signs
      cc_DL : Char := ',';   // Comma sign
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	28/06/2019  | 0.4       | A.Nowak       | Changing conditions for error occuring and status update
	17/07/2019  | 0.5       | L.Klar        | Status handling changed
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	23/08/2019  | 2.1       | K.Pokorski    | Comments simplified
	20/09/2019  | 2.2       | A.Nowak       | Change data type of Status from "UDT_Status" to Struct
	01/10/2019  | 2.3       | A.Nowak       | Implementation of the new FIFO block
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	22/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – Update FIFO header status bits
	    
	    // Mode 'S' - FIFO register status update
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #sa_Status.FIFOStatus,
	              qx_Error => #sa_Status.FIFOError,
	              qx_Warning => #sa_Status.FIFOWarning,
	              iqv_Data := #s_UDT_MessageArray,
	              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	              iqv_DataBuffer := #iqa_FifoData);
	    
	END_REGION
	
	REGION 2 – ACK message preparation
	    
	    IF (NOT #sa_Status.FIFOError)                            // No FIFO error
	    THEN
	        
	        IF (NOT #iqUDT_FifoHeader.Status.Full)                 // FIFO not full 
	        THEN
	            
	            REGION 2.1 – Message type preparation
	                
	                // Add "ACK-" prefix into the original messege type 
	                #ss_MT := CONCAT(IN1 := #cs_ACK, IN2 := #iUDT_Message.MT);
	                
	            END_REGION
	            
	            REGION 2.2 – Message preparation
	                
	                // Acknowledge message composing according to the structure: SCN,SCT,RCN,RCT,MT+'ACK',MSGID {CRLF}
	                #ss_Message := CONCAT(IN1 := #iUDT_Message.RCN,            // Receiver IP address ("i_UDT_Message.RCN") 
	                                      IN2 := #cc_DL,                        // Comma sign ("cc_DL") - ","
	                                      IN3 := #iUDT_Message.RCT,            // Receiver Name ("i_UDT_Message.RCT") 
	                                      IN4 := #cc_DL,                        // Comma sign ("cc_DL") - ","
	                                      IN5 := #iUDT_Message.SCN,            // Sender IP address ("i_UDT_Message.SCN")   
	                                      IN6 := #cc_DL,                        // Comma sign ("cc_DL") - ","
	                                      IN7 := #iUDT_Message.SCT,            // Sender Name ("i_UDT_Message.SCT") 
	                                      IN8 := #cc_DL,                        // Comma sign ("cc_DL") - ","
	                                      IN9 := #ss_MT,                        // Message type("ss_MT") - "ACK-" + original message type
	                                      IN10 := #cc_DL,                       // Comma sign ("cc_DL") - ","
	                                      IN11 := #iUDT_Message.Data[1],       // Message ID - MSGID ("i_UDT_Message.Data[1]")
	                                      IN12 := #cs_CRLF);                    // Termination signs ("cs_CRLF") - "$R$L"
	                
	            END_REGION
	            
	            REGION 2.3 – Maximum number of message array elements
	                
	                #si_MaxMsgLen := "FC_GetNrOfArrayEl"(iv_Array := #s_UDT_MessageArray.Character);
	                
	            END_REGION
	            
	            REGION 2.4 – Message character string conversion to a message array of characters
	                
	                Strg_TO_Chars(Strg := #ss_Message,
	                              pChars := 0,
	                              Cnt => #sui_ArrayOffset,
	                              Chars := #s_UDT_MessageArray.Character);
	                
	            END_REGION
	            
	            REGION 2.5 – Clearing remaining characters in the message character array
	                
	                // Filling up not used message character array elements with '$00' (ASCII - 16#00)
	                FILL_BLK(IN := '$00',
	                         COUNT := UINT_TO_ULINT(INT_TO_UINT(#si_MaxMsgLen) -
	                                                #sui_ArrayOffset),
	                         OUT => #s_UDT_MessageArray.Character[#sui_ArrayOffset]);
	                
	            END_REGION
	            
	            REGION 2.6 – Message write into a FIFO register
	                
	                // Mode 'W' - Write FIFO record
	                "FC_Fifo"(ic_Mode := 'W',
	                          qUDT_Status => #sa_Status.FIFOStatus,
	                          qx_Error => #sa_Status.FIFOError,
	                          qx_Warning => #sa_Status.FIFOWarning,
	                          iqv_Data := #s_UDT_MessageArray,
	                          iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                          iqv_DataBuffer := #iqa_FifoData);
	                
	            END_REGION
	            
	            // In case of FIFO full, the FIFO full error bit and FIFO collective error bit are set
	        ELSE
	            
	            #sa_Status.FIFOError := TRUE;
	            #sa_Status.FIFOStatus.FifoFull := TRUE;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 – Status
	    
	    // Parametrization collective error output
	    #qx_Error := #sa_Status.FIFOError;           // FIFO error
	    
	    // Parametrization collective warning output
	    #qx_Warning := #sa_Status.FIFOWarning;       // FIFO warning
	    
	END_REGION
END_FUNCTION_BLOCK

TYPE "UDT_UPSChatStatistics"
VERSION : 0.1
   STRUCT
      CommunicationError : "UDT_EventStatistic";
      LostChatConnection : "UDT_EventStatistic";
      LostXLeConnection : "UDT_EventStatistic";
      LostPLCCommunication : "UDT_EventStatistic";
      Heartbeat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Heartbeat message counter
      IDFWD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // IDFWD message counter
      SORTCONF { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // SORTCONF message counter
      PLCMsg { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // PLCMsg message counter
      PLCINFO { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // PLCINFO message counter
      SORT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // SORT message counter
      HB : DInt;   // HB message counter
   END_STRUCT;

END_TYPE

TYPE "UDT_UPSMessageHeader"
TITLE = UDT_UPSMessageHeader
VERSION : 0.1
//User-defined structure of UPS message header data.
   STRUCT
      SCN : String[15] := 'aaa.bbb.ccc.ddd';   // Sender client name
      SCT : String[8] := 'AAA-BBBB';   // Sender client type
      RCN : String[15] := 'aaa.bbb.ccc.ddd';   // Receiver client name
      RCT : String[8] := 'AAA-BBBB';   // Receiver client type
   END_STRUCT;

END_TYPE

TYPE "UDT_UPSSspStatistics"
VERSION : 0.1
   STRUCT
      CS_Start : DInt;   // Number of times started
      CS_Stop : "UDT_EventStatistic";
   END_STRUCT;

END_TYPE

TYPE "UDT_UPSMACHSTAT"
TITLE = UDT_MACHSTAT
VERSION : 0.1
//User-defined structure of UPS machine statuses.
   STRUCT
      OpsNormal : Struct   // Ops/Normal
         StopMCP : Bool;   // Byte 1, Bit 0 - Operator Stop MCP Panel
         StopRemoteCon1 : Bool;   // Byte 1, Bit 1 - Operator Stop Remote Console 1
         StopRemoteCon2 : Bool;   // Byte 1, Bit 2 - Operator Stop Remote Console 2
         BuildingStop : Bool;   // Byte 1, Bit 3 - Building Stop via HMI
         BuildingBreak : Bool;   // Byte 1, Bit 4 - Building Break Time via HMI
         PowerSaveShutdown : Bool;   // Byte 1, Bit 5 - Power Save Shutdown
         SorterNotAtSpeed : Bool;   // Byte 1, Bit 6 - Sorter Not at speed
         MaintenanceSysMode : Bool;   // Byte 1, Bit 7 - System in Maintenance Mode
         Spare_8 : Bool;   // Byte 2, Bit 8 - Future / or Machine Specific (To be identyfied)
         Spare_9 : Bool;   // Byte 2, Bit 9 - Future / or Machine Specific (To be identyfied)
         Spare_10 : Bool;   // Byte 2, Bit 10 - Future / or Machine Specific (To be identyfied)
         Spare_11 : Bool;   // Byte 2, Bit 11 - Future / or Machine Specific (To be identyfied)
         Spare_12 : Bool;   // Byte 2, Bit 12 - Future / or Machine Specific (To be identyfied)
         Spare_13 : Bool;   // Byte 2, Bit 13 - Future / or Machine Specific (To be identyfied)
         Spare_14 : Bool;   // Byte 2, Bit 14 - Future / or Machine Specific (To be identyfied)
         Spare_15 : Bool;   // Byte 2, Bit 15 - Future / or Machine Specific (To be identyfied)
         Spare_16 : Bool;   // Byte 3, Bit 16 - Future / or Machine Specific (To be identyfied)
         Spare_17 : Bool;   // Byte 3, Bit 17 - Future / or Machine Specific (To be identyfied)
         Spare_18 : Bool;   // Byte 3, Bit 18 - Future / or Machine Specific (To be identyfied)
         Spare_19 : Bool;   // Byte 3, Bit 19 - Future / or Machine Specific (To be identyfied)
         Spare_20 : Bool;   // Byte 3, Bit 20 - Future / or Machine Specific (To be identyfied)
         Spare_21 : Bool;   // Byte 3, Bit 21 - Future / or Machine Specific (To be identyfied)
         Spare_22 : Bool;   // Byte 3, Bit 22 - Future / or Machine Specific (To be identyfied)
         Spare_23 : Bool;   // Byte 3, Bit 23 - Future / or Machine Specific (To be identyfied)
         Spare_24 : Bool;   // Byte 4, Bit 24 - Future / or Machine Specific (To be identyfied)
         Spare_25 : Bool;   // Byte 4, Bit 25 - Future / or Machine Specific (To be identyfied)
         Spare_26 : Bool;   // Byte 4, Bit 26 - Future / or Machine Specific (To be identyfied)
         Spare_27 : Bool;   // Byte 4, Bit 27 - Future / or Machine Specific (To be identyfied)
         Spare_28 : Bool;   // Byte 4, Bit 28 - Future / or Machine Specific (To be identyfied)
         Spare_29 : Bool;   // Byte 4, Bit 29 - Future / or Machine Specific (To be identyfied)
         Spare_30 : Bool;   // Byte 4, Bit 30 - Future / or Machine Specific (To be identyfied)
         Spare_31 : Bool;   // Byte 4, Bit 31 - Future / or Machine Specific (To be identyfied)
      END_STRUCT;
      SafetyFaults : Struct   // Safety faults
         BuildingEStop : Bool;   // Byte 5, Bit 0 - Building Emergency Stop
         SystemEStop : Bool;   // Byte 5, Bit 1 - System Emergency Stop
         EmerPullCord : Bool;   // Byte 5, Bit 2 - Emergency Pull Cord
         PhotoEyeBlock1 : Bool;   // Byte 5, Bit 3 - Safety Photo Eye Blocked (Long Range Photo Eye) 1
         PlatformLockout1 : Bool;   // Byte 5, Bit 4 - Platform Lockout 1
         PlatformLockout2 : Bool;   // Byte 5, Bit 5 - Platform Lockout 2
         PhotoEyeBlock2 : Bool;   // Byte 5, Bit 6 - Safety Photo Eye Blocked (Long Range Photo Eye) 2
         PhotoEyeBlock3 : Bool;   // Byte 5, Bit 7 - Safety Photo Eye Blocked (Long Range Photo Eye) 3
         Spare_8 : Bool;   // Byte 6, Bit 8 - Future / or Machine Specific (To be identyfied)
         Spare_9 : Bool;   // Byte 6, Bit 9 - Future / or Machine Specific (To be identyfied)
         Spare_10 : Bool;   // Byte 6, Bit 10 - Future / or Machine Specific (To be identyfied)
         Spare_11 : Bool;   // Byte 6, Bit 11 - Future / or Machine Specific (To be identyfied)
         Spare_12 : Bool;   // Byte 6, Bit 12 - Future / or Machine Specific (To be identyfied)
         Spare_13 : Bool;   // Byte 6, Bit 13 - Future / or Machine Specific (To be identyfied)
         Spare_14 : Bool;   // Byte 6, Bit 14 - Future / or Machine Specific (To be identyfied)
         Spare_15 : Bool;   // Byte 6, Bit 15 - Future / or Machine Specific (To be identyfied)
         Spare_16 : Bool;   // Byte 7, Bit 16 - Future / or Machine Specific (To be identyfied)
         Spare_17 : Bool;   // Byte 7, Bit 17 - Future / or Machine Specific (To be identyfied)
         Spare_18 : Bool;   // Byte 7, Bit 18 - Future / or Machine Specific (To be identyfied)
         Spare_19 : Bool;   // Byte 7, Bit 19 - Future / or Machine Specific (To be identyfied)
         Spare_20 : Bool;   // Byte 7, Bit 20 - Future / or Machine Specific (To be identyfied)
         Spare_21 : Bool;   // Byte 7, Bit 21 - Future / or Machine Specific (To be identyfied)
         Spare_22 : Bool;   // Byte 7, Bit 22 - Future / or Machine Specific (To be identyfied)
         Spare_23 : Bool;   // Byte 7, Bit 23 - Future / or Machine Specific (To be identyfied)
         Spare_24 : Bool;   // Byte 8, Bit 24 - Future / or Machine Specific (To be identyfied)
         Spare_25 : Bool;   // Byte 8, Bit 25 - Future / or Machine Specific (To be identyfied)
         Spare_26 : Bool;   // Byte 8, Bit 26 - Future / or Machine Specific (To be identyfied)
         Spare_27 : Bool;   // Byte 8, Bit 27 - Future / or Machine Specific (To be identyfied)
         Spare_28 : Bool;   // Byte 8, Bit 28 - Future / or Machine Specific (To be identyfied)
         Spare_29 : Bool;   // Byte 8, Bit 29 - Future / or Machine Specific (To be identyfied)
         Spare_30 : Bool;   // Byte 8, Bit 30 - Future / or Machine Specific (To be identyfied)
         Spare_31 : Bool;   // Byte 8, Bit 31 - Future / or Machine Specific (To be identyfied)
      END_STRUCT;
      SystemFaults : Struct   // System faults
         PLCRackFault : Bool;   // Byte 9, Bit 0 - PLC Rack Fault
         EncoderFault : Bool;   // Byte 9, Bit 1 - Encoder Fault
         TipperOrDiverterFault : Bool;   // Byte 9, Bit 2 - Tipper / Diverter Fault
         TCPConFail : Bool;   // Byte 9, Bit 3 - TCP Connection Failure
         SensorJam : Bool;   // Byte 9, Bit 4 - Package Detect Sensor Jam
         CamOrScanFail : Bool;   // Byte 9, Bit 5 - Camera / Scanner Failure
         InductPEJam : Bool;   // Byte 9, Bit 6 - Induct Photo Eye Jam
         SortVerificationPEJam : Bool;   // Byte 9, Bit 7 - Sort Verification Photo Eye Jam
         TakeAwayConvPEJam : Bool;   // Byte 10, Bit 8 - Take Away Conveyor Photo Eye Jam
         SorterMechFault : Bool;   // Byte 10, Bit 9 - Sorter Mechanical Fault
         Spare_10 : Bool;   // Byte 10, Bit 10 - Future / or Machine Specific (To be identyfied)
         SorterJam : Bool;   // Byte 10, Bit 11 - Sorter Jam (Logical Failure)
         InductPCAlignmentError : Bool;   // Byte 10, Bit 12 - Induct Photo Cell Alignment Error
         MotorFault : Bool;   // Byte 10, Bit 13 - Motor Fault
         PowerFault : Bool;   // Byte 10, Bit 14 - Power Fault
         Spare_15 : Bool;   // Byte 10, Bit 15 - Future / or Machine Specific (To be identyfied)
         IOComError : Bool;   // Byte 11, Bit 16 - I/O Communications Error
         RemoteIOComError : Bool;   // Byte 11, Bit 17 - Remote I/O Communications Error
         XLeChatComError : Bool;   // Byte 11, Bit 18 - XLe chat Communications Error
         SerialComError : Bool;   // Byte 11, Bit 19 - Serial Communications Error
         SubsystemError : Bool;   // Byte 11, Bit 20 - Subsytem Error (Scale, Camera, etc...)
         VDFFault : Bool;   // Byte 11, Bit 21 - VDF Fault
         SystemResetInitiated : Bool;   // Byte 11, Bit 22 - System Reset Initiated
         PFCStopMode : Bool;   // Byte 11, Bit 23 - PFC not in Run Mode
         NoHitPoints : Bool;   // Byte 12, Bit 24 - No Hit points / Divert Set Ponts found
         MissingTraysDetected : Bool;   // Byte 12, Bit 25 - Missing Trays Detected
         DataFault : Bool;   // Byte 12, Bit 26 - Data Fault, X number of sequential missing valid SORT messages
         Spare_27 : Bool;   // Byte 12, Bit 27 - Future / or Machine Specific (To be identyfied)
         Spare_28 : Bool;   // Byte 12, Bit 28 - Future / or Machine Specific (To be identyfied)
         Spare_29 : Bool;   // Byte 12, Bit 29 - Future / or Machine Specific (To be identyfied)
         Spare_30 : Bool;   // Byte 12, Bit 30 - Future / or Machine Specific (To be identyfied)
         Spare_31 : Bool;   // Byte 12, Bit 31 - Future / or Machine Specific (To be identyfied)
      END_STRUCT;
      OtherFaults : Struct   // Other faults
         ConsoleDisconnect : Bool;   // Byte 13, Bit 0 - Console Disconnect
         PLCChassisPower : Bool;   // Byte 13, Bit 1 - PLC Chassis Power
         SystemInputPower : Bool;   // Byte 13, Bit 2 - System Input Power
         SystemPowerOutput : Bool;   // Byte 13, Bit 3 - System Power Output
         DiverterTipperPower : Bool;   // Byte 13, Bit 4 - Diverter / Tipper Power
         VFDServoFault : Bool;   // Byte 13, Bit 5 - VFD / Servo Fault
         MotorStarterFault : Bool;   // Byte 13, Bit 6 - Motor Starter Fault
         PLCFault : Bool;   // Byte 13, Bit 7 - PLC Fault
         Spare_8 : Bool;   // Byte 14, Bit 8 - Future / or Machine Specific (To be identyfied)
         Spare_9 : Bool;   // Byte 14, Bit 9 - Future / or Machine Specific (To be identyfied)
         Spare_10 : Bool;   // Byte 14, Bit 10 - Future / or Machine Specific (To be identyfied)
         Spare_11 : Bool;   // Byte 14, Bit 11 - Future / or Machine Specific (To be identyfied)
         Spare_12 : Bool;   // Byte 14, Bit 12 - Future / or Machine Specific (To be identyfied)
         Spare_13 : Bool;   // Byte 14, Bit 13 - Future / or Machine Specific (To be identyfied)
         Spare_14 : Bool;   // Byte 14, Bit 14 - Future / or Machine Specific (To be identyfied)
         Spare_15 : Bool;   // Byte 14, Bit 15 - Future / or Machine Specific (To be identyfied)
         Spare_16 : Bool;   // Byte 15, Bit 16 - Future / or Machine Specific (To be identyfied)
         Spare_17 : Bool;   // Byte 15, Bit 17 - Future / or Machine Specific (To be identyfied)
         Spare_18 : Bool;   // Byte 15, Bit 18 - Future / or Machine Specific (To be identyfied)
         Spare_19 : Bool;   // Byte 15, Bit 19 - Future / or Machine Specific (To be identyfied)
         Spare_20 : Bool;   // Byte 15, Bit 20 - Future / or Machine Specific (To be identyfied)
         Spare_21 : Bool;   // Byte 15, Bit 21 - Future / or Machine Specific (To be identyfied)
         Spare_22 : Bool;   // Byte 15, Bit 22 - Future / or Machine Specific (To be identyfied)
         Spare_23 : Bool;   // Byte 15, Bit 23 - Future / or Machine Specific (To be identyfied)
         Spare_24 : Bool;   // Byte 16, Bit 24 - Future / or Machine Specific (To be identyfied)
         Spare_25 : Bool;   // Byte 16, Bit 25 - Future / or Machine Specific (To be identyfied)
         Spare_26 : Bool;   // Byte 16, Bit 26 - Future / or Machine Specific (To be identyfied)
         Spare_27 : Bool;   // Byte 16, Bit 27 - Future / or Machine Specific (To be identyfied)
         Spare_28 : Bool;   // Byte 16, Bit 28 - Future / or Machine Specific (To be identyfied)
         Spare_29 : Bool;   // Byte 16, Bit 29 - Future / or Machine Specific (To be identyfied)
         Spare_30 : Bool;   // Byte 16, Bit 30 - Future / or Machine Specific (To be identyfied)
         Spare_31 : Bool;   // Byte 16, Bit 31 - Future / or Machine Specific (To be identyfied)
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_UPS1stStageFlowControlConfiguration"
VERSION : 0.1
   STRUCT
      NumberOfInfeedsInUse : Int;   // Number of infeeds used
      ThresholdConsecutivesAboveSP : Int;   // Number of consecutive intervals above set point to trigger flow control
      ThresholdConsecutivesBelowSP : Int;   // Number of consecutive intervals below set point to reset flow control
      IntervalsNumberOfEvaluationPeriod : Int;   // Number of intervals for evaluation of flow control
      LegthBasedFlowControl : Bool;   // TRUE = The input of the counts is length FALSE = The input is counts of parcel
      IsLengthImperial : Bool;   // TRUE =  Length is given in inches. FALSE = Lentgh is given in mm
      IncrementingCounts : Bool;   // TRUE = Input data are incremented. FALSE =  Input data are updated every 15 sec
      Infeed : Array[1..10] of Struct
         RegisterOffset : Int;   // Number of register offset for evalueated flow calculation
         MinimumTimeToStop : UInt;   // Minimum stop time of divert
         IsHighPriority : Bool;   // TRUE= The divert is high priority
         IsNotAllowedToStop : Bool;   // TRUE= The divert is not allowed to stop (e.g. Recirculation)
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_UPSLostCounters"
VERSION : 0.1
   STRUCT
      LostInTracking : DInt;   // Parcel lost in tracking
      NoUPSID : DInt;   // No UPS ID created (missing SCAN_DATA_2)
      NoSortRcv : DInt;   // No sort instruction
   END_STRUCT;

END_TYPE

FUNCTION "FC_CharToInt" : Void
TITLE = FC_TimeToString
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 32
// END_ATTRIBUTES
//Function to convert date in DTL to the string format.
   VAR_INPUT 
      Offset : Int;   // Offset in Char Data
      Data : "UDT_Message";
   END_VAR

   VAR_OUTPUT 
      qi_data : Int;   // Int format data
   END_VAR


BEGIN
	
	
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2019             MHS                                                     |
	|  All Rights Reserved         Larenweg 90                                             |
	|                              5234 KC 's-Hertogenbosch,                               |
	|                              Netherlands                                             |
	|                                                                                      |     
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	28/05/2021  | 0.1       | M. Jager      | first release MHS TIA 16.0
	
	*)
	
	#qi_data :=
	(STRING_TO_INT(IN := (CHAR_TO_STRING(IN := #Data.Character[#Offset]))) * 1000) +
	(STRING_TO_INT(IN := (CHAR_TO_STRING(IN := #Data.Character[#Offset + 1]))) * 100) +
	(STRING_TO_INT(IN := (CHAR_TO_STRING(IN := #Data.Character[#Offset + 2]))) * 10) +
	(STRING_TO_INT(IN := (CHAR_TO_STRING(IN := #Data.Character[#Offset + 3]))));
END_FUNCTION

TYPE "UDT_ConveyorHandshake"
TITLE = UDT_ConveyorHandshake
VERSION : 0.1
//User-defined structure of conveyor handshake variables.
   STRUCT
      GIN : Int;   // General identification number
      NrOfPosToShift : Int;   // Number of positions to shift
      DownstreamDisplacement : Int;   // Displacement from downstream [cm]
      RTS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor ready to send
      RTR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor ready to receive
      TIP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Transfer in progress
      ResetEnergySave { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset energy save mode
      CascadeStartUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Cascade startup
      ReqStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request stop
   END_STRUCT;

END_TYPE

FUNCTION "FC_UPSMsgId" : Void
TITLE = FC_MSGID
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : UPS_SpecificCommunication
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 34
// END_ATTRIBUTES
//Function to create the UPS message ID.
   VAR_INPUT 
      is_ActualDateTime : String;   // Actual date and time
      is_ModuleName : String;   // Module type
      is_DeviceNumber : String;   // Device number
   END_VAR

   VAR_IN_OUT 
      iqs_MSGID : String;   // MSGID character string
      iqdi_UniqueMsgID : DInt;   // Unique message ID integer value
   END_VAR

   VAR_TEMP 
      ts_Timestamp : String;   // Timestamp
      ts_UniqueMsgID : String[11];   // Unique message ID character sting
      ti_UniqueMsgIDLen : Int;   // Unique message ID length
      ti_i : Int;   // Loop counter
   END_VAR

   VAR CONSTANT 
      cc_Dash : Char := '-';   // Dash sign
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	23/08/2019  | 2.1       | K.Pokorski    | Comments simplified
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – Initialization
	    
	    #ts_Timestamp := '';
	    #ti_UniqueMsgIDLen := 0;
	    #ti_i := 0;
	    
	END_REGION
	
	REGION 2 – Timestamp preparation
	    
	    #ts_Timestamp := RIGHT(IN := #is_ActualDateTime, L := 12);
	    
	END_REGION
	
	REGION 3 – Unique message ID preparation
	    
	    // Unique message ID incrementation
	    IF (#iqdi_UniqueMsgID < 2147483647)     // Unique message ID is lower than 2147483647                              
	    THEN
	        
	        #iqdi_UniqueMsgID += 1;
	        
	    ELSE
	        
	        #iqdi_UniqueMsgID := 0;
	        
	    END_IF;
	    
	    // Unique message ID character string clearing
	    #ts_UniqueMsgID := '';
	    
	    // Unique message ID integer conversion to a character string
	    VAL_STRG(IN := #iqdi_UniqueMsgID,
	             SIZE := 0,
	             PREC := 0,
	             FORMAT := 0,
	             P := 1,
	             OUT => #ts_UniqueMsgID);
	    
	    // Length of the unique message ID character string
	    #ti_UniqueMsgIDLen := LEN(#ts_UniqueMsgID);
	    
	    // Unique message ID character string leading zeros addition
	    IF (#ti_UniqueMsgIDLen < 11)        // Unique message ID length lower than 11
	    THEN
	        
	        FOR #ti_i := 1 TO 11 - #ti_UniqueMsgIDLen DO
	            
	            #ts_UniqueMsgID := CONCAT(IN1 := '0',
	                                      IN2 := #ts_UniqueMsgID);
	            
	        END_FOR;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 – MSGID preparation
	    
	    #iqs_MSGID := CONCAT(IN1 := #is_ModuleName,      // Module name 
	                         IN2 := #cc_Dash,            // Dash sign - "-"
	                         IN3 := #is_DeviceNumber,    // Device number
	                         IN4 := #cc_Dash,            // Dash sign - "-"
	                         IN5 := #ts_Timestamp,       // Timestamp 
	                         IN6 := #cc_Dash,            // Dash sign - "-"
	                         IN7 := #ts_UniqueMsgID);    // Unique message ID 
	    
	END_REGION
END_FUNCTION

FUNCTION_BLOCK "FB_SickVmsTcpipReceive"
TITLE = FB_TCPIPReceive
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : Communication
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 45
// END_ATTRIBUTES
//Function block to receive data from TCPIP.
   VAR_INPUT 
      i_UDT_Connection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_Connection";   // Connection parameters
      ix_EnableReceive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Enable receive
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective error output
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective warning output
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // Fifo header
      iqs_FifoData : Array[*] of "UDT_Message";   // Fifo data
      iq_UDT_Statistics : "UDT_TCPIPReceiveStatistics";   // Statistic structure
   END_VAR

   VAR 
      s_FB_TRCV {InstructionName := 'TRCV'; LibVersion := '4.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TRCV;   // Siemens "TRCV" block - to receive the data from TCPIP socket
      ss_TRCV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // TRCV block interface structure
         Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    TRCV - Enable
         NDR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    TRCV - New data available
         Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    TRCV - Busy
         Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    TRCV - Error
         Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   //    TRCV - Status
         RcvLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   //    TRCV - Received length
         Data { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..999] of Char;   //    TRCV - Data
      END_STRUCT;
      s_UDT_MsgArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Message";   // Message character array
      s_UDT_MsgPartArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Message";   // Part of the message character array
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         ErrorCode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Error code structure
            TRCV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Siemens TRCV error code - Check documentation
         END_STRUCT;
         FIFORcvStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";   // Receive FIFO status structure
         FIFORcvError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // Receive FIFO error
         FIFORcvWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // Receive  FIFO warning
         ReceiveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRCV block operation error - Check TRCVStatus
      END_STRUCT;
      sdi_RcvMsgCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Total received messages counter
      si_RcvMsgOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Received message offset
      si_RcvMsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Received message length
      si_NrOfRcvMsg { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Number of received messages in one frame
      si_RcvMsgPartLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length of the part of received message
      si_i { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Loop counter
      si_MaxMsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum message length
      sx_RcvMsgPart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Received part of the message
      sx_InvalidTermination { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Termination sign missing
   END_VAR

   VAR CONSTANT 
      cc_CRLF_R : Char := '$03';
      cc_CRLF_L : Char := '$03';   // Last termination sign
      cc_NULL : Char := '$00';   // NULL sign
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2019             MHS                                                     |
	|  All Rights Reserved         Larenweg 90                                             |
	|                              5234 KC 's-Hertogenbosch,                               |
	|                              Netherlands                                             |
	|                                                                                      |     
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar       | first release MHS TIA 15.1
	17/06/2019  | 0.3       | A.Nowak      | Replace 2nd level subregions with comments (5.3)
	24/07/2019  | 2.0       | L.Klar       | 2.0 MHS library release TIA 15.1
	22/08/2019  | 2.1       | K.Pokorski   | Comments adjusted
	12/09/2019  | 2.2       | A.Nowak      | Delete buffer size variable 
	20/09/2019  | 2.3       | J.Krawczuk   | Replacing UDT_HeartbeatStatus structure to internal structure  
	01/10/2019  | 2.4       | A.Nowak      | Implementation of the new FIFO block
	12/11/2019  | 3.0       | P.Majka      | 3.0 MHS library release TIA 15.1
	23/03/2021  | 3.1       | L.Klar       | Static variables data types changed form uint to int
	14/08/2021  | 3.2       | S. Deulkar   | In region 5.3, conveted variable to ULINT because it was giving warning
	14/03/2024  | 4.1       | S. Nieswiec  | Added from Hannover project and changed name according to standard
	02/05/2024  | 4.2       | J.Majer      | Datatype conversions changed from automatic to explicit, to accomodate IEC 61131-3 standard
	*)
	
	REGION 1 – Update FIFO header status bits
	    
	    // Mode 'S' - FIFO register status update
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFORcvStatus,
	              qx_Error => #ss_Status.FIFORcvError,
	              qx_Warning => #ss_Status.FIFORcvWarning,
	              iqv_Data := #s_UDT_MsgArray,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	    
	END_REGION
	
	REGION 2 – Maximum number of message arrays elements
	    
	    #si_MaxMsgLen := "FC_GetNrOfArrayEl"(iv_Array := #s_UDT_MsgArray.Character);
	    
	END_REGION
	
	REGION 3 – Receive enable
	    
	    // Allow receiving if the connection is established and there are no fifo errors
	    #ss_TRCV.Enable :=
	    #ix_EnableReceive
	    AND NOT #ss_Status.FIFORcvError;
	    
	END_REGION
	
	REGION 4 – Receive data
	    
	    // Data received in an ADHOC mode - data available immediately
	    #s_FB_TRCV(EN_R := #ss_TRCV.Enable,
	               ID := #i_UDT_Connection.ID,
	               LEN := 0,
	               ADHOC := TRUE,
	               NDR => #ss_TRCV.NDR,
	               BUSY => #ss_TRCV.Busy,
	               ERROR => #ss_TRCV.Error,
	               STATUS => #ss_TRCV.Status,
	               RCVD_LEN => #ss_TRCV.RcvLen,
	               DATA := #ss_TRCV.Data);
	    
	END_REGION
	
	IF #ss_TRCV.RcvLen > 1000 THEN
	    #ss_TRCV.RcvLen := 1000;
	END_IF;
	
	REGION 5 – Received data handling
	    
	    // Receiving data was successful
	    IF (#ss_TRCV.NDR                    // New data received without error
	        AND NOT #ss_TRCV.Busy           // Job not yet started or already completed
	        AND NOT #ss_TRCV.Error          // No errors during receiving messages
	        AND #ss_TRCV.RcvLen > 0)        // Length greater than zero
	    THEN
	        
	        REGION 5.1 – Initialization
	            
	            #si_RcvMsgLen := 0;
	            #si_RcvMsgOffset := 0;
	            #si_NrOfRcvMsg := 0;
	            
	        END_REGION
	        
	        REGION 5.2 – Received part of the message
	            
	            // Move part of the messages to a buffer if available
	            IF (#sx_RcvMsgPart)                             // Message part available
	            THEN
	                
	                #s_UDT_MsgArray := #s_UDT_MsgPartArray;
	                #sx_RcvMsgPart := FALSE;
	                
	            END_IF;
	            
	        END_REGION
	        
	        REGION 5.3 – Message handling
	            
	            FOR #si_i := 0 TO UDINT_TO_INT(#ss_TRCV.RcvLen) - 1 DO
	                
	                // Message length validation
	                IF (#si_RcvMsgLen + #si_RcvMsgPartLen < #si_MaxMsgLen)
	                THEN
	                    
	                    // Termination sign found
	                    IF (#ss_TRCV.Data[#si_i] = #cc_CRLF_R)
	                    THEN
	                        
	                        // Move received message to the message array
	                        MOVE_BLK(IN := #ss_TRCV.Data[#si_RcvMsgOffset],
	                                 COUNT := INT_TO_ULINT(#si_RcvMsgLen + 1),
	                                 OUT => #s_UDT_MsgArray.Character[#si_RcvMsgPartLen]);
	                        
	                        // Clear NOT used message array characters
	                        FILL_BLK(IN := #cc_NULL,
	                                 COUNT := INT_TO_ULINT(#si_MaxMsgLen - #si_RcvMsgLen + #si_RcvMsgPartLen - 1),
	                                 OUT => #s_UDT_MsgArray.Character[#si_RcvMsgLen + #si_RcvMsgPartLen + 1]);
	                        
	                        // Check and clear termination sign                                                       
	                        IF (#si_RcvMsgLen + #si_RcvMsgPartLen - 1) >= 0 AND (#si_RcvMsgLen + #si_RcvMsgPartLen - 1) < #si_MaxMsgLen THEN
	                            IF (#s_UDT_MsgArray.Character[#si_RcvMsgLen + #si_RcvMsgPartLen] = #cc_CRLF_R)        // Character is a termination sign
	                            THEN
	                                #sx_InvalidTermination := FALSE;                                    // Reset the invalid termination bit
	                                
	                                // Termination sign invalid - error generated, statistics increased    
	                            ELSE
	                                
	                                #sx_InvalidTermination := TRUE;
	                                #iq_UDT_Statistics.InvalidMsg += 1;
	                                
	                            END_IF;
	                        ELSE
	                            #iq_UDT_Statistics.InvalidMsg += 1;
	                        END_IF;
	                        
	                        
	                        // Move message into the FIFO data block
	                        IF (NOT #sx_InvalidTermination)                                         // No termination sign error 
	                        THEN
	                            
	                            // Mode 'W' - Write FIFO record
	                            "FC_Fifo"(ic_Mode := 'W',
	                                      qUDT_Status => #ss_Status.FIFORcvStatus,
	                                      qx_Error => #ss_Status.FIFORcvError,
	                                      qx_Warning => #ss_Status.FIFORcvWarning,
	                                      iqv_Data := #s_UDT_MsgArray,
	                                      iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	                                      iqv_DataBuffer := #iqs_FifoData);
	                            
	                            
	                        END_IF;
	                        
	                        
	                        // Update lengths and counters
	                        #si_RcvMsgPartLen := 0;
	                        #si_RcvMsgOffset += #si_RcvMsgLen + 1;
	                        #si_RcvMsgLen := 0;
	                        #si_NrOfRcvMsg += 1;
	                        #sdi_RcvMsgCounter += 1;
	                        
	                        // Termination sign not found        
	                    ELSE
	                        
	                        #si_RcvMsgLen := #si_RcvMsgLen + 1;                               // Increment received message length
	                        
	                    END_IF;
	                    
	                    // Message length invalid - reset message length and increase statistics
	                ELSE
	                    
	                    #si_RcvMsgLen := 0;
	                    #iq_UDT_Statistics.InvalidMsg += 1;
	                    
	                END_IF;
	                
	            END_FOR;
	            
	        END_REGION
	        
	        REGION 5.4 – Part of the message preparation
	            
	            // Move part of the message to buffer when last received sign is not a termination signs
	            IF (#ss_TRCV.Data[UDINT_TO_INT(#ss_TRCV.RcvLen) - 1] <> #cc_CRLF_R            // Last received sign is not a termination sing
	                AND #si_RcvMsgLen < #si_MaxMsgLen)                         // Message length valid
	            THEN
	                
	                // Fill not used message char array elements with '$00' 
	                FILL_BLK(IN := '$00',
	                         COUNT := INT_TO_ULINT(#si_MaxMsgLen) -
	                         INT_TO_ULINT(#si_RcvMsgLen),
	                         OUT => #s_UDT_MsgPartArray.Character[#si_RcvMsgLen]);
	                
	                // Move part of the message to a buffer
	                MOVE_BLK(IN := #ss_TRCV.Data[#si_RcvMsgOffset],
	                         COUNT := INT_TO_ULINT(#si_RcvMsgLen),
	                         OUT => #s_UDT_MsgPartArray.Character[0]);
	                
	                // Set the part of the message received bit and move length of the received message into the length of the part of the message variable
	                #sx_RcvMsgPart := TRUE;
	                #si_RcvMsgPartLen := #si_RcvMsgLen;
	                
	            END_IF;
	            
	        END_REGION
	        
	    END_IF;
	    
	END_REGION
	
	REGION 6 – Status
	    
	    REGION 6.1 - Block status
	        
	        // Receive error
	        #ss_Status.ReceiveError := #ss_TRCV.Error;
	        
	        // Parametrization collective error output
	        #qx_Error :=
	        #ss_Status.FIFORcvError                          // FIFO error
	        OR #ss_Status.ReceiveError;                      // Receive error
	        
	        // Parametrization collective warning output
	        #qx_Warning := #ss_Status.FIFORcvWarning;        // FIFO warning
	        
	    END_REGION
	    
	    REGION 6.2 - Error code preparation
	        
	        IF (#ss_TRCV.#Status > 16#8000
	            OR #ss_TRCV.#Status = 16#0)
	        THEN
	            
	            #ss_Status.ErrorCode.TRCV := #ss_TRCV.#Status;
	            
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_TCPIPConnect"
TITLE = FB_TCPIPConnect
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : Communication
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 231
// END_ATTRIBUTES
//Function block to establish and terminateTCPIP connection.
   VAR_INPUT 
      iUDT_Connection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_Connection";   // Connection parameters
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_TCPIPConnectStatus";   // HMI status structure
      qUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   // Common status structure
      qx_Connected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Connected status
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
      iqUDT_Statistics : "UDT_TCPIPConnectStatistics";   // Statistic structure
      iqx_Reconnect { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reconnect command
   END_VAR

   VAR 
      sUDT_CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Common status structure
      sFB_TCON {InstructionName := 'TCON'; LibVersion := '4.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TCON;   // Siemens "TCON" block - to establish the connection
      sFB_TDISCON {InstructionName := 'TDISCON'; LibVersion := '2.1'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TDISCON;   // Siemens "TDISCON" block - to terminate the connection
      sFB_DIAG {InstructionName := 'T_DIAG'; LibVersion := '1.2'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : T_DIAG;   // Siemens "T_DIAG" block - to diagnose the connection
      sFB_TimerConTimeout { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // MHS "FB_TimerOnOffDelay" block - to measure the connection timeout
      sFB_TimerFilter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // MHS "FB_TimerOnOffDelay" block - to filter the connection established signal
      sv_InterfaceData {InstructionName := 'TCON_IP_v4'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TCON_IP_v4;   // TCON Interface configuration data
      sR_TRIG_ConnectionLost {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Siemens "R_TRIG" - to prepare rising edge signal on Connection lost signal
      sR_TRIG_Reset {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Siemens "R_TRIG" - to prepare rising edge signal on reset data signal
      sa_Connect { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // TCON interface structure
         Request { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TCON - Request
         Done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TCON - Done
         Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TCON - Busy
         Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TCON - Error
         Active { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TCON - Active
         Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   //  TCON - Status
      END_STRUCT;
      sa_Disconnect { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // TDISCON interface structure
         Request { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TDISCON - Request
         Done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TDISCON - Done
         Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TDISCON - Busy
         Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TDISCON - Error
         Active { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TDISCON - Active
         Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   //  TDISCON - Status
      END_STRUCT;
      sa_Diag { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // T_DIAG block diagnostic variables
         Request { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TDIAG - Request
         Done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TDIAG - Done
         Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TDIAG - Busy
         Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TDIAG - Error
         Active { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TDIAG - Active
         Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   //  TDIAG - Status
         Result {InstructionName := 'TDiag_Status'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TDiag_Status;   //  TDIAG - Result
      END_STRUCT;
      sx_Connected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Connection established memory
      sx_ConnectedFiltred { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Connection established memory (filtred)
      sx_CommunicationFault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Communication fault
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	13/06/2019  | 0.2       | A.Nowak       | Delete writing to variable - S_FB_Timer_ConTimeout
	24/06/2019  | 0.3       | L.Klar        | Status running added
	25/06/2019  | 0.5       | L.Klar        | Statistics changed to InOut
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	21/08/2019  | 2.1       | K.Pokorski    | Comments adjusted
	26/09/2019  | 2.2       | A.Nowak       | Delete static status structure and change region 9. Create new static sx_CommunicationFault.
	09/10/2019  | 2.3       | M.Kurc        | System equipment control added
	04/11/2019  | 2.4       | L.Klar        | 10 Hz clock and first scan changed from memory bit to DB variable
	19/11/2019  | 2.5       | L.Klar        | Status outputs corrected
	20/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – Initialization
	    
	    // Reset connected status bit and reconnect command bit during first PLC scan
	    IF ("DB_Memory".FirstScan)             // First PLC scan occured
	    THEN
	        
	        #sx_Connected := FALSE;
	        #iqx_Reconnect := TRUE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 – Connection error reset
	    
	    // Reset errors and blocks statuses when no connection state available and communication fault reset received 
	    #sR_TRIG_Reset(CLK := #iqUDT_EquipmentControl.Command.Reset);
	    
	    IF (#sx_CommunicationFault                                      // Communication fault 
	        AND #sR_TRIG_Reset.Q)                                      // Reset signal trigger
	    THEN
	        
	        #sa_Connect.Status := 16#0;
	        #sa_Disconnect.Status := 16#0;
	        #sa_Diag.Status := 16#0;
	        #sx_CommunicationFault := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 – Communication Interface preparation
	    
	    #sv_InterfaceData.InterfaceId := #iUDT_Connection.Interface_ID;                       // HW-identifier of IE-interface submodule 
	    #sv_InterfaceData.ID := #iUDT_Connection.ID;                                          // Connection reference / identifier
	    #sv_InterfaceData.ConnectionType := 16#0B;                                             // Type OF connection: 11=TCP/IP, 19=UDP 17=TCP/IP
	    #sv_InterfaceData.ActiveEstablished := #iUDT_Connection.ActiveEstablished;            // Active/passive connection establishment
	    #sv_InterfaceData.RemoteAddress.ADDR[1] := INT_TO_BYTE(#iUDT_Connection.IP[1]);       // Remote IP address (IPv4) - x.0.0.0
	    #sv_InterfaceData.RemoteAddress.ADDR[2] := INT_TO_BYTE(#iUDT_Connection.IP[2]);       // Remote IP address (IPv4) - 0.x.0.0
	    #sv_InterfaceData.RemoteAddress.ADDR[3] := INT_TO_BYTE(#iUDT_Connection.IP[3]);       // Remote IP address (IPv4) - 0.0.x.0
	    #sv_InterfaceData.RemoteAddress.ADDR[4] := INT_TO_BYTE(#iUDT_Connection.IP[4]);       // Remote IP address (IPv4) - 0.0.0.x 
	    
	    // Set local or remote port depending on whether the PLC is active or passive device in connection 
	    IF (#sv_InterfaceData.ActiveEstablished)                                               // Active connection
	    THEN
	        
	        #sv_InterfaceData.LocalPort := 0;
	        #sv_InterfaceData.RemotePort := #iUDT_Connection."Port";
	        
	        // Passive connection
	    ELSE
	        
	        #sv_InterfaceData.LocalPort := #iUDT_Connection."Port";
	        #sv_InterfaceData.RemotePort := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 – Connection establishment and termination
	    
	    IF (#iqx_Reconnect)                                                     // Reconnect request          
	    THEN
	        
	        // Terminate a TCPIP connection if reconnect command available and connection established
	        IF (#sx_Connected)                                                  // Connection established
	        THEN
	            
	            // Disconnect request 
	            #sa_Disconnect.Request :=
	            #iqx_Reconnect                                                  // Reconnect command
	            AND #sa_Disconnect.Status = 16#7000;                            // TDISCON block status is equal to 16#7000 (No job processing active)
	            
	            // Terminate a TCPIP connection when request available
	            #sFB_TDISCON(REQ := #sa_Disconnect.Request,
	                         ID := #sv_InterfaceData.ID,
	                         DONE => #sa_Disconnect.Done,
	                         BUSY => #sa_Disconnect.Busy,
	                         ERROR => #sa_Disconnect.Error,
	                         STATUS => #sa_Disconnect.Status);
	            
	            // In case of connection broken, connected bit and disconnect block active bit are reset
	            IF (#sa_Disconnect.Done)                                        // Disconnect was successful
	            THEN
	                
	                #sx_Connected := FALSE;
	                #sa_Disconnect.Active := FALSE;
	                
	                // Connection termination in progress
	            ELSE
	                
	                #sa_Disconnect.Active := TRUE;                              // Set the disconnecting active status bit 
	                
	            END_IF;
	            
	            // Try to establish connection if reconnect command active and there is no connection
	        ELSE                                                                // Connection is terminated 
	            
	            // Connect request
	            #sa_Connect.Request := #iqx_Reconnect AND                       // Reconnect command 
	            #sa_Connect.Status = 16#7000;            // TCON block status is equal to 16#7000 (No job processing active)
	            
	            // Establishing a TCPIP connection when request available
	            #sFB_TCON(REQ := #sa_Connect.Request,
	                      ID := #sv_InterfaceData.ID,
	                      DONE => #sa_Connect.Done,
	                      BUSY => #sa_Connect.Busy,
	                      ERROR => #sa_Connect.Error,
	                      STATUS => #sa_Connect.Status,
	                      CONNECT := #sv_InterfaceData);
	            
	            // In case of connection established, connected bit is set, connect block active bit and reconnect command are reset
	            IF (#sa_Connect.Done)                                           // Connect successful 
	            THEN
	                
	                #sx_Connected := TRUE;
	                #sa_Connect.Active := FALSE;
	                #iqx_Reconnect := FALSE;
	                
	                // Connection establishing in progress
	            ELSE
	                
	                #sa_Connect.Active := TRUE;                                 // Set the connecting active status
	                
	            END_IF;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 5 – Connection establishment and termination error handling
	    
	    // Measure the maximum connect or disconnect time
	    #sFB_TimerConTimeout(ix_SignalToDelay := #sa_Connect.Active
	                         OR #sa_Disconnect.Active,
	                         iudi_OnDelayTime := DINT_TO_UDINT(#iUDT_Connection.ConTimeout),
	                         iudi_OffDelayTime := 0);
	    
	    IF (#sFB_TimerConTimeout.qx_DelayedSignal)                                                 // Connecting / disconnecting time error from connection timeout timer
	    THEN
	        
	        IF (#sa_Connect.Active)                                                                  // Connecting is active
	        THEN
	            
	            // If connection already exist and block try establish connection, connected bit is set, connect block active bit and reconnect command are reset
	            IF (#sa_Connect.Status = 16#80A3)                                                    // Connecting status equal to 16#80A3 - The connection already exist
	            THEN
	                
	                #sx_Connected := TRUE;
	                #sa_Connect.Active := FALSE;
	                #iqx_Reconnect := FALSE;
	                
	                // Connection time has expired - error generated
	            ELSE
	                
	                #sx_CommunicationFault := TRUE;
	                
	            END_IF;
	            
	            // Disconnect operation failed - error generated 
	        ELSIF (#sa_Disconnect.Active)
	        THEN
	            
	            #sx_CommunicationFault := TRUE;
	            
	        END_IF;
	        
	    END_IF;
	    
	    // The connection terminated by partner - error generated, connected bit reset and reconnect command request set
	    IF (#sa_Diag.Result.State <> 16#04)                         // The connection terminated by partner                                                    
	    THEN
	        
	        #sx_CommunicationFault := TRUE;
	        #sx_Connected := FALSE;
	        #iqx_Reconnect := TRUE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 6 – Connection diagnostic
	    
	    // Check connection condition ten times per second
	    IF (NOT #sa_Connect.Active AND NOT #sa_Disconnect.Active)        // Connecting and disconnecting procedure are not active
	    THEN
	        
	        #sFB_DIAG(REQ := "DB_Memory".Clock_10Hz,
	                  ID := #sv_InterfaceData.ID,
	                  DONE => #sa_Diag.Done,
	                  BUSY => #sa_Diag.Busy,
	                  ERROR => #sa_Diag.Error,
	                  STATUS => #sa_Diag.Status,
	                  RESULT := #sa_Diag.Result);
	        
	    END_IF;
	    
	END_REGION
	
	REGION 7 – Connection established filter
	    
	    // Connected status bit filtering
	    #sFB_TimerFilter(ix_SignalToDelay := #sx_Connected,
	                     iudi_OnDelayTime := 50,
	                     qx_DelayedSignal => #sx_ConnectedFiltred);
	    
	END_REGION
	
	REGION 8 – Statistics
	    
	    // Prepare rising edge of connected status signal 
	    #sR_TRIG_ConnectionLost(CLK := NOT #sx_ConnectedFiltred);
	    
	    // Conditions to call "FC_Statistics" 
	    IF (NOT #sx_ConnectedFiltred                                                        // No connection 
	        OR #iqUDT_EquipmentControl.Command.ResetData)                                  // Reset data
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := NOT #sx_ConnectedFiltred,
	                        ix_RTrigActivate := #sR_TRIG_ConnectionLost.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.ConnectionLost);
	        
	    END_IF;
	    
	END_REGION
	
	REGION 9 – Status
	    
	    #sUDT_CommonStatus.Error := #sx_CommunicationFault;                        // Error
	    
	    #sUDT_CommonStatus.AutoON := #sx_ConnectedFiltred;                         // Auto ON
	    
	    #qUDT_HMIStatus.Specific.CommunicationFault := #sx_CommunicationFault;     // Communication faults
	    
	    #qUDT_HMIStatus.Specific.Connected := #sx_ConnectedFiltred;                // Connected
	    
	    IF #sUDT_CommonStatus.AutoON                                               // Auto ON
	    THEN
	        
	        #qUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".AutoON;
	        
	    END_IF;
	    
	    IF #sUDT_CommonStatus.Error                                                // Error
	    THEN
	        
	        #qUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Error;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 10 Report to control block
	    
	    // Function to manage report between control block and conveyor block
	    
	    "FC_EquipmentReport"(iUDT_Status := #sUDT_CommonStatus,
	                         iqUDT_Control := #iqUDT_EquipmentControl);
	    
	END_REGION
	
	REGION 11 – Write outputs
	    
	    #qx_Connected := #sx_Connected;
	    
	END_REGION
END_FUNCTION_BLOCK

TYPE "UDT_ParcelData"
VERSION : 0.1
   STRUCT
      AvgParcelLength : DInt := 10;
      TimeReadMessages : Time := T#10s;
      TimOutComm : Time := T#30s;
      NrOfParcels : Array[1..500] of DInt;
   END_STRUCT;

END_TYPE

TYPE "UDT_UPSSafetyZoneStatistics"
VERSION : 0.1
   STRUCT
      NotHealthy { S7_SetPoint := 'False'} : "UDT_EventStatistic";
   END_STRUCT;

END_TYPE

TYPE "UDT_ConveyorInterface"
TITLE = UDT_ConveyorInterface
VERSION : 0.1
//User-defined structure of conveyor interface variables.
   STRUCT
      Displacement : Int;   // Displacement per PLC scan [cm] either from position (if available) or speed and time
      SpeedSetpoint : Int;   // Conveyor speed setpoint [mm/s]
      ActualSpeed : Int;   // Conveyors actual speed [mm/s]
      DeltaPosition : Int;   // Read from Conveyor Servo Position [mm] after 1 PLC cycle
      RunFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Run forward request
      RunRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Run reverse request
      InternalErrorEncoder { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Encoder has an error
      InternalErrorVFD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // VFD has an error
      InternalErrorTracking { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Tracking has an error
      InternalErrorPEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PEC has an error
      InternalWarningVFD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // VFD has a warning
      InternalWarningTracking { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Tracking has a warning
      InternalErrorReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset internal errors
      ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Configuration error is active
      VFDRunning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor is running
      VFDatSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor at speed setpoint
      Disconnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // VFD disconnected
      ManualModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Covneyor is in manual mode
      ResetStatistics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset statistics
      HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Hardware for the Equipment is available and healthy
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_UPSCameraFault"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 49
// END_ATTRIBUTES
   VAR_INPUT 
      ii_GIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // GIN to be checked
   END_VAR

   VAR_OUTPUT 
      qx_Fault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Camera fault
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
   END_VAR

   VAR 
      si_CameraGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Camera GIN
      si_MissingScanData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Number of missing SCAN_DATA2 messages
   END_VAR

   VAR CONSTANT 
      ci_MaximumMissingScanData : Int := 10;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	15/01/2020  | 3.0       | L.Klar        | 3.0 MHS library release TIA 15.1
	22/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Calculate displacement 
	    
	    // Check if for GIN found in tracking ID has been created (SCAN_DATA2 received) 
	    // After 10 missings a fault is generated
	    
	    IF #ii_GIN <> #si_CameraGIN
	        AND #ii_GIN <> 0
	    THEN
	        
	        #si_CameraGIN := #ii_GIN;
	        
	        IF #si_CameraGIN > 0
	        THEN
	            IF NOT "DB_GIN".GIN[#si_CameraGIN].UPS.IDCreated
	            THEN
	                #si_MissingScanData += 1;
	            ELSE
	                #si_MissingScanData := 0;
	            END_IF;
	        END_IF;
	        
	        
	        IF #si_MissingScanData >= #ci_MaximumMissingScanData
	        THEN
	            #qx_Fault := TRUE;
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Fault reset
	    IF #si_MissingScanData >= #ci_MaximumMissingScanData
	        AND #iqUDT_EquipmentControl.Command.Reset
	    THEN
	        #qx_Fault := FALSE;
	        #si_MissingScanData := 0;
	    END_IF;
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_UPSCIP"
TITLE = Communication Interface Panel Cabinet Block
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : CesarLeite
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 51
// END_ATTRIBUTES
   VAR_INPUT 
      ix_SystemRunning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // System running error free
      ix_XLESelectorSwitch { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Selector switch CHAT/XLE - (True=BackUp, False=Primary)
      ix_CameraSelectorSwitch { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Selector switch Camera - (True=BackUp, False=Primary)
      ix_CIP24VDC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // CIP 24VDC Ok - (True=Healthy, False=Error)
      ix_CIPCircuitBreakerOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // CIP circuit breaker Ok (True=Healthy, False=Error)
      ix_DWSOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Weighing Scale Ok (True=Healthy, False=Error)
      ix_CameraInput1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Camera Tunel Input 1
      ix_CameraInput2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Camera Tunel Input 2
      ix_XLEFaulty { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // XLE Chat communication fault
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_UPSCIPStatus";   // CIP Status
      qUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   // CIP HMI Status
      qx_SystemStopRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // System stop request
      qx_XLEReconnect { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reconnect XLE
      qx_XLESwitch { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // If the output is false the XLE is in primary, if false the XLE is in backup
      qx_CameraSwitch { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // If the output is false the camera is in primary, if false the camara is in backup
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   // CIP Equipment control
      iqUDT_Statistics : "UDT_UPSCIPStatistics";   // CIP Statistics structure
   END_VAR

   VAR 
      sUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_UPSCIPStatus";   // HMI status structure
      sUDT_CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Common status structure
      sUDT_CommonStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Common status structure
      sR_Trig_XLESwitch {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rise trigger when XLE selector switch to backup
      sF_Trig_XLESwitch {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Fall trigger when XLE selector switch to primary
      sR_Trig_CameraSwitch {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rise trigger when camera selector switch to backup
      sF_Trig_CameraSwitch {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Fall trigger when camera selector switch to primary
      sF_Trig_CIP24VDC {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Fall trigger when CIP 24VDC
      sF_Trig_CIPCircuitBreaker {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Fall trigger when CIP circuit breaker is tripped
      sF_Trig_DWSFault {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Fall trigger when weighing scale has a fault
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	19/09/2019  | 2.0       | C.Leite       | first release TIA 15.1
	14/10/2019  | 2.1       | L.Klar        | Updated status structure
	07/11/2019  | 2.2       | M.Kurc        | Add I/O: system running/stop and camera/XLE switch
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1 
	09/07/2020  | 3.1       | S.Theocharis  | Update HMI status in every scan. Bug fix with initialization
	21/08/2020  | 3.2       | S.Theocharis  | Error handling when XLE/Camera switch while system is running
	                                        | Added statistics of selection switches
	13/08/2020  | 3.3       | L.Klar        | XLE reconnect command added, communication fault added to stop camera belt
	22/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Trigger
	    
	    // Rise trigger selector switch CHAT/XLE BackUp 
	    #sR_Trig_XLESwitch(CLK := #ix_XLESelectorSwitch);
	    
	    // Fall trigger selector switch CHAT/XLE BackUp 
	    #sF_Trig_XLESwitch(CLK := #ix_XLESelectorSwitch);
	    
	    // Fall trigger selector switch camera to primary 
	    #sF_Trig_CameraSwitch(CLK := #ix_CameraSelectorSwitch);
	    
	    // Rise trigger selector switch camera to primary 
	    #sR_Trig_CameraSwitch(CLK := #ix_CameraSelectorSwitch);
	    
	    // Fall trigger CIP 24VDC error
	    #sF_Trig_CIP24VDC(CLK := #ix_CIP24VDC);
	    
	    // Fall trigger CIP 24VDC circuit breaker tripped
	    #sF_Trig_CIPCircuitBreaker(CLK := #ix_CIPCircuitBreakerOk);
	    
	    // Fall trigger weighing scale fault
	    #sF_Trig_DWSFault(CLK := #ix_DWSOk);
	    
	END_REGION
	
	REGION 2 - Reset faults
	    
	    // All faults are reset when the reset input is true
	    IF #iqUDT_EquipmentControl.Command.Reset
	    THEN
	        
	        #sUDT_HMIStatus.Specific.CIP24VDCError := FALSE;
	        #sUDT_HMIStatus.Specific.CIPCircuitBreakerTripped := FALSE;
	        #sUDT_HMIStatus.Specific.WeighingScaleFault := FALSE;
	        #sUDT_HMIStatus.Specific.XLE_SwitchError := FALSE;
	        #sUDT_HMIStatus.Specific.Camera_SwitchError := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Status monitoring 
	    
	    // CHAT/XLE Selector Switch
	    
	    #sUDT_HMIStatus.Specific.XLEBackUp := #ix_XLESelectorSwitch;
	    
	    #sUDT_HMIStatus.Specific.XLEPrimary := NOT #ix_XLESelectorSwitch;
	    
	    // CIP 24VDC Fault
	    
	    IF NOT #ix_CIP24VDC
	    THEN
	        
	        #sUDT_HMIStatus.Specific.CIP24VDCError := TRUE;
	        
	    END_IF;
	    
	    // CIP Circuit Breaker Tripped
	    
	    IF NOT #ix_CIPCircuitBreakerOk
	    THEN
	        
	        #sUDT_HMIStatus.Specific.CIPCircuitBreakerTripped := TRUE;
	        
	    END_IF;
	    
	    // Weighing Scale Fault
	    
	    IF NOT #ix_DWSOk
	    THEN
	        
	        #sUDT_HMIStatus.Specific.WeighingScaleFault := TRUE;
	        
	    END_IF;
	    
	    // Camera Tunel 
	    #sUDT_HMIStatus.Specific.CameraTunel1 := NOT #ix_CameraSelectorSwitch;
	    #sUDT_HMIStatus.Specific.CameraTunel2 := #ix_CameraSelectorSwitch;
	    
	    // XLE Switching error while running
	    IF #ix_SystemRunning AND (#sR_Trig_XLESwitch.Q OR #sF_Trig_XLESwitch.Q)
	    THEN
	        #sUDT_HMIStatus.Specific.XLE_SwitchError := TRUE;
	    END_IF;
	    
	    // Camera Switching error while running
	    IF #ix_SystemRunning AND (#sR_Trig_CameraSwitch.Q OR #sF_Trig_CameraSwitch.Q)
	    THEN
	        #sUDT_HMIStatus.Specific.Camera_SwitchError := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Switching Camera and XLE
	    
	    // XLE activation
	    #qx_XLESwitch := #ix_XLESelectorSwitch;
	    
	    // Camera activation
	    #qx_CameraSwitch := #ix_CameraSelectorSwitch;
	    
	END_REGION
	
	REGION 5 - XLE change 
	    
	    #qx_XLEReconnect := #sR_Trig_XLESwitch.Q OR #sF_Trig_XLESwitch.Q;
	    
	END_REGION
	
	REGION 6 - Statistics
	    
	    // 24 VDC fault statistics
	    IF #sUDT_HMIStatus.Specific.CIP24VDCError
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.CIP24VDCError,
	                        ix_RTrigActivate := #sF_Trig_CIP24VDC.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.CIP24VDCFault);
	        
	    END_IF;
	    
	    // CIP Circuit Breaker Tripped statistics
	    IF #sUDT_HMIStatus.Specific.CIPCircuitBreakerTripped
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.CIPCircuitBreakerTripped,
	                        ix_RTrigActivate := #sF_Trig_CIPCircuitBreaker.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.CIPCircuitBreakerTripped);
	        
	    END_IF;
	    
	    // CIP Weighing Scale Fault statistics
	    IF #sUDT_HMIStatus.Specific.WeighingScaleFault
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.WeighingScaleFault,
	                        ix_RTrigActivate := #sF_Trig_DWSFault.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.WeighingScaleFault);
	    END_IF;
	    
	    //Camera selection switch changes
	    IF #sR_Trig_CameraSwitch.Q OR #sF_Trig_CameraSwitch.Q THEN
	        #iqUDT_Statistics.SS_Camera += 1;
	        
	    ELSIF #iqUDT_EquipmentControl.Command.ResetData THEN
	        #iqUDT_Statistics.SS_Camera := 0;
	    END_IF;
	    
	    //XLE selector switch changes
	    IF #sR_Trig_XLESwitch.Q OR #sF_Trig_XLESwitch.Q THEN
	        #iqUDT_Statistics.SS_XLE += 1;
	        
	    ELSIF #iqUDT_EquipmentControl.Command.ResetData THEN
	        #iqUDT_Statistics.SS_XLE := 0;
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Status
	    
	    // Stop system
	    #qx_SystemStopRequest := #ix_SystemRunning AND (#sUDT_HMIStatus.Specific.Camera_SwitchError OR #sUDT_HMIStatus.Specific.XLE_SwitchError OR #ix_XLEFaulty);
	    
	    // Set common error to report 
	    #sUDT_CommonStatus.Error := #sUDT_HMIStatus.Specific.WeighingScaleFault
	    OR #sUDT_HMIStatus.Specific.CIPCircuitBreakerTripped
	    OR #sUDT_HMIStatus.Specific.CIP24VDCError
	    OR #sUDT_HMIStatus.Specific.Camera_SwitchError
	    OR #sUDT_HMIStatus.Specific.XLE_SwitchError;
	    
	    // Write status value to output
	    IF #sUDT_CommonStatusOld <> #sUDT_CommonStatus                                // Update on change
	        OR (#sR_Trig_CameraSwitch.Q OR #sF_Trig_CameraSwitch.Q)
	        OR (#sR_Trig_XLESwitch.Q OR #sF_Trig_XLESwitch.Q)
	    THEN
	        
	        #sUDT_HMIStatus.Status := 0; //initialize status
	        
	        IF #sUDT_HMIStatus.Specific.WeighingScaleFault                             // Error
	            OR #sUDT_HMIStatus.Specific.Camera_SwitchError
	            OR #sUDT_HMIStatus.Specific.XLE_SwitchError
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Error;
	            
	        END_IF;
	        
	        IF #sUDT_HMIStatus.Specific.CIPCircuitBreakerTripped                       // CB error
	            OR #sUDT_HMIStatus.Specific.CIP24VDCError
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".CBError;
	        END_IF;
	        
	        
	        #sUDT_CommonStatusOld := #sUDT_CommonStatus;                              // Copy status to memory
	        #qUDT_Status := #sUDT_CommonStatus;                                       // Copy status to output
	    END_IF;
	    
	    #qUDT_HMIStatus := #sUDT_HMIStatus;                                           // Copy HMI status
	    
	END_REGION
	
	REGION 8 - Report to control block
	    
	    // Function to manage report between control block and conveyor block
	    
	    "FC_EquipmentReport"(iUDT_Status := #sUDT_CommonStatus,
	                         iqUDT_Control := #iqUDT_EquipmentControl);
	    
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_SickTCPcomm"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 236
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_Connection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_Connection";   // Connection parameters
   END_VAR

   VAR_OUTPUT 
      qx_CommunicationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Communication error
      q_di_FlowCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Total parcel flow count
   END_VAR

   VAR_IN_OUT 
      iq_UDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
      iq_UDT_Statistics_Connect : "UDT_TCPIPConnectStatistics";   // Statistic structure
      iq_UDT_Statistics_Rcv : "UDT_TCPIPReceiveStatistics";   // Statistic structure
      iq_UDT_ParcelData : "UDT_ParcelData";   // Parcel data
      iq_UDT_FIFOHeader : "UDT_FifoHeader";
      iq_FIFOData : Array[*] of "UDT_Message";
      iqx_Reconnect { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reconnect command
   END_VAR

   VAR 
      TCPIP_Connect { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TCPIPConnect";
      TCPIPReceive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_SickVmsTcpipReceive";
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         ErrorCode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Error code structure
            TRCV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Siemens TRCV error code - Check documentation
         END_STRUCT;
         FIFORcvStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";   // Receive FIFO status structure
         FIFORcvError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // Receive FIFO error
         FIFORcvWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // Receive  FIFO warning
         ReceiveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRCV block operation error - Check TRCVStatus
      END_STRUCT;
      ss_UDT_MsgArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Message";   // Message character array
      sdi_Lenght { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // object length
      si_SystemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 0=stopped, 1=running, 2=jam
      si_PackageCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // number of objects
      si_SeqNr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Current incremental sequence number
      si_SeqNrOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Last incremental sequence number
      si_Counter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // loop counter
      slr_Time { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // message read time
      slr_ComTimeOut { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Communcation timeout time
      sx_CommError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Communication error
      sx_ReceiveEnable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE=receive enable
      sx_ReadBuffer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // read the FIFO buffer
      sr_TotalAvgParcel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;
   END_VAR

   VAR_TEMP 
      tx_Error : Bool;   // TCPIP communication error
      tdi_CycleLenght : DInt;
      tx_Warning : Bool;   // TCPIP communication warning
      ti_Length : Int;   // the length of parcel
      ti_Move_BLKErrorCode : Int;
      tr_CycleAvgParcels : Real;
      tx_IntegerAvgParcels : Real;
   END_VAR

   VAR CONSTANT 
      Index_IncSeqNr : Int := 1;   // was 8
      Index_SystemStatus : Int := 5;   // was 12
      Index_PackageCount : Int := 6;   // was 13
      Index_StartFirstLength : Int := 7;   // was 14
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2019             MHS                                                     |
	|  All Rights Reserved         Larenweg 90                                             |
	|                              5234 KC 's-Hertogenbosch,                               |
	|                              Netherlands                                             |
	|                                                                                      |
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	22/03/2021  | 0.1       | M. Jager     | first release MHS TIA 16.0
	26/07/2022  | 0.2       | S. Deulkar   | Reset avg parcel data when reset data command occour
	14/03/2024  | 4.1       | S. Nieswiec  | Added from Hannover project and changed name according to standard
	*)
	
	
	#TCPIP_Connect(iUDT_Connection := #i_UDT_Connection,
	               qx_Connected => #sx_ReceiveEnable,
	               iqUDT_EquipmentControl := #iq_UDT_EquipmentControl,
	               iqUDT_Statistics := #iq_UDT_Statistics_Connect,
	               iqx_Reconnect := #iqx_Reconnect);
	
	#TCPIPReceive(i_UDT_Connection := #i_UDT_Connection,
	              ix_EnableReceive := #sx_ReceiveEnable,
	              qx_Error => #tx_Error,
	              qx_Warning => #tx_Warning,
	              iq_UDT_FifoHeader := #iq_UDT_FIFOHeader,
	              iqs_FifoData := #iq_FIFOData,
	              iq_UDT_Statistics := #iq_UDT_Statistics_Rcv);
	
	
	// Read the FIFO data when it is not EMPTY
	IF NOT #iq_UDT_FIFOHeader.Status.Empty THEN
	    #sx_ReadBuffer := TRUE;
	END_IF;
	
	IF #sx_ReadBuffer THEN
	    
	    "FC_Fifo"(ic_Mode := 'R',
	              qUDT_Status => #ss_Status.FIFORcvStatus,
	              qx_Error => #ss_Status.FIFORcvError,
	              qx_Warning => #ss_Status.FIFORcvWarning,
	              iqv_Data := #ss_UDT_MsgArray,
	              iqUDT_FifoHeader := #iq_UDT_FIFOHeader,
	              iqv_DataBuffer := #iq_FIFOData);
	    
	    #sx_ReadBuffer := FALSE;
	    
	    //System status
	    #si_SystemStatus := (STRING_TO_INT(IN := (CHAR_TO_STRING(IN := #ss_UDT_MsgArray.Character[#Index_SystemStatus]))));
	    
	    //Package count
	    #si_PackageCount := (STRING_TO_INT(IN := (CHAR_TO_STRING(IN := #ss_UDT_MsgArray.Character[#Index_PackageCount]))));
	    
	    #tdi_CycleLenght := 0;
	    
	    FOR #si_Counter := 1 TO #si_PackageCount BY 1 DO
	        //get length from FIFO data and add to total length
	        
	        "FC_CharToInt"(Offset := (#Index_StartFirstLength + ((#si_Counter - 1) * 12)),
	                       Data := #ss_UDT_MsgArray,
	                       qi_data => #ti_Length);
	        
	        #sdi_Lenght := #sdi_Lenght + #ti_Length;
	        
	        #tdi_CycleLenght += #ti_Length;
	        
	    END_FOR;
	    
	    IF #iq_UDT_EquipmentControl.Command.ResetData
	    THEN
	        #sr_TotalAvgParcel := 0;
	    END_IF;
	    
	    #tr_CycleAvgParcels := (DINT_TO_REAL(#tdi_CycleLenght) / DINT_TO_REAL(#iq_UDT_ParcelData.AvgParcelLength));
	    
	    #sr_TotalAvgParcel += #tr_CycleAvgParcels;
	    
	    IF #sr_TotalAvgParcel < 0
	    THEN
	        #sr_TotalAvgParcel := 0;
	    END_IF;
	    
	    //get incremental sequence number
	    "FC_CharToInt"(Offset := #Index_IncSeqNr,
	                   Data := #ss_UDT_MsgArray,
	                   qi_data => #si_SeqNr);
	    
	    // when incremental sequence number changed, reset timer communication error
	    IF #si_SeqNr <> #si_SeqNrOld THEN
	        #slr_ComTimeOut := 0;
	        #sx_CommError := FALSE;
	        #si_SeqNrOld := #si_SeqNr;
	    END_IF;
	    
	END_IF;
	
	// Output flow count
	#q_di_FlowCount := TRUNC(#sr_TotalAvgParcel);
	
	//If time elapsed, store  NrOfParcelsinto DB_ParcelData
	#slr_Time := #slr_Time + "DB_Memory".PrevCycleTime;
	IF (#slr_Time > LINT_TO_REAL(IN := TIME_TO_LINT(IN := #iq_UDT_ParcelData.TimeReadMessages))) THEN
	    
	    // Shift Parcel data with 1 position  
	    MOVE_BLK(IN := #iq_UDT_ParcelData.NrOfParcels[1],
	             COUNT := 499,
	             OUT => #iq_UDT_ParcelData.NrOfParcels[2]);
	    
	    //calculate number of parcels and store in DB_ParcelData
	    #iq_UDT_ParcelData.NrOfParcels[1] := #sdi_Lenght / #iq_UDT_ParcelData.AvgParcelLength;
	    
	    //reset time and length
	    #slr_Time := 0.0;
	    #sdi_Lenght := 0;
	END_IF;
	
	//TimeOut Communication
	#slr_ComTimeOut := #slr_ComTimeOut + "DB_Memory".PrevCycleTime;
	IF (#slr_ComTimeOut > LINT_TO_REAL(IN := TIME_TO_LINT(IN := #iq_UDT_ParcelData.TimOutComm))) THEN
	    #sx_CommError := TRUE;
	    #slr_ComTimeOut := 0;
	END_IF;
	
	
	//Write Error Status
	#iq_UDT_EquipmentControl.Report.Error := #iq_UDT_EquipmentControl.Report.Error OR #sx_CommError;
	#qx_CommunicationError := #sx_CommError;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_UPS2ndStageFlowControl"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 47
// END_ATTRIBUTES
   VAR_INPUT 
      ix_LengthBased { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ix_ImperialLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ix_IncrementingCounts { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      idi_ParcelCountInfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //  Counter of parcels from infeed
      ix_ActiveInfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Infeed is running / active
   END_VAR

   VAR_OUTPUT 
      qx_New15SecInterval { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE = Indicates a new 15 Sec interval to partner PLC
      qx_LimitFlowInfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE = Stop infeed due flow control
      qdi_30secFlowInfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //  30 seconds pph rate
      qdi_1minFlowInfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //  1 minute pph rate
      qdi_3minFlowInfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //  3 minutes pph rate
      qdi_10minFlowInfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //  10 minutes pph rate
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";
      iq_InfeedArray : "UDT_UPSFlowRateCountingRegisters";   //  Array of line x
      iqUDT_FlowControlHMI : "UDT_UPSFlowControlHMI";
   END_VAR

   VAR 
      s_FB_Pulse_EndOf15sPeriod { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Pulse";   //  15 second pulse generator
      s_infeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //  Data of infeed line
         diCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //  Counter of parcels from infeed
         diLastScanCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //  Last scan counter of parcels from infeed
         diFlowRate30sec { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //  30sec pph rate
         diFlowRate1min { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //  1 min pph rate
         diFlowRate3min { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //  3 min pph rate
         diFlowRate10min { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //  10 min pph rate
         iNumberOfNewParcels { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Number of new parcels during this scan
         Active { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE = infeed is active
         RequestStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE= Request flow control
         OneShotRequestStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Rising edge request to stop
         DuringMinimumStopTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Infeed is stopped and the minimum stop time is not elapsed
      END_STRUCT;
      s_FB_MinStopTimeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //  Minimum stop time active
      sx_Disabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disabled from user
      sdi_CumulativeFlowRate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //  Cumulative flow rate 1min pph at evaluation point
      sdi_AverageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //  Average length
      si_LastLowPriority { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Pointer to the last low priority infeed
      si_limit { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Number of infeeds in use - uper limit for array
      si_CurrentConsecutivesAboveSP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Number of consecutive intervals  with flow above HMI set point
      si_CurrentConsecutivesBelowSP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Number of consecutive intervals with flow below HMI set point
      sx_StopRequested { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Any infeed requested to stop
   END_VAR

   VAR_TEMP 
      tr_quotient : Real;   //  Quotient of division
      tr_fraction : Real;   //  Return of fraction
      ti_buffer : Int;   //  Auxiliary buffer
      ti_LC_k : Int;
      ti_Index : Int;   //  temporaty index
      tx_End15sPeriod : Bool;   //  End of 15 seconds flow period
   END_VAR

   VAR CONSTANT 
      cdi_InchesAverageLength : DInt := DINT#20;   //  Average length in inches
      cdi_mmAverageLength : DInt := DINT#508;   //  Average length in mm
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2019             MHS                                                     |
	|  All Rights Reserved         Larenweg 90                                             |
	|                              5234 KC 's-Hertogenbosch,                               |
	|                              Netherlands                                             |
	|                                                                                      |
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	28/01/2020  | 3.0       | S.Theocharis | Initial version (Covnert from 1st stage)
	14/03/2024  | 4.1       | S.Nieswiec   | Added from Hannover project
	*)
	
	REGION 1 - Normalization and data move
	    
	    REGION 1.1 - Normalization
	        
	        IF #ix_LengthBased THEN
	            
	            IF #ix_ImperialLength THEN
	                #sdi_AverageLength := #cdi_InchesAverageLength;  // infeed count in inches
	            ELSE
	                #sdi_AverageLength := #cdi_mmAverageLength;       // infeed count in mm
	            END_IF;
	        ELSE
	            #sdi_AverageLength := L#1;                            // infeed count in parcels     
	        END_IF;
	        
	    END_REGION
	    
	    REGION 1.2 - Move Input data to static
	        //Move counters
	        #s_infeed.diCounter := #idi_ParcelCountInfeed;
	        
	        
	        //Move infeed active bit
	        #s_infeed.Active := #ix_ActiveInfeed;
	        
	        
	    END_REGION
	    
	END_REGION
	
	
	REGION 2 - End of 15s flow period
	    
	    // Calculate 15 seconds period
	    #s_FB_Pulse_EndOf15sPeriod(iudi_PulseTime := 15000,
	                               qx_Pulse => #tx_End15sPeriod);
	    
	END_REGION
	
	REGION 3 - Add number of parcels in the register
	    //Each Region is used for different configurations
	    
	    REGION 4.1 - When input counts are incrementing 
	        
	        IF #ix_IncrementingCounts THEN
	            
	            
	            
	            //calculate new parcels per infeed
	            IF #s_infeed.diCounter >= #s_infeed.diLastScanCounter THEN
	                //Parcels are incremented normaly
	                #s_infeed.iNumberOfNewParcels := DINT_TO_INT(#s_infeed.diCounter - #s_infeed.diLastScanCounter);
	                
	            ELSE
	                //Exception handling of parcel counter was reset in the partner PLC. Therefore for this scan we don't subtrack the ones of the previous scan
	                #s_infeed.iNumberOfNewParcels := DINT_TO_INT(#s_infeed.diCounter);
	            END_IF;
	            
	            //Move current counter at the static variable of the last scan
	            #s_infeed.diLastScanCounter := #s_infeed.diCounter;
	            
	            //add new parcels in the 1st register
	            #iq_InfeedArray.iCR[1] += (#s_infeed.iNumberOfNewParcels);
	        END_IF;
	        
	    END_REGION
	    
	    REGION 4.2 - When input counts are updated every 15 sec interval
	        //That logic here needs to be tested. There is a risk of loosing some parcels beacuse of the delay between the pLC to PLC communication.
	        
	        IF NOT #ix_IncrementingCounts AND #tx_End15sPeriod THEN
	            #iq_InfeedArray.iCR[1] := DINT_TO_INT(#s_infeed.diCounter);
	        END_IF;
	    END_REGION
	    
	END_REGION
	
	REGION 5 - Flow rate calculation
	    // The 15 second period has passed
	    IF (#tx_End15sPeriod) THEN
	        
	        
	        // Initialize static flow buffer
	        #s_infeed.diFlowRate30sec := L#0;
	        #s_infeed.diFlowRate1min := L#0;
	        #s_infeed.diFlowRate3min := L#0;
	        #s_infeed.diFlowRate10min := L#0;
	        
	        // Loop through 40 Counting Registers per infeed
	        FOR #ti_LC_k := 1 TO 40 DO
	            
	            // 30 sec flow handling
	            IF #ti_LC_k <= 2 THEN
	                #s_infeed.diFlowRate30sec += INT_TO_DINT(#iq_InfeedArray.iCR[#ti_LC_k]);
	                
	                // Conversion to full hour
	                IF #ti_LC_k = 2
	                THEN
	                    #s_infeed.diFlowRate30sec *= L#120;
	                    //Normalise
	                    #s_infeed.diFlowRate30sec /= #sdi_AverageLength;
	                    
	                END_IF;
	            END_IF;
	            
	            // 1 minute flow handling
	            IF #ti_LC_k <= 4 THEN
	                #s_infeed.diFlowRate1min += INT_TO_DINT(#iq_InfeedArray.iCR[#ti_LC_k]);
	                
	                // Conversion to full hour
	                IF #ti_LC_k = 4 THEN
	                    #s_infeed.diFlowRate1min *= L#60;
	                    //Normalise
	                    #s_infeed.diFlowRate1min /= #sdi_AverageLength;
	                END_IF;
	            END_IF;
	            
	            // 3 minutes flow handling
	            IF #ti_LC_k <= 12 THEN
	                #s_infeed.diFlowRate3min += INT_TO_DINT(#iq_InfeedArray.iCR[#ti_LC_k]);
	                
	                // Conversion to full hour
	                IF #ti_LC_k = 12 THEN
	                    #s_infeed.diFlowRate3min *= L#20;
	                    //Normalise
	                    #s_infeed.diFlowRate3min /= #sdi_AverageLength;
	                END_IF;
	            END_IF;
	            
	            // 10 minutes flow handling
	            #s_infeed.diFlowRate10min += INT_TO_DINT(#iq_InfeedArray.iCR[#ti_LC_k]);
	            
	            // Conversion to full hour
	            IF #ti_LC_k = 40
	            THEN
	                #s_infeed.diFlowRate10min *= L#6;
	                //Normalise
	                #s_infeed.diFlowRate10min /= #sdi_AverageLength;
	            END_IF;
	            
	        END_FOR;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Cumulative flow at evaluation point
	    
	    IF (#tx_End15sPeriod) THEN
	        
	        //initialise static variable
	        #sdi_CumulativeFlowRate := L#0;
	        
	        FOR #ti_LC_k := 1 TO 4 BY 1 DO
	            
	            #sdi_CumulativeFlowRate += INT_TO_DINT(#iq_InfeedArray.iCR[#ti_LC_k]);
	            
	        END_FOR;
	        
	        // Conversion to full hour
	        #sdi_CumulativeFlowRate *= L#60;
	        
	        //Normalise
	        #sdi_CumulativeFlowRate /= #sdi_AverageLength;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Shift arrays when 15s flow period ends
	    
	    // 15 seconds period elapsed 
	    IF (#tx_End15sPeriod) THEN
	        
	        // Shifted counting register by one element down
	        MOVE_BLK(IN := #iq_InfeedArray.iCR[1],
	                 COUNT := 59,
	                 OUT => #iq_InfeedArray.iCR[2]);
	        
	        // Reset first registter
	        #iq_InfeedArray.iCR[1] := 0;
	        
	        
	    END_IF;
	    
	END_REGION
	
	REGION 8 - Compare Current Value with Set Point
	    
	    IF (#tx_End15sPeriod) THEN
	        
	        IF #sdi_CumulativeFlowRate >= INT_TO_DINT(#iqUDT_FlowControlHMI.Setpoint) THEN
	            
	            #si_CurrentConsecutivesAboveSP += 1;  //increment consecutives above set point
	            #si_CurrentConsecutivesBelowSP := 0;  //reset consecutives below set point
	        ELSE
	            
	            #si_CurrentConsecutivesAboveSP := 0;  //reset consecutives above set point
	            #si_CurrentConsecutivesBelowSP += 1;  //increment consecutives below set point
	            
	            //limit consecutives below set point to threshold value. Protection against INT overflow
	            IF #si_CurrentConsecutivesBelowSP >= 3 THEN
	                
	                #si_CurrentConsecutivesBelowSP := 3;
	                
	            END_IF;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 9 - Evaluation - Apply flow control 
	    //The evaluation period is specified by UPS at 1min or 4 intervals of 15 seconds
	    
	    IF (#tx_End15sPeriod) AND #si_CurrentConsecutivesAboveSP > 0 THEN
	        
	        //divide  current consecutives above SP with the number of intervals for evaluation ,,
	        #tr_quotient := INT_TO_REAL(#si_CurrentConsecutivesAboveSP) / INT_TO_REAL(4);
	        
	        //call fraction to check the number of decimal places of the quotient
	        #tr_fraction := FRAC(#tr_quotient);
	        
	        //If there are no decimal places then the current consecutive above set point is multiple
	        //of the evaluation period. Therefore the evaluation of the flow control should take place.
	        IF #tr_fraction = 0.0 THEN
	            
	            
	            REGION 9.1 - Request stop to limit flow
	                
	                IF
	                    #s_infeed.Active                                      //infeed running / activated ..
	                    AND NOT #s_infeed.RequestStop                            // .. and not already stopped...
	                    AND NOT #s_infeed.DuringMinimumStopTime                  // .. and not during minimum time to stop
	                    
	                THEN
	                    #s_infeed.RequestStop := TRUE;
	                    #s_infeed.OneShotRequestStop := TRUE;
	                    //exit loop to stop one infeed every evaluation interval
	                END_IF;
	                
	            END_REGION
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 10 - Evaluation - Remove flow control
	    
	    IF (#tx_End15sPeriod) AND #si_CurrentConsecutivesBelowSP >= 3 THEN
	        #s_infeed.RequestStop := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 11  - Set minimum time of stopped time
	    //Set minimum time to stop 1min
	    #s_FB_MinStopTimeActive(iudi_OnDelayTime := 0,
	                            iudi_OffDelayTime := 60000,
	                            ix_SignalToDelay := #s_infeed.OneShotRequestStop,
	                            ix_Enable := TRUE,
	                            qx_DelayedSignal => #s_infeed.DuringMinimumStopTime);
	    
	    //reset one shot request to stop 
	    #s_infeed.OneShotRequestStop := FALSE;
	    
	    
	    
	END_REGION
	
	REGION 12 - HMI Enable / Disable
	    
	    //Command to disable frlow control from HMI
	    #sx_Disabled := #iqUDT_FlowControlHMI.CommandToDisable;
	    
	END_REGION
	
	REGION 12 - Ouput the request stop
	    
	    #qx_LimitFlowInfeed := (#s_infeed.RequestStop OR #s_infeed.DuringMinimumStopTime) AND NOT #sx_Disabled;
	    
	END_REGION
	
	REGION 13 - Output flow rates
	    
	    //Disabled status to HMI
	    #iqUDT_FlowControlHMI.DisabledStatus := #sx_Disabled;
	    
	    ///Output 15 Sec interval one shot
	    #qx_New15SecInterval := #tx_End15sPeriod;
	    
	    //Cumulative
	    #iqUDT_FlowControlHMI.CalculatedFlow := DINT_TO_INT(#sdi_CumulativeFlowRate);
	    
	    //Infeed 1
	    #qdi_30secFlowInfeed := (#s_infeed.diFlowRate30sec);
	    #qdi_1minFlowInfeed := (#s_infeed.diFlowRate1min);
	    #qdi_3minFlowInfeed := (#s_infeed.diFlowRate3min);
	    #qdi_10minFlowInfeed := (#s_infeed.diFlowRate10min);
	    
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_UPSDecode"
TITLE = FB_Decode
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : UPS_SpecificCommunication
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 52
// END_ATTRIBUTES
//Function block to decode UPS messages.
   VAR_INPUT 
      iUDT_UPSMsgHeader { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_UPSMessageHeader";   // Structure with names and IP addresses of devices
      ix_ConEstablished { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TCPIP communication established
      ix_HeartbeatOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat ok input
      ix_ResetData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset statistics
      iudi_HBTimeout { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // HB timeout [ms]
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective error output
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective warning output
      qx_HBNotOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // HB not ok output
   END_VAR

   VAR_IN_OUT 
      iqUDT_FifoRcvHeader : "UDT_FifoHeader";   // FIFO receive header
      iqUDT_FifoSendHeader : "UDT_FifoHeader";   // FIFO send header
      iqUDT_MSGIDCounters : "UDT_UPSMSGIDCounters";   // Message ID counters
      iqUDT_Statistic : "UDT_UPSDecodeStatistics";   // Statistic structure
      iqa_FifoRcvData : Array[*] of "UDT_Message";   // FIFO receive data
      iqa_FifoSendData : Array[*] of "UDT_Message";   // FIFO send data
      iqa_ExternalReaders : Array[*] of "UDT_UPSExternalReader";   // External readers structure
      iqx_HeartBeat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat message detect
   END_VAR

   VAR 
      sFB_Acknowledge { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_UPSAcknowledge";   // Acknowlage function
      sFB_Timer_HBCheck { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // MHS "FB_TimerOnOffDelay" - to measure the time of missing HB
      sR_TRIG_EnableMonitoring {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Siemens "R_TRIG" - to prepare the rising edge trigger on "ix_HBEnableMonitoring" signal
      sF_TRIG_HBCheck {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Siemens "F_TRIG" - to prepare the falling edge trigger on "sx_HBCheck" signal
      sUDT_SortedMsg { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_UPSMessage";   // Buffer for sorted message
      sUDT_FifoMsg { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Message";   // Buffer for fifos message
      sa_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         BadMessage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..10] of "UDT_Message";   //   Unknown message read
         FIFORcvStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";   //   Receive FIFO status structure
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //   FIFO error
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //   FIFO warning
         AcknowledgeError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //   Acknowledge error
         AcknowledgeWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //   Acknowledge warning
         HB_NotOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Health bit not OK
      END_STRUCT;
      sw_CameraState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Camera state word
      sw_DWSState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // DWS state word
      susi_PackageNr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Unique ID of package
      si_RingBufferNr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 1;   // Bad messages ringbuffer counter
      sx_HB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // HB message detect
      sx_HBCheck { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // HB check
      sx_InvalidTimeout { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid HB timeout
   END_VAR

   VAR_TEMP 
      ti_j : Int;   // Loop counter
      ti_k : Int;   // Loop counter
      ti_i : Int;   // Loop counter
      ti_ClearOther : Int;   // Elements to clear
      ti_Position : Int;   // Temporary position parial message
      ti_NrOfDataBuffer : Int;   // Number of data buffer
      ti_NrOfMessageChar : Int;   // Length of FIFO message
      ti_DestBuffSize : Int;   // Length of array with package destinations
      ti_Dest : Int;   // Temporary destination
      ti_NumberOfGinElements : Int;   // Size of GIN buffer
      ti_ack : Int;   // Place of 'ACK' in message
      ti_BadMsgSize : Int;   // Bad message buffer size
      tui_Length : UInt;   // Length of partial message
      tx_EndMessage : Bool;   // End message mark detected
      tx_MsgRead : Bool;   // Message read from FIFO
      tx_HealthMsgError : Bool;   // Health message error
      tx_SD2Error : Bool;   // ScanData2 message statistic required
      tx_AckRequired : Bool;   // Message required ACK
      tx_InvalidHeader : Bool;   // Invalid header
      tx_DataRequired : Bool;   // Data need to be read
      tx_InvalidMessage : Bool;   // Invalid message
      tx_InvalidMessageType : Bool;   // Message type invalid
   END_VAR

   VAR CONSTANT 
      cc_NULL : Char := '$00';   // NULL sign
      cc_DL : Char := ',';   // Comma sign
      cs_HB : String := 'HB';   // "HB" message type
      cs_HEARTBEAT : String := 'HEARTBEAT';   // "HEARTBEAT" message type
      cs_SORT : String := 'SORT';   // "SORT" message type
      cs_SCANDATA2 : String := 'SCAN_DATA2';   // "SCANDATA2" message type
      cs_HEALTH : String := 'HEALTH';   // "HEALTH" message type
      cs_DIRECTIVE : String := 'DIRECTIVE';   // "HEALTH" message type
      cs_OF : String := 'OF';   // "HEALTH" message type
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | K.Pokorski    | first release MHS TIA 15.1
	27/06/2019  | 0.4       | A.Nowak       | change 'and' for 'or' in status region 13
	17/07/2019  | 0.5       | L.Klar        | Status handling changed
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	23/08/2019  | 2.1       | K.Pokorski    | Comments adjusted
	11/09/2019  | 2.2       | K.Pokorski    | Statistics handling and MT decoding edited
	19/09/2019  | 2.3       | A.Nowak       | Correct comments, allign code to line, merge regions 5,6,7. Renumber regions.
	26/09/2019  | 2.4       | P.Majka       | Implementing HB logic - added Region 6
	01/10/2019  | 2.5       | A.Nowak       | Implementation of the new FIFO block
	20/11/2019  | 2.6       | L.Klar        | Header verifiction corrected
	20/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	08/01/2020  | 3.1       | L.Klar        | SORT message handling changed
	13/01/2020  | 3.2       | K.Pokorski    | Messages acknowledge added/ MSGID counter added
	16/07/2020  | 3.3       | L.Klar        | New FC_Health and scandata2 block calls, input for external readers added
	07/10/2020  | 3.4       | L.Klar        | Health message acnowledge removed
	22/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #sa_Status.FIFORcvStatus,
	              qx_Error => #sa_Status.FIFOError,
	              qx_Warning => #sa_Status.FIFOWarning,
	              iqv_Data := #sUDT_FifoMsg,
	              iqUDT_FifoHeader := #iqUDT_FifoRcvHeader,
	              iqv_DataBuffer := #iqa_FifoRcvData);
	    
	    IF (NOT #iqUDT_FifoRcvHeader.Status.Empty                             // FIFO not empty 
	        AND NOT #sa_Status.FIFOError)                                      // No FIFO error 
	    THEN
	        
	        // Mode 'R' - Read FIFO record
	        "FC_Fifo"(ic_Mode := 'R',
	                  qUDT_Status => #sa_Status.FIFORcvStatus,
	                  qx_Error => #sa_Status.FIFOError,
	                  qx_Warning => #sa_Status.FIFOWarning,
	                  iqv_Data := #sUDT_FifoMsg,
	                  iqUDT_FifoHeader := #iqUDT_FifoRcvHeader,
	                  iqv_DataBuffer := #iqa_FifoRcvData);
	        
	        // Message read bit set and position initialize 
	        #tx_MsgRead := TRUE;
	        #ti_Position := 0;
	        
	        // FIFO empty or FIFO error occured      
	    ELSE
	        
	        #tx_MsgRead := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 – Header separation and correctness 
	    
	    IF (#tx_MsgRead)                                                  // Message read from FIFO
	    THEN
	        
	        // SCN
	        "FC_SeparateMsg"(iUDT_Message := #sUDT_FifoMsg,             // Separating the sender client name from a message
	                         ic_Delimiter := #cc_DL,
	                         ic_EndSign := #cc_NULL,
	                         qs_Msg => #sUDT_SortedMsg.SCN,
	                         qx_EndMsg => #tx_EndMessage,
	                         ii_Position := #ti_Position,
	                         qui_Length => #tui_Length,
	                         qx_NoSeparationSign => #tx_InvalidMessage);
	        
	        // Signal an error 
	        IF (#tx_InvalidMessage)                                          // Message is invalid 
	        THEN
	            
	            #tx_InvalidHeader := TRUE;
	            
	            // No error occured, calculate the next message part position offset
	        ELSE
	            
	            #tx_InvalidHeader := FALSE;
	            #ti_Position += UINT_TO_INT(#tui_Length) + 1;
	            
	        END_IF;
	        
	        // SCT
	        IF (NOT #tx_InvalidHeader)                                              // Header is valid
	        THEN
	            
	            "FC_SeparateMsg"(iUDT_Message := #sUDT_FifoMsg,             // Separating the sender client type from a message
	                             ic_Delimiter := #cc_DL,
	                             ic_EndSign := #cc_NULL,
	                             qs_Msg => #sUDT_SortedMsg.SCT,
	                             qx_EndMsg => #tx_EndMessage,
	                             ii_Position := #ti_Position,
	                             qui_Length => #tui_Length,
	                             qx_NoSeparationSign => #tx_InvalidMessage);
	            
	            // Signal an error    
	            IF (#tx_InvalidMessage)                                         // Message is invalid 
	            THEN
	                
	                #tx_InvalidHeader := TRUE;
	                
	                // No error occured, calculate the next message part position offset
	            ELSE
	                
	                #ti_Position += UINT_TO_INT(#tui_Length) + 1;
	                
	            END_IF;
	            
	        END_IF;
	        
	        // RCN
	        IF (NOT #tx_InvalidHeader)                                              // Header is valid
	        THEN
	            
	            "FC_SeparateMsg"(iUDT_Message := #sUDT_FifoMsg,             // Separating the receiver client name from a message
	                             ic_Delimiter := #cc_DL,
	                             ic_EndSign := #cc_NULL,
	                             qs_Msg => #sUDT_SortedMsg.RCN,
	                             qx_EndMsg => #tx_EndMessage,
	                             ii_Position := #ti_Position,
	                             qui_Length => #tui_Length,
	                             qx_NoSeparationSign => #tx_InvalidMessage);
	            
	            // Signal an error    
	            IF (#tx_InvalidMessage)                                          // Message is invalid 
	            THEN
	                
	                #tx_InvalidHeader := TRUE;
	                
	                // No error occured, calculate the next message part position offset    
	            ELSE
	                
	                #ti_Position += UINT_TO_INT(#tui_Length) + 1;
	                
	            END_IF;
	            
	        END_IF;
	        
	        // RCT
	        IF (NOT #tx_InvalidHeader)                                               // Header is valid
	        THEN
	            
	            "FC_SeparateMsg"(iUDT_Message := #sUDT_FifoMsg,              // Separating the receiver client type from a message
	                             ic_Delimiter := #cc_DL,
	                             ic_EndSign := #cc_NULL,
	                             qs_Msg => #sUDT_SortedMsg.RCT,
	                             qx_EndMsg => #tx_EndMessage,
	                             ii_Position := #ti_Position,
	                             qui_Length => #tui_Length,
	                             qx_NoSeparationSign => #tx_InvalidMessage);
	            
	            // Signal an error     
	            IF (#tx_InvalidMessage)                                          // Message is invalid
	            THEN
	                
	                #tx_InvalidHeader := TRUE;
	                
	                // No error occured, calculate the next message part position offset     
	            ELSE
	                
	                #ti_Position += UINT_TO_INT(#tui_Length) + 1;
	                
	            END_IF;
	            
	        END_IF;
	        
	        // MT
	        IF (NOT #tx_InvalidHeader)                                               // Header is valid
	        THEN
	            
	            "FC_SeparateMsg"(iUDT_Message := #sUDT_FifoMsg,              // Separating the message type from a message
	                             ic_Delimiter := #cc_DL,
	                             ic_EndSign := #cc_NULL,
	                             qs_Msg => #sUDT_SortedMsg.MT,
	                             qx_EndMsg => #tx_EndMessage,
	                             ii_Position := #ti_Position,
	                             qui_Length => #tui_Length,
	                             qx_NoSeparationSign => #tx_InvalidMessage);
	            
	            // Message is invalid
	            IF (#tx_InvalidMessage)
	            THEN
	                
	                #tx_InvalidHeader := TRUE;
	                
	                // No error occured, calculate the next message part position offset    
	            ELSE
	                
	                #ti_Position += UINT_TO_INT(#tui_Length) + 1;
	                
	            END_IF;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 – Message type (MT) decoding
	    
	    // Message is read and header is valid 
	    IF (NOT #tx_InvalidHeader
	        AND #tx_MsgRead)
	    THEN
	        
	        // Looking for 'ACK' in message type
	        #ti_ack := FIND(IN1 := #sUDT_SortedMsg.MT, IN2 := 'ACK');  // Find server's acknowledge message type 
	        
	        
	        // Message type validation
	        #tx_InvalidMessageType :=
	        (#sUDT_SortedMsg.MT <> #cs_HB
	        AND #sUDT_SortedMsg.MT <> #cs_HEALTH
	        AND #sUDT_SortedMsg.MT <> #cs_HEARTBEAT
	        AND #sUDT_SortedMsg.MT <> #cs_SCANDATA2
	        AND #sUDT_SortedMsg.MT <> #cs_SORT
	        AND #sUDT_SortedMsg.MT <> #cs_DIRECTIVE
	        AND #ti_ack = 0);
	        
	        // Read data required for all message except Heartbeat and HB
	        #tx_DataRequired :=
	        (#sUDT_SortedMsg.MT <> #cs_HEARTBEAT)
	        AND (#sUDT_SortedMsg.MT <> #cs_HB
	        AND #ti_ack = 0
	        AND NOT #tx_InvalidMessageType);
	        
	        // Only for heartbeat message acknowledge is not required, for other message acknowledge is required.
	        #tx_AckRequired :=
	        (#sUDT_SortedMsg.MT <> #cs_HEARTBEAT
	        AND #sUDT_SortedMsg.MT <> #cs_HEALTH)
	        AND #ti_ack = 0
	        AND NOT #tx_InvalidMessageType;
	        
	    ELSE
	        
	        #tx_AckRequired := FALSE;
	        #tx_InvalidMessageType := FALSE;
	        
	    END_IF;
	    
	    
	END_REGION
	
	REGION 4 – Read data    
	    
	    // Data read required
	    IF (#tx_DataRequired
	        AND NOT #tx_InvalidHeader
	        AND NOT #tx_InvalidMessageType)
	    THEN
	        
	        #ti_NrOfDataBuffer := "FC_GetNrOfArrayEl"(#sUDT_SortedMsg.Data);
	        
	        // Separating message fields
	        FOR #ti_j := 1 TO #ti_NrOfDataBuffer DO
	            
	            "FC_SeparateMsg"(iUDT_Message := #sUDT_FifoMsg,
	                             ic_Delimiter := #cc_DL,
	                             ic_EndSign := #cc_NULL,
	                             qs_Msg => #sUDT_SortedMsg.Data[#ti_j],
	                             qx_EndMsg => #tx_EndMessage,
	                             ii_Position := #ti_Position,
	                             qui_Length => #tui_Length,
	                             qx_NoSeparationSign => #tx_InvalidMessage);
	            
	            // Next field position offset
	            #ti_Position += UINT_TO_INT(#tui_Length) + 1;
	            
	            // Filling up not used message array elements with ''
	            IF (#tx_EndMessage                                                          // End message mark detected
	                AND #ti_j < #ti_NrOfDataBuffer)                                         // Loop counter lower than number of data buffer
	            THEN
	                
	                // Calculating elements to clear 
	                #ti_ClearOther := #ti_j + 1;
	                
	                FOR #ti_k := #ti_ClearOther TO #ti_NrOfDataBuffer DO
	                    
	                    IF (#sUDT_SortedMsg.Data[#ti_k] = '')                              // Message buffer is cleared
	                    THEN
	                        
	                        EXIT;
	                        
	                    END_IF;
	                    
	                    #sUDT_SortedMsg.Data[#ti_k] := '';                                 // Clear unused message buffer
	                    
	                END_FOR;
	                
	                EXIT;
	                
	            END_IF;
	            
	        END_FOR;
	        
	        #tx_DataRequired := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 5 – Message handling
	    
	    // If the message is read and header is valid, handle message according to the type 
	    IF (NOT #tx_InvalidHeader
	        AND #tx_MsgRead)
	    THEN
	        
	        // Set HB bit if HB message is received
	        IF (#sUDT_SortedMsg.MT = #cs_HB)
	        THEN
	            
	            #sx_HB := TRUE;
	            
	            IF (#iqUDT_MSGIDCounters.HB < 2147483647)     // Unique message ID is lower than 2147483647                              
	            THEN
	                
	                #iqUDT_MSGIDCounters.HB += 1;
	                
	            ELSE
	                
	                #iqUDT_MSGIDCounters.HB := 0;
	                
	            END_IF;
	            
	        END_IF;
	        
	        // Set heartbeat bit if the Heartbeat message is received 
	        IF (#sUDT_SortedMsg.MT = #cs_HEARTBEAT)
	        THEN
	            
	            #iqx_HeartBeat := TRUE;
	            
	        END_IF;
	        
	        // Sort message received
	        IF (#sUDT_SortedMsg.MT = #cs_SORT)
	        THEN
	            
	            STRG_VAL(IN := MID(IN := #sUDT_SortedMsg.Data[2], L := 4, P := 3),         // Extract parcel PLCID from PKGUID field
	                     FORMAT := 16#0,
	                     P := 1,
	                     OUT => #susi_PackageNr);
	            
	            #ti_NumberOfGinElements := "FC_GetNrOfArrayEl"("DB_GIN".GIN);                   // Maximum number of GIN elements
	            
	            // Filing up the GIN record informations
	            IF (#susi_PackageNr >= 1
	                AND #susi_PackageNr <= #ti_NumberOfGinElements)
	            THEN
	                
	                "DB_GIN".GIN[#susi_PackageNr].UPS.MSGID := #sUDT_SortedMsg.Data[1];                                        // Sort MSGID
	                "DB_GIN".GIN[#susi_PackageNr].UPS.PKGUID := #sUDT_SortedMsg.Data[2];                                       // Sort PKGUID
	                "DB_GIN".GIN[#susi_PackageNr].UPS.TRKNUM := #sUDT_SortedMsg.Data[3];                                       // Sort TRKNUM
	                #ti_DestBuffSize := "FC_GetNrOfArrayEl"(iv_Array := "DB_GIN".GIN[#susi_PackageNr].General.Destination);     // Sort DEST
	                
	                // Move all parcel destionation to "DB_GIN"
	                FOR #ti_i := 5 TO #ti_DestBuffSize DO
	                    
	                    // The destination field has ended
	                    IF (#sUDT_SortedMsg.Data[#ti_i] = '')
	                    THEN
	                        
	                        EXIT;
	                        
	                    END_IF;
	                    
	                    // Convert destination from string to integer 
	                    STRG_VAL(IN := #sUDT_SortedMsg.Data[#ti_i],
	                             FORMAT := 16#0,
	                             P := 1,
	                             OUT => #ti_Dest);
	                    
	                    
	                    "DB_GIN".GIN[#susi_PackageNr].General.Destination[#ti_i - 5] := #ti_Dest;                               // Save currect destination to "DB_GIN"
	                    
	                END_FOR;
	                
	                // Destination recieved 
	                "DB_GIN".GIN[#susi_PackageNr].General.DestRcv := "DB_GIN".GIN[#susi_PackageNr].General.Destination[0] <> 0;
	                
	                // Write received parcel dimensions parameters to a GIN record (Sort DIMS)
	                STRG_VAL(IN := MID(IN := #sUDT_SortedMsg.Data[4], L := 4, P := 3),
	                         FORMAT := 0,
	                         P := 1,
	                         OUT => "DB_GIN".GIN[#susi_PackageNr].UPS.Length);
	                
	                STRG_VAL(IN := MID(IN := #sUDT_SortedMsg.Data[4], L := 4, P := 7),
	                         FORMAT := 0,
	                         P := 1,
	                         OUT => "DB_GIN".GIN[#susi_PackageNr].UPS.Width);
	                ;
	                
	                STRG_VAL(IN := MID(IN := #sUDT_SortedMsg.Data[4], L := 4, P := 11),
	                         FORMAT := 0,
	                         P := 1,
	                         OUT => "DB_GIN".GIN[#susi_PackageNr].UPS.Height);
	                
	                STRG_VAL(IN := MID(IN := #sUDT_SortedMsg.Data[4], L := 4, P := 16),
	                         FORMAT := 0,
	                         P := 1,
	                         OUT => "DB_GIN".GIN[#susi_PackageNr].UPS.Weight);
	                
	                // Convert value of weight
	                "DB_GIN".GIN[#susi_PackageNr].General.Weight := "DB_GIN".GIN[#susi_PackageNr].General.Weight * 100;
	                
	                // Dimensions recieved
	                "DB_GIN".GIN[#susi_PackageNr].UPS.DimDataRcv := "DB_GIN".GIN[#susi_PackageNr].General.Length <> 0
	                AND "DB_GIN".GIN[#susi_PackageNr].General.Width <> 0
	                AND "DB_GIN".GIN[#susi_PackageNr].General.Height <> 0
	                AND "DB_GIN".GIN[#susi_PackageNr].General.Weight <> 0;
	                
	                
	                // Set invalid header error when PLCID is invalid
	            ELSE
	                
	                #tx_InvalidHeader := TRUE;
	                
	            END_IF;
	            
	            // Unique message ID incrementation
	            IF (#iqUDT_MSGIDCounters.SORT < 2147483647)     // Unique message ID is lower than 2147483647                              
	            THEN
	                
	                #iqUDT_MSGIDCounters.SORT += 1;
	                
	            ELSE
	                
	                #iqUDT_MSGIDCounters.SORT := 0;
	                
	            END_IF;
	            
	        END_IF;
	        
	        // ScanData2 message received 
	        IF (#sUDT_SortedMsg.MT = #cs_SCANDATA2)
	        THEN
	            
	            "FC_UPSScanData2"(iUDT_Message := #sUDT_SortedMsg,
	                              qx_Error => #tx_SD2Error,
	                              iqa_ExternalReaders := #iqa_ExternalReaders);
	            
	            // ScanData2 message statistic required
	            IF #tx_SD2Error
	            THEN
	                
	                #tx_InvalidHeader := TRUE;
	                #tx_AckRequired := FALSE;
	                
	            END_IF;
	            
	        END_IF;
	        
	        // Health message received
	        IF (#sUDT_SortedMsg.MT = #cs_HEALTH)
	        THEN
	            
	            "FC_UPSHealth"(iUDT_Message := #sUDT_SortedMsg,
	                           qx_Error => #tx_HealthMsgError,
	                           iqa_ExternalReaders := #iqa_ExternalReaders);
	            
	            
	            // Health message statistic required
	            IF (#tx_HealthMsgError)
	            THEN
	                
	                #tx_InvalidHeader := TRUE;
	                #tx_AckRequired := FALSE;
	                
	            END_IF;
	            
	        END_IF;
	        
	        // Health message received
	        IF (#sUDT_SortedMsg.MT = #cs_DIRECTIVE)
	        THEN
	            
	            STRG_VAL(IN := MID(IN := #sUDT_SortedMsg.Data[3], L := 4, P := 3),         // Extract parcel PLCID from PKGUID field
	                     FORMAT := 16#0,
	                     P := 1,
	                     OUT => #susi_PackageNr);
	            
	            #ti_NumberOfGinElements := "FC_GetNrOfArrayEl"("DB_GIN".GIN);                   // Maximum number of GIN elements
	            
	            // Filing up the GIN record informations
	            IF (#susi_PackageNr >= 1
	                AND #susi_PackageNr <= #ti_NumberOfGinElements)
	            THEN
	                
	                IF #sUDT_SortedMsg.Data[2] = #cs_OF THEN
	                    "DB_GIN".GIN[#susi_PackageNr].UPS.ThreatParcel := TRUE;
	                END_IF;
	                
	                #tx_AckRequired := TRUE;
	                
	                // Set invalid header error when PLCID is invalid
	            ELSE
	                
	                #tx_InvalidHeader := TRUE;
	                
	            END_IF;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 6 – HB message
	    
	    //HB timeout validation
	    #sx_InvalidTimeout := #iudi_HBTimeout <= 0;
	    
	    //HB monitoring if timeout correct
	    IF (NOT #sx_InvalidTimeout)
	    THEN
	        
	        // Making rising edge trigger for HB enable monitoring
	        #sR_TRIG_EnableMonitoring(CLK := #ix_ConEstablished AND #ix_HeartbeatOk);
	        
	        // HB monitoring if HB monitoring enabled
	        IF (#ix_ConEstablished
	            AND #ix_HeartbeatOk)
	        THEN
	            
	            // Resetting HB not OK status bit when HB message received
	            IF #sx_HB
	            THEN
	                
	                #sa_Status.HB_NotOK := FALSE;
	                
	            END_IF;
	            
	            // Measure the time of a missing HB triggered by HB recived or enable trigger
	            #sFB_Timer_HBCheck(ix_SignalToDelay := #sx_HB OR #sR_TRIG_EnableMonitoring.Q,
	                               iudi_OnDelayTime := 0,
	                               iudi_OffDelayTime := #iudi_HBTimeout,
	                               qx_DelayedSignal => #sx_HBCheck);
	            
	            // Resetting HB message received
	            #sx_HB := FALSE;
	            
	            // Making falling edge triffer for HB check signal
	            #sF_TRIG_HBCheck(CLK := #sx_HBCheck);
	            
	            // Incrementing HB statistics and setting HB not OK  
	            IF #sF_TRIG_HBCheck.Q                                                              // HB message not checked trigger
	            THEN
	                
	                #sa_Status.HB_NotOK := TRUE;
	                #iqUDT_Statistic.HBNotObserved += 1;
	                
	            END_IF;
	            
	        ELSE
	            
	            // Resetting HB not OK status bit when HB monitoring is disabled
	            #sa_Status.HB_NotOK := FALSE;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 7 – Send Ack 
	    
	    // Received message require ACK
	    IF (#tx_AckRequired)
	    THEN
	        
	        #sFB_Acknowledge(iUDT_Message := #sUDT_SortedMsg,
	                         qx_Error => #sa_Status.AcknowledgeError,
	                         qx_Warning => #sa_Status.AcknowledgeWarning,
	                         iqUDT_FifoHeader := #iqUDT_FifoSendHeader,
	                         iqa_FifoData := #iqa_FifoSendData);
	        
	        #tx_AckRequired := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 8 – Statistic update
	    
	    // Error statistics update required 
	    IF (#tx_InvalidHeader
	        OR #tx_InvalidMessageType)
	        AND #tx_MsgRead
	    THEN
	        
	        #iqUDT_Statistic.InvalidMsg += 1;                                  // Invalid message received counter incrementation
	        
	        // Maximum number of bad messages array
	        #ti_BadMsgSize := "FC_GetNrOfArrayEl"(#sa_Status.BadMessage);
	        
	        // Writing invalid message in a bad message array
	        IF (#si_RingBufferNr >= #ti_BadMsgSize)
	        THEN
	            
	            #si_RingBufferNr := 1;
	            
	        END_IF;
	        
	        #ti_NrOfMessageChar := "FC_GetNrOfArrayEl"(iv_Array := #sUDT_FifoMsg.Character);
	        
	        MOVE_BLK(IN := #sUDT_FifoMsg.Character[0],
	                 COUNT := INT_TO_UINT(#ti_NrOfMessageChar) - 1,
	                 OUT => #sa_Status.BadMessage[#si_RingBufferNr].Character[0]);
	        
	        #si_RingBufferNr += 1;
	        
	    END_IF;
	    
	    //Resetting statistics
	    IF (#ix_ResetData)
	    THEN
	        
	        #iqUDT_Statistic.InvalidMsg := 0;
	        #iqUDT_Statistic.HBNotObserved := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 9 – Reset message type
	    
	    #sUDT_SortedMsg.MT := '';
	    
	END_REGION
	
	REGION 10 – Status
	    
	    // Collective error output
	    #qx_Error :=
	    #sa_Status.FIFOError                                // FIFO error 
	    OR #sa_Status.AcknowledgeError                      // Acknowledge block error
	    OR (#ix_ConEstablished                          // HB monitoring enabled
	    AND #sa_Status.HB_NotOK)                            // HB not OK
	    OR #sx_InvalidTimeout;                              // Invalid timeout
	    
	    
	    // Collective warning output
	    #qx_Warning :=
	    #sa_Status.FIFOWarning                              // FIFO warning
	    OR #sa_Status.AcknowledgeWarning;                   // Acknowledge block warning
	    
	    // HB error
	    #qx_HBNotOk := #sa_Status.HB_NotOK;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_UPSChatStatistics"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 50
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_MSGIDCounters { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_UPSMSGIDCounters";   // MSGID counters structure
      ix_CommunicationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE if communication error
      ix_LostChatConnection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE if communication with chat is broken
      ix_LostXLeConnection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE if communication with XLe is broken
      ix_LostCardCommunication { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE if communication with card is broken
   END_VAR

   VAR_IN_OUT 
      iqUDT_ChatStatistics : "UDT_UPSChatStatistics";   // Chat statistics structure
      iqUDT_EquipmentControl : "UDT_EquipmentControl";
   END_VAR

   VAR 
      sUDT_MSGIDCounters { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_UPSMSGIDCounters";   // Auxiliary MSGID counter structure
      sR_TRIG_LostChatConn {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rise trigger when a chat fault occurs
      sR_TRIG_LostXLeConn {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rise trigger when a XLe fault occurs
      sR_TRIG_LostCardComm {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rise trigger when a card fault occurs
      sR_TRIG_CommError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rise trigger when a communication fault occurs
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	14/01/2019  | 3.0       | K.Pokorski    | 3.0 MHS library release TIA 15.1
	22/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - First scan
	    
	    // Move actual MSGID counter to static structure during first PLC scan
	    IF "DB_Memory".FirstScan THEN
	        
	        #sUDT_MSGIDCounters := #iUDT_MSGIDCounters;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Reset messages statistics
	    
	    // Reset all messages statistics when reset data bit available 
	    IF #iqUDT_EquipmentControl.Command.ResetData THEN
	        
	        #iqUDT_ChatStatistics.HB := 0;
	        #iqUDT_ChatStatistics.Heartbeat := 0;
	        #iqUDT_ChatStatistics.IDFWD := 0;
	        #iqUDT_ChatStatistics.PLCINFO := 0;
	        #iqUDT_ChatStatistics.PLCMsg := 0;
	        #iqUDT_ChatStatistics.SORT := 0;
	        #iqUDT_ChatStatistics.SORTCONF := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Statistics
	    
	    // If Heartbeat message's MSGID was change, update statistic
	    IF #sUDT_MSGIDCounters.Heartbeat <> #iUDT_MSGIDCounters.Heartbeat
	    THEN
	        
	        // Increase heartbeat statistics if are in DInt range
	        IF (#iqUDT_ChatStatistics.Heartbeat < 2147483647)
	        THEN
	            
	            #iqUDT_ChatStatistics.Heartbeat += 1;
	            // Update static MSGID counter
	            #sUDT_MSGIDCounters.Heartbeat := #iUDT_MSGIDCounters.Heartbeat;
	            
	            // Start statistics from 0 if are out of DInt range    
	        ELSE
	            
	            #iqUDT_ChatStatistics.Heartbeat := 0;
	            // Update static MSGID counter
	            #sUDT_MSGIDCounters.Heartbeat := #iUDT_MSGIDCounters.Heartbeat;
	            
	        END_IF;
	        
	    END_IF;
	    
	    // If IDFWD message's MSGID was change, update statistic
	    IF #sUDT_MSGIDCounters.IDFWD <> #iUDT_MSGIDCounters.IDFWD
	    THEN
	        
	        // Increase IDFWD statistics if are in DInt range
	        IF (#iqUDT_ChatStatistics.IDFWD < 2147483647)
	        THEN
	            
	            #iqUDT_ChatStatistics.IDFWD += 1;
	            // Update static MSGID counter
	            #sUDT_MSGIDCounters.IDFWD := #iUDT_MSGIDCounters.IDFWD;
	            
	            // Start statistics from 0 if are out of DInt range 
	        ELSE
	            
	            #iqUDT_ChatStatistics.IDFWD := 0;
	            // Update static MSGID counter
	            #sUDT_MSGIDCounters.IDFWD := #iUDT_MSGIDCounters.IDFWD;
	            
	        END_IF;
	        
	    END_IF;
	    
	    // If PLCINFO message's MSGID was change, update statistic
	    IF #sUDT_MSGIDCounters.PLCINFO <> #iUDT_MSGIDCounters.PLCINFO
	    THEN
	        
	        // Increase PLCINFO statistics if are in DInt range
	        IF (#iqUDT_ChatStatistics.PLCINFO < 2147483647)
	        THEN
	            
	            #iqUDT_ChatStatistics.PLCINFO += 1;
	            // Update static MSGID counter
	            #sUDT_MSGIDCounters.PLCINFO := #iUDT_MSGIDCounters.PLCINFO;
	            
	            // Start statistics from 0 if are out of DInt range 
	        ELSE
	            
	            #iqUDT_ChatStatistics.PLCINFO := 0;
	            // Update static MSGID counter
	            #sUDT_MSGIDCounters.PLCINFO := #iUDT_MSGIDCounters.PLCINFO;
	            
	        END_IF;
	        
	    END_IF;
	    
	    
	    // If SORT message's MSGID was change, update statistic
	    IF #sUDT_MSGIDCounters.SORT <> #iUDT_MSGIDCounters.SORT
	    THEN
	        
	        // Increase SORT statistics if are in DInt range
	        IF (#iqUDT_ChatStatistics.SORT < 2147483647)
	        THEN
	            
	            #iqUDT_ChatStatistics.SORT += 1;
	            // Update static MSGID counter
	            #sUDT_MSGIDCounters.SORT := #iUDT_MSGIDCounters.SORT;
	            
	            // Start statistics from 0 if are out of DInt range 
	        ELSE
	            
	            #iqUDT_ChatStatistics.SORT := 0;
	            // Update static MSGID counter
	            #sUDT_MSGIDCounters.SORT := #iUDT_MSGIDCounters.SORT;
	            
	        END_IF;
	        
	    END_IF;
	    
	    // If SORTCONF message's MSGID was change, update statistic
	    IF #sUDT_MSGIDCounters.SORTCONF <> #iUDT_MSGIDCounters.SORTCONF
	    THEN
	        
	        // Increase SORTCONF statistics if are in DInt range
	        IF (#iqUDT_ChatStatistics.SORTCONF < 2147483647)
	        THEN
	            
	            #iqUDT_ChatStatistics.SORTCONF += 1;
	            // Update static MSGID counter
	            #sUDT_MSGIDCounters.SORTCONF := #iUDT_MSGIDCounters.SORTCONF;
	            
	            // Start statistics from 0 if are out of DInt range 
	        ELSE
	            
	            #iqUDT_ChatStatistics.SORTCONF := 0;
	            // Update static MSGID counter
	            #sUDT_MSGIDCounters.SORTCONF := #iUDT_MSGIDCounters.SORTCONF;
	            
	        END_IF;
	        
	    END_IF;
	    
	    // If HB message's MSGID was change, update statistic
	    IF #sUDT_MSGIDCounters.HB <> #iUDT_MSGIDCounters.HB
	    THEN
	        
	        // Increase HB statistics if are in DInt range
	        IF (#iqUDT_ChatStatistics.HB < 2147483647)
	        THEN
	            
	            #iqUDT_ChatStatistics.HB += 1;
	            // Update static MSGID counter
	            #sUDT_MSGIDCounters.HB := #iUDT_MSGIDCounters.HB;
	            
	            // Start statistics from 0 if are out of DInt range 
	        ELSE
	            
	            #iqUDT_ChatStatistics.HB := 0;
	            // Update static MSGID counter
	            #sUDT_MSGIDCounters.HB := #iUDT_MSGIDCounters.HB;
	            
	        END_IF;
	        
	    END_IF;
	    
	    // Communication error rising edge detect 
	    #sR_TRIG_CommError(CLK := #ix_CommunicationError);
	    
	    // Communication error statistics
	    IF #ix_CommunicationError
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #ix_CommunicationError,
	                        ix_RTrigActivate := #sR_TRIG_CommError.Q,
	                        iqUDT_Statistics := #iqUDT_ChatStatistics.CommunicationError);
	        
	    END_IF;
	    
	    // Chat communication error rising edge detect 
	    #sR_TRIG_LostChatConn(CLK := #ix_LostChatConnection);
	    
	    // Chat communication error statistics
	    IF #ix_LostChatConnection
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #ix_LostChatConnection,
	                        ix_RTrigActivate := #sR_TRIG_LostChatConn.Q,
	                        iqUDT_Statistics := #iqUDT_ChatStatistics.LostChatConnection);
	        
	    END_IF;
	    
	    // XLe communication error rising edge detect 
	    #sR_TRIG_LostXLeConn(CLK := #ix_LostXLeConnection);
	    
	    // XLe communication erro statistics
	    IF #ix_LostXLeConnection
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #ix_LostXLeConnection,
	                        ix_RTrigActivate := #sR_TRIG_LostXLeConn.Q,
	                        iqUDT_Statistics := #iqUDT_ChatStatistics.LostXLeConnection);
	        
	    END_IF;
	    
	    // Card communication error rising edge detect 
	    #sR_TRIG_LostCardComm(CLK := #ix_LostCardCommunication);
	    
	    // Card communication error statistics
	    IF #ix_LostCardCommunication
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #ix_LostCardCommunication,
	                        ix_RTrigActivate := #sR_TRIG_LostCardComm.Q,
	                        iqUDT_Statistics := #iqUDT_ChatStatistics.LostPLCCommunication);
	        
	    END_IF;
	    
	END_REGION
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_UPSPLCMsg"
TITLE = FB_PLCMsg
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : UPS_SpecificCommunication
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 59
// END_ATTRIBUTES
//Function block to prepare and send the UPS PLCMSG message. 
   VAR_INPUT 
      iUDT_MsgHeader { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_UPSMessageHeader";   // UPS message header
      is_PLCIdTrayId { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[2] := '00';   // PLC ID or TRAY ID
      ii_GIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // GIN
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective error output
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective warning output
   END_VAR

   VAR_IN_OUT 
      iqUDT_FifoHeader : "UDT_FifoHeader";   // Fifo header
      iqa_FifoData : Array[*] of "UDT_Message";   // Fifo data
   END_VAR

   VAR 
      sUDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Message";   // Message character array
      sa_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";   //  FIFO status structure
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //  FIFO error
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //  FIFO warning
         InvalidGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Invalid GIN
         InvalidPLCID_TRAYID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Invalid PLC ID or TRAY ID
         InvalidMsgArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Invalid message array size
      END_STRUCT;
      ss_PLCID_TRAYID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[6];   // PLC ID or Tray ID
      ss_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Message character string
      sui_MsgArrayElNr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Number of written message characters
      si_MaxMsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum message length
      si_MsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // String character message length
      si_PLCID_TRAYIDLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // PLC ID or Tray ID length
      si_i { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Loop counter
   END_VAR
   VAR RETAIN
      si_OldGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Old GIN
   END_VAR

   VAR CONSTANT 
      cc_NULL : Char := '$00';   // NULL sign
      cc_DL : Char := ',';   // Comma sign
      cs_PLCMsg : String := 'PLC_MSG';   // Message type
      cs_CRLF : String := '$R$L';   // Termination signs
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2019             MHS                                                     |
	|  All Rights Reserved         Larenweg 90                                             |
	|                              5234 KC 's-Hertogenbosch,                               |
	|                              Netherlands                                             |
	|                                                                                      |     
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	13/06/2019  | 0.2       | A.Nowak       | Replacement of instruction if for direct write into variable - Region 2.5
	28/06/2019  | 0.4       | A.Nowak       | Changing conditions for error occuring and status update
	17/07/2019  | 0.5       | L.Klar        | Status handling changed
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	23/08/2019  | 2.1       | L.Klar        | PLC ID/Tray ID input changed to integer, PLC ID/Tray ID conversion int to string added, logic to add leading zeros to PLCID/Tray ID added, comments adjusted
	20/09/2019  | 2.2       | M.Kurpiers    | Change - status to struct
	01/10/2019  | 2.3       | A.Nowak       | Implementation of the new FIFO block
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	08/01/2020  | 3.1       | L.Klar        | ii_GIN added, invalid GIN status added
	13/10/2020  | 3.2       | L.Klar        | MSGID removed
	                                        | Message trigger based on new GIN detection
	22/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – PLCMsg
	    
	    IF #ii_GIN > 0 AND #ii_GIN <> #si_OldGIN
	    THEN
	        
	        #si_OldGIN := #ii_GIN;
	        
	        REGION 2.1 – FIFO header status update
	            
	            // Mode 'S' - FIFO register status update
	            "FC_Fifo"(ic_Mode := 'S',
	                      qUDT_Status => #sa_Status.FIFOStatus,
	                      qx_Error => #sa_Status.FIFOError,
	                      qx_Warning => #sa_Status.FIFOWarning,
	                      iqv_Data := #sUDT_MessageArray,
	                      iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                      iqv_DataBuffer := #iqa_FifoData);
	            
	        END_REGION
	        
	        REGION 1.2 – GIN and PLCID/TRAYID validation
	            
	            // GIN validation
	            #sa_Status.InvalidGIN :=
	            #ii_GIN < 1
	            OR #ii_GIN > 9999;
	            
	            // PLCID/TRAYID validation
	            #sa_Status.InvalidPLCID_TRAYID :=
	            #is_PLCIdTrayId <> '00'
	            AND #is_PLCIdTrayId <> '99'
	            AND #is_PLCIdTrayId <> 'TR'
	            AND #is_PLCIdTrayId <> '1R'
	            AND #is_PLCIdTrayId <> '2R'
	            AND #is_PLCIdTrayId <> '3R'
	            AND #is_PLCIdTrayId <> '4R';
	            
	        END_REGION
	        
	        REGION 1.3 – PLC_MSG message preparation
	            
	            IF (NOT #sa_Status.FIFOError
	                AND NOT #sa_Status.InvalidGIN
	                AND NOT #sa_Status.InvalidPLCID_TRAYID)
	            THEN
	                
	                IF (NOT #iqUDT_FifoHeader.Status.Full)
	                THEN
	                    
	                    // PLCID/TRAYID character string clearing
	                    #ss_PLCID_TRAYID := '';
	                    
	                    // PLCID/TRAYID integer input conversion to a character string
	                    VAL_STRG(IN := #ii_GIN,
	                             SIZE := 0,
	                             PREC := 0,
	                             FORMAT := 0,
	                             P := 1,
	                             OUT => #ss_PLCID_TRAYID);
	                    
	                    // Length of the PLCID/TRAYID character string 
	                    #si_PLCID_TRAYIDLen := LEN(#ss_PLCID_TRAYID);
	                    
	                    // PLCID/TRAYID character string leading zeros addition
	                    IF (#si_PLCID_TRAYIDLen < 4)
	                    THEN
	                        
	                        FOR #si_i := 1 TO 4 - #si_PLCID_TRAYIDLen DO
	                            
	                            #ss_PLCID_TRAYID := CONCAT(IN1 := '0',
	                                                       IN2 := #ss_PLCID_TRAYID);
	                            
	                        END_FOR;
	                        
	                    END_IF;
	                    
	                    // PLCID/TRAYID addition
	                    #ss_PLCID_TRAYID := INSERT(IN1 := #ss_PLCID_TRAYID, IN2 := #is_PLCIdTrayId, P := 0);
	                    
	                    // PLC_MSG message composing according to the structure: SCN,SCT,RCN,RCT,MT,MSGID,PLCID {CRLF}
	                    #ss_Message := CONCAT(IN1 := #iUDT_MsgHeader.SCN,           // Sender IP address  
	                                          IN2 := #cc_DL,                        // Comma sign - ","
	                                          IN3 := #iUDT_MsgHeader.SCT,           // Sender Name  
	                                          IN4 := #cc_DL,                        // Comma sign - ","
	                                          IN5 := #iUDT_MsgHeader.RCN,           // Receiver IP address
	                                          IN6 := #cc_DL,                        // Comma sign - ","
	                                          IN7 := #iUDT_MsgHeader.RCT,           // Receiver Name
	                                          IN8 := #cc_DL,                        // Comma sign - ","
	                                          IN9 := #cs_PLCMsg,                    // Message type - "IDFWD"
	                                          IN10 := #cc_DL,                       // Comma sign - ","
	                                          IN11 := #ss_PLCID_TRAYID,             // PLCID
	                                          IN12 := #cs_CRLF);                    // Termination signs - "$R$L"
	                    
	                    
	                    // Maximum number of the message characters
	                    #si_MaxMsgLen := "FC_GetNrOfArrayEl"(iv_Array := #sUDT_MessageArray.Character);
	                    
	                    // Length of the complete message
	                    #si_MsgLen := LEN(#ss_Message);
	                    
	                    // Message array size validation
	                    #sa_Status.InvalidMsgArraySize := #si_MsgLen > #si_MaxMsgLen;
	                    
	                    // Message character string conversion to a message array of characters
	                    IF (NOT #sa_Status.InvalidMsgArraySize)      // Message character array size is valid 
	                    THEN
	                        
	                        Strg_TO_Chars(Strg := #ss_Message,
	                                      pChars := 0,
	                                      Cnt => #sui_MsgArrayElNr,
	                                      Chars := #sUDT_MessageArray.Character);
	                        
	                    END_IF;
	                    
	                    // Clearing remaining characters in the message character array
	                    IF (NOT #sa_Status.InvalidMsgArraySize)
	                    THEN
	                        
	                        // Filling up not used message character array elements with '$00' (ASCII - 16#00)
	                        FILL_BLK(IN := #cc_NULL,
	                                 COUNT := UINT_TO_ULINT(INT_TO_UINT(#si_MaxMsgLen) - #sui_MsgArrayElNr),
	                                 OUT => #sUDT_MessageArray.Character[#sui_MsgArrayElNr]);
	                        
	                    END_IF;
	                    
	                    // Message write into a FIFO register
	                    IF (NOT #sa_Status.InvalidMsgArraySize)
	                    THEN
	                        
	                        // Mode 'W' - Write FIFO record
	                        "FC_Fifo"(ic_Mode := 'W',
	                                  qUDT_Status => #sa_Status.FIFOStatus,
	                                  qx_Error => #sa_Status.FIFOError,
	                                  qx_Warning => #sa_Status.FIFOWarning,
	                                  iqv_Data := #sUDT_MessageArray,
	                                  iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                                  iqv_DataBuffer := #iqa_FifoData);
	                        
	                    END_IF;
	                    
	                    // In case of FIFO full, the FIFO full error bit and FIFO collective error bit are set
	                ELSE
	                    
	                    #sa_Status.FIFOError := TRUE;
	                    #sa_Status.FIFOStatus.FifoFull := TRUE;
	                    
	                END_IF;
	                
	            END_IF;
	            
	        END_REGION
	        
	        REGION 1.4 – Status
	            
	            // Parametrization collective error output
	            #qx_Error :=
	            #sa_Status.InvalidMsgArraySize
	            OR #sa_Status.InvalidPLCID_TRAYID
	            OR #sa_Status.FIFOError;
	            
	            // Parametrization collective warning output
	            #qx_Warning := #sa_Status.FIFOWarning;
	            
	        END_REGION
	        
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_UPSSSPLamp"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 62
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_EquipmentControl { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EquipmentControl";   // Equipment control structure
      ix_SspInput { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // SSP Field input
      ix_SspHealthy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // SSP Zone Healthy
      ix_RIOPNNodeError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PN Node of SSP input is in error
      ix_RIOPNNodeOffline { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PN Node of SSP input is offline
      ix_SspReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // SSP Field reset input
      ìx_24VOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 24 V OK
   END_VAR

   VAR_OUTPUT 
      qx_Lamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // SSP Lamp (Green)
      qx_SSPStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // SSP Status
   END_VAR

   VAR_IN_OUT 
      iqUDT_Statistics : "UDT_UPSSspStatistics";
      iqx_StartToSystemControl { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start command for system control
      iqx_ResetToSystemControl { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset command for system control
   END_VAR

   VAR 
      sR_TRIG_SSPReset {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger SSP reset
      sR_TRIG_Stop {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge stop
      sx_SspStartRequired { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Restart required because of SSP pressed
      sx_SspStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Status of SSP
   END_VAR

   VAR_TEMP 
      tx_LampSteady : Bool;   // Temp variable for steady lamp
      tx_LampBlink : Bool;   // Temp variable for blinking lamp
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	11/06/2020  | 3.0       | S. Deulkar    | first release TIA 15
	29/07/2020  | 3.1       | S. Theocharis | Add one shot detection on the reset input
	17/08/2020  | 3.2       | S. Theocharis | Add statistics / StatusS
	22/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 Detect SSP Reset one shot
	    
	    #sR_TRIG_SSPReset(CLK := #ix_SspReset);
	    
	END_REGION
	
	REGION 2 SSP Status
	    
	    #qx_SSPStatus := #sx_SspStatus := NOT #ix_SspHealthy
	    AND NOT #ix_RIOPNNodeError
	    AND NOT #ix_RIOPNNodeOffline
	    AND #ìx_24VOk;
	    
	END_REGION
	
	REGION 3 Lamp logic
	    
	    // Conditions to detect restart required for SSP or not
	    IF NOT #ix_SspHealthy
	    THEN
	        #sx_SspStartRequired := TRUE;
	    END_IF;
	    
	    IF #iUDT_EquipmentControl.Command.Start
	    THEN
	        #sx_SspStartRequired := FALSE;
	    END_IF;
	    
	    // conditions for blinking lamp
	    #tx_LampBlink := #ix_SspHealthy
	    AND #sx_SspStartRequired
	    AND #iUDT_EquipmentControl.Command.AutomaticOn
	    AND #iUDT_EquipmentControl.Request.RestartRequired;
	    
	    // COnditions for steady lamp
	    #tx_LampSteady := #ix_SspInput
	    AND NOT #ix_SspHealthy;
	    
	END_REGION
	
	REGION 4 Send reset command to system control
	    
	    #iqx_ResetToSystemControl := (#tx_LampSteady AND #sR_TRIG_SSPReset.Q)
	    OR #iqx_ResetToSystemControl;
	    
	    #iqx_StartToSystemControl := (#tx_LampBlink AND #sR_TRIG_SSPReset.Q)
	    OR #iqx_StartToSystemControl;
	    
	    #qx_Lamp := (#tx_LampBlink AND "DB_Memory"."Clock_0.5Hz")
	    OR #tx_LampSteady;
	    
	END_REGION
	
	
	
	REGION 5 Statistics
	    
	    REGION 5.1 Triggers
	        
	        //Stoped trigger
	        #sR_TRIG_Stop(CLK := NOT #ix_SspHealthy);
	        
	    END_REGION
	    
	    REGION 5.2 SSP Start
	        
	        //Count up
	        IF #tx_LampBlink AND #sR_TRIG_SSPReset.Q THEN
	            #iqUDT_Statistics.CS_Start += 1;
	        END_IF;
	        
	        //Reset
	        IF #iUDT_EquipmentControl.Command.ResetData THEN
	            #iqUDT_Statistics.CS_Start := 0;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 5.3 SSP Stop
	        
	        IF (NOT #ix_SspHealthy
	            OR #iUDT_EquipmentControl.Command.ResetData)                                          // Reset statistics
	        THEN
	            
	            "FC_Statistics"(ix_Reset := #iUDT_EquipmentControl.Command.ResetData,        // Reset statistics input
	                            ix_Activate := NOT #ix_SspHealthy,                                    // Activate statistics functions input
	                            ix_RTrigActivate := #sR_TRIG_Stop.Q,                                   // Statistics active trigger
	                            iqUDT_Statistics := #iqUDT_Statistics.CS_Stop);                       // Statistics values output
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_UPSEnergySaving"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 53
// END_ATTRIBUTES
   VAR_INPUT 
      ii_EsaveTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Time after which Energy Saving is activated [s]
      ix_PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Signal from PEC
      ix_ResetEsave { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset Energy Saving timer
   END_VAR

   VAR_OUTPUT 
      qx_ResetEsave { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1- Energy Saving OFF, 0 = Energy Saving ON
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
   END_VAR

   VAR 
      sFB_TimerOnOffDelayEnergySaving { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Energy Saving timer
      sx_TimerReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset timer
   END_VAR

   VAR_TEMP 
      tx_TimerDone : Bool;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	10/12/2019  | 3.0       | M.Kurc        | first release MHS TIA 15.1
	21/04/2020  | 3.1       | S. Deulkar    | Send restart required when in energy save
	22/04/2020  | 3.2       | L. Klar       | Timer output change to temp instead of output, time is given in s instead of ms
	22/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Timer
	    
	    #sFB_TimerOnOffDelayEnergySaving(iudi_OnDelayTime := INT_TO_UDINT(#ii_EsaveTime) * 1000,     // On delay time[ms],
	                                     ix_SignalToDelay := #sx_TimerReset,                       // Condition to start/reset timer
	                                     ix_Enable := TRUE,
	                                     qx_DelayedSignal => #tx_TimerDone);                       // Output signal after time elapsed
	    
	END_REGION
	
	REGION 2 - Conditions to start/reset timer
	    
	    // To start/reset timer command autoamtic on must be avalible
	    // Timer start count after start command and time is not elapsed
	    // Timer reseting count when PEC detect parcel or external reset signal occurs
	    #sx_TimerReset := ((#ix_PEC
	    AND NOT #ix_ResetEsave
	    AND NOT #tx_TimerDone)
	    OR (#tx_TimerDone
	    AND NOT #iqUDT_EquipmentControl.Command.Start
	    AND NOT #ix_ResetEsave))
	    AND #iqUDT_EquipmentControl.Command.AutomaticOn;
	    
	    // Update EnergySave report
	    #iqUDT_EquipmentControl.Report.EnergySave := #tx_TimerDone;
	    #qx_ResetEsave := NOT #tx_TimerDone;
	    
	    #iqUDT_EquipmentControl.Request.RestartRequired := #iqUDT_EquipmentControl.Request.RestartRequired
	    OR #tx_TimerDone;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_UPSFlowMeasurement"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 54
// END_ATTRIBUTES
   VAR_INPUT 
      ix_PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Signal of the filtered PEC
   END_VAR

   VAR_OUTPUT 
      qdi_FlowCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //  Flow count since last reset
      qi_30secFlow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  30 seconds pph rate
      qi_1minFlow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  1 minute pph rate
      qi_3minFlow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  3 minutes pph rate
      qi_10minFlow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  10 minutes pph rate
      qa_15secFlowCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..50] of Int;   //  Array of parcel count every 15 seconds
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";
   END_VAR

   VAR 
      sFB_Pulse_EndOf15sPeriod { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Pulse";
      sR_TRIG_ParcelDetect {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge of PEC signal
      sa_CountingReg { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..50] of Int;   //  Counting registers
      sdi_FlowCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //  Flow count since last reset
      si_30secFlow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  30 seconds flow rate register
      si_1minFlow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  1 minute flow rate register
      si_3minFlow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  3 minutes flow rate register
      si_10minFlow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  10 minutes flow rate register
      si_FlowCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Flow count for configured time
   END_VAR

   VAR_TEMP 
      ti_LCi : Int;   //  Loop counter
      tx_End15sPeriod : Bool;   //  End of 15 seconds flow period
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	05/12/2019  | 3.0       | K.Pokorski    | first release MHS TIA 15.1
	13/12/2020  | 3.1       | F.Baten       | Added Flow count as output of the block
	22/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Increasing first parcel counting register
	    
	    // Rising edge PEC signal
	    #sR_TRIG_ParcelDetect(CLK := #ix_PEC);
	    
	    // Increase first counting register when new parcel detect
	    IF (#sR_TRIG_ParcelDetect.Q)
	    THEN
	        
	        #sa_CountingReg[1] += 1;
	        #sdi_FlowCount += 1;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 - End of 15s flow period
	    
	    // Calculate 15 seconds period
	    #sFB_Pulse_EndOf15sPeriod(iudi_PulseTime := 15000,
	                              qx_Pulse => #tx_End15sPeriod);
	    
	END_REGION
	
	REGION 3 - Flow data calculating
	    
	    // The 15 second period has passed
	    IF (#tx_End15sPeriod)
	    THEN
	        
	        // Initialize static flow buffer
	        #si_30secFlow := 0;
	        #si_1minFlow := 0;
	        #si_3minFlow := 0;
	        #si_10minFlow := 0;
	        
	        // Loop through 40 CR
	        FOR #ti_LCi := 1 TO 40 DO
	            
	            // 30 sec flow handling
	            IF #ti_LCi <= 2
	            THEN
	                
	                #si_30secFlow += #sa_CountingReg[#ti_LCi];
	                
	                // Conversion to full hour
	                IF #ti_LCi = 2
	                THEN
	                    
	                    #si_30secFlow *= 120;
	                    
	                END_IF;
	                
	            END_IF;
	            
	            // 1 minute flow handling
	            IF #ti_LCi <= 4
	            THEN
	                
	                #si_1minFlow += #sa_CountingReg[#ti_LCi];
	                
	                // Conversion to full hour
	                IF #ti_LCi = 4
	                THEN
	                    
	                    #si_1minFlow *= 60;
	                    
	                END_IF;
	                
	            END_IF;
	            
	            // 3 minutes flow handling
	            IF #ti_LCi <= 12
	            THEN
	                
	                #si_3minFlow += #sa_CountingReg[#ti_LCi];
	                
	                // Conversion to full hour
	                IF #ti_LCi = 12
	                THEN
	                    
	                    #si_3minFlow *= 20;
	                    
	                END_IF;
	                
	            END_IF;
	            
	            // 10 minutes flow handling
	            #si_10minFlow += #sa_CountingReg[#ti_LCi];
	            
	            // Conversion to full hour
	            IF #ti_LCi = 40
	            THEN
	                
	                #si_10minFlow *= 6;
	                
	            END_IF;
	            
	        END_FOR;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Flow count reset
	    
	    IF #iqUDT_EquipmentControl.Command.ResetData
	        
	    THEN
	        #sdi_FlowCount := 0;
	    END_IF;
	    
	END_REGION
	
	
	REGION 5 - Moving CRs when 15s flow period ends
	    
	    // 15 seconds period elapsed 
	    IF (#tx_End15sPeriod)
	    THEN
	        
	        // Moving counting register to output
	        #qa_15secFlowCount := #sa_CountingReg;
	        
	        // Shifted counting register by one element down
	        MOVE_BLK(IN := #sa_CountingReg[1],
	                 COUNT := 49,
	                 OUT => #sa_CountingReg[2]);
	        
	        // Reset first registter
	        #sa_CountingReg[1] := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Write outputs
	    #qdi_FlowCount := #sdi_FlowCount;
	    #qi_30secFlow := #si_30secFlow;
	    #qi_1minFlow := #si_1minFlow;
	    #qi_3minFlow := #si_3minFlow;
	    #qi_10minFlow := #si_10minFlow;
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_UPSHeartbeat"
TITLE = FB_Heartbeat
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : UPS_SpecificCommunication
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 55
// END_ATTRIBUTES
//Function block to send and monitor the UPS heartbeat message.
   VAR_INPUT 
      iUDT_MsgHeader { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_UPSMessageHeader";   // UPS message header
      is_ActualDateTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[23];   // Actual date and time
      is_BuildingMnemonic { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[5] := 'abcde';   // Building mnemonic
      is_SoftCompData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[8] := 'YYYYMMDD';   // Software compilation data
      is_ModuleName { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[2] := 'AB';   // Module type
      is_DeviceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[4] := 'abcd';   // Device number
      iudi_HeartbeatInterval { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Heartbeat send time interval [ms]
      iudi_HeartbeatTimeout { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Heartbeat timeout [ms]
      ix_EnableSend { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Enable heartbeat message send
      ix_ResetData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset statistics
   END_VAR

   VAR_OUTPUT 
      qx_HeartbeatOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat ok
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective error output
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective warning output
   END_VAR

   VAR_IN_OUT 
      iqUDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_Message";   // FIFO data
      iqUDT_Statistics : "UDT_UPSHeartbeatStatistics";   // Statistic strucure
      iqdi_UniqueMsgID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Unique message ID integer
      iqx_Heartbeat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbreat
      iqx_Reconnect { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reconnect command
   END_VAR

   VAR 
      sFB_Timer_HeartbeatCheck { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // MHS "FB_TimerOnOffDelay" - to measure the time of  missing Hearbeat
      sFB_HeartbeatPulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Pulse";   // MHS "FB_Pulse" block - to generate preset pulse signal
      sR_TRIG_EnableSend {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Siemens "R_TRIG" - to prepare the rising edge trigger on "ix_EnableSend" signal
      sUDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Message";   // Message character array
      sa_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO data buffer full
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO error
         HeartbeatOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO warning
         InvalidTimeInterval { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat ok
         InvalidTimeout { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat time interval lower than zero
         InvalidMsgArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat timeout lower than zero or lower than heartbeat time interval
      END_STRUCT;
      ss_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Message character string
      ss_MSGID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Timestamp
      sui_MsgArrayElNr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Invalid message array size
      si_MaxMsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum message length
      si_MsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // String character message length
      si_LostMsg { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Number of lost heartbeat messages
      sx_HeartbeatPulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat pulse
      sx_HeartbeatOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat ok
      sx_MsgLost { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message lost
      sx_HeartbeatCheck { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat check
   END_VAR

   VAR CONSTANT 
      cc_NULL : Char := '$00';   // NULL sign
      cc_Dash : Char := '-';   // Dash sign
      cc_DL : Char := ',';   // Comma sign
      cs_Heartbeat : String := 'HEARTBEAT';   // Message type
      cs_CRLF : String := '$R$L';   // Termination signs
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	14/06/2019  | 0.2       | A.Nowak       | Replacement of instruction if for direct write into variable - Region 2 , 4.5
	28/06/2019  | 0.4       | A.Nowak       | Changing conditions for error occuring and status update
	18/07/2019  | 0.5       | L.Klar        | Status handling changed
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	23/08/2019  | 2.1       | K.Pokorski    | Comments simplified
	20/09/2019  | 2.2       | J.Krawczuk    | Replacing UDT_HeartbeatStatus structure to internal structure 
	01/10/2019  | 2.3       | A.Nowak       | Implementation of the new FIFO block
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	13/10/2020  | 3.1       | L.Klar        | RCT and RCN changed to UPS server
	22/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #sa_Status.FIFOStatus,
	              qx_Error => #sa_Status.FIFOError,
	              qx_Warning => #sa_Status.FIFOWarning,
	              iqv_Data := #sUDT_MessageArray,
	              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	    
	END_REGION
	
	REGION 2 – Heartbeat time interval and timeout validation
	    
	    #sa_Status.InvalidTimeInterval := #iudi_HeartbeatInterval <= 0;
	    
	    #sa_Status.InvalidTimeout :=
	    #iudi_HeartbeatTimeout <= 0
	    OR #iudi_HeartbeatTimeout <= #iudi_HeartbeatInterval;
	    
	END_REGION
	
	REGION 3 – Heartbeat pulse generation
	    
	    IF (NOT #sa_Status.InvalidTimeInterval                            // Preset heartbeat time interval is valid 
	        AND NOT #sa_Status.InvalidTimeout)                            // Timeout is valid
	    THEN
	        
	        // Heartbeat pulse generation 
	        #sFB_HeartbeatPulse(iudi_PulseTime := #iudi_HeartbeatInterval,
	                            qx_Pulse => #sx_HeartbeatPulse);
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 – HEARTBEAT message preparation
	    
	    IF (NOT #iqUDT_FifoHeader.Status.Full)                         // FIFO isn't full
	    THEN
	        
	        IF (#sx_HeartbeatPulse                                      // Heartbeat pulse available                
	            AND #ix_EnableSend                                      // Send is enable
	            AND NOT #sa_Status.FIFOError)                        // No FIFO error
	        THEN
	            
	            REGION 4.1 – Unique MSGID
	                
	                "FC_UPSMsgId"(is_ActualDateTime := #is_ActualDateTime,
	                              is_ModuleName := #is_ModuleName,
	                              is_DeviceNumber := #is_DeviceNumber,
	                              iqs_MSGID := #ss_MSGID,
	                              iqdi_UniqueMsgID := #iqdi_UniqueMsgID);
	                
	            END_REGION
	            
	            REGION 4.2 – Message preparation
	                
	                // Heartbeat message composing according to the structure: SCN,SCT,RCN,RCT,MT,MSGID,VER {CRLF}
	                #ss_Message := CONCAT(IN1 := #iUDT_MsgHeader.SCN,      // Sender IP address     
	                                      IN2 := #cc_DL,                    // Comma sign - ","
	                                      IN3 := #iUDT_MsgHeader.SCT,      // Sender Name     
	                                      IN4 := #cc_DL,                    // Comma sign - ","
	                                      IN5 := #iUDT_MsgHeader.RCN,      // Sender IP address   
	                                      IN6 := #cc_DL,                    // Comma sign - ","
	                                      IN7 := #iUDT_MsgHeader.RCT,      // Sender Name    
	                                      IN8 := #cc_DL,                    // Comma sign - ","
	                                      IN9 := #cs_Heartbeat,             // Message type - "HEARTBEAT"
	                                      IN10 := #cc_DL,                   // Comma sign  - ","
	                                      IN11 := #ss_MSGID,                // MSGID 
	                                      IN12 := #cc_DL,                   // Comma sign - ","
	                                      IN13 := #is_BuildingMnemonic,     // Building mnemonic
	                                      IN14 := #cc_Dash,                 // Dash sign - "-"
	                                      IN15 := #iUDT_MsgHeader.SCT,     // Sender IP address 
	                                      IN16 := #cc_Dash,                 // Dash sign - "-"
	                                      IN17 := #is_SoftCompData,         // Software compilation date 
	                                      IN18 := #cs_CRLF);                // Termination signs - "$R$L"           
	                
	            END_REGION
	            
	            REGION 4.3 – Maximum number of the message characters
	                
	                #si_MaxMsgLen := "FC_GetNrOfArrayEl"(iv_Array := #sUDT_MessageArray.Character);
	                
	            END_REGION
	            
	            REGION 4.4 – Length of the complete message
	                
	                #si_MsgLen := LEN(#ss_Message);
	                
	            END_REGION
	            
	            REGION 4.5 –  Message array size validation
	                
	                #sa_Status.InvalidMsgArraySize := #si_MsgLen > #si_MaxMsgLen;
	                
	            END_REGION
	            
	            REGION 4.6 –  Message character string conversion to a message array of characters
	                
	                IF (NOT #sa_Status.InvalidMsgArraySize)                      // Message character array size is valid 
	                THEN
	                    
	                    Strg_TO_Chars(Strg := #ss_Message,
	                                  pChars := 0,
	                                  Cnt => #sui_MsgArrayElNr,
	                                  Chars := #sUDT_MessageArray.Character);
	                    
	                END_IF;
	                
	            END_REGION
	            
	            REGION 4.7 – Clearing remaining characters in the message character array
	                
	                IF (NOT #sa_Status.InvalidMsgArraySize)                      // Message character array size is valid 
	                THEN
	                    
	                    // Filling up not used message character array elements with '$00' (ASCII - 16#00)
	                    FILL_BLK(IN := #cc_NULL,
	                             COUNT := UINT_TO_ULINT(INT_TO_UINT(#si_MaxMsgLen) - #sui_MsgArrayElNr),
	                             OUT => #sUDT_MessageArray.Character[#sui_MsgArrayElNr]);
	                    
	                END_IF;
	                
	            END_REGION
	            
	            REGION 4.8 – Message write into a FIFO register
	                
	                IF (#ix_EnableSend                                                   // Heartbeat send enable
	                    AND NOT #sa_Status.InvalidMsgArraySize)                       // Message character array size is valid 
	                THEN
	                    
	                    // Mode 'W' - Write FIFO record
	                    "FC_Fifo"(ic_Mode := 'W',
	                              qUDT_Status => #sa_Status.FIFOStatus,
	                              qx_Error => #sa_Status.FIFOError,
	                              qx_Warning => #sa_Status.FIFOWarning,
	                              iqv_Data := #sUDT_MessageArray,
	                              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                              iqv_DataBuffer := #iqs_FifoData);
	                    
	                    
	                END_IF;
	                
	            END_REGION
	            
	        END_IF;
	        
	        // In case of FIFO full, the FIFO full error bit and FIFO collective error bit are set
	    ELSE
	        
	        #sa_Status.FIFOError := TRUE;
	        #sa_Status.FIFOStatus.FifoFull := TRUE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 5 – Heartbeat monitoring
	    
	    IF (NOT #sa_Status.InvalidTimeInterval                                                                        // Time interval is valid
	        AND NOT #sa_Status.InvalidTimeout                                                                         // Timeout is  valid
	        AND NOT #sa_Status.InvalidMsgArraySize)                                                                   // Message character array size is valid 
	        
	    THEN
	        
	        #sR_TRIG_EnableSend(CLK := #ix_EnableSend);
	        
	        // Reset heartbeat ok 
	        IF (NOT #ix_EnableSend)                                                                                      // Heartbeat send not enable
	        THEN
	            
	            #sx_HeartbeatOk := FALSE;
	            
	        END_IF;
	        
	        // Clear auxiliary variables
	        IF (#iqx_Heartbeat                                                                                           // Hearbeat message received
	            AND #ix_EnableSend)                                                                                      // Heartbeat send enable
	        THEN
	            
	            #si_LostMsg := 0;                                                                                        // Lost messages counter
	            #sx_MsgLost := FALSE;                                                                                    // Message lost bit
	            #sx_HeartbeatOk := TRUE;                                                                                 // HeartbeatOk bit
	            
	        END_IF;
	        
	        // Time measurement of a missing heartbeat 
	        #sFB_Timer_HeartbeatCheck(ix_SignalToDelay := #iqx_Heartbeat                                                // Heartbeat signal
	                                  OR #sx_MsgLost                                                // Message lost
	                                  OR #sR_TRIG_EnableSend.Q,                                    // Enable send trigger
	                                  iudi_OnDelayTime := 0,
	                                  iudi_OffDelayTime := #iudi_HeartbeatTimeout,
	                                  qx_DelayedSignal => #sx_HeartbeatCheck);
	        
	        #iqx_Heartbeat := FALSE;
	        #sx_MsgLost := FALSE;
	        
	        // Increment lost messages counter and set lost message bit 
	        IF (NOT #sx_HeartbeatCheck              // Heartbeat not checked
	            AND NOT #iqx_Reconnect              // No reconnect command
	            AND #ix_EnableSend)                 // Send is enable   
	        THEN
	            
	            #si_LostMsg += 1;
	            #sx_MsgLost := TRUE;
	            
	        END_IF;
	        
	        // Reestablish connection, increment statistics and signalize heartbeat error 
	        IF (#si_LostMsg = 3)                   // Three heartbeat message are lost
	        THEN
	            
	            #iqx_Reconnect := TRUE;
	            #iqUDT_Statistics.ConLost += 1;
	            #si_LostMsg := 0;
	            #sx_MsgLost := FALSE;
	            #sx_HeartbeatOk := FALSE;
	            
	        END_IF;
	        
	        // Configuration error occured    
	    ELSE
	        
	        #sx_HeartbeatOk := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 6 – Reset statistics
	    
	    IF (#ix_ResetData)                          // Reset statistics request
	    THEN
	        
	        #iqUDT_Statistics.ConLost := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 7 – Status
	    
	    // Hearbeat ok output
	    #qx_HeartbeatOK := #sx_HeartbeatOk;
	    
	    // Parametrization collective error output
	    #qx_Error :=
	    #sa_Status.InvalidTimeInterval                   // Invalid time interval 
	    OR #sa_Status.InvalidTimeout                     // Invalid timeout 
	    OR #sa_Status.InvalidMsgArraySize                // Invalid message character array size   
	    OR #sa_Status.FIFOError                          // FIFO error
	    OR NOT #sx_HeartbeatOk;                             // No heartbeat OK
	    
	    // Parametrization collective warning output
	    #qx_Warning := #sa_Status.FIFOWarning;           // FIFO warning
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_UPSIdFwd"
TITLE = FB_IDFWD
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : UPS_SpecificCommunication
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 56
// END_ATTRIBUTES
//Function block to prepare and send the UPS IDFWD message. 
   VAR_INPUT 
      iUDT_MsgHeader { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_UPSMessageHeader";   // UPS message header
      is_ActualDateTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[23];   // Actual date and time
      is_ModuleName { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[2] := 'AB';   // Module type
      is_DeviceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[4] := 'abcd';   // Device number
      is_PLCID_TRAYID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[2] := '00';   // PLC ID or TRAY ID
      ii_GIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // GIN
      ii_DesSys { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Designated system: 1- Weight scale ; 2 - X-Ray; 3 - Camera system; 4 - Label applicator; 5 - Sorter; 6 - Other
      ii_Delay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Message delay time [ms]
      ix_DestinationRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when message send as a destinations request
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective error output
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective warning output
   END_VAR

   VAR_IN_OUT 
      iqUDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqa_FifoData : Array[*] of "UDT_Message";   // FIFO data
      iqdi_UniqueMsgID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Unique message ID counter
   END_VAR

   VAR 
      s_UDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_Message";   // Message character array
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";   //  FIFO Status structure
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //  FIFO error
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //  FIFO warning
         InvalidDesSysPar { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Invalid designated system parameter input
         InvalidGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Invalid GIN
         InvalidPLCID_TRAYID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Invalid PLCID/TRAYID
         InvalidDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Invalid delay time
         InvalidMsgArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Invalid message array size
      END_STRUCT;
      ss_PLCIDTRAYID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[6];   // PLCID
      ss_Delay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[4];   // Message delay
      ss_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Message character string
      ss_MSGID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Timestamp
      ss_DesSys { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Designated system character string
      sui_MsgArrayElNr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Number of written message characters
      si_MaxMsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum message length
      si_MsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // String character message length
      si_PLCIDLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // PLCID length
      si_DelayLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Message delay length
      si_i { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Loop counter
   END_VAR
   VAR RETAIN
      si_OldGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Old GIN
   END_VAR

   VAR CONSTANT 
      cc_NULL : Char := '$00';   // NULL sign
      cc_DL : Char := ',';   // Comma sign
      cs_IDFWD : String := 'IDFWD';   // Message type
      cs_WeightScale : String := 'WT_SCALE';   // Designated system - Weight scale
      cs_XRay : String := 'X_RAY   ';   // Designated system - X-Ray system
      cs_CameraSys : String := 'CAMERA  ';   // Designated system - Camera system
      cs_LabelApplicator : String := 'LBL_APP ';   // Designated system - Label applicator
      cs_Sorter : String := 'SORTER  ';   // Designated system - Sorter
      cs_Other : String := 'OTHER   ';   // Designated system - Other
      cs_CRLF : String := '$R$L';   // Termination signs
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	13/06/2019  | 0.2       | A.Nowak       | Replacement of instruction if for direct write into variable - Region 3 and 4.6 
	25/06/2019  | 0.3       | A.Nowak       | Add delay "ss_Delay" clearing ( 4.2 )
	28/06/2019  | 0.4       | A.Nowak       | Changing conditions for error occuring and status update
	17/07/2019  | 0.5       | L.Klar        | Status handling changed
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	23/08/2019  | 2.1       | L.Klar        | PLC ID input changed to integer, PLC ID conversion int to string added, logic to add leading zeros to PLCID added, comments simplified
	10/09/2019  | 2.2       | A.Nowak       | Move region 3 and 4 to 2, delete subregions from region 3, write comment to "ii_DesSys" variable
	20/09/2019  | 2.3       | A.Nowak       | Change data type of Status from "UDT_Status" to Struct
	01/10/2019  | 2.4       | A.Nowak       | Implementation of the new FIFO block
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	08/01/2020  | 3.1       | L.Klar        | ii_PLCID change to is_PLCID_TRAYID and ii_GIN, invalid GIN status added, destination send request input added
	13/10/2020  | 3.2       | L.Klar        | Designated system constants format changed from leading spaces to trailing
	                                        | Message trigger based on new GIN detection
	22/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – IDFWD
	    
	    IF #ii_GIN > 0 AND #ii_GIN <> #si_OldGIN
	    THEN
	        
	        #si_OldGIN := #ii_GIN;
	        
	        REGION 1.1 – FIFO header status update
	            
	            // Mode 'S' - FIFO register status update
	            "FC_Fifo"(ic_Mode := 'S',
	                      qUDT_Status => #ss_Status.FIFOStatus,
	                      qx_Error => #ss_Status.FIFOError,
	                      qx_Warning => #ss_Status.FIFOWarning,
	                      iqv_Data := #s_UDT_MessageArray,
	                      iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                      iqv_DataBuffer := #iqa_FifoData);
	            
	        END_REGION
	        
	        REGION 1.2 – Configuration check and creating error
	            
	            #ss_Status.InvalidDesSysPar := FALSE;
	            
	            // Designated system assignment
	            CASE #ii_DesSys OF
	                1:
	                    #ss_DesSys := #cs_WeightScale;                              // WeightScale - "WT_SCALE"
	                2:
	                    #ss_DesSys := #cs_XRay;                                     // X-ray - "X_RAY   "
	                3:
	                    #ss_DesSys := #cs_CameraSys;                                // Camera system - "CAMERA  "   
	                4:
	                    #ss_DesSys := #cs_LabelApplicator;                          // Label applicator - "LBL_APP "
	                5:
	                    #ss_DesSys := #cs_Sorter;                                   // Sorter - "  SORTER"
	                6:
	                    #ss_DesSys := #cs_Other;                                    // Other system - "OTHER   "
	                    
	                    // In case of designated system parameter out of range clear designated system variable and set the error bit  
	                ELSE
	                    
	                    #ss_DesSys := '';
	                    #ss_Status.InvalidDesSysPar := TRUE;
	                    
	            END_CASE;
	            
	            // GIN validation
	            #ss_Status.InvalidGIN :=
	            #ii_GIN < 1
	            OR #ii_GIN > 9999;
	            
	            // PLCID/TRAYID validation
	            #ss_Status.InvalidPLCID_TRAYID :=
	            #is_PLCID_TRAYID <> '00'
	            AND #is_PLCID_TRAYID <> '99'
	            AND #is_PLCID_TRAYID <> 'TR'
	            AND #is_PLCID_TRAYID <> '1R'
	            AND #is_PLCID_TRAYID <> '2R'
	            AND #is_PLCID_TRAYID <> '3R'
	            AND #is_PLCID_TRAYID <> '4R';
	            
	            // Delay time validation
	            #ss_Status.InvalidDelay :=
	            #ii_Delay < 0
	            OR #ii_Delay > 9999;
	            
	        END_REGION
	        
	        REGION 1.3 – IDFWD message preparation
	            
	            IF (NOT #ss_Status.FIFOError
	                AND NOT #ss_Status.InvalidDesSysPar
	                AND NOT #ss_Status.InvalidGIN
	                AND NOT #ss_Status.InvalidDelay
	                AND NOT #ss_Status.InvalidPLCID_TRAYID)
	            THEN
	                
	                IF (NOT #iqUDT_FifoHeader.Status.Full)
	                THEN
	                    
	                    // Unique MSGID
	                    "FC_UPSMsgId"(is_ActualDateTime := #is_ActualDateTime,
	                                  is_ModuleName := #is_ModuleName,
	                                  is_DeviceNumber := #is_DeviceNumber,
	                                  iqs_MSGID := #ss_MSGID,
	                                  iqdi_UniqueMsgID := #iqdi_UniqueMsgID);
	                    
	                    // PLCID/TRAYID preparation
	                    #ss_PLCIDTRAYID := '';
	                    
	                    // PLC ID integer input conversion to a character string
	                    VAL_STRG(IN := #ii_GIN,
	                             SIZE := 0,
	                             PREC := 0,
	                             FORMAT := 0,
	                             P := 1,
	                             OUT => #ss_PLCIDTRAYID);
	                    
	                    // Length of the PLCID/TRAYID character string 
	                    #si_PLCIDLen := LEN(#ss_PLCIDTRAYID);
	                    
	                    // PLCID/TRAYID character string leading zeros addition
	                    IF (#si_PLCIDLen < 4)       // PLCID length lower than 4
	                    THEN
	                        
	                        FOR #si_i := 1 TO 4 - #si_PLCIDLen DO
	                            
	                            #ss_PLCIDTRAYID := CONCAT(IN1 := '0',
	                                                      IN2 := #ss_PLCIDTRAYID);
	                            
	                        END_FOR;
	                        
	                    END_IF;
	                    
	                    // PLCID/TRAYID addition
	                    #ss_PLCIDTRAYID := INSERT(IN1 := #ss_PLCIDTRAYID, IN2 := #is_PLCID_TRAYID, P := 0);
	                    
	                    // Delay preparation
	                    #ss_Delay := '';
	                    
	                    // Delay integer input conversion to a character string
	                    VAL_STRG(IN := #ii_Delay,
	                             SIZE := 0,
	                             PREC := 0,
	                             FORMAT := 0,
	                             P := 1,
	                             OUT => #ss_Delay);
	                    
	                    // Length of the delay character string 
	                    #si_DelayLen := LEN(#ss_Delay);
	                    
	                    // Delay character string leading zeros addition
	                    IF (#si_DelayLen < 4)
	                    THEN
	                        
	                        FOR #si_i := 1 TO 4 - #si_DelayLen DO
	                            
	                            #ss_Delay := CONCAT(IN1 := '0',
	                                                IN2 := #ss_Delay);
	                            
	                        END_FOR;
	                        
	                    END_IF;
	                    
	                    // Message preparation
	                    
	                    // IDFWD message composing according to the structure: SCN,SCT,RCN,RCT,MT,MSGID,PLCID,DESSYS,DELAY{CRLF}
	                    #ss_Message := CONCAT(IN1 := #iUDT_MsgHeader.SCN,          // Sender IP address  
	                                          IN2 := #cc_DL,                        // Comma sign - ","
	                                          IN3 := #iUDT_MsgHeader.SCT,          // Sender Name   
	                                          IN4 := #cc_DL,                        // Comma sign - ","
	                                          IN5 := #iUDT_MsgHeader.RCN,          // Receiver IP address
	                                          IN6 := #cc_DL,                        // Comma sign - ","
	                                          IN7 := #iUDT_MsgHeader.RCT,          // Receiver Name  
	                                          IN8 := #cc_DL,                        // Comma sign - ","
	                                          IN9 := #cs_IDFWD,                     // Message type - "IDFWD"
	                                          IN10 := #cc_DL,                       // Comma sign - ","
	                                          IN11 := #ss_MSGID,                    // MSGID
	                                          IN12 := #cc_DL,                       // Comma sign - ","                                 
	                                          IN13 := #ss_PLCIDTRAYID,             // PLCID
	                                          IN14 := #cc_DL,                       // Comma sign - ","
	                                          IN15 := #ss_DesSys,                   // Designated system         
	                                          IN16 := #cc_DL,                       // Comma sign - ","
	                                          IN17 := #ss_Delay,                    // Delay time
	                                          IN18 := #cs_CRLF);                    // Termination signs - "$R$L"
	                    
	                    // Maximum number of the message characters
	                    #si_MaxMsgLen := "FC_GetNrOfArrayEl"(iv_Array := #s_UDT_MessageArray.Character);
	                    
	                    // Length of the complete message
	                    #si_MsgLen := LEN(#ss_Message);
	                    
	                    // Message array size validation
	                    #ss_Status.InvalidMsgArraySize := #si_MsgLen > #si_MaxMsgLen;
	                    
	                    // Message character String conversion into the message array of characters
	                    IF (NOT #ss_Status.InvalidMsgArraySize)
	                    THEN
	                        
	                        Strg_TO_Chars(Strg := #ss_Message,
	                                      pChars := 0,
	                                      Cnt => #sui_MsgArrayElNr,
	                                      Chars := #s_UDT_MessageArray.Character);
	                        
	                    END_IF;
	                    
	                    // Clearing remaining characters in the message character array
	                    IF (NOT #ss_Status.InvalidMsgArraySize)
	                    THEN
	                        
	                        // Filling up not used message character array elements with '$00' (ASCII - 16#00)
	                        FILL_BLK(IN := #cc_NULL,
	                                 COUNT := UINT_TO_ULINT(INT_TO_UINT(#si_MaxMsgLen) - #sui_MsgArrayElNr),
	                                 OUT => #s_UDT_MessageArray.Character[#sui_MsgArrayElNr]);
	                        
	                    END_IF;
	                    
	                    // Message write into a FIFO register
	                    IF (NOT #ss_Status.InvalidMsgArraySize)
	                    THEN
	                        
	                        // Mode 'W' - Write FIFO record
	                        "FC_Fifo"(ic_Mode := 'W',
	                                  qUDT_Status => #ss_Status.FIFOStatus,
	                                  qx_Error => #ss_Status.FIFOError,
	                                  qx_Warning => #ss_Status.FIFOWarning,
	                                  iqv_Data := #s_UDT_MessageArray,
	                                  iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                                  iqv_DataBuffer := #iqa_FifoData);
	                        
	                        // Message sent as a destination request 
	                        "DB_GIN".GIN[#ii_GIN].General.DestReqSend := #ix_DestinationRequest;
	                        
	                    END_IF;
	                    
	                    // In case of FIFO full, the FIFO full error bit and FIFO collective error bit are set
	                ELSE
	                    
	                    #ss_Status.FIFOError := TRUE;
	                    #ss_Status.FIFOStatus.FifoFull := TRUE;
	                    
	                END_IF;
	                
	            END_IF;
	            
	        END_REGION
	        
	        REGION 1.4 – Status
	            
	            // Parametrization collective error output
	            #qx_Error :=
	            #ss_Status.InvalidDesSysPar
	            OR #ss_Status.InvalidDelay
	            OR #ss_Status.InvalidGIN
	            OR #ss_Status.InvalidMsgArraySize
	            OR #ss_Status.FIFOError;
	            
	            // Parametrization collective warning output
	            #qx_Warning := #ss_Status.FIFOWarning;
	            
	        END_REGION
	        
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_UPSLogon"
TITLE = FB_Logon
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : UPS_SpecificCommunication
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 57
// END_ATTRIBUTES
//Function block to prepare and send UPS LOGON and FILTER messages.
   VAR_INPUT 
      iUDT_Connection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_Connection";   // Connection parameters
      iUDT_MsgHeader { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_UPSMessageHeader";   // UPS message header
      ia_MsgType { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..34] of String;   // UPS message types
      ix_ConEstablished { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TCPIP Connection established
   END_VAR

   VAR_OUTPUT 
      qx_LogonOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FILTER and LOGON messages sent
   END_VAR

   VAR 
      sFB_TSEND {InstructionName := 'TSEND'; LibVersion := '4.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TSEND;   // Siemens "TSEND" block - to send the data over TCPIP socket
      sR_TRIG_ConEstablished {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Siemens "R_Trig" - to prepare the rising edge trigger on "ix_ConEstablished" signal
      sR_TRIG_SendTrigFilter {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Siemens "R_Trig" - to prepare the Filter send trigger
      sR_TRIG_SendTrigLogon {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Siemens "R_Trig" - to prepare the LOGON send trigger
      sa_TSEND { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // TSEND block parameter structure
         Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
         Req { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      END_STRUCT;
      sa_FilterMsg { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..699] of Char;   // FILTER message character array
      sa_LogonMsg { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..34] of Char;   // LOGON message character array
      ss_Logon { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // LOGON message character string
      ss_Header { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Message header character string
      ss_Filter_1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // FILTER message part 1 character string
      ss_Filter_2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // FILTER message part 2 character string
      ss_Footer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // FILTER message footer character string
      sui_ArrayOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Offset for writing in the array
      sui_FilterArrayElNr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Number of written FILTER characters
      sui_LogonArrayElNr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Number of written LOGON characters
      si_MaxNrOfMsgTypes { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum number of message types
      si_MaxFilterLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum number of FILTER message characters
      si_MaxLogonLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum number of LOGON message characters
      si_i { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Loop counter
      sx_LogProc { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Logon procedure
      sx_FilterSent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FILTER message sent
      sx_LogonSent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // LOGON message sent
   END_VAR

   VAR CONSTANT 
      cc_DL : Char := ',';   // Comma sign
      cs_Filter : String := 'FILTER';   // Message type
      cs_Logon : String := 'LOGON';   // Message type
      cs_Pipe : String := ',|,';   // FILTER message element - ,|,
      cs_MT : String := 'MT,$'';   // FILTER message element - MT,'
      cs_Q : String := '$',=';   // FILTER message element - ',=
      cs_CRLF : String := '$R$L';   // Termination signs
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	23/08/2019  | 2.1       | K.Pokorski    | Comments simplified
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	22/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – Connection check   
	    
	    // TCIPI connection established rising edge
	    #sR_TRIG_ConEstablished(CLK := #ix_ConEstablished);
	    
	    // Logon process start
	    IF (#sR_TRIG_ConEstablished.Q)                             // Connection established rising edge
	    THEN
	        
	        #sx_LogProc := TRUE;
	        
	    END_IF;
	    
	    // Message send confirmation bits reset in case of connection lost
	    IF (NOT #ix_ConEstablished)                                 // Connection terminated 
	    THEN
	        
	        #sx_FilterSent := FALSE;
	        #sx_LogonSent := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 – Assembly FILTER message
	    
	    IF (#sx_LogProc)                                            // Logon procedure
	    THEN
	        
	        // Resetting all components of the "Filter" message
	        REGION 2.1 – Initialization
	            
	            #si_i := 0;
	            #sui_ArrayOffset := 0;
	            #sui_FilterArrayElNr := 0;
	            #ss_Header := '';
	            #ss_Filter_1 := '';
	            #ss_Filter_2 := '';
	            #ss_Footer := '';
	            
	        END_REGION
	        
	        REGION 2.2 – Maximum number of the message types array elements
	            
	            #si_MaxNrOfMsgTypes := "FC_GetNrOfArrayEl"(iv_Array := #ia_MsgType);
	            
	        END_REGION
	        
	        REGION 2.3 – Maximum number of the FILTER message array elements
	            
	            #si_MaxFilterLen := "FC_GetNrOfArrayEl"(iv_Array := #sa_FilterMsg);
	            
	        END_REGION
	        
	        // Combining all components of the FILTER message header into one character string
	        REGION 2.4 – Assembly FILTER message header
	            
	            #ss_Header := CONCAT(IN1 := #iUDT_MsgHeader.SCN,       // Sender IP address 
	                                 IN2 := #cc_DL,                     // Comma sign - ","
	                                 IN3 := #iUDT_MsgHeader.SCT,       // Sender Name   
	                                 IN4 := #cc_DL,                     // Comma sign - ","
	                                 IN5 := #cc_DL,                     // Comma sign - ","
	                                 IN6 := #cc_DL,                     // Comma sign - ","
	                                 IN7 := #cs_Filter,                 // Message type - "FILTER"
	                                 IN8 := #cc_DL);                    // Comma sign - ","
	            
	        END_REGION
	        
	        
	        REGION 2.5 – Assembly FILTER message 
	            
	            // Combining all components of the FILTER message into one character string
	            FOR #si_i := 0 TO #si_MaxNrOfMsgTypes - 1 DO
	                
	                IF (#ia_MsgType[#si_i] <> '')       // Message type isn't empty
	                THEN
	                    
	                    //  Message charater string conversion to a message array characters
	                    IF (#si_i = 0)                                                          // Loop counter equal to 0
	                    THEN
	                        
	                        #ss_Filter_1 := CONCAT(IN1 := #cs_MT,                               // FILTER message constant - "MT,'"
	                                               IN2 := #ia_MsgType[#si_i],                   // Used message type
	                                               IN3 := #cs_Q,                                // FILTER message constant - "',="
	                                               IN4 := #cc_DL);                              // Comma sign - ","
	                        
	                        // Message header character string into the character array conversion
	                        Strg_TO_Chars(Strg := #ss_Header,
	                                      pChars := 0,
	                                      Cnt => #sui_ArrayOffset,
	                                      Chars := #sa_FilterMsg);
	                        
	                        // FILTER message part 1 character string into the character array conversion
	                        Strg_TO_Chars(Strg := #ss_Filter_1,
	                                      pChars := #sui_ArrayOffset,
	                                      Cnt => #sui_FilterArrayElNr,
	                                      Chars := #sa_FilterMsg);
	                        
	                        // Handled message types addition to a filter message 
	                    ELSIF (#si_i > 0)                                                       // Loop counter is greater than 0
	                    THEN
	                        
	                        #ss_Filter_2 := CONCAT(IN1 := #cs_MT,                               // FILTER message constant - "MT,'"
	                                               IN2 := #ia_MsgType[#si_i],                   // Used message type
	                                               IN3 := #cs_Q,                                // FILTER message constant - "',="
	                                               IN4 := #cs_Pipe);                            // FILTER message constant - ",|,"
	                        
	                        // Array offset update
	                        #sui_ArrayOffset += #sui_FilterArrayElNr;
	                        
	                        // FILTER message part 2 character string into the character array conversion
	                        Strg_TO_Chars(Strg := #ss_Filter_2,
	                                      pChars := #sui_ArrayOffset,
	                                      Cnt => #sui_FilterArrayElNr,
	                                      Chars := #sa_FilterMsg);
	                        
	                    END_IF;
	                    
	                    // The message type array element is empty    
	                ELSE
	                    
	                    EXIT;
	                    
	                END_IF;
	                
	            END_FOR;
	            
	        END_REGION
	        
	        REGION 2.6 – Assembly FILTER message footer
	            
	            // FILTER footer creation
	            #ss_Footer := #cs_CRLF;
	            
	            // Array offset update
	            #sui_ArrayOffset += #sui_FilterArrayElNr;
	            
	            // FILTER footer character string into the character array conversion
	            Strg_TO_Chars(Strg := #ss_Footer,
	                          pChars := #sui_ArrayOffset,
	                          Cnt => #sui_FilterArrayElNr,
	                          Chars := #sa_FilterMsg);
	            
	        END_REGION
	        
	        REGION 2.7 – Clearing remaining characters in the message character array
	            
	            // Filling up not used FILTER character array elements with '$00' (ASCII - 16#00)
	            FILL_BLK(IN := '$00',
	                     COUNT := UINT_TO_ULINT(INT_TO_UINT(#si_MaxFilterLen) -
	                                            #sui_FilterArrayElNr -
	                                            #sui_ArrayOffset),
	                     OUT => #sa_FilterMsg[#sui_ArrayOffset + #sui_FilterArrayElNr]);
	            
	        END_REGION
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 – Assembly LOGON message
	    
	    IF (#sx_LogProc)        // Logon procedure
	    THEN
	        
	        REGION 3.1 – Initialization
	            
	            #ss_Logon := '';
	            
	        END_REGION
	        
	        REGION 3.2 – Maximum number of the LOGON message array elements
	            
	            #si_MaxLogonLen := "FC_GetNrOfArrayEl"(iv_Array := #sa_LogonMsg);
	            
	        END_REGION
	        
	        REGION 3.3 – Assembly LOGON message 
	            
	            #ss_Logon := CONCAT(IN1 := #iUDT_MsgHeader.SCN,        // Sender IP address      
	                                IN2 := #cc_DL,                      // Comma sign - ","
	                                IN3 := #iUDT_MsgHeader.SCT,        // Sender Name
	                                IN4 := #cc_DL,                      // Comma sign - ","
	                                IN5 := #cc_DL,                      // Comma sign - ","
	                                IN6 := #cc_DL,                      // Comma sign - ","
	                                IN7 := #cs_Logon,                   // Message type - "LOGON"
	                                IN8 := #cs_CRLF);                   // Termination signs - "$R$L"
	            
	            // LOGON message character string into the character array conversion
	            Strg_TO_Chars(Strg := #ss_Logon,
	                          pChars := 0,
	                          Cnt => #sui_LogonArrayElNr,
	                          Chars := #sa_LogonMsg);
	            
	        END_REGION
	        
	        REGION 3.4 – Clearing remaining characters in the message character array
	            
	            // Filling up not used LOGON character array elements with '$00' (ASCII - 16#00)
	            FILL_BLK(IN := '$00',
	                     COUNT := UINT_TO_ULINT(INT_TO_UINT(#si_MaxLogonLen) -
	                                            #sui_LogonArrayElNr),
	                     OUT => #sa_LogonMsg[#sui_LogonArrayElNr]);
	            
	        END_REGION
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 – Send FILTER message
	    
	    REGION 4.1 – Send trigger preparation
	        
	        #sR_TRIG_SendTrigFilter(CLK := NOT #sa_TSEND.#Busy
	                                AND #ix_ConEstablished
	                                AND #sx_LogProc
	                                AND NOT #sx_FilterSent
	                                AND NOT #sx_LogonSent,
	                                Q => #sa_TSEND.#Req);
	        
	    END_REGION
	    
	    REGION 4.2 – Send message
	        
	        IF (NOT #sx_FilterSent               // FILTER message not sent
	            AND NOT #sx_LogonSent)           // LOGON message not sent    
	        THEN
	            
	            // FILTER message send
	            #sFB_TSEND(REQ := #sa_TSEND.#Req,
	                       ID := #iUDT_Connection.ID,
	                       LEN := #sui_ArrayOffset + #sui_FilterArrayElNr,
	                       DONE => #sa_TSEND.Done,
	                       BUSY => #sa_TSEND.Busy,
	                       ERROR => #sa_TSEND.Error,
	                       STATUS => #sa_TSEND.Status,
	                       DATA := #sa_FilterMsg);
	            
	            // FILTER sent
	            IF (#sa_TSEND.#Done)        // Operation is done
	            THEN
	                
	                #sx_FilterSent := TRUE;
	                
	            END_IF;
	            
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 5 – LOGON message send
	    
	    REGION 5.1 – Send trigger preparation
	        
	        #sR_TRIG_SendTrigLogon(CLK := NOT #sa_TSEND.Busy       // TSEND block not busy
	                               AND #ix_ConEstablished          // Connection established
	                               AND #sx_LogProc                 // Logon procedure 
	                               AND #sx_FilterSent              // FILTER message is sent
	                               AND NOT #sx_LogonSent,          // LOGON message is not sent
	                               Q => #sa_TSEND.Req);
	        
	    END_REGION
	    
	    REGION 5.2 – Send message
	        
	        IF (#sx_FilterSent              // FILTER mseesge is sent         
	            AND NOT #sx_LogonSent)      // LOGON message is not sent              
	        THEN
	            // LOGON message send
	            #sFB_TSEND(REQ := #sa_TSEND.#Req,
	                       ID := #iUDT_Connection.ID,
	                       LEN := #sui_LogonArrayElNr,
	                       DONE => #sa_TSEND.#Done,
	                       BUSY => #sa_TSEND.#Busy,
	                       ERROR => #sa_TSEND.#Error,
	                       STATUS => #sa_TSEND.#Status,
	                       DATA := #sa_LogonMsg);
	            
	            // LOGON sent
	            IF (#sa_TSEND.#Done)        // Operation is done
	            THEN
	                
	                #sx_LogonSent := TRUE;
	                
	            END_IF;
	            
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 6 – Reset Logon procedure
	    
	    IF (#sx_FilterSent               // FILTER message sent
	        AND #sx_LogonSent)           // LOGON message sent    
	    THEN
	        
	        #sx_LogProc := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 7 – Write outputs
	    
	    #qx_LogonOk :=
	    #sx_FilterSent            // FILTER message sent 
	    AND #sx_LogonSent;        // LOGON message sent
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_UPSPLCInfo"
TITLE = FB_PLCInfo
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : UPS_SpecificCommunication
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 58
// END_ATTRIBUTES
//Function block to prepare and send the UPS PLCINFO message. 
   VAR_INPUT 
      iUDT_MsgHeader { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_UPSMessageHeader";   // UPS message header
      iUDT_MachStat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_UPSMACHSTAT";   // Machine status
      iUDT_ExternalReaders { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..15] of "UDT_UPSExternalReader";   // Active camera
      is_ActualDateTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[23];   // Actual date and time
      is_ModuleName { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[2] := 'AB';   // Module type
      is_DeviceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[4] := 'abcd';   // Device number
      iudi_Speed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Conveyor speed [ft/min]
      iudi_SysRevs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Number of system revolutions since sort start
      ii_SendTimeInterval { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Send time interval [ms]
      ix_ExternalTrigger { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External trigger to send a message
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective error output
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective warning output
   END_VAR

   VAR_IN_OUT 
      iqUDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqa_FifoData : Array[*] of "UDT_Message";   // FIFO data
      iqdi_UniqueMsgID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Unique message ID integer
   END_VAR

   VAR 
      sUDT_ActiveCamera { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Array[0..15] of "UDT_UPSExternalReader";   // Active camera status
      sa_MachStatArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..15] of Byte;   // Machine status array
      sR_TRIG_ExternaReq {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Siemens "R_TRIG" - to prepare the rising edge trigger on "ix_ExternalTrigger" signal
      sF_TRIG_ExternalReq {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Siemens "F_TRIG" - to prepare the falling edge trigger on "ix_ExternalTrigger" signal
      sFB_SendPulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Pulse";   // MHS "FB_Pulse" block - to generate preset pulse signal
      sUDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Message";   // Message character array
      sa_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";   // FIFO status structure
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO error
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO warning
         InvalidSysRevs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid system revolutions number
         InvalidSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid conveyor speed
         InvalidMsgArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid message array size
      END_STRUCT;
      ss_MsgID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[32];   // Unique message ID
      ss_SysRevs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[4];   // Number of system revolutions since sort start
      ss_Speed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[5];   // Speed
      ss_CameraState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[2];   // Camera state character string
      ss_Header { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Header character string
      ss_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Message character string
      ss_ActiveCamera { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Active camera character string
      ss_MachStat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Machine status character string
      ss_MachStatPart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Part of the machine status character string
      sui_MsgArrayElNr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Number of written message characters
      sui_ArrayOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Offset for writing in the array
      si_MaxMsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum message length
      si_MsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Message character string length
      si_SysRevsLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // System revolutions character string length
      si_i { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Loop counter
      sx_NewCameraState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Camera state changed
   END_VAR

   VAR CONSTANT 
      cc_NULL : Char := '$00';   // NULL sign
      cc_Dash : Char := '-';   // Dash sign
      cc_DL : Char := ',';   // Comma sign
      cs_CamOn : String := '|1';   // Camera state - True
      cs_CamOff : String := '|0';   // Camera state - False
      cs_PLCInfo : String := 'PLCINFO';   // Message type
      cs_CRLF : String := '$R$L';   // Termination signs
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	13/06/2019  | 0.2       | A.Nowak       | Replacement of instruction if for direct write into variable - Region 2 and 3 and 4.10 
	28/06/2019  | 0.4       | A.Nowak       | Changing conditions for error occuring and status update
	18/07/2019  | 0.5       | L.Klar        | Status handling changed
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	19/08/2019  | 2.1       | L.Klar        | Cyclic and event message handling added
	23/08/2019  | 2.2       | K.Pokorski    | Bool to byte block changed to direct reference, comments simplified
	20/09/2019  | 2.3       | M.Kurpiers    | Change - status to struct
	01/10/2019  | 2.4       | A.Nowak       | Implementation of the new FIFO block
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	22/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	02/05/2024  | 4.1       | J.Majer      | Datatype conversions changed from automatic to explicit, to accomodate IEC 61131-3 standard
	*)
	
	REGION 1 – Message send trigger
	    
	    // Custom pulse to create cyclic trigger
	    #sFB_SendPulse(iudi_PulseTime := #ii_SendTimeInterval);
	    
	    // Camera state check 
	    #sx_NewCameraState := #sUDT_ActiveCamera <> #iUDT_ExternalReaders;
	    #sUDT_ActiveCamera := #iUDT_ExternalReaders;                             // Move new camera state to block memory
	    
	    // Preparation of the rising and falling edge on the external request to send signal
	    #sR_TRIG_ExternaReq(CLK := #ix_ExternalTrigger);
	    #sF_TRIG_ExternalReq(CLK := #ix_ExternalTrigger);
	    
	END_REGION
	
	REGION 2 – PLCInfo message request
	    
	    // Condition of sending the message
	    IF (#sFB_SendPulse.qx_Pulse                // Cyclic trigger
	        OR #sx_NewCameraState                   // Camera state changed
	        OR #sR_TRIG_ExternaReq.Q               // External trigger rising edge
	        OR #sF_TRIG_ExternalReq.Q)             // External trigger falling edge
	    THEN
	        
	        REGION 2.1 – FIFO header status update
	            
	            // Mode 'S' - FIFO register status update
	            "FC_Fifo"(ic_Mode := 'S',
	                      qUDT_Status => #sa_Status.FIFOStatus,
	                      qx_Error => #sa_Status.FIFOError,
	                      qx_Warning => #sa_Status.FIFOWarning,
	                      iqv_Data := #sUDT_MessageArray,
	                      iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                      iqv_DataBuffer := #iqa_FifoData);
	            
	            
	        END_REGION
	        
	        REGION 2.2 – Conveyor speed validation
	            
	            #sa_Status.InvalidSpeed :=
	            #iudi_Speed < 0
	            OR #iudi_Speed > 99999;
	            
	        END_REGION
	        
	        REGION 2.3 – System revolutions number validation
	            
	            #sa_Status.InvalidSysRevs :=
	            #iudi_SysRevs < 0
	            OR #iudi_SysRevs > 9999;
	            
	        END_REGION
	        
	        REGION 2.4 – PLCINFO message preparation
	            
	            IF (NOT #sa_Status.InvalidSysRevs                                // System revolutions number is valid 
	                AND NOT #sa_Status.InvalidSpeed                              // Conveyor speed is valid 
	                AND NOT #sa_Status.FIFOError)                                // No FIFO errors
	            THEN
	                
	                IF (NOT #iqUDT_FifoHeader.Status.Full)                      // FIFO isn't full
	                THEN
	                    
	                    // Unique MSGID
	                    "FC_UPSMsgId"(is_ActualDateTime := #is_ActualDateTime,
	                                  is_ModuleName := #is_ModuleName,
	                                  is_DeviceNumber := #is_DeviceNumber,
	                                  iqs_MSGID := #ss_MsgID,
	                                  iqdi_UniqueMsgID := #iqdi_UniqueMsgID);
	                    
	                    
	                    // Conveyor speed conversion
	                    VAL_STRG(IN := #iudi_Speed,
	                             SIZE := 0,
	                             PREC := 0,
	                             FORMAT := 0,
	                             P := 1,
	                             OUT => #ss_Speed);
	                    
	                    // Machine status conversion
	                    #sa_MachStatArray[0].%X0 := #iUDT_MachStat."OpsNormal".StopMCP;                     // MCP Stop PB          // Byte 1, Bit 0 - Operator Stop MCP Panel
	                    #sa_MachStatArray[0].%X1 := #iUDT_MachStat."OpsNormal".StopRemoteCon1;              // SSP         // Byte 1, Bit 1 - Operator Stop Remote Console 1
	                    #sa_MachStatArray[0].%X2 := #iUDT_MachStat."OpsNormal".StopRemoteCon2;              // SSP         // Byte 1, Bit 2 - Operator Stop Remote Console 2
	                    #sa_MachStatArray[0].%X3 := #iUDT_MachStat."OpsNormal".BuildingStop;                // MCP Estop         // Byte 1, Bit 3 - Building Stop via HMI
	                    #sa_MachStatArray[0].%X4 := #iUDT_MachStat."OpsNormal".BuildingBreak;               // false         // Byte 1, Bit 4 - Building Break Time via HMI
	                    #sa_MachStatArray[0].%X5 := #iUDT_MachStat."OpsNormal".PowerSaveShutdown;           // system energy save       // Byte 1, Bit 5 - Power Save Shutdown
	                    #sa_MachStatArray[0].%X6 := #iUDT_MachStat."OpsNormal".SorterNotAtSpeed;            //False        // Byte 1, Bit 6 - Sorter Not at speed
	                    #sa_MachStatArray[0].%X7 := #iUDT_MachStat."OpsNormal".MaintenanceSysMode;          // Manual      // Byte 1, Bit 7 - System in Maintenance Mode
	                    
	                    #sa_MachStatArray[1].%X0 := #iUDT_MachStat."OpsNormal".Spare_8;                     // Byte 2, Bit 0 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[1].%X1 := #iUDT_MachStat."OpsNormal".Spare_9;                     // Byte 2, Bit 1 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[1].%X2 := #iUDT_MachStat."OpsNormal".Spare_10;                    // Byte 2, Bit 2 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[1].%X3 := #iUDT_MachStat."OpsNormal".Spare_11;                    // Byte 2, Bit 3 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[1].%X4 := #iUDT_MachStat."OpsNormal".Spare_12;                    // Byte 2, Bit 4 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[1].%X5 := #iUDT_MachStat."OpsNormal".Spare_13;                    // Byte 2, Bit 5 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[1].%X6 := #iUDT_MachStat."OpsNormal".Spare_14;                    // Byte 2, Bit 6 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[1].%X7 := #iUDT_MachStat."OpsNormal".Spare_15;                    // Byte 2, Bit 7 - Future / or Machine Specific (To be identified)
	                    
	                    
	                    #sa_MachStatArray[2].%X0 := #iUDT_MachStat."OpsNormal".Spare_16;                    // Byte 3, Bit 0 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[2].%X1 := #iUDT_MachStat."OpsNormal".Spare_17;                    // Byte 3, Bit 1 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[2].%X2 := #iUDT_MachStat."OpsNormal".Spare_18;                    // Byte 3, Bit 2 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[2].%X3 := #iUDT_MachStat."OpsNormal".Spare_19;                    // Byte 3, Bit 3 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[2].%X4 := #iUDT_MachStat."OpsNormal".Spare_20;                    // Byte 3, Bit 4 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[2].%X5 := #iUDT_MachStat."OpsNormal".Spare_21;                    // Byte 3, Bit 5 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[2].%X6 := #iUDT_MachStat."OpsNormal".Spare_22;                    // Byte 3, Bit 6 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[2].%X7 := #iUDT_MachStat."OpsNormal".Spare_23;                    // Byte 3, Bit 7 - Future / or Machine Specific (To be identified)
	                    
	                    
	                    #sa_MachStatArray[3].%X0 := #iUDT_MachStat."OpsNormal".Spare_24;                    // Byte 4, Bit 0 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[3].%X1 := #iUDT_MachStat."OpsNormal".Spare_25;                    // Byte 4, Bit 1 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[3].%X2 := #iUDT_MachStat."OpsNormal".Spare_26;                    // Byte 4, Bit 2 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[3].%X3 := #iUDT_MachStat."OpsNormal".Spare_27;                    // Byte 4, Bit 3 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[3].%X4 := #iUDT_MachStat."OpsNormal".Spare_28;                    // Byte 4, Bit 4 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[3].%X5 := #iUDT_MachStat."OpsNormal".Spare_29;                    // Byte 4, Bit 5 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[3].%X6 := #iUDT_MachStat."OpsNormal".Spare_30;                    // Byte 4, Bit 6 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[3].%X7 := #iUDT_MachStat."OpsNormal".Spare_31;                    // Byte 4, Bit 7 - Future / or Machine Specific (To be identified)
	                    
	                    
	                    #sa_MachStatArray[4].%X0 := #iUDT_MachStat.SafetyFaults.BuildingEStop;              // comm false           // Byte 5, Bit 0 - Building Emergency Stop
	                    #sa_MachStatArray[4].%X1 := #iUDT_MachStat.SafetyFaults.SystemEStop;                // MCP Estop          // Byte 5, Bit 1 - System Emergency Stop
	                    #sa_MachStatArray[4].%X2 := #iUDT_MachStat.SafetyFaults.EmerPullCord;               // Byte 5, Bit 2 - Emergency Pull Cord
	                    #sa_MachStatArray[4].%X3 := #iUDT_MachStat.SafetyFaults.PhotoEyeBlock1;             // Byte 5, Bit 3 - Safety Photo Eye Blocked (Long Range Photo Eye) 1
	                    #sa_MachStatArray[4].%X4 := #iUDT_MachStat.SafetyFaults.PlatformLockout1;           // Byte 5, Bit 4 - Platform Lockout 1
	                    #sa_MachStatArray[4].%X5 := #iUDT_MachStat.SafetyFaults.PlatformLockout2;           // Byte 5, Bit 5 - Platform Lockout 2
	                    #sa_MachStatArray[4].%X6 := #iUDT_MachStat.SafetyFaults.PhotoEyeBlock2;             // Byte 5, Bit 6 - Safety Photo Eye Blocked (Long Range Photo Eye) 2
	                    #sa_MachStatArray[4].%X7 := #iUDT_MachStat.SafetyFaults.PhotoEyeBlock3;             // Byte 5, Bit 7 - Safety Photo Eye Blocked (Long Range Photo Eye) 3
	                    
	                    
	                    #sa_MachStatArray[5].%X0 := #iUDT_MachStat.SafetyFaults.Spare_8;                    // Byte 6, Bit 0 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[5].%X1 := #iUDT_MachStat.SafetyFaults.Spare_9;                    // Byte 6, Bit 1 - Future / OR Machine Specific (TO be identified)
	                    #sa_MachStatArray[5].%X2 := #iUDT_MachStat.SafetyFaults.Spare_10;                   // Byte 6, Bit 2 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[5].%X3 := #iUDT_MachStat.SafetyFaults.Spare_11;                   // Byte 6, Bit 3 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[5].%X4 := #iUDT_MachStat.SafetyFaults.Spare_12;                   // Byte 6, Bit 4 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[5].%X5 := #iUDT_MachStat.SafetyFaults.Spare_13;                   // Byte 6, Bit 5 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[5].%X6 := #iUDT_MachStat.SafetyFaults.Spare_14;                   // Byte 6, Bit 6 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[5].%X7 := #iUDT_MachStat.SafetyFaults.Spare_15;                   // Byte 6, Bit 7 - Future / or Machine Specific (To be identified)
	                    
	                    
	                    #sa_MachStatArray[6].%X0 := #iUDT_MachStat.SafetyFaults.Spare_16;                   // Byte 7, Bit 0 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[6].%X1 := #iUDT_MachStat.SafetyFaults.Spare_17;                   // Byte 7, Bit 1 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[6].%X2 := #iUDT_MachStat.SafetyFaults.Spare_18;                   // Byte 7, Bit 2 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[6].%X3 := #iUDT_MachStat.SafetyFaults.Spare_19;                   // Byte 7, Bit 3 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[6].%X4 := #iUDT_MachStat.SafetyFaults.Spare_20;                   // Byte 7, Bit 4 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[6].%X5 := #iUDT_MachStat.SafetyFaults.Spare_21;                   // Byte 7, Bit 5 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[6].%X6 := #iUDT_MachStat.SafetyFaults.Spare_22;                   // Byte 7, Bit 6 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[6].%X7 := #iUDT_MachStat.SafetyFaults.Spare_23;                   // Byte 7, Bit 7 - Future / or Machine Specific (To be identified)
	                    
	                    
	                    #sa_MachStatArray[7].%X0 := #iUDT_MachStat.SafetyFaults.Spare_24;                   // Byte 8, Bit 0 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[7].%X1 := #iUDT_MachStat.SafetyFaults.Spare_25;                   // Byte 8, Bit 1 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[7].%X2 := #iUDT_MachStat.SafetyFaults.Spare_26;                   // Byte 8, Bit 2 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[7].%X3 := #iUDT_MachStat.SafetyFaults.Spare_27;                   // Byte 8, Bit 3 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[7].%X4 := #iUDT_MachStat.SafetyFaults.Spare_28;                   // Byte 8, Bit 4 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[7].%X5 := #iUDT_MachStat.SafetyFaults.Spare_29;                   // Byte 8, Bit 5 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[7].%X6 := #iUDT_MachStat.SafetyFaults.Spare_30;                   // Byte 8, Bit 6 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[7].%X7 := #iUDT_MachStat.SafetyFaults.Spare_31;                   // Byte 8, Bit 7 - Future / or Machine Specific (To be identified)
	                    
	                    
	                    #sa_MachStatArray[8].%X0 := #iUDT_MachStat.SystemFaults.PLCRackFault;               // RIO Error     // Byte 9, Bit 0 - PLC Rack Fault
	                    #sa_MachStatArray[8].%X1 := #iUDT_MachStat.SystemFaults.EncoderFault;               // Byte 9, Bit 1 - Encoder Fault
	                    #sa_MachStatArray[8].%X2 := #iUDT_MachStat.SystemFaults.TipperOrDiverterFault;      // Byte 9, Bit 2 - Tipper / Diverter Fault
	                    #sa_MachStatArray[8].%X3 := #iUDT_MachStat.SystemFaults.TCPConFail;                 // Byte 9, Bit 3 - TCP Connection Failure
	                    #sa_MachStatArray[8].%X4 := #iUDT_MachStat.SystemFaults.SensorJam;                  // Byte 9, Bit 4 - Package Detect Sensor Jam
	                    #sa_MachStatArray[8].%X5 := #iUDT_MachStat.SystemFaults.CamOrScanFail;              // health        // Byte 9, Bit 5 - Camera / Scanner Failure
	                    #sa_MachStatArray[8].%X6 := #iUDT_MachStat.SystemFaults.InductPEJam;                // Byte 9, Bit 6 - Induct Photo Eye Jam
	                    #sa_MachStatArray[8].%X7 := #iUDT_MachStat.SystemFaults.SortVerificationPEJam;      // Byte 9, Bit 7 - Sort Verification Photo Eye Jam
	                    
	                    
	                    #sa_MachStatArray[9].%X0 := #iUDT_MachStat.SystemFaults.TakeAwayConvPEJam;          // Byte 10, Bit 0 - Take Away Conveyor Photo Eye Jam
	                    #sa_MachStatArray[9].%X1 := #iUDT_MachStat.SystemFaults.SorterMechFault;            // Byte 10, Bit 1 - Sorter Mechanical Fault
	                    #sa_MachStatArray[9].%X2 := #iUDT_MachStat.SystemFaults.Spare_10;                   // Byte 10, Bit 2 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[9].%X3 := #iUDT_MachStat.SystemFaults.SorterJam;                  // Byte 10, Bit 3 - Sorter Jam (Logical Failure)
	                    #sa_MachStatArray[9].%X4 := #iUDT_MachStat.SystemFaults.InductPCAlignmentError;     // Byte 10, Bit 4 - Induct Photo Cell Alignment Error
	                    #sa_MachStatArray[9].%X5 := #iUDT_MachStat.SystemFaults.MotorFault;                 // Byte 10, Bit 5 - Motor Fault
	                    #sa_MachStatArray[9].%X6 := #iUDT_MachStat.SystemFaults.PowerFault;                 // PDP                // Byte 10, Bit 6 - Power Fault
	                    #sa_MachStatArray[9].%X7 := #iUDT_MachStat.SystemFaults.Spare_15;                   // Byte 10, Bit 7 - Future / or Machine Specific (To be identified)
	                    
	                    
	                    #sa_MachStatArray[10].%X0 := #iUDT_MachStat.SystemFaults.IOComError;                // Byte 11, Bit 0 - I/O Communications Error
	                    #sa_MachStatArray[10].%X1 := #iUDT_MachStat.SystemFaults.RemoteIOComError;          // Byte 11, Bit 1 - Remote I/O Communications Error
	                    #sa_MachStatArray[10].%X2 := #iUDT_MachStat.SystemFaults.XLeChatComError;           // Byte 11, Bit 2 - XLe chat Communications Error
	                    #sa_MachStatArray[10].%X3 := #iUDT_MachStat.SystemFaults.SerialComError;            // Byte 11, Bit 3 - Serial Communications Error
	                    #sa_MachStatArray[10].%X4 := #iUDT_MachStat.SystemFaults.SubsystemError;            // camera error           // Byte 11, Bit 4 - Subsystem Error (Scale, Camera, etc…)
	                    #sa_MachStatArray[10].%X5 := #iUDT_MachStat.SystemFaults.VDFFault;                  // Byte 11, Bit 5 - VDF Fault
	                    #sa_MachStatArray[10].%X6 := #iUDT_MachStat.SystemFaults.SystemResetInitiated;      // Byte 11, Bit 6 - System Reset Initiated
	                    #sa_MachStatArray[10].%X7 := #iUDT_MachStat.SystemFaults.PFCStopMode;               // Byte 11, Bit 7 - PFC not in Run Mode
	                    
	                    
	                    #sa_MachStatArray[11].%X0 := #iUDT_MachStat.SystemFaults.NoHitPoints;               // Byte 12, Bit 0 - No Hit points / Divert Set Points found
	                    #sa_MachStatArray[11].%X1 := #iUDT_MachStat.SystemFaults.MissingTraysDetected;      // Byte 12, Bit 1 - Missing Trays Detected
	                    #sa_MachStatArray[11].%X2 := #iUDT_MachStat.SystemFaults.DataFault;                 // Byte 12, Bit 2 - Data Fault, X number of sequential missing valid SORT messages
	                    #sa_MachStatArray[11].%X3 := #iUDT_MachStat.SystemFaults.Spare_27;                  // Byte 12, Bit 3 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[11].%X4 := #iUDT_MachStat.SystemFaults.Spare_28;                  // Byte 12, Bit 4 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[11].%X5 := #iUDT_MachStat.SystemFaults.Spare_29;                  // Byte 12, Bit 5 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[11].%X6 := #iUDT_MachStat.SystemFaults.Spare_30;                  // Byte 12, Bit 6 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[11].%X7 := #iUDT_MachStat.SystemFaults.Spare_31;                  // Byte 12, Bit 7 - Future / or Machine Specific (To be identified)
	                    
	                    
	                    #sa_MachStatArray[12].%X0 := #iUDT_MachStat.OtherFaults.ConsoleDisconnect;          // Byte 13, Bit 0 - Console Disconnect
	                    #sa_MachStatArray[12].%X1 := #iUDT_MachStat.OtherFaults.PLCChassisPower;            // Byte 13, Bit 1 - PLC Chassis Power
	                    #sa_MachStatArray[12].%X2 := #iUDT_MachStat.OtherFaults.SystemInputPower;           // Byte 13, Bit 2 - System Input Power
	                    #sa_MachStatArray[12].%X3 := #iUDT_MachStat.OtherFaults.SystemPowerOutput;          // Byte 13, Bit 3 - System Output Power
	                    #sa_MachStatArray[12].%X4 := #iUDT_MachStat.OtherFaults.DiverterTipperPower;        // Byte 13, Bit 4 - Diverter / Tipper Power
	                    #sa_MachStatArray[12].%X5 := #iUDT_MachStat.OtherFaults.VFDServoFault;              // Byte 13, Bit 5 - VFD / Servo Fault
	                    #sa_MachStatArray[12].%X6 := #iUDT_MachStat.OtherFaults.MotorStarterFault;          // Byte 13, Bit 6 - Motor Starter Fault
	                    #sa_MachStatArray[12].%X7 := #iUDT_MachStat.OtherFaults.PLCFault;                   // Byte 13, Bit 7 - PLC Fault
	                    
	                    
	                    #sa_MachStatArray[13].%X0 := #iUDT_MachStat.OtherFaults.Spare_8;                    // Byte 14, Bit 0 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[13].%X1 := #iUDT_MachStat.OtherFaults.Spare_9;                    // Byte 14, Bit 1 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[13].%X2 := #iUDT_MachStat.OtherFaults.Spare_10;                   // Byte 14, Bit 2 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[13].%X3 := #iUDT_MachStat.OtherFaults.Spare_11;                   // Byte 14, Bit 3 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[13].%X4 := #iUDT_MachStat.OtherFaults.Spare_12;                   // Byte 14, Bit 4 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[13].%X5 := #iUDT_MachStat.OtherFaults.Spare_13;                   // Byte 14, Bit 5 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[13].%X6 := #iUDT_MachStat.OtherFaults.Spare_14;                   // Byte 14, Bit 6 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[13].%X7 := #iUDT_MachStat.OtherFaults.Spare_15;                   // Byte 14, Bit 7 - Future / or Machine Specific (To be identified)
	                    
	                    
	                    #sa_MachStatArray[14].%X0 := #iUDT_MachStat.OtherFaults.Spare_16;                   // Byte 15, Bit 0 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[14].%X1 := #iUDT_MachStat.OtherFaults.Spare_17;                   // Byte 15, Bit 1 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[14].%X2 := #iUDT_MachStat.OtherFaults.Spare_18;                   // Byte 15, Bit 2 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[14].%X3 := #iUDT_MachStat.OtherFaults.Spare_19;                   // Byte 15, Bit 3 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[14].%X4 := #iUDT_MachStat.OtherFaults.Spare_20;                   // Byte 15, Bit 4 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[14].%X5 := #iUDT_MachStat.OtherFaults.Spare_21;                   // Byte 15, Bit 5 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[14].%X6 := #iUDT_MachStat.OtherFaults.Spare_22;                   // Byte 15, Bit 6 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[14].%X7 := #iUDT_MachStat.OtherFaults.Spare_23;                   // Byte 15, Bit 7 - Future / or Machine Specific (To be identified)
	                    
	                    
	                    #sa_MachStatArray[15].%X0 := #iUDT_MachStat.OtherFaults.Spare_24;                   // Byte 16, Bit 0 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[15].%X1 := #iUDT_MachStat.OtherFaults.Spare_25;                   // Byte 16, Bit 1 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[15].%X2 := #iUDT_MachStat.OtherFaults.Spare_26;                   // Byte 16, Bit 2 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[15].%X3 := #iUDT_MachStat.OtherFaults.Spare_27;                   // Byte 16, Bit 3 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[15].%X4 := #iUDT_MachStat.OtherFaults.Spare_28;                   // Byte 16, Bit 4 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[15].%X5 := #iUDT_MachStat.OtherFaults.Spare_29;                   // Byte 16, Bit 5 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[15].%X6 := #iUDT_MachStat.OtherFaults.Spare_30;                   // Byte 16, Bit 6 - Future / or Machine Specific (To be identified)
	                    #sa_MachStatArray[15].%X7 := #iUDT_MachStat.OtherFaults.Spare_31;                   // Byte 16, Bit 7 - Future / or Machine Specific (To be identified)
	                    
	                    
	                    // Machine status character string clearing
	                    #ss_MachStat := '';
	                    
	                    // Machine status bytes conversion to character string
	                    FOR #si_i := 0 TO 15 DO
	                        
	                        #ss_MachStatPart := '';                                                         // Machine status part of the character string clearing    
	                        
	                        VAL_STRG(IN := BYTE_TO_USINT(#sa_MachStatArray[#si_i]),                                        // Machine status byte conversion to string          
	                                 SIZE := 0,
	                                 PREC := 0,
	                                 FORMAT := 0,
	                                 P := 1,
	                                 OUT => #ss_MachStatPart);
	                        
	                        // MACHSTAT character string building
	                        IF (#si_i < 15)                                                                 // Loop counter lower than 15
	                        THEN
	                            
	                            #ss_MachStat := CONCAT(IN1 := #ss_MachStat,
	                                                   IN2 := #ss_MachStatPart,
	                                                   IN3 := #cc_Dash);
	                            
	                        ELSE
	                            
	                            #ss_MachStat := CONCAT(IN1 := #ss_MachStat,
	                                                   IN2 := #ss_MachStatPart);
	                            
	                        END_IF;
	                        
	                    END_FOR;
	                    
	                    // System revolutions number preparation
	                    
	                    // System revolutions number character string clearing
	                    #ss_SysRevs := '';
	                    
	                    // System revolutions number integer input conversion to a character string
	                    VAL_STRG(IN := #iudi_SysRevs,
	                             SIZE := 0,
	                             PREC := 0,
	                             FORMAT := 0,
	                             P := 1,
	                             OUT => #ss_SysRevs);
	                    
	                    // Length of the system revolutions number character string 
	                    #si_SysRevsLen := LEN(#ss_SysRevs);
	                    
	                    // System revolutions number character string leading zeros addition
	                    IF (#si_SysRevsLen < 4)             // System revolutions character string length lower than 4
	                    THEN
	                        
	                        FOR #si_i := 1 TO 4 - #si_SysRevsLen DO
	                            
	                            #ss_SysRevs := CONCAT(IN1 := '0',
	                                                  IN2 := #ss_SysRevs);
	                            
	                        END_FOR;
	                        
	                    END_IF;
	                    
	                    // Active cameras
	                    
	                    // Active cameras character string clearing
	                    #ss_ActiveCamera := '';
	                    
	                    
	                    // Active cameras character string building 
	                    // If the IP address of the camera is not empty, the proper string with its state is prepared.
	                    FOR #si_i := 0 TO 9 DO
	                        
	                        IF (#iUDT_ExternalReaders[#si_i].IPAddress <> '')      // Camera adres isn't empty
	                        THEN
	                            
	                            IF (#iUDT_ExternalReaders[#si_i].State)            // State on true
	                            THEN
	                                
	                                #ss_CameraState := #cs_CamOn;
	                                
	                            ELSE
	                                
	                                #ss_CameraState := #cs_CamOff;
	                                
	                            END_IF;
	                            
	                            IF (#si_i = 0)          // Loop counter equal to 0
	                            THEN
	                                
	                                #ss_ActiveCamera := CONCAT(IN1 := #ss_ActiveCamera,                                 // Active camera
	                                                           IN2 := #iUDT_ExternalReaders[#si_i].IPAddress,           // Camera IP address
	                                                           IN3 := #ss_CameraState);                                 // Camera state
	                                
	                            ELSE
	                                
	                                #ss_ActiveCamera := CONCAT(IN1 := #ss_ActiveCamera,                                 // Active camera
	                                                           IN2 := #cc_Dash,                                         // Dash sign - "-"
	                                                           IN3 := #iUDT_ExternalReaders[#si_i].IPAddress,           // Camera IP address
	                                                           IN4 := #ss_CameraState);                                 // Camera state
	                                
	                            END_IF;
	                            
	                        END_IF;
	                        
	                    END_FOR;
	                    
	                    // PLCINFO message composing according to the structure: SCN,SCT,RCN,RCT,MT,MSGID,SPEED,MACHSTAT,SYSREVS,ACTIVECAMERA {CRLF}
	                    #ss_Header := CONCAT(IN1 := #iUDT_MsgHeader.SCN,        // Sender IP address 
	                                         IN2 := #cc_DL,                     // Comma sign - ","
	                                         IN3 := #iUDT_MsgHeader.SCT,        // Sender Name   
	                                         IN4 := #cc_DL,                     // Comma sign - ","
	                                         IN5 := #iUDT_MsgHeader.RCN,        // Receiver IP address
	                                         IN6 := #cc_DL,                     // Comma sign - ","
	                                         IN7 := #iUDT_MsgHeader.RCT,        // Receiver Name  
	                                         IN8 := #cc_DL,                     // Comma sign - ","
	                                         IN9 := #cs_PLCInfo,                // Message type - "PLCINFO"
	                                         IN10 := #cc_DL,                    // Comma sign - ","
	                                         IN11 := #ss_MsgID,                 // MSGID
	                                         IN12 := #cc_DL);                   // Comma sign - ","
	                    
	                    #ss_Message := CONCAT(IN1 := #ss_Speed,                 // Conveyor speed
	                                          IN2 := #cc_DL,                    // Comma sign - ","    
	                                          IN3 := #ss_MachStat,              // Machine status
	                                          IN4 := #cc_DL,                    // Comma sign - ","
	                                          IN5 := #ss_SysRevs,               // System revolutions
	                                          IN6 := #cc_DL,                    // Comma sign - ","
	                                          IN7 := #ss_ActiveCamera,          // Active camera
	                                          IN8 := #cs_CRLF);                 // Termination signs - "$R$L"
	                    
	                    // Get the maximum number of the message array elements
	                    #si_MaxMsgLen := "FC_GetNrOfArrayEl"(iv_Array := #sUDT_MessageArray.Character);
	                    
	                    // Get the length of the complete message
	                    #si_MsgLen := LEN(#ss_Message) + LEN(#ss_Header);
	                    
	                    // Message array size validation
	                    #sa_Status.InvalidMsgArraySize := #si_MsgLen > #si_MaxMsgLen;
	                    
	                    // Convert header AND message charater strings into the message array OF characters
	                    IF (NOT #sa_Status.InvalidMsgArraySize)                 // Message character array size valid 
	                    THEN
	                        
	                        Strg_TO_Chars(Strg := #ss_Header,                   // Convert message character string to Message character array 
	                                      pChars := 0,
	                                      Cnt => #sui_ArrayOffset,
	                                      Chars := #sUDT_MessageArray.Character);
	                        
	                        Strg_TO_Chars(Strg := #ss_Message,                  // Convert message character string  to the char array 
	                                      pChars := #sui_ArrayOffset,
	                                      Cnt => #sui_MsgArrayElNr,
	                                      Chars := #sUDT_MessageArray.Character);
	                        
	                    END_IF;
	                    
	                    // Clear remaining characters in message character array
	                    IF (NOT #sa_Status.InvalidMsgArraySize)                 // Message character array size is valid 
	                    THEN
	                        
	                        // Filling up not used message character array elements with '$00' (ASCII - 16#00)
	                        FILL_BLK(IN := #cc_NULL,                            // Fill not used message char array elements with '$00' 
	                                 COUNT := UINT_TO_ULINT(INT_TO_UINT(#si_MaxMsgLen) - #sui_MsgArrayElNr - #sui_ArrayOffset),
	                                 OUT => #sUDT_MessageArray.Character[#sui_MsgArrayElNr + #sui_ArrayOffset]);
	                        
	                    END_IF;
	                    
	                    // Move message into the FIFO buffer
	                    IF (NOT #sa_Status.InvalidMsgArraySize)                 // Message character array size is valid 
	                    THEN
	                        
	                        // Mode 'W' - Write FIFO record
	                        "FC_Fifo"(ic_Mode := 'W',
	                                  qUDT_Status => #sa_Status.FIFOStatus,
	                                  qx_Error => #sa_Status.FIFOError,
	                                  qx_Warning => #sa_Status.FIFOWarning,
	                                  iqv_Data := #sUDT_MessageArray,
	                                  iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                                  iqv_DataBuffer := #iqa_FifoData);
	                        
	                        
	                    END_IF;
	                    
	                    // In case of FIFO full, the FIFO full error bit and FIFO collective error bit are set
	                ELSE
	                    
	                    #sa_Status.FIFOError := TRUE;
	                    #sa_Status.FIFOStatus.FifoFull := TRUE;
	                    
	                    
	                END_IF;
	                
	            END_IF;
	            
	        END_REGION
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 – Status
	    
	    // Create a collective error bit
	    #qx_Error :=
	    #sa_Status.InvalidSysRevs                   // Invalid system revolutions number
	    OR #sa_Status.InvalidSpeed                  // Invalid conveyor speed
	    OR #sa_Status.InvalidMsgArraySize           // Invalid message array size   
	    OR #sa_Status.FIFOError;                    // FIFO error
	    
	    // Create a collective warning bit
	    #qx_Warning := #sa_Status.FIFOWarning;      // FIFO warning
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_UPSSortConf"
TITLE = FB_SortConf
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : UPS_SpecificCommunication
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 61
// END_ATTRIBUTES
//Function block to prepare and send the UPS SORTCONF message. 
   VAR_INPUT 
      iUDT_MsgHeader { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_UPSMessageHeader";   // UPS message header
      is_ActualDateTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[23];   // Actual date and time
      is_ModuleName { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[2] := 'AB';   // Module type
      is_DeviceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[4] := 'abcd';   // Device number
      ii_GIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // GIN
      ii_Destination { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Chute destination
      ii_GINRangeStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Valid GIN range start
      ii_GINRangeEnd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Valid GIN range end
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective error output
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective warning output
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
      iqUDT_LostStatistics : "UDT_UPSLostCounters";   // Lost parcels statistics
      iqUDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqa_FifoData : Array[*] of "UDT_Message";   // FIFO data
      iqdi_UniqueMsgID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Unique message ID integer
   END_VAR

   VAR 
      sUDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Message";   // Message character array
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";   //  FIFO status structure
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //  FIFO error
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //  FIFO warning
         InvalidPkgRevs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Invalid package revolutions number
         InvalidGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Invalid GIN
         InvalidDest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Invalid destination
         InvalidMsgArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Invalid message array size
      END_STRUCT;
      sa_PKGSTATArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..4] of Byte;   // PKGSTAT
      ss_Dest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[5];   // Destination
      ss_PACKREVS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[4];   // Package revolutions
      ss_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Message character string
      ss_PKGSTAT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Message delay
      ss_PKGSTATPart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Message delay
      sui_MsgArrayElNr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Number of written message characters
      si_MaxMsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum message length
      si_MsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // String character message length
      si_GINLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // GIN array length
      si_PACKREVSLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Package revolutions string length
      si_DestLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Destination string length
      si_i { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Loop counter
   END_VAR
   VAR RETAIN
      si_OldGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Old GIN
   END_VAR

   VAR CONSTANT 
      cc_NULL : Char := '$00';   // NULL sign
      cc_DL : Char := ',';   // Comma sign
      cc_Dash : Char := '-';   // Dash sign
      cs_CRLF : String := '$R$L';   // Termination signs
      cs_SortConf : String := 'SORTCONF';   // Message type
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	13/06/2019  | 0.2       | A.Nowak       | Replacement of instruction if for direct write into variable - Region 3 and 4 and 5 and 6.8 , changing and for or in conditions in regions 3 and 4 and 5
	28/06/2019  | 0.4       | A.Nowak       | Changing conditions for error occuring and status update
	18/07/2019  | 0.5       | L.Klar        | Status handling changed
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	23/08/2019  | 2.1       | K.Pokorski    | Bool to byte block changed to direct reference, comments simplified
	20/09/2019  | 2.2       | M.Kurpiers    | Change - status to struct
	01/10/2019  | 2.3       | A.Nowak       | Implementation of the new FIFO block
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	09/01/2020  | 3.1       | L.Klar        | Parcel status handling changed
	01/10/2020  | 3.2       | L.Klar        | Invalid package revolution error condition changed to handle 0
	                                        | Message trigger based on new GIN detection
	14/12/2020  | 3.3       | L.Klar        | ID created bit changed, destination too late reset if no detination received
	14/12/2020  | 3.4       | L.Klar        | Statistics for BAU added
	22/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	02/05/2024  | 4.1       | J.Majer      | Datatype conversions changed from automatic to explicit, to accomodate IEC 61131-3 standard
	*)
	
	REGION 1 - Reset statistics
	    
	    IF #iqUDT_EquipmentControl.Command.ResetData THEN
	        
	        #iqUDT_LostStatistics.LostInTracking := 0;
	        #iqUDT_LostStatistics.NoUPSID := 0;
	        #iqUDT_LostStatistics.NoSortRcv := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 – SortConf
	    
	    IF #ii_GIN <> #si_OldGIN
	        AND #ii_GIN >= #ii_GINRangeStart
	        AND #ii_GIN <= #ii_GINRangeEnd
	    THEN
	        
	        #si_OldGIN := #ii_GIN;
	        
	        REGION 2.1 – Update the FIFO header status bits
	            
	            // Mode 'S' - FIFO register status update
	            "FC_Fifo"(ic_Mode := 'S',
	                      qUDT_Status => #ss_Status.FIFOStatus,
	                      qx_Error => #ss_Status.FIFOError,
	                      qx_Warning => #ss_Status.FIFOWarning,
	                      iqv_Data := #sUDT_MessageArray,
	                      iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                      iqv_DataBuffer := #iqa_FifoData);
	            
	            
	        END_REGION
	        
	        REGION 2.2 – Maximum number of the package information's array elements
	            
	            #si_GINLen := "FC_GetNrOfArrayEl"(iv_Array := "DB_GIN".GIN);
	            
	        END_REGION
	        
	        REGION 2.3 – GIN validation
	            
	            #ss_Status.InvalidGIN :=
	            #ii_GIN <= 0
	            OR #ii_GIN > #si_GINLen;
	            
	        END_REGION
	        
	        REGION 2.4 – Number of recirculations validation
	            
	            IF (NOT #ss_Status.InvalidGIN)
	            THEN
	                
	                #ss_Status.InvalidPkgRevs :=
	                "DB_GIN".GIN[#ii_GIN].General.NrOfRecirculations < 0
	                OR "DB_GIN".GIN[#ii_GIN].General.NrOfRecirculations > 9999;
	                
	            END_IF;
	            
	        END_REGION
	        
	        REGION 2.5 – Destination validation
	            
	            IF (NOT #ss_Status.InvalidGIN)
	            THEN
	                
	                #ss_Status.InvalidDest :=
	                "DB_GIN".GIN[#ii_GIN].General.Destination[0] < 0
	                OR "DB_GIN".GIN[#ii_GIN].General.Destination[0] >= 10000;
	                
	            END_IF;
	            
	        END_REGION
	        
	        REGION 2.6 - Sort statistics
	            
	            IF "DB_GIN".GIN[#ii_GIN].General.DestRcv THEN
	                "DB_GIN".GIN[#ii_GIN].UPS.IDCreated := TRUE;
	            END_IF;
	            
	            IF NOT "DB_GIN".GIN[#ii_GIN].General.Lost THEN
	                IF "DB_GIN".GIN[#ii_GIN].UPS.IDCreated THEN
	                    IF NOT "DB_GIN".GIN[#ii_GIN].General.DestRcv THEN
	                        #iqUDT_LostStatistics.NoSortRcv += 1;
	                    END_IF;
	                ELSE
	                    #iqUDT_LostStatistics.NoUPSID += 1;
	                END_IF;
	            ELSE
	                #iqUDT_LostStatistics.LostInTracking += 1;
	            END_IF;
	            
	        END_REGION
	        
	        REGION 2.7 – SORTCONF message preparation
	            
	            // Conditions of sending the message
	            IF (NOT #ss_Status.FIFOError
	                AND NOT #ss_Status.InvalidGIN
	                AND NOT #ss_Status.InvalidPkgRevs
	                AND NOT #ss_Status.InvalidDest)
	            THEN
	                
	                IF (NOT #iqUDT_FifoHeader.Status.Full)
	                THEN
	                    
	                    // Unique  MSGID
	                    "FC_UPSMsgId"(is_ActualDateTime := #is_ActualDateTime,
	                                  is_ModuleName := #is_ModuleName,
	                                  is_DeviceNumber := #is_DeviceNumber,
	                                  iqs_MSGID := "DB_GIN".GIN[#ii_GIN].UPS.MSGID,
	                                  iqdi_UniqueMsgID := #iqdi_UniqueMsgID);
	                    
	                    // Sort status
	                    
	                    // Parcel diverted
	                    "DB_GIN".GIN[#ii_GIN].General.SortStatus.NoDivert := FALSE;
	                    
	                    // Good divert
	                    "DB_GIN".GIN[#ii_GIN].General.SortStatus.GoodDivert := #ii_Destination = "DB_GIN".GIN[#ii_GIN].General.Destination[0] AND NOT "DB_GIN".GIN[#ii_GIN].General.Lost;
	                    
	                    // Divert failed
	                    "DB_GIN".GIN[#ii_GIN].General.SortStatus.FailedDivert := NOT "DB_GIN".GIN[#ii_GIN].General.SortStatus.GoodDivert;
	                    
	                    "DB_GIN".GIN[#ii_GIN].General.SortStatus.DivertDestination := #ii_Destination;
	                    
	                    
	                    IF "DB_GIN".GIN[#ii_GIN].General.SortStatus.FailedDivert
	                    THEN
	                        IF NOT "DB_GIN".GIN[#ii_GIN].General.Lost THEN
	                            "DB_GIN".GIN[#ii_GIN].General.SortStatus.NoDivertCause.NoDestRcv := NOT "DB_GIN".GIN[#ii_GIN].General.DestRcv;
	                            "DB_GIN".GIN[#ii_GIN].General.SortStatus.NoDivertCause.DestTooLate := "DB_GIN".GIN[#ii_GIN].General.DestRcv;
	                        ELSE
	                            "DB_GIN".GIN[#ii_GIN].General.SortStatus.NoDivertCause.NoDestRcv := FALSE;
	                            "DB_GIN".GIN[#ii_GIN].General.SortStatus.NoDivertCause.DestTooLate := FALSE;
	                        END_IF;
	                    END_IF;
	                    
	                    // Package status - PKGSTAT2
	                    
	                    #sa_PKGSTATArray[0].%X0 := "DB_GIN".GIN[#ii_GIN].UPS.IDCreated;                                         // Byte 1, Bit 0 - PLCID created or TrayID Read (Package Passed through Camera Tunnel
	                    #sa_PKGSTATArray[0].%X1 := "DB_GIN".GIN[#ii_GIN].UPS.DimDataRcv;                                        // Byte 1, Bit 1 - Package Dimensional Data Received via Camera Scan Data Message
	                    #sa_PKGSTATArray[0].%X2 := "DB_GIN".GIN[#ii_GIN].UPS.PkgWrongInduct;                                    // Byte 1, Bit 2 - Package Did NOT Induct Properly (Non-Tray Systems)
	                    #sa_PKGSTATArray[0].%X3 := "DB_GIN".GIN[#ii_GIN].General.DestRcv;                                       // Byte 1, Bit 3 - SORT Command Received
	                    #sa_PKGSTATArray[0].%X4 := "DB_GIN".GIN[#ii_GIN].General.SortStatus.NoDivertCause.DestTooLate;          // Byte 1, Bit 4 - SORT Command Late
	                    #sa_PKGSTATArray[0].%X5 := "DB_GIN".GIN[#ii_GIN].General.SortStatus.NoDivertCause.InvalidDest;          // Byte 1, Bit 5 - SORT Command Invalid Destination
	                    #sa_PKGSTATArray[0].%X6 := "DB_GIN".GIN[#ii_GIN].General.SortStatus.NoDivertCause.NoDestRcv;            // Byte 1, Bit 6 - No SORT message Received for PKG or TRAY ID
	                    #sa_PKGSTATArray[0].%X7 := "DB_GIN".GIN[#ii_GIN].General.SortStatus.GoodDivert;                         // Byte 1, Bit 7 - Good Divert / Sort 
	                    
	                    
	                    #sa_PKGSTATArray[1].%X0 := "DB_GIN".GIN[#ii_GIN].UPS.IDCalcFromCamID;                                   // Byte 2, Bit 0 - PLCID/TrayID Calculated From CamID
	                    #sa_PKGSTATArray[1].%X1 := "DB_GIN".GIN[#ii_GIN].General.SortStatus.NoDivert;                           // Byte 2, Bit 1 - Divert/Tip Attempted
	                    #sa_PKGSTATArray[1].%X2 := "DB_GIN".GIN[#ii_GIN].General.SortStatus.NoDivertCause.TrayDisabled;         // Byte 2, Bit 2 - Tray Disabled (Tray Systems)
	                    #sa_PKGSTATArray[1].%X3 := "DB_GIN".GIN[#ii_GIN].General.SortStatus.NoDivertCause.DestDisabled;         // Byte 2, Bit 3 - Destination Disabled (via HMI or PFC)
	                    #sa_PKGSTATArray[1].%X4 := "DB_GIN".GIN[#ii_GIN].UPS.UnknownParcelID;                                   // Byte 2, Bit 4 - Unknown Parcel ID
	                    #sa_PKGSTATArray[1].%X5 := "DB_GIN".GIN[#ii_GIN].UPS.UndefinedProblem;                                  // Byte 2, Bit 5 - Un-Defined Problem
	                    #sa_PKGSTATArray[1].%X6 := "DB_GIN".GIN[#ii_GIN].UPS.UnrecognizedCmd;                                   // Byte 2, Bit 6 - Un-recognized command
	                    #sa_PKGSTATArray[1].%X7 := "DB_GIN".GIN[#ii_GIN].UPS.SorterInMainteneceMode;                            // Byte 2, Bit 7 - Sorter in Maintenance/Commissioning Mode
	                    
	                    
	                    #sa_PKGSTATArray[2].%X0 := "DB_GIN".GIN[#ii_GIN].General.SortStatus.NoDivertCause.ChuteJam;             // Byte 3, Bit 0 - Chute Jam
	                    #sa_PKGSTATArray[2].%X1 := "DB_GIN".GIN[#ii_GIN].General.SortStatus.FailedDivert;                       // Byte 3, Bit 1 - Failed Divert
	                    #sa_PKGSTATArray[2].%X2 := "DB_GIN".GIN[#ii_GIN].General.Lost;                                          // Byte 3, Bit 2 - Parcel Lost in PFC Tracking
	                    #sa_PKGSTATArray[2].%X3 := "DB_GIN".GIN[#ii_GIN].UPS.DestUserSusp;                                      // Byte 3, Bit 3 - Destination User Suspended
	                    #sa_PKGSTATArray[2].%X4 := "DB_GIN".GIN[#ii_GIN].General.SortStatus.NoDivertCause.ChuteFull;            // Byte 3, Bit 4 - Chute Full / Bag Closed
	                    #sa_PKGSTATArray[2].%X5 := "DB_GIN".GIN[#ii_GIN].General.SortStatus.NoDivertCause.SorterNotAtSpeed;     // Byte 3, Bit 5 - Sorter NOT At Speed
	                    #sa_PKGSTATArray[2].%X6 := "DB_GIN".GIN[#ii_GIN].UPS.SorterNotSynch;                                    // Byte 3, Bit 6 - Sorter NOT Synchronized (Tilt Tray Systems)
	                    #sa_PKGSTATArray[2].%X7 := FALSE;                                                                       // Byte 3, Bit 7 - Max Recirculation (Revolving Systems)
	                    
	                    
	                    #sa_PKGSTATArray[3].%X0 := "DB_GIN".GIN[#ii_GIN].UPS.PkgDetAtVerCheckPoint;                             // Byte 4, Bit 0 - Package Detected at Verification Check Point
	                    #sa_PKGSTATArray[3].%X1 := "DB_GIN".GIN[#ii_GIN].General.SortStatus.NoDivertCause.LeadingGapError;      // Byte 4, Bit 1 - Gap Error Leading Edge
	                    #sa_PKGSTATArray[3].%X2 := "DB_GIN".GIN[#ii_GIN].General.SortStatus.NoDivertCause.TrailingGapError;     // Byte 4, Bit 2 - Gap Error Trailing Edge 
	                    #sa_PKGSTATArray[3].%X3 := "DB_GIN".GIN[#ii_GIN].General.PkgTooHigh;                                    // Byte 4, Bit 3 - Package Too Tall
	                    #sa_PKGSTATArray[3].%X4 := "DB_GIN".GIN[#ii_GIN].General.PkgTooSmall;                                   // Byte 4, Bit 4 - Package Too Small
	                    #sa_PKGSTATArray[3].%X5 := "DB_GIN".GIN[#ii_GIN].General.PkgTooLong;                                    // Byte 4, Bit 5 - Package Too Long
	                    #sa_PKGSTATArray[3].%X6 := "DB_GIN".GIN[#ii_GIN].General.SortStatus.NoDivertCause.DestNotReachable;     // Byte 4, Bit 6 - Crossover Destination 
	                    #sa_PKGSTATArray[3].%X7 := "DB_GIN".GIN[#ii_GIN].UPS.ChuteFullAftrAlterDest;                            // Byte 4, Bit 7 - Preferred chute full after passed alternate destination
	                    
	                    
	                    #sa_PKGSTATArray[4].%X0 := "DB_GIN".GIN[#ii_GIN].UPS.ChuteNotAvailAfterAlterDest;                       // Byte 5, Bit 0 - Preferred chute not available after passed alternate destination
	                    #sa_PKGSTATArray[4].%X1 := "DB_GIN".GIN[#ii_GIN].General.SortStatus.NoDivertCause.NoRTR;                // Byte 5, Bit 1 - Take away conveyor not running
	                    #sa_PKGSTATArray[4].%X2 := "DB_GIN".GIN[#ii_GIN].UPS.PLCRedirected;                                     // Byte 5, Bit 2 - PLC Redirected
	                    #sa_PKGSTATArray[4].%X3 := FALSE;                                                                       // Byte 5, Bit 3 - Future / or Machine Specific (To be identified)
	                    #sa_PKGSTATArray[4].%X4 := FALSE;                                                                       // Byte 5, Bit 4 - Future / or Machine Specific (To be identified)
	                    #sa_PKGSTATArray[4].%X5 := FALSE;                                                                       // Byte 5, Bit 5 - Future / or Machine Specific (To be identified)
	                    #sa_PKGSTATArray[4].%X6 := FALSE;                                                                       // Byte 5, Bit 6 - Future / or Machine Specific (To be identified) 
	                    #sa_PKGSTATArray[4].%X7 := FALSE;                                                                       // Byte 5, Bit 7 - Future / or Machine Specific (To be identified)
	                    
	                    // PKGSTAT character string clearing
	                    #ss_PKGSTAT := '';
	                    
	                    // PKGSTAT bytes conversion to character string
	                    FOR #si_i := 0 TO 4 DO
	                        
	                        // Initialize the part of the PKGSTAT character string 
	                        #ss_PKGSTATPart := '';
	                        
	                        // PKGSTAT byte conversion to string
	                        VAL_STRG(IN := BYTE_TO_USINT(#sa_PKGSTATArray[#si_i]),
	                                 SIZE := 0,
	                                 PREC := 0,
	                                 FORMAT := 0,
	                                 P := 1,
	                                 OUT => #ss_PKGSTATPart);
	                        
	                        // PKGSTAT character string building
	                        IF (#si_i < 4)              // Loop counter lower than 4
	                        THEN
	                            
	                            #ss_PKGSTAT := CONCAT(IN1 := #ss_PKGSTAT,
	                                                  IN2 := #ss_PKGSTATPart,
	                                                  IN3 := #cc_Dash);
	                            
	                        ELSE
	                            
	                            #ss_PKGSTAT := CONCAT(IN1 := #ss_PKGSTAT,
	                                                  IN2 := #ss_PKGSTATPart);
	                        END_IF;
	                        
	                    END_FOR;
	                    
	                    // Package revolutions - PACKREVS
	                    
	                    // Package revolutions number character string clearing
	                    #ss_PACKREVS := '';
	                    
	                    // Package revolutions number integer converion to a character string
	                    VAL_STRG(IN := "DB_GIN".GIN[#ii_GIN].General.NrOfRecirculations,
	                             SIZE := 0,
	                             PREC := 0,
	                             FORMAT := 0,
	                             P := 1,
	                             OUT => #ss_PACKREVS);
	                    
	                    // Length of the package revolutions number character string
	                    #si_PACKREVSLen := LEN(#ss_PACKREVS);
	                    
	                    // Package revolutions number character string leading zeros addition
	                    IF (#si_PACKREVSLen < 4)        // Package revolutions string length is lower than 4                                  
	                    THEN
	                        
	                        FOR #si_i := 1 TO 4 - #si_PACKREVSLen DO
	                            
	                            #ss_PACKREVS := CONCAT(IN1 := '0',
	                                                   IN2 := #ss_PACKREVS);
	                            
	                        END_FOR;
	                        
	                    END_IF;
	                    
	                    // Destination - DEST
	                    
	                    // Initialize the destination character String
	                    #ss_Dest := '';
	                    
	                    // Destionation value integer converion to a character string
	                    VAL_STRG(IN := "DB_GIN".GIN[#ii_GIN].General.SortStatus.DivertDestination,
	                             SIZE := 0,
	                             PREC := 0,
	                             FORMAT := 0,
	                             P := 1,
	                             OUT => #ss_Dest);
	                    
	                    // Length of the destination character string
	                    #si_DestLen := LEN(#ss_Dest);
	                    
	                    // Destination character string leading zeros addition
	                    IF (#si_DestLen < 5)        // Destination string length
	                    THEN
	                        
	                        FOR #si_i := 1 TO 5 - #si_DestLen DO
	                            
	                            #ss_Dest := CONCAT(IN1 := '0',
	                                               IN2 := #ss_Dest);
	                            
	                        END_FOR;
	                        
	                    END_IF;
	                    
	                    // Message preparation
	                    
	                    // SORTCANF message composing according to the structure: SCN,SCT,RCN,RCT,MT,PKGUID,TRKNUM,Dest,PKGSTAT,PACKREVS {CRLF}
	                    #ss_Message := CONCAT(IN1 := #iUDT_MsgHeader.SCN,                  // Sender IP address  
	                                          IN2 := #cc_DL,                                // Comma sign - ","
	                                          IN3 := #iUDT_MsgHeader.SCT,                  // Sender Name   
	                                          IN4 := #cc_DL,                                // Comma sign - ","
	                                          IN5 := #iUDT_MsgHeader.RCN,                  // Receiver IP address 
	                                          IN6 := #cc_DL,                                // Comma sign - ","
	                                          IN7 := #iUDT_MsgHeader.RCT,                  // Receiver Name)    
	                                          IN8 := #cc_DL,                                // Comma sign - ","
	                                          IN9 := #cs_SortConf,                          // Message type - "SORTCONF"
	                                          IN10 := #cc_DL,                               // Comma sign - ","
	                                          IN11 := "DB_GIN".GIN[#ii_GIN].UPS.MSGID,      // MSGID 
	                                          IN12 := #cc_DL,                               // Comma sign - ","                                 
	                                          IN13 := "DB_GIN".GIN[#ii_GIN].UPS.PKGUID,     // Package unique ID 
	                                          IN14 := #cc_DL,                               // Comma sign - ","
	                                          IN15 := "DB_GIN".GIN[#ii_GIN].UPS.TRKNUM,     // Tracking number 
	                                          IN16 := #cc_DL,                               // Comma sign - ","
	                                          IN17 := #ss_Dest,                             // Destination 
	                                          IN18 := #cc_DL,                               // Comma sign - ","
	                                          IN19 := #ss_PKGSTAT,                          // Package status 
	                                          IN20 := #cc_DL,                               // Comma sign - ","
	                                          IN21 := #ss_PACKREVS,                         // Package revolutions
	                                          IN22 := #cs_CRLF);                            // Termination signs - "$R$L"
	                    
	                    // Maximum number of the message characters
	                    #si_MaxMsgLen := "FC_GetNrOfArrayEl"(iv_Array := #sUDT_MessageArray.Character);
	                    
	                    // Length of the complete message
	                    #si_MsgLen := LEN(#ss_Message);
	                    
	                    // Message array size validation
	                    #ss_Status.InvalidMsgArraySize := #si_MsgLen > #si_MaxMsgLen;
	                    
	                    // Message charater string conversion to a Message array characters
	                    IF (NOT #ss_Status.InvalidMsgArraySize)
	                    THEN
	                        
	                        Strg_TO_Chars(Strg := #ss_Message,
	                                      pChars := 0,
	                                      Cnt => #sui_MsgArrayElNr,
	                                      Chars := #sUDT_MessageArray.Character);
	                        
	                    END_IF;
	                    
	                    // Clearing remaining characters in message character array
	                    IF (NOT #ss_Status.InvalidMsgArraySize)
	                    THEN
	                        
	                        // Filling up not used message character array elements with '$00' (ASCII - 16#00)
	                        FILL_BLK(IN := #cc_NULL,
	                                 COUNT := UINT_TO_ULINT(INT_TO_UINT(#si_MaxMsgLen) - #sui_MsgArrayElNr),
	                                 OUT => #sUDT_MessageArray.Character[#sui_MsgArrayElNr]);
	                        
	                    END_IF;
	                    
	                    // Message write into a FIFO register
	                    IF (NOT #ss_Status.InvalidMsgArraySize)
	                        
	                    THEN
	                        
	                        // Mode 'W' - Write FIFO record
	                        "FC_Fifo"(ic_Mode := 'W',
	                                  qUDT_Status => #ss_Status.FIFOStatus,
	                                  qx_Error => #ss_Status.FIFOError,
	                                  qx_Warning => #ss_Status.FIFOWarning,
	                                  iqv_Data := #sUDT_MessageArray,
	                                  iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                                  iqv_DataBuffer := #iqa_FifoData);
	                        
	                        
	                    END_IF;
	                    
	                    // In case of FIFO full, the FIFO full error bit and FIFO collective error bit are set
	                ELSE
	                    
	                    #ss_Status.FIFOError := TRUE;
	                    #ss_Status.FIFOStatus.FifoFull := TRUE;
	                    
	                END_IF;
	                
	            END_IF;
	            
	        END_REGION
	        
	        REGION 2.8 – Status
	            
	            // Create a collective error bit
	            #qx_Error :=
	            #ss_Status.InvalidDest
	            OR #ss_Status.InvalidPkgRevs
	            OR #ss_Status.InvalidGIN
	            OR #ss_Status.InvalidMsgArraySize
	            OR #ss_Status.FIFOError;
	            
	            // Create a collective warning bit
	            #qx_Warning := #ss_Status.FIFOWarning;
	            
	        END_REGION
	        
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_UPSSafetyZoneStatistics"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 60
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_EquipmentControl { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EquipmentControl";   // Equipment control structure
      ix_SafetyZoneOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // SSP Field input
   END_VAR

   VAR_OUTPUT 
      qx_SafetyZoneOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_IN_OUT 
      iqUDT_Statistics : "UDT_UPSSafetyZoneStatistics";
   END_VAR

   VAR 
      sR_TRIG_NotHealthy {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge start
      sx_safetyZoneOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	17/08/2020  | 1.0       | S. Theocharis | First release
	22/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	
	REGION 1 Safety Zone ok mapping
	    
	    #qx_SafetyZoneOK := #sx_safetyZoneOk := #ix_SafetyZoneOK;
	    
	END_REGION
	
	
	REGION 2 Statistics
	    
	    REGION 2.1 Trigger
	        //Start trigger
	        #sR_TRIG_NotHealthy(CLK := NOT #sx_safetyZoneOk);
	        
	    END_REGION
	    
	    REGION 2.2 Not Healthy
	        
	        IF (NOT #sx_safetyZoneOk
	            OR #iUDT_EquipmentControl.Command.ResetData)                                          // Reset statistics
	        THEN
	            
	            "FC_Statistics"(ix_Reset := #iUDT_EquipmentControl.Command.ResetData,        // Reset statistics input
	                            ix_Activate := NOT #sx_safetyZoneOk,                                    // Activate statistics functions input
	                            ix_RTrigActivate := #sR_TRIG_NotHealthy.Q,                                   // Statistics active trigger
	                            iqUDT_Statistics := #iqUDT_Statistics.NotHealthy);                       // Statistics values output
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_UPSThreatParcel"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 63
// END_ATTRIBUTES
   VAR_INPUT 
      ii_TrackingPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ix_ReleaseButton { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PSP release button
   END_VAR

   VAR_OUTPUT 
      qx_StopConveyorDieBack { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stop conveyor external die back
      qx_PreStopConveyorDieBack { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Pre stop conveyor external die back
      qx_ReleaseButtonIndication { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PSP release button indicator
      qx_Lamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Lamp indicator
      qx_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_IN_OUT 
      iqUDT_StopConveyorInterface : "UDT_ConveyorInterface";
      iqUDT_Handshake : "UDT_ConveyorHandshake";   // Conveyor handshake
      iqa_TrackingData : Array[*] of Int;   // Tracking array
   END_VAR

   VAR 
      s_R_TRIG_ThreatParelFound {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      s_R_TRIG_Button {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      s_F_TRIG_Sensor {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;
      si_OldGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_StopConveyorEmptyDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      sx_ThreatParcelFound { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_SecondThreatParcelFound { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_StopConveyorEmpty { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_StopPreConveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	23/02/2021  | 0.1       | L.Klar        | first release MHS TIA 15.1
	22/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Get new GIN
	    
	    IF #iqa_TrackingData[#ii_TrackingPosition] > 0 AND
	        #iqa_TrackingData[#ii_TrackingPosition] <> #si_OldGIN
	    THEN
	        
	        IF "DB_GIN".GIN[#iqa_TrackingData[#ii_TrackingPosition]].UPS.ThreatParcel THEN
	            
	            IF #sx_ThreatParcelFound THEN
	                #sx_SecondThreatParcelFound := TRUE;
	            ELSE
	                #sx_ThreatParcelFound := TRUE;
	            END_IF;
	            
	        END_IF;
	        
	        #si_OldGIN := #iqa_TrackingData[#ii_TrackingPosition];
	    END_IF;
	    
	    IF NOT #sx_ThreatParcelFound AND #sx_SecondThreatParcelFound THEN
	        #sx_ThreatParcelFound := TRUE;
	        #sx_SecondThreatParcelFound := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Release parcel
	    
	    #s_R_TRIG_Button(CLK := #ix_ReleaseButton);
	    
	    IF #s_R_TRIG_Button.Q THEN
	        #sx_ThreatParcelFound := FALSE;
	        #sx_StopConveyorEmpty := FALSE;
	        #sx_StopPreConveyor := FALSE;
	    END_IF;
	    
	END_REGION
	
	
	
	REGION 2 - Threat parcel separtion
	    
	    #s_R_TRIG_ThreatParelFound(CLK := #sx_ThreatParcelFound);
	    #s_F_TRIG_Sensor(CLK := #iqUDT_Handshake.TIP);
	    
	    IF #s_R_TRIG_ThreatParelFound.Q THEN
	        #si_StopConveyorEmptyDistance := 300;
	    END_IF;
	    
	    IF #si_StopConveyorEmptyDistance > 0 THEN
	        #si_StopConveyorEmptyDistance -= #iqUDT_StopConveyorInterface.Displacement;
	    END_IF;
	    
	    IF #sx_ThreatParcelFound AND #si_StopConveyorEmptyDistance = 0 THEN
	        #sx_StopConveyorEmpty := TRUE;
	    END_IF;
	    
	    IF #s_F_TRIG_Sensor.Q AND #sx_ThreatParcelFound AND #sx_StopConveyorEmpty THEN
	        #sx_StopPreConveyor := TRUE;
	        #sx_StopConveyorEmpty := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Outputs control
	    
	    #qx_StopConveyorDieBack := #sx_ThreatParcelFound AND #sx_StopConveyorEmpty;
	    #qx_PreStopConveyorDieBack := ((#sx_ThreatParcelFound OR #sx_SecondThreatParcelFound) AND NOT #sx_StopConveyorEmpty) OR #sx_StopPreConveyor;
	    
	    #qx_Lamp := #sx_ThreatParcelFound AND #sx_StopPreConveyor;
	    #qx_ReleaseButtonIndication := #sx_ThreatParcelFound AND #sx_StopPreConveyor;
	    
	    #qx_HMIStatus := #sx_ThreatParcelFound AND #sx_StopPreConveyor;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_UPS1stStageFlowControl"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 46
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_configuration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_UPS1stStageFlowControlConfiguration";   //   Configuration UDT
      idi_AdditionalRate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   Additional rate from other measuring PLCs
      idi_ParcelCountInfeed1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   Counter of parcels from infeed
      ix_ActiveInfeed1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Infeed is running / active
      idi_ParcelCountInfeed2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   Counter of parcels from infeed
      ix_ActiveInfeed2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Infeed is running / active
      idi_ParcelCountInfeed3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   Counter of parcels from infeed
      ix_ActiveInfeed3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Infeed is running / active
      idi_ParcelCountInfeed4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   Counter of parcels from infeed
      ix_ActiveInfeed4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Infeed is running / active
      idi_ParcelCountInfeed5 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   Counter of parcels from infeed
      ix_ActiveInfeed5 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Infeed is running / active
      idi_ParcelCountInfeed6 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   Counter of parcels from infeed
      ix_ActiveInfeed6 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Infeed is running / active
      idi_ParcelCountInfeed7 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   Counter of parcels from infeed
      ix_ActiveInfeed7 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Infeed is running / active
      idi_ParcelCountInfeed8 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   Counter of parcels from infeed
      ix_ActiveInfeed8 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Infeed is running / active
      idi_ParcelCountInfeed9 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   Counter of parcels from infeed
      ix_ActiveInfeed9 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Infeed is running / active
      idi_ParcelCountInfeed10 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   Counter of parcels from infeed
      ix_ActiveInfeed10 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Infeed is running / active
   END_VAR

   VAR_OUTPUT 
      qx_ConfigruationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE = Unexpected configuration
      qx_New15SecInterval { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE = Indicates a new 15 Sec interval to partner PLC
      qx_LimitFlowInfeed1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE = Stop infeed due flow control
      qdi_30secFlowInfeed1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   30 seconds pph rate
      qdi_1minFlowInfeed1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   1 minute pph rate
      qdi_3minFlowInfeed1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   3 minutes pph rate
      qdi_10minFlowInfeed1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   10 minutes pph rate
      qx_LimitFlowInfeed2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE = Stop infeed due flow control
      qdi_30secFlowInfeed2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   30 seconds pph rate
      qdi_1minFlowInfeed2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   1 minute pph rate
      qdi_3minFlowInfeed2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   3 minutes pph rate
      qdi_10minFlowInfeed2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   10 minutes pph rate
      qx_LimitFlowInfeed3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE = Stop infeed due flow control
      qdi_30secFlowInfeed3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   30 seconds pph rate
      qdi_1minFlowInfeed3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   1 minute pph rate
      qdi_3minFlowInfeed3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   3 minutes pph rate
      qdi_10minFlowInfeed3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   10 minutes pph rate
      qx_LimitFlowInfeed4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE = Stop infeed due flow control
      qdi_30secFlowInfeed4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   30 seconds pph rate
      qdi_1minFlowInfeed4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   1 minute pph rate
      qdi_3minFlowInfeed4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   3 minutes pph rate
      qdi_10minFlowInfeed4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   10 minutes pph rate
      qx_LimitFlowInfeed5 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE = Stop infeed due flow control
      qdi_30secFlowInfeed5 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   30 seconds pph rate
      qdi_1minFlowInfeed5 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   1 minute pph rate
      qdi_3minFlowInfeed5 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   3 minutes pph rate
      qdi_10minFlowInfeed5 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   10 minutes pph rate
      qx_LimitFlowInfeed6 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE = Stop infeed due flow control
      qdi_30secFlowInfeed6 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   30 seconds pph rate
      qdi_1minFlowInfeed6 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   1 minute pph rate
      qdi_3minFlowInfeed6 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   3 minutes pph rate
      qdi_10minFlowInfeed6 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   10 minutes pph rate
      qx_LimitFlowInfeed7 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE = Stop infeed due flow control
      qdi_30secFlowInfeed7 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   30 seconds pph rate
      qdi_1minFlowInfeed7 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   1 minute pph rate
      qdi_3minFlowInfeed7 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   3 minutes pph rate
      qdi_10minFlowInfeed7 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   10 minutes pph rate
      qx_LimitFlowInfeed8 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE = Stop infeed due flow control
      qdi_30secFlowInfeed8 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   30 seconds pph rate
      qdi_1minFlowInfeed8 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   1 minute pph rate
      qdi_3minFlowInfeed8 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   3 minutes pph rate
      qdi_10minFlowInfeed8 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   10 minutes pph rate
      qx_LimitFlowInfeed9 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE = Stop infeed due flow control
      qdi_30secFlowInfeed9 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   30 seconds pph rate
      qdi_1minFlowInfeed9 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   1 minute pph rate
      qdi_3minFlowInfeed9 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   3 minutes pph rate
      qdi_10minFlowInfeed9 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   10 minutes pph rate
      qx_LimitFlowInfeed10 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE = Stop infeed due flow control
      qdi_30secFlowInfeed10 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   30 seconds pph rate
      qdi_1minFlowInfeed10 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   1 minute pph rate
      qdi_3minFlowInfeed10 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   3 minutes pph rate
      qdi_10minFlowInfeed10 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   10 minutes pph rate
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";
      iqUDT_FlowControlHMI : "UDT_UPSFlowControlHMI";
      iqa_InfeedArray : Array[1..10] of "UDT_UPSFlowRateCountingRegisters";   //   Array of line x
   END_VAR

   VAR 
      sFB_Pulse_EndOf15sPeriod { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Pulse";   //   15 second pulse generator
      sa_infeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..10] of Struct   //   Data of infeed line
         diCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   Counter of parcels from infeed
         diLastScanCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   Last scan counter of parcels from infeed
         diFlowRate30sec { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   30sec pph rate
         diFlowRate1min { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   1 min pph rate
         diFlowRate3min { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   3 min pph rate
         diFlowRate10min { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   10 min pph rate
         iNumberOfNewParcels { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Number of new parcels during this scan
         Active { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE = infeed is active
         RequestStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE= Request flow control
         OneShotRequestStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Rising edge request to stop
         DuringMinimumStopTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Infeed is stopped and the minimum stop time is not elapsed
      END_STRUCT;
      sa_FirstToStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..10] of Int;   //   Number of infeed - sorted as per higher priotrity to stop
      sFB_MinStopTimeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Array[1..10] of "FB_TimerOnOffDelay";   //   Minimum stop time active
      sdi_CumulativeFlowRate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   Cumulative flow rate 1min pph at evaluation point
      sdi_AverageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   Average length
      si_LastLowPriority { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Pointer to the last low priority infeed
      si_limit { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Number of infeeds in use - uper limit for array
      si_CurrentConsecutivesAboveSP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Number of consecutive intervals  with flow above HMI set point
      si_CurrentConsecutivesBelowSP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Number of consecutive intervals with flow below HMI set point
      sx_Disabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Disabled from user
      sx_StopRequested { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Any infeed requested to stop
      sx_swapLowPriority { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Used to indicate swap of position in the priority sorting
      sx_swapHighPriority { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Used to indicate swap of position in the priority sorting
   END_VAR

   VAR_TEMP 
      tr_quotient : Real;   //   Quotient of division
      tr_fraction : Real;   //   Return of fraction
      ti_buffer : Int;   //   Auxiliary buffer
      ti_LC_i : Int;   //   Loop counter
      ti_LC_k : Int;   //   Loop counter
      ti_Index : Int;   //   temporaty index
      ti_HighPriorityLowLimit : Int;   //   pointer to high priority low limit
      tx_End15sPeriod : Bool;   //   End of 15 seconds flow period
      tx_invalidLimit : Bool;   //   Invalid number of diverts
      tx_invalidOffset : Bool;   //   Invalid offset in a divert
   END_VAR

   VAR CONSTANT 
      cdi_InchesAverageLength : DInt := DINT#20;   //   Average length in inches
      cdi_mmAverageLength : DInt := DINT#508;   //   Average length in mm
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	09/04/2020  | 3.0       | S.Theocharis  | First release. UPS Appendix B V2.0 20161010
	22/04/2020  | 3.1       | S.Theocharis  | Changed to handle product length 
	24/04/2020  | 3.2       | S.Theocharis  | Convert INTs to DINTs. 
	                                        | Add validation check for negative offset
	24/04/2020  | 3.3       | S.Theocharis  | Bug fix of the index used in 1min flow calculation 
	29/04/2020  | 3.4       | K.Pokorski    | Change prefix to qdi so as to match variable types 
	28/01/2021  | 3.5       | S.Theocharis  | Update HMI interface. Add disable command and disabled status
	10/04/2021  | 3.6       | S.Theocharis  | Add input additional flow to evaluated flow. For inbound area
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	13/03/2024  | 4.1       | S. Nieświec   | 4.1 Release TIA 18
	*)
	
	REGION 1 - Normalization and data move
	    
	    REGION 1.1 - Normalization
	        
	        IF #iUDT_configuration.LegthBasedFlowControl THEN
	            
	            IF #iUDT_configuration.IsLengthImperial THEN
	                #sdi_AverageLength := #cdi_InchesAverageLength;  // infeed count in inches
	            ELSE
	                #sdi_AverageLength := #cdi_mmAverageLength;       // infeed count in mm
	            END_IF;
	        ELSE
	            #sdi_AverageLength := L#1;                            // infeed count in parcels     
	        END_IF;
	        
	    END_REGION
	    
	    REGION 1.2 - Move Input data to static
	        //Move counters
	        #sa_infeed[1].diCounter := #idi_ParcelCountInfeed1;
	        #sa_infeed[2].diCounter := #idi_ParcelCountInfeed2;
	        #sa_infeed[3].diCounter := #idi_ParcelCountInfeed3;
	        #sa_infeed[4].diCounter := #idi_ParcelCountInfeed4;
	        #sa_infeed[5].diCounter := #idi_ParcelCountInfeed5;
	        #sa_infeed[6].diCounter := #idi_ParcelCountInfeed6;
	        #sa_infeed[7].diCounter := #idi_ParcelCountInfeed7;
	        #sa_infeed[8].diCounter := #idi_ParcelCountInfeed8;
	        #sa_infeed[9].diCounter := #idi_ParcelCountInfeed9;
	        #sa_infeed[10].diCounter := #idi_ParcelCountInfeed10;
	        
	        //Move infeed active bit
	        #sa_infeed[1].Active := #ix_ActiveInfeed1;
	        #sa_infeed[2].Active := #ix_ActiveInfeed2;
	        #sa_infeed[3].Active := #ix_ActiveInfeed3;
	        #sa_infeed[4].Active := #ix_ActiveInfeed4;
	        #sa_infeed[5].Active := #ix_ActiveInfeed5;
	        #sa_infeed[6].Active := #ix_ActiveInfeed6;
	        #sa_infeed[7].Active := #ix_ActiveInfeed7;
	        #sa_infeed[8].Active := #ix_ActiveInfeed8;
	        #sa_infeed[9].Active := #ix_ActiveInfeed9;
	        
	        //map number of infeeds in use at the static memory
	        #si_limit := #iUDT_configuration.NumberOfInfeedsInUse;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 2 - Validate configuration 
	    //We validate configuration in every scan...
	    //..validation on first scan is also possible
	    
	    //Check number of used diverts
	    #tx_invalidLimit := #si_limit <= 1
	    OR #si_limit > 10;
	    
	    //Check divert offset configuration
	    //the offset cannot be above 56 because it will lead outside of the array size when we calculate the cummulative flow rate
	    IF NOT #tx_invalidLimit THEN
	        FOR #ti_LC_i := 1 TO #si_limit BY 1 DO
	            IF
	                #iUDT_configuration.Infeed[#ti_LC_i].RegisterOffset > 56 OR #iUDT_configuration.Infeed[#ti_LC_i].RegisterOffset < 0
	            THEN
	                #tx_invalidOffset := TRUE;
	            END_IF;
	        END_FOR;
	    END_IF;
	    
	    // Error handling 
	    IF #tx_invalidLimit OR #tx_invalidOffset OR #iUDT_configuration.IntervalsNumberOfEvaluationPeriod = 0 THEN
	        //On error: Set error output..
	        #qx_ConfigruationError := TRUE;
	        
	        //..reset flow control outputs..
	        #qx_LimitFlowInfeed1 := FALSE;
	        #qx_LimitFlowInfeed2 := FALSE;
	        #qx_LimitFlowInfeed3 := FALSE;
	        #qx_LimitFlowInfeed4 := FALSE;
	        #qx_LimitFlowInfeed5 := FALSE;
	        #qx_LimitFlowInfeed6 := FALSE;
	        #qx_LimitFlowInfeed7 := FALSE;
	        #qx_LimitFlowInfeed8 := FALSE;
	        #qx_LimitFlowInfeed9 := FALSE;
	        #qx_LimitFlowInfeed10 := FALSE;
	        
	        //..and exit block
	        RETURN;
	    ELSE
	        #qx_ConfigruationError := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 3 - End of 15s flow period
	    
	    // Calculate 15 seconds period
	    #sFB_Pulse_EndOf15sPeriod(iudi_PulseTime := 15000,
	                              qx_Pulse => #tx_End15sPeriod);
	    
	END_REGION
	
	REGION 4 - Add number of parcels in the register
	    //Each Region is used for different configurations
	    
	    REGION 4.1 - When input counts are incrementing 
	        
	        IF #iUDT_configuration.IncrementingCounts THEN
	            
	            FOR #ti_LC_i := 1 TO #si_limit BY 1 DO
	                
	                //calculate new parcels per infeed
	                IF #sa_infeed[#ti_LC_i].diCounter >= #sa_infeed[#ti_LC_i].diLastScanCounter THEN
	                    //Parcels are incremented normaly
	                    #sa_infeed[#ti_LC_i].iNumberOfNewParcels := DINT_TO_INT(#sa_infeed[#ti_LC_i].diCounter - #sa_infeed[#ti_LC_i].diLastScanCounter);
	                    
	                ELSE
	                    //Exception handling of parcel counter was reset in the partner PLC. Therefore for this scan we don't subtrack the ones of the previous scan
	                    #sa_infeed[#ti_LC_i].iNumberOfNewParcels := DINT_TO_INT(#sa_infeed[#ti_LC_i].diCounter);
	                END_IF;
	                
	                //Move current counter at the static variable of the last scan
	                #sa_infeed[#ti_LC_i].diLastScanCounter := #sa_infeed[#ti_LC_i].diCounter;
	                
	                //add new parcels in the 1st register
	                #iqa_InfeedArray[#ti_LC_i].iCR[1] += (#sa_infeed[#ti_LC_i].iNumberOfNewParcels);
	                
	            END_FOR;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 4.2 - When input counts are updated every 15 sec interval
	        //That logic here needs to be tested. There is a risk of loosing some parcels beacuse of the delay between the pLC to PLC communication.
	        
	        IF NOT #iUDT_configuration.IncrementingCounts AND #tx_End15sPeriod THEN
	            
	            FOR #ti_LC_i := 1 TO #si_limit BY 1 DO
	                
	                #iqa_InfeedArray[#ti_LC_i].iCR[1] := DINT_TO_INT(#sa_infeed[#ti_LC_i].diCounter);
	                
	            END_FOR;
	            
	        END_IF;
	    END_REGION
	    
	END_REGION
	
	REGION 5 - Flow rate calculation
	    // The 15 second period has passed
	    IF (#tx_End15sPeriod) THEN
	        
	        // loop the used infeeds
	        FOR #ti_LC_i := 1 TO #si_limit BY 1 DO
	            
	            // Initialize static flow buffer
	            #sa_infeed[#ti_LC_i].diFlowRate30sec := L#0;
	            #sa_infeed[#ti_LC_i].diFlowRate1min := L#0;
	            #sa_infeed[#ti_LC_i].diFlowRate3min := L#0;
	            #sa_infeed[#ti_LC_i].diFlowRate10min := L#0;
	            
	            // Loop through 40 Counting Registers per infeed
	            FOR #ti_LC_k := 1 TO 40 DO
	                
	                // 30 sec flow handling
	                IF #ti_LC_k <= 2 THEN
	                    #sa_infeed[#ti_LC_i].diFlowRate30sec += INT_TO_DINT(#iqa_InfeedArray[#ti_LC_i].iCR[#ti_LC_k]);
	                    
	                    // Conversion to full hour
	                    IF #ti_LC_k = 2
	                    THEN
	                        #sa_infeed[#ti_LC_i].diFlowRate30sec *= L#120;
	                        
	                        //Normalise
	                        #sa_infeed[#ti_LC_i].diFlowRate30sec /= #sdi_AverageLength;
	                        
	                        
	                    END_IF;
	                END_IF;
	                
	                // 1 minute flow handling
	                IF #ti_LC_k <= 4 THEN
	                    #sa_infeed[#ti_LC_i].diFlowRate1min += INT_TO_DINT(#iqa_InfeedArray[#ti_LC_i].iCR[#ti_LC_k]);
	                    
	                    // Conversion to full hour
	                    IF #ti_LC_k = 4 THEN
	                        #sa_infeed[#ti_LC_i].diFlowRate1min *= L#60;
	                        //Normalise
	                        #sa_infeed[#ti_LC_i].diFlowRate1min /= #sdi_AverageLength;
	                    END_IF;
	                END_IF;
	                
	                // 3 minutes flow handling
	                IF #ti_LC_k <= 12 THEN
	                    #sa_infeed[#ti_LC_i].diFlowRate3min += INT_TO_DINT(#iqa_InfeedArray[#ti_LC_i].iCR[#ti_LC_k]);
	                    
	                    // Conversion to full hour
	                    IF #ti_LC_k = 12 THEN
	                        #sa_infeed[#ti_LC_i].diFlowRate3min *= L#20;
	                        //Normalise
	                        #sa_infeed[#ti_LC_i].diFlowRate3min /= #sdi_AverageLength;
	                    END_IF;
	                END_IF;
	                
	                // 10 minutes flow handling
	                #sa_infeed[#ti_LC_i].diFlowRate10min += INT_TO_DINT(#iqa_InfeedArray[#ti_LC_i].iCR[#ti_LC_k]);
	                
	                // Conversion to full hour
	                IF #ti_LC_k = 40
	                THEN
	                    #sa_infeed[#ti_LC_i].diFlowRate10min *= L#6;
	                    //Normalise
	                    #sa_infeed[#ti_LC_i].diFlowRate10min /= #sdi_AverageLength;
	                END_IF;
	                
	            END_FOR;
	            
	        END_FOR;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Cumulative flow at evaluation point
	    
	    IF (#tx_End15sPeriod) THEN
	        
	        //initialise static variable
	        #sdi_CumulativeFlowRate := L#0;
	        
	        FOR #ti_LC_i := 1 TO #si_limit BY 1 DO
	            
	            FOR #ti_LC_k := 1 TO 4 BY 1 DO
	                
	                #sdi_CumulativeFlowRate += INT_TO_DINT(#iqa_InfeedArray[#ti_LC_i].iCR[#ti_LC_k + #iUDT_configuration.Infeed[#ti_LC_i].RegisterOffset]);
	                
	            END_FOR;
	            
	        END_FOR;
	        
	        // Conversion to full hour
	        #sdi_CumulativeFlowRate *= L#60;
	        
	        //Normalise
	        #sdi_CumulativeFlowRate /= #sdi_AverageLength;
	        
	        //add additional rate calculated in other PLCs ( e.g. recirculation OTE RATE!)
	        #sdi_CumulativeFlowRate := #sdi_CumulativeFlowRate + #idi_AdditionalRate;
	        
	        
	        
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Shift arrays when 15s flow period ends
	    
	    // 15 seconds period elapsed 
	    IF (#tx_End15sPeriod) THEN
	        
	        FOR #ti_LC_i := 1 TO #si_limit BY 1 DO
	            
	            // Shifted counting register by one element down
	            MOVE_BLK(IN := #iqa_InfeedArray[#ti_LC_i].iCR[1],
	                     COUNT := 59,
	                     OUT => #iqa_InfeedArray[#ti_LC_i].iCR[2]);
	            
	            // Reset first registter
	            #iqa_InfeedArray[#ti_LC_i].iCR[1] := 0;
	            
	        END_FOR;
	    END_IF;
	    
	END_REGION
	
	REGION 8 - Compare Current Value with Set Point
	    
	    IF (#tx_End15sPeriod) THEN
	        
	        IF #sdi_CumulativeFlowRate >= INT_TO_DINT(#iqUDT_FlowControlHMI.Setpoint) THEN
	            
	            #si_CurrentConsecutivesAboveSP += 1;  //increment consecutives above set point
	            #si_CurrentConsecutivesBelowSP := 0;  //reset consecutives below set point
	        ELSE
	            
	            #si_CurrentConsecutivesAboveSP := 0;  //reset consecutives above set point
	            #si_CurrentConsecutivesBelowSP += 1;  //increment consecutives below set point
	            
	            //limit consecutives below set point to threshold value. Protection against INT overflow
	            IF #si_CurrentConsecutivesBelowSP >= #iUDT_configuration.ThresholdConsecutivesBelowSP THEN
	                
	                #si_CurrentConsecutivesBelowSP := #iUDT_configuration.ThresholdConsecutivesBelowSP;
	                
	            END_IF;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 9 - Evaluation - Apply flow control 
	    //The evaluation period is specified by UPS at 1min or 4 intervals of 15 seconds
	    
	    IF (#tx_End15sPeriod) AND #si_CurrentConsecutivesAboveSP > 0 THEN
	        
	        //divide  current consecutives above SP with the number of intervals for evaluation ,,
	        #tr_quotient := INT_TO_REAL(#si_CurrentConsecutivesAboveSP) / INT_TO_REAL(#iUDT_configuration.IntervalsNumberOfEvaluationPeriod);
	        
	        //call fraction to check the number of decimal places of the quotient
	        #tr_fraction := FRAC(#tr_quotient);
	        
	        //If there are no decimal places then the current consecutive above set point is multiple
	        //of the evaluation period. Therefore the evaluation of the flow control should take place.
	        IF #tr_fraction = 0.0 THEN
	            
	            REGION 9.1 - Sort infeeds from 1st to stop to last to stop
	                //Sort as per priorities. From low priority to high 
	                //The high priority infeeds will be last in the sort regardless their flow
	                
	                //initialize index
	                #ti_Index := 1;
	                
	                //Sort from top the low priority infeeds
	                FOR #ti_LC_i := 1 TO #si_limit BY 1 DO
	                    
	                    IF #iUDT_configuration.Infeed[#ti_LC_i].IsHighPriority = FALSE THEN
	                        #sa_FirstToStop[#ti_Index] := #ti_LC_i;
	                        #ti_Index += 1;
	                    END_IF;
	                    
	                END_FOR;
	                
	                //Pointer to last low priority infeed
	                #si_LastLowPriority := #ti_Index - 1;
	                
	                //Sort the high priority infeeds if there are any 
	                IF #si_LastLowPriority < #si_limit THEN
	                    FOR #ti_LC_i := 1 TO #si_limit BY 1 DO
	                        
	                        IF #iUDT_configuration.Infeed[#ti_LC_i].IsHighPriority = TRUE THEN
	                            #sa_FirstToStop[#ti_Index] := #ti_LC_i;
	                            #ti_Index += 1;
	                        END_IF;
	                        
	                    END_FOR;
	                END_IF;
	                
	                //Sort based on the flow. Low priority infeeds
	                IF #si_LastLowPriority > 0 THEN
	                    
	                    REPEAT
	                        #sx_swapLowPriority := FALSE;
	                        
	                        FOR #ti_LC_i := #si_LastLowPriority TO 2 BY -1 DO
	                            IF #sa_infeed[#sa_FirstToStop[#ti_LC_i - 1]].diFlowRate1min < #sa_infeed[#sa_FirstToStop[#ti_LC_i]].diFlowRate1min THEN
	                                
	                                #ti_buffer := #sa_FirstToStop[#ti_LC_i];
	                                #sa_FirstToStop[#ti_LC_i] := #sa_FirstToStop[#ti_LC_i - 1];
	                                #sa_FirstToStop[#ti_LC_i - 1] := #ti_buffer;
	                                #sx_swapLowPriority := TRUE;
	                                
	                            END_IF;
	                        END_FOR;
	                    UNTIL NOT #sx_swapLowPriority
	                    END_REPEAT;
	                END_IF;
	                
	                
	                //Sort based on the flow. High priority infeeds
	                IF #si_LastLowPriority < #si_limit THEN
	                    #ti_HighPriorityLowLimit := (#si_LastLowPriority + 1);
	                    REPEAT
	                        #sx_swapHighPriority := FALSE;
	                        
	                        FOR #ti_LC_i := #si_limit TO #ti_HighPriorityLowLimit BY -1 DO
	                            
	                            IF (#sa_infeed[#sa_FirstToStop[#ti_LC_i - 1]].diFlowRate1min < #sa_infeed[#sa_FirstToStop[#ti_LC_i]].diFlowRate1min)
	                                AND #iUDT_configuration.Infeed[#sa_FirstToStop[#ti_LC_i - 1]].IsHighPriority
	                            THEN
	                                
	                                #ti_buffer := #sa_FirstToStop[#ti_LC_i];
	                                #sa_FirstToStop[#ti_LC_i] := #sa_FirstToStop[#ti_LC_i - 1];
	                                #sa_FirstToStop[#ti_LC_i - 1] := #ti_buffer;
	                                #sx_swapHighPriority := TRUE;
	                                
	                            END_IF;
	                        END_FOR;
	                    UNTIL NOT #sx_swapHighPriority
	                    END_REPEAT;
	                END_IF;
	                
	            END_REGION
	            
	            REGION 9.2 - Request stop to limit flow
	                
	                FOR #ti_LC_i := 1 TO #si_limit BY 1 DO
	                    
	                    IF
	                        #sa_infeed[#sa_FirstToStop[#ti_LC_i]].Active                                      //infeed running / activated ..
	                        AND NOT #sa_infeed[#sa_FirstToStop[#ti_LC_i]].RequestStop                            // .. and not already stopped...
	                        AND NOT #sa_infeed[#sa_FirstToStop[#ti_LC_i]].DuringMinimumStopTime                  // .. and not during minimum time to stop
	                        AND NOT #iUDT_configuration.Infeed[#sa_FirstToStop[#ti_LC_i]].IsNotAllowedToStop    // and is allowed to stop.
	                        
	                    THEN
	                        #sa_infeed[#sa_FirstToStop[#ti_LC_i]].RequestStop := TRUE;
	                        #sa_infeed[#sa_FirstToStop[#ti_LC_i]].OneShotRequestStop := TRUE;
	                        EXIT;                                                                                   //exit loop to stop one infeed every evaluation interval
	                    END_IF;
	                    
	                END_FOR;
	                
	            END_REGION
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 10 - Evaluation - Remove flow control
	    
	    IF (#tx_End15sPeriod) AND #si_CurrentConsecutivesBelowSP >= #iUDT_configuration.ThresholdConsecutivesBelowSP THEN
	        
	        FOR #ti_LC_i := 1 TO #si_limit BY 1 DO
	            #sa_infeed[#ti_LC_i].RequestStop := FALSE;
	        END_FOR;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 11  - Set minimum time of stopped time
	    
	    FOR #ti_LC_i := 1 TO #si_limit BY 1 DO
	        
	        //Set minimum time to stop 
	        #sFB_MinStopTimeActive[#ti_LC_i](iudi_OnDelayTime := 0,
	                                         iudi_OffDelayTime := #iUDT_configuration.Infeed[#ti_LC_i].MinimumTimeToStop,
	                                         ix_SignalToDelay := #sa_infeed[#ti_LC_i].OneShotRequestStop,
	                                         ix_Enable := TRUE,
	                                         qx_DelayedSignal => #sa_infeed[#ti_LC_i].DuringMinimumStopTime);
	        
	        //reset one shot request to stop 
	        #sa_infeed[#ti_LC_i].OneShotRequestStop := FALSE;
	        
	    END_FOR;
	    
	END_REGION
	
	REGION 12 - HMI Enable / Disable
	    
	    //Command to disable frlow control from HMI
	    #sx_Disabled := #iqUDT_FlowControlHMI.CommandToDisable;
	    
	END_REGION
	
	REGION 12 - Ouput the request stop
	    
	    #qx_LimitFlowInfeed1 := (#sa_infeed[1].RequestStop OR #sa_infeed[1].DuringMinimumStopTime) AND NOT #sx_Disabled;
	    #qx_LimitFlowInfeed2 := (#sa_infeed[2].RequestStop OR #sa_infeed[2].DuringMinimumStopTime) AND NOT #sx_Disabled;
	    #qx_LimitFlowInfeed3 := (#sa_infeed[3].RequestStop OR #sa_infeed[3].DuringMinimumStopTime) AND NOT #sx_Disabled;
	    #qx_LimitFlowInfeed4 := (#sa_infeed[4].RequestStop OR #sa_infeed[4].DuringMinimumStopTime) AND NOT #sx_Disabled;
	    #qx_LimitFlowInfeed5 := (#sa_infeed[5].RequestStop OR #sa_infeed[5].DuringMinimumStopTime) AND NOT #sx_Disabled;
	    #qx_LimitFlowInfeed6 := (#sa_infeed[6].RequestStop OR #sa_infeed[6].DuringMinimumStopTime) AND NOT #sx_Disabled;
	    #qx_LimitFlowInfeed7 := (#sa_infeed[7].RequestStop OR #sa_infeed[7].DuringMinimumStopTime) AND NOT #sx_Disabled;
	    #qx_LimitFlowInfeed8 := (#sa_infeed[8].RequestStop OR #sa_infeed[8].DuringMinimumStopTime) AND NOT #sx_Disabled;
	    #qx_LimitFlowInfeed9 := (#sa_infeed[9].RequestStop OR #sa_infeed[9].DuringMinimumStopTime) AND NOT #sx_Disabled;
	    #qx_LimitFlowInfeed10 := (#sa_infeed[10].RequestStop OR #sa_infeed[10].DuringMinimumStopTime) AND NOT #sx_Disabled;
	    
	END_REGION
	
	REGION 13 - Output flow rates
	    
	    //Disabled status to HMI
	    #iqUDT_FlowControlHMI.DisabledStatus := #sx_Disabled;
	    
	    ///Output 15 Sec interval one shot
	    #qx_New15SecInterval := #tx_End15sPeriod;
	    
	    //Cumulative
	    #iqUDT_FlowControlHMI.CalculatedFlow := DINT_TO_INT(#sdi_CumulativeFlowRate);
	    
	    //Infeed 1
	    #qdi_30secFlowInfeed1 := (#sa_infeed[1].diFlowRate30sec);
	    #qdi_1minFlowInfeed1 := (#sa_infeed[1].diFlowRate1min);
	    #qdi_3minFlowInfeed1 := (#sa_infeed[1].diFlowRate3min);
	    #qdi_10minFlowInfeed1 := (#sa_infeed[1].diFlowRate10min);
	    
	    //Infeed 2
	    #qdi_30secFlowInfeed2 := (#sa_infeed[2].diFlowRate30sec);
	    #qdi_1minFlowInfeed2 := (#sa_infeed[2].diFlowRate1min);
	    #qdi_3minFlowInfeed2 := (#sa_infeed[2].diFlowRate3min);
	    #qdi_10minFlowInfeed2 := (#sa_infeed[2].diFlowRate10min);
	    
	    //Infeed 3
	    #qdi_30secFlowInfeed3 := (#sa_infeed[3].diFlowRate30sec);
	    #qdi_1minFlowInfeed3 := (#sa_infeed[3].diFlowRate1min);
	    #qdi_3minFlowInfeed3 := (#sa_infeed[3].diFlowRate3min);
	    #qdi_10minFlowInfeed3 := (#sa_infeed[3].diFlowRate10min);
	    
	    //Infeed 4
	    #qdi_30secFlowInfeed4 := (#sa_infeed[4].diFlowRate30sec);
	    #qdi_1minFlowInfeed4 := (#sa_infeed[4].diFlowRate1min);
	    #qdi_3minFlowInfeed4 := (#sa_infeed[4].diFlowRate3min);
	    #qdi_10minFlowInfeed4 := (#sa_infeed[4].diFlowRate10min);
	    
	    //Infeed 5
	    #qdi_30secFlowInfeed5 := (#sa_infeed[5].diFlowRate30sec);
	    #qdi_1minFlowInfeed5 := (#sa_infeed[5].diFlowRate1min);
	    #qdi_3minFlowInfeed5 := (#sa_infeed[5].diFlowRate3min);
	    #qdi_10minFlowInfeed5 := (#sa_infeed[5].diFlowRate10min);
	    
	    //Infeed 6
	    #qdi_30secFlowInfeed6 := (#sa_infeed[6].diFlowRate30sec);
	    #qdi_1minFlowInfeed6 := (#sa_infeed[6].diFlowRate1min);
	    #qdi_3minFlowInfeed6 := (#sa_infeed[6].diFlowRate3min);
	    #qdi_10minFlowInfeed6 := (#sa_infeed[6].diFlowRate10min);
	    
	    //Infeed 7
	    #qdi_30secFlowInfeed7 := (#sa_infeed[7].diFlowRate30sec);
	    #qdi_1minFlowInfeed7 := (#sa_infeed[7].diFlowRate1min);
	    #qdi_3minFlowInfeed7 := (#sa_infeed[7].diFlowRate3min);
	    #qdi_10minFlowInfeed7 := (#sa_infeed[7].diFlowRate10min);
	    
	    //Infeed 8
	    #qdi_30secFlowInfeed8 := (#sa_infeed[8].diFlowRate30sec);
	    #qdi_1minFlowInfeed8 := (#sa_infeed[8].diFlowRate1min);
	    #qdi_3minFlowInfeed8 := (#sa_infeed[8].diFlowRate3min);
	    #qdi_10minFlowInfeed8 := (#sa_infeed[8].diFlowRate10min);
	    
	    //Infeed 9
	    #qdi_30secFlowInfeed9 := (#sa_infeed[9].diFlowRate30sec);
	    #qdi_1minFlowInfeed9 := (#sa_infeed[9].diFlowRate1min);
	    #qdi_3minFlowInfeed9 := (#sa_infeed[9].diFlowRate3min);
	    #qdi_10minFlowInfeed9 := (#sa_infeed[9].diFlowRate10min);
	    
	    //Infeed 10
	    #qdi_30secFlowInfeed10 := (#sa_infeed[10].diFlowRate30sec);
	    #qdi_1minFlowInfeed10 := (#sa_infeed[10].diFlowRate1min);
	    #qdi_3minFlowInfeed10 := (#sa_infeed[10].diFlowRate3min);
	    #qdi_10minFlowInfeed10 := (#sa_infeed[10].diFlowRate10min);
	    
	END_REGION
	
END_FUNCTION_BLOCK

