TYPE "UDT_ModuleState"
TITLE = UDT_ModuleState
VERSION : 0.1
//User-defined structure of module states.
   STRUCT
      Configured { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Module configured
      Exist { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Module exist
      Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Module has error
   END_STRUCT;

END_TYPE

TYPE "UDT_DeviceState"
TITLE = UDT_DeviceState
VERSION : 0.1
//User-defined structure of device states.
   STRUCT
      Configure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Device configured in TIA Portal hardware
      Exist { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Device physically connected
      Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Device has an error
      ProfinetNumber : UInt;   // Profinet slave number
      HW_ID : UInt;   // Device's HW_ID
      PNDeviceName : String;   // Device's project name
   END_STRUCT;

END_TYPE

TYPE "UDT_ProfinetDevice"
TITLE = UDT_ProfinetDevice
VERSION : 0.1
//User-defined structure of profinet device state.
   STRUCT
      DeviceState : "UDT_DeviceState";   // Device state
      Module { S7_SetPoint := 'False'} : Array[0..31] of "UDT_ModuleState";   // Modules
   END_STRUCT;

END_TYPE

TYPE "UDT_CommonStatus"
TITLE = UDT_CommonStatus
VERSION : 0.1
//User-defined structure of common statuses.
   STRUCT
      SafetyStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Emergancy stop
      Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // An error is active
      Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // A warning is active
      ManualRun { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Running in manual mode
      Manual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // In manual mode
      Halted { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Halted
      Dieback { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // In dieback
      Stopped { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stopped
      Running { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Running
      EnergySave { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // In energy saving mode
      AutoON { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Automatic started
   END_STRUCT;

END_TYPE

TYPE "UDT_ProfinetNetwork"
TITLE = UDT_ProfinetNetwork
VERSION : 0.1
//User-defined structure of profinet network state.
   STRUCT
      DeviceStatus : Array[0..512] of "UDT_ProfinetDevice";   // Profinet device status
   END_STRUCT;

END_TYPE

TYPE "UDT_GINWES"
VERSION : 0.1
   STRUCT
      Barcode : String[40];
   END_STRUCT;

END_TYPE

TYPE "UDT_GINWCS"
VERSION : 0.1
   STRUCT
      ActionTaken : String;   // Location code value that describes the actual disposition of the package
      Destination1 : String[20];   // Location code value that describes where the package should go (Diverter Number)
      Destination2 : String[20];   // Location code value that describes where the package should go (Diverter Number)
      Destination3 : String[20];   // Location code value that describes where the package should go (Diverter Number)
      Destination4 : String[20];   // Location code value that describes where the package should go (Diverter Number)
      Destination5 : String[20];   // Location code value that describes where the package should go (Diverter Number)
      ReasonCode : String[2];   // Management Code value that describes the result of attempting to route the package to the Destination
      Barcode1 : String;   // Barcode identifier code
      Barcode2 : String;
      Barcode3 : String;
      Barcode4 : String;
   END_STRUCT;

END_TYPE

TYPE "UDT_GINDHL"
VERSION : 0.1
   STRUCT
      ObjectID : String[10];   // Object ID
      VID : String[16];   // Virtual Item Identifier (VID)
      PieceID : String[40];   // Piece ID barcodes
      SortStrategy : String[1];   // Sort Strategy 1 - Highest priority available , 2 - Nearest
      ParcelReject { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Parcel reject
      Destination : Array[1..6] of Struct   // Destination
         ID : UInt;   // ID
         SortCommandActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sort command
         ParcelSorted { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parcel sorted
         Rejected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parcel rejected
         Reason : Int;   // Reason
      END_STRUCT;
      ParcelLocation : Struct   // Parcel Location
         Current : UInt;   // Current
         Last : UInt;   // Last
         Sort : UInt;   // Sort
      END_STRUCT;
      MFCMessage : Struct   // MFC Sort messages
         Sent : Struct   // Messages sent from the PLC to the MFC system
            SortResult { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Sort Result
            VIDResponse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message VID Response
            ScanReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Scan Reset
            XrayResult { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Xray result
            ParcelRegInfo { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Xray registration info
         END_STRUCT;
         Received : Struct   // Messages received from the MFC system to the PLC
            RejectParcel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Reject Parcel
            Destination { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Destination
            DestinationResent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Destination Resent
            TemporaryParcelIdentifier { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Temporary Parcel Identifier
            XrayRegistrationInfo { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         END_STRUCT;
      END_STRUCT;
      Xray : Struct   // Xray data structure
         RoutingCode : String[2];   // Routing code
         Group : String[1];   // The group field is used to identify the group of the operator decisions came from in a
         Level : String[1];   // Level field is used to identify which level the operator decision came from in a
         Result : String[1];   // Results can be indicated with the following:A = Accept, R = Reject, U = Unavailable (Timeout), Z = High Threat
         BagIDMessage : Struct   // Message from PLC to Xray
            MessagePrepared { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message is prepared and ready to send
            WrongMessageStructure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message has wrong structure
            Sent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message sent by PLC to Xray
            SentTime : String;   // Time when message sent by PLC to Xray
            NotSent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message was not sent from the PLC
            Received { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message received by Xray
            TimeReceived : String;   // Time when message received by Xray
            NotReceived { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message did not reach Xray
         END_STRUCT;
         DecisionMessage : Struct   // Message from Xray to PLC
            Received { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message received by PLC
            ReceivedTime : String;   // The message received by PLC
            NotReceivedOnTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message did not reach PLC
         END_STRUCT;
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_GINUPS"
VERSION : 0.1
   STRUCT
      TRKNUM : String[18];   // Tracking number
      PKGUID : String[32];   // Package ID
      MSGID : String[32];   // Message ID
      Length : Int;   // Camera Length in mm
      Width : Int;   // Camera Width in mm
      Height : Int;   // Camera Height in mm
      Weight : DInt;   // Weight in g
      IDCreated { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 1, Bit 0 - PLCID created or TrayID Read
      DimDataRcv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 1, Bit 1 - Package Dimensional Data Received via Camera Scan Data Message
      PkgWrongInduct { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 1, Bit 2 - Package Did NOT Induct Properly (Non-Tray Systems)
      IDCalcFromCamID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 2, Bit 0 - PLCID/TrayID Calculated From CamID
      UnknownParcelID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 2, Bit 4 - Unknown Parcel ID
      UndefinedProblem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 2, Bit 5 - Un-Defined Problem
      UnrecognizedCmd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 2, Bit 6 - Un-recognized command
      SorterInMainteneceMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 2, Bit 7 - Sorter in Maintenance/Commissioning Mode
      DestUserSusp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 3, Bit 3 - Destination User Suspended
      SorterNotSynch { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 3, Bit 6 - Sorter NOT Synchronized (Tilt Tray Systems)
      PkgDetAtVerCheckPoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 4, Bit 0 - Package Detected at Verification Check Point
      ChuteFullAftrAlterDest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 4, Bit 7 - Preferred chute full after passed alternate destination
      ChuteNotAvailAfterAlterDest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 5, Bit 0 - Preferred chute not available after passed alternate destination
      PLCRedirected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 5, Bit 2 - PLC Redirected
      ThreatParcel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Threat parcel
   END_STRUCT;

END_TYPE

TYPE "UDT_GINFedEx"
VERSION : 0.1
   STRUCT
      Timestamp : String[17];   // Local time timestamp
      TimeZoneDesignator : String[5];   // Time zone designator
      PackageEntrancePoint : String[14];   // Entrance point, where LLC starts tracking the parcel.
      PackageEntranceState : String[1];   // Entrance state
      PackageExitPoint : String[14];   // Exit point name, where LLC reports the last known tracking point.
      PackageExitState : String[1];   // Exit point state when LLC reports the last known tracking point.
      PalletType : String[2];   // Pallet code for different type of pallets on the market
      Mask : String[1];   // Flag to indicate that a pallet has been mask.
      CellNumber : String[4];   // Tray/Cell number (for loop sorters) or generated by LLC (on line sorters).
      CellsOccupied : String[1];   // Cells occupied by the piece for loop sorters.
      ImageID : String[6];   // Image ID number created by the ADC system.
      ScanUnitType : String[1];   // Scan unit type
      ADCSystemID : String[15];   // Number assigned by the ADC system
      PackageID : String[15];   // Number assigned by the LLC system
      LLCSystemID : String[15];
      HLCPackageID : String[10];   // Unique number for the specific package during it stays in HLC system.
      HLCResultCode : String[16];   // Result code based on processing of the scan event messages.
      ShipmentID : String[6];   // Consignment id of the parcel.
      WeightStatus : String[1];   // Status to indicate if the parcel/pallet has weight on the system.
      ActualDestination : String[6];   // Location code value that describes the actual disposition of the package.
      Destination1 : String[6];   // Location code value that describes where the package should go (Diverter Number).
      Destination2 : String[6];   // Location code value that describes where the package should go (Diverter Number).
      Destination3 : String[6];   // Location code value that describes where the package should go (Diverter Number).
      Destination4 : String[6];   // Location code value that describes where the package should go (Diverter Number).
      Destination5 : String[6];   // Location code value that describes where the package should go (Diverter Number).
      CutOffTimeDestination1 : String[5];   // Cut Off Time in Local Time.
      CutOffTimeDestination2 : String[5];   // Cut Off Time in Local Time.
      CutOffTimeDestination3 : String[5];   // Cut Off Time in Local Time.
      CutOffTimeDestination4 : String[5];   // Cut Off Time in Local Time.
      CutOffTimeDestination5 : String[5];   // Cut Off Time in Local Time.
      ReasonCode1 : String[8];   // Management Code value that describes the result of attempting to route the package to the Destination
      ReasonCode2 : String[8];   // Management Code value that describes the result of attempting to route the package to the Destination
      ReasonCode3 : String[8];   // Management Code value that describes the result of attempting to route the package to the Destination
      ReasonCode4 : String[8];   // Management Code value that describes the result of attempting to route the package to the Destination
      ReasonCode5 : String[8];   // Management Code value that describes the result of attempting to route the package to the Destination
      HLCDataText : String[20];   // Free text for future use.
      Customs : String[1];   // Need to be checked by customs
      DIMSystemID : String[15];   // Identifier of dimensioning system.
      DIMStatus : String[5];   // Basic diagnostic information from the dimensioning system at the moment of the measurement.
      PackageDimLength : String[6];   // Length dimension of package in resolution of dim system.
      PackageDimWidth : String[6];   // Width dimension of package in resolution of dim system.
      PackageDimHeight : String[6];   // Height dimension of package in resolution of dim system.
      DIMUOM : String[2];   // Unit of measure of the package dimensions.
      DimLFTstatusCode : String[8];   // Dimension LFT status code.
      DimConfidence : String[2];   // The level of assurance for the correct dimensions.
      DimensionSource : String[1];   // For combined camera/laser dim acquisition devices. It indicates type of capturing mode
      AlibiDims : String[25];   // Alibi for Dimensions
      SCLSystemID : String[15];   // Identifier of weight scale.
      SCLStatus : String[5];   // Basic diagnostic information from the weight scale system.
      SCLWT : String[6];   // Scale weight of package in resolution of scale system.
      SCLWTUOM : String[2];   // Unit of measurement for Weight
      SCLLFTStatusCode : String[2];   // Scale LFT status code.
      AlibiWeight : String[25];   // Alibi for Weight
      ReasonCode : String[1];   // This code should be used when the SI message has some defect.
      Stackable : String[1];   // If stackable recognition is enabled, Y or N
      Stickerstype : String[2];   // When optical recognition is used to sort
      FlyingDocument : String[1];   // Status to confirm if the document/flyer is prone to fly off the sorter.
      ModeofOperation : String[1];   // Camera Tunnel operational mode format:
      CameraHeadstatus : String[2];   // Diagnostic information on camera/laser heads performing barcode reads.
      PackageDataTruncated : String[1];   // Y = Full length of barcode data exceeds 9999 bytes, data truncated
      TotalBarcodeDataLength : String[4];   // Length of all barcode data that was sent in bytes;
      Barcode1Identification : String[3];   // Barcode identifier code.
      Barcode1status : String[2];   // Barcode confidence factor
      Barcode1datalength : String[4];   // String length of barcode data in bytes; inclusive of this field. Use 0054 as a fixed value
      Barcode1data : String[50];   // Highest priority barcode
      Barcode2Identification : String[3];   // Barcode identifier code.
      Barcode2status : String[2];   // Barcode confidence factor
      Barcode2datalength : String[4];   // String length of barcode data in bytes; inclusive of this field. Use 0054 as a fixed value
      Barcode2data : String[50];   // Highest priority barcode
      Barcode3Identification : String[3];   // Barcode identifier code.
      Barcode3status : String[2];   // Barcode confidence factor
      Barcode3datalength : String[4];   // String length of barcode data in bytes; inclusive of this field. Use 0054 as a fixed value
      Barcode3data : String[50];   // Highest priority barcode
      BarcodeIdentification : String[3];   // Barcode identifier code.
      Barcodestatus : String[2];   // Barcode confidence factor
      Barcodedatalength : String[4];   // String length of barcode data in bytes
      Barcodedata : String[50];   // Sortation barcode
      CustomerID : DInt;   // 6 digits SequentialID (NNNNNN)
      AreaNumber : String[2];   // Package Sequence ID "Area Number"
      PurgeEnabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Purge enabled for parcel: destination overwritten with Purge destination
   END_STRUCT;

END_TYPE

TYPE "UDT_GINStandard"
VERSION : 0.1
   STRUCT
      Destination : Array[0..20] of DInt;   // Destination
      Identification : Struct   // Barcode identification
         GoodRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Barcode read was succesful
         NoRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Barcode read was unsuccesful
         MultiRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Multiple Barcodes were detected
         Barcode : Array[0..10] of Char;   // Barcode values
      END_STRUCT;
      GinAssigned { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // GIN is assigned to package
      Lost { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Lost in tracking
      Length : Int;   // Length in mm
      Width : Int;   // Width in mm
      Height : Int;   // Height in mm
      Weight : DInt;   // Weight in g
      PkgTooLong { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is too long
      PkgTooSmall { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is too small
      PkgTooHigh { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is too high
      PkgOverWeight { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is over weight
      TrailingGap : Int;   // Trailing gap size in cm between the package
      LeadingGap : Int;   // Leading gap size in cm between the package
      NrOfRecirculations : Int;   // Number of recirculations
      DestReqSend { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Destination request sent to high level
      DestRcv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Destination received from high level
      SortStatus : Struct   // Sort status of the package
         DivertDestination : Int;   // Destination to which the package is diverted
         GoodDivert { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package diverted
         FailedDivert { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package failed to divert
         NoDivert : Bool := TRUE;   // Divert is not activated
         NoDivertCause : Struct   // Cause for no divert
            ChuteJam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Chute is jammed
            ChuteFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Chute is full
            NoRTR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Downstream conveyor is not ready to receive
            DestDisabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Destination is disabled
            TrayDisabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Tray is disabled
            SorterNotAtSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sorter is not at speed
            LeadingGapError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Gap size with downstream parcel is not enough
            TrailingGapError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Gap size with upstream parcel is not enough
            PkgTooHigh { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is too high to divert
            PkgTooLong { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is too long to divert
            DestNotReachable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sort destionation is not reachable
            InvalidDest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sort destination is invalid
            DestTooLate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Destination too late
            NoDestRcv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Destination not received from high level
         END_STRUCT;
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_EventStatistic"
TITLE = UDT_EventStatistic
VERSION : 0.1
//User-defined structure of event statistic data.
   STRUCT
      NumberOfTimes : DInt;   // Number of times the event occurred since last reset
      LastEventSeconds : DInt;   // Number of seconds of the current or last event
      TotalEventSeconds : DInt;   // Total number of seconds the event occurred since last reset
   END_STRUCT;

END_TYPE

FUNCTION "FC_GetNrOfArrayEl" : Int
TITLE = FC_GetNrOfArrayEl
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 19
// END_ATTRIBUTES
//Function to get the number of array elements.
   VAR_INPUT 
      iv_Array : Variant;   // Input array
   END_VAR

   VAR_TEMP 
      ti_NrOfArrayEl : Int;   // Number of array elements
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	27/08/2019  | 2.1       | K.Pokorski    | Comments adjusted
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – Number of an array elements
	    
	    IF IS_ARRAY(#iv_Array)                                                  // Input variable is an array
	    THEN
	        
	        #ti_NrOfArrayEl := UDINT_TO_INT(CountOfElements(#iv_Array));
	        
	        // Reset array length if the input variable isn't an array
	    ELSE
	        
	        #ti_NrOfArrayEl := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 – Return output
	    
	    #FC_GetNrOfArrayEl := #ti_NrOfArrayEl;
	    
	END_REGION
	
END_FUNCTION

TYPE "UDT_AixMotorStatus"
VERSION : 0.1
   STRUCT
      Overheat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor temperature has exceeded 105 degrees Celsius
      MaxTorque { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor at maximum torque output
      ShortCircuit { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor short circuit
      MotorNotConnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor is not connected
      Overload { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor overloaded after more than 20 seconds in Stalled
      Stalled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor stalled and speed is less than 10% of the set speed
      BadHall { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor Hall Effect Sensor error active
      MotorNotUsed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor is not used
      MotorStatus1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor running and direction status
      MotorStatus2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor running and direction status
      MotorPortinDOmode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor port is in digital output mode .
      Bit03 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
      Bit04 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
      BoardOverheat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
      OverVoltage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Supply voltage + motor back EMF exceeded 30 volts
      LowVoltage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Module power supply is less than 18 Volts
      MotorStatus : DWord;
   END_STRUCT;

END_TYPE

TYPE "UDT_EquipmentControl"
TITLE = UDT_EquipmentControl
VERSION : 0.1
//User-defined structure of equipment control commands.
   STRUCT
      Command : Struct   // Control command
         Start { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start conveyor
         Stop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stop conveyor
         Reset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Faults reset
         ResetData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Statistics reset
         ManualMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual mode required
         DisableManualMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disable manual mode
         AutomaticOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // System is started in automatic mode
         StopRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      END_STRUCT;
      Report { S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Conveyors state
      Request : Struct   // Request from equipment
         RestartRequired { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Restart required from system control
         SignalingRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Beeper required
         InhibitStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      END_STRUCT;
   END_STRUCT;

END_TYPE

DATA_BLOCK "DB_ProfinetDiagnostic"
TITLE = DB_ProfinetDiagnostic
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
NON_RETAIN
//Data block to store profinet network diagnostic data.
   VAR 
      ProfinetNetworks { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Array[1..10] of "UDT_ProfinetNetwork";
   END_VAR


BEGIN

END_DATA_BLOCK

TYPE "UDT_GIN"
VERSION : 0.1
   STRUCT
      General { S7_SetPoint := 'False'} : "UDT_GINStandard";
      FedEx { S7_SetPoint := 'False'} : "UDT_GINFedEx";
      UPS { S7_SetPoint := 'False'} : "UDT_GINUPS";
      DHL { S7_SetPoint := 'False'} : "UDT_GINDHL";
      WCS { S7_SetPoint := 'False'} : "UDT_GINWCS";
      WES { S7_SetPoint := 'False'} : "UDT_GINWES";
   END_STRUCT;

END_TYPE

DATA_BLOCK "DB_Memory"
TITLE = DB_Memory
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
VERSION : 3.0
NON_RETAIN
   VAR 
      ClockByte { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // System clock byte
      Clock_10Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 10 Hz system clock bit
      Clock_5Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 5 Hz system clock bit
      "Clock_2.5Hz" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 2.5 Hz system clock bit
      Clock_2Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 2 Hz system clock bit
      "Clock_1.25Hz" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1.25 Hz system clock bit
      Clock_1Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 Hz system clock bit
      "Clock_0.625Hz" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0.625 Hz system clock bit
      "Clock_0.5Hz" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0.5 Hz system clock bit
      SystemByte { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // System byte
      OSClockByte { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // One shot of clock pulse
      "OS_0.1sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 0.1 sec
      "OS_0.2sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 0.2 sec
      "OS_0.4sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 0.4 sec
      "OS_0.5sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 0.5 sec
      "OS_0.8sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 0.8 sec
      OS_1sec { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 1 sec
      "OS_1.6sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 1.6 sec
      OS_2sec { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 2 sec
      PrevCycleTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Previous PLC cycle Time
      RuntimeMem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Runtime memory
      FirstScan { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // First scan bit
      DiagStatusUpdate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Diagnostic status update
      AlwaysTrue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Always True bit
      AlwaysFalse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Always False bit
      CommissioningFalse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Commissioning always false
      CommissioningTrue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Commissioning always true
      ReconnectCommand { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reconnect command
      ScanMainRack { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Trigger to check main rack confiuration
      ScanProfinet { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Scan profinet bit
      Simulation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Simulation
      PN1OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet ok
      "Local~PROFINET_IO-System" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IO System
      "Local~PROFINET_IO-System_1" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 1
      "Local~PROFINET_IO-System_2" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 2
      "Local~PROFINET_IO-System_3" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 3
      "Local~PROFINET_IO-System_4" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 4
      "Local~PROFINET_IO-System_5" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 5
      "Local~PROFINET_IO-System_6" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 6
      "Local~PROFINET_IO-System_7" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 7
      "Local~PROFINET_IO-System_8" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 8
      "Local~PROFINET_IO-System_9" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 9
   END_VAR


BEGIN

END_DATA_BLOCK

TYPE "UDT_PNDevice"
VERSION : 0.1
   STRUCT
      PNNetworknumber : Int := 1;   // Number of the profinet network where device exist
      PNDeviceNumber : Int := 0;   // Profinet number of the device
      PNDeviceFound { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Device found in Profinet structure
   END_STRUCT;

END_TYPE

TYPE "UDT_VfdSinaParameterUser"
TITLE = UDT_VFD_SinaParameterUser
VERSION : 0.1
//User-defined structure of Siemens parameter.
   STRUCT
      siParaNo : UInt;   // Number of parameter (Number 1..65535)
      siIndex : Int;   // Subindex (Number 1..65535)
      srValue : Real;   // Value of parameter
      sdValue : DInt;   // Value of parameter
      syFormat : Byte := BYTE#16#00;   // Format of value (Format 0x40..0x44)
      swErrorNo : Word := WORD#16#0000;   // Error number (see table below)
   END_STRUCT;

END_TYPE

TYPE "UDT_ConveyorCommonConfiguration"
VERSION : 0.1
   STRUCT
      Length : DInt;   // Conveyor length [mm]
      LengthCorrection : DInt;   // Length correction [mm]
   END_STRUCT;

END_TYPE

TYPE "UDT_InductParcelData"
VERSION : 0.1
   STRUCT
      GINNumber : Int;   // GIN number
      GapRequired : Int;   // Size of gap requested by induct
      WindowPosition : Int;   // Position of the window in the merge tracking
      WindowReserved { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The window is reserved for the induct
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_OnOffDelayDistance"
TITLE = FB_TimerOnOffDelay
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 18
// END_ATTRIBUTES
//Function block to generate on/off signal delay.
   VAR_INPUT 
      idi_OnDelayDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // On delay distance [cm]
      idi_OffDelayDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Off delay distance [cm]
      ii_Displacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Actual displacement
      ix_SignalToDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Input signal to be delayed
      ix_Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;   // Measuring enable
   END_VAR

   VAR_OUTPUT 
      qdi_ActualDelayDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Actual delay distance [cm]
      qx_DelayedSignal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Delayed signal output
   END_VAR

   VAR RETAIN
      sdi_ActualDelayDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Actual delay distance [cm]
   END_VAR
   VAR 
      s_R_TRIG_Signal {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Siemens "R_Trig" - to prepare the rising edge trigger on "ix_SignalToDelay" signal
      s_F_TRIG_Signal {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Siemens "F_Trig" - to prepare the falling edge trigger on "ix_SignalToDelay" signal
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	26/04/2023  | 0.1       | F.Baten       | first release MHS TIA 15.1
	*)
	
	REGION Step 1 – Input signal edge detection 
	    
	    #s_R_TRIG_Signal(CLK := #ix_SignalToDelay);
	    
	    
	    #s_F_TRIG_Signal(CLK := #ix_SignalToDelay);
	    
	END_REGION
	
	REGION Step 2 – Actual delay distance initialization
	    
	    IF (#s_R_TRIG_Signal.Q OR #s_F_TRIG_Signal.Q)           // Input signal changed        
	    THEN
	        
	        #sdi_ActualDelayDistance := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION Step 3 – On/Off delay distance calculation
	    
	    
	    IF (#ix_SignalToDelay                                       // Signal to be delayed is active
	        AND #ix_Enable)                                         // Measuring enabled                   
	    THEN
	        
	        // Timer on
	        IF (#sdi_ActualDelayDistance >= #idi_OnDelayDistance)
	        THEN
	            
	            #qx_DelayedSignal := TRUE;
	            
	        ELSE
	            
	            #sdi_ActualDelayDistance += ABS(#ii_Displacement);
	            
	        END_IF;
	        
	    END_IF;
	    
	    // Timer off
	    IF (NOT #ix_SignalToDelay                                   // Signal to be delayed is not active
	        AND #ix_Enable)                                         // Measuring enabled                 
	    THEN
	        
	        IF (#sdi_ActualDelayDistance >= #idi_OffDelayDistance)
	        THEN
	            
	            #qx_DelayedSignal := FALSE;
	            
	        ELSE
	            
	            #sdi_ActualDelayDistance += ABS(#ii_Displacement);
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION Step 4 – Actual time
	    
	    #qdi_ActualDelayDistance := #sdi_ActualDelayDistance;
	    
	END_REGION
END_FUNCTION_BLOCK

TYPE "UDT_PECDConfiguration"
VERSION : 0.1
   STRUCT
      Distance : DInt;   // Distance between photo eye and the end of conveyor [mm]
      OnDelayDistance : DInt;   // Photo eye distance on delay [cm]
      OffDelayDistance : DInt;   // Photo eye distance off delay [cm]
      JamDisplacementLimit : Int;   // Limit displacement with PEC blocked o detect jam [cm]
      ResetWithPECBlocked : Bool := TRUE;   // When 'True' Allow reset system after jam with PEC blocked
   END_STRUCT;

END_TYPE

TYPE "UDT_MotorData"
VERSION : 0.1
   STRUCT
      MainVoltage : Int;   // [Volt] Mains
      NominalVoltage : Int;   // [Volt] Motor nameplate for applicable connection
      NominalCurrent : Real;   // [Amps] Motor nameplate for applicable connection
      NominalPower : Real;   // [kW] Motor nameplate
      NominalSpeed : Int;   // [RPM] Motor nameplate
      NominalTorque : Real;   // [Nm] Motor nameplate
      CosPhi : Real;   // 0.0 - 0.99 Motor nameplate
      Connection : Int;   // 0=Start , 1=Delta
      BrakeConfig { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE = Brake control from VFD. FALSE = No Brake
      EncoderConfig { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE = Encoder connected at the VFD . FALSE = No encoder at the VFD
      EncoderResolution : Int;   // Pulses Per Rev
      ThermalConfig : Int;   // 0=No thermal control, 1= PTC1, 2=KTY84, 4= Bimetalic Switch
      NoMotorsParallel : Int;   // Number of motors in parallel
      VFDType : Int;   // Specific code 1= G120C, 5302= G120D 0,75kW, 5304= G120D 1,5kW, 5306= G120D 3kW, 5307= G120D 4kW, 5308= 5,5kW, 5309= G120D 7,5kW
      MinimumRamp : Int;   // Minimum applicable ramp in ms
      FAdress : Real;   // Safety adress from HW configuration
   END_STRUCT;

END_TYPE

TYPE "UDT_InductGapsize"
VERSION : 0.1
   STRUCT
      "Maximal length" : Int;   // Maximal length of parcel [cm]
      Gap : Int;   // Gapsize of this size parcel [cm]
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_VfdNORDParaAcycRead"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 34
// END_ATTRIBUTES
   VAR_INPUT 
      iHW_Identifier { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_IO;
      ii_FISystembus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 1;
      ii_Parameter_Number { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ii_Parameter_Index { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ii_Parameter_Set { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ix_Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_OUTPUT 
      qdi_Value { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      qw_Error_ID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
      qx_Valid { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      qx_Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR 
      sa_Write_Val { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..3] of Word;
      sa_Rec_Write { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} AT sa_Write_Val : Struct
         PKE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
         Index { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
         Para_Val { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      END_STRUCT;
      sa_Read_Val { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..3] of Word;
      sa_Rec_Read { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} AT sa_Read_Val : Struct
         PKE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
         Index { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
         Para_Val { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      END_STRUCT;
      sv_WRREC_Instance {InstructionName := 'WRREC'; LibVersion := '1.1'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : WRREC;
      sv_RDREC_Instance {InstructionName := 'RDREC'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : RDREC;
      sw_Ak { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
      sdi_Data_Record { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      sdi_ValueStatic { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      sw_Pnu { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
      sw_ErrorIDStatic { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
      si_Receivecounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      sx_ValidStatic { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_ErrorStatic { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_TEMP 
      tw_ResponseIND : Word;
      tw_ResponseLABEL : Word;
      tw_ResponsePNU : Word;
      tdi_ResponsePWE : DInt;
      tx_WithIndex : Bool;
      tx_WithParameterSet : Bool;
   END_VAR

   VAR CONSTANT 
      cw_IncorrectSubindex : Word := 3;
      cw_InternalResponseLabelCannotBeDepicted : Word := 202;
      cw_NoResponse : Word := 0;
      cw_OrderCannotBeExecuted : Word := 7;
      cw_OrderParameterValue : Word := 1;
      cw_ParameterOffset : Word := 1000;
      cw_PNUMask : Word := 16#07FF;
      ci_ReceivecounterMax : Int := 255;
      ci_Length : UInt := 8;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	25/01/2021  | 0.1       | S.Theocharis  | Copy from NORD library 
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5            
	*)
	
	#tx_WithIndex := #ii_Parameter_Index > 0;
	#tx_WithParameterSet := #ii_Parameter_Set > 0;
	
	CASE #si_State OF
	        
	    0:
	        IF #ix_Enable AND
	            NOT ((#ii_Parameter_Set < 0) OR (#ii_Parameter_Index < 0) OR (#ii_Parameter_Set > 4) OR
	            (#tx_WithParameterSet AND (#ii_Parameter_Index > 64)) OR (NOT #tx_WithParameterSet AND (#ii_Parameter_Index > 256))) THEN
	            //initialize
	            #si_Receivecounter := 0;
	            
	            // get PROFINET IO data record
	            IF (#ii_Parameter_Number >= 150 AND #ii_Parameter_Number <= 199) OR (#ii_Parameter_Number >= 800 AND #ii_Parameter_Number <= 849) THEN
	                // order to the bus interface
	                #sdi_Data_Record := 100;
	            ELSIF ((#ii_Parameter_Number >= 0 AND #ii_Parameter_Number < 150) OR (#ii_Parameter_Number >= 200 AND #ii_Parameter_Number <= 799) OR
	                (#ii_Parameter_Number >= 850 AND #ii_Parameter_Number <= 999)) AND (#ii_FISystembus > 0) AND (#ii_FISystembus <= 8) THEN
	                // order to frequency inverter 1..8
	                #sdi_Data_Record := #ii_FISystembus + 100;
	            ELSE
	                #sdi_Data_Record := 0;
	            END_IF;
	            
	            // get order label (AK)
	            #sw_Ak := #cw_OrderParameterValue;
	            
	            // merge parameter label (PKE)
	            #sw_Pnu := INT_TO_WORD(#ii_Parameter_Number + WORD_TO_INT(#cw_ParameterOffset));
	            #sa_Rec_Write.PKE := SHL(IN := #sw_Ak, N := 12) OR #sw_Pnu;
	            
	            // get sub-index (IND)
	            IF #tx_WithIndex AND #tx_WithParameterSet THEN
	                #sa_Rec_Write.Index := SHL(IN := SHL(IN := INT_TO_WORD((#ii_Parameter_Index) - 1), N := 2) OR
	                                           INT_TO_WORD((#ii_Parameter_Set) - 1), N := 8);
	            ELSIF NOT #tx_WithIndex AND #tx_WithParameterSet THEN
	                #sa_Rec_Write.Index := SHL(IN := INT_TO_WORD((#ii_Parameter_Set) - 1), N := 8);
	            ELSIF #tx_WithIndex AND NOT #tx_WithParameterSet THEN
	                #sa_Rec_Write.Index := SHL(IN := INT_TO_WORD((#ii_Parameter_Index) - 1), N := 8);
	            ELSE
	                #sa_Rec_Write.Index := 0;
	            END_IF;
	            
	            // check if parameter or index changed from last request
	            IF (#sa_Rec_Read.PKE AND #cw_PNUMask) <> (#sa_Rec_Write.PKE AND #cw_PNUMask) OR
	                (#sa_Rec_Read.Index <> #sa_Rec_Write.Index) THEN
	                // if changed reset valid bit
	                #sx_ValidStatic := FALSE;
	                #sx_ErrorStatic := FALSE;
	            END_IF;
	            
	            // write data to device
	            #sv_WRREC_Instance(REQ := TRUE,
	                               ID := #iHW_Identifier,
	                               INDEX := #sdi_Data_Record,
	                               LEN := #ci_Length,
	                               DONE => #sv_WRREC_Instance.DONE,
	                               BUSY => #sv_WRREC_Instance.BUSY,
	                               ERROR => #sv_WRREC_Instance.ERROR,
	                               RECORD := #sa_Write_Val);
	            #si_State := 1;
	        ELSIF #ix_Enable AND
	            ((#ii_Parameter_Set < 0) OR (#ii_Parameter_Index < 0) OR (#ii_Parameter_Set > 4) OR
	            (#tx_WithParameterSet AND (#ii_Parameter_Index > 63)) OR (NOT #tx_WithParameterSet AND (#ii_Parameter_Index > 255))) THEN
	            #sx_ValidStatic := FALSE;
	            #sx_ErrorStatic := TRUE;
	            #sdi_ValueStatic := 0;
	            #sw_ErrorIDStatic := #cw_IncorrectSubindex;
	        ELSE
	            #sv_RDREC_Instance(REQ := FALSE,
	                               ID := #iHW_Identifier,
	                               INDEX := #sdi_Data_Record,
	                               MLEN := #ci_Length,
	                               RECORD := #sa_Read_Val);
	            #sx_ValidStatic := FALSE;
	            #sx_ErrorStatic := FALSE;
	            #sw_ErrorIDStatic := 0;
	            #sdi_ValueStatic := 0;
	        END_IF;
	        
	    1:
	        #sv_WRREC_Instance();
	        
	        IF #sv_WRREC_Instance.DONE THEN
	            #sv_WRREC_Instance(REQ := FALSE);
	            #si_State := 2;
	        ELSIF #sv_WRREC_Instance.ERROR THEN
	            #sx_ValidStatic := FALSE;
	            #sx_ErrorStatic := TRUE;
	            #sdi_ValueStatic := 0;
	            #sw_ErrorIDStatic := DWORD_TO_WORD(#sv_WRREC_Instance.STATUS);
	            #si_State := 0;
	        END_IF;
	        
	    2:
	        #sv_RDREC_Instance(REQ := TRUE,
	                           ID := #iHW_Identifier,
	                           INDEX := #sdi_Data_Record,
	                           MLEN := #ci_Length,
	                           RECORD := #sa_Read_Val);
	        
	        #tw_ResponseLABEL := SHR(IN := #sa_Rec_Read.PKE, N := 12);
	        #tw_ResponsePNU := #sa_Rec_Read.PKE AND #cw_PNUMask;
	        #tw_ResponseIND := #sa_Rec_Read.Index;
	        #tdi_ResponsePWE := #sa_Rec_Read.Para_Val;
	        
	        IF #sv_RDREC_Instance.ERROR THEN
	            #sx_ValidStatic := FALSE;
	            #sx_ErrorStatic := TRUE;
	            #sdi_ValueStatic := 0;
	            #sw_ErrorIDStatic := DWORD_TO_WORD(#sv_RDREC_Instance.STATUS);
	            #si_State := 0;
	        ELSIF #sv_RDREC_Instance.VALID AND #tw_ResponseLABEL = #cw_OrderCannotBeExecuted THEN
	            #sx_ValidStatic := FALSE;
	            #sx_ErrorStatic := TRUE;
	            #sdi_ValueStatic := 0;
	            #sw_ErrorIDStatic := DINT_TO_WORD(#tdi_ResponsePWE);
	            #si_State := 0;
	        ELSIF #sv_RDREC_Instance.VALID AND #tw_ResponseLABEL <> #cw_NoResponse AND
	            #tw_ResponseLABEL <> #cw_OrderCannotBeExecuted AND #tw_ResponsePNU = #sw_Pnu AND
	            #tw_ResponseIND = #sa_Rec_Write.Index THEN
	            // acyclic read command complete
	            #sx_ValidStatic := TRUE;
	            #sx_ErrorStatic := FALSE;
	            #sdi_ValueStatic := #tdi_ResponsePWE;
	            #sw_ErrorIDStatic := 0;
	            #si_State := 0;
	        END_IF;
	        
	        // check for read timeout
	        IF #si_Receivecounter >= #ci_ReceivecounterMax THEN
	            #sx_ValidStatic := FALSE;
	            #sx_ErrorStatic := TRUE;
	            #sdi_ValueStatic := 0;
	            #sw_ErrorIDStatic := #cw_InternalResponseLabelCannotBeDepicted;
	            #si_State := 0;
	        ELSE
	            #si_Receivecounter := #si_Receivecounter + 1;
	        END_IF;
	        
	END_CASE;
	
	// output assignment
	#qx_Busy := INT_TO_BOOL(#si_State);
	IF #ix_Enable THEN
	    #qx_Valid := #sx_ValidStatic;
	    #qx_Error := #sx_ErrorStatic;
	    #qw_Error_ID := #sw_ErrorIDStatic;
	    #qdi_Value := #sdi_ValueStatic;
	ELSE
	    #qx_Valid := FALSE;
	    #qx_Error := FALSE;
	    #qw_Error_ID := 0;
	    #qdi_Value := 0;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_VfdNORDParaAcycWrite"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 35
// END_ATTRIBUTES
   VAR_INPUT 
      HW_Identifier { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_IO;
      idi_Value { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      ii_FISystembus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 1;
      ii_ParameterNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ii_ParameterIndex { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ii_ParameterSet { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ix_Execute { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ix_Parameter32Bit { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ix_RAM_Only { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_OUTPUT 
      qx_Done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      qx_Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      qdi_ValueRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      qw_ErrorID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
   END_VAR

   VAR 
      sa_WriteVal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..3] of Word;
      sa_RecWrite { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} AT sa_WriteVal : Struct
         PKE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
         Index { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
         Para_Val { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      END_STRUCT;
      sa_ReadVal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..3] of Word;
      sa_RecRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} AT sa_ReadVal : Struct
         PKE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
         Index { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
         Para_Val { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      END_STRUCT;
      sv_WRRECInstance {InstructionName := 'WRREC'; LibVersion := '1.1'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : WRREC;
      sv_RDRECInstance {InstructionName := 'RDREC'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : RDREC;
      sw_Ak { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
      sw_Pnu { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
      sw_ErrorIDStatic { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
      sdi_DataRecord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      si_Receivecounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      sx_FLMExecute { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_REdgeExecute { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_DoneStatic { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_ErrorStatic { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_TEMP 
      tw_ResponseIND : Word;
      tw_ResponseLABEL : Word;
      tw_ResponsePNU : Word;
      tdi_ResponsePWE : DInt;
      tx_WithIndex : Bool;
      tx_WithParameterSet : Bool;
   END_VAR

   VAR CONSTANT 
      cw_ChangeParameterValueWordEEPROM : Word := 2;
      cw_ChangeParameterValueWordRAM : Word := 14;
      cw_ChangeParameterValueDoubleWordEEPROM : Word := 3;
      cw_ChangeParameterValueDoubleWordRAM : Word := 13;
      cw_IncorretSubindex : Word := 3;
      cw_InternalResponseLabelCannotBeDepicted : Word := 202;
      cw_InvalidDataType : Word := 5;
      cw_NoResponse : Word := 0;
      cw_OrderCannotBeExecuted : Word := 7;
      cw_ParameterOffset : Word := 1000;
      cw_PNUMask : Word := 16#07FF;
      ci_ReceivecounterMax : Int := 255;
      ci_Length : UInt := 8;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	25/01/2021  | 0.1       | S.Theocharis  | Copy fron NORD library 
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5           
	*)
	// protects the frequency inverter from too frequent write requests.
	IF #ix_Execute <> #sx_FLMExecute THEN
	    IF #ix_Execute THEN
	        #sx_REdgeExecute := TRUE;
	    ELSE
	        #sx_REdgeExecute := FALSE;
	    END_IF;
	    #sx_FLMExecute := #ix_Execute;
	ELSE
	    #sx_REdgeExecute := FALSE;
	END_IF;
	
	#tx_WithIndex := #ii_ParameterIndex > 0;
	#tx_WithParameterSet := #ii_ParameterSet > 0;
	
	CASE #si_State OF
	        
	    0:
	        IF #sx_REdgeExecute AND
	            NOT ((#ii_ParameterSet < 0) OR (#ii_ParameterIndex < 0) OR (#ii_ParameterSet > 4) OR
	            (#tx_WithParameterSet AND (#ii_ParameterIndex > 64)) OR (NOT #tx_WithParameterSet AND (#ii_ParameterIndex > 256)) OR
	            (NOT #ix_Parameter32Bit AND #idi_Value < -32768) OR (NOT #ix_Parameter32Bit AND #idi_Value > 16#FFFF)) THEN
	            //initialize
	            #sx_DoneStatic := FALSE;
	            #sx_ErrorStatic := FALSE;
	            #sw_ErrorIDStatic := 0;
	            #si_Receivecounter := 0;
	            #qx_Done := FALSE;
	            #qx_Busy := TRUE;
	            
	            // get PROFINET IO data record
	            IF (#ii_ParameterNumber >= 150 AND #ii_ParameterNumber <= 199) OR (#ii_ParameterNumber >= 800 AND #ii_ParameterNumber <= 849) THEN
	                // order to the bus interface
	                #sdi_DataRecord := 100;
	            ELSIF ((#ii_ParameterNumber >= 0 AND #ii_ParameterNumber < 150) OR (#ii_ParameterNumber >= 200 AND #ii_ParameterNumber <= 799) OR
	                (#ii_ParameterNumber >= 850 AND #ii_ParameterNumber <= 999)) AND (#ii_FISystembus > 0) AND (#ii_FISystembus <= 8) THEN
	                // order to frequency inverter 1..8
	                #sdi_DataRecord := #ii_FISystembus + 100;
	            ELSE
	                #sdi_DataRecord := 0;
	            END_IF;
	            
	            // get order label (AK)
	            IF #ix_RAM_Only THEN
	                IF #ix_Parameter32Bit THEN
	                    #sw_Ak := #cw_ChangeParameterValueDoubleWordRAM;
	                ELSE
	                    #sw_Ak := #cw_ChangeParameterValueWordRAM;
	                END_IF;
	            ELSE
	                IF #ix_Parameter32Bit THEN
	                    #sw_Ak := #cw_ChangeParameterValueDoubleWordEEPROM;
	                ELSE
	                    #sw_Ak := #cw_ChangeParameterValueWordEEPROM;
	                END_IF;
	            END_IF;
	            
	            // merge parameter label (PKE)
	            #sw_Pnu := INT_TO_WORD(#ii_ParameterNumber + WORD_TO_INT(#cw_ParameterOffset));
	            #sa_RecWrite.PKE := SHL(IN := #sw_Ak, N := 12) OR #sw_Pnu;
	            
	            // get sub-index (IND)
	            IF #tx_WithIndex AND #tx_WithParameterSet THEN
	                #sa_RecWrite.Index := SHL(IN := SHL(IN := INT_TO_WORD((#ii_ParameterIndex) - 1), N := 2) OR
	                                          INT_TO_WORD((#ii_ParameterSet) - 1), N := 8);
	            ELSIF NOT #tx_WithIndex AND #tx_WithParameterSet THEN
	                #sa_RecWrite.Index := SHL(IN := INT_TO_WORD((#ii_ParameterSet) - 1), N := 8);
	            ELSIF #tx_WithIndex AND NOT #tx_WithParameterSet THEN
	                #sa_RecWrite.Index := SHL(IN := INT_TO_WORD((#ii_ParameterIndex) - 1), N := 8);
	            ELSE
	                #sa_RecWrite.Index := 0;
	            END_IF;
	            
	            // get parameter value (PWE)
	            #sa_RecWrite.Para_Val := #idi_Value;
	            
	            // write data to device
	            #sv_WRRECInstance(REQ := TRUE,
	                              ID := #HW_Identifier,
	                              INDEX := #sdi_DataRecord,
	                              LEN := #ci_Length,
	                              DONE => #sv_WRRECInstance.DONE,
	                              BUSY => #sv_WRRECInstance.BUSY,
	                              ERROR => #sv_WRRECInstance.ERROR,
	                              RECORD := #sa_WriteVal);
	            #si_State := 1;
	        ELSIF #sx_REdgeExecute AND
	            ((#ii_ParameterSet < 0) OR (#ii_ParameterIndex < 0) OR (#ii_ParameterSet > 4) OR
	            (#tx_WithParameterSet AND (#ii_ParameterIndex > 63)) OR (NOT #tx_WithParameterSet AND (#ii_ParameterIndex > 255))) THEN
	            #sx_DoneStatic := FALSE;
	            #sx_ErrorStatic := TRUE;
	            #sw_ErrorIDStatic := #cw_IncorretSubindex;
	        ELSIF #sx_REdgeExecute AND
	            ((NOT #ix_Parameter32Bit AND #idi_Value < -32768) OR (NOT #ix_Parameter32Bit AND #idi_Value > 16#FFFF)) THEN
	            // limitation to int value range. positive hex crc checksums are allowed
	            #sx_DoneStatic := FALSE;
	            #sx_ErrorStatic := TRUE;
	            #sw_ErrorIDStatic := #cw_InvalidDataType;
	        ELSE
	            #sv_RDRECInstance(REQ := FALSE,
	                              ID := #HW_Identifier,
	                              INDEX := #sdi_DataRecord,
	                              MLEN := #ci_Length,
	                              RECORD := #sa_ReadVal);
	        END_IF;
	        
	    1:
	        #sv_WRRECInstance();
	        
	        IF #sv_WRRECInstance.DONE THEN
	            #sv_WRRECInstance(REQ := FALSE);
	            #si_State := 2;
	        ELSIF #sv_WRRECInstance.ERROR THEN
	            #sx_DoneStatic := FALSE;
	            #sx_ErrorStatic := TRUE;
	            #sw_ErrorIDStatic := DWORD_TO_WORD(#sv_WRRECInstance.STATUS);
	            #si_State := 0;
	            #qx_Done := FALSE;
	            #qx_Busy := TRUE;
	        END_IF;
	        
	    2:
	        #sv_RDRECInstance(REQ := TRUE,
	                          ID := #HW_Identifier,
	                          INDEX := #sdi_DataRecord,
	                          MLEN := #ci_Length,
	                          RECORD := #sa_ReadVal);
	        
	        #tw_ResponseLABEL := SHR(IN := #sa_RecRead.PKE, N := 12);
	        #tw_ResponsePNU := #sa_RecRead.PKE AND #cw_PNUMask;
	        #tw_ResponseIND := #sa_RecRead.Index;
	        #tdi_ResponsePWE := #sa_RecRead.Para_Val;
	        #qdi_ValueRead := #sa_RecRead.Para_Val;
	        IF #sv_RDRECInstance.ERROR THEN
	            #sx_DoneStatic := FALSE;
	            #sx_ErrorStatic := TRUE;
	            #sw_ErrorIDStatic := DWORD_TO_WORD(#sv_RDRECInstance.STATUS);
	            #si_State := 0;
	        ELSIF #sv_RDRECInstance.VALID AND #tw_ResponseLABEL = #cw_OrderCannotBeExecuted THEN
	            #sx_DoneStatic := FALSE;
	            #sx_ErrorStatic := TRUE;
	            #sw_ErrorIDStatic := DINT_TO_WORD(#tdi_ResponsePWE);
	            #si_State := 0;
	        ELSIF #sv_RDRECInstance.VALID AND #tw_ResponseLABEL <> #cw_NoResponse AND
	            #tw_ResponseLABEL <> #cw_OrderCannotBeExecuted AND #tw_ResponsePNU = #sw_Pnu AND
	            #tw_ResponseIND = #sa_RecWrite.Index THEN
	            // acyclic write command complete
	            #sx_DoneStatic := TRUE;
	            #si_State := 0;
	        END_IF;
	        
	        // check for read timeout
	        IF #si_Receivecounter >= #ci_ReceivecounterMax THEN
	            #sx_DoneStatic := FALSE;
	            #sx_ErrorStatic := TRUE;
	            #sw_ErrorIDStatic := #cw_InternalResponseLabelCannotBeDepicted;
	            #si_State := 0;
	        ELSE
	            #si_Receivecounter := #si_Receivecounter + 1;
	        END_IF;
	END_CASE;
	
	// output assignment
	#qx_Busy := INT_TO_BOOL(#si_State) AND NOT #sx_DoneStatic AND NOT #sx_ErrorStatic;
	IF #ix_Execute THEN
	    #qx_Done := #sx_DoneStatic;
	    #qx_Error := #sx_ErrorStatic;
	    #qw_ErrorID := #sw_ErrorIDStatic;
	ELSE
	    #qx_Done := FALSE;
	    #qx_Error := FALSE;
	    #qw_ErrorID := 0;
	END_IF;
END_FUNCTION_BLOCK

TYPE "UDT_VfdNordParameter"
TITLE = UDT_VfdNordParameter
VERSION : 0.1
//Parameter structure to read and write
   STRUCT
      WriteValue : DInt;   // Parameter value to write
      ActualValue : DInt;   // Actual value read from VFD
      ParaNumber : Int;   // Parameter number to access
      Index : Int;   // Parameter index number to access
      ParaSet : Int;   // Parameter set to acces
      Format32 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Write the parameter in DWord format. 0 = Write the parameter in Word format
      WriteAccess { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Write the parameter. 0 = Read the parameter
      InUse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Parameter is to be processed
      RamOnly { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Save parameter in RAM, 0 = Save parameter in RAM and EEPROM
   END_STRUCT;

END_TYPE

TYPE "UDT_FifoHeader"
TITLE = UDT_FifoHeader
VERSION : 0.1
//User-defined structure of FIFO register header information.
   STRUCT
      Status : Struct   // Status bits
         Empty { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO Empty
         Prefull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO Prefull
         Full { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO Full
      END_STRUCT;
      NextEntryToRead : Int;   // Next FIFO entry to read
      NextEntryToWrite : Int;   // Next FIFO entry to write
      MaxNrOfEntries : Int;   // Maximum number of FIFO entries
      TotalEntriesStored : Int;   // Total number of FIFO entries
   END_STRUCT;

END_TYPE

TYPE "UDT_FIFOInductInfo"
VERSION : 0.1
   STRUCT
      InductNumber : Int;   // Induct number
      GapSize : Int;   // Size of gap requested by induct
      RemoveEntry { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Entry is not needed by induct anymore
   END_STRUCT;

END_TYPE

TYPE "UDT_FifoStatus"
TITLE = UDT_FifoStatus
VERSION : 0.1
//
//User-defined structure of FC_Fifo function status.
//Version History:
//Date              | Version   | Author         | Remark
//24/05/2019  | 0.1           | K.Pokorski   | first release MHSE TIA 15.1
//24/05/2019  | 0.2           | K.Pokorski   | first release MHSE TIA 15.1
//
   STRUCT
      InvalidMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid mode selected
      InvalidMaxNrOfEntries { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid maximum number of entries or buffer is not an array
      InvalidTotalEntriesStored { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid total number of entries
      InvalidNextEntryToWrite { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid number of next entry to write
      InvalidNextEntryToRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid number of next entry to read
      InvalidDataType { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message and buffer element data type inconsistent
      FifoPreFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 90 % of FIFO data buffer capacity reached
      FifoFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO data buffer full
   END_STRUCT;

END_TYPE

DATA_BLOCK "DB_GIN"
TITLE = DB_GIN
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
NON_RETAIN
//Data block to store parcels informations.
   VAR 
      GIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Array[1..1] of "UDT_GIN";   // GIN informations - for project remove unneeded customers and extend array bound range to 9999
   END_VAR


BEGIN

END_DATA_BLOCK

DATA_BLOCK "DB_HMIStatusConfiguration"
TITLE = DB_HMIStatusConfiguration
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
VERSION : 3.0
NON_RETAIN
   VAR 
      FireAlarm : Int;   // Fire alarm active
      SafetyStop : Int;   // Safety stop error status
      Error : Int;   // Error status
      Warning : Int;   // Warning status
      ManualRun : Int;   // Manual run status
      Manual : Int;   // Manual status
      Halted : Int;   // Halted status
      Dieback : Int;   // Die back status
      Stopped : Int;   // Stopped status
      Running : Int;   // Running status
      EnergySave : Int;   // Energy save status
      CommunicationError : Int;   // Communication error status
      CBError : Int;   // CB error status
      ProfinetError : Int;   // Profinet error status
      HardwareError : Int;   // Hardware error status
      VFDNotHealthy : Int;   // VFD noth healthy status
      VFDError : Int;   // VFD error status
      PECJam : Int;   // PEC jam status
      ChuteFull : Int;   // Chute full status
      EncoderError : Int;   // Encoder error status
      TrackingError : Int;   // Tracking error status
      DimensionError : Int;   // Dimension error status
      OperationalError : Int;   // Operational error status
      AutoON : Int;   // Automatic is on
      ChuteHalfFull : Int;   // Disable by operator
      DisableByManagement : Int;   // Disable by management
      GateOpen : Int;   // Manual operated gate is open
      GateClosed : Int;   // Manual operated gate is closed
      GateClosedAndNoOperatorPresent : Int;   // Manual operated gate is closed and no operator is present
      PositionChangeOngoing : Int;   // Lifting device or arm diverter changing position
      BufferMode : Int;   // BufferMode Active
      ContinuousMode : Int;   // ContinuousMode Active
      LabbelingMode : Int;   // LabbelingMode Active
   END_VAR


BEGIN
   FireAlarm := 1;
   SafetyStop := 3;
   Error := 5;
   Warning := 7;
   ManualRun := 9;
   Manual := 11;
   Halted := 13;
   Dieback := 15;
   Stopped := 17;
   Running := 19;
   EnergySave := 21;
   CommunicationError := 23;
   CBError := 25;
   ProfinetError := 27;
   HardwareError := 29;
   VFDNotHealthy := 31;
   VFDError := 33;
   PECJam := 35;
   ChuteFull := 37;
   EncoderError := 39;
   TrackingError := 41;
   DimensionError := 43;
   OperationalError := 45;
   AutoON := 47;
   ChuteHalfFull := 49;
   DisableByManagement := 51;
   GateOpen := 53;
   GateClosed := 55;
   GateClosedAndNoOperatorPresent := 57;
   PositionChangeOngoing := 59;
   BufferMode := 61;
   ContinuousMode := 63;
   LabbelingMode := 65;

END_DATA_BLOCK

FUNCTION_BLOCK "FB_TimerOnOffDelay"
TITLE = FB_TimerOnOffDelay
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 32
// END_ATTRIBUTES
//Function block to generate on/off signal delay.
   VAR_INPUT 
      iudi_OnDelayTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // On delay time [ms]
      iudi_OffDelayTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Off delay time [ms]
      ix_SignalToDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Input signal to be delayed
      ix_Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;   // Timer Enable
   END_VAR

   VAR_OUTPUT 
      qlr_ActualTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Actual time
      qx_DelayedSignal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Delayed signal output
   END_VAR

   VAR 
      s_R_TRIG_Signal {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Siemens "R_Trig" - to prepare the rising edge trigger on "ix_SignalToDelay" signal
      s_F_TRIG_Signal {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Siemens "F_Trig" - to prepare the falling edge trigger on "ix_SignalToDelay" signal
   END_VAR
   VAR RETAIN
      slr_ActualDelayTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Actual delay time [ms]
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	26/08/2019  | 2.1       | M.Kurpiers    | Comments adjusted
	04/11/2019  | 2.2       | L.Klar        | Prevoius cycle scan changed from memory to DB variable
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION Step 1 – Input signal edge detection 
	    
	    #s_R_TRIG_Signal(CLK := #ix_SignalToDelay);
	    
	    
	    #s_F_TRIG_Signal(CLK := #ix_SignalToDelay);
	    
	END_REGION
	
	REGION Step 2 – Actual delay time initialization
	    
	    IF (#s_R_TRIG_Signal.Q OR #s_F_TRIG_Signal.Q)           // Input signal changed        
	    THEN
	        
	        #slr_ActualDelayTime := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION Step 3 – On/Off delay time calculation
	    
	    
	    IF (#ix_SignalToDelay                                       // Signal to be delayed is active
	        AND #ix_Enable)                                         // Ttimer enabled                   
	    THEN
	        
	        // Timer on
	        IF (#slr_ActualDelayTime >= #iudi_OnDelayTime)
	        THEN
	            
	            #qx_DelayedSignal := TRUE;
	            
	        ELSE
	            
	            #slr_ActualDelayTime += "DB_Memory".PrevCycleTime;
	            
	        END_IF;
	        
	    END_IF;
	    
	    // Timer off
	    IF (NOT #ix_SignalToDelay                                   // Signal to delay is not active
	        AND #ix_Enable)                                         // Timer is enabled                  
	    THEN
	        
	        IF (#slr_ActualDelayTime >= #iudi_OffDelayTime)
	        THEN
	            
	            #qx_DelayedSignal := FALSE;
	            
	        ELSE
	            
	            #slr_ActualDelayTime += "DB_Memory".PrevCycleTime;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION Step 4 – Actual time
	    
	    #qlr_ActualTime := #slr_ActualDelayTime;
	    
	END_REGION
END_FUNCTION_BLOCK

TYPE "UDT_PECConfiguration"
VERSION : 0.1
   STRUCT
      Distance : DInt;   // Distance between photo eye and the end of conveyor [mm]
      JamDisplacementLimit : Int;   // Limit displacement with PEC blocked o detect jam [cm]
      TimeOnDelay : UDInt;   // Photo eye time on delay [ms]
      TimeOffDelay : UDInt;   // Photo eye time off delay [ms]
      ResetWithPECBlocked { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // When 'True' Allow reset system after jam with PEC blocked
   END_STRUCT;

END_TYPE

TYPE "UDT_ConveyorHandshake"
TITLE = UDT_ConveyorHandshake
VERSION : 0.1
//User-defined structure of conveyor handshake variables.
   STRUCT
      GIN : Int;   // General identification number
      NrOfPosToShift : Int;   // Number of positions to shift
      DownstreamDisplacement : Int;   // Displacement from downstream [cm]
      RTS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor ready to send
      RTR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor ready to receive
      TIP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Transfer in progress
      ResetEnergySave { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset energy save mode
      CascadeStartUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Cascade startup
      ReqStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request stop
   END_STRUCT;

END_TYPE

TYPE "UDT_AixControllerStatus"
VERSION : 0.1
   STRUCT
      MotorStatus { ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixMotorStatus";
      SpeedFeedbackError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE if  right motor deviates from set speed
      InternalWarning { ExternalWritable := 'False'} : Bool := FALSE;   // An internal warning is active
      InternalError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // An internal error is active
      CommunicationErrorVFD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Communication with VFD timed out
      PNSlaveNotOnline { ExternalWritable := 'False'} : Bool := FALSE;   // Profinet slave is not on line
      PNSlaveError { ExternalWritable := 'False'} : Bool := FALSE;   // Profinet slave has an error
      PNSlaveWarning { ExternalWritable := 'False'} : Bool := FALSE;   // Profinet slave has a warning
      ControllerStatus : DWord;
   END_STRUCT;

END_TYPE

TYPE "UDT_GOSLog"
VERSION : 0.1
   STRUCT
      GIN_nr : Int;
      InfeedUpstreamGap : Int;   // Gap in millimeters (mm)
      InfeedDownstreamGap : Int;   // Gap in millimeters (mm)
      OutfeedUpstreamGap : Int;   // Gap in meters (mm)
      OutfeedDownstreamGap : Int;   // Gap in meters (mm)
      ParcelLength : Int;
      GapToBeRecovered : Int;
      ParcelDownStreamResults : Int;
      ParcelUpStreamResults : Int;
      Accelerate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      Decelerate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      PrevConveyorUpstreamGap : Int;
      PrevConveyorDownstreamGap : Int;
      NextConveyorUpstreamGap : Int;
      NextConveyorDownstreamGap : Int;
   END_STRUCT;

END_TYPE

TYPE "UDT_PECStatus"
VERSION : 0.1
   STRUCT
      PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Current state of the photo eye
      Jam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PEC jam error
   END_STRUCT;

END_TYPE

FUNCTION "FC_Statistics" : Void
TITLE = FC_Statistics
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 26
// END_ATTRIBUTES
//Function to calculate statistics.
   VAR_INPUT 
      ix_Reset : Bool;   // Reset statistics data
      ix_Activate : Bool;   // Activete statistics counters
      ix_RTrigActivate : Bool;   // Activation rise trigger
   END_VAR

   VAR_IN_OUT 
      iqUDT_Statistics : "UDT_EventStatistic";   // Statistic structure
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | C. Leite      | first release MHS TIA 15.1
	17/07/2019  | 0.2       | A.Nowak       | Add comments
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	27/08/2019  | 2.1       | M.Kurpiers    | Comments adjusted
	04/11/2019  | 2.2       | L.Klar        | 1 second pulse changed from memory bit to DB variable
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Number of events
	    
	    IF (#ix_RTrigActivate)      // Event occured                                
	    THEN
	        
	        // Increment the number of times the event occurred and clear the time of the current or last event
	        #iqUDT_Statistics.NumberOfTimes += 1;
	        #iqUDT_Statistics.LastEventSeconds := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Event time
	    
	    // 1 shot every 1 sec and activate statistic counter 
	    IF ("DB_Memory".OS_1sec AND #ix_Activate)
	    THEN
	        
	        // Increment the time of the current or last event and the time of all events that occured
	        #iqUDT_Statistics.LastEventSeconds += 1;
	        #iqUDT_Statistics.TotalEventSeconds += 1;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Data reset
	    
	    
	    IF (#ix_Reset)                                            // Reset statistics data                                          
	    THEN
	        
	        IF (NOT #ix_Activate)                                 // Statistic counter isn't activate                                
	        THEN
	            
	            // Clear statistics data
	            #iqUDT_Statistics.NumberOfTimes := 0;
	            #iqUDT_Statistics.LastEventSeconds := 0;
	            #iqUDT_Statistics.TotalEventSeconds := 0;
	            
	        ELSE
	            
	            // Write 1 to the number of times the event occurred and clear times  
	            #iqUDT_Statistics.NumberOfTimes := 1;
	            #iqUDT_Statistics.LastEventSeconds := 0;
	            #iqUDT_Statistics.TotalEventSeconds := 0;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
END_FUNCTION

TYPE "UDT_PECStatistics"
VERSION : 0.1
   STRUCT
      Jam : "UDT_EventStatistic";   // Number of times PEC got jammed
   END_STRUCT;

END_TYPE

TYPE "UDT_RIOStatus"
VERSION : 0.1
   STRUCT
      Status : Int;   // Status number
      Specific : Struct   // Specific structure
         PNSlaveNotOnline { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet slave is not online
         PNSlaveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet slave is in error
         ET200sp_ErrorModule : Array[0..31] of Bool;   // Module error
         PNSlaveWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet slave has a warning
      END_STRUCT;
   END_STRUCT;

END_TYPE

FUNCTION "FC_GetDevicePN" : Void
TITLE = FC_GetDevicePN
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 18
// END_ATTRIBUTES
   VAR_INPUT 
      is_PNDeviceName : String;   // Name of the device
      ix_SimulationModeActive : Bool;   // True = Simulation mode active
   END_VAR

   VAR_IN_OUT 
      iqUDT_PND : "UDT_PNDevice";   // Device found in Profinet structure
   END_VAR

   VAR_TEMP 
      ti_NrOfConfiguredPNNetworks : Int;   // Number of networks configured in project
      ti_NrOfDevices : Int;   // Nr of devices is networks
      ti_LcPNNetworkNumber : Int;   // Loop counter to find PN network number
      ti_LcPNDeviceNumber : Int;   // Loop counter to find PN device number
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	16/09/2019  | 2.3       | F.Baten       | Cut out of 'FB_RIO'
	29/09/2019  | 2.4       | K.Pokorski    | Network seach started from 1 instead 0
	30/09/2019  | 2.5       | K.Pokorski    | Chagne prefixes of temporary varaibles from 'si' to 'ti'
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Get Device Profinet number
	    // if simulation is disabled 
	    IF NOT #ix_SimulationModeActive
	    THEN
	        // And the profinet device is not found yet
	        IF (#is_PNDeviceName <> "DB_ProfinetDiagnostic".ProfinetNetworks[#iqUDT_PND.PNNetworknumber].DeviceStatus[#iqUDT_PND.PNDeviceNumber].DeviceState.PNDeviceName)
	            OR #iqUDT_PND.PNDeviceFound = FALSE
	        THEN
	            #iqUDT_PND.PNDeviceFound := FALSE;
	            
	            // check how many profinet networks are configured
	            #ti_NrOfConfiguredPNNetworks := "FC_GetNrOfArrayEl"("DB_ProfinetDiagnostic".ProfinetNetworks);
	            
	            FOR #ti_LcPNNetworkNumber := 1 TO (#ti_NrOfConfiguredPNNetworks) DO
	                
	                #iqUDT_PND.PNNetworknumber := #ti_LcPNNetworkNumber;
	                
	                // and check how many devices are configured per network
	                #ti_NrOfDevices := "FC_GetNrOfArrayEl"("DB_ProfinetDiagnostic".ProfinetNetworks[#iqUDT_PND.PNNetworknumber].DeviceStatus);
	                
	                // check for each of the devices in the networks if the PN device name is similair to the configured device name
	                FOR #ti_LcPNDeviceNumber := 0 TO (#ti_NrOfDevices - 1) DO
	                    
	                    #iqUDT_PND.PNDeviceNumber := #ti_LcPNDeviceNumber;
	                    
	                    // set device found when a match is found for the device name in the PN network
	                    IF (#is_PNDeviceName = "DB_ProfinetDiagnostic".ProfinetNetworks[#iqUDT_PND.PNNetworknumber].DeviceStatus[#iqUDT_PND.PNDeviceNumber].DeviceState.PNDeviceName
	                        AND #is_PNDeviceName <> '')
	                    THEN
	                        
	                        #iqUDT_PND.PNDeviceFound := TRUE;
	                        EXIT;
	                        
	                    END_IF;
	                END_FOR;
	                
	                // exit loop when device name is matching
	                IF #iqUDT_PND.PNDeviceFound
	                THEN
	                    
	                    EXIT;
	                    
	                END_IF;
	            END_FOR;
	        END_IF;
	    END_IF;
	    
	END_REGION
END_FUNCTION

FUNCTION "FC_GetPNPortStatus" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 20
// END_ATTRIBUTES
   VAR_INPUT 
      ii_NumberOfPorts : Int;   //  Number of ports in device
      iUDT_DevicePNInfo : "UDT_PNDevice";   //  PN device info structure
   END_VAR

   VAR_OUTPUT 
      qa_PortFault : Array[1..8] of Bool;   //  When TRUE then specific port has a fault
   END_VAR

   VAR_TEMP 
      tp_GetDiagInfo {InstructionName := 'DIS'; LibVersion := '1.0'} : DIS;   //  Diagnostic structure
      tp_DeviceGeoAddr {InstructionName := 'GEOADDR'; LibVersion := '1.0'} : GEOADDR;   //  Device pointer structre
      ta_PortFault : Array[1..8] of Bool;   //  When TRUE then port has a fault
      ti_Geo2LogStatus : Int;   //  GEO2LOG status code
      ti_GetDiagStatus : Int;   //  Get_Diag status code
      ti_Log2GeoStatus : Int;   //  LOG2GEO status code
      ti_Loopcounter : Int;   //  Loop counter
      tui_cnt : UInt;   //  Not used
      tdi_PortLaddr : HW_ANY;   //  HW identifier
      ti_PortFault : Bool;   //  At least one port is faulty
      tx_ConfigurationError : Bool;   //  Configuration error occurred
   END_VAR

   VAR CONSTANT 
      ci_Area : UInt := 1;   //     Area ID of IO Profinet devices
      ci_HWTYPE : UInt := 5;
      ci_PortSlot : UInt := 0;
      ci_PortSubslot : Word := 16#8000;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	03/11/2020  | 3.0       | K.Pokorski    | first release MHS TIA 15.1
	17/12/2020  | 3.1       | K.Pokorski    | Run operation only during error
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Check configuration
	    
	    #tx_ConfigurationError := #ii_NumberOfPorts < 1
	    OR #ii_NumberOfPorts > 8
	    OR NOT #iUDT_DevicePNInfo.PNDeviceFound;
	    
	END_REGION
	
	REGION 2 - Read profinet network number
	    
	    // Using LOG2GEO profinet network address is read
	    #ti_Log2GeoStatus := LOG2GEO(LADDR := "DB_ProfinetDiagnostic".ProfinetNetworks[#iUDT_DevicePNInfo.PNNetworknumber].DeviceStatus[#iUDT_DevicePNInfo.PNDeviceNumber].DeviceState.HW_ID,
	                                 GEOADDR := #tp_DeviceGeoAddr);
	    
	END_REGION
	
	REGION 3 - Preparation the device pointer
	    
	    // HWTYPE = 5 - Submodule
	    #tp_DeviceGeoAddr.HWTYPE := #ci_HWTYPE;
	    // AREA = 1 - PROFINET IO
	    #tp_DeviceGeoAddr.AREA := #ci_Area;
	    // SLOT = 0 - Ports are on slot 0 
	    #tp_DeviceGeoAddr.SLOT := #ci_PortSlot;
	    // STATION - Profinet number
	    #tp_DeviceGeoAddr.STATION := "DB_ProfinetDiagnostic".ProfinetNetworks[#iUDT_DevicePNInfo.PNNetworknumber].DeviceStatus[#iUDT_DevicePNInfo.PNDeviceNumber].DeviceState.ProfinetNumber;
	    
	END_REGION
	
	REGION 4 - Checking the port status
	    // If device report error and is available on the PN network
	    IF "DB_ProfinetDiagnostic".ProfinetNetworks[#iUDT_DevicePNInfo.PNNetworknumber].DeviceStatus[#iUDT_DevicePNInfo.PNDeviceNumber].DeviceState.Error
	        AND "DB_ProfinetDiagnostic".ProfinetNetworks[#iUDT_DevicePNInfo.PNNetworknumber].DeviceStatus[#iUDT_DevicePNInfo.PNDeviceNumber].DeviceState.Exist
	        AND NOT #tx_ConfigurationError
	    THEN
	        
	        // Loop through all profinet ports
	        FOR #ti_Loopcounter := 1 TO #ii_NumberOfPorts DO
	            // Reset auxiliary port fault bit 
	            #ta_PortFault[#ti_Loopcounter] := FALSE;
	            // SUBSLOT = 16#8000 plus port number (TIA structure to refer to port)
	            #tp_DeviceGeoAddr.SUBSLOT := INT_TO_UINT(WORD_TO_INT(#ci_PortSubslot) + (#ti_Loopcounter));
	            // Using GEO2LOG port address is read
	            #ti_Geo2LogStatus := GEO2LOG(GEOADDR := #tp_DeviceGeoAddr, LADDR => #tdi_PortLaddr);
	            // Using GET_DIAG port status is read
	            #ti_GetDiagStatus := GET_DIAG(MODE := 1, LADDR := #tdi_PortLaddr, CNT_DIAG => #tui_cnt, DIAG := #tp_GetDiagInfo);
	            
	            // Set port fault if all operations do not report any error and port is faulty
	            IF #ti_GetDiagStatus = 0
	                AND #ti_Geo2LogStatus = 0
	                AND #ti_Log2GeoStatus = 0
	                AND #tp_GetDiagInfo.OwnState = 4
	            THEN
	                #ta_PortFault[#ti_Loopcounter] := TRUE;
	            END_IF;
	        END_FOR;
	        // Reset module status if error occurred
	    ELSIF #tx_ConfigurationError
	    THEN
	        FOR #ti_Loopcounter := 1 TO 8 DO
	            #ta_PortFault[#ti_Loopcounter] := FALSE;
	        END_FOR;
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Write output
	    
	    #qa_PortFault := #ta_PortFault;
	    
	END_REGION
	
	
END_FUNCTION

TYPE "UDT_ConveyorInterface"
TITLE = UDT_ConveyorInterface
VERSION : 0.1
//User-defined structure of conveyor interface variables.
   STRUCT
      Displacement : Int;   // Displacement per PLC scan [cm] either from position (if available) or speed and time
      SpeedSetpoint : Int;   // Conveyor speed setpoint [mm/s]
      ActualSpeed : Int;   // Conveyors actual speed [mm/s]
      DeltaPosition : Int;   // Read from Conveyor Servo Position [mm] after 1 PLC cycle
      RunFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Run forward request
      RunRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Run reverse request
      InternalErrorEncoder { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Encoder has an error
      InternalErrorVFD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // VFD has an error
      InternalErrorTracking { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Tracking has an error
      InternalErrorPEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PEC has an error
      InternalWarningVFD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // VFD has a warning
      InternalWarningTracking { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Tracking has a warning
      InternalErrorReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset internal errors
      ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Configuration error is active
      VFDRunning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor is running
      VFDatSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor at speed setpoint
      Disconnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // VFD disconnected
      ManualModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Covneyor is in manual mode
      ResetStatistics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset statistics
      HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Hardware for the Equipment is available and healthy
   END_STRUCT;

END_TYPE

FUNCTION "FC_EquipmentReport" : Void
TITLE = FC_Equipment_Report
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 16
// END_ATTRIBUTES
//Function to generate equipment report.
   VAR_INPUT 
      iUDT_Status : "UDT_CommonStatus";   // Status structure
   END_VAR

   VAR_IN_OUT 
      iqUDT_Control : "UDT_EquipmentControl";   // Equipment control
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | F.Baten       | first release MHS TIA 15.1
	17/06/2019  | 0.3       | L.Klar        | Manual mode added to "UDT_EquipmentControl"
	17/07/2019  | 0.4       | A.Nowak       | Add all statuses and comments
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	27/08/2019  | 2.1       | K.Pokorski    | Comments adjusted
	16/09/2019  | 2.2       | K.Pokorski    | Equipment error free condition added to "Restart required" status
	06/10/2019  | 2.3       | S. Deukar     | Updated accoring to new UDT equipment report
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	05/02/2024  | 3.1       | L.Klar        | Auto On extention added 
	13/03/2024  | 4.0       | S. Nieswiec   | Added to baseline
	*)
	
	REGION 1 - Equipment report update
	    
	    // Extension of stopped equipment report with the stopped status
	    #iqUDT_Control.Report.Stopped := #iUDT_Status.Stopped
	    OR #iqUDT_Control.Report.Stopped;
	    
	    // Extension of started equipment report with the started status
	    #iqUDT_Control.Report.Running := #iUDT_Status.Running
	    OR #iqUDT_Control.Report.Running;
	    
	    // Extension of energy save equipment report with the energy save status
	    #iqUDT_Control.Report.EnergySave := #iUDT_Status.EnergySave
	    OR #iqUDT_Control.Report.EnergySave;
	    
	    // Extension of warning equipment report with the warning status
	    #iqUDT_Control.Report.Warning := #iUDT_Status.Warning
	    OR #iqUDT_Control.Report.Warning;
	    
	    // Extension of manual mode equipment report with the manual mode status
	    #iqUDT_Control.Report.Manual := #iUDT_Status.Manual
	    OR #iqUDT_Control.Report.Manual;
	    
	    // Extension of error equipment report with the error status
	    #iqUDT_Control.Report.Error := #iUDT_Status.Error
	    OR #iqUDT_Control.Report.Error;
	    
	    // Extension of safety stop equipment report with the safety stop status
	    #iqUDT_Control.Report.SafetyStop := #iUDT_Status.SafetyStop
	    OR #iqUDT_Control.Report.SafetyStop;
	    
	    // Extension of Auto On equipment report with the Auto On status
	    #iqUDT_Control.Report.AutoON := #iUDT_Status.AutoON
	    OR #iqUDT_Control.Report.AutoON;
	    
	    // Extension of restart required equipment report with the restart required and no equipment error statuses
	    #iqUDT_Control.Request.RestartRequired := #iUDT_Status.Stopped
	    AND NOT #iUDT_Status.Error
	    OR #iqUDT_Control.Request.RestartRequired;
	    
	END_REGION
END_FUNCTION

TYPE "UDT_RIOStatistics"
TITLE = UDT_RIOStatistics
VERSION : 0.1
//User-defined structure of FB_RIO function block statistics.
   STRUCT
      PNSlaveNotOnline { S7_SetPoint := 'False'} : "UDT_EventStatistic";   // Statistics of  Profinet slave not online
      PNSlaveError { S7_SetPoint := 'False'} : "UDT_EventStatistic";   // Statistics of a Profinet slave error
   END_STRUCT;

END_TYPE

TYPE "UDT_FlowSplitterCommand"
TITLE = Flow Splitter Command
VERSION : 0.1
   STRUCT
      PercentageSplit : Int;   // Percentage value [%] that diverts are on.
      Mode : Int;   // 1- 100% transport; 2- 50% transport; 3- 100% divert; 4- % divert via HMI; 5- Semi automatic
      ManualMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual mode command from HMI
      ManualStartStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start conveyor running when the bit is true, stop conveyor when the bit is false
      ManualFullSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Full speed conveyor in manual mode
      ManualJog { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command to jog conveyor in slow speed from HMI
      Zone1DivertActivation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Active diverts in zone 1
      Zone2DivertActivation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Active diverts in zone 2
   END_STRUCT;

END_TYPE

TYPE "UDT_FlowSplitterStatus"
TITLE = Flow splitter status
VERSION : 0.1
   STRUCT
      Status : Int;   // Status number
      Specific : Struct
         Mode : Int;   // Mode: 1- 100% transport; 2- 50% transport; 3- 100% divert; 4- % divert via HMI; 5- Semi automatic
         Debris { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Debris detected under the belt
         PEC_EoSJam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PEC Jam detected
         PEC_DivertChuteJam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PEC divert chute jam detected
         DivertsActivationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Error when zone 1 is not active but zone 2 is active
         AirPressure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Air pressure error
         EncoderError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Encoder error
         Zone1Divert { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Zone 1 divert is active
         Zone2Divert { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Zone 2 divert is active
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_CaljanReceiveV2"
VERSION : 0.1
   STRUCT
      Healthy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True if (un)loader is healthy
      BeltDirection_Loading { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True if belt is running in loading mode
      BeltDirection_Unloading { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True if belt is running in unloading mode
      ReadyToReceive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True if loader is ready to receive
      ChuteBlockedActivated { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True when the button chute blocked at the keypad is set
      PECLoader { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True when no parcels are detected (fail safe) Signal from Caljan Front photo eye
      PECUnloader { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True when no parcels are detected (fail safe). Signal from Caljan Rear photo eye
      StoreModeActivated { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True when store mode is selected at the kyepad
      RunModeActivated { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True when the run mode is selected at the keypad
      LowerOngoing { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True when the "lower belt" hydraulic valve is active
      RaisingOngoing { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True when the "raise belt" hydraulic valve is active
      "Spare_I1.3" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Spare Bit 3
      "Spare_I1.4" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Spare Bit 4
      "Spare_I1.5" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Spare Bit 5
      "Spare_I1.6" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Spare Bit 6
      "Spare_I1.7" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Spare Bit 7
      ActualSpeed : Int;   // Speed in milimeters per second
      Spare_IW4 : Word;   // Spare Word 4
      Spare_IW6 : Word;   // Spare Word 6
   END_STRUCT;

END_TYPE

TYPE "UDT_DimensionsCheckStatus"
VERSION : 0.1
   STRUCT
      Status : Int;   // Status number
      Specific : Struct   // Specific status
         ParcelTooLong { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parcel is too long
         ParcelTooHigh { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parcel is too high
         ParcelTooWide { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parcel is too wide
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_GateStatus"
VERSION : 0.1
   STRUCT
      Status : Int;   // HMI status structure
      Specific : Struct
         GateClosed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // When TRUE then gate is closed, when FALSE then gate is open
         GateClosedAndNoOperatorPresent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // When TRUE then gate is closed, no operator is inside
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_EmptyWindow"
VERSION : 0.1
   STRUCT
      EmptyWindoSize : Int;   // Minimum size of empty window [mm]
      Last_InductPosition : Int;   // Last inducted position
      No_Of_Empty_Window : Int;   // Number of empty window
      Displacement : Int;   // Displacement [cm/scan]
      EmptyWIndowPosition : Array[0..50] of Int;   // Array of avaiable empty windows
   END_STRUCT;

END_TYPE

TYPE "UDT_CaljanConfigurationV2"
TITLE = UDT_UnloaderConfiguration
VERSION : 0.1
//User-defined structure of unloader parameters.
   STRUCT
      PNDeviceName : String;   // Profinet device Name
      FirstConveyorToStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // First conveyor to start cascade mode
      Energy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Energy save mode enable
      EnergySaveLenght : DInt;   // Distance conveyor travelled before energy save activate [cm]
      ResetDelay : UDInt := 1000;   // Time required
      CascadeTimeOnDelay : UDInt;   // Cascade time on delay [ms]
      BufferPEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when buffer PEC from system is available
   END_STRUCT;

END_TYPE

TYPE "UDT_CaljanStatusV2"
TITLE = UDT_UnloaderStatus
VERSION : 0.1
//User-defined structure of FB_Unloader function block status.
   STRUCT
      Status : Int;   // Status number
      Specific : Struct   // Equipment specific warnings and errors
         PEC_EoS : "UDT_PECStatus";   // PEC status structure
         PNSlaveNotOnline { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet slave is not online
         PNSlaveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet slave is in error
         PNSlaveWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet slave has  a warning
         Disabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Unloader is disabled by HMI
         VFDError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Unloader has an VFD error
         NotHealthy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Unloader is not healthy
         StoreMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Store mode activated
         RunMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Run mode activated
         LowerOngoing { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // "lower belt" hydraulic valve is active
         RaisingOngoing { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // "raise belt" hydraulic valve is active
         ChuteBlocked { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Chute blocked activated
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_CaljanSendV2"
VERSION : 0.1
   STRUCT
      Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Needs to be True for the “Run” mode to be active
      AllowLoading { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True if belt start in loading mode is allowed
      AllowUnloading { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True if belt start in unloading mode is allowed
      Reset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset error and safety command
      BufferPEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Photoeye signal. Used for store mode. True when product is detected.
      "Spare_Q0.5" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Spare Bit 5
      JogReverseCommand { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // While TRUE the extendible conveyor should run in reverse (external hold-to-run reverse signal) Reverse = Loading direction
      "Spare_Q0.7" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Spare Bit 7
      Spare_QB1 : Byte;   // Spare Byte 1
      Spare_QW2 : Word;   // Spare Word 2
      Spare_QW4 : Word;   // Spare Word 4
      Spare_QW6 : Word;   // Spare Word 6
   END_STRUCT;

END_TYPE

TYPE "UDT_CaljanStatisticsV2"
TITLE = UDT_UnloaderStatistics
VERSION : 0.1
//User-defined structure of FB_Unloader function block statistics.
   STRUCT
      EnergySave : "UDT_EventStatistic";   // Number of times that save energy mode occurs
      ExtendableUpTime : "UDT_EventStatistic";   // Conveyor up time
      ExtendableDownTime : "UDT_EventStatistic";   // Conveyor down time
      VFDError : "UDT_EventStatistic";   // VFD Error
      NotHealthy : "UDT_EventStatistic";   // Extendable not healthy
      PEC_EOS : "UDT_PECStatistics";   // PEC error
      PNNodeNotOnline : "UDT_EventStatistic";   // PN node not online
      PNNodeError : "UDT_EventStatistic";   // PN node has error
   END_STRUCT;

END_TYPE

TYPE "UDT_HS10080XCTConfiguration"
VERSION : 0.1
   STRUCT
      InfeedConveyor : "UDT_ConveyorCommonConfiguration";
      MainConveyor : "UDT_ConveyorCommonConfiguration";
      OutfeedConveyor : "UDT_ConveyorCommonConfiguration";
      PEC_InfeedTimeOnDelay : UDInt;   // Photo eye time on delay [ms]
      PEC_InfeedTimeOffDelay : UDInt;   // Photo eye time off delay [ms]
      PEC_InfeedDistance : Int;   // Distance between photo eye and the end of conveyor [mm]
      PEC_InfeedDistanceOffset : Int;   // Distance offset between photo eye and the end of conveyor [mm]
      PEC_OutfeedTimeOnDelay : UDInt;   // Photo eye time on delay [ms]
      PEC_OutfeedTimeOffDelay : UDInt;   // Photo eye time off delay [ms]
      PEC_OutfeedDistance : Int;   // Distance between photo eye and the end of conveyor [mm]
      PEC_OutfeedDistanceOffset : Int;   // Distance offset between photo eye and the end of conveyor [mm]
      OutfeedPECJamDisplacementLimit : Int;   // Limit displacement with PEC blocked to detect jam [cm]
      InfeedPECJamDisplacementLimit : Int;   // Limit displacement with PEC blocked to detect jam [cm]
      Gap : Int;   // Gapping tail to head value [cm]
      CallibrationTimeout : UDInt;   // Max time when callibration is requested before "ix_AllowCallibration" is overruled
      MainConvFeedbackDelayTime : UInt;   // Time limit to check XRAY main conveyor speed OK feedback (ms)
      EnergySaveLenght : Int;   // Distance conveyor travelled before energy save activate [cm]
      CascadeTimeOnDelay : UDInt;   // Cascade time on delay [ms]
      Energy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Energy save mode enable
      FirstConveyorToStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // First conveyor to start cascade mode
      ResetWithPECBlocked { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // When 'True' - Allow reset system after jam with the PEC blocked
   END_STRUCT;

END_TYPE

TYPE "UDT_HS10080XCTHMICommand"
VERSION : 0.1
   STRUCT
      NoScanMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // NO scan mode command from HMI
   END_STRUCT;

END_TYPE

TYPE "UDT_FlowSplitterConfiguration"
TITLE = Flow Splitter Configuration
VERSION : 0.1
   STRUCT
      PEC_EoSTimeOnDelay : UDInt;   // Photo eye time on delay [ms]
      PEC_EoSTimeOffDelay : UDInt;   // Photo eye time off delay [ms]
      PEC_FilterChuteTimeOnDelay : UDInt;   // Divert chute photo eye time on delay [ms]
      PEC_FilterChuteTimeOffDelay : UDInt;   // Divert chute photo eye time off delay [ms]
      PEC_FilterUpstreamTimeOnDelay : UDInt;   // Upstream photo eye time on delay [ms]
      PEC_FilterUpstreamTimeOffDelay : UDInt;   // Upstream photo eye time off delay [ms]
      AirPressure_FilterTimeOffDelay : UDInt;   // Air pressure time off delay [ms]
      DivertsTimeActivation : UDInt;   // Time to enable diverts pop-up [ms]
      CascadeTimeOnDelay : UDInt;   // Cascade time on delay [ms]
      DebrisTimeFilter : UDInt;   // Time to filter debris sensor signal [ms]
      SpeedSetpointNominal : Int;   // Nominal speed setpoint [mm/s]
      SpeedSetpointLow : Int;   // Low speed setpoint [mm/s]
      DivertSwitchDelay : Int;   // Divert switch delay [s]
      JamDisplacementLimit : Int;   // Limit displacement with PEC blocked to detect jam [cm]
      DivertChuteJamDisplacLimit : Int;   // Limit displacement with PEC divert chute blocked to detect jam [cm]
      TimeBasedSplit : Int;   // Time based split [s]
      Length : Int;   // Conveyor length [mm]
      LengthCorrection : Int;   // Length correction [mm]
      DefaultMode : Int;   // Mode: 1- 100% transport; 2- 50% transport; 3- 100% divert; 4- % divert; 5 - Semi automatic
      PEC_Present { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Thue when a photo eye is present in the flow splitter
      PEC_ChutePesent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Thue when a photo eye is present in the chute
      FirstConveyorToStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // First conveyor to start cascade mode
      OnFlyChangeOfMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // On fly change of mode
      DivertsTimeSave { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disable diverts if there is no parcels
      Energy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Energy save mode enable
      EnergySaveLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Distance conveyor travelled before energy save activate [cm]
   END_STRUCT;

END_TYPE

TYPE "UDT_CapacityConfiguration"
VERSION : 0.1
   STRUCT
      AveragePackageLengthConfiguration : Int;   // Average package length [mm]
      Interval : UDInt;   // Interval time [s]
      Treshold : Int;   // Minimum value for the capacity to be saved
   END_STRUCT;

END_TYPE

TYPE "UDT_Chute2PECConfiguration"
VERSION : 0.1
//User-defined structure of FB_Chute2PEC function block configuration.
   STRUCT
      FullDetectionTime : UDInt;   // Time after which chute full is detected
      FullReleaseTime : UDInt;   // Time after which chute full is released
      HalfFullDetectionTime : UDInt;   // Time after which chute half full is detected
      HalfFullReleaseTime : UDInt;   // Time after which chute half full is released
   END_STRUCT;

END_TYPE

TYPE "UDT_Chute1PECStatus"
VERSION : 0.1
//User-defined structure of FB_Chute1PEC function block status.
   STRUCT
      Status : Int;   // Status number
      Specific : Struct   // CH02 specific status structure
         ChuteFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Chute is full status
         ChuteDisabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Chute is disabled status
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_DimensionsCheckStatistics"
VERSION : 0.1
   STRUCT
      TooLongParcels : "UDT_EventStatistic";
      TooHighParcels : "UDT_EventStatistic";
      TooWideParcels : "UDT_EventStatistic";
   END_STRUCT;

END_TYPE

TYPE "UDT_HS10080XCTStatus"
TITLE = UDT_HS10080XCTStatus
VERSION : 0.1
//User-defined structure of FB_Xray_HS10080XCT function block status.
   STRUCT
      Status : Int;   // Status number
      XraySpecific : Struct   // Equipment specific warnings and errors
         XrayPowerNotOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // X-ray not turned on
         MachineNotOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // X-ray not initialised or not working properly
         XRayNotReady { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // X-ray not ready to receive a bag
         TransitActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Transit mode is active
         NoScanActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // X-ray is in the no-scan mode
         IQTestActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // IQ test is active on XRAY
         DoorInterlockNotOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One of the doors of the in- or outfeed tunnel is opend
         RepairSwitch { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // X-ray mains are powered off
         ServiceMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // X-ray is in service mode.
         TempOutOfRange { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // XCT operating temperature is out of range
         GantrySpeedNotOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Gantry speed is not ok
      END_STRUCT;
      InfeedConvSpecific : Struct   // Equipment specific warnings and errors
         Status : Int;   // Satus number
         Conv_ERR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor is in error
         Encoder_ERR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Encoder error
         PEC_EoSJam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PE Jammed end of system pec
      END_STRUCT;
      MainConvSpecific : Struct   // Equipment specific warnings and errors
         Status : Int;   // Satus number
         Conv_ERR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor is in error
         Encoder_ERR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Encoder error
      END_STRUCT;
      OutfeedConvSpecific : Struct   // Equipment specific warnings and errors
         Status : Int;   // Satus number
         Conv_ERR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor is in error
         Encoder_ERR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Encoder error
         PEC_EoSJam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PE Jammed end of system pec
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_DimensionsCheckConfiguration"
VERSION : 0.1
   STRUCT
      DistanceBetweenLenghtPECs : UInt;   // Distance between two Lenght PECs [cm]
      ParcelLengthAllowedDeviation : UInt;   // Maximum torelance in measured parcel length [cm]
      PECLength1OnTime : UDInt;   // Lenght 1 photo eye time on delay [ms]
      PECLength1OffTime : UDInt;   // Lenght 1 photo eye time off delay [ms]
      PECLength2OnTime : UDInt;   // Lenght 2 photo eye time on delay [ms]
      PECLength2OffTime : UDInt;   // Lenght 2 photo eye time off delay [ms]
      PECLength2CheckLimit : UDInt;   // maximum length for length check PEC 2
      PECWidthOnTime : UDInt;   // Width 1 photo eye time on delay [ms]
      PECWidthOffTime : UDInt;   // Width 1 photo eye time off delay [ms]
      PECWidthCheckLimit : UDInt;   // maximum width for width check PEC
      PECHeightTimeOn : UDInt;   // Height photo eye time on delay [ms]
      PECHeightTimeOff : UDInt;   // Height photo eye time off delay [ms]
      AllowedPackageWidth : UInt;   // Maximum package width measured by mode 2
   END_STRUCT;

END_TYPE

TYPE "UDT_DimensionsCheckStatisticsV2"
VERSION : 0.1
   STRUCT
      TooLongParcels : "UDT_EventStatistic";
      TooShortParcels : "UDT_EventStatistic";
      TooHighParcels : "UDT_EventStatistic";
      TooLowParcels : "UDT_EventStatistic";
      TooWideParcels : "UDT_EventStatistic";
      TooNarrowParcels : "UDT_EventStatistic";
      IncorrectShape : "UDT_EventStatistic";
      GeneralError : "UDT_EventStatistic";
   END_STRUCT;

END_TYPE

TYPE "UDT_DimensionsCheckHMIDataV2"
VERSION : 0.1
   STRUCT
      ActualSensor1 : UInt;   // Actual sensor value
      OffsetSensor1 : UInt;   // Sensor offset value
      PositionSensor1 : UInt;   // The value of the sensor after subtracting the offset
      ActualSensor2 : UInt;   // Actual sensor value
      OffsetSensor2 : UInt;   // Sensor offset value
      PositionSensor2 : UInt;   // The value of the sensor after subtracting the offset
      BeltWidth : UInt;   // Belt width
      ProductWidth : UInt;   // Product width
   END_STRUCT;

END_TYPE

TYPE "UDT_DimensionsCheckStatusV2"
VERSION : 0.1
   STRUCT
      Status : Int;   // Status number
      Specific : Struct   // Specific status
         ParcelTooLongError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Error - parcel is too long
         ParcelTooShortError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Error - parcel is too short
         ParcelTooHighError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Error - parcel is too high
         ParcelTooLowError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Error - parcel is too low
         ParcelTooWideError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Error - parcel is too wide
         ParcelTooNarrowError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Error - parcel is too narrow
         IncorrectParcelOrientationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Error - Incorrect parcel orientation
         GeneralError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // General error
         DisabledGeneralFunctionality { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disabled general DMC functionality
         DisabledTooLongParcel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disabled "TooLongParcel" detection
         DisabledTooShortParcelError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disabled "TooShortParcel" detection
         DisabledTooHighParcelError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disabled "TooHighParcel" detection
         DisabledTooLowParcelError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disabled "TooLowParcel" detection
         DisabledTooWideParcelError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disabled "TooWideParcel" detection
         DisabledTooNarrowParcelError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disabled "TooNarrowParcel" detection
         DisabledParcelOrientationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disabled "ParcelOrientation" detection
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_DimensionsCheckCommandV2"
TITLE = Flow Splitter Command
VERSION : 0.1
   STRUCT
      DisableGeneral { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disable genneral functionality DMC
      DisableTooLongParcelError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disable "TooLongParcel" error
      DisableTooShortParcelError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disable "TooShortParcel" error
      DisableTooHighParcelError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disable "TooHighParcel" error
      DisableTooLowParcelError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disable "TooLowParcel" error
      DisableTooWideParcelError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disable "TooWideParcel" error
      DisableTooNarrowParcelError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disable "TooNarrowParcel" error
      DisableParcelOrientationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disable "ParcelOrientation" error
      ButtonOffsetDistanceSensor1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Button to set offset value
      ButtonOffsetDistanceSensor2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Button to set offset value
   END_STRUCT;

END_TYPE

TYPE "UDT_Chute1PECStatistics"
VERSION : 0.1
//User-defined structure of FB_Chute1PEC function block statistics.
   STRUCT
      ChuteFull { S7_SetPoint := 'False'} : "UDT_EventStatistic";   // Chute full statistics
      ChuteDisabled { S7_SetPoint := 'False'} : "UDT_EventStatistic";   // Chute disabled statistics
   END_STRUCT;

END_TYPE

TYPE "UDT_DimensionsCheckConfigurationV2"
VERSION : 0.1
   STRUCT
      PEC_Time_Delay : Struct   // Times for sensors ON/OFF delay
         On_MinHeight : UDInt := 30;   // Minimum Height photo eye time on delay [ms]
         Off_MinHeight : UDInt := 30;   // MinimumHeight photo eye time off delay [ms]
      END_STRUCT;
      Position : Struct   // This values is calculeted from the PEC1 to the next one
         MinHeightPEC_Array : Int;   // Distance between Lenght PEC Laser and Min Height PEC Array [mm]
         Width_Distance_Sensor_1 : Int;   // Distance between Lenght PEC Laser and Distance sensor 1 [mm]
         Width_Distance_Sensor_2 : Int;   // Distance between Lenght PEC Laser and Distance sensor 2 [mm]
         BeltWidth : Int;   // Distance between side guards [mm]
      END_STRUCT;
      Limit : Struct   // Limits for parcel size
         MinWidth : Int := 100;   // Minimum width [mm]
         MaxWidth : Int := 900;   // Maximum width [mm]
         MinLength : Int := 100;   // Minimum length [mm]
         MaxLength : Int := 1200;   // Maximum length [mm]
         TooHighDistance : Int := 200;   // Distance [mm]
         TooLongDistance : Int := 1400;   // Distance [mm]
      END_STRUCT;
      Tolerance : Struct   // Tolerance for parcel size
         TooWide : Int;   // [%] - Percentage of deviations
         TooNarrow : Int;   // [%] - Percentage of deviations
         TooHigh : Int;   // [%] - Percentage of deviations
         TooLow : Int;   // [%] - Percentage of deviations
         Orientation : Int;   // [%] - Percentage of deviations
      END_STRUCT;
      Functionality : Struct   // Set TRUE if functionality should be enabled
         TooLongParcelError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // If true "TooLongParcel"detection active
         TooShortParcelError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // If true "TooShortParcel"detection active
         TooHighParcelError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // If true "TooHighParcel"detection active
         TooLowParcelError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // If true "TooLowParcel"detection active
         TooWideParcelError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // If true "TooWideParcel"detection active
         TooNarrowParcelError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // If true "TooNarrowParcel"detection active
         ParcelOrientationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // If true "ParcelOrientation"detection active
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_ControlPowerGroupWORStatus"
VERSION : 0.1
   STRUCT
      Status : Int;   // Status number
      Specific : Struct
         PowerSuppliesError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Power supplly error
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_FlowSplitterStatistics"
TITLE = Flow splitter statistics
VERSION : 0.1
   STRUCT
      FlowSplitterUpTime : "UDT_EventStatistic";   // Flow splitter up time
      FlowSplitterDownTime : "UDT_EventStatistic";   // Flow splitter down time
      PECChuteDivertJam : "UDT_EventStatistic";   // PEC chute divert jam
      PEC_EoSJam : "UDT_EventStatistic";   // PEC end of section jam
      AirPressure : "UDT_EventStatistic";   // Air pressure fault
      DebrisSensor : "UDT_EventStatistic";   // Debris detected under the belt
      EncoderError : "UDT_EventStatistic";   // Encoder error
      Mode100Straight : "UDT_EventStatistic";   // 100% send to straight downstream conveyor
      "Mode50/50" : "UDT_EventStatistic";   // 50% send to straight downstream conveyor, 50% send to divert downstream conveyor
      Mode100Divert : "UDT_EventStatistic";   // 100% send to divert downstream conveyor
      ModeTimeBasedSplit : "UDT_EventStatistic";   // Time base split mode
      ModeSemiAutomatic : "UDT_EventStatistic";   // Semi automatic mode
      EnergySave : "UDT_EventStatistic";   // Number of times that save energy mode occurs
   END_STRUCT;

END_TYPE

TYPE "UDT_ControlPowerGroupWORStatistics"
VERSION : 0.1
   STRUCT
      PowerSupplyError : "UDT_EventStatistic";   // Error Power Supply Group Statistics
   END_STRUCT;

END_TYPE

TYPE "UDT_ConnectStatus"
VERSION : 0.1
   STRUCT
      Status : Int;   // Status number
      Specific : Struct   // Specific status structure
         Connected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Connected
         CommunicationFault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Communication fault
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_Chute2PECStatus"
VERSION : 0.1
//User-defined structure of FB_CH03 function block status.
   STRUCT
      Status : Int;   // Status number
      Specific : Struct   // CH02 specific status structure
         ChuteFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Chute is full status
         ChuteHalfFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Chute is half full status
         ChuteDisabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Chute is disabled status
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_Chute2PECStatistics"
VERSION : 0.1
//User-defined structure of FB_CH03 function block statistics.
   STRUCT
      ChuteFull { S7_SetPoint := 'False'} : "UDT_EventStatistic";   // Chute full statistics
      ChuteHalfFull : "UDT_EventStatistic";   // Chute half full statistics
      ChuteDisabled { S7_SetPoint := 'False'} : "UDT_EventStatistic";   // Chute disabled statistics
   END_STRUCT;

END_TYPE

TYPE "UDT_Chute1PECConfiguration"
VERSION : 0.1
//User-defined structure of FB_Chute1PEC function block configuration.
   STRUCT
      FullDetectionTime : UDInt;   // Time after which chute full is detected
      FullReleaseTime : UDInt;   // Time after which chute full is released
   END_STRUCT;

END_TYPE

TYPE "UDT_EuchnerLockStatus"
VERSION : 0.1
   STRUCT
      LockFault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Internal lock fault
      DoorClosed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The door is closed
      DoorOpened { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The door is opened
      BoltTongueClosed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The lock bolt tongue is closed
      Safelylocked { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The lock is safely locked
      SafetyLockAckReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The safety lock signal needs to be confirmed
   END_STRUCT;

END_TYPE

TYPE "UDT_HS10080XCTStatistics"
TITLE = UDT_HS10080XCTStatistics
VERSION : 0.1
//User-defined structure of FB_Xray_HS10080XCT function block statistics.
   STRUCT
      XRayMode : "UDT_EventStatistic";   // Running in X-Ray mode
      ServiceMode : "UDT_EventStatistic";   // Running in service mode
      TransitMode : "UDT_EventStatistic";   // Running in transit mode
      EStopActive : "UDT_EventStatistic";   // E-Stop is active
      RepairSwitch : "UDT_EventStatistic";   // Mains power on
      TempOutOfRange : "UDT_EventStatistic";   // XCT doesn’t work because XCT operating temperature isn’t given.
      Stopped : "UDT_EventStatistic";   // Machine is stopped
      Calibrating : "UDT_EventStatistic";   // Calibration is active
      CallibrationForced : "UDT_EventStatistic";   // Callibration is forced on (timed out waiting)
      Interlock : "UDT_EventStatistic";   // One of the doors of the in or outfeed tunnel is opend
      InfeedConveyorError : "UDT_EventStatistic";   // The Infeed conveyor was in error
      OutfeedConveyorError : "UDT_EventStatistic";   // The Outfeed conveyor was in error
      EncoderError : "UDT_EventStatistic";   // One of the encoders has faulted
   END_STRUCT;

END_TYPE

TYPE "UDT_VfdPositioningStatus"
TITLE = UDT_VfdPositioningStatus
VERSION : 0.1
//User-defined structure of VFD SEW positioning status.
   STRUCT
      ErrorCode : Int;   // Error code
      SubErrorCode : Int;   // Sub error code
      PNSlaveNotOnline : Bool := FALSE;   // Profinet slave is not on line
      PNSlaveError : Bool := FALSE;   // Profinet slave has an error
      InternalError : Bool := FALSE;   // A VFD internal error is active, see error code
      InternalWarning : Bool := FALSE;   // A VFD internal warning is active, see error code
      CommunicationErrorMovikit : Bool := FALSE;   // Communication error with MoviKit
      PositioningTimeOutError : Bool := FALSE;   // Exceeded time to reach position
      PNSlaveWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet slave has a warning
   END_STRUCT;

END_TYPE

TYPE "UDT_XBSInductInterfaceSend"
VERSION : 0.1
   STRUCT
      WatchDog : Byte;   // Watch dog counter
      IncomingParcel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parcel found in 2-meter distance from the induct line
      Discharge { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Transfer in Progress
      ParcelOnBoard : DInt;   // Number of parcels in 2-meter distance from the induct line
      ParcelID : DInt;   // ParcelID of the parcel in transfer
      ObjectID : DInt;   // ObjectID Of the parcel in the transfer
      LastConveyorSpeed : Real;   // Actual speed of the last conveyor (mm/sec)
   END_STRUCT;

END_TYPE

TYPE "UDT_Induct"
VERSION : 0.1
   STRUCT
      DistanceLastReserved { S7_SetPoint := 'True'} : Int;   // The distance after which the next window will be reserved
      DisableWindowReservation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Signal to disable window reservation
      AutoRecovery { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Signal for induct to auto recover
      Position : Array[1..20] of "UDT_InductParcelData";   // Position
   END_STRUCT;

END_TYPE

TYPE "UDT_InductConfiguration"
VERSION : 0.1
   STRUCT
      Induct_Number { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 1;   // Induct number where the most upstream induct is 1
      Induct_Position { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 100;   // Virtual position of the induct [mm] on the merge tracking DB
      GapMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 2;   // 1=HeadToHead, 2=Length+fixedgap size 3=Length+flex gapsize
      GapHeadToHead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 150;   // Gapping head to head value [cm]
      GapTailToHead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 10;   // Gapping tail to head value [cm]
      MaxParcelSize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 30;   // Maximum size parcel [mm] to set when no size is found
      MinParcelSize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 5;   // Minimum size parcel [mm] to set when no size is found
      ReactivationRequestDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := 10000;   // Delay distance before request to MergeGenerator to activate [mm]
      RunEmptyDistance : DInt := 10000;   // Distance the merge conveyor has to run before the induct starts after an EMstop [mm]
      SearchOnly { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = The induct is not requesting a gap, only searching
      DistanceRunBeforeAutoRecovery : Int := 1;   // Distance the merge conevyor should run before Induct does an auto recovery request
      ParcelStopPositionAutoRecovery : Int;   // Position where parcel stops when Induct needs to auto recover
      RecoveryAdditionalGap : Int;   // Additional Gap during recovery  or first startup of Induct
      InductPositionWindow : Int := 10;   // Induct position window (tollerance) [cm]
      FlexGap { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..5] of "UDT_InductGapsize";
   END_STRUCT;

END_TYPE

DATA_BLOCK "DB_Time"
TITLE = DB_Time
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
NON_RETAIN
//Data block to store date and time data.
   VAR 
      ActualTimeDTL {InstructionName := 'DTL'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DTL;   // Actual date and time in DTL
      ActualTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Actual date and time in String
      Timestamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[17];   // Actual date and time in String
      DaylightSaving { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
   END_VAR


BEGIN

END_DATA_BLOCK

TYPE "UDT_InchingStatus"
VERSION : 0.1
   STRUCT
      Full { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor is full
      Active { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Inching is active
   END_STRUCT;

END_TYPE

TYPE "UDT_Destinations"
VERSION : 0.1
   STRUCT
      Destination : Array[0..5] of DInt;   // Destination code to compare to to go to position
   END_STRUCT;

END_TYPE

TYPE "UDT_GapOptimizationSystemConfiguration"
VERSION : 0.1
   STRUCT
      LengthConvA : Int;   // The length of conveyor A (mm)
      LengthConvB : Int;   // The length of conveyor B (mm)
      LengthConvC : Int;   // The length of conveyor C (mm)
      PosPECA1 : Int;   // The position of PEC from the beginning of conveyor A (mm)
      PosPECA2 : Int;   // The position of PEC from the end of the conveyor A (mm)
      PosPECB1 : Int;   // The position of PEC from the beginning of conveyor B (mm)
      PosPECB2 : Int;   // The position of PEC from the end of the conveyor B (mm)
      PosPECC1 : Int;   // The position of PEC from the beginning of conveyor C (mm)
      PosPECC2 : Int;   // The position of PEC from the end of the conveyor C (mm)
      InitialSpeed : Int;   // Initial speed of each conveyor (mm/s)
      Acceleration : Int;   // Acceleration (mm/s2)
      MaximumSpeed : Int;   // Maximum speed (mm/s)
      MinimumSpeed : Int;   // Minimum speed (mm/s)
      MarginLength : Int;   // Extra length margin for acceleration (mm)
      RequiredGap : Int;   // The required gap (mm)
      AllowedUpstreamGap : Int;   // Minimum upstream gap allowed to decelerate (mm)
      AllowedParcelLength : Int;   // The maximum length of a parcel allowed to accelerate or decelerate on one conveyor (mm)
      LengthSpaceBetweenConv : Int;   // The distance of free space between 2 conveyors (mm)
      PosPECBos : Int;   // The position of the PEC from the beginning of the conveyor (mm)
   END_STRUCT;

END_TYPE

TYPE "UDT_GapOptimizationSystemStatus"
VERSION : 0.1
   STRUCT
      Status : Int;   // Status number
   END_STRUCT;

END_TYPE

TYPE "UDT_GapOptimizationSystemInterface"
VERSION : 0.1
   STRUCT
      SpeedConvA : Int;   // Setpoint speed of conveyor A (mm/s)
      SpeedConvB : Int;   // Setpoint speed of conveyor B (mm/s)
      SpeedConvC : Int;   // Setpoint speed of conveyor C (mm/s)
   END_STRUCT;

END_TYPE

FUNCTION "FC_GOSCalculation" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 21
// END_ATTRIBUTES
   VAR_INPUT 
      ir_TravelDistanceCurrentParc : Real;   // Travel distance of the current parcel till the end of the conveyor (mm)
      ir_TravelDistanceUpstreamParc : Real;   // Travel distance of the upstream parcel till the end of the conveyor (mm)
      ir_InitialSpeed : Real;   // Initial speed of the VFD (mm/s)
      ir_Acceleration : Real;   // Maximum acceleration of the VFD (mm/s2)
      ir_MaxSpeed : Real;   // Maximum speed of the VFD (mm/s)
      ir_MinSpeed : Real;   // Minimum speed of hte VFD (mm/s)
      ii_ParcelGapDownstream : Int;   // Downstream gap of the current parcel to his next parcel (mm)
      ii_ParcelGapUpstream : Int;   // Upstream gap of the current parcel to his previous parcel (mm)
      ii_RequiredGap : Int;   // Required gap between the parcels (mm)
      ii_MarginGap : Int;   // Extra margin gap (mm)
      ii_AllowedUpstreamGap : Int;   // Maximum allowed gap upstream (mm)
      ix_ActionConv : Bool;   // ActionConv = True means that conveyor is running
   END_VAR

   VAR_OUTPUT 
      qi_Speed : Int;   // Calculated speed (mm/s)
      qi_ParcelGapRecovered : Int;   // Gap recovered by acceleration or deceleration (mm)
      qx_Accelerate : Bool;   // Accelerate = True means that the action of acceleration is active
      qx_Decelerate : Bool;   // Decelerate = True means that the action of deceleration is active
      qi_TimeToChangeSpeed : LReal;   // Time for which the speed shoud be changed  [ms]
   END_VAR

   VAR_TEMP 
      tr_NewTravelTime : Real;   // Calculated travel time (s)
      tr_Speed : Real;   // Calculated speed (mm/s)
      tr_RecoverdGapAccDec : Real;   // Gap that is recovered by acceleration and deceleration (mm)
      tr_RecoverdGapDecAcc : Real;   // Gap that is recovered by deceleration and acceleration (mm)
      tr_ParcelGapToBeRecovered : Real;   // Gap that has to be recovered (mm)
      tr_NewTravelDistance : Real;   // Calculated travel distance (mm)
      tr_AccDecTravelDistance : Real;   // Distance travelled by parcel when accelerated and decelerated (mm)
   END_VAR


BEGIN
	(*
	
	----------------------------------------------------------------------------------------
	28/01/2020  | 1.0       | R. Joosse     | first release TIA 15.1
	28/01/2020  | 2.0       | M. Singh      | Used Absolute value of input distances so as to have correct calculations in case of a UFO
	04/04/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 Calculation speed for acceleration and deceleration
	    //Acceleration
	    
	    IF ((#ii_ParcelGapDownstream > #ii_RequiredGap + #ii_MarginGap) AND (#ii_ParcelGapUpstream < #ii_RequiredGap) AND (#ii_ParcelGapUpstream <> 0))
	        OR (#ii_ParcelGapDownstream > #ii_RequiredGap + 100) //100mm is to be added to Config as "Additional Gap Downstream For Unconditional Acccelaeration"
	    THEN
	        #tr_ParcelGapToBeRecovered := #ii_ParcelGapDownstream - #ii_RequiredGap;
	        #qx_Accelerate := True;
	        #qx_Decelerate := FALSE;
	        
	        IF #ix_ActionConv
	        THEN
	            IF ABS_REAL(IN := #ir_TravelDistanceUpstreamParc) <= ABS_REAL(IN := #ir_TravelDistanceCurrentParc)
	                
	            THEN
	                #tr_NewTravelDistance := ABS_REAL(IN := #ir_TravelDistanceUpstreamParc); //   #tr_NewTravelDistance := #ir_TravelDistance_UpstreamParc;
	            ELSE
	                #tr_NewTravelDistance := ABS_REAL(IN := #ir_TravelDistanceCurrentParc); //    #tr_NewTravelDistance := #ir_TravelDistance_CurrentParc;
	            END_IF;
	            
	            //Calculate speed  (v2 = u2 +2as)
	            #tr_Speed := SQRT((#ir_InitialSpeed * #ir_InitialSpeed) + (2.0 * #ir_Acceleration * ((#tr_NewTravelDistance / 2.0))));
	            
	            // #tr_Speed := SQRT((#ir_InitialSpeed * #ir_InitialSpeed) + (2.0 * #ir_Acceleration * ((#tr_NewTravelDistance / 2.0) - 50))); 
	            //Calculate travel time (v = u + at)
	            #tr_NewTravelTime := ((#tr_Speed - #ir_InitialSpeed) / #ir_Acceleration) * 2.0;
	            
	            //Recovered gap by acceleration and deceleration in millimeters
	            #tr_RecoverdGapAccDec := #tr_NewTravelDistance - (#ir_InitialSpeed * #tr_NewTravelTime);
	            
	            IF #tr_RecoverdGapAccDec <= #tr_ParcelGapToBeRecovered
	            THEN
	                #qi_ParcelGapRecovered := REAL_TO_INT(#tr_RecoverdGapAccDec);
	            ELSE
	                #tr_NewTravelDistance := #tr_NewTravelDistance - (#tr_RecoverdGapAccDec - #tr_ParcelGapToBeRecovered);
	                
	                #tr_Speed := SQRT((#ir_InitialSpeed * #ir_InitialSpeed) + (2.0 * #ir_Acceleration * ((#tr_NewTravelDistance / 2.0))));
	                
	                //   #tr_Speed := SQRT((#ir_InitialSpeed * #ir_InitialSpeed) + (2.0 * #ir_Acceleration * ((#tr_NewTravelDistance / 2.0) - 50)));
	                
	                //Calculate travel time (v = u + at)
	                #tr_NewTravelTime := ((#tr_Speed - #ir_InitialSpeed) / #ir_Acceleration) * 2.0;
	                
	                #qi_ParcelGapRecovered := REAL_TO_INT(#tr_NewTravelDistance - (#ir_InitialSpeed * #tr_NewTravelTime));
	            END_IF;
	        END_IF;
	        
	        //Deceleration        
	    ELSIF (#ii_ParcelGapDownstream < #ii_RequiredGap) AND #ii_ParcelGapDownstream > 0 AND
	        ((#ii_ParcelGapUpstream > #ii_AllowedUpstreamGap) OR (#ii_ParcelGapUpstream = 0))
	        
	    THEN
	        #tr_ParcelGapToBeRecovered := #ii_RequiredGap - #ii_ParcelGapDownstream;
	        #qx_Accelerate := FALSE;
	        #qx_Decelerate := True;
	        
	        IF #ix_ActionConv
	        THEN
	            IF ABS_REAL(IN := #ir_TravelDistanceUpstreamParc) <= ABS_REAL(IN := #ir_TravelDistanceCurrentParc) AND
	                (ABS_REAL(IN := #ir_TravelDistanceUpstreamParc) > 150.0)
	            THEN
	                #tr_NewTravelDistance := ABS_REAL(IN := #ir_TravelDistanceUpstreamParc);
	            ELSE
	                #tr_NewTravelDistance := ABS_REAL(IN := #ir_TravelDistanceCurrentParc);
	            END_IF;
	            
	            //Calculate speed used v2 = (u2 -2as)
	            #tr_Speed := SQRT((#ir_InitialSpeed * #ir_InitialSpeed) - ((2.0 * #ir_Acceleration * (#tr_NewTravelDistance / 2.0))));
	            
	            //Calculate travel time v= u + at
	            #tr_NewTravelTime := ((#ir_InitialSpeed - #tr_Speed) / #ir_Acceleration) * 2.0;
	            
	            //Recovered gap by acceleration and deceleration in millimeters
	            #tr_RecoverdGapDecAcc := (#ir_InitialSpeed * #tr_NewTravelTime) - #tr_NewTravelDistance;
	            
	            IF #tr_RecoverdGapDecAcc <= #tr_ParcelGapToBeRecovered
	            THEN
	                #qi_ParcelGapRecovered := REAL_TO_INT(#tr_RecoverdGapDecAcc);
	            ELSE
	                #tr_NewTravelDistance := #tr_NewTravelDistance - (#tr_RecoverdGapDecAcc - #tr_ParcelGapToBeRecovered);
	                
	                //Calculate speed used v2 = (u2 -2as)
	                #tr_Speed := SQRT((#ir_InitialSpeed * #ir_InitialSpeed) - ((2.0 * #ir_Acceleration * (#tr_NewTravelDistance / 2.0))));
	                
	                //Calculate travel time v= u + at
	                #tr_NewTravelTime := ((#ir_InitialSpeed - #tr_Speed) / #ir_Acceleration) * 2.0;
	                
	                //Recovered gap by acceleration and deceleration in millimeters
	                #tr_RecoverdGapDecAcc := (#ir_InitialSpeed * #tr_NewTravelTime) - #tr_NewTravelDistance;
	                
	                #qi_ParcelGapRecovered := REAL_TO_INT(#tr_RecoverdGapDecAcc);
	                
	            END_IF;
	        END_IF;
	        
	    ELSE
	        //Initial speed
	        #tr_Speed := #ir_InitialSpeed;
	        #qx_Accelerate := FALSE;
	        #qx_Decelerate := FALSE;
	    END_IF;
	END_REGION
	
	REGION 2 Write calculated speed on the output 
	    #qi_TimeToChangeSpeed := REAL_TO_LREAL(IN := #tr_NewTravelTime * 1000 / 2);
	    
	    IF #tr_Speed > #ir_InitialSpeed
	    THEN
	        #qi_Speed := REAL_TO_INT(#ir_MaxSpeed);
	    ELSIF #tr_Speed < #ir_InitialSpeed
	    THEN
	        #qi_Speed := REAL_TO_INT(#ir_MinSpeed);
	    END_IF;
	END_REGION
	
	
END_FUNCTION

TYPE "UDT_Merge"
VERSION : 0.1
   STRUCT
      LastUsed : Int;   // Last used FIFO entry
      MaxNumberofEntries : Int;   // Maximum number of FIFO entries
      Remove { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // An entry was removed by an induct
      GenerationInactive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Generation is inactive (not generating and handling requests)
      ReactivateReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request to activate generation from an induct
      FIFO : Array[0..10] of "UDT_FIFOInductInfo";   // FIFO structure for induct requests
      TrackingPointerForInduct { S7_SetPoint := 'True'} : Array[1..10] of Int;   // Tracking the request for the induct
      RequestInFIFO { S7_SetPoint := 'True'} : Array[1..10] of Bool;   // Request is in FIFO handshake
   END_STRUCT;

END_TYPE

DATA_BLOCK "DB_GOSLog"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
   VAR 
      DB_GOSLog { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Array[0..100] of "UDT_GOSLog";
   END_VAR


BEGIN

END_DATA_BLOCK

TYPE "UDT_ConveyorPanelStatus"
TITLE = Cabinet MCP Status
VERSION : 0.1
   STRUCT
      CBFeedbackError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit feedback error
      MainSwitchOff { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Main switch tripped
   END_STRUCT;

END_TYPE

TYPE "UDT_ConveyorPanelStatistics"
TITLE = Cabinet MCP Statistics
VERSION : 0.1
   STRUCT
      CBFeedbackError : "UDT_EventStatistic";   // Circuit breaker feedback error
      MainSwitchOff : "UDT_EventStatistic";   // Main switch fault statistics
   END_STRUCT;

END_TYPE

TYPE "UDT_ControlPowerGroupStatus"
VERSION : 0.1
   STRUCT
      Status : Int;   // Status number
      Specific : Struct
         Fail_PowerSupply_1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Power supply 1 fail
         Fail_PowerSupply_2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Power supply 2 fail
         Fail_PowerSupply_3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Power supply 3 fail
         Fail_PowerSupply_4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Power supply 4 fail
         Fail_PowerSupply_5 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Power supply 5 fail
         Fail_PowerSupply_6 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Power supply 6 fail
         Fail_PowerSupply_7 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Power supply 7 fail
         Fail_PowerSupply_8 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Power supply 8 fail
         Fail_PowerSupply_9 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Power supply 9 fail
         Fail_PowerSupply_10 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Power supply 10 fail
         PowerSuppliesWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Power supplies warning
         PowerSuppliesError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Power supplies error
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_ControlPowerGroupStatistics"
VERSION : 0.1
   STRUCT
      PowerSupplyGroupWarnning : "UDT_EventStatistic";   // Warning Power Supply Group Statistics
      PowerSupplyGroupError : "UDT_EventStatistic";   // Error Power Supply Group Statistics
   END_STRUCT;

END_TYPE

TYPE "UDT_AirPressureSwitchStatus"
VERSION : 0.1
   STRUCT
      Status : Int;   // Status number
      Specific : Struct   // Equipment specific warnings and errors
         AirPressureOK : Bool;   // Air pressure switch is okay
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_TPManualControlButtons"
TITLE = UDT_TPManualControlButtons
VERSION : 0.1
//User defined structure to communicate buttons to and from the Touch buttons
   STRUCT
      ManualMode : Bool;
      ManualStart : Bool;
      ManualStop : Bool;
      ManualFullSpeed : Bool;
      ManualLowSpeed : Bool;
      ManualJog : Bool;
      ManualReverse : Bool;
   END_STRUCT;

END_TYPE

TYPE "UDT_AixPlcFull4McoStatus"
VERSION : 0.1
   STRUCT
      StatusMotor1 { S7_SetPoint := 'False'} : "UDT_AixControllerStatus";
      StatusMotor2 : "UDT_AixControllerStatus";
      StatusMotor3 : "UDT_AixControllerStatus";
      StatusMotor4 : "UDT_AixControllerStatus";
      StatusMotor5 : "UDT_AixControllerStatus";
      StatusMotor6 : "UDT_AixControllerStatus";
      StatusMotor7 : "UDT_AixControllerStatus";
      StatusMotor8 : "UDT_AixControllerStatus";
   END_STRUCT;

END_TYPE

FUNCTION "FC_StringToTime" : Void
TITLE = FC_StringToTime
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 27
// END_ATTRIBUTES
//Function to convert date in string format to the DTL.
   VAR_INPUT 
      is_StringTime : String;   // Input string with date
   END_VAR

   VAR_OUTPUT 
      qt_Date {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;   // Output Date in DTL
   END_VAR

   VAR_TEMP 
      ts_DateInt : Struct   // Temp partial date in integer
         Year : UInt;
         Month : USInt;
         Day : USInt;
         Hour : USInt;
         Minute : USInt;
         Second : USInt;
         Millisecond : UDInt;
      END_STRUCT;
      ts_DateString : Struct   // Temp partial date in string
         Hour : String[2];
         Minute : String[2];
         Second : String[2];
         Millisecond : String[3];
      END_STRUCT;
   END_VAR

   VAR CONSTANT 
      ci_StringLength2 : Int := 2;   // Length of the part of the string
      ci_StringLength3 : Int := 3;   // Length of the part of the string
      ci_StringPosition1 : Int := 1;   // Position of the first caracter inside the string
      ci_StringPosition4 : Int := 4;   // Position of the first caracter inside the string
      ci_StringPosition7 : Int := 7;   // Position of the first caracter inside the string
      ci_StringPosition10 : Int := 10;   // Position of the first caracter inside the string
      cw_FormatZero : Word := 0;   // Simple value format
      Ci_Year : UInt := 1970;   // Fixed year 1970, start value dtl
      ci_Month : USInt := 1;   // Fixed month 1, start value dtl
      ci_Day : USInt := 1;   // Fixed day 1, start value dtl
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | K.Pokorski    | first release MHS TIA 15.1
	26/06/2019  | 0.2       | M.Kurpiers    | Change in region 1 P:=3 -> P:=4
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	26/07/2019  | 2.1       | M.Kurpiers    | Comments adjusted
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	16/02/2023  | 3.1       | F.Baten       | Added constants
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Separation different part of the date 
	    
	    // Separation different part of the date from the data string and saving it to the structure
	    #ts_DateString.Hour := MID(IN := #is_StringTime,
	                               L := #ci_StringLength2,
	                               P := #ci_StringPosition1);               // Separating an hour from the date string  
	    #ts_DateString.Minute := MID(IN := #is_StringTime,
	                                 L := #ci_StringLength2,
	                                 P := #ci_StringPosition4);             // Separating a minute from the date string 
	    #ts_DateString.Second := MID(IN := #is_StringTime,
	                                 L := #ci_StringLength2,
	                                 P := #ci_StringPosition7);             // Separating a second from the date string 
	    #ts_DateString.Millisecond := MID(IN := #is_StringTime,
	                                      L := #ci_StringLength3,
	                                      P := #ci_StringPosition10);       // Separating a millisecond from the date string 
	    
	END_REGION
	
	REGION 2 - Conversion string to integer
	    
	    STRG_VAL(IN := #ts_DateString.Hour,                         // Conversion a hour from string 
	             FORMAT := #cw_FormatZero,                          // Simple value format
	             P := INT_TO_UINT(#ci_StringPosition1),             // First position in string
	             OUT => #ts_DateInt.Hour);                          // Integer temporary variable
	    // Conversion a minute from string 
	    STRG_VAL(IN := #ts_DateString.Minute,
	             FORMAT := #cw_FormatZero,
	             P := INT_TO_UINT(#ci_StringPosition1),
	             OUT => #ts_DateInt.Minute);
	    // Conversion a second from string 
	    STRG_VAL(IN := #ts_DateString.Second,
	             FORMAT := #cw_FormatZero,
	             P := INT_TO_UINT(#ci_StringPosition1),
	             OUT => #ts_DateInt.Second);
	    // Conversion a milisecond from string
	    STRG_VAL(IN := #ts_DateString.Millisecond,
	             FORMAT := #cw_FormatZero,
	             P := INT_TO_UINT(#ci_StringPosition1),
	             OUT => #ts_DateInt.Millisecond);
	    
	END_REGION
	
	REGION 3 - Combine integer to "DTL" data type and setting output
	    
	    // Move parts of the date to the DTL output structure 
	    #qt_Date.YEAR := #Ci_Year;
	    #qt_Date.MONTH := #ci_Month;
	    #qt_Date.DAY := #ci_Day;
	    #qt_Date.HOUR := #ts_DateInt.Hour;
	    #qt_Date.MINUTE := #ts_DateInt.Minute;
	    #qt_Date.SECOND := #ts_DateInt.Second;
	    #qt_Date.NANOSECOND := #ts_DateInt.Millisecond * 1000000;
	    
	END_REGION
END_FUNCTION

TYPE "UDT_PNCoupler_Interface"
TITLE = Interface signals between PN Coupler
VERSION : 0.1
   STRUCT
      DownstreamDisplacement : Int;   // Displacement from downstream [cm]
      RTS : Bool;   // Conveyor ready to send
      RTR : Bool;   // Conveyor ready to receive
      TIP : Bool;   // Transfer in progress
      ResetEnergySave : Bool;   // Reset energy save mode
      CascadeStartUp : Bool;   // Cascade startup
   END_STRUCT;

END_TYPE

TYPE "UDT_EncoderStatus"
VERSION : 0.1
   STRUCT
      Fault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_STRUCT;

END_TYPE

TYPE "UDT_MergeGeneratorConfig"
TITLE = UDT_MergeGeneratorConfig
VERSION : 0.1
//V 3.1
   STRUCT
      GenerationPoint : Int;   // Position on tracking where is written [mm]
      NumberInducts : Int;   // Number of induct belts conected to the merge belt.
      GapHeadToHead : Int;   // Length of the fixed gap (cm)
      ChangeWindowModeDistance : DInt := 60000;   // Distance to Deactivate window generation (mm)
      ModeSelection : Int;   // 0= standard, 1 = no empty window
      DelayDistance : Int;   // Delay in looking for next window for the same induct
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_PECD"
TITLE = FB_PEC
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : Conveyor
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 22
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_PECConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECDConfiguration";   // PEC configuration structure
      ix_PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Signal of the PEC
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";   // Status structure
      qx_PECFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PEC Filtered
   END_VAR

   VAR_IN_OUT 
      iqUDT_ConveyorInterface : "UDT_ConveyorInterface";   // Interface structure
      iqUDT_PECStatistics : "UDT_PECStatistics";   // Statistics structure
   END_VAR

   VAR 
      s_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatus";   // Status structure
      s_StatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatus";   // Auxiliary status structure
      PEC_OnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_OnOffDelayDistance";   // Filtering end of section photo eye signal
      R_TRIG_PECJam {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger PEC jam
      sx_Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Enable
   END_VAR
   VAR RETAIN
      si_AuxJamDisplacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Auxiliary variable to calculate displacement when PEC is blocked
   END_VAR
   VAR 
      sx_PECFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Photo eye filtered
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	 16/04/2023 | 1.0       | F.Baten       | Adapt from PEC timer based 
	 03/05/2023 | 4.0       | F.Baten       | 4.0 Release TIA 17.5 
	*)
	
	REGION 1 - Triggers
	    
	    // Rising edge PEC Jam
	    #R_TRIG_PECJam(CLK := #s_Status.Jam);
	    
	END_REGION
	
	REGION 2 - Active function  
	    
	    // To activate the jam monitoring the jam displacement limit  must be configured up to zero. 
	    #sx_Enable := #iUDT_PECConfiguration.JamDisplacementLimit > 0;
	    
	END_REGION
	
	REGION 3 - Reset errors
	    
	    // Jam error is reset when reset bit is active and jam error is active and is connfigured alllow reset jam with PEC blocked or photo eye is not active
	    IF #iqUDT_ConveyorInterface.InternalErrorReset
	        AND (#iUDT_PECConfiguration.ResetWithPECBlocked
	        OR (NOT #iUDT_PECConfiguration.ResetWithPECBlocked
	        AND #sx_PECFiltered))
	        AND #s_Status.Jam
	    THEN
	        
	        #si_AuxJamDisplacement := 0;
	        #s_Status.Jam := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Photo eye filters
	    
	    // End of section photo eye signal filter measurement
	    #PEC_OnOffDelay(ii_Displacement := #iqUDT_ConveyorInterface.Displacement,
	                    idi_OnDelayDistance := #iUDT_PECConfiguration.OnDelayDistance,
	                    idi_OffDelayDistance := #iUDT_PECConfiguration.OffDelayDistance,
	                    ix_SignalToDelay := #ix_PEC,
	                    ix_Enable := TRUE,
	                    qx_DelayedSignal => #sx_PECFiltered);
	    
	    // Write the current status of the photo eye
	    #s_Status.PEC := #sx_PECFiltered;
	    #qx_PECFiltered := #sx_PECFiltered;
	    
	END_REGION
	
	REGION 5 - Jam detection   
	    
	    IF NOT #sx_PECFiltered                                             // Photo eye blocked
	        AND #sx_Enable                                                  // Active of checking the PEC jam 
	    THEN
	        
	        #si_AuxJamDisplacement += ABS(#iqUDT_ConveyorInterface.Displacement);
	        
	    ELSE
	        
	        #si_AuxJamDisplacement := 0;
	        
	    END_IF;
	    
	    // Compare jam auxiliary counter with displacement jam configured
	    IF #si_AuxJamDisplacement > #iUDT_PECConfiguration.JamDisplacementLimit
	    THEN
	        
	        #s_Status.Jam := TRUE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Statistics
	    
	    // Statistics Jam PEC
	    IF #s_Status.Jam                                                    // PEC jam error active
	        OR #iqUDT_ConveyorInterface.ResetStatistics                    // Reset statistics
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #s_Status.Jam,
	                        ix_RTrigActivate := #R_TRIG_PECJam.Q,
	                        iqUDT_Statistics := #iqUDT_PECStatistics.Jam);
	        
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Internal PEC error
	    
	    IF #s_Status.Jam
	    THEN
	        
	        #iqUDT_ConveyorInterface.InternalErrorPEC := TRUE;
	        
	    END_IF;
	    
	END_REGION
	
	
	REGION 8 - Status
	    
	    // Status update on change
	    IF #s_StatusOld <> #s_Status
	    THEN
	        
	        #qUDT_HMIStatus := #s_Status;
	        #s_StatusOld := #s_Status;
	        
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

TYPE "UDT_PECDUpdateConfiguration"
TITLE = UDT_PECConfiguration
VERSION : 0.1
//User-defined structure of PEC parameters.
   STRUCT
      OnDelayDistance : DInt;   // Photo eye distance on delay [cm]
      OffDelayDistance : DInt;   // Photo eye distance off delay [cm]
      Distance : DInt;   // Distance between photo eye and the end of conveyor [mm]
      JamDisplacementLimit : Int;   // Limit displacement with PEC blocked o detect jam [cm]
      SearchWindowFwd : Int;   // Search window in forward direction [cm]
      SearchWindowRvs : Int;   // Search window in reverse direction [cm]
      GINRangeStart : Int;   // GIN range start value
      GINRangeEnd : Int;   // GIN range end value
      NrOfTeachParcels : Int;   // Number of parcels to teach
      DefaultGIN : Int := 1;   // Default GIN record
      MaxLost : Int;   // Maximum number of lost parcels in a row
      ParcelLengthFilter : Bool := TRUE;   // Parcel length filter
      ResetWithPECBlocked { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // When 'True' Allow reset system after jam with PEC blocked
      GenerationPoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Generation point
      NegativeGINDelete { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True when negative GIN has to be deleted
      ParcelLengthMeasurement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parcel length measurement
      GapLengthMeasurement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Gap length measurement
   END_STRUCT;

END_TYPE

TYPE "UDT_WE01Status"
VERSION : 0.1
   STRUCT
      Status : Int;   // Status number
      Specific : Struct
         WeighingScaleFault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Weighing Scale unit in Fault state
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_VSUConfiguration"
TITLE = UDT_VSUConfig
VERSION : 0.1
//User-defined structure of VSU parameters.
   STRUCT
      PEC_EoSTimeOnDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Photo eye EOS time on delay [ms]
      PEC_EoSTimeOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Photo eye EOS time off delay [ms]
      PEC_OutTimeOnDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Photo eye outfeed time on delay [ms]
      PEC_OutTimeOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Photo eye outfeed time off delay [ms]
      PEC_JamTimeOnDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Photo eye jam time on delay [ms]
      PEC_JamTimeOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Photo eye jam time off delay [ms]
      JogNoHornTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt := 1000;   // Time within jog buttons can be pressed without new startup indication
      SwitchingTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt := 950;   // Time it takes to go from one position to the next [ms]
      DefaultPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 2;   // Default position number (1= up or 2= down) , If left 0 the block will go to 1
      HeadToHead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 120;   // Head to head distance to downstream conveyor (upper and lower) [cm]
      Gap { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 60;   // Gap to downstream conveyor (upper and lower) [cm]
      JamDisplacementLimit { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 100;   // Limit displacement with PEC blocked to detect jam [cm]
      SecurityChecked { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // If true, then in semiautomatic stop the parcel for reject (if the VSU is not directed to reject)
   END_STRUCT;

END_TYPE

TYPE "UDT_VSUStatus"
TITLE = UDT_VSUStatus
VERSION : 0.1
//User-defined structure of FB_VerticalSwitch function block status.
   STRUCT
      Status : Int;   // Status number
      Specific : Struct   // Equipment specific warnings and errors
         ReferencedError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // VFD is not referenced
         UpperSwitchArea_Err { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Upper switching area PEC was activated when moving
         LowerSwitchArea_Err { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Lower switching area PEC was activated when moving
         UpperEntranceJam_Err { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Upper outfeed conveyor entrance PEC was blocked too long
         LowerEntranceJam_Err { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Lower outfeed conveyor entrance PEC was blocked too long
         Direction_Err { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parcel should be rejected (in semi-automatic and security mode).
         Keyswitch_WRN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Keyswitch is in '0' position
         UpperPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Upper position reached
         LowerPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Lower position reached
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_VSUCommand"
TITLE = UDT_VSUCommand
VERSION : 0.1
//User-defined structure of VSU commands.
   STRUCT
      SemiAutomaticMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Semiautomatic mode command from HMI
      ManualMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual mode command from HMI
      CommandUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command from HMI to go to upper position in semiautomatic or manual mode
      CommandDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command from HMI to go to lower position in semiautomatic or manual mode
      JogUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command from HMI to Jog upwards
      JogDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command from HMI to Jog downwards
      ReferenceRun { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command from HMI to reference drive
   END_STRUCT;

END_TYPE

TYPE "UDT_VSUStatistics"
TITLE = UDT_VSUStatistics
VERSION : 0.1
//User-defined structure of FB_VerticalSwitch function block statistics.
   STRUCT
      UpTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EventStatistic";   // VSU up time
      DownTime : "UDT_EventStatistic";   // VSU down time
      UpperSwitchArea_Error : "UDT_EventStatistic";   // Error statistics for VSU
      LowerSwitchArea_Error : "UDT_EventStatistic";   // Error statistics for VSU
      UpperEntranceJam_Error : "UDT_EventStatistic";   // Error statistics for VSU
      LowerEntranceJam_Error : "UDT_EventStatistic";   // Error statistics for VSU
      Direction_Error : "UDT_EventStatistic";   // Error statistics for VSU
   END_STRUCT;

END_TYPE

TYPE "UDT_VfdSiemensPI"
TITLE = UDT_VFD_Siemens_PI
VERSION : 0.1
//User-defined structure of VFD Siemens input telegram.
   STRUCT
      ZSW_1 : Struct   // Status Word Interconnection 1
         SpareBit8 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Spare bit 8
         MasterControlRequested { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Master_control_requested (The automation system is requested to accept the inverter control) p 2080[9] = r0899.9
         SafetyTestRequired { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Only applicable in G120 with safety motion monitoring
         SpareBit11 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Spare bit 11
         HoldingBrakeOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Holding brake open (Signal open and close a motor holding brake) p 2080[12] = r 0899.12
         AlarmMotorOvertemp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0 = Alarm, motor overtemperature p2080[13] = r 2135.14
         MotorRotatesClockwise { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Motor rotates clockwise (Internal inverter actual value > 0), 0 = Motor rotates counterclockwise (Invertal inverter actual value < 0) p 2080[14] = 2197.3
         AlarmInverterThermalOverload { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0 = Alarm, inverter thermal overload p 2080[15] = r0836.0 / r2135.15
         ReadyToStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Ready_to_start (Power supply switched in; electronics initialized; pulses locked) p 2080[0] = r 0899.0
         Ready { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Ready (Motor is switched on (ON/OFF1 = 1), no fault is active. With the command "Enable operation" (STW1.3), the inverterswitches on the motor) p 2080[1] = r 0899.1
         OperationEnabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Operation enabled (Motor follows setpoint. See control word 1 bit 3) p 2080[2] = r 0899.2
         FaultActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Fault_active (The inverter has a fault. Acknowledge fault using STW1.7) p 2080[3] = r 2139.3
         OFF2Inactive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = OFF2_inactive (Coast down to standstill is not active) p 2080[4] = r 0899.4
         OFF3Inactive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = OFF3_inactive (Quick stop is not active) p 2080[5] = r 0899.5
         SpareBit6 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Spare bit 6
         AlarmActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Alarm_active (Motor remains switched on; no acknowledgement is necessary.) p 2080[7] = r 2139.7
      END_STRUCT;
      ActualSpeed : Int;   // Actual Speed 100%=4000 HEX = 16384 DEZ normalisation with p 2000 of the inverter
      ActualCurrent : Int;   // Actual Current 100%=4000 HEX = 16384 DEZ normalisation with p 2002 of the inverter
      ActualTorque : Int;   // Actual Torque 100%=4000 HEX = 16384 DEZ normalisation with p 2003 of the inverter
      AlarmCode : UInt;   // Actual alarm Code
      FaultCode : UInt;   // Actual fault Code
      XIST_A : DInt;   // Actual position value [LU]
      SpareWord9 : Int;   // Spare Word 9
      SpareWord10 : Int;   // Spare Word 10
      SpareWord11 : Int;   // Spare Word 11
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_VfdSiemensCommissioning"
TITLE = FB_VFD_Siemens_Commissioning
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
VERSION : 3.2
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 38
// END_ATTRIBUTES
   VAR_INPUT 
      ihw_SinaParamHardwareId { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_IO := 0;   // Device hardware ID
      iUDT_MotorConfig { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_MotorData";   // Motor nad VFD parameters
      ix_Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Input enable signal
   END_VAR

   VAR_OUTPUT 
      qx_Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parametrization in progress
      qx_Done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parametrization done
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parametrization error
      qx_StartMeasuring { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start measuring
   END_VAR

   VAR_IN_OUT 
      iqx_GoToNextStep { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Go to next step
   END_VAR

   VAR 
      sa_Parameter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Array[1..16] of "UDT_VfdSinaParameterUser";   // Structure with parameters
      sa_ParameterEmpty { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Array[1..16] of "UDT_VfdSinaParameterUser";   // Empty structure
      sa_ParameterToCompare { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Array[1..16] of "UDT_VfdSinaParameterUser";   // Structure with parameters to compare
      sFB_SinaParaInstance {InstructionName := 'SinaPara'; LibVersion := '1.1'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : SinaPara;   // Write/read parameters to/from VFD
      sR_TRIG_StartJob {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Bit for start trigger for rising edge
      sR_TRIG_Time {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Bit for trigger for time couting
      sR_TRIG_DelayTime {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Bit for trigger for time couting
      sF_TRIG_CancelJob {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Bit for start trigger for falling edge
      sa_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Parametrization status
         StepNr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // The number of the current step
         StepNrError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // The number of the step in witch the error occurred
         ParameterNrError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // The number of the parameter in witch the error occurred
         ResponseValueError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Response value error
         WrongFormat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Wrong parameter format
         TimeExceeded { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Time has been exceeded
         NeedAck { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Need acknowledge signal (to cintinue parametrization)
         StepDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Step done
         MemoryCardInserted { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The card is in the VFD, checked in step 51
      END_STRUCT;
      sa_SinaPara { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Sina Para status
         DiagId { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Expanded communication error
         ErrorId { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DWord;   // Error Id: 1st word (binary) coded as to which parameter access is faulted
         Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Main error signal from SINA_PARA instruction
      END_STRUCT;
      sa_Stepconfig { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Structure with step configuration
         Read { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Write { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         ParaNo { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         new_Step_config { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
            Used { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
            Read { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
            Write { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
            ParaNo { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         END_STRUCT;
      END_STRUCT;
      sa_StepconfigEmpty { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Empty structure
         Read { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Write { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         ParaNo { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         new_Step_config { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
            Used { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
            Read { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
            Write { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
            ParaNo { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         END_STRUCT;
      END_STRUCT;
      si_StepNr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Current step number
      si_StepNrOLD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Step number in previous PLC cycle
      si_StepTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Step time
      si_DelayTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // The time after which is read the parameters
      si_StepNrError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // The step number where the error is currently
      si_ParameterNrError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // The parameter number where the error is currently
      si_SinaParaParaNo { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 0;   // SinaPara- Number of parameter, 0 to 16
      si_Loop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Number of parameters used in loop
      sx_Only_motor_measuring { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // [True] If the motor and VFD have been parameterized. Only measure the motor.
      sx_ActiveButtonGoToNextStep { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Button to go for the next step
      sx_Start { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Signal to start of parameterization function SinaPara
      sx_Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parametrization in progress (busy)
      sx_Done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parametrization done
      sx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Main error signal
      sx_OnlyRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Only read mode
      sx_OnlyWrite { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Only write mode
      sx_WriteRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Write and read mode
      sx_SinaParaStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // SinaPara- Start of parameterization, 0= inactive function, 1= active function
      sx_SinaParaReadWrite { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // SinaPara- Read/write parameters , 0=read parameter , 1=write parameter
      sx_SinaParaReady { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // SinaPara- Ready to parameterization
      sx_SinaParaBusy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // SinaPara- Busy signal
      sx_SinaParaDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // SinaPara- Parameterization done
      sx_ReadDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Read done
      sx_WriteDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Write done
      sx_PreparedData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Step data prepared
      sx_TimeRTrig { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Trigger for time counting
      sx_ReadTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Read time, on this time the parameters are read in the loop
      sx_Freecycle { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // "Empty" program cycle where the code is not executed, SinaPara need edge to start
      sx_StartMeasuring { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start measuring
      sx_ComparisonParameters { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Comparison parameters ,1- Correct , 0- Bad
      sx_StartDelayTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Delay of reading parameters
      sx_ResponseValueError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The parameter read out is not correct
      sx_WrongFormat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The parameter has a wrong format
      sx_SelectedG120C { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sequence from VFD G120C
      sx_SelectedG120D { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sequence from VFD G120D
   END_VAR

   VAR CONSTANT 
      cb_SinaParamAxisNo : Byte := 16#01;   // Axis number
      ci_StepTime : Int := 60;   // The time that the function has to read the correct parameters
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/06/2019  | 1.0       | S. Nikodem    | first release MHS TIA 15.1
	12/11/2019  | 3.0       | P. Majka      | 3.0 MHS library release TIA 15.1
	12/10/2021  | 3.2       | S. Nikodem    | new release MHS TIA 15.1
	03/11/2021  | 3.3       | M. Piela      | Add comments
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Start Job
	    
	    // Monitor rising trigger if is input enable signal
	    #sR_TRIG_StartJob(CLK := #ix_Enable);
	    
	    // If start trigger  occurs for a rising edge then variables to start conditions are prepared
	    IF (#sR_TRIG_StartJob.Q)
	    THEN
	        
	        #sx_Start := TRUE;
	        #sx_Busy := TRUE;
	        #sx_Done := FALSE;
	        #sx_Error := FALSE;
	        #sx_Freecycle := FALSE;
	        #sx_ReadDone := FALSE;
	        #sx_WriteDone := FALSE;
	        #sx_PreparedData := FALSE;
	        #si_StepTime := 0;
	        #sx_ResponseValueError := FALSE;
	        #sx_WrongFormat := FALSE;
	        #si_StepNrError := 0;
	        #si_ParameterNrError := 0;
	        #sx_StartDelayTime := FALSE;
	        #sa_Status.MemoryCardInserted := FALSE;
	        
	        #sa_Status.StepDone := FALSE;
	        #sa_Status.NeedAck := FALSE;
	        #sa_Status.ResponseValueError := FALSE;
	        #sa_Status.StepNrError := 0;
	        #sa_Status.ParameterNrError := 0;
	        #sa_Status.TimeExceeded := FALSE;
	        
	        #si_StepNr := 1;
	        
	        //After activation bit “sx_Only_motor_measuring” sequence jump to step 44 and only the motor measurement
	        //and all steps after it will be performed. But before that VFD, Safety must be configured and switched on 400 V.
	        IF #sx_Only_motor_measuring THEN
	            
	            #si_StepNr := 44;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Cancel Job
	    
	    // Monitor falling trigger if is input enable signal
	    #sF_TRIG_CancelJob(CLK := #ix_Enable);
	    
	    // If occurs start trigger for falling edge 
	    IF (#sF_TRIG_CancelJob.Q)
	    THEN
	        
	        #sx_Start := FALSE;
	        #sx_Busy := FALSE;
	        #sx_StartMeasuring := FALSE;
	        
	        // If parametrization is not done
	        IF (NOT #sx_Done)
	        THEN
	            
	            #sx_Error := TRUE;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Clean structure 
	    
	    //When a step in the sequence changes, the structure must be cleared
	    IF (#si_StepNrOLD <> #si_StepNr) OR #sR_TRIG_StartJob.Q THEN
	        
	        #sa_Parameter := #sa_ParameterEmpty;
	        #sa_Stepconfig := #sa_StepconfigEmpty;
	        
	    END_IF;
	    
	    //Copy step number
	    #si_StepNrOLD := #si_StepNr;
	    
	END_REGION
	
	REGION 4 - Sequence steps
	    
	    //The VFD type is selected based on the variable "# i_UDT_MotorConfig.VFDType"
	    #sx_SelectedG120D := #iUDT_MotorConfig.VFDType = 5302 OR
	    #iUDT_MotorConfig.VFDType = 5304 OR
	    #iUDT_MotorConfig.VFDType = 5306 OR
	    #iUDT_MotorConfig.VFDType = 5307 OR
	    #iUDT_MotorConfig.VFDType = 5308 OR
	    #iUDT_MotorConfig.VFDType = 5309;
	    
	    #sx_SelectedG120C := #iUDT_MotorConfig.VFDType = 1;
	    
	    REGION Step 1
	        
	        IF #si_StepNr = 1 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;           //Paramerters are readed
	            #sa_Stepconfig.Write := TRUE;          //Paramerters are write
	            #sa_Stepconfig.ParaNo := 1;            //Defined how many parameters are used
	            
	            //Used parameters in this step 
	            //1 - Drive commissioning mode, 30: Parameter reset
	            #sa_Parameter[1].siParaNo := 10;        //Parameter number
	            #sa_Parameter[1].srValue := 30.0;       //Parameter value
	            #sa_Parameter[1].syFormat := 3;         //Parameter format
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 2 
	        
	        IF #si_StepNr = 2 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 1;
	            
	            //Used parameters in this step 
	            //1 - Reset drive parameters, 1: Start a parameter reset
	            #sa_Parameter[1].siParaNo := 970;
	            #sa_Parameter[1].srValue := 1.0;
	            #sa_Parameter[1].syFormat := 16#0006;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 3
	        
	        IF #si_StepNr = 3 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.ParaNo := 3;
	            
	            //Used parameters in this step 
	            //1 - Drive commissioning mode, 1: Quick commissioning
	            #sa_Parameter[1].siParaNo := 10;
	            #sa_Parameter[1].srValue := 1.0;
	            #sa_Parameter[1].syFormat := 16#0003;
	            //2 - Reset drive parameters
	            #sa_Parameter[2].siParaNo := 970;
	            #sa_Parameter[2].syFormat := 16#0006;
	            //3 - Parameter write inhibit status
	            #sa_Parameter[3].siParaNo := 3996;
	            #sa_Parameter[3].syFormat := 0;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 4
	        
	        IF #si_StepNr = 4 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 1;
	            
	            //Used parameters in this step 
	            //1 - Drive commissioning mode, 30: Parameter reset
	            #sa_Parameter[1].siParaNo := 10;
	            #sa_Parameter[1].srValue := 30.0;
	            #sa_Parameter[1].syFormat := 3;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 5
	        
	        IF #si_StepNr = 5 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 2;
	            
	            //Used parameters in this step 
	            //1 - SI password input, 0 = default value
	            #sa_Parameter[1].siParaNo := 9761;
	            #sa_Parameter[1].syFormat := 7;
	            //2 - Drive commissioning mode, 30: Parameter reset
	            #sa_Parameter[2].siParaNo := 10;
	            #sa_Parameter[2].srValue := 30.0;
	            #sa_Parameter[2].syFormat := 3;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 6
	        
	        IF #si_StepNr = 6 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 1;
	            
	            //Used parameters in this step 
	            //1 - Reset drive parameters, 5: Starts a safety parameter reset
	            #sa_Parameter[1].siParaNo := 970;
	            #sa_Parameter[1].srValue := 5.0;
	            #sa_Parameter[1].syFormat := 3;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 7
	        
	        IF #si_StepNr = 7 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.ParaNo := 3;
	            
	            //Used parameters in this step 
	            //1 - Drive commissioning mode, 1: Quick commissioning
	            #sa_Parameter[1].siParaNo := 10;
	            #sa_Parameter[1].srValue := 1.0;
	            #sa_Parameter[1].syFormat := 3;
	            //2 - Reset drive parameters
	            #sa_Parameter[2].siParaNo := 970;
	            #sa_Parameter[2].syFormat := BYTE#16#03;
	            //3 - Parameter write inhibit status
	            #sa_Parameter[3].siParaNo := 3996;
	            #sa_Parameter[3].syFormat := BYTE#16#05;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 8
	        
	        IF #si_StepNr = 8 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 1;
	            
	            //Used parameters in this step 
	            //1 - Save parameters, 1: Save drive object
	            #sa_Parameter[1].siParaNo := 971;
	            #sa_Parameter[1].srValue := 1.0;
	            #sa_Parameter[1].syFormat := 6;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 9
	        
	        IF #si_StepNr = 9 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.ParaNo := 1;
	            
	            //Used parameters in this step 
	            //1 - Save parameters
	            #sa_Parameter[1].siParaNo := 971;
	            #sa_Parameter[1].syFormat := 6;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 10
	        
	        IF #si_StepNr = 10 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 1;
	            
	            //Used parameters in this step 
	            //1 - Drive commissioning mode, 1: Quick commissioning
	            #sa_Parameter[1].siParaNo := 10;
	            #sa_Parameter[1].srValue := 1.0;
	            #sa_Parameter[1].syFormat := 3;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 11
	        
	        IF #si_StepNr = 11 AND #sx_SelectedG120D THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 8;
	            
	            //Used parameters in this step 
	            //1 - Macro drive unit
	            #sa_Parameter[1].siParaNo := 15;
	            #sa_Parameter[1].sdValue := 27;
	            #sa_Parameter[1].syFormat := BYTE#16#07;
	            //2 - Power unit application
	            #sa_Parameter[2].siParaNo := 205;
	            #sa_Parameter[2].syFormat := BYTE#16#03;
	            //3 - Automatic calculation motor/control parameters
	            #sa_Parameter[3].siParaNo := 340;
	            #sa_Parameter[3].syFormat := BYTE#16#03;
	            //4 - Technology application
	            #sa_Parameter[4].siParaNo := 500;
	            #sa_Parameter[4].syFormat := BYTE#16#03;
	            //5 - Field bus interface protocol selection
	            #sa_Parameter[5].siParaNo := 2030;
	            #sa_Parameter[5].srValue := 7.0;
	            #sa_Parameter[5].syFormat := BYTE#16#03;
	            //6 - IEC/NEMA mot stds
	            #sa_Parameter[6].siParaNo := 100;
	            #sa_Parameter[6].syFormat := BYTE#16#03;
	            //7 - Drive filter type motor side
	            #sa_Parameter[7].siParaNo := 230;
	            #sa_Parameter[7].syFormat := BYTE#16#03;
	            //8 - Motor cooling type
	            #sa_Parameter[8].siParaNo := 335;
	            #sa_Parameter[8].syFormat := BYTE#16#03;
	            
	        END_IF;
	        
	        IF #si_StepNr = 11 AND #sx_SelectedG120C THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 6;
	            
	            //Used parameters in this step 
	            //1 - Macro drive unit
	            #sa_Parameter[1].siParaNo := 15;
	            #sa_Parameter[1].sdValue := 7;
	            #sa_Parameter[1].syFormat := BYTE#16#07;
	            //2 - Automatic calculation motor/control parameters
	            #sa_Parameter[2].siParaNo := 340;
	            #sa_Parameter[2].syFormat := BYTE#16#03;
	            //3 - Field bus interface protocol selection
	            #sa_Parameter[3].siParaNo := 2030;
	            #sa_Parameter[3].srValue := 7.0;
	            #sa_Parameter[3].syFormat := BYTE#16#03;
	            //4 - IEC/NEMA mot stds
	            #sa_Parameter[4].siParaNo := 100;
	            #sa_Parameter[4].syFormat := BYTE#16#03;
	            //5 - Drive filter type motor side
	            #sa_Parameter[5].siParaNo := 230;
	            #sa_Parameter[5].syFormat := BYTE#16#03;
	            //6 - Motor cooling type
	            #sa_Parameter[6].siParaNo := 335;
	            #sa_Parameter[6].syFormat := BYTE#16#03;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 12
	        
	        IF #si_StepNr = 12 AND #sx_SelectedG120D THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 1;
	            
	            //Used parameters in this step 
	            //1 - Open-loop/closed-loop control operating mode
	            IF #iUDT_MotorConfig.EncoderConfig THEN
	                
	                #sa_Parameter[1].siParaNo := 1300;
	                #sa_Parameter[1].srValue := 21.0;           //21: Speed control (with encoder)
	                #sa_Parameter[1].syFormat := BYTE#16#03;
	                
	            ELSE
	                
	                #sa_Parameter[1].siParaNo := 1300;
	                #sa_Parameter[1].srValue := 20.0;           //20: Speed control (encoderless)
	                #sa_Parameter[1].syFormat := BYTE#16#03;
	                
	            END_IF;
	            
	        END_IF;
	        
	        IF #si_StepNr = 12 AND #sx_SelectedG120C THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 1;
	            
	            //Used parameters in this step 
	            //1 - PROFIdrive PZD telegram selection, 999: Free telegram configuration with BICO
	            #sa_Parameter[1].siParaNo := 922;
	            #sa_Parameter[1].srValue := 999.0;
	            #sa_Parameter[1].syFormat := BYTE#16#06;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 13
	        
	        IF #si_StepNr = 13 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 3;
	            
	            //Used parameters in this step 
	            //1 - PROFIdrive PZD telegram selection, 999: Free telegram configuration with BICO
	            #sa_Parameter[1].siParaNo := 922;
	            #sa_Parameter[1].srValue := 999.0;
	            #sa_Parameter[1].syFormat := BYTE#16#06;
	            //2 - Speed setpoint selection, 6: No supplementary setpoint + Fieldbus
	            #sa_Parameter[2].siParaNo := 1000;
	            #sa_Parameter[2].srValue := 6.0;
	            #sa_Parameter[2].syFormat := BYTE#16#03;
	            //3 - Motor data identification and rotating measurement
	            #sa_Parameter[3].siParaNo := 1900;
	            #sa_Parameter[3].syFormat := 16#0003;
	            #sa_Parameter[3].swErrorNo := 16#0000;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 14
	        
	        IF #si_StepNr = 14 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 16;
	            
	            //Used parameters in this step 
	            //1 - Telegram word 1 bit 0 
	            #sa_Parameter[1].siParaNo := 2080;
	            #sa_Parameter[1].sdValue := 58981376;       //r899.0
	            #sa_Parameter[1].syFormat := BYTE#16#07;
	            //2 - Telegram word 1 bit 1
	            #sa_Parameter[2].siParaNo := 2080;
	            #sa_Parameter[2].siIndex := 1;
	            #sa_Parameter[2].sdValue := 58981377;       //r899.1
	            #sa_Parameter[2].syFormat := BYTE#16#07;
	            //3 - Telegram word 1 bit 2
	            #sa_Parameter[3].siParaNo := 2080;
	            #sa_Parameter[3].siIndex := 2;
	            #sa_Parameter[3].sdValue := 58981378;       //r899.2
	            #sa_Parameter[3].syFormat := BYTE#16#07;
	            //4 - Telegram word 1 bit 3
	            #sa_Parameter[4].siParaNo := 2080;
	            #sa_Parameter[4].siIndex := 3;
	            #sa_Parameter[4].sdValue := 140_246_019;    //r2139.3
	            #sa_Parameter[4].syFormat := BYTE#16#07;
	            //5 - Telegram word 1 bit 4
	            #sa_Parameter[5].siParaNo := 2080;
	            #sa_Parameter[5].siIndex := 4;
	            #sa_Parameter[5].sdValue := 58981380;       //r899.4
	            #sa_Parameter[5].syFormat := BYTE#16#07;
	            //6 - Telegram word 1 bit 5
	            #sa_Parameter[6].siParaNo := 2080;
	            #sa_Parameter[6].siIndex := 5;
	            #sa_Parameter[6].sdValue := 58981381;       //r889.5
	            #sa_Parameter[6].syFormat := BYTE#16#07;
	            //7 - Telegram word 1 bit 6
	            #sa_Parameter[7].siParaNo := 2080;
	            #sa_Parameter[7].siIndex := 6;
	            #sa_Parameter[7].syFormat := BYTE#16#07;
	            //8 - Telegram word 1 bit 7
	            #sa_Parameter[8].siParaNo := 2080;
	            #sa_Parameter[8].siIndex := 7;
	            #sa_Parameter[8].sdValue := 140_246_023;        //r2139.7
	            #sa_Parameter[8].syFormat := BYTE#16#07;
	            //9 - Telegram word 1 bit 8
	            #sa_Parameter[9].siParaNo := 2080;
	            #sa_Parameter[9].siIndex := 8;
	            #sa_Parameter[9].syFormat := BYTE#16#07;
	            //10 - Telegram word 1 bit 9
	            #sa_Parameter[10].siParaNo := 2080;
	            #sa_Parameter[10].siIndex := 9;
	            #sa_Parameter[10].sdValue := 58981385;          //r899.9
	            #sa_Parameter[10].syFormat := BYTE#16#07;
	            //11 - Telegram word 1 bit 10
	            #sa_Parameter[11].siParaNo := 2080;
	            #sa_Parameter[11].siIndex := 10;
	            #sa_Parameter[11].syFormat := BYTE#16#07;
	            //12 - Telegram word 1 bit 11
	            #sa_Parameter[12].siParaNo := 2080;
	            #sa_Parameter[12].siIndex := 11;
	            #sa_Parameter[12].syFormat := BYTE#16#07;
	            //13 - Telegram word 1 bit 12
	            #sa_Parameter[13].siParaNo := 2080;
	            #sa_Parameter[13].siIndex := 12;
	            #sa_Parameter[13].sdValue := 58981388;          //r899.12
	            #sa_Parameter[13].syFormat := BYTE#16#07;
	            //14 - Telegram word 1 bit 13
	            #sa_Parameter[14].siParaNo := 2080;
	            #sa_Parameter[14].siIndex := 13;
	            #sa_Parameter[14].sdValue := 139_983_886;       //r2135.14
	            #sa_Parameter[14].syFormat := BYTE#16#07;
	            //15 - Telegram word 1 bit 14
	            #sa_Parameter[15].siParaNo := 2080;
	            #sa_Parameter[15].siIndex := 14;
	            #sa_Parameter[15].sdValue := 144_047_107;       //r2197.3
	            #sa_Parameter[15].syFormat := BYTE#16#07;
	            //16 - Telegram word 1 bit 15
	            #sa_Parameter[16].siParaNo := 2080;
	            #sa_Parameter[16].siIndex := 15;
	            #sa_Parameter[16].sdValue := 139_983_887;       //r2135.15
	            #sa_Parameter[16].syFormat := BYTE#16#07;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 15
	        
	        IF #si_StepNr = 15 AND #sx_SelectedG120D THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 15;
	            
	            //Used parameters in this step 
	            //1 - Invert binector-connector converter status word
	            #sa_Parameter[1].siParaNo := 2088;
	            #sa_Parameter[1].srValue := 43008.0;
	            #sa_Parameter[1].syFormat := BYTE#16#06;
	            
	            //CI: PROFIdrive PZD send word
	            //2 - Telegram word 0
	            #sa_Parameter[2].siParaNo := 2051;
	            #sa_Parameter[2].sdValue := 136_969_216;
	            #sa_Parameter[2].syFormat := BYTE#16#07;
	            //3 - Telegram word 1
	            #sa_Parameter[3].siParaNo := 2051;
	            #sa_Parameter[3].siIndex := 1;
	            #sa_Parameter[3].sdValue := 4193280;
	            #sa_Parameter[3].syFormat := BYTE#16#07;
	            //4 - Telegram word 2
	            #sa_Parameter[4].siParaNo := 2051;
	            #sa_Parameter[4].siIndex := 2;
	            #sa_Parameter[4].sdValue := 4520961;
	            #sa_Parameter[4].syFormat := BYTE#16#07;
	            //5 - Telegram word 3
	            #sa_Parameter[5].siParaNo := 2051;
	            #sa_Parameter[5].siIndex := 3;
	            #sa_Parameter[5].sdValue := 5307393;
	            #sa_Parameter[5].syFormat := BYTE#16#07;
	            //6 - Telegram word 4
	            #sa_Parameter[6].siParaNo := 2051;
	            #sa_Parameter[6].siIndex := 4;
	            #sa_Parameter[6].sdValue := 139_787_264;
	            #sa_Parameter[6].syFormat := BYTE#16#07;
	            //7 - Telegram word 5
	            #sa_Parameter[7].siParaNo := 2051;
	            #sa_Parameter[7].siIndex := 5;
	            #sa_Parameter[7].sdValue := 139_721_728;
	            #sa_Parameter[7].syFormat := BYTE#16#07;
	            //8 - Telegram word 9
	            #sa_Parameter[8].siParaNo := 2051;
	            #sa_Parameter[8].siIndex := 9;
	            #sa_Parameter[8].syFormat := BYTE#16#07;
	            //9 - Telegram word 10
	            #sa_Parameter[9].siParaNo := 2051;
	            #sa_Parameter[9].siIndex := 10;
	            #sa_Parameter[9].syFormat := BYTE#16#07;
	            //10 - Telegram word 11
	            #sa_Parameter[10].siParaNo := 2051;
	            #sa_Parameter[10].siIndex := 11;
	            #sa_Parameter[10].sdValue := 47381504;
	            #sa_Parameter[10].syFormat := BYTE#16#07;
	            
	            //CI: PROFIdrive PZD send double word
	            //11 - Telegrm double word 5
	            #sa_Parameter[11].siParaNo := 2061;
	            #sa_Parameter[11].siIndex := 5;
	            #sa_Parameter[11].syFormat := BYTE#16#07;
	            //12 - Telegrm double word 6
	            #sa_Parameter[12].siParaNo := 2061;
	            #sa_Parameter[12].siIndex := 6;
	            #sa_Parameter[12].syFormat := BYTE#16#07;
	            //13 - Telegrm double word 7
	            #sa_Parameter[13].siParaNo := 2061;
	            #sa_Parameter[13].siIndex := 7;
	            #sa_Parameter[13].syFormat := BYTE#16#07;
	            
	            //14 - CI: Ramp-function generator ramp-up time scaling
	            #sa_Parameter[14].siParaNo := 1138;
	            #sa_Parameter[14].sdValue := 134_413_314;
	            #sa_Parameter[14].syFormat := BYTE#16#07;
	            //15 - CI: Ramp-function generator ramp-down time scaling
	            #sa_Parameter[15].siParaNo := 1139;
	            #sa_Parameter[15].sdValue := 134_413_315;
	            #sa_Parameter[15].syFormat := BYTE#16#07;
	            
	        END_IF;
	        
	        IF #si_StepNr = 15 AND #sx_SelectedG120C THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 14;
	            
	            //Used parameters in this step 
	            //1 - Invert binector-connector converter status word
	            #sa_Parameter[1].siParaNo := 2088;
	            #sa_Parameter[1].srValue := 43008.0;
	            #sa_Parameter[1].syFormat := BYTE#16#06;
	            //2 - CI: PROFIdrive PZD send word
	            #sa_Parameter[2].siParaNo := 2051;
	            #sa_Parameter[2].sdValue := 136_969_216;
	            #sa_Parameter[2].syFormat := BYTE#16#07;
	            //3 - Telegram word 1
	            #sa_Parameter[3].siParaNo := 2051;
	            #sa_Parameter[3].siIndex := 1;
	            #sa_Parameter[3].sdValue := 4193280;
	            #sa_Parameter[3].syFormat := BYTE#16#07;
	            //4 - Telegram word 2
	            #sa_Parameter[4].siParaNo := 2051;
	            #sa_Parameter[4].siIndex := 2;
	            #sa_Parameter[4].sdValue := 4520961;
	            #sa_Parameter[4].syFormat := BYTE#16#07;
	            //5 - Telegram word 3
	            #sa_Parameter[5].siParaNo := 2051;
	            #sa_Parameter[5].siIndex := 3;
	            #sa_Parameter[5].sdValue := 5307393;
	            #sa_Parameter[5].syFormat := BYTE#16#07;
	            //6 - Telegram word 4
	            #sa_Parameter[6].siParaNo := 2051;
	            #sa_Parameter[6].siIndex := 4;
	            #sa_Parameter[6].sdValue := 139_787_264;
	            #sa_Parameter[6].syFormat := BYTE#16#07;
	            //7 - Telegram word 11
	            #sa_Parameter[7].siParaNo := 2051;
	            #sa_Parameter[7].siIndex := 11;
	            #sa_Parameter[7].sdValue := 47381504;
	            #sa_Parameter[7].syFormat := BYTE#16#07;
	            //8 - Telegram word 9
	            #sa_Parameter[8].siParaNo := 2051;
	            #sa_Parameter[8].siIndex := 9;
	            #sa_Parameter[8].syFormat := BYTE#16#07;
	            //9 - Telegram word 10
	            #sa_Parameter[9].siParaNo := 2051;
	            #sa_Parameter[9].siIndex := 10;
	            #sa_Parameter[9].syFormat := BYTE#16#07;
	            //CI: PROFIdrive PZD send double word
	            //10 - Telegrm double word 5
	            #sa_Parameter[10].siParaNo := 2061;
	            #sa_Parameter[10].siIndex := 5;
	            #sa_Parameter[10].syFormat := BYTE#16#07;
	            //11 - Telegrm double word 6
	            #sa_Parameter[11].siParaNo := 2061;
	            #sa_Parameter[11].siIndex := 6;
	            #sa_Parameter[11].syFormat := BYTE#16#07;
	            //12 - Telegrm double word 5
	            #sa_Parameter[12].siParaNo := 2061;
	            #sa_Parameter[12].siIndex := 5;
	            #sa_Parameter[12].syFormat := BYTE#16#08;
	            //13 - CI: Ramp-function generator ramp-up time scaling
	            #sa_Parameter[13].siParaNo := 1138;
	            #sa_Parameter[13].sdValue := 134_413_314;
	            #sa_Parameter[13].syFormat := BYTE#16#07;
	            //14 - CI: Ramp-function generator ramp-down time scaling
	            #sa_Parameter[14].siParaNo := 1139;
	            #sa_Parameter[14].sdValue := 134_413_315;
	            #sa_Parameter[14].syFormat := BYTE#16#07;
	            
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 16
	        
	        IF #si_StepNr = 16 AND #sx_SelectedG120D THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 14;
	            
	            //Used parameters in this step 
	            //1 - BI: ON/OFF (OFF1)
	            #sa_Parameter[1].siParaNo := 840;
	            #sa_Parameter[1].sdValue := 137_034_752;
	            #sa_Parameter[1].syFormat := BYTE#16#07;
	            //2 - BI: No coast-down / coast-down (OFF2) signal source 1
	            #sa_Parameter[2].siParaNo := 844;
	            #sa_Parameter[2].sdValue := 137_034_753;
	            #sa_Parameter[2].syFormat := BYTE#16#07;
	            //3 - BI: No Quick Stop / Quick Stop (OFF3) signal source 1
	            #sa_Parameter[3].siParaNo := 848;
	            #sa_Parameter[3].sdValue := 137_034_754;
	            #sa_Parameter[3].syFormat := BYTE#16#07;
	            //4 - BI: Enable operation/inhibit operation
	            #sa_Parameter[4].siParaNo := 852;
	            #sa_Parameter[4].sdValue := 137_034_755;
	            #sa_Parameter[4].syFormat := BYTE#16#07;
	            //5 - BI: Enable ramp-function generator/inhibit ramp-function generator
	            #sa_Parameter[5].siParaNo := 1140;
	            #sa_Parameter[5].sdValue := 137_034_756;
	            #sa_Parameter[5].syFormat := BYTE#16#07;
	            //6 - BI: Continue ramp-function generator/freeze ramp-function generator
	            #sa_Parameter[6].siParaNo := 1141;
	            #sa_Parameter[6].sdValue := 137_034_757;
	            #sa_Parameter[6].syFormat := BYTE#16#07;
	            //7 - BI: Enable setpoint/inhibit setpoint
	            #sa_Parameter[7].siParaNo := 1142;
	            #sa_Parameter[7].sdValue := 137_034_758;
	            #sa_Parameter[7].syFormat := BYTE#16#07;
	            //8 - BI: 1st acknowledge faults
	            #sa_Parameter[8].siParaNo := 2103;
	            #sa_Parameter[8].sdValue := 137_034_759;
	            #sa_Parameter[8].syFormat := BYTE#16#07;
	            //9 - BI: Control by PLC/no control by PLC
	            #sa_Parameter[9].siParaNo := 854;
	            #sa_Parameter[9].sdValue := 137_034_762;
	            #sa_Parameter[9].syFormat := BYTE#16#07;
	            //10 - BI: Setpoint inversion
	            #sa_Parameter[10].siParaNo := 1113;
	            #sa_Parameter[10].sdValue := 137_034_763;
	            #sa_Parameter[10].syFormat := BYTE#16#07;
	            //11 - CI: Main setpoint
	            #sa_Parameter[11].siParaNo := 1070;
	            #sa_Parameter[11].sdValue := 134_413_313;
	            #sa_Parameter[11].syFormat := BYTE#16#07;
	            //12 - CI: Connector-binector converter signal source
	            #sa_Parameter[12].siParaNo := 2099;
	            #sa_Parameter[12].sdValue := 134_413_323;
	            #sa_Parameter[12].syFormat := BYTE#16#07;
	            //13 - BI: CU signal source for terminal DO 0
	            #sa_Parameter[13].siParaNo := 730;
	            #sa_Parameter[13].sdValue := 137_296_896;
	            #sa_Parameter[13].syFormat := BYTE#16#07;
	            //14 - BI: CU signal source for terminal DO 1
	            #sa_Parameter[14].siParaNo := 731;
	            #sa_Parameter[14].sdValue := 137_296_897;
	            #sa_Parameter[14].syFormat := BYTE#16#07;
	            
	        END_IF;
	        
	        IF #si_StepNr = 16 AND #sx_SelectedG120C THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 15;
	            
	            //Used parameters in this step 
	            //1 - BI: ON/OFF (OFF1)
	            #sa_Parameter[1].siParaNo := 840;
	            #sa_Parameter[1].sdValue := 137_034_752;
	            #sa_Parameter[1].syFormat := BYTE#16#07;
	            //2 - BI: No coast-down / coast-down (OFF2) signal source 1
	            #sa_Parameter[2].siParaNo := 844;
	            #sa_Parameter[2].sdValue := 137_034_753;
	            #sa_Parameter[2].syFormat := BYTE#16#07;
	            //3 - BI: No Quick Stop / Quick Stop (OFF3) signal source 1
	            #sa_Parameter[3].siParaNo := 848;
	            #sa_Parameter[3].sdValue := 137_034_754;
	            #sa_Parameter[3].syFormat := BYTE#16#07;
	            //4 - BI: Enable operation/inhibit operation
	            #sa_Parameter[4].siParaNo := 852;
	            #sa_Parameter[4].sdValue := 137_034_755;
	            #sa_Parameter[4].syFormat := BYTE#16#07;
	            //5 - BI: Enable ramp-function generator/inhibit ramp-function generator
	            #sa_Parameter[5].siParaNo := 1140;
	            #sa_Parameter[5].sdValue := 137_034_756;
	            #sa_Parameter[5].syFormat := BYTE#16#07;
	            //6 - BI: Continue ramp-function generator/freeze ramp-function generator
	            #sa_Parameter[6].siParaNo := 1141;
	            #sa_Parameter[6].sdValue := 137_034_757;
	            #sa_Parameter[6].syFormat := BYTE#16#07;
	            //7 - BI: Enable setpoint/inhibit setpoint
	            #sa_Parameter[7].siParaNo := 1142;
	            #sa_Parameter[7].sdValue := 137_034_758;
	            #sa_Parameter[7].syFormat := BYTE#16#07;
	            //8 - BI: 1st acknowledge faults
	            #sa_Parameter[8].siParaNo := 2103;
	            #sa_Parameter[8].sdValue := 137_034_759;
	            #sa_Parameter[8].syFormat := BYTE#16#07;
	            //9 - BI: Control by PLC/no control by PLC
	            #sa_Parameter[9].siParaNo := 854;
	            #sa_Parameter[9].sdValue := 137_034_762;
	            #sa_Parameter[9].syFormat := BYTE#16#07;
	            //10 - BI: Setpoint inversion
	            #sa_Parameter[10].siParaNo := 1113;
	            #sa_Parameter[10].sdValue := 137_034_763;
	            #sa_Parameter[10].syFormat := BYTE#16#07;
	            //11 - CI: Main setpoint
	            #sa_Parameter[11].siParaNo := 1070;
	            #sa_Parameter[11].sdValue := 134_413_313;
	            #sa_Parameter[11].syFormat := BYTE#16#07;
	            //12 - CI: Connector-binector converter signal source
	            #sa_Parameter[12].siParaNo := 2099;
	            #sa_Parameter[12].sdValue := 134_413_323;
	            #sa_Parameter[12].syFormat := BYTE#16#07;
	            //13 - BI: CU signal source for terminal DO 0
	            #sa_Parameter[13].siParaNo := 730;
	            #sa_Parameter[13].sdValue := 3472387;
	            #sa_Parameter[13].syFormat := BYTE#16#07;
	            
	            IF #iUDT_MotorConfig.BrakeConfig THEN
	                
	                //14 - BI: CU signal source for terminal DO 1
	                #sa_Parameter[14].siParaNo := 731;
	                #sa_Parameter[14].sdValue := 58981388;
	                #sa_Parameter[14].syFormat := BYTE#16#07;
	                
	            ELSE
	                
	                //14 - BI: CU signal source for terminal DO 1
	                #sa_Parameter[14].siParaNo := 731;
	                #sa_Parameter[14].sdValue := 3537922;
	                #sa_Parameter[14].syFormat := BYTE#16#07;
	                
	            END_IF;
	            
	            //CI: PROFIdrive PZD send word
	            //15 - Telegram word 5
	            #sa_Parameter[15].siParaNo := 2051;
	            #sa_Parameter[15].siIndex := 5;
	            #sa_Parameter[15].sdValue := 139_721_728;
	            #sa_Parameter[15].syFormat := BYTE#16#07;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 17
	        
	        IF #si_StepNr = 17 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 11;
	            
	            //Used parameters in this step 
	            //p133 - Motor configuration
	            //1 - p133.0 Motor connection type
	            #sa_Parameter[1].siParaNo := 133;
	            #sa_Parameter[1].srValue := #iUDT_MotorConfig.Connection;
	            #sa_Parameter[1].syFormat := BYTE#16#06;
	            //2 - Drive unit line supply voltage
	            #sa_Parameter[2].siParaNo := 210;
	            #sa_Parameter[2].srValue := #iUDT_MotorConfig.MainVoltage;
	            #sa_Parameter[2].syFormat := BYTE#16#06;
	            //3 - Motor type selection
	            #sa_Parameter[3].siParaNo := 300;
	            #sa_Parameter[3].srValue := 1;                              //1: Induction motor
	            #sa_Parameter[3].syFormat := BYTE#16#03;
	            //4 - Rated motor voltage
	            #sa_Parameter[4].siParaNo := 304;
	            #sa_Parameter[4].srValue := #iUDT_MotorConfig.NominalVoltage;
	            #sa_Parameter[4].syFormat := BYTE#16#08;
	            //5 - Rated motor current
	            #sa_Parameter[5].siParaNo := 305;
	            #sa_Parameter[5].srValue := #iUDT_MotorConfig.NominalCurrent;
	            #sa_Parameter[5].syFormat := BYTE#16#08;
	            //6 - Number of motors connected in parallel
	            #sa_Parameter[6].siParaNo := 306;
	            #sa_Parameter[6].srValue := #iUDT_MotorConfig.NoMotorsParallel;
	            #sa_Parameter[6].syFormat := BYTE#16#05;
	            //7 - Rated motor power
	            #sa_Parameter[7].siParaNo := 307;
	            #sa_Parameter[7].srValue := #iUDT_MotorConfig.NominalPower;
	            #sa_Parameter[7].syFormat := BYTE#16#08;
	            //8 - Rated motor power factor
	            #sa_Parameter[8].siParaNo := 308;
	            #sa_Parameter[8].srValue := #iUDT_MotorConfig.CosPhi;
	            #sa_Parameter[8].syFormat := BYTE#16#08;
	            //9 - Rated motor frequency
	            #sa_Parameter[9].siParaNo := 310;
	            #sa_Parameter[9].srValue := 50.0;
	            #sa_Parameter[9].syFormat := BYTE#16#08;
	            //10 - Rated motor speed
	            #sa_Parameter[10].siParaNo := 311;
	            #sa_Parameter[10].srValue := 1450.0;
	            #sa_Parameter[10].syFormat := BYTE#16#08;
	            //11 - Current limit
	            #sa_Parameter[11].siParaNo := 640;
	            #sa_Parameter[11].srValue := #iUDT_MotorConfig.NominalCurrent * 1.5;
	            #sa_Parameter[11].syFormat := BYTE#16#08;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 18
	        
	        IF #si_StepNr = 18 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 5;
	            
	            //Used parameters in this step 
	            //1 - Ramp-function generator ramp-up time
	            #sa_Parameter[1].siParaNo := 1120;
	            #sa_Parameter[1].srValue := 10.0;
	            #sa_Parameter[1].syFormat := BYTE#16#08;
	            //2 - Ramp-function generator ramp-down time
	            #sa_Parameter[2].siParaNo := 1121;
	            #sa_Parameter[2].srValue := 10.0;
	            #sa_Parameter[2].syFormat := BYTE#16#08;
	            //3 - OFF3 ramp-down time
	            #sa_Parameter[3].siParaNo := 1135;
	            #sa_Parameter[3].srValue := #iUDT_MotorConfig.MinimumRamp;
	            #sa_Parameter[3].syFormat := BYTE#16#08;
	            //4 - Motor holding brake opening time
	            #sa_Parameter[4].siParaNo := 1216;
	            #sa_Parameter[4].srValue := 100.0;
	            #sa_Parameter[4].syFormat := BYTE#16#08;
	            //5 - Motor holding brake closing time
	            #sa_Parameter[5].siParaNo := 1217;
	            #sa_Parameter[5].srValue := 100.0;
	            #sa_Parameter[5].syFormat := BYTE#16#08;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 19
	        
	        IF #si_StepNr = 19 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 12;
	            
	            //Used parameters in this step 
	            //1 - Reference speed reference frequency
	            #sa_Parameter[1].siParaNo := 2000;
	            #sa_Parameter[1].srValue := 2000.0;
	            #sa_Parameter[1].syFormat := BYTE#16#08;
	            //2 - Reference current
	            #sa_Parameter[2].siParaNo := 2002;
	            #sa_Parameter[2].srValue := #iUDT_MotorConfig.NominalCurrent * 1.5;
	            #sa_Parameter[2].syFormat := BYTE#16#08;
	            //3 - Reference torque
	            #sa_Parameter[3].siParaNo := 2003;
	            #sa_Parameter[3].srValue := #iUDT_MotorConfig.NominalTorque * 1.5;
	            #sa_Parameter[3].syFormat := BYTE#16#08;
	            //4 - Ramp-function generator ramp-up time
	            #sa_Parameter[4].siParaNo := 1120;
	            #sa_Parameter[4].srValue := 20.0;
	            #sa_Parameter[4].syFormat := BYTE#16#08;
	            //5 - Ramp-function generator ramp-down time
	            #sa_Parameter[5].siParaNo := 1121;
	            #sa_Parameter[5].srValue := 20.0;
	            #sa_Parameter[5].syFormat := BYTE#16#08;
	            //Drive commissioning parameter filter
	            //6 - Power unit commissioning
	            #sa_Parameter[6].siParaNo := 10;
	            #sa_Parameter[6].srValue := 2.0;
	            #sa_Parameter[6].syFormat := BYTE#16#03;
	            //7 - Maximum speed
	            #sa_Parameter[7].siParaNo := 1082;
	            #sa_Parameter[7].srValue := 2000.0;
	            #sa_Parameter[7].syFormat := BYTE#16#08;
	            //8 - BI: Jog bit 0
	            #sa_Parameter[8].siParaNo := 1055;
	            #sa_Parameter[8].siIndex := 1;
	            #sa_Parameter[8].syFormat := BYTE#16#07;
	            //9 - BI: Jog bit 1
	            #sa_Parameter[9].siParaNo := 1056;
	            #sa_Parameter[9].siIndex := 1;
	            #sa_Parameter[9].syFormat := BYTE#16#07;
	            //10 - BI: 1st acknowledge faults
	            #sa_Parameter[10].siParaNo := 2103;
	            #sa_Parameter[10].siIndex := 1;
	            #sa_Parameter[10].syFormat := BYTE#16#07;
	            //11 - BI: 2nd acknowledge faults
	            #sa_Parameter[11].siParaNo := 2104;
	            #sa_Parameter[11].syFormat := BYTE#16#07;
	            //12 - BI: Command data set selection CDS bit 0
	            #sa_Parameter[12].siParaNo := 810;
	            #sa_Parameter[12].syFormat := BYTE#16#07;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 20
	        
	        IF #si_StepNr = 20 AND #sx_SelectedG120D THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 1;
	            
	            //Used parameters in this step 
	            //1 - Power unit code number
	            #sa_Parameter[1].siParaNo := 201;
	            #sa_Parameter[1].srValue := #iUDT_MotorConfig.VFDType;
	            #sa_Parameter[1].syFormat := BYTE#16#06;
	            
	        END_IF;
	        
	        IF #si_StepNr = 20 AND #sx_SelectedG120C THEN
	            
	            #si_StepNr := 24;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 21
	        
	        IF #si_StepNr = 21 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 1;
	            
	            //Used parameters in this step 
	            //1 - Drive commissioning parameter filter
	            #sa_Parameter[1].siParaNo := 10;
	            #sa_Parameter[1].srValue := 4.0;         //4: Encoder commissioning
	            #sa_Parameter[1].syFormat := BYTE#16#03;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 22
	        
	        IF #si_StepNr = 22 AND NOT #iUDT_MotorConfig.EncoderConfig THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 1;
	            
	            //Used parameters in this step 
	            //1 - Encoder type selection
	            #sa_Parameter[1].siParaNo := 400;
	            #sa_Parameter[1].syFormat := BYTE#16#03;
	            
	        END_IF;
	        
	        IF #si_StepNr = 22 AND #iUDT_MotorConfig.EncoderConfig THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 4;
	            
	            //Used parameters in this step 
	            //1-  Encoder type selection
	            #sa_Parameter[1].siParaNo := 400;
	            #sa_Parameter[1].srValue := 9999.0;         //9999: User-defined
	            #sa_Parameter[1].syFormat := BYTE#16#03;
	            //2 - Rotary encoder pulse number
	            #sa_Parameter[2].siParaNo := 408;
	            #sa_Parameter[2].sdValue := REAL_TO_DINT(#iUDT_MotorConfig.EncoderResolution);
	            #sa_Parameter[2].syFormat := BYTE#16#07;
	            //3 - Encoder rotary zero mark distance
	            #sa_Parameter[3].siParaNo := 425;
	            #sa_Parameter[3].sdValue := REAL_TO_DINT(#iUDT_MotorConfig.EncoderResolution);
	            #sa_Parameter[3].syFormat := BYTE#16#07;
	            //4 - Encoder configuration effective
	            #sa_Parameter[4].siParaNo := 404;
	            #sa_Parameter[4].sdValue := 2097160;
	            #sa_Parameter[4].syFormat := BYTE#16#07;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 23
	        
	        IF #si_StepNr = 23 AND #sx_SelectedG120D THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 2;
	            
	            //Used parameters in this step
	            //1 - Open-loop/closed-loop control operating mode 
	            IF #iUDT_MotorConfig.EncoderConfig THEN
	                #sa_Parameter[1].siParaNo := 1300;
	                #sa_Parameter[1].srValue := 21.0;           //21: Speed control (with encoder)
	                #sa_Parameter[1].syFormat := BYTE#16#03;
	                
	            ELSE
	                //1 - Open-loop/closed-loop control operating mode
	                #sa_Parameter[1].siParaNo := 1300;
	                #sa_Parameter[1].srValue := 20.0;           //20 - Speed control (encoderless)
	                #sa_Parameter[1].syFormat := BYTE#16#03;
	                
	            END_IF;
	            
	            //2 - Drive commissioning parameter filter 
	            #sa_Parameter[2].siParaNo := 10;
	            #sa_Parameter[2].srValue := 1.0;                //1: Quick commissioning
	            #sa_Parameter[2].syFormat := BYTE#16#03;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 24
	        
	        IF #si_StepNr = 24 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 1;
	            
	            //Used parameters in this step 
	            //1 - Save parameters
	            #sa_Parameter[1].siParaNo := 971;
	            #sa_Parameter[1].srValue := 1.0;
	            #sa_Parameter[1].syFormat := BYTE#16#06;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 25
	        
	        IF #si_StepNr = 25 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.ParaNo := 1;
	            
	            //Used parameters in this step 
	            //1 - Save parameters
	            #sa_Parameter[1].siParaNo := 971;
	            #sa_Parameter[1].syFormat := BYTE#16#06;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 26
	        
	        IF #si_StepNr = 26 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 1;
	            
	            //Used parameters in this step 
	            //1 - Drive commissioning parameter filter
	            #sa_Parameter[1].siParaNo := 10;
	            #sa_Parameter[1].syFormat := BYTE#16#03;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 27
	        
	        IF #si_StepNr = 27 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 1;
	            
	            //Used parameters in this step 
	            //1 - Drive commissioning parameter filter
	            #sa_Parameter[1].siParaNo := 10;
	            #sa_Parameter[1].srValue := 95.0;           //95 - Safety Integrated commissioning
	            #sa_Parameter[1].syFormat := BYTE#16#03;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 28
	        
	        IF #si_StepNr = 28 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 3;
	            
	            //Used parameters in this step 
	            //1 - SI password input 
	            #sa_Parameter[1].siParaNo := 9761;
	            #sa_Parameter[1].syFormat := BYTE#16#07;
	            //2 - SI password new
	            #sa_Parameter[2].siParaNo := 9762;
	            #sa_Parameter[2].syFormat := BYTE#16#07;
	            //3 - SI password acknowledgment
	            #sa_Parameter[3].siParaNo := 9763;
	            #sa_Parameter[3].syFormat := BYTE#16#07;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 29
	        
	        IF #si_StepNr = 29 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 1;
	            
	            //Used parameters in this step 
	            //1 - SI password input 
	            #sa_Parameter[1].siParaNo := 9761;
	            #sa_Parameter[1].syFormat := BYTE#16#07;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 30
	        
	        IF #si_StepNr = 30 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 4;
	            
	            //Used parameters in this step 1
	            //1 - SI enable functions integrated in the drive
	            #sa_Parameter[1].siParaNo := 9601;
	            #sa_Parameter[1].sdValue := 8;
	            #sa_Parameter[1].syFormat := BYTE#16#07;
	            //2 - SI PROFIsafe address
	            #sa_Parameter[2].siParaNo := 9610;
	            #sa_Parameter[2].srValue := #iUDT_MotorConfig.FAdress;
	            #sa_Parameter[2].syFormat := BYTE#16#06;
	            //3 - PROFIsafe telegram selection 
	            #sa_Parameter[3].siParaNo := 60022;
	            #sa_Parameter[3].srValue := 30.0;
	            #sa_Parameter[3].syFormat := BYTE#16#06;
	            //4 - SI forced checking procedure timer
	            #sa_Parameter[4].siParaNo := 9659;
	            #sa_Parameter[4].srValue := 9000.0;
	            #sa_Parameter[4].syFormat := BYTE#16#08;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 31
	        
	        IF #si_StepNr = 31 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 1;
	            
	            //Used parameters in this step 
	            //1 - SI Motion copy function
	            #sa_Parameter[1].siParaNo := 9700;
	            #sa_Parameter[1].srValue := 208.0;
	            #sa_Parameter[1].syFormat := BYTE#16#03;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 32
	        
	        IF #si_StepNr = 32 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.ParaNo := 1;
	            
	            //Used parameters in this step 
	            //1 - SI Motion copy function
	            #sa_Parameter[1].siParaNo := 9700;
	            #sa_Parameter[1].syFormat := BYTE#16#03;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 33
	        
	        IF #si_StepNr = 33 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.ParaNo := 2;
	            
	            //Used parameters in this step 
	            //1 - SI enable functions integrated in the drive
	            #sa_Parameter[1].siParaNo := 9801;
	            #sa_Parameter[1].srValue := 8.0;
	            #sa_Parameter[1].syFormat := BYTE#16#06;
	            //2 - Safety adress
	            #sa_Parameter[2].siParaNo := 9810;
	            #sa_Parameter[2].srValue := #iUDT_MotorConfig.FAdress;
	            #sa_Parameter[2].syFormat := BYTE#16#06;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 34
	        
	        IF #si_StepNr = 34 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 1;
	            
	            //Used parameters in this step 
	            //1 - Acknowledge SI data change
	            #sa_Parameter[1].siParaNo := 9701;
	            #sa_Parameter[1].srValue := 220.0;          //220: [DC hex] Acknowledge SI basic parameter change
	            #sa_Parameter[1].syFormat := BYTE#16#03;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 35
	        
	        IF #si_StepNr = 35 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.ParaNo := 1;
	            
	            //Used parameters in this step 
	            //1 - Acknowledge SI data change
	            #sa_Parameter[1].siParaNo := 9701;
	            #sa_Parameter[1].syFormat := BYTE#16#03;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 36
	        
	        IF #si_StepNr = 36 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 1;
	            
	            //Used parameters in this step 
	            //1 - SI copy function
	            #sa_Parameter[1].siParaNo := 9700;
	            #sa_Parameter[1].srValue := 87.0;           //87: [57 hex] Start copy function SI parameters
	            #sa_Parameter[1].syFormat := BYTE#16#03;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 37
	        
	        IF #si_StepNr = 37 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.ParaNo := 1;
	            
	            //Used parameters in this step 
	            //1 - SI copy function
	            #sa_Parameter[1].siParaNo := 9700;
	            #sa_Parameter[1].syFormat := BYTE#16#03;
	            
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 38
	        
	        IF #si_StepNr = 38 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 1;
	            
	            //Used parameters in this step 
	            //1 - Acknowledge SI data change
	            #sa_Parameter[1].siParaNo := 9701;
	            #sa_Parameter[1].srValue := 220.0;          //220: [DC hex] Acknowledge SI basic parameter change
	            #sa_Parameter[1].syFormat := BYTE#16#03;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 39
	        
	        IF #si_StepNr = 39 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.ParaNo := 1;
	            
	            //Used parameters in this step 
	            //1 - Acknowledge SI data change
	            #sa_Parameter[1].siParaNo := 9701;
	            #sa_Parameter[1].syFormat := BYTE#16#03;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 40
	        
	        IF #si_StepNr = 40 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 1;
	            
	            //1 - Drive commissioning parameter filter
	            #sa_Parameter[1].siParaNo := 10;
	            #sa_Parameter[1].syFormat := 3;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 41
	        
	        IF #si_StepNr = 41 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 1;
	            
	            //Used parameters in this step 
	            //1 - Save parameters
	            #sa_Parameter[1].siParaNo := 971;
	            #sa_Parameter[1].srValue := 1.0;            //1: Save drive object
	            #sa_Parameter[1].syFormat := BYTE#16#06;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 42
	        
	        IF #si_StepNr = 42 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.ParaNo := 2;
	            
	            //Used parameters in this step 
	            //1 - Reset drive parameters
	            #sa_Parameter[1].siParaNo := 970;
	            #sa_Parameter[1].syFormat := BYTE#16#06;
	            //2 - Parameter write inhibit status
	            #sa_Parameter[2].siParaNo := 3996;
	            #sa_Parameter[2].syFormat := BYTE#16#05;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 43
	        
	        IF #si_StepNr = 43 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 1;
	            
	            //Used parameters in this step 
	            //1 - Drive unit reset
	            #sa_Parameter[1].siParaNo := 972;
	            #sa_Parameter[1].srValue := 1.0;            //1: Hardware-Reset immediate
	            #sa_Parameter[1].syFormat := 16#0006;
	            #sa_Parameter[1].swErrorNo := 0;
	            
	            #sa_Status.NeedAck := TRUE;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 44
	        
	        IF #si_StepNr = 44 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.ParaNo := 1;
	            
	            //Used parameters in this step 
	            //1 - Drive commissioning parameter filter
	            #sa_Parameter[1].siParaNo := 10;
	            #sa_Parameter[1].syFormat := 16#0003;
	            #sa_Parameter[1].swErrorNo := 0;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 45
	        
	        IF #si_StepNr = 45 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 1;
	            
	            //Used parameters in this step 
	            //1 - Drive commissioning parameter filter
	            #sa_Parameter[1].siParaNo := 10;
	            #sa_Parameter[1].syFormat := BYTE#16#03;
	            #sa_Parameter[1].swErrorNo := 0;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 46
	        
	        IF #si_StepNr = 46 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 2;
	            
	            //Used parameters in this step 
	            //1 - Temperature sensor, sensor type
	            #sa_Parameter[1].siParaNo := 601;
	            #sa_Parameter[1].srValue := #iUDT_MotorConfig.ThermalConfig;
	            #sa_Parameter[1].syFormat := BYTE#16#03;
	            
	            //2 - Motor holding brake configuration
	            #sa_Parameter[2].siParaNo := 1215;
	            #sa_Parameter[2].srValue := 0;
	            #sa_Parameter[2].syFormat := BYTE#16#03;
	            
	            IF #iUDT_MotorConfig.BrakeConfig THEN
	                
	                IF #sx_SelectedG120C THEN
	                    
	                    #sa_Parameter[2].srValue := 3;
	                    
	                END_IF;
	                
	                IF #sx_SelectedG120D THEN
	                    
	                    #sa_Parameter[2].srValue := 1;
	                    
	                END_IF;
	                
	            END_IF;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 47
	        
	        IF #si_StepNr = 47 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 1;
	            
	            //Used parameters in this step 
	            //1 - Motor data identification and rotating measurement
	            #sa_Parameter[1].siParaNo := 1900;
	            #sa_Parameter[1].srValue := 2.0;            //2: Identifying motor data (at standstill)
	            #sa_Parameter[1].syFormat := BYTE#16#03;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 48
	        
	        IF #si_StepNr = 48 AND #sx_SelectedG120D THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.ParaNo := 2;
	            
	            //Used parameters in this step 
	            //1 - Identification status 
	            #sa_Parameter[1].siParaNo := 47;
	            #sa_Parameter[1].syFormat := BYTE#16#03;
	            //2 - Motor data identification and rotating measurement
	            #sa_Parameter[2].siParaNo := 1900;
	            #sa_Parameter[2].syFormat := BYTE#16#03;
	            
	            #sx_StartMeasuring := TRUE;
	            
	        END_IF;
	        
	        IF #si_StepNr = 48 AND #sx_SelectedG120C THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.ParaNo := 2;
	            
	            //1 - Used parameters in this step 
	            //Identification status 
	            #sa_Parameter[1].siParaNo := 47;
	            #sa_Parameter[1].syFormat := BYTE#16#03;
	            //2 - Motor data identification and rotating measurement
	            #sa_Parameter[2].siParaNo := 1900;
	            #sa_Parameter[2].syFormat := BYTE#16#03;
	            //3 - Status word 1
	            #sa_Parameter[3].siParaNo := 52;
	            #sa_Parameter[3].srValue := 60272.0;
	            #sa_Parameter[3].syFormat := BYTE#16#06;
	            
	            #sx_StartMeasuring := TRUE;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 49
	        
	        IF #si_StepNr = 49 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.ParaNo := 1;
	            
	            //Used parameters in this step 
	            //1 - Save parameters
	            #sa_Parameter[1].siParaNo := 971;
	            #sa_Parameter[1].srValue := 1.0;            //1: Save drive object
	            #sa_Parameter[1].syFormat := BYTE#16#06;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 50
	        
	        IF #si_StepNr = 50 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.ParaNo := 1;
	            
	            //Used parameters in this step 
	            //1 - Save parameters
	            #sa_Parameter[1].siParaNo := 971;
	            #sa_Parameter[1].syFormat := BYTE#16#06;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 51
	        
	        IF #si_StepNr = 51 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.ParaNo := 1;
	            
	            //Used parameters in this step 
	            //1 - Memory card status
	            #sa_Parameter[1].siParaNo := 9400;
	            #sa_Parameter[1].syFormat := BYTE#16#03;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 52
	        
	        IF #si_StepNr = 52 THEN
	            
	            
	            IF #sa_Status.MemoryCardInserted THEN
	                
	                //Step configuration 
	                #sa_Stepconfig.Write := TRUE;
	                #sa_Stepconfig.ParaNo := 1;
	                
	                //Used parameters in this step 
	                //1 - Data transfer start
	                #sa_Parameter[1].siParaNo := 804;
	                #sa_Parameter[1].srValue := 2.0;            //2:start data transfer from device memory to memory card
	                #sa_Parameter[1].syFormat := BYTE#16#03;
	                
	            ELSE
	                
	                #si_StepNr := 54;
	                
	            END_IF;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 53
	        
	        IF #si_StepNr = 53 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.ParaNo := 1;
	            
	            //Used parameters in this step 
	            //1 - Data transfer start
	            #sa_Parameter[1].siParaNo := 804;
	            #sa_Parameter[1].srValue := 0.0;
	            #sa_Parameter[1].syFormat := BYTE#16#03;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION Step 54
	        
	        IF #si_StepNr = 54 THEN
	            
	            //Step configuration 
	            #sa_Stepconfig.Read := TRUE;
	            #sa_Stepconfig.Write := TRUE;
	            #sa_Stepconfig.ParaNo := 1;
	            
	            //Used parameters in this step 
	            //1 - Drive commissioning parameter filter
	            #sa_Parameter[1].siParaNo := 10;
	            #sa_Parameter[1].syFormat := BYTE#16#03;
	            
	            #sx_Done := TRUE;
	            #sx_Busy := FALSE;
	            #sx_StartMeasuring := FALSE;
	            
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 5 - Prepered data   
	    
	    //This region is responsible for preparing data for each step. Copying data from the sequence and activating the write / read mode or both.
	    IF (#sx_Start AND                   // If occurs: signal to start of parametrization 
	        NOT #sx_PreparedData AND        // And step data is not prepared 
	        NOT #sx_Done AND                // And parametrization is not done 
	        #ix_Enable)                     // And input enable signal 
	    THEN
	        
	        REGION 5.1 - Parametrization mode - only read
	            
	            //Set READ mode
	            IF (#sa_Stepconfig.Read
	                AND NOT #sa_Stepconfig.Write)
	            THEN
	                
	                #sx_OnlyRead := TRUE;
	                #sx_OnlyWrite := FALSE;
	                #sx_WriteRead := FALSE;
	                #sx_SinaParaStart := TRUE;
	                #sx_SinaParaReadWrite := FALSE;
	                
	            END_IF;
	            
	        END_REGION
	        
	        REGION 5.2 - Parametrization mode - only write
	            
	            //Set WRITE mode
	            IF (NOT #sa_Stepconfig.Read
	                AND #sa_Stepconfig.Write)
	            THEN
	                
	                #sx_OnlyRead := FALSE;
	                #sx_OnlyWrite := TRUE;
	                #sx_WriteRead := FALSE;
	                #sx_SinaParaStart := TRUE;
	                #sx_SinaParaReadWrite := TRUE;
	                
	            END_IF;
	            
	        END_REGION
	        
	        REGION 5.3 - Parametrization mode - write and read
	            
	            //Set READ/WRITE mode
	            IF (#sa_Stepconfig.Read
	                AND #sa_Stepconfig.Write)
	            THEN
	                
	                #sx_OnlyRead := FALSE;
	                #sx_OnlyWrite := FALSE;
	                #sx_WriteRead := TRUE;
	                #sx_SinaParaStart := TRUE;
	                #sx_SinaParaReadWrite := TRUE;
	                
	            END_IF;
	            
	        END_REGION
	        
	        #si_SinaParaParaNo := #sa_Stepconfig.ParaNo;          // Copy number of parameters from step commissionig to static number of parameters
	        #sa_ParameterToCompare := #sa_Parameter;               // Copy parameters
	        #sx_PreparedData := TRUE;                              // Set step data prepared 
	        
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Call read/write parameter block - SinaPara
	    
	    // Sina Para is responsible for write and reads parameters from VFD 
	    #sFB_SinaParaInstance(Start := #sx_SinaParaStart
	                          AND #sx_Start
	                          AND #ix_Enable,
	                          ReadWrite := #sx_SinaParaReadWrite,
	                          ParaNo := #si_SinaParaParaNo,
	                          AxisNo := #cb_SinaParamAxisNo,
	                          hardwareId := #ihw_SinaParamHardwareId,
	                          Ready => #sx_SinaParaReady,
	                          Busy => #sx_SinaParaBusy,
	                          Done => #sx_SinaParaDone,
	                          Error => #sa_SinaPara.Error,
	                          ErrorId => #sa_SinaPara.ErrorId,
	                          DiagId => #sa_SinaPara.DiagId,
	                          Parameter := #sa_Parameter);
	    
	END_REGION
	
	REGION 7 - Compare read parameters with basic parameters
	    
	    // When the comparison parameters have incorrect value or format, function SinaPara reads again parameters 
	    IF (#sx_ResponseValueError OR
	        #sx_WrongFormat)
	    THEN
	        
	        #sx_SinaParaStart := TRUE;
	        #sx_SinaParaDone := FALSE;
	        #sx_ResponseValueError := FALSE;
	        #sx_WrongFormat := FALSE;
	        
	    END_IF;
	    
	    // After read correctly data with SinaPara are compered with the parameter from this step. 
	    IF (#sx_SinaParaStart AND                                                                                                                           // If SinaPara start signal is on
	        NOT #sx_SinaParaReadWrite AND                                                                                                                   // And SinaPara is read parameters
	        #sx_SinaParaDone AND                                                                                                                            // And SinaPara function is done is on 
	        NOT #sa_SinaPara.Error AND                                                                                                                      // And SinaPara function error signal is off
	        #ix_Enable)                                                                                                                                     // And input enable signal
	    THEN
	        
	        // Create loop from 1 parameter to number of parameters
	        FOR #si_Loop := 1 TO #si_SinaParaParaNo DO
	            
	            // If parameter value from data of parameters are different than parameter value from step commissioning 
	            IF
	                #sa_Parameter[#si_Loop].srValue <> #sa_ParameterToCompare[#si_Loop].srValue OR
	                #sa_Parameter[#si_Loop].sdValue <> #sa_ParameterToCompare[#si_Loop].sdValue
	            THEN
	                
	                #sx_ResponseValueError := TRUE;
	                #si_ParameterNrError := #si_Loop;
	                #si_StepNrError := #si_StepNr;
	                
	            ELSE
	                
	                #sx_ResponseValueError := False;
	                
	            END_IF;
	            
	            // If parameter format is equal 44 set wrong format fault 
	            IF #sa_Parameter[#si_Loop].syFormat = 44
	            THEN
	                
	                #sx_WrongFormat := TRUE;
	                #si_ParameterNrError := #si_Loop;
	                #si_StepNrError := #si_StepNr;
	                
	            ELSE
	                
	                #sx_WrongFormat := False;
	                
	            END_IF;
	            
	        END_FOR;
	        
	        // Check if error occurs if isn't then read parameter are the same like step parameters. Else the SinaPara read parameters again.
	        IF (NOT #sx_ResponseValueError AND
	            NOT #sx_WrongFormat) OR
	            #si_StepNr = 51
	        THEN
	            
	            #sx_ComparisonParameters := TRUE;
	            
	        ELSE
	            
	            #sx_SinaParaStart := FALSE;
	            
	        END_IF;
	        
	    END_IF;
	    
	    REGION 7.1 - Check if SD is inside
	        
	        IF (#si_StepNr = 51 AND #sa_Parameter[1].srValue = 1) THEN
	            
	            #sa_Status.MemoryCardInserted := TRUE;
	            
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 8 - Status commissioning 
	    
	    REGION 8.1 - Step number Error 
	        
	        IF (#sx_SinaParaStart AND                                                                   // Parametrization is start 
	            #sa_SinaPara.Error AND                                                                  // Occurs error bit
	            (NOT #sa_Status.NeedAck) AND                                                            // This step does not need to be confirmed
	            (NOT #sx_SinaParaReadWrite OR                                                           // Parameters are not write
	            (#sx_SinaParaReadWrite AND                                                              // Parameters are read 
	            #sx_ReadTime)))                                                                         // Read time signal is on 
	        THEN
	            
	            #sa_Status.StepNrError := #si_StepNr;
	            #sx_Start := FALSE;
	            #sx_Error := TRUE;
	            #sx_Done := FALSE;
	            #sx_StartMeasuring := FALSE;
	            
	        END_IF;
	        
	        IF #sa_Status.NeedAck AND                                                       // This step must be confirmed
	            #sa_SinaPara.Error                                                          // Occurs error bit
	            
	        THEN
	            
	            #sx_SinaParaStart := FALSE;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 8.2 - Read Done
	        
	        // The parameters are read form VFD
	        IF (#sx_SinaParaStart                       // Parametrization is start
	            AND #sx_SinaParaDone                    // Parametrization is done
	            AND NOT #sx_SinaParaReadWrite AND       // Parameters are not read/write
	            (#sx_OnlyRead OR #sx_WriteRead) AND     // Is selected only read mode or is selected wite/read mode
	            #sx_ComparisonParameters AND            // Comparison parameters are correct
	            #ix_Enable)
	        THEN
	            
	            #sx_ReadDone := TRUE;                   // Set read done
	            #sx_SinaParaStart := FALSE;             // Stop parametrization
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 8.3 - Write Done 
	        
	        // The parameters are write to VFD
	        IF (#sx_SinaParaStart                             // Parametrization is start
	            AND #sx_SinaParaDone                          // Parametrization is done
	            AND #sx_SinaParaReadWrite                     // Parameters are write signal is on 
	            AND (#sx_OnlyWrite OR #sx_WriteRead)          // Is selected only write mode or is selected wite/read mode
	            AND #ix_Enable)
	        THEN
	            
	            #sx_WriteDone := TRUE;
	            #sx_SinaParaStart := FALSE;
	            #sx_SinaParaReadWrite := FALSE;
	            #sx_SinaParaDone := FALSE;
	            #sx_StartDelayTime := TRUE;
	            
	        END_IF;
	        
	        // Write parameters in VFD need 1 sec to read
	        IF #sx_StartDelayTime
	        THEN
	            
	            // Monitor rising trigger if occur system clock bit 1Hz
	            #sR_TRIG_DelayTime(CLK := "DB_Memory"."Clock_0.5Hz");
	            
	            // If trigger for time couting occurs then increase step time by 1 [s]
	            IF #sR_TRIG_DelayTime.Q
	            THEN
	                
	                #si_DelayTime += 1;
	                
	            END_IF;
	            
	            // If the deley time is bigger as 2 
	            IF #si_DelayTime >= 2
	            THEN
	                
	                #si_DelayTime := 0;
	                #sx_StartDelayTime := FALSE;
	                #sx_SinaParaStart := TRUE;
	                
	            END_IF;
	            
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 9 - Read Data 
	    
	    // Parameter are raed in the loop. At this time the parameters are comparable to those of the step. If they disagree an error occurs
	    IF (((#sx_WriteRead AND #sx_WriteDone)                                         // Write/read mode is selected and write is done
	        OR #sx_OnlyRead)                                                           // Only read mode is selected 
	        AND #sx_PreparedData                                                       // Data are prepared   
	        AND NOT #sx_Error                                                          // Not error occurs
	        AND NOT #sa_Status.TimeExceeded                                            // Not time step exceeded
	        AND NOT #sx_ReadDone                                                       // Read is not done
	        AND #ix_Enable)                                                            // Input enable signal 
	    THEN
	        
	        // Monitor rising trigger if occur system clock bit 1Hz
	        #sR_TRIG_Time(CLK := "DB_Memory".Clock_1Hz);
	        
	        // Increase step time by 1 [s]
	        IF #sR_TRIG_Time.Q                                                            // If trigger for time couting occurs
	        THEN
	            
	            #si_StepTime += 1;
	            
	        END_IF;
	        
	        // If step time is greater than or equal to
	        IF #si_StepTime >= #ci_StepTime
	        THEN
	            
	            #sx_ReadTime := FALSE;
	            
	            
	            IF NOT #sx_ReadDone THEN
	                
	                #sx_Error := TRUE;
	                #sa_Status.TimeExceeded := true;
	                #sa_Status.ResponseValueError := #sx_ResponseValueError;
	                #sa_Status.WrongFormat := #sx_WrongFormat;
	                #sa_Status.StepNrError := #si_StepNrError;
	                #sa_Status.ParameterNrError := #si_ParameterNrError;
	                
	            END_IF;
	            
	        ELSE
	            
	            #sx_ReadTime := TRUE;           // Reset read time 
	            
	        END_IF;
	        
	    ELSE
	        
	        #si_StepTime := 0;          // Set step time to 0
	        
	    END_IF;
	    
	END_REGION
	
	REGION 10 - Freecycle
	    
	    //SinaPara block needs a positive edge to start working 
	    IF #sa_Status.StepDone      // If step is done 
	        AND #ix_Enable         // Enagle signal is active 
	    THEN
	        
	        #sx_Freecycle := TRUE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 11 - Step Done 
	    
	    // When the step modes are fulfilled, the step done signal is active
	    IF (#sx_ReadDone                          // Read is done 
	        AND #sx_WriteDone                     // Write is done 
	        AND #sx_WriteRead                     // Write/Read mode is selected 
	        AND #sx_ComparisonParameters)         // Comparison read data is done
	        
	        OR (NOT #sx_ReadDone                  // Read isn't done
	        AND #sx_WriteDone                     // Write is done
	        AND #sx_OnlyWrite)                    // Write mode is selected
	        
	        OR (#sx_ReadDone                      // Read is done
	        AND NOT #sx_WriteDone                 // Write isn't done
	        AND #sx_OnlyRead                      // Read mode is selected
	        AND #sx_ComparisonParameters)         // Comparison read data is done
	        AND #ix_Enable                        // Enable signal is active 
	    THEN
	        
	        #sa_Status.StepDone := TRUE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 12 - Go to next step 
	    
	    // When all conditions are met the functions go to the next step automatically or is active signal wich every steps must be acknowledged
	    IF (((#sx_ActiveButtonGoToNextStep                                            // Activeted button to go for the next step
	        AND #iqx_GoToNextStep)                                                    // Signal go to next step is occurs
	        OR NOT #sx_ActiveButtonGoToNextStep)                                      // Signal go to next step is not occurs
	        AND ((#sa_Status.NeedAck                                                  // Need acknowledge
	        AND #iqx_GoToNextStep)                                                    // Activeted button to go for the next step
	        OR NOT #sa_Status.NeedAck)                                                // Need acknowledge is not occurs
	        AND ((NOT #sx_Error                                                       // Is no error
	        AND #sa_Status.StepDone                                                   // Step is done
	        AND #sx_Freecycle)                                                        // Empty cycle
	        OR #sa_Status.NeedAck)                                                    // This step must be confirmed
	        AND #ix_Enable)                                                           // Input enable signal
	        
	    THEN
	        
	        #sx_PreparedData := FALSE;
	        #sx_ReadDone := FALSE;
	        #sx_WriteDone := FALSE;
	        #sx_SinaParaStart := FALSE;
	        #sx_Freecycle := FALSE;
	        #sx_StartMeasuring := FALSE;
	        #sx_ComparisonParameters := FALSE;
	        #iqx_GoToNextStep := FALSE;
	        #sa_Status.NeedAck := FALSE;
	        #sa_Status.StepDone := FALSE;
	        #si_StepNr += 1;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 13 - Write output
	    
	    #sa_Status.StepNr := #si_StepNr;
	    #qx_Busy := #sx_Busy;
	    #qx_Done := #sx_Done;
	    #qx_Error := #sx_Error;
	    #qx_StartMeasuring := #sx_StartMeasuring;
	    
	END_REGION
END_FUNCTION_BLOCK

TYPE "UDT_VfdSEWSpeedPI"
TITLE = UDT_VFD_SEW_PI
VERSION : 0.1
//User-defined structure of VFD SEW input telegram.
   STRUCT
      Status_Word_1 : Struct   // Status Word 1
         Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // An error is active "1"
         Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // A warning is active "1"
         DriveTrain2Active { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Drive train 2 is active "1"
         VelocityTargetActualComparison { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The notification "Velocity target-actual-comparison" is on "1"
         SW_LimitSwitchInactive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // he software limit switch is inactive "1"
         BIT_13_Reserved { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         StandbyActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Standby mode is active "1"
         MovikitHandshakeOut { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Copied value of "MovikitHandshakeIn"
         InverterReady { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // There's no error and the inverter is ready "1"
         STO_Inactive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // STO is not active "1"
         OutputStageEnabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The output stage is released "1"
         BrakeReleased { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The brake is released "1"
         DriveActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The drive is active and the shaft turning "1"
         Referenced { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The drive is referenced "1"
         RelativePositionApplied { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The relative position is applied "1"
         InPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The notification "in position" is on "1"
      END_STRUCT;
      ActualSpeed : Int;   // Actual drive speed (Int) in rpm
      StatusErrorNo : Word;   // Current status of the drive
      ActualTorque : Int;   // Actual torque in percent od the rated unit torque
   END_STRUCT;

END_TYPE

TYPE "UDT_VfdSEWSpeedPO"
TITLE = UDT_VFD_SEW_PO
VERSION : 0.1
//User-defined structure of VFD SEW output telegram.
   STRUCT
      Control_Word_1 : Struct   // Control Word 1
         ResetError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset error "1"
         BIT_09_Reserved { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         ActivateDriveTrain2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate drive train 2 "1"
         BIT_11_Reserved { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         DeactivateSW_LimitSwitch { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Deactivate software limit switch "1"
         ActivateInhibit { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate inhibit "1"
         ActivateStandby { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate standby "1"
         MovikitHandshakeIn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // If the MOVIKIT works the value will be copied into "MovikitHandshakeOut"
         EnableRapidStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Enable “1” / Rapid stop “0”
         EnableApplicationStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Enable “1” / Application stop “0”
         BIT_02_Reserved { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         ReleaseBrake { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Release brake "1"
         JogPos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Jog in positive direction "1"
         JogNeg { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Jog in negative direction "1"
         ApplyRelativePositioning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Take the relative position from the FCB09 "1"
         StartStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start "1" / Stop "0"
      END_STRUCT;
      SetpointSpeed : Int;   // Speed (Int) in rpm
      SetpointAcceleration : Int;   // Acceleration (Int) in rpm/s
      SetpointDeceleration : Int;   // Decceleration (Int) in rpm/s
   END_STRUCT;

END_TYPE

TYPE "UDT_VfdPositioningConfiguration"
TITLE = UDT_VfdPositioningConfiguration
VERSION : 0.1
//User defined stucture for configuring positioning device
   STRUCT
      TorqueMax : Real;   // VFD torque max - reference [Nm] as set up in SEW project
      SupplyFdbckOnDelayTime : UDInt;   // On delay time for supply feedback [ms]
      PositionWindow : DInt;   // Position window (tolerance) [mm]
      PositionMax : DInt;   // Maximum allowed position [mm]
      PositionMin : DInt;   // Minimum allowed position [mm]
      VFDSpeed : Int;   // Speed to run in automatic mode [mm/s]
      VFDAccDecel : Int;   // Acceleration and deceleration [mm/s2]
      VFDPNDeviceName : String;   // VFD's device name
      Position : Array[0..10] of DInt;   // Positions in mm to move to as requested
   END_STRUCT;

END_TYPE

TYPE "UDT_VfdSEWPositioningPI"
TITLE = UDT_VfdSEWPositioningPI
VERSION : 0.1
//User-defined structure of VFD SEW input telegram.
   STRUCT
      Status_Word_1 : Struct   // Status Word 1
         Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // An error is active "1"
         Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // A warning is active "1"
         DriveTrain2Active { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Drive train 2 is active "1"
         VelocityTargetActualComparison { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The notification "Velocity target-actual-comparison" is on "1"
         SW_LimitSwitchInactive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // he software limit switch is inactive "1"
         BIT_13_Reserved { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         StandbyActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Standby mode is active "1"
         MovikitHandshakeOut { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Copied value of "MovikitHandshakeIn"
         InverterReady { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // There's no error and the inverter is ready "1"
         STO_Inactive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // STO is not active "1"
         OutputStageEnabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The output stage is released "1"
         BrakeReleased { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The brake is released "1"
         DriveActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The drive is active and the shaft turning "1"
         Referenced { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The drive is referenced "1"
         RelativePositionApplied { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The relative position is applied "1"
         InPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The notification "in position" is on "1"
      END_STRUCT;
      ActualSpeed : Int;   // Actual drive speed (Int) [mm/s]
      StatusErrorNo : Word;   // Current status of the drive
      ActualTorque : Int;   // Actual torque in percent od the rated unit torque
      DigitalInput : Word;   // Digital inputs
      Mode : Int;   // Actual application mode (Int)
      ActualPosition_hW : Word;   // Actual position - High Word
      ActualPosition_lW : Word;   // Actual position - Low Word
   END_STRUCT;

END_TYPE

TYPE "UDT_ConveyorConfiguration"
TITLE = UDT_ConveyorConfiguration
VERSION : 0.1
//User-defined structure of conveyor parameters.
   STRUCT
      Common : "UDT_ConveyorCommonConfiguration";   // Common configuration
      Forward_Direction : Struct   // Forward Direction configuration
         EnergySaveLenght : DInt;   // Distance conveyor travelled before energy save activate [cm]
         GapHeadToHead : DInt;   // Gapping head to head value [cm]
         GapTailToHead : DInt;   // Gapping tail to head value [cm]
         GapCorrection : DInt;   // Gap offset to cover VFD's ramps [cm]
         PEC_EoSDistanceOffset : DInt;   // Distance offset between photo eye and the end of conveyor [mm]
         Mode : Int;   // Automatic operation; 1- Slave; 2- Queue;
         FirstConveyorToStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // First conveyor to start cascade mode forward direction
      END_STRUCT;
      Reverse_Direction : Struct   // Reverse Direction configuration
         EnergySaveLenght : DInt;   // Distance conveyor travelled before energy save activate [cm]
         GapHeadToHead : DInt;   // Gapping head to head value [cm]
         GapTailToHead : DInt;   // Gapping tail to head value [cm]
         GapCorrection : DInt;   // Gap offset to cover VFD's ramps [cm]
         PEC_BoSDistanceOffset : DInt;   // Distance offset between photo eye and the end of conveyor [mm]
         Mode : Int;   // Automatic operation; 1- Slave; 2- Queue;
         FirstConveyorToStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // First conveyor to start cascade mode reverse direction
      END_STRUCT;
      CascadeTimeOnDelay : UDInt;   // Cascade time on delay [ms]
      ExtraGapRecovery : DInt;   // Extra gap to recovery die back [cm]
      SpeedSetpointLow : Int;   // Low speed setpoint [mm/s]
      SpeedSetpointNominal : Int;   // Nominal speed setpoint [mm/s]
      Energy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Energy save mode enable
      Bi_Directional_Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The conveyor can run in both directions
   END_STRUCT;

END_TYPE

TYPE "UDT_VfdSEWPositioningPO"
TITLE = UDT_VFD_SEW_PO
VERSION : 0.1
//User-defined structure of VFD SEW output telegram.
   STRUCT
      Control_Word_1 : Struct   // Control Word 1
         ResetError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset error "1"
         BIT_09_Reserved { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         ActivateDriveTrain2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate drive train 2 "1"
         BIT_11_Reserved { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         DeactivateSW_LimitSwitch { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Deactivate software limit switch "1"
         ActivateInhibit { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate inhibit "1"
         ActivateStandby { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate standby "1"
         MovikitHandshakeIn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // If the MOVIKIT works the value will be copied into "MovikitHandshakeOut"
         EnableRapidStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Enable “1” / Rapid stop “0”
         EnableApplicationStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Enable “1” / Application stop “0”
         BIT_02_Reserved { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         ReleaseBrake { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Release brake "1"
         JogPos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Jog in positive direction "1"
         JogNeg { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Jog in negative direction "1"
         ApplyRelativePositioning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Take the relative position from the FCB09 "1"
         StartStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start "1" / Stop "0"
      END_STRUCT;
      SetpointSpeed : Int;   // Speed (Int) [mm/s]
      SetpointAcceleration : Int;   // Acceleration (Int) [mm/s²]
      SetpointDeceleration : Int;   // Decceleration (Int) [mm/s²]
      DigitalOutputs : Word;   // Digital Outputs
      SetpointMode : Int;   // Set the application mode (Int)
      SetpointPosition_hW : Word;   // Setpoint Position - High Word
      SetpointPosition_lW : Word;   // Setpoint Position - Low Word
   END_STRUCT;

END_TYPE

TYPE "UDT_Message"
TITLE = UDT_Message
VERSION : 0.1
//User-defined structure of the message characters array.
   STRUCT
      Character : Array[0..499] of Char;   // Message character
   END_STRUCT;

END_TYPE

TYPE "UDT_TCPIPReceiveStatistics"
TITLE = UDT_TCPIPReceiveStatistics
VERSION : 0.1
//User-defined structure of FB_TCPIPReceive function block statistics.
   STRUCT
      InvalidMsg : UInt;   // Invalid message received
   END_STRUCT;

END_TYPE

TYPE "UDT_SystemStatistics"
TITLE = Cabinet MCP Statistics
VERSION : 0.1
   STRUCT
      HMI_Stop : "UDT_EventStatistic";   // HMI stop statistics
      Field_Stop : "UDT_EventStatistic";   // Field stop statistics
      Building_EStop : "UDT_EventStatistic";   // Bulding emergency stop statistics
      MCP_EStop : "UDT_EventStatistic";   // MCP emergency stop statistics
      RemotePanel_EStop : "UDT_EventStatistic";   // Remote panel emergency stop statistics
      Error : "UDT_EventStatistic";   // System in error
      StartNumberOfTimes { S7_SetPoint := 'True'} : DInt;   // Number of times system started
      ResetNumberOfTimes { S7_SetPoint := 'True'} : DInt;   // Number of timer system reset
      DataResetNumberOfTimes { S7_SetPoint := 'True'} : DInt;   // Number of data reset
   END_STRUCT;

END_TYPE

TYPE "UDT_ProfiDiagStatistics"
TITLE = UDT_ProfiDiagStatistics
VERSION : 0.1
//User-defined structure of FB_ProfiDiag function block statistics.
   STRUCT
      DeviceError { S7_SetPoint := 'False'} : Array[0..512] of "UDT_EventStatistic";   // Device error statistics
   END_STRUCT;

END_TYPE

TYPE "UDT_PowerDistributionPanelCBState"
VERSION : 0.1
   STRUCT
      CircuitBreakerStateF100 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF201 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF202 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF203 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF204 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF205 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF206 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF207 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF208 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF209 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF210 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF211 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF212 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF213 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF214 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF215 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF216 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF217 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF218 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF219 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF220 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF221 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF222 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF223 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF224 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF225 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF226 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF227 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF228 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF229 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF231 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF232 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF233 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF234 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF235 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF236 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF237 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF238 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF239 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF240 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF241 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF242 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF243 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF244 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF245 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF246 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF247 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF248 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF249 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF250 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF251 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF501 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF502 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF503 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF504 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
      CircuitBreakerStateF505 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit Breaker State Ok if the signal is true
   END_STRUCT;

END_TYPE

TYPE "UDT_PowerDistributionPanelStatus"
VERSION : 0.1
   STRUCT
      Status : Int;   // Status number
      Specific : Struct
         CircuitBreakersTripped { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breakers tripped when the value is true
         CircuitBreakerTrippedF100 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF201 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF202 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF203 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF204 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF205 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF206 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF207 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF208 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF209 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF210 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF211 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF212 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF213 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF214 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF215 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF216 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF217 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF218 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF219 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF220 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF221 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF222 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF223 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF224 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF225 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF226 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF227 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF228 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF229 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF231 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF232 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF233 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF234 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF235 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF236 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF237 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF238 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF239 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF240 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF241 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF242 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF243 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF244 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF245 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF246 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF247 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF248 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF249 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF250 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF501 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF502 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF503 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF504 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF505 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Circuit breaker is tripped when the value is true
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_XBSInductInterfaceRcv"
VERSION : 0.1
   STRUCT
      Watchdog : Byte;   // Watchdog counter
      RunConsent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Ready to receive
      Running { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The IDS is moving
      Fault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The IDS is in fault status
      Enabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The IDS is allowed to laod packages on Sorter
      Throughput : DInt;   // Production target
      LastConveyorSpeedSP : Real;   // Maximum Speed setpoint for the last conveyor of the upstream line (mm/sec)
      MinimumGap : Real;   // Minimum gap between the head and the tail of parcels
   END_STRUCT;

END_TYPE

TYPE "UDT_InchingConfiguration"
TITLE = UDT_InchingConfiguration
VERSION : 0.1
//User-defined structure of inching block parameters.
   STRUCT
      GapSize : Int;   // Gapsize in [cm]
      MaximalFillingPosition : Int;   // Position in [cm] from the end
      ButtonReleaseDelayTime : UDInt;   // Time in [ms] to accept the button to set full or release
      WaitForStartConf { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True = Wait for conformation to start after running empty
   END_STRUCT;

END_TYPE

TYPE "UDT_VfdSiemensPO"
TITLE = UDT_VFD_Siemens_PO
VERSION : 0.1
//User-defined structure of VFD Siemens output telegram.
   STRUCT
      STW_1 : Struct   // Control Word Interconnection 1
         ForceDormantErrorTest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Only applicable in G120 with safety motion monitoring
         SpareBit9 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Spare bit 9
         ControlViaPLC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Control via PLC (Control via fieldbus, inverter accepts the process data from the fieldbus), 0 = No control via PLC (Inverter ignores the process data from the fieldbus) p 0854[0] = r 2090.10
         DirectionReversal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0 = Direction reversal (Invert setpoint of the inverter) p1113[0] = r 2090.11
         SpareBit12 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Spare bit 12
         SpareBit13 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Spare bit 13
         SpareBit14 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Spare bit 14
         SpareBit15 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Spare bit 15
         ONOFF1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0 --> 1 = ON (The inverter goes to "ready "state. If, in addition bit 3 = 1 then the inverter switches on the motor), 0 = OFF1 (The motor brakes with ramp-down time p1121 of the ramp-function generator. The inverter switches off the motor an standstill) p0840[0] = r 2090.0
         OFF2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = No OFF2 (The motor can be switched on (ON command)), 0 = OFF2 (Switch off the motor immediately, the motor then coasts down to a standstill) p0844[0] = r 2090.1
         OFF3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = No OFF3 (The motor can be switched on (ON command)), 0 = OFF3 (Quick stop: The motor brakes with the OFF3 ramp-down time p 1135 down to a standstill.) p0848[0] = r 2090.2
         EnableOperation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Enable operation (Switch on motor (pulses can be enabled)), 0 = Inhibit operation (Immediately switch off motor (cancel pulses)) p 0852[0] = r 2090.3
         DoNotDisableRFG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Do not disable RFG (The ramp-function generator can be enabled), 0 = Disable RFG (The inverter immedeately sets its ramp-function generator output to 0) p 1140[0] = r 2090.4
         EnableRFG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Enable RFG (The output of the ramp-function generator follows the setpoint), 0 = Stop RFG (The output of the ramp-function generator stops at the actual value) p1141[0] = r 2090.5
         EnableSetpoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Enable setpoint (Motor accelerates with the ramp-up time p1120 to the setpoint), 0 = Inhibit setpoint (The inverter brakes the motor with the ramp-down time p1121 of the ramp-function generator) p 1142[0] = r 2090.6
         Acknowledge { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0 --> 1 = Acknowledge faults (Acknowledge fault. If the ON command is still active, the inverter switches to "closing lockout" state) p 2103[0] = r 2090.7
      END_STRUCT;
      SpeedSetpoint : Int;   // Speed Setpoint 100%=4000 HEX = 16384 DEZnormalisation with p 2000 of the inverter
      SetpointAcceleration : Int;   // Acceleration time, defalut time scale in VFD in the rage 0...200%=0...7FFF HEX= 0...32767
      SetpointDeceleration : Int;   // Decceleration time, defalut time scale in VFD in the rage 0...200%=0...7FFF HEX= 0...32767
      SpareWord5 : Int;   // Spare Word 5
      SpareWord6 : Int;   // Spare Word 6
      SpareWord7 : Int;   // Spare Word 7
      SpareWord8 : Int;   // Spare Word 8
      SpareWord9 : Int;   // Spare Word 9
      SpareWord10 : Int;   // Spare Word 10
      SpareWord11 : Int;   // Spare Word 11
   END_STRUCT;

END_TYPE

TYPE "UDT_UnloaderConfiguration"
TITLE = UDT_UnloaderConfiguration
VERSION : 0.1
//User-defined structure of unloader parameters.
   STRUCT
      PEC_EOS : "UDT_PECConfiguration";   // Photo eye time on delay
      Speedsetpoint : Int;   // Speedsetpoint: 0=Low, 1=Nom, 2=High
      EnergySaveLength : Int;   // Distance conveyor travelled before energy save activate [cm]
      FirstConveyorToStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // First conveyor to start cascade mode
      Energy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Energy save mode enable
   END_STRUCT;

END_TYPE

TYPE "UDT_UnloaderStatistics"
TITLE = UDT_UnloaderStatistics
VERSION : 0.1
//User-defined structure of FB_Unloader function block statistics.
   STRUCT
      EnergySave : "UDT_EventStatistic";   // Number of times that save energy mode occurs
      ExtendableUpTime : "UDT_EventStatistic";   // Conveyor up time
      ExtendableDownTime : "UDT_EventStatistic";   // Conveyor down time
      VFDError : "UDT_EventStatistic";   // VFD Error
      NotHealthy : "UDT_EventStatistic";   // Extendable not healthy
      TooLongParcel : "UDT_EventStatistic";   // Too long parcels
      PEC_EOS : "UDT_PECStatistics";   // PEC error
   END_STRUCT;

END_TYPE

TYPE "UDT_Connection"
TITLE = UDT_Connection
VERSION : 0.1
//User-defined structure of connection parameters.
   STRUCT
      ActiveEstablished : Bool := FALSE;   // 0 – Passive connection establishment; 1 – Active connection establishment
      Interface_ID : HW_ANY := 64;   // Interface ID of CPU Ethernet interface
      ID : CONN_OUC;   // Unique ID as system reference for the connection
      IP : Array[1..4] of Int;   // IP address
      Port : UInt;   // Port number of the communication partner
      ConTimeout : DInt;   // Maximum waiting time for response from the communication partner [ms]
   END_STRUCT;

END_TYPE

TYPE "UDT_TCPIPConnectStatus"
TITLE = UDT_TCPIPConnectStatus
VERSION : 0.1
//User-defined structure of FB_TCPIPConnect function block status.
   STRUCT
      Status : Int;   // Status number
      Specific : Struct   // Specific status structure
         ErrorCode : Struct   // Error code structure
            TCON : Word;   // Siemens TCON error code - Check documetation
            TDISCON : Word;   // Siemens TDISCON error code - Check documetation
            TDIAG : Word;   // Siemens TDIAG error code - Check documetation
         END_STRUCT;
         Connected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Connected
         CommunicationFault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Communication fault
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_TCPIPConnectStatistics"
TITLE = UDT_TCPIPConnectStatistics
VERSION : 0.1
//User-defined structure of FB_TCPIPConnect function block statistics.
   STRUCT
      ConnectionLost { S7_SetPoint := 'False'} : "UDT_EventStatistic";   // Connection lost statistics
   END_STRUCT;

END_TYPE

TYPE "UDT_SystemControlStatus"
TITLE = UDT_SystemControlStatus
VERSION : 0.1
//User-defined structure of FB_SystemControl function block status.
   STRUCT
      Status : Int;   // Status number
   END_STRUCT;

END_TYPE

TYPE "UDT_SystemControlCommand"
TITLE = UDT_SystemControlCommand
VERSION : 0.1
//User-defined structure of system control commands.
   STRUCT
      Start { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start Command from HMI
      Stop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stop command from HMI
      Reset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset command from HMI
      ResetData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset data command from HMI
      ResetSafety { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset safety command from HMI
      ManualMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual mode command from HMI
   END_STRUCT;

END_TYPE

TYPE "UDT_SystemControlStatistics"
TITLE = UDT_SystemControlStatistics
VERSION : 0.1
//User-defined structure of FB_SystemControl function block statistics.
   STRUCT
      Run : "UDT_EventStatistic";   // Equipment run statistics
      Error : "UDT_EventStatistic";   // Equipment error statistics
      EnergySave : "UDT_EventStatistic";   // Equipment energy save statistics
   END_STRUCT;

END_TYPE

TYPE "UDT_MainControlPanelStatistics"
TITLE = Cabinet MCP Statistics
VERSION : 0.1
   STRUCT
      UPSFault : "UDT_EventStatistic";   // Unit Power Supply fault statistics
      FireAlarm : "UDT_EventStatistic";   // Fire Alarm active statistics
      "230VAC_CB101F1Tripped" : "UDT_EventStatistic";   // Circuit braker 101F1 tripped  statistics
      "230VAC_CB101F4Tripped" : "UDT_EventStatistic";   // Circuit braker 101F4 tripped statistics
      "230VAC_CB102F1Tripped" : "UDT_EventStatistic";   // Circuit braker 102F1 tripped statistics
      "230VAC_CB102F3Tripped" : "UDT_EventStatistic";   // Circuit braker 102F3 tripped statistics
      "230VAC_CB201F4Tripped" : "UDT_EventStatistic";   // Circuit braker 201F4 tripped statistics
      "24VDC_CB201F1Tripped" : "UDT_EventStatistic";   // Circuit braker 201F1 tripped statistics
      "24VDC_CB205F5Tripped" : "UDT_EventStatistic";   // Circuit braker 205F5 tripped statistics
      "24VDC_CB205F9Tripped" : "UDT_EventStatistic";   // Circuit braker 205F9 tripped statistics
      ScalanceSwitchStatus : "UDT_EventStatistic";   // Scalance switch status statistics
      Spare_1 : "UDT_EventStatistic";   // Spare
      Spare_2 : "UDT_EventStatistic";   // Spare
      Spare_3 : "UDT_EventStatistic";   // Spare
      PS_201T1_Tripped { S7_SetPoint := 'False'} : "UDT_EventStatistic";   // Circuit braker 201T1 tripped statistics
      "PN/PNCouplerFault" : "UDT_EventStatistic";   // PN/PN coupler fault statistics
      SingulatorCouplerFault : "UDT_EventStatistic";   // ProSoft coupler fault statistics
      ScalanceSwitchFault : "UDT_EventStatistic";   // Scalance switch fault statistics
      IOModuleCouplerFault : "UDT_EventStatistic";   // IO Module fault statistics
      RackModuleFault : "UDT_EventStatistic";   // A module fault occurred in the mainrack
   END_STRUCT;

END_TYPE

TYPE "UDT_MainControlPanelStatus"
TITLE = Cabinet MCP Status
VERSION : 0.1
   STRUCT
      Status : Int;   //  Status number
      Specific : Struct
         PN_PN_MSP_PNSlaveNotOnline { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  PNPN coupler is not online
         PN_PN_MSP_PNSlaveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  PNPN coupler has an error
         PN_PN_MSP_PNSlaveWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  PNPN coupler has a warning
         IOModule_PNSlaveNotOnline { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // I/O Module is not online
         IOModule_PNSlaveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // I/O Module has an error
         IOModule_PNSlaveWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // I/O Module has a warning
         ScalanceSwitchPNSlaveNotOnline { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Scalance switch is not online
         ScalanceSwitchPNSlaveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Scalance switch has an error
         ScalanceSwitchPNSlaveWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Scalance switch has a warning
         ScalanceSwitchStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when Scalance switch is not healthy
         Singulator_PNSlaveNotOnline { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Singulator coupler is not online
         Singulator_PNSlaveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Singulator coupler has an error
         Singulator_PNSlaveWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Singulator coupler has a warning
         UPSSwitchTripped { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Unit Power Supply switch tripped
         FireAlarmActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Fire alarm active when the signal is true
         PS_201T1_Tripped { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE if power supply 201T1 tripped
         "230VAC_CB201F4Tripped" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE if MCP circuit breaker 201F4 tripped
         "230VAC_CB101F1Tripped" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE if MCP circuit breaker 101F1 tripped
         "230VAC_CB101F4Tripped" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE if MCP circuit breaker 101F4 tripped
         "230VAC_CB102F1Tripped" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE if MCU circuit breaker 102F1 tripped
         "230VAC_CB102F3Tripped" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE if MCU circuit breaker 102F3 tripped
         "24VDC_CB201F1Tripped" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE if MCU circuit breaker 205F1 tripped
         "24VDC_CB205F5Tripped" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE if MCU circuit breaker 205F5 tripped
         "24VDC_CB205F9Tripped" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE if MCU circuit breaker 205F9 tripped
         Spare_1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Spare
         Spare_2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Spare
         Spare_3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Spare
         RackSlotError : Array[0..31] of Bool;   //  One of the main rack slots has an error
         IOModuleSlotError : Array[0..31] of Bool;   //  Module error
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_StopRollerConfiguration"
VERSION : 0.1
   STRUCT
      BrakePuls : UDInt;   // Time [ms] brake is up in brake function
      BrakePause : UDInt;   // Time [ms] brake is down in brake function
      BrakePauseLong : UDInt;   // Long time [ms] brake is down in brake function
      PECBrakeOnDelay : UDInt;   // On delay time PEC brake signal
      PECBrakeOffDelay : UDInt;   // Off delay time PEC brake signal
      PECStopOnDelay : UDInt;   // On delay time PEC stop signal
      PECStopOffDelay : UDInt;   // Off delay time PEC stop signal
      StopFunctionOnDelay : UDInt;   // On delay time stop function
      StopFunctionOffDelay : UDInt;   // Off delay time stop function
      FailSafe { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate output to release
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_AMBASpiralSlatCheck"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 254
// END_ATTRIBUTES
   VAR_INPUT 
      ix_SlatDetection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Proximity switch signal (TRUE = Slat detected)
      ix_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when hardware is Ok
   END_VAR

   VAR_IN_OUT 
      iqx_MissingSlatDetected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // [Failure] Missing slat detected (TRUE = detected)
      iqUDT_Statistics : "UDT_EventStatistic";   // Statistics of missing slat
      iqUDT_EquipmentControl : "UDT_EquipmentControl";
   END_VAR

   VAR 
      sFB_SignalFilter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // On/Off delay to filter the input signal
      sR_TRIG_MissingSlatDetected {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Flank detection missing slat
   END_VAR

   VAR_TEMP 
      tx_SlatDetected : Bool;
   END_VAR

   VAR CONSTANT 
      cudi_OffDelay : UDInt := 25;   // [ms]
   END_VAR


BEGIN
	(*                                                                                   
	Version history:
	Date        | Version   | Author              | Remark
	----------------------------------------------------------------------------------------
	 14/03/2022 | 1.0       | G.Vlooswijk         | Initial version for FedEx Milano
	 16/05/2022 | 1.1       | G.Vlooswijk         | Tested (logic) GLS Tongeren
	 03/06/2024 | 1.2       | J.Majer             | Adapted to current library
	*)
	
	REGION Inputs
	    
	    // Filter input signal
	    #sFB_SignalFilter(iudi_OffDelayTime := #cudi_OffDelay,
	                      ix_SignalToDelay := #ix_SlatDetection,
	                      qx_DelayedSignal => #tx_SlatDetected);
	    
	END_REGION
	
	REGION Missing slat detection
	    
	    //Set fault
	    IF NOT #tx_SlatDetected AND #ix_HardwareOk THEN
	        #iqx_MissingSlatDetected := TRUE;
	    END_IF;
	    
	    //Reset fault
	    IF #iqx_MissingSlatDetected
	        AND (NOT #ix_HardwareOk
	        OR #tx_SlatDetected AND #iqUDT_EquipmentControl.Command.Reset)
	    THEN
	        #iqx_MissingSlatDetected := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION Statistics
	    
	    // Rising flank detection
	    #sR_TRIG_MissingSlatDetected(CLK := #iqx_MissingSlatDetected);
	    
	    IF #iqx_MissingSlatDetected
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #iqx_MissingSlatDetected,
	                        ix_RTrigActivate := #sR_TRIG_MissingSlatDetected.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics);
	        
	    END_IF;
	    
	END_REGION
	
	
END_FUNCTION_BLOCK

TYPE "UDT_SorterConveyorConfiguration"
TITLE = UDT_SorterConveyorConfiguration
VERSION : 0.1
//User-defined structure of  sorter conveyor parameters.
   STRUCT
      Common : "UDT_ConveyorCommonConfiguration";   // Common configuration
      Forward_Direction : Struct   // Forward Direction configuration
         EnergySaveLenght : DInt;   // Distance conveyor travelled before energy save activate [cm]
         PEC_EoSDistanceOffset : DInt;   // Distance offset between photo eye and the end of conveyor [mm]
         FirstConveyorToStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // First conveyor to start cascade mode forward direction
      END_STRUCT;
      CascadeTimeOnDelay : UDInt;   // Cascade time on delay [ms]
      SpeedSetpointPendantLow : Int;   // Extra gap to recovery die back [cm]
      SpeedSetpointLow : Int;   // Low speed setpoint [mm/s]
      SpeedSetpointNominal : Int;   // Nominal speed setpoint [mm/s]
      RTR_at_Speed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE = RTR to upstream when sorter reached nominal speed
      Energy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Energy save mode enable
   END_STRUCT;

END_TYPE

TYPE "UDT_SpiralVeyorStatus"
VERSION : 0.1
   STRUCT
      MissingSlat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Missing slat detected in SpiralVeyor lane
      BrokenChain { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Broken chain detected in SpiralVeyor lane
      ChainOverlength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Warning chain overlength detected in SpiralVeyor lane
   END_STRUCT;

END_TYPE

TYPE "UDT_PendantVT100Interface"
TITLE = Configuation variables for VT100 Radio Pendant
VERSION : 0.1
   STRUCT
      LowSpeedSelected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Lowest Speed
      ManualSpeedSelected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual Speed
      CmdRun { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Comman to run VFD
      CmdDivert { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command to divert
      ServiceModeEngaged { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Pendant service mode is engaged
      PendantStopHealthy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Pedant Stop button is healthy
      PendantReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset command from pendant
      RequestSTO { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request STO command to safety program
      ForceLowSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Force low speed for pin detection
   END_STRUCT;

END_TYPE

TYPE "UDT_SpiralVeyorStatistics"
VERSION : 0.1
   STRUCT
      MissingSlat { S7_SetPoint := 'False'} : "UDT_EventStatistic";   // Statistics of missing slat event
      BrokenChain { S7_SetPoint := 'False'} : "UDT_EventStatistic";   // Statistics of broken chain event
      ChainOverlength { S7_SetPoint := 'False'} : "UDT_EventStatistic";   // Statistics of chain overlength event
   END_STRUCT;

END_TYPE

TYPE "UDT_ConveyorStatistics"
TITLE = UDT_ConveyorStatistics
VERSION : 0.1
//User-defined structure of FB_Conveyor function block statistics.
   STRUCT
      EnergySave : "UDT_EventStatistic";   // Number of times that save energy mode occurs
      ConveyorUp : "UDT_EventStatistic";   // Conveyor up statistics
      ConveyorDown : "UDT_EventStatistic";   // Conveyor down statistics
      ConveyorStop : "UDT_EventStatistic";   // Conveyor down statistics
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_Displacement"
TITLE = FB_Displacement
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
//Function block to calculate the displacement.
   VAR_IN_OUT 
      iqUDT_ConveyorInterface : "UDT_ConveyorInterface";   // Conveyor interface structure Motor
   END_VAR

   VAR 
      slr_FormDisplacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Conveyor displacement [cm]
      slr_Correction { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Correction [cm]
      sx_PositionModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Position Mode is used, Will reset after power change
   END_VAR

   VAR_TEMP 
      ti_Displacement : Int;   // Conveyor displacement [cm]
   END_VAR

   VAR CONSTANT 
      ci_IntMin : Int := -32768;
      ci_IntMax : Int := 32767;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	12/09/2019  | 2.1       | P.Majka       | Comments updataed
	04/11/2019  | 2.2       | L.Klar        | Prevoius cycle scan changed from memory to DB variable
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	31/05/2024  | 4.1       | I.Ajram       | Added Displacement from Position feedback
	*)
	REGION 0 - Mode detection
	    IF #iqUDT_ConveyorInterface.DeltaPosition <> 0 THEN
	        #sx_PositionModeActive := true;
	    END_IF;
	END_REGION
	
	
	REGION 1 - Displacement From Speed
	    IF NOT #sx_PositionModeActive THEN
	        REGION 1.1 Calculate Displacement
	            // Displacement is calculated using actual conveyor speed and the previous PLC cycle scan time
	            #slr_FormDisplacement := INT_TO_LREAL(#iqUDT_ConveyorInterface.ActualSpeed) * "DB_Memory".PrevCycleTime / 10000.0;
	            
	            // Correction is used to accumulate the rest of the calculated value
	            #slr_Correction := FRAC(#slr_FormDisplacement) + #slr_Correction;
	            
	            // The actual displacement is a sum of complete parts of the displacement and correction variables
	            #ti_Displacement := DINT_TO_INT(TRUNC(#slr_FormDisplacement) + TRUNC(#slr_Correction));
	            
	        END_REGION
	        
	        REGION 1.2 - Correction check
	            
	            // Correction incrementation or decremantation if it exceeds 1 or -1 in case of negative speed
	            IF (#slr_Correction >= 1)
	            THEN
	                
	                #slr_Correction -= 1;
	                
	            ELSIF (#slr_Correction <= -1)
	            THEN
	                
	                #slr_Correction += 1;
	                
	            END_IF;
	            
	        END_REGION
	        
	        #iqUDT_ConveyorInterface.Displacement := #ti_Displacement;
	    END_IF;
	END_REGION
	
	REGION 2 - Displacement from Position
	    // pass position displacement from Servo Feedback
	    IF #sx_PositionModeActive THEN
	        #iqUDT_ConveyorInterface.Displacement := #iqUDT_ConveyorInterface.DeltaPosition;
	        
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

TYPE "UDT_RIOVSUStatus"
VERSION : 0.1
   STRUCT
      PNSlaveNotOnline { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet slave is not online
      PNSlaveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet slave has an error
      "400VCircuitBreaker" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 400V Circuit breaker has tripped
      BrakeCircuitBreaker { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Brake Circuit breaker has tripped
      BrakeThermalError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Brake of the servo unit is giving a thermal error
      "24VPowersupplyError" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 24V power supply is in error
      ET200sp_ErrorModule : Array[0..31] of Bool;   // True = ET200sp Module has an error or is offline
      PNSlaveWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet slave has a warning
   END_STRUCT;

END_TYPE

TYPE "UDT_RIOVSUStatistics"
TITLE = UDT_RIOStatistics
VERSION : 0.1
//User-defined structure of FB_RIO function block statistics.
   STRUCT
      Int400VCBError : "UDT_EventStatistic";   // Statistics of internal 400V circuit breaker not OK
      Ext400VError : "UDT_EventStatistic";   // Statistics of external 400V not OK
      "24VError" : "UDT_EventStatistic";   // Statistics of external 24V not OK
      BrakeCBerror : "UDT_EventStatistic";   // Statistics of brake circuit breaker not OK
      BrakeThermError : "UDT_EventStatistic";   // Statistics of brake thermal error
      PNSlaveNotOnline : "UDT_EventStatistic";   // Statistics of Profinet slave not online
      PNSlaveError : "UDT_EventStatistic";   // Statistics of a Profinet slave error
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_RIO"
TITLE = FB_RIO
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 225
// END_ATTRIBUTES
//Function block to diagnose remote IO module.
   VAR_INPUT 
      is_ET200spPNDeviceName { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   //  Name of the ET200sp device
      ix_24VOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when 24VDC is healthy
      ix_SimulationModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when simulation mode active
      ix_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when  hardware is Ok
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_RIOStatus";   //  HMI status structure
      qUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   //  Common status structure
      qx_PNDeviceOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Device ok
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   //  Equipment control structure
      iqUDT_Statistics : "UDT_RIOStatistics";   //  Statistics structure
   END_VAR

   VAR 
      sUDT_CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //  Common status structure
      sUDT_CommonStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //  Common status structure
      sUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RIOStatus";   //  HMI status structure
      sUDT_PNDevice { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PNDevice";   //  PN device info structure
      sa_PNPortsStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..8] of Bool;   // TRUE when specific port has an error
      sFB_TimerOnOffDelayCheckSupply { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //  MHS "TimerOnOffDelay" - to delay time for VFD supply contactor
      sR_TRIG_PNSlaveNotOnline {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge for trigger Profinet slave not online statistics
      sR_TRIG_DeviceFound {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge for trigger scan modules
      sR_TRIG_PNSlaveError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge for trigger Profinet slave error statistics
      si_ModuleStateReturn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Status structure
      si_NrOfModulesWithError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Number of the faulty modules
      sx_PowerOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  True = External Power OK
      sx_PNSlaveOnline { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Profinet device is online and error free
      sx_ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Commissioning: configuration error
   END_VAR

   VAR_TEMP 
      ta_Configured : Array[0..127] of Bool;   //  Configured modules array
      ta_Exist : Array[0..127] of Bool;   //  Existing modules array
      ta_Error : Array[0..127] of Bool;   //  Faulty modules array
      ti_NrOfModule : Int;   //  Number of current module
      ti_DiagArraySize : Int;   //  Diagnostic array size
   END_VAR

   VAR CONSTANT 
      cui_ConfiguredModulesMode : UInt := 1;   //  Mode selector: 1 = Configured modules scan mode
      cui_ModuleErrorMode : UInt := 2;   //  Mode selector: 2 = Existing modules scan mode
      cui_ExistingModulesMode : UInt := 4;   //  Mode selector: 3 = Module Error scan mode
      ci_PowerSupplyDelayTime : UInt := 4000;   //  Power supply delay time
      ci_NumberOfProfinetPorts : Int := 2;   // Number of Profinet ports in device
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | K.Pokorski    | first release MHS TIA 15.1
	14/06/2019  | 0.2       | K.Pokorski    | Delete trigger in faults reset - Region 4
	14/06/2019  | 0.3       | A.Nowak       | Replacement of instruction if for direct write into variable - Region 3 
	24/06/2019  | 0.3       | L.Klar        | Status running added
	19/07/2019  | 0.5       | L.Klar        | Status handling changed, output qx_DeviceOk added
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	14/08/2019  | 2.1       | K.Pokorski    | Profinet number search automatically
	03/09/2019  | 2.2       | TVB           | Updated code for status and statistics, added 24v input to set errors
	09/09/2019  | 2.3       | K.Pokorski    | Updated code for reset errors, changed conditions to start scan loop
	01/10/2019  | 2.4       | K.Pokorski    | Changed region 1 contents to FC
	01/10/2019  | 2.5       | K.Pokorski    | Common status added
	14/10/2019  | 2.6       | L.Klar        | Updated status structure
	14-10-2019  | 2.7       | S. Deulkar    | Created saperate network for status
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	04/11/2019  | 3.1       | F.Baten       | Region 3: ix_SimulationModeActive rearranged to correct position
	08/07/2019  | 3.2       | S.Theocharis  | Write q_Status in every scan. Initialize static status 
	09/07/2019  | 3.3       | S.Theocharis  | Initialize the #si_NrOfModulesWithError on the reset
	03/11/2020  | 3.4       | K.Pokorski    | Profinet ports diagnostics added 
	02/08/2021  | 3.5       | S. Deulkar    | Added logic to reset error when 24V is not okay. 
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Get Device Profinet information
	    
	    "FC_GetDevicePN"(is_PNDeviceName := #is_ET200spPNDeviceName,
	                     ix_SimulationModeActive := #ix_SimulationModeActive,
	                     iqUDT_PND := #sUDT_PNDevice);
	    
	    
	    "FC_GetPNPortStatus"(ii_NumberOfPorts := #ci_NumberOfProfinetPorts,
	                         iUDT_DevicePNInfo := #sUDT_PNDevice,
	                         qa_PortFault => #sa_PNPortsStatus);
	    
	END_REGION
	
	REGION 2 - Reset errors
	    
	    // reset Profinet Slave error/not online  
	    IF #iqUDT_EquipmentControl.Command.Reset
	        OR NOT #ix_24VOk
	    THEN
	        #sUDT_HMIStatus.Specific.PNSlaveNotOnline := FALSE;
	        #sUDT_HMIStatus.Specific.PNSlaveError := FALSE;
	        #sUDT_HMIStatus.Specific.PNSlaveWarning := FALSE;
	        #si_NrOfModulesWithError := 0;
	    END_IF;
	    
	    // reset ET200sp module error status
	    IF #sUDT_HMIStatus.Specific.PNSlaveNotOnline OR #iqUDT_EquipmentControl.Command.Reset OR NOT #ix_24VOk
	    THEN
	        FILL_BLK(IN := FALSE,
	                 COUNT := 32,
	                 OUT => #sUDT_HMIStatus.Specific.ET200sp_ErrorModule[0]);
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Update PN slave device status
	    // Hardware will only be available after the delay, so the device has time for the initialisation
	    #sFB_TimerOnOffDelayCheckSupply(iudi_OnDelayTime := #ci_PowerSupplyDelayTime,
	                                    ix_SignalToDelay := #ix_24VOk,
	                                    qx_DelayedSignal => #sx_PowerOk);
	    
	    // check if PN device is online
	    IF NOT "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.Exist
	        AND #sx_PowerOk
	        OR NOT #sUDT_PNDevice.PNDeviceFound
	        AND NOT #ix_SimulationModeActive
	    THEN
	        
	        #sUDT_HMIStatus.Specific.PNSlaveNotOnline := TRUE;
	        
	    END_IF;
	    
	    // Check if PN ports are healthy 
	    IF #sa_PNPortsStatus[1] XOR #sa_PNPortsStatus[2] THEN
	        #sUDT_HMIStatus.Specific.PNSlaveWarning := TRUE;
	    END_IF;
	    
	    
	    // check if PN device has an error
	    IF "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.Error
	        AND #sx_PowerOk
	        AND NOT #ix_SimulationModeActive
	        AND NOT #sUDT_HMIStatus.Specific.PNSlaveWarning
	    THEN
	        #sUDT_HMIStatus.Specific.PNSlaveError := TRUE;
	    END_IF;
	    
	    // set bit when PN device is healthy (online and no error)
	    #sx_PNSlaveOnline := NOT #sUDT_HMIStatus.Specific.PNSlaveNotOnline
	    AND #sUDT_PNDevice.PNDeviceFound
	    AND #sx_PowerOk;
	    
	    // create rising edge to scan module status when device is found
	    #sR_TRIG_DeviceFound(CLK := #sUDT_PNDevice.PNDeviceFound);
	    
	END_REGION
	
	REGION 4 - Status update modules ET200sp
	    // update ET200sp module status 
	    IF (#sx_PNSlaveOnline
	        AND (#sUDT_HMIStatus.Specific.PNSlaveError OR
	        #sUDT_HMIStatus.Specific.PNSlaveWarning))
	        OR #sR_TRIG_DeviceFound.Q
	    THEN
	        // get configured modules
	        #si_ModuleStateReturn := ModuleStates(LADDR := "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.HW_ID,
	                                              MODE := #cui_ConfiguredModulesMode,
	                                              STATE := #ta_Configured);
	        
	        // get module online status
	        #si_ModuleStateReturn := ModuleStates(LADDR := "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.HW_ID,
	                                              MODE := #cui_ExistingModulesMode,
	                                              STATE := #ta_Exist);
	        
	        // get module error status
	        #si_ModuleStateReturn := ModuleStates(LADDR := "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.HW_ID,
	                                              MODE := #cui_ModuleErrorMode,
	                                              STATE := #ta_Error);
	        
	        // Handle ET200sp module errors/offline
	        IF (#si_ModuleStateReturn = 0)
	        THEN
	            #si_NrOfModulesWithError := 0;
	            
	            #ti_DiagArraySize := "FC_GetNrOfArrayEl"(iv_Array := "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].Module);
	            
	            FOR #ti_NrOfModule := 0 TO (#ti_DiagArraySize - 1) DO
	                
	                // check if the module is configured
	                IF (#ta_Configured[#ti_NrOfModule])
	                THEN
	                    "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].Module[#ti_NrOfModule].Configured := TRUE;
	                    // and check if the module is online
	                    IF (#ta_Exist[#ti_NrOfModule])
	                    THEN
	                        "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].Module[#ti_NrOfModule].Exist := TRUE;
	                        
	                    ELSE
	                        "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].Module[#ti_NrOfModule].Exist := FALSE;
	                        #sUDT_HMIStatus.Specific.ET200sp_ErrorModule[#ti_NrOfModule] := TRUE;
	                        // count number of modules with error/offline
	                        #si_NrOfModulesWithError += 1;
	                    END_IF;
	                    
	                    // and check if the module has an error
	                    IF (NOT #ta_Error[#ti_NrOfModule])
	                    THEN
	                        "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].Module[#ti_NrOfModule].Error := FALSE;
	                        
	                    ELSE
	                        "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].Module[#ti_NrOfModule].Error := TRUE;
	                        #sUDT_HMIStatus.Specific.ET200sp_ErrorModule[#ti_NrOfModule] := TRUE;
	                        // count number OF modules with error/offline
	                        #si_NrOfModulesWithError += 1;
	                    END_IF;
	                    
	                ELSE
	                    // reset module status when module is not configured
	                    "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].Module[#ti_NrOfModule].Configured := FALSE;
	                    "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].Module[#ti_NrOfModule].Exist := FALSE;
	                    "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].Module[#ti_NrOfModule].Error := FALSE;
	                    
	                END_IF;
	            END_FOR;
	        END_IF;
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Check RIO Panel Status
	    // check if PN device is healthy
	    #qx_PNDeviceOk := (#si_NrOfModulesWithError = 0)
	    AND NOT #sUDT_HMIStatus.Specific.PNSlaveNotOnline
	    AND NOT #sUDT_HMIStatus.Specific.PNSlaveError;
	    
	    // set config not ok bit if no device found
	    #sx_ConfigurationError := NOT #sUDT_PNDevice.PNDeviceFound;
	    
	    
	END_REGION
	
	REGION 6 - Statistics
	    // create trigger on error and create statistics for profinet slave not online
	    #sR_TRIG_PNSlaveNotOnline(CLK := #sUDT_HMIStatus.Specific.PNSlaveNotOnline);
	    
	    IF #iqUDT_EquipmentControl.Command.ResetData OR #sUDT_HMIStatus.Specific.PNSlaveNotOnline
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.PNSlaveNotOnline,
	                        ix_RTrigActivate := #sR_TRIG_PNSlaveNotOnline.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.PNSlaveNotOnline);
	    END_IF;
	    
	    // create trigger on error and create statistics for profinet slave error
	    #sR_TRIG_PNSlaveError(CLK := #sUDT_HMIStatus.Specific.PNSlaveError);
	    
	    IF #iqUDT_EquipmentControl.Command.ResetData OR #sUDT_HMIStatus.Specific.PNSlaveError
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.PNSlaveError,
	                        ix_RTrigActivate := #sR_TRIG_PNSlaveError.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.PNSlaveError);
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Status
	    
	    #sUDT_CommonStatus.Error := #sUDT_HMIStatus.Specific.PNSlaveError
	    OR #sUDT_HMIStatus.Specific.PNSlaveNotOnline
	    OR #si_NrOfModulesWithError <> 0;
	    
	    // HMI status update
	    IF #sUDT_CommonStatusOld <> #sUDT_CommonStatus                    // update on change
	    THEN
	        
	        // HMI status initialization
	        #sUDT_HMIStatus.Status := 0;
	        
	        // HMI status calculation
	        IF #si_NrOfModulesWithError <> 0                                // Hardware error
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".HardwareError;
	            
	        END_IF;
	        
	        IF #sUDT_HMIStatus.Specific.PNSlaveError                       // Profinet error
	            OR #sUDT_HMIStatus.Specific.PNSlaveNotOnline
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".ProfinetError;
	            
	        END_IF;
	        #qUDT_Status := #sUDT_CommonStatus;                       // Copy status to output
	        #qUDT_HMIStatus := #sUDT_HMIStatus;                       // Copy HMI status to output
	        #sUDT_CommonStatusOld := #sUDT_CommonStatus;              // Copy status to memory
	        
	        
	    END_IF;
	    
	    //Write status in every scan. AST 8/7/20
	    #qUDT_HMIStatus := #sUDT_HMIStatus;                       // Copy HMI status to output
	    
	END_REGION
	
	REGION 8 - Report to control block
	    
	    // Function to manage report between control block and conveyor block
	    "FC_EquipmentReport"(iUDT_Status := #sUDT_CommonStatus,
	                         iqUDT_Control := #iqUDT_EquipmentControl);
	    
	END_REGION
	
END_FUNCTION_BLOCK

TYPE "UDT_VSUInterface"
TITLE = UDT_VSUInterface
VERSION : 0.1
//User-defined structure of VSU interface parameters.
   STRUCT
      Decisionpoint : Int;   // Point in tracking where the destination is found on the VSU conveyor [mm]
      RequestedPosition : Int;   // Position Requested by destination block
      PositionSetpoint : Int;   // Position number (as configured) to go to by positioning device
      PositionActual : Int;   // Position number the positioning device is actually on
      SwitchingTime : UInt;   // Time it takes to go from one position to the next [ms]
      VSUMainPowerOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True = Main power for VSU ok
      BrakeOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True = VSU brake is ok
      PNDeviceOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Device ok
      Automatic { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Automatic mode request
      RunEnabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Running of the positioning device is enabled by VSU
      GoReference { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate reference run by VSU
      Referenced { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Positioning device is referenced
      Manual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual mode request
      Reference_command { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Refference command
      JogUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Jog request to move equipment up
      JogDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Jog request to move equipment down
      Ready { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Positioning block is running and error free
      MotorRunning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor is running
      Positioning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // positioning device is moving to its position
      ResetStatistics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset statistics
      InternalErrorRIOPanel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // RIO panel has an internal error
      InternalWarningRIOPanel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // RIO panel has an internal waring
      InternalErrorVFD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // positioning device internal error
      InternalWarningVFD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // positioning device has a warning
      InternalErrorReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset internal faults
      StartLowSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Positioning device starting in low speed
      RequestDieBackUpstream { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External request die back to the upstream conveyor of the VSU
      ExternalHold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External request to stop the VSU conveyor
   END_STRUCT;

END_TYPE

TYPE "UDT_UnloaderCommand"
VERSION : 0.1
   STRUCT
      Disable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disable unloader
   END_STRUCT;

END_TYPE

TYPE "UDT_LoaderCommand"
VERSION : 0.1
   STRUCT
      Disable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disable loader
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_PEC"
TITLE = FB_PEC
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : Conveyor
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 219
// END_ATTRIBUTES
   VAR_INPUT 
      ix_PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Signal of the PEC
      iUDT_PECConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";   // PEC configuration structure
   END_VAR

   VAR_OUTPUT 
      qx_PECFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PEC Filtered
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";   // Status structure
   END_VAR

   VAR_IN_OUT 
      iqUDT_ConveyorInterface : "UDT_ConveyorInterface";   // Interface structure
      iqUDT_PECStatistics : "UDT_PECStatistics";   // Statistics structure
   END_VAR

   VAR 
      s_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatus";   // Status structure
      s_StatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatus";   // Auxiliary status structure
      sx_Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Enable
   END_VAR
   VAR RETAIN
      si_AuxJamDisplacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Auxiliary variable to calculate displacement when PEC is blocked
   END_VAR
   VAR 
      sx_PECFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Photo eye filtered
      PEC_TimerOnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Filtering end of section photo eye signal
      R_TRIG_PECJam {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger PEC jam
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	04/10/2019  | 2.0       | S. Nikodem    | first release TIA 15.1
	09/10/2019  | 2.1       | L.Klar        | Internal PEC error added
	28/10/2019  | 2.2       | S. Nikodem    | Change sign in region 2 - equal to greater then
	29/10/2019  | 2.3       | L.Klar        | UDT_PECStatus output variable changed, interface comments adjusted
	29/10/2019  | 2.4       | L.Klar        | Region 4 - time input corrected
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	26/11/2019  | 3.1       | P.Majka       | Static variable name change to PEC from EOS PEC
	12/12/2019  | 3.2       | C. Leite      | Absolute displacement value to control jam error in both directions
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	12/03/2024  | 4.1       | S. Nieswiec   | Small variable name changes according to current standard  
	*)
	
	REGION 1 - Triggers
	    
	    // Rising edge PEC Jam
	    #R_TRIG_PECJam(CLK := #s_Status.Jam);
	    
	END_REGION
	
	REGION 2 - Active function  
	    
	    // To activate the jam monitoring the jam displacement limit  must be configured up to zero. 
	    #sx_Enable := #iUDT_PECConfiguration.JamDisplacementLimit > 0;
	    
	END_REGION
	
	REGION 3 - Reset errors
	    
	    // Jam error is reset when reset bit is active and jam error is active and is connfigured alllow reset jam with PEC blocked or photo eye is not active
	    IF #iqUDT_ConveyorInterface.InternalErrorReset
	        AND (#iUDT_PECConfiguration.ResetWithPECBlocked
	        OR (NOT #iUDT_PECConfiguration.ResetWithPECBlocked
	        AND #sx_PECFiltered))
	        AND #s_Status.Jam
	    THEN
	        
	        #si_AuxJamDisplacement := 0;
	        #s_Status.Jam := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Photo eye filters
	    
	    // End of section photo eye signal filter timer
	    #PEC_TimerOnOffDelay(iudi_OnDelayTime := #iUDT_PECConfiguration.TimeOnDelay,
	                         iudi_OffDelayTime := #iUDT_PECConfiguration.TimeOffDelay,
	                         ix_SignalToDelay := #ix_PEC,
	                         ix_Enable := TRUE,
	                         qx_DelayedSignal => #sx_PECFiltered);
	    
	    // Write the current status of the photo eye
	    #s_Status.PEC := #sx_PECFiltered;
	    #qx_PECFiltered := #sx_PECFiltered;
	    
	END_REGION
	
	REGION 5 - Jam detection   
	    
	    IF NOT #sx_PECFiltered                                                    // Photo eye blocked
	        AND #sx_Enable                                                            // Active of checking the PEC jam 
	    THEN
	        
	        #si_AuxJamDisplacement += ABS(#iqUDT_ConveyorInterface.Displacement);
	        
	    ELSE
	        
	        #si_AuxJamDisplacement := 0;
	        
	    END_IF;
	    
	    // Compare jam auxiliary counter with displacement jam configured
	    IF #si_AuxJamDisplacement > #iUDT_PECConfiguration.JamDisplacementLimit
	    THEN
	        
	        #s_Status.Jam := TRUE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Statistics
	    
	    // Statistics Jam PEC
	    IF #s_Status.Jam                                                                // PEC jam error active
	        OR #iqUDT_ConveyorInterface.ResetStatistics                                       // Reset statistics
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #s_Status.Jam,
	                        ix_RTrigActivate := #R_TRIG_PECJam.Q,
	                        iqUDT_Statistics := #iqUDT_PECStatistics.Jam);
	        
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Internal PEC error
	    
	    IF #s_Status.Jam
	    THEN
	        
	        #iqUDT_ConveyorInterface.InternalErrorPEC := TRUE;
	        
	    END_IF;
	    
	END_REGION
	
	
	REGION 8 - Status
	    
	    // Status update on change
	    IF #s_StatusOld <> #s_Status
	    THEN
	        
	        #qUDT_HMIStatus := #s_Status;
	        #s_StatusOld := #s_Status;
	        
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

TYPE "UDT_VfdConfiguration"
TITLE = UDT_VFD_Configuration
VERSION : 0.1
//User-defined structure oparameters.
   STRUCT
      GearRatio : Real;   // Gear box value X = turns at input to get 1 turn at output
      ReferenceRPM : Real;   // VFD speed max - reference [rpm]
      WheelEndPerimeter : Real;   // Perimeter of wheel at the end of gear [mm]
      VFDRampUpTime : UDInt;   // VFD ramp up time for monitoring starting [ms]
      VFDRampDownTime : UDInt;   // VFD ramp up time for monitoring stopping [ms]
      SpeedSetpointWindow : Int := 5;   // VFD speed setpoint window (tolerance) [mm/s]
      VFDPNDeviceName : String;   // VFD's Profinet device name
      DirectionReversal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // If true, direction will be swapped
      InterlockFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // False when turning in forward direction is not possible / allowed
      InterlockRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // False when turning in reverse direction is not possible / allowed
      VFDStartupTime : UDInt := 2000;   // Time when the motor should start [ms]
   END_STRUCT;

END_TYPE

TYPE "UDT_VfdNordPI"
TITLE = UDT_VfdNordPI
VERSION : 0.1
//User-defined structure of VFD Nord input telegram.
   STRUCT
      ZSW : Struct   // Status word
         SetpointReached { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0 = Actual value does not corresponf to setpoint. 1 = Actual value matches the setpoint
         BusControlActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0 = Control on local device active. 1 = The master has beed requestd to take over control
         "StartFunction481.9" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Bus bit 10 of status word is set P481
         RotationRightIsOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = The FI output voltage has a RH rotation field
         RotationLeftIsOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = The FI output voltage has a LH rotation field
         "StartFunction481.10" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Bus bit 13 of status word is set P481
         ParameterSetBit0ON { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parameter set bit 0 status
         ParameterSetBit1ON { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parameter set bit 0 status
         ReadyToStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Initialisation completed, charging relay switched on, output voltage disabled
         ReadyForOperation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0 = No switch-on command present or fault. 1 = The inverted can start with the command "Enable operation"
         OperationEnabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = The output voltage is enabled; ramp of the frequency inverter up to the existing setpoint
         Fault : Bool := FALSE;   // 1 = Drive unit defective, not ready for operation
         VoltageEnabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0 = "Disable voltage" command present
         EmergencyStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0 = "Emergency stop" command present
         StartingDisabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = With the command "Standby" the FI goes into status "Ready to switch on"
         WarningActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Drive operation continues, no acknowledgement necessary
      END_STRUCT;
      ActualSpeed : Int;   // Actual calculated speed [rpm]. [Range  -200% ..200%][100%=4000HEX/ 16384DEC = P202 nominal speed]
      FaultCode : Int;   // Actual fault code
   END_STRUCT;

END_TYPE

TYPE "UDT_VfdStatus"
TITLE = UDT_VfdStatus
VERSION : 0.1
//User-defined structure of VFD status.
   STRUCT
      ErrorCode : Int;   // Error code
      SubErrorCode : Int;   // Sub error code
      PNSlaveNotonline : Bool := FALSE;   // Profinet slave is not on line
      PNSlaveError : Bool := FALSE;   // Profinet slave has an error
      InternalError : Bool := FALSE;   // A VFD internal error is active, see error code
      InternalWarning : Bool := FALSE;   // A VFD internal warning is active, see error code
      CommunicationErrorMovikit : Bool := FALSE;   // Communication error with MoviKit
      VFDRunningFeedbackError : Bool := FALSE;   // Motor is not running
      PNSlaveWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet slave has a warning
   END_STRUCT;

END_TYPE

TYPE "UDT_CaljanStatistics"
TITLE = UDT_UnloaderStatistics
VERSION : 0.1
//User-defined structure of FB_Unloader function block statistics.
   STRUCT
      EnergySave : "UDT_EventStatistic";   // Number of times that save energy mode occurs
      ExtendableUpTime : "UDT_EventStatistic";   // Conveyor up time
      ExtendableDownTime : "UDT_EventStatistic";   // Conveyor down time
      VFDError : "UDT_EventStatistic";   // VFD Error
      NotHealthy : "UDT_EventStatistic";   // Extendable not healthy
      TooLongParcel : "UDT_EventStatistic";   // Too long parcels
      PEC_EOS : "UDT_PECStatistics";   // PEC error
      PNNodeNotOnline : "UDT_EventStatistic";   // PN node not online
      PNNodeError : "UDT_EventStatistic";   // PN node has error
   END_STRUCT;

END_TYPE

TYPE "UDT_VfdNordPO"
TITLE = UDT_VfdNordPO
VERSION : 0.1
//User-defined structure of VFD Nord output telegram.
   STRUCT
      STW : Struct   // Control Word
         "StartFunction408.11" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Bus bit 8 of control word is set. P480
         "StartFunction408.12" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Bus bit 8 of control word is set. P480
         ControlDataValid { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = The bus master trasnfers valid process data. 0 = The transmitted process data are invalid
         RotationRightOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Switch on rotation right
         RotationLeftOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Switch on rotation left
         Reserved { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved from NORD
         ParameterSetBit0 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activates parameter set
         ParameterSetBit1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activates parameter set
         ReadyForOperation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Set the frequency inverter to standby. 0=Reverse with brake ramp
         DisableVoltage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0 = Switch off the frequency inverter output voltage. 1 = Cancel "Disable voltage"
         EmergencyStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0 = Emergency stop with programmed estop time. Not Fail Safe Estop. 1 = Cancel condition "Emergency stop"
         EnableOperation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Enable output voltage acceleration to setpoint. 0 = Block voltage, switch off output voltage
         EnablePulsles { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Enable acceleration encoder. 0 = Acceleraton encoder is set to zero
         EnableRamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Enable setpoint on acceleration encoder. 0 = Freeze the setpoint provided by the acceleration encoder
         EnableSetpoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 = Activate the selected setpoint on the acceleration encoder. 0= Set the selected setpoint on the acceleration encoder to 0
         Acknowledge { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0-->1 = Inactive errors are acknowledged
      END_STRUCT;
      FrequencySetPoint : Int;   // Frequency HZ SetPoint to VFD 100%=4000HEX /16384 DEC . 0% = 0000HEX / 0 DEC Normalization with P105
      RampTimeSetPoint : Int;   // Ramp time to VFD [Range 0..200%][100% = 4000HEX /16384DEC = 10sec]
   END_STRUCT;

END_TYPE

TYPE "UDT_CommisioningNord"
VERSION : 0.1
   STRUCT
      HWAdress : Int;   // Actual dipswitch adress of the VFD
      i_ParCRC : Word;   // VFD generated CRC
      CommissionError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Commissioning error active
   END_STRUCT;

END_TYPE

TYPE "UDT_CaljanCommand"
VERSION : 0.1
   STRUCT
      Disable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disable unloader
   END_STRUCT;

END_TYPE

TYPE "UDT_VfdStatistics"
TITLE = UDT_VFDStatistics_SEW
VERSION : 0.1
//User-defined structure of FB_VFD_SEW_MOVI-C function block statistics.
   STRUCT
      PNSlaveNotOnline : "UDT_EventStatistic";   // Statistics of Profinet slave not online
      PNSlaveError : "UDT_EventStatistic";   // Statistics of a Profinet slave error
      VFDInternalError : "UDT_EventStatistic";   // Statistics of an internal VFD error
      CommunicationErrorMovikit : "UDT_EventStatistic";   // Statistics of a communication error
      Running : "UDT_EventStatistic";   // Statistics for running time
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_VfdNORDCommissioning"
TITLE = Block for parameterising NORD VFD
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 234
// END_ATTRIBUTES
   VAR_INPUT 
      ihw_HardwareID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_IO := 0;   // Device hardware ID
      iudt_MotorData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_MotorData";
      ir_ReferenceFrequency { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;
      ix_VFDReadyToRun { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Condition to start motor identyfication
   END_VAR

   VAR_OUTPUT 
      qi_HWAdress { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      qx_Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parametrisation in progress
      qx_Done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parametrisation done
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parametrisation error
      qx_24VCommissioningDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 24V commissioning done succesfully
   END_VAR

   VAR_IN_OUT 
      iqx_Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Input enable signal
   END_VAR

   VAR 
      sFB_ParaAcycRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_VfdNORDParaAcycRead";
      sFB_ParaAcycWrite { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_VfdNORDParaAcycWrite";
      sR_TRIG_Done {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_StartJob {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Bit for start trigger for rising edge
      sF_TRIG_CancelJob {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Bit for start trigger for falling edge
      sa_Parameter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Array[0..60] of "UDT_VfdNordParameter";   // Data of parameters
      sa_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Parametrization status
         StepNrError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // The number of the step in witch the error occurred
         ParameterNrError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // The number of the parameter in witch the error occurred
         StepNr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 0;   // Current step number
         ResponseValueError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Response value error
         WrongFormat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Wrong parameter format
         TimeExceeded { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Time has been exceeded
         NeedAck { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Need acknowledge signal (to cintinue parametrization)
         StepDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Step done
      END_STRUCT;
      si_StepTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_StepMax { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 0;   // Maximum step number
      sx_Start { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Signal to start of parameterization function SinaPara
      sx_Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parametrization in progress (busy)
      sx_Done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parametrization done
      sx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Main error signal
      sx_PreparedData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Step data prepared
      sx_ReadOrder { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Order to read paraeter with transition from 0 to 1
      sx_WriteOrder { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Order to write parameter with transition from 0 to 1
      sx_MaxStepCalculation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Maximum step calculated
   END_VAR
   VAR RETAIN
      sx_24VCommissioningDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 24V commissioning done succesfully
   END_VAR

   VAR_TEMP 
      ti_index : Int;   // Temporary array index
      ti_ControlMethod : Int;
      ti_EncoderCode : Int;
      ti_i : Int;   // Loop counter
      ti_BrakeReaction : Int;
   END_VAR

   VAR CONSTANT 
      ci_CFC_ClosedLoop : Int := 1;
      ci_CFC_OpenLoop : Int := 0;
      ci_EncoderRes512 : Int := 1;
      ci_EncoderRes1024 : Int := 3;
      ci_EncoderRes2048 : Int := 5;
      ci_EncoderRes4096 : Int := 6;
      ci_MaxStepTime : Int := 100;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	12/01/2020  | 0.1       | S.Theocharis  | Initial version TIA 15.1
	08/04/2021  | 0.2       | F.Baten       | New read/write blocks
	                                        | New motor parameter set ( most values not 32bit )
	                                        | PN device with onboard safety
	                                        | Reading and writing optimised
	27/01/2022  | 0.3       | K.Pokorski    | Add 24V and 400V commissionig status
	                                        | Fix VFD Output bug
	                                        | Initialize InUse status in all parameters
	                                        | Fix Motor identification
	                                        | Save parameters to External memory
	                                        | Delete saving F-parameters from sequence (not working and creating faults)
	                                        | Delete reading CRC code (reading old CRC code what can be confusing)
	21/04/2022  | 0.4       | K.Pokorski    | Delete motor identification
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	                                        
	*)
	
	REGION 1 - Start Job
	    
	    // Monitor rising trigger if is input enable signal
	    #sR_TRIG_StartJob(CLK := #iqx_Enable);
	    
	    IF (#sR_TRIG_StartJob.Q)
	    THEN
	        #sx_Start := TRUE;
	        #sx_Busy := TRUE;
	        #sx_Done := FALSE;
	        #sx_Error := FALSE;
	        #sx_PreparedData := FALSE;
	        #sx_MaxStepCalculation := FALSE;
	        #sa_Status.StepDone := FALSE;
	        #sa_Status.StepNrError := 0;
	        #sa_Status.ParameterNrError := 0;
	        #sa_Status.StepNr := 0;
	        #si_StepTime := 0;
	        #qi_HWAdress := 0;
	        
	        FOR #ti_i := 0 TO 60 DO
	            #sa_Parameter[#ti_i].InUse := FALSE;
	        END_FOR;
	        
	        
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Build Sequences in static memory
	    
	    IF #sR_TRIG_StartJob.Q THEN
	        //  IF NOT #sx_24VCommissioningDone THEN
	        REGION Step 01 - P523 Factory reset [0..3]           
	            #ti_index := 0;
	            #sa_Parameter[#ti_index].ParaNumber := 523;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := 1;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 02 - P003 Set supervisor code to access all parameters [0..9999]
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 3;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := 3;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 03 - P800 Set Operating mode Safety [0-1]
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 800;
	            #sa_Parameter[#ti_index].Index := 1;
	            #sa_Parameter[#ti_index].WriteValue := 1;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 04 - P800 Set Operating mode Safety [0-1]
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 800;
	            #sa_Parameter[#ti_index].Index := 2;
	            #sa_Parameter[#ti_index].WriteValue := 0;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 05 - P802 Set Enable safety channel [0-1]  Channel 1 on
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 802;
	            #sa_Parameter[#ti_index].Index := 1;
	            #sa_Parameter[#ti_index].WriteValue := 1;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 06 - P802 Set Enable safety channel [0-1]  Channel 2 on
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 802;
	            #sa_Parameter[#ti_index].Index := 2;
	            #sa_Parameter[#ti_index].WriteValue := 1;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 07 - P802 Set Enable safety channel [0-1]  Channel 3 on
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 802;
	            #sa_Parameter[#ti_index].Index := 3;
	            #sa_Parameter[#ti_index].WriteValue := 1;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 08 - P846 Read dipswitches 
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 846;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := 0;
	            #sa_Parameter[#ti_index].WriteAccess := FALSE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 09 - P120 Set extern control units [0-1]  Switch off 3 and 4
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 120;
	            #sa_Parameter[#ti_index].Index := 3;
	            #sa_Parameter[#ti_index].WriteValue := 0;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 10 - P120 Set extern control units [0-1]  Switch off 3 and 4
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 120;
	            #sa_Parameter[#ti_index].Index := 4;
	            #sa_Parameter[#ti_index].WriteValue := 0;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 11 - P202 Write motor nominal speed [150...24000]rpm
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 202;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := #iudt_MotorData.NominalSpeed;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 1; // Parameter set 1
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 12 - P203 Write motor nominal current [0.1 ...1000.0]A
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 203;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := (REAL_TO_DINT(#iudt_MotorData.NominalCurrent * 10));  // Value 55 = 5.5 Amps
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0; // Parameter set 1
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 13 - P204 Write motor nominal voltage [100 ... 800]V
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 204;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := #iudt_MotorData.NominalVoltage;
	            #sa_Parameter[#ti_index].WriteAccess := FALSE;
	            #sa_Parameter[#ti_index].ParaSet := 1; // Parameter set 1
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 14 - P205 Write motor nominal power 
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 205;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := (REAL_TO_DINT(#iudt_MotorData.NominalPower * 100));
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0; // Parameter set 1
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 15 - P206 Write motor cosPhi [0.50 ... 0.95]
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 206;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := REAL_TO_DINT(#iudt_MotorData.CosPhi * 100);
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0; // Parameter set 1
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 16 - P207 Connection Star / Delta [0=Star 1=Delta]
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 207;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := #iudt_MotorData.Connection;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0; // Parameter set 1
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 17 - P105 Write Maximum / Reference Frequency [0.1...400.0]Hz
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 105;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := REAL_TO_DINT(#ir_ReferenceFrequency * 10);
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0; // Parameter set 1
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 18 - P107 Brake reaction
	            IF #iudt_MotorData.BrakeConfig THEN
	                #ti_BrakeReaction := 20;
	            ELSE
	                #ti_BrakeReaction := 0;
	            END_IF;
	            
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 107;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := #ti_BrakeReaction;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0; // Parameter set 1
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 19 - P300 Mode [0..2]
	            //If an IE4 motor is operated in CFC closed loop mode , the slip error monitoring must be activated. P327<>0
	            IF #iudt_MotorData.EncoderResolution <> 0 THEN
	                #ti_ControlMethod := #ci_CFC_ClosedLoop; //CFC closed loop control. Speed control with encoder feedback
	            ELSE
	                #ti_ControlMethod := #ci_CFC_OpenLoop; //VFC open loop control. Speed control without encoder feedback
	            END_IF;
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 300;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := #ti_ControlMethod;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 1; // Parameter set 1
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 20 - P301 Encoder Resolution [0..17]
	            CASE #iudt_MotorData.EncoderResolution OF
	                512:
	                    #ti_EncoderCode := #ci_EncoderRes512;
	                1024:
	                    #ti_EncoderCode := #ci_EncoderRes1024;
	                2048:
	                    #ti_EncoderCode := #ci_EncoderRes2048;
	                4096:
	                    #ti_EncoderCode := #ci_EncoderRes4096;
	                ELSE
	                    #ti_EncoderCode := 6; //default value
	            END_CASE;
	            
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 301;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := #ti_EncoderCode;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 21 - P326 Encoder ratio [0.01 ... 100.0]
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 326;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := (1 * 100); //leave temporary the default 1.00;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 22 - P420[1] Digital inputs [0 ... 80] DI1
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 420;
	            #sa_Parameter[#ti_index].Index := 1;
	            #sa_Parameter[#ti_index].WriteValue := 0;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 23 - P420[2] Digital inputs [0 ... 80] DI2
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 420;
	            #sa_Parameter[#ti_index].Index := 2;
	            #sa_Parameter[#ti_index].WriteValue := 0;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 24 - P420[3] Digital inputs [0 ... 80] DI3
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 420;
	            #sa_Parameter[#ti_index].Index := 3;
	            #sa_Parameter[#ti_index].WriteValue := 0;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 25 - P426 Quick Stop time [0 ... 320.00] sec
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 426;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := 60;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 1; //paraset 1
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 26 - P509 Control word source [0..4]
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 509;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := 3; // System bus communication (PN)
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 27 - P543[1] Actual speed to actual value 1 [0..57]
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 543;
	            #sa_Parameter[#ti_index].Index := 1;
	            #sa_Parameter[#ti_index].WriteValue := 1; // 2 = Set Actual value 1 to actual speed
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 1; // Parameter set 1
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 28 - P543[2] Error code to actual value 2 [0..57]
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 543;
	            #sa_Parameter[#ti_index].Index := 2;
	            #sa_Parameter[#ti_index].WriteValue := 9; // 9 =  Set Actual value 2 to error code
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 1; // Parameter set 1
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 29 - P543[3] DIO status to actual value 3 [0..57]
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 543;
	            #sa_Parameter[#ti_index].Index := 3;
	            #sa_Parameter[#ti_index].WriteValue := 5; // 5 =  Set Actual value 3 to DIO status
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 1; // Parameter set 1
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 30 - P546[1] Frequency setpoint to setpoint 1 [0..36]
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 546;
	            #sa_Parameter[#ti_index].Index := 1;
	            #sa_Parameter[#ti_index].WriteValue := 1; // 5 =  Set setpoint 1 to frequency setpoint
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 1; // Parameter set 1
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 31 - P546[2] Ramp setpoint to setpoint 2 [0..36]
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 546;
	            #sa_Parameter[#ti_index].Index := 2;
	            #sa_Parameter[#ti_index].WriteValue := 15; // 15 =  Set setpoint 2 to ramp setpoint
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 1; // Parameter set 1
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 32 - P546[3] DO control to setpoint 3 [0..36]
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 546;
	            #sa_Parameter[#ti_index].Index := 3;
	            #sa_Parameter[#ti_index].WriteValue := 31; // 5 =  Set setpoint 3 to DIO
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 1; // Parameter set 1
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 33 - P434[3] DO Function [1..2]
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 434;
	            #sa_Parameter[#ti_index].Index := 1;
	            #sa_Parameter[#ti_index].WriteValue := 38;
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 1; // Parameter set 1
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 34 - P560 Save [0..2]
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 560;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := 1; // 1= save RAM & EERPOM
	            #sa_Parameter[#ti_index].WriteAccess := TRUE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	        
	        REGION Step 35 - P550 Copy internal EEPROM to external EEPROM [0..3]
	            #ti_index := #ti_index + 1;
	            #sa_Parameter[#ti_index].ParaNumber := 550;
	            #sa_Parameter[#ti_index].Index := 0;
	            #sa_Parameter[#ti_index].WriteValue := 2; // 2 = Copy internal to external EEPROM 
	            #sa_Parameter[#ti_index].WriteAccess := FALSE;
	            #sa_Parameter[#ti_index].ParaSet := 0;
	            #sa_Parameter[#ti_index].Format32 := FALSE;
	            #sa_Parameter[#ti_index].ActualValue := 0;
	            #sa_Parameter[#ti_index].InUse := TRUE;
	            #sa_Parameter[#ti_index].RamOnly := FALSE;
	        END_REGION
	    END_IF;
	    
	    (* IF #ix_VFDReadyToRun AND #sx_24VCommissioningDone THEN
	         REGION Step 39 - P220 Measurement [0..2]
	             #ti_index := 0;
	             #sa_Parameter[#ti_index].ParaNumber := 220;
	             #sa_Parameter[#ti_index].Index := 0;
	             #sa_Parameter[#ti_index].WriteValue := 2; // 2 =  Motor identification
	             #sa_Parameter[#ti_index].WriteAccess := TRUE;
	             #sa_Parameter[#ti_index].ParaSet := 1;
	             #sa_Parameter[#ti_index].Format32 := FALSE;
	             #sa_Parameter[#ti_index].ActualValue := 0;
	             #sa_Parameter[#ti_index].InUse := TRUE;
	             #sa_Parameter[#ti_index].RamOnly := FALSE;
	         END_REGION
	         
	         REGION Step 40 - P220 Read if measurement started
	             #ti_index := #ti_index + 1;
	             #sa_Parameter[#ti_index].ParaNumber := 220;
	             #sa_Parameter[#ti_index].Index := 0;
	             #sa_Parameter[#ti_index].WriteValue := 0;
	             #sa_Parameter[#ti_index].WriteAccess := FALSE;
	             #sa_Parameter[#ti_index].ParaSet := 1;
	             #sa_Parameter[#ti_index].Format32 := FALSE;
	             #sa_Parameter[#ti_index].ActualValue := 0;
	             #sa_Parameter[#ti_index].InUse := TRUE;
	             #sa_Parameter[#ti_index].RamOnly := FALSE;
	         END_REGION
	         
	         REGION Step 41 - P220 Read if measurement finished
	             #ti_index := #ti_index + 1;
	             #sa_Parameter[#ti_index].ParaNumber := 220;
	             #sa_Parameter[#ti_index].Index := 0;
	             #sa_Parameter[#ti_index].WriteValue := 0;
	             #sa_Parameter[#ti_index].WriteAccess := FALSE;
	             #sa_Parameter[#ti_index].ParaSet := 1;
	             #sa_Parameter[#ti_index].Format32 := FALSE;
	             #sa_Parameter[#ti_index].ActualValue := 0;
	             #sa_Parameter[#ti_index].InUse := TRUE;
	             #sa_Parameter[#ti_index].RamOnly := FALSE;
	         END_REGION
	         
	         
	         REGION Step 42 - P560 Save [0..2] (Step 39 - without motor identification)
	             #ti_index := #ti_index + 1;
	             #sa_Parameter[#ti_index].ParaNumber := 560;
	             #sa_Parameter[#ti_index].Index := 0;
	             #sa_Parameter[#ti_index].WriteValue := 1; // 1= save RAM & EERPOM
	             #sa_Parameter[#ti_index].WriteAccess := TRUE;
	             #sa_Parameter[#ti_index].ParaSet := 0;
	             #sa_Parameter[#ti_index].Format32 := FALSE;
	             #sa_Parameter[#ti_index].ActualValue := 0;
	             #sa_Parameter[#ti_index].InUse := TRUE;
	             #sa_Parameter[#ti_index].RamOnly := FALSE;
	         END_REGION
	         
	         REGION Step 43 - P550 Copy internal EEPROM to external EEPROM [0..3] (Step 40 - without motor identification)
	             #ti_index := #ti_index + 1;
	             #sa_Parameter[#ti_index].ParaNumber := 550;
	             #sa_Parameter[#ti_index].Index := 0;
	             #sa_Parameter[#ti_index].WriteValue := 2; // 2 = Copy internal to external EEPROM 
	             #sa_Parameter[#ti_index].WriteAccess := FALSE;
	             #sa_Parameter[#ti_index].ParaSet := 0;
	             #sa_Parameter[#ti_index].Format32 := FALSE;
	             #sa_Parameter[#ti_index].ActualValue := 0;
	             #sa_Parameter[#ti_index].InUse := TRUE;
	             #sa_Parameter[#ti_index].RamOnly := FALSE;
	         END_REGION
	         #sx_MotorMeasurement := TRUE;
	         
	     END_IF; *)
	    
	    // END_IF;
	    
	END_REGION
	
	REGION 3 - Cancel job
	    
	    // Monitor falling trigger if is input enable signal
	    #sF_TRIG_CancelJob(CLK := #iqx_Enable);
	    
	    IF (#sF_TRIG_CancelJob.Q)
	    THEN
	        // IF parametrization is NOT done
	        IF (NOT #sx_Done)
	        THEN
	            
	            #sx_Error := TRUE;
	            #sx_ReadOrder := FALSE;
	            #sx_WriteOrder := FALSE;
	            #sFB_ParaAcycWrite.qx_Done := FALSE;
	            #sx_Start := FALSE;
	            #sx_Busy := FALSE;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Caclulaton used step in the sequence
	    // If maximum step is not calculated and input enable signal 
	    IF (NOT #sx_MaxStepCalculation
	        AND #iqx_Enable)
	    THEN
	        
	        // Create loop from maximum step number = 1 to 80
	        FOR #si_StepMax := 1 TO 80 DO
	            
	            IF (NOT #sa_Parameter[#si_StepMax].InUse)   // If step commissioning is not used in sequence
	            THEN
	                #sx_MaxStepCalculation := TRUE;
	                EXIT;
	            END_IF;
	        END_FOR;
	    END_IF;
	END_REGION
	
	REGION 5 - Prepare data
	    
	    IF (#sx_Start                                       // If occurs: signal to start of parametrization 
	        AND NOT #sx_PreparedData                        // And step data is not prepared 
	        AND NOT #sa_Status.StepDone                      // And parametrization is not done 
	        AND #iqx_Enable)                                // And input enable signal 
	    THEN
	        
	        #sx_WriteOrder := #sa_Parameter[#sa_Status.StepNr].WriteAccess;
	        #sx_ReadOrder := NOT #sa_Parameter[#sa_Status.StepNr].WriteAccess;
	        #sx_PreparedData := TRUE;
	        
	    END_IF;
	END_REGION
	
	REGION 6 - Call write parameter block
	    
	    IF #sx_WriteOrder AND #sx_PreparedData THEN
	        #sFB_ParaAcycWrite(HW_Identifier := #ihw_HardwareID,
	                           idi_Value := #sa_Parameter[#sa_Status.StepNr].WriteValue,
	                           ii_ParameterNumber := #sa_Parameter[#sa_Status.StepNr].ParaNumber,
	                           ii_ParameterIndex := #sa_Parameter[#sa_Status.StepNr].Index,
	                           ii_ParameterSet := #sa_Parameter[#sa_Status.StepNr].ParaSet,
	                           ix_Parameter32Bit := #sa_Parameter[#sa_Status.StepNr].Format32,
	                           ix_RAM_Only := #sa_Parameter[#sa_Status.StepNr].RamOnly,
	                           ix_Execute := NOT #sFB_ParaAcycWrite.qx_Done,
	                           qx_Done => #sFB_ParaAcycWrite.qx_Done,
	                           qx_Busy => #sFB_ParaAcycWrite.qx_Busy,
	                           qx_Error => #sFB_ParaAcycWrite.qx_Error,
	                           qdi_ValueRead => #sa_Parameter[#sa_Status.StepNr].ActualValue,
	                           qw_ErrorID => #sFB_ParaAcycWrite.qw_ErrorID);
	        
	        #sR_TRIG_Done(CLK := #sFB_ParaAcycWrite.qx_Done);
	    END_IF;
	END_REGION
	
	REGION 7 - Call read parameter block 
	    
	    IF #sx_ReadOrder AND #sx_PreparedData THEN
	        #sFB_ParaAcycRead(iHW_Identifier := #ihw_HardwareID,
	                          ix_Enable := TRUE,
	                          ii_Parameter_Number := #sa_Parameter[#sa_Status.StepNr].ParaNumber,
	                          ii_Parameter_Index := #sa_Parameter[#sa_Status.StepNr].Index,
	                          ii_Parameter_Set := #sa_Parameter[#sa_Status.StepNr].ParaSet,
	                          qx_Valid => #sFB_ParaAcycRead.qx_Valid,
	                          qx_Busy => #sFB_ParaAcycRead.qx_Busy,
	                          qx_Error => #sFB_ParaAcycRead.qx_Error,
	                          qw_Error_ID => #sFB_ParaAcycRead.qw_Error_ID,
	                          qdi_Value => #sFB_ParaAcycRead.qdi_Value);
	    END_IF;
	END_REGION
	
	REGION 8 - Status commissioning
	    
	    REGION 8.1 Step number error
	        
	        IF (#sx_WriteOrder AND #sFB_ParaAcycWrite.qx_Error)
	            OR
	            (#sx_ReadOrder AND #sFB_ParaAcycRead.qx_Error)
	            OR #sa_Status.TimeExceeded
	        THEN
	            #sx_Start := FALSE;
	            #sx_Error := TRUE;
	            #sx_Done := FALSE;
	            
	            #sx_WriteOrder := FALSE;
	            #sx_ReadOrder := False;
	            #sa_Status.StepNrError := #sa_Status.StepNr;
	        END_IF;
	    END_REGION
	    
	    
	    REGION 8.2 - Read done
	        
	        IF #sx_ReadOrder
	            AND NOT #sFB_ParaAcycRead.qx_Busy
	            AND NOT #sFB_ParaAcycRead.qx_Error
	            AND #sFB_ParaAcycRead.qx_Valid
	            
	        THEN
	            
	            #sa_Status.StepDone := TRUE;
	            #sx_ReadOrder := FALSE;
	            #sa_Parameter[#sa_Status.StepNr].ActualValue := DINT_TO_INT(#sFB_ParaAcycRead.qdi_Value);
	            
	            IF #sa_Parameter[#sa_Status.StepNr].ParaNumber = 846
	            THEN
	                #qi_HWAdress := DINT_TO_INT(#sFB_ParaAcycRead.qdi_Value);
	            END_IF;
	            
	        END_IF;
	    END_REGION
	    
	    
	    REGION 8.3 - Write done
	        
	        IF #sx_WriteOrder
	            AND NOT #sFB_ParaAcycWrite.qx_Error
	            AND #sR_TRIG_Done.Q
	        THEN
	            #sa_Status.StepDone := TRUE;
	            #sx_WriteOrder := FALSE;
	            #sFB_ParaAcycWrite.qx_Done := FALSE;
	        END_IF;
	    END_REGION
	    
	    REGION 8.4 - Step time watchdog
	        // the function is too long active
	        IF #iqx_Enable AND "DB_Memory"."OS_0.1sec"
	        THEN
	            #si_StepTime += 1;
	        END_IF;
	        IF (#si_StepTime > #ci_MaxStepTime)
	        THEN
	            #sa_Status.TimeExceeded := TRUE;
	        ELSE
	            #sa_Status.TimeExceeded := FALSE;
	        END_IF;
	    END_REGION
	END_REGION
	
	REGION 9 - Go to next step
	    
	    IF #iqx_Enable
	        AND #sa_Status.StepDone
	        AND "DB_Memory".OS_2sec
	    THEN
	        #sx_PreparedData := FALSE;
	        #sa_Status.StepDone := FALSE;
	        #sa_Status.StepNr += 1;
	        #si_StepTime := 0;
	    END_IF;
	END_REGION
	
	REGION 10 - Commissioning done
	    
	    IF (#si_StepMax <= #sa_Status.StepNr
	        AND #iqx_Enable)
	    THEN
	        #iqx_Enable := FALSE;
	        #sx_Done := TRUE;
	        #sx_Start := FALSE;
	        #sx_Busy := FALSE;
	        #sx_24VCommissioningDone := TRUE;
	        
	    END_IF;
	END_REGION
	
	REGION 11 - Write output
	    
	    #qx_Busy := #sx_Busy;
	    #qx_Done := #sx_Done;
	    #qx_Error := #sx_Error;
	    #qx_24VCommissioningDone := #sx_24VCommissioningDone;
	    
	END_REGION
	
	
END_FUNCTION_BLOCK

TYPE "UDT_CaljanSend"
VERSION : 0.1
   STRUCT
      PEC_Override { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True if passage of parcels through PEC is allowed. (HMI)
      AllowLoading { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True if belt start in loading mode is allowed
      AllowUnloading { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True if belt start in unloading mode is allowed
      Reset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset error and safety command
      "Spare_Q0.4" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Spare Bit 4
      "Spare_Q0.5" : Bool := FALSE;   // Spare Bit 5
      "Spare_Q0.6" : Bool := FALSE;   // Spare Bit 6
      "Spare_Q0.7" : Bool := FALSE;   // Spare Bit 7
      Spare_QB1 : Byte;   // Spare Byte 1
      Spare_QW2 : Word;   // Spare Word 2
      Spare_QW4 : Word := 16#0000;   // Spare Word 4
      Spare_QW6 : Word := 16#0000;   // Spare Word 6
   END_STRUCT;

END_TYPE

TYPE "UDT_CaljanStatus"
TITLE = UDT_UnloaderStatus
VERSION : 0.1
//User-defined structure of FB_Unloader function block status.
   STRUCT
      Status : Int;   // Status number
      Specific : Struct   // Equipment specific warnings and errors
         PEC_EoS : "UDT_PECStatus";   // PEC status structure
         PNSlaveNotOnline { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet slave is not online
         PNSlaveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet slave is in error
         PNSlaveWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet slave has  a warning
         Disabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Unloader is disabled by HMI
         TooLongParcel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Unloader detected a too long parcel
         VFDError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Unloader has an VFD error
         NotHealthy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Unloader is not healthy
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_AixZpaFullIN"
VERSION : 0.1
   STRUCT
      LocalUpstreamZoneStatus_Rev { ExternalVisible := 'False'} : Byte;   // Local upstream Zone's status when the conveyor is running in opposite to configured direction
      LocalUpstreamZoneStatus_Fwd { ExternalVisible := 'False'} : Byte;   // Local upstream Zone's status when the conveyor is running in configured direction
      LocalDownstreamZoneStatus_Rev { ExternalVisible := 'False'} : Byte;   // Local downstream Zone's status when the conveyor is running in opposite to configured direction
      LocalDownstreamZoneStatus_Fwd { ExternalVisible := 'False'} : Byte;   // Local downstream Zone's status when the conveyor is running in configured direction
      ArrivalCountUpstreamZone { ExternalVisible := 'False'} : Int;   // Count incremented upon each new arrival
      DepartureCountUpstreamZone { ExternalVisible := 'False'} : Int;   // Count incremented upon each release
      ArrivalCountDownstreamZone { ExternalVisible := 'False'} : Int;   // Count incremented upon each new arrival
      DepartureCountDownstreamZone { ExternalVisible := 'False'} : Int;   // Count incremented upon each release
      Diagnostic { ExternalVisible := 'False'} : Struct   // 32 bit diagnostic field. When bits are set the error is active
         LeftMotorOverheat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left motor temperature has exceeded 105 degrees Celsius
         LeftMotorMaxTorque { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left motor is running with maximum torque output
         LeftMotorShort { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left motor short circuit
         LeftMotorNotConn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left motor is not connected
         LeftMotorOverload { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left motor overloaded after more than 20 seconds in Stalled
         LeftMotorStalled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left motor stalled and speed is less than 10% of the set speed
         LeftMotorBadHall { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left motor Hall Efect Sensor error active
         LeftMotorNotUsed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left motor is not used
         ModuleResetFlag { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Index06Bit01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         OverVoltage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Supply voltage + Left motor back EMF exceeded 30 volts
         LeftMotorAnyErr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Any Left motor error active
         ConnectionsNotOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Ethernet connection error
         UpstreamJamErr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Jam error active on Upstream zone
         LeftSensLowGain { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left sensor error
         LowVoltage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Module power supply is less than 18 Volts
         RightMotorOverheat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right motor temperature has exceeded 105 degrees Celsius
         RightMotorMaxTorque { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right motor is running with maximum torque output
         RightMotorShort { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right motor short circuit
         RightMotorNotConn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right motor is not connected
         RightMotorOverload { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right motor overloaded after more than 20 seconds in Stalled
         RightMotorStalled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right motor is stalled and speed is less than 10% of the set speed
         RightMotorBadHall { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right motor Hall Efect Sensor error active
         RightMotorNotUsed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right motor is not used
         Index07Bit00 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Index07Bit01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         OverVoltage1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Supply voltage + Right motor back EMF exceeded 30 volts
         RightMotorAnyErr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Any Right motor error active
         Index07Bit04 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         DownstreamJamErr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Jam error active on Downstream zone
         RightSensLowGain { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right sensor error
         LowVoltage1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Module power supply is less than 18 Volts
      END_STRUCT;
      TrackingUpstreamZone { ExternalVisible := 'False'} : DWord;   // The Tracking data of the product currently on this zone
      TrackingDownstreamZone { ExternalVisible := 'False'} : DWord;   // The Tracking data of the product currently on this zone
      ReleaseCounterUpstreamZone { ExternalVisible := 'False'} : Int;   // Current value of the 'SetReleaseCountUpstream' output
      ReleaseCounterDownstreamZone { ExternalVisible := 'False'} : Int;   // Current value of the 'SetReleaseCountDownstream' output
      GetDischargeTracking_Fwd { ExternalVisible := 'False'} : DWord;   // Tracking data of just discharged item when running in configured direction
      GetDischargeTracking_Rev { ExternalVisible := 'False'} : DWord;   // Tracking data of just discharged item when running in opposite of configured direction
      AllSensorPortInputs { ExternalVisible := 'False'} : Struct   // Left and Right Sensor Port inputs
         Bit08 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit09 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit10 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit11 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit12 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit13 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit14 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Heartbeat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // This bit toggles every 2 seconds
         LeftPin2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left sensor port state (Pin2)
         Bit01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         RightPin2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right sensor port state (Pin2)
         Bit03 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         LeftSensor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left sensor port state (Pin4)
         Bit05 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         RightSensor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right sensor port state (Pin4)
         Bit07 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
      END_STRUCT;
      Index19 { ExternalVisible := 'False'} : Word;   // Reserved
      ConveyStopStatus { ExternalVisible := 'False'} : Struct   // Status of ConveyStop
         Bit08 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit09 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         StopActiveCommandPLC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stop active due to stop command from the PLC
         Bit11 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit12 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit13 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit14 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit15 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit00 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit02 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit03 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit04 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         StopActiveOtherModule { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stop condition is active on a module in the ConveyStop group
         StopActiveLostConn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stop is active due to a loss of communication connection
         StopActiveLostPLC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stop active due to a loss of connection with the PLC
      END_STRUCT;
      Future { ExternalVisible := 'False'} : Array[21..30] of Int;
      GeneralLineError : Struct
         Reserved0 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Reserved1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Reserved2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Reserved3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Reserved4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Reserved5 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Reserved6 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Reserved7 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         MotorError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // There is a motor error somewhere upstream
         ConnectionError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // There is a connection error somewhere upstream
         JamError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // There is a Jam error somewhere upstream
         SensorDetectError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // There is a Sensor detect error somewhere upstream
         Reserved12 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Reserved13 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Reserved14 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Reserved15 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_CaljanReceive"
VERSION : 0.1
   STRUCT
      Healthy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True if (un)loader is healthy
      BeltDirection_Loading { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True if belt is running in loading mode
      BeltDirection_Unloading { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True if belt is running in unloading mode
      ReadyToReceive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True if loader is ready to receive
      HoldReverseSignal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True when reverse button is pressed (only applicable to unloaders)
      ResetReverse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True when reset reverse button is pressed (only applicable to unloaders)
      PECUnloader { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True when no parcels are detected (fail safe)
      "Spare_I0.7" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Spare Bit 7
      Spare_IB1 : Byte;   // Spare Byte 1
      ActualSpeed : Int;   // Actual speed [mm/s]
      Spare_IW4 : Word;   // Spare Word 3
      Spare_IW6 : Word;   // Spare Word 4
   END_STRUCT;

END_TYPE

TYPE "UDT_AixZpaFullOUT"
VERSION : 0.1
   STRUCT
      InductTrackingOnUpstreamZone { ExternalVisible := 'False'} : DWord;   // Writes the tracking data of the product currently on the zone when ReleaseControlUpstream is incremented by 1
      InductTrackingOnDownstreamZone { ExternalVisible := 'False'} : DWord;   // Writes the tracking data of the product currently on the zone when ReleaseControlDownstream is incremented by 1
      AccumulateControlUpstream { ExternalVisible := 'False'} : Struct
         AccumUpstreamToThisZone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Accumulates the Upstream zone relative to this zone
         SetArrival { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Simulate downstream arrival to prevent Arrival Jam
         JogDefaultDir { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Jog zone in default direction
         JogOppDir { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Jog zone in opposite of default direction
         WakeUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Wake Up Local Upstream Zone
         MaintMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Enable Maintenance Mode
         Bit14 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit15 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Accumulate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Accumulates this local zone
         Bit01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit02 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit03 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit04 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit05 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit06 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit07 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
      END_STRUCT;
      AccumulateControlDownstream { ExternalVisible := 'False'} : Struct
         AccumUpstreamToThisZone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Accumulates the Upstream zone relative to this zone
         SetArrival { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Simulate downstream arrival to prevent Arrival Jam
         JogDefaultDir { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Jog zone in default direction
         JogOppDir { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Jog zone in opposite of default direction
         WakeUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Wake Up Local Downstream Zone
         MaintMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Enable Maintenance Moded
         Bit14 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit15 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Accumulate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Accumulates this local zone
         Bit01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit02 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit03 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit04 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit05 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit06 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit07 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
      END_STRUCT;
      SetSpeedLeftMotor { ExternalVisible := 'False'} : Int;   // Speed setting for Left motor in mm/s(or 1/10 of an RPM for PGD)
      SetSpeedRightMotor { ExternalVisible := 'False'} : Int;   // Speed setting for the Right motor in mm/s(or 1/10 of an RPM for PGD)
      SetReleaseCountUpstream { ExternalVisible := 'False'} : Int;   // Changing the value causes the Upstream zone to release the current product
      SetReleaseCountDownstream { ExternalVisible := 'False'} : Int;   // Changing the value causes the Downstream zone to release the current product
      SetInductStatus { ExternalVisible := 'False'} : Word;   // Used as a "Wake up" signal - Write '4' to wake up, write 1 to stop wake up
      SetDishargeStatus { ExternalVisible := 'False'} : Word;   // Used as a "Lane full" signal. Write '5' to accumulate, write 1 to allow release
      SetInductTrackingFwd { ExternalVisible := 'False'} : DWord;   // Assign this data to next arrival when in fwd direction
      SetInductTrackingRev { ExternalVisible := 'False'} : DWord;   // Assign this data to next arrival when in rev direction
      ClearMotorError { ExternalVisible := 'False'} : Word;   // Write '1" to clear motor error - Write '0' to resume
      Index17 { ExternalVisible := 'False'} : Word;   // Reserved
      Index18 { ExternalVisible := 'False'} : Word;   // Reserved
      ConveyStopControl { ExternalVisible := 'False'} : Word;   // Write '1' to STOP the group, write 2 to clear STOP. Transition 0 - 2 is needed to clear the Stop
      ClearJamUpstream { ExternalVisible := 'False'} : Word;   // Write '1' to clear zone jam
      ClearJamDownstream { ExternalVisible := 'False'} : Word;   // Write '1' to clear zone jam
      GlobalDirAccModeUpstr { ExternalVisible := 'False'} : Word;   // Used to change direction of flow or accumulation mode for a continuous group of zones beginning with the local zone
      GlobalDirAccModeDnstr { ExternalVisible := 'False'} : Word;   // Used to change direction of flow or accumulation mode for a continuous group of zones beginning with the local zone
      Future { ExternalVisible := 'False'} : Array[24..31] of Int;
   END_STRUCT;

END_TYPE

TYPE "UDT_ConveyorStatus"
TITLE = UDT_ConveyorStatus
VERSION : 0.1
//User-defined structure of FB_Conveyor function block status.
   STRUCT
      Status : Int;   // Status number
      Specific : Struct
         Reverse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor is running in reverse direction
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_CaljanConfiguration"
TITLE = UDT_UnloaderConfiguration
VERSION : 0.1
//User-defined structure of unloader parameters.
   STRUCT
      PEC_EOS : "UDT_PECConfiguration";   // Photo eye time on delay
      Forward_Direction : Struct   // Forward Direction configuration
         GapHeadToHead : DInt;   // Gapping head to head value [cm]
         GapTailToHead : DInt;   // Gapping tail to head value [cm]
         GapCorrection : DInt;   // Gap offset to cover VFD's ramps [cm]
      END_STRUCT;
      PNDeviceName : String;   // VFD's Profinet device name
      Speedsetpoint : Int;   // Speedsetpoint: 0=Low, 1=Nom, 2=High
      EnergySaveLength : Int;   // Distance conveyor traveled before energy save activate [cm]
      FirstConveyorToStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // First conveyor to start cascade mode
      Energy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Energy save mode enable
      ResetDelay : UDInt := 1000;   // Time required
      CaljanMode : Int;   // Choosing device 1=loader, 2=unloader
      CascadeTimeOnDelay : UDInt;   // Cascade time on delay [ms]
   END_STRUCT;

END_TYPE

TYPE "UDT_ConveyorCommand"
TITLE = UDT_ConveyorCommand
VERSION : 0.1
//User-defined structure of conveyor commands.
   STRUCT
      ManualMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual mode command from HMI
      ManualStartStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Run conveyor in manual mode
      ManualFullSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Full speed conveyor in manual mode
      ManualJog { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command to jog conveyor in slow speed from HMI
      Reverse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command to run conveyor in reverse direction from HMI
      ManualSpeed : Int := 50;   // Manual mode speed as percentage of nominal speed [0-100%]
   END_STRUCT;

END_TYPE

TYPE "UDT_Interface_Signal"
VERSION : 0.1
   STRUCT
      RQST { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request to activate
      CMD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request is Active and thus commanded
   END_STRUCT;

END_TYPE

TYPE "UDT_UnloaderStatus"
TITLE = UDT_UnloaderStatus
VERSION : 0.1
//User-defined structure of FB_Unloader function block status.
   STRUCT
      Status : Int;   // Status number
      Specific : Struct   // Equipment specific warnings and errors
         PEC_EoS : "UDT_PECStatus";   // PEC status structure
         Disabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Unloader is disabled by HMI
         TooLongParcel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Unloader detected a too long parcel
         VFDError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Unloader has an VFD error
         NotHealthy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Unloader is not healthy
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_PNNodeStatus"
VERSION : 0.1
   STRUCT
      Status : Int;   // Status number
      Specific : Struct   // Specific structure
         PNSlaveNotOnline { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet slave is not online
         PNSlaveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet slave is in error
         PNSlaveWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet slave has  a warning
      END_STRUCT;
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_AMBASpiralChainCheck"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 256
// END_ATTRIBUTES
   VAR_INPUT 
      ix_ProxSwitchDriveShaft { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Proximity switche signal drive shaft
      ix_ProxSwitchIdlerShaft { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Proximity switche signal idler shaft
      ix_HardwareOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when hardware is ok
   END_VAR

   VAR_IN_OUT 
      iqx_BrokenChainDetected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // [Failure] Broken chain detected (TRUE = detected)
      iqx_ChainOverlengthDetected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // [Warning] Chain overlength detected (TRUE = detected)
      iqUDT_BrokenChainStatistics : "UDT_EventStatistic";   // Statistics of broken chain event
      iqUDT_ChainOverlengthStatistics : "UDT_EventStatistic";   // Statistics of missing slat event
      iqUDT_EquipmentControl : "UDT_EquipmentControl";
   END_VAR

   VAR 
      sFB_SignalFilter_DriveShaft { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // On/Off delay to filter the input signal
      sFB_SignalFilter_IdlerShaft { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // On/Off delay to filter the input signal
      sR_TRIG_DriveShaft {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_IdlerShaft {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_ChainOverlength {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_BrokenChain {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      si_PulseCounterDriveShaft { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Counter drive shaft pulses
      sx_IdlerShaftPulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR CONSTANT 
      cudi_OffDelay : UDInt := 25;   // [ms]
      cudi_OnDelay : UDInt := 25;   // [ms]
   END_VAR


BEGIN
	(*                                                                             
	Version history:
	Date        | Version   | Author              | Remark
	----------------------------------------------------------------------------------------
	 14/03/2022 | 1.0       | G.Vlooswijk         | Initial version for FedEx Milano
	 16/05/2022 | 1.1       | G.Vlooswijk         | Tested (logic) GLS Tongeren
	 03/06/2024 | 1.2       | J.Majer             | Adapted to current library
	*)
	
	REGION Input signals
	    
	    //Filter signals
	    #sFB_SignalFilter_DriveShaft(iudi_OnDelayTime := #cudi_OnDelay,
	                                 iudi_OffDelayTime := #cudi_OffDelay,
	                                 ix_SignalToDelay := #ix_ProxSwitchDriveShaft);
	    
	    #sFB_SignalFilter_IdlerShaft(iudi_OnDelayTime := #cudi_OnDelay,
	                                 iudi_OffDelayTime := #cudi_OffDelay,
	                                 ix_SignalToDelay := #ix_ProxSwitchIdlerShaft);
	    
	    //Flank detection
	    #sR_TRIG_DriveShaft(CLK := #sFB_SignalFilter_DriveShaft.qx_DelayedSignal);
	    
	    #sR_TRIG_IdlerShaft(CLK := #sFB_SignalFilter_IdlerShaft.qx_DelayedSignal);
	    
	END_REGION
	
	REGION Broken chain logic
	    
	    IF #sR_TRIG_DriveShaft.Q THEN
	        #si_PulseCounterDriveShaft += 1;
	    END_IF;
	    
	    IF #sR_TRIG_IdlerShaft.Q THEN
	        #si_PulseCounterDriveShaft := 0;
	    END_IF;
	    
	    //Set fault
	    IF #si_PulseCounterDriveShaft > 2 AND #ix_HardwareOK THEN
	        #iqx_BrokenChainDetected := TRUE;
	    END_IF;
	    
	    //Reset fault
	    IF #iqx_BrokenChainDetected AND NOT #ix_HardwareOK
	        OR #iqx_BrokenChainDetected AND #iqUDT_EquipmentControl.Command.Reset
	    THEN
	        #iqx_BrokenChainDetected := FALSE;
	        #si_PulseCounterDriveShaft := 0;
	    END_IF;
	    
	END_REGION
	
	(* Chain overlength is detected when the drive shaft pulse is not active during the whole Idler shaft pulse. *)
	REGION Chain overlength logic
	    
	    //Set mememory bit on rising flank Iderler shaft pulse
	    IF #sR_TRIG_IdlerShaft.Q THEN
	        #sx_IdlerShaftPulse := TRUE;
	    END_IF;
	    
	    //Reset memory bit when both signals are high
	    IF #sFB_SignalFilter_DriveShaft.qx_DelayedSignal
	        AND #sFB_SignalFilter_IdlerShaft.qx_DelayedSignal
	        AND #sx_IdlerShaftPulse
	    THEN
	        #sx_IdlerShaftPulse := FALSE;
	    END_IF;
	    
	    //Set warning
	    IF #sx_IdlerShaftPulse
	        AND NOT #sFB_SignalFilter_IdlerShaft.qx_DelayedSignal
	        AND #ix_HardwareOK
	    THEN
	        #iqx_ChainOverlengthDetected := TRUE;
	    END_IF;
	    
	    //Reset warning
	    IF #iqx_ChainOverlengthDetected
	        AND (NOT #ix_HardwareOK
	        OR #iqUDT_EquipmentControl.Command.Reset)
	    THEN
	        #iqx_ChainOverlengthDetected := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION Statistics
	    
	    REGION Broken chain
	        
	        #sR_TRIG_BrokenChain(CLK := #iqx_BrokenChainDetected);
	        
	        IF #iqx_BrokenChainDetected
	            OR #iqUDT_EquipmentControl.Command.ResetData
	        THEN
	            "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                            ix_Activate := #iqx_BrokenChainDetected,
	                            ix_RTrigActivate := #sR_TRIG_BrokenChain.Q,
	                            iqUDT_Statistics := #iqUDT_BrokenChainStatistics);
	        END_IF;
	        
	    END_REGION
	    
	    REGION Chain overlength
	        
	        #sR_TRIG_ChainOverlength(CLK := #iqx_ChainOverlengthDetected);
	        
	        IF #iqx_ChainOverlengthDetected
	            OR #iqUDT_EquipmentControl.Command.ResetData
	        THEN
	            "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                            ix_Activate := #iqx_ChainOverlengthDetected,
	                            ix_RTrigActivate := #sR_TRIG_ChainOverlength.Q,
	                            iqUDT_Statistics := #iqUDT_ChainOverlengthStatistics);
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION "FC_Fifo" : Void
TITLE = FC_Fifo
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 17
// END_ATTRIBUTES
//Function for controlling FIFO register.
   VAR_INPUT 
      ic_Mode : Char;   // Mode selector: "W" - Write; "R" - Read; "C" - Clear (Reset) "S" - Status
   END_VAR

   VAR_OUTPUT 
      qUDT_Status : "UDT_FifoStatus";   // FIFO status structure
      qx_Error : Bool;   // Collective error output
      qx_Warning : Bool;   // Collective warning output
   END_VAR

   VAR_IN_OUT 
      iqv_Data : Variant;   // Data
      iqUDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqv_DataBuffer : Variant;   // FIFO data buffer
   END_VAR

   VAR_TEMP 
      tUDT_Status : "UDT_FifoStatus";   // Status structure
      ti_MoveBLKErrorCode : Int;   // Move_BLK_Variant function return
      tx_HeaderValid : Bool;   // Header valid
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	14/06/2019  | 0.2       | A.Nowak       | Replacement of instruction if for direct write into variable - Region 3 , 4.1 , 4.2 , 4.3 , 4.4 , 8.1  , 8.2 
	17/07/2019  | 0.3       | L.Klar        | Status handling changed
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	23/08/2019  | 2.1       | K.Pokorski    | Comments corrected
	27/08/2019  | 2.2       | M.Kurpiers    | Comments adjusted
	27/09/2019  | 2.3       | K.Pokorski    | Variant input included
	01/10/2019  | 2.4       | A.Nowak       | Correct comments and rename regions
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – Diagnostic bits initialization
	    
	    // Clear FIFO statuses
	    #tUDT_Status.FifoFull := FALSE;
	    #tUDT_Status.FifoPreFull := FALSE;
	    
	END_REGION
	
	REGION 2 – Array's information
	    
	    // If buffer elements type is invalid, set the error 
	    #tUDT_Status.InvalidDataType := NOT (TypeOf(#iqv_Data) = TypeOfElements(#iqv_DataBuffer));
	    
	END_REGION
	
	REGION 3 – Mode validation
	    
	    // Set the mode invalid if selected mode isn't one of the following: W- Write, R - Read, C - Clear, S - Status
	    #tUDT_Status.InvalidMode := #ic_Mode <> 'W'
	    AND #ic_Mode <> 'R'
	    AND #ic_Mode <> 'C'
	    AND #ic_Mode <> 'S';
	    
	END_REGION
	
	REGION 4 – The header settings checking
	    
	    // The correct mode has been selected and data type is valid
	    IF (NOT #tUDT_Status.InvalidMode
	        AND NOT #tUDT_Status.InvalidDataType)
	    THEN
	        
	        REGION 4.1 – The number of maximum FIFO entries validation 
	            
	            // Write the number of array's elements to FIFO header
	            #iqUDT_FifoHeader.MaxNrOfEntries := "FC_GetNrOfArrayEl"(#iqv_DataBuffer);
	            
	            // Set the invalid maximum number of entries error 
	            #tUDT_Status.InvalidMaxNrOfEntries := #iqUDT_FifoHeader.MaxNrOfEntries <= 0;
	            
	        END_REGION
	        
	        REGION 4.2 – The number of total FIFO entries validation
	            
	            // Set the invalid total number of entries error 
	            #tUDT_Status.InvalidTotalEntriesStored := #iqUDT_FifoHeader.TotalEntriesStored < 0        // The total number of entries is lower than 0
	            OR #iqUDT_FifoHeader.TotalEntriesStored > #iqUDT_FifoHeader.MaxNrOfEntries;               // The total number of entries is greater than the maximum number of entries
	            
	        END_REGION
	        
	        REGION 4.3 – The number of the next entry to write 
	            
	            // Set the invalid next entry to write
	            #tUDT_Status.InvalidNextEntryToWrite := #iqUDT_FifoHeader.NextEntryToWrite < 0            // The number of next entry to write is lower than 0  
	            OR #iqUDT_FifoHeader.NextEntryToWrite >= #iqUDT_FifoHeader.MaxNrOfEntries;                // The number of next entry to write is greater or equal to the maximum number of entries 
	            
	        END_REGION
	        
	        REGION 4.4 – The number of the next entry to read 
	            
	            // Set the invalid next entry to read
	            #tUDT_Status.InvalidNextEntryToRead := #iqUDT_FifoHeader.NextEntryToRead < 0              // The number of next entry to read is lower than 0 
	            OR #iqUDT_FifoHeader.NextEntryToRead >= #iqUDT_FifoHeader.MaxNrOfEntries;                 // The number of next entry to read is greater or equal to the maximum nr of entries 
	            
	        END_REGION
	        
	        REGION 4.5 – FIFO header validation summary
	            
	            // Create collective header error
	            #tx_HeaderValid := NOT #tUDT_Status.InvalidMaxNrOfEntries
	            AND NOT #tUDT_Status.InvalidTotalEntriesStored
	            AND NOT #tUDT_Status.InvalidNextEntryToWrite
	            AND NOT #tUDT_Status.InvalidNextEntryToRead;
	            
	        END_REGION
	        
	    END_IF;
	    
	END_REGION
	
	REGION 5 – Writing the data into the FIFO buffer
	    
	    IF (#ic_Mode = 'W'                                                                          // Write mode selected                                                               
	        AND #tx_HeaderValid                                                                     // FIFO header valid 
	        AND NOT #tUDT_Status.InvalidDataType)                                                  // Buffer data type valid
	    THEN
	        
	        
	        IF (#iqUDT_FifoHeader.TotalEntriesStored < #iqUDT_FifoHeader.MaxNrOfEntries)          // Checking total number of stored entries                
	        THEN
	            
	            // Move input data to FIFO data buffer  
	            #ti_MoveBLKErrorCode := MOVE_BLK_VARIANT(SRC := #iqv_Data,
	                                                     COUNT := 1,
	                                                     SRC_INDEX := 0,
	                                                     DEST_INDEX := #iqUDT_FifoHeader.NextEntryToWrite,
	                                                     DEST => #iqv_DataBuffer);
	            
	            // Increment the number of the next entry to write 
	            #iqUDT_FifoHeader.NextEntryToWrite += 1;
	            
	            // Increment the total number of stored entries 
	            #iqUDT_FifoHeader.TotalEntriesStored += 1;
	            
	            
	            IF (#iqUDT_FifoHeader.NextEntryToWrite >= #iqUDT_FifoHeader.MaxNrOfEntries)       // Check the number of the next entry to write                             
	            THEN
	                
	                #iqUDT_FifoHeader.NextEntryToWrite := 0;
	                
	            END_IF;
	            
	        ELSE
	            
	            #tUDT_Status.FifoFull := TRUE;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 6 – Reading the data from the FIFO data buffer
	    
	    IF (#ic_Mode = 'R'                                                                  // Read mode selected    
	        AND #tx_HeaderValid                                                             // FIFO header valid 
	        AND NOT #tUDT_Status.InvalidDataType)                                           // Buffer data type valid                                                
	    THEN
	        
	        IF (#iqUDT_FifoHeader.TotalEntriesStored > 0)                                   // Checking total number of stored entries                                                     
	        THEN
	            
	            // Move the FIFO data to the data output
	            #ti_MoveBLKErrorCode := MOVE_BLK_VARIANT(SRC := #iqv_DataBuffer,
	                                                     COUNT := 1,
	                                                     SRC_INDEX := #iqUDT_FifoHeader.NextEntryToRead,
	                                                     DEST_INDEX := 0,
	                                                     DEST => #iqv_Data);
	            
	            // Increment the number of the next entry to read
	            #iqUDT_FifoHeader.NextEntryToRead += 1;
	            
	            // Decrement the total number of stored entries
	            #iqUDT_FifoHeader.TotalEntriesStored -= 1;
	            
	            IF (#iqUDT_FifoHeader.NextEntryToRead >= #iqUDT_FifoHeader.MaxNrOfEntries)  // Check the number of the next entry to read                 
	            THEN
	                
	                #iqUDT_FifoHeader.NextEntryToRead := 0;
	                
	            END_IF;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 7 – Clearing the FIFO header
	    
	    IF (#ic_Mode = 'C'                      // Clear mode selected  
	        AND #tx_HeaderValid)                // FIFO header valid                         
	    THEN
	        
	        #iqUDT_FifoHeader.TotalEntriesStored := 0;
	        #iqUDT_FifoHeader.NextEntryToWrite := 0;
	        #iqUDT_FifoHeader.NextEntryToRead := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 8 – FIFO management status update
	    
	    IF (#tx_HeaderValid)                   // The header is valid                                     
	    THEN
	        
	        REGION 8.1 – FIFO Empty
	            
	            // Set the FIFO empty status bit
	            #iqUDT_FifoHeader.Status.Empty := #iqUDT_FifoHeader.TotalEntriesStored = 0;
	            
	        END_REGION
	        
	        REGION 8.2 – FIFO Full
	            
	            // Set the FIFO full status bit 
	            #iqUDT_FifoHeader.Status.Full := #iqUDT_FifoHeader.TotalEntriesStored = #iqUDT_FifoHeader.MaxNrOfEntries;
	            
	        END_REGION
	        
	        REGION 8.3 – FIFO Pre-full
	            
	            IF (#iqUDT_FifoHeader.TotalEntriesStored >= 0.9 * #iqUDT_FifoHeader.MaxNrOfEntries)       // Checking if the number of total stored entries is greater or equal to 90% of the max number of entries     
	            THEN
	                
	                // Set the FIFO pre-full status 
	                #iqUDT_FifoHeader.Status.Prefull := TRUE;
	                #tUDT_Status.FifoPreFull := TRUE;
	                
	            ELSE
	                
	                #iqUDT_FifoHeader.Status.Prefull := FALSE;
	                
	            END_IF;
	            
	        END_REGION
	        
	    END_IF;
	    
	END_REGION
	
	REGION 9 – Status
	    
	    REGION 9.1 – Common status update
	        
	        // Collective error output
	        #qx_Error := NOT #tx_HeaderValid
	        OR #tUDT_Status.InvalidMode
	        OR #tUDT_Status.FifoFull
	        OR #tUDT_Status.InvalidDataType;
	        
	        // Collective warning output              
	        #qx_Warning := #tUDT_Status.FifoPreFull;
	        
	    END_REGION
	    
	    REGION 9.2 – Status update
	        
	        // Update the outer status structure with internal status structure
	        #qUDT_Status := #tUDT_Status;
	        
	    END_REGION
	    
	END_REGION
END_FUNCTION

DATA_BLOCK "DB_GINDefault"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
   VAR 
      GIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Array[1..20] of "UDT_GIN";   // GIN informations
   END_VAR


BEGIN

END_DATA_BLOCK

TYPE "UDT_ValveConfiguration"
VERSION : 0.1
   STRUCT
      ControlMode : Int := 1;   // 1 = Hold ix_open to keep qx_open active, 2 = detects rising edge on ix_Open to Open, ix_Close to Close
      ValveType : Int := 1;   // 1 = SEV, 2 = DEV
      CloseFeedBackExist { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Valve has a feed back that signals when fully cLosed
      OpenFeedBackExist { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Valve has a feed back that signals when fully Open
      OpenTime : Int;   // estimated open time, will trigger FTO if open feedback exist and not detected
      CloseTime : Int;   // estimated close time, will trigger FTC if close feedback exist and not detected
   END_STRUCT;

END_TYPE

FUNCTION "FC_WriteGIN" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 31
// END_ATTRIBUTES
   VAR_INPUT 
      ii_GIN : Int;   //    GIN number
      ii_PositionToWrite : Int;   //    Position in tracking array where to start writing GIN
      ii_NumberOfPositions : Int;   //    Number of positions to be written
      ix_Direction : Bool;   //    TRUE when positions in positive direction have to be written
   END_VAR

   VAR_IN_OUT 
      iqa_TrackingData : Array[*] of Int;   //    Tracking data
   END_VAR

   VAR_TEMP 
      ti_LCWritePosition : Int;   //    Loop counter
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	27/02/2020  | 3.1       | L.Klar        | first release MHSE TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – GIN write
	    
	    // Depending on the direction, a GIN is written into a specific number of tracking array positions.
	    #ti_LCWritePosition := 0;
	    
	    IF #ix_Direction
	    THEN
	        FOR #ti_LCWritePosition := #ii_PositionToWrite TO #ii_PositionToWrite + #ii_NumberOfPositions - 1 BY 1 DO
	            #iqa_TrackingData[#ti_LCWritePosition] := #ii_GIN;
	        END_FOR;
	    ELSE
	        FOR #ti_LCWritePosition := #ii_PositionToWrite TO #ii_PositionToWrite - #ii_NumberOfPositions + 1 BY -1 DO
	            #iqa_TrackingData[#ti_LCWritePosition] := #ii_GIN;
	        END_FOR;
	    END_IF;
	    
	END_REGION
END_FUNCTION

TYPE "UDT_PNNodeStatistics"
VERSION : 0.1
   STRUCT
      PNSlaveError : "UDT_EventStatistic";   // Statistics of a Profinet slave error
      PNSlaveNotOnline : "UDT_EventStatistic";   // Statistics of  Profinet slave not online
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_ParcelLength"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 20
// END_ATTRIBUTES
   VAR_INPUT 
      ii_PECPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //    Photoeye position [cm]
      ii_Displacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //    Displacement [cm]
      ix_LengthMeasurementEnable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Length measurement enable
      ix_GapMeasurementEnable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Gap measurement enable
   END_VAR

   VAR_IN_OUT 
      iqa_TrackingData : Array[*] of Int;   //    Tracking data
   END_VAR

   VAR 
      sR_TRIG_Data {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //    Data rising edge for length and gap measurements
      sF_TRIG_Data {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //    Data falling edge for length and gap measurements
      si_Length { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //    Parcel length
      si_Gap { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //    Gap distance
      si_GIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //    GIN number of current measured parcel
      si_OldGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //    GIN number of previous mesured parcel
   END_VAR

   VAR CONSTANT 
      ci_Overflow : Int := 32767;   //    Integer overflow value
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	21/02/2020  | 3.1       | L.Klar        | first release MHSE TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – Data triggers
	    
	    // Triggers to detect front and end of data
	    
	    #sR_TRIG_Data(CLK := #iqa_TrackingData[#ii_PECPosition] > 0);
	    #sF_TRIG_Data(CLK := #iqa_TrackingData[#ii_PECPosition] > 0);
	    
	END_REGION
	
	REGION 2 – Length counter
	    
	    //  Length is counted from a displacement, when data is available
	    //  
	    IF (#iqa_TrackingData[#ii_PECPosition] > 0
	        AND #ix_LengthMeasurementEnable
	        AND #si_Length < #ci_Overflow)
	        
	    THEN
	        #si_Length += #ii_Displacement;
	    END_IF;
	    
	END_REGION
	
	REGION 3 – Gap counter
	    
	    //  Gap is counted from a displacement, when data isn't available
	    IF (#iqa_TrackingData[#ii_PECPosition] = 0
	        AND #ix_GapMeasurementEnable
	        AND #si_Gap < #ci_Overflow)
	    THEN
	        #si_Gap += #ii_Displacement;
	    END_IF;
	    
	END_REGION
	
	REGION 4 – Parcel GIN
	    
	    IF (#sR_TRIG_Data.Q AND
	        (#ix_LengthMeasurementEnable OR #ix_GapMeasurementEnable))
	    THEN
	        #si_GIN := #iqa_TrackingData[#ii_PECPosition];
	    END_IF;
	    
	END_REGION
	
	REGION 5 – Write length into a GIN record
	    
	    IF (#sF_TRIG_Data.Q)
	    THEN
	        
	        IF #ix_LengthMeasurementEnable OR #ix_GapMeasurementEnable THEN
	            #si_OldGIN := #si_GIN;
	        END_IF;
	        
	        IF (#si_GIN > 0
	            AND ABS(#si_Length) > 0
	            AND #ix_LengthMeasurementEnable)
	        THEN
	            "DB_GIN".GIN[#si_GIN].General.Length := ABS(#si_Length) - 1;
	            #si_Length := 0;
	        ELSE
	            #si_Length := 0;
	        END_IF;
	    END_IF;
	    
	END_REGION
	
	REGION 6 – Write GIN into a GIN record
	    
	    IF (#sR_TRIG_Data.Q)
	    THEN
	        IF (#si_OldGIN > 0
	            AND #si_GIN > 0
	            AND #si_Gap <> 0
	            AND #si_OldGIN <> #si_GIN
	            AND #ix_GapMeasurementEnable)
	        THEN
	            IF (#ii_Displacement > 0)
	            THEN
	                "DB_GIN".GIN[#si_GIN].General.LeadingGap := ABS(#si_Gap) - 1;
	                "DB_GIN".GIN[#si_OldGIN].General.TrailingGap := "DB_GIN".GIN[#si_GIN].General.LeadingGap;
	                #si_Gap := 0;
	            ELSIF (#ii_Displacement < 0)
	            THEN
	                "DB_GIN".GIN[#si_OldGIN].General.LeadingGap := ABS(#si_Gap - 1);
	                "DB_GIN".GIN[#si_GIN].General.TrailingGap := "DB_GIN".GIN[#si_OldGIN].General.LeadingGap;
	                #si_Gap := 0;
	            END_IF;
	        ELSE
	            #si_Gap := 0;
	        END_IF;
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

TYPE "UDT_ValveStatus"
TITLE = UDT_ConveyorStatus
VERSION : 0.1
//User-defined structure of FB_Conveyor function block status.
   STRUCT
      Status { ExternalWritable := 'False'} : Int;   // Status number
      Specific { ExternalWritable := 'False'} : Struct
         Opening { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Valve is opening
         Opened { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Valve in Open position
         Closing { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Valve is closing
         Closed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Valve in Closed position
         FailToOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Fail to open / extend
         FailToClose { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Fail to close / retract
         AirPressureLost { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // No air pressure
         ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Configuration is not set correctly
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_AixPlcFullControllerConfiguration"
TITLE = UDT_VFD_Configuration
VERSION : 0.1
//User-defined structure oparameters.
   STRUCT
      AixContrlPNDeviceName { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Ai2's Controller Profinet device name
      Motor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         RampUpTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt := 100;   // Ramp up time for monitoring starting [ms]
         RampDownTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt := 100;   // Ramp up time for monitoring stopping [ms]
         SpeedSetpointWindow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 5;   // Speed setpoint window (tolerance) [mm/s]
         Ratio { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real := 1.0;   // Ratio conveyor roller to driven roller
         DirectionReversal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True = direction will be reversed
         InterlockFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;   // False = running in forward direction is not possible / allowed
         InterlockRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // False = running in reverse direction is not possible / allowed
         MotorExist { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True = Motor output connected
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_PECUpdateStatistics"
TITLE = UDT_PECupdateStatistics
VERSION : 0.1
//User-defined structure of FB_PECUpdate function block statistics.
   STRUCT
      PEC { S7_SetPoint := 'False'} : "UDT_PECStatistics";   // PEC Statistics
      TooManyLost { S7_SetPoint := 'False'} : "UDT_EventStatistic";   // Too many lost parcels
      TotalNrOfParcels : DInt;   // Total number of parcels
   END_STRUCT;

END_TYPE

TYPE "UDT_UnknownGIN"
TITLE = UDT_UnknownGIN
VERSION : 0.1
//User-defined structure of unknown GIN range.
   STRUCT
      Start : Int := 1;   // Unknown GIN range start value
      End : Int := 199;   // Unknown GIN range end value
      GIN : Int := 0;   // Las generated unknown GIN
   END_STRUCT;

END_TYPE

TYPE "UDT_AixPlcFullIn"
VERSION : 0.1
   STRUCT
      ConveyStopStatus { ExternalVisible := 'False'} : Struct   // Status of ConveyStop
         Bit08 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit09 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         StopActiveCommandPLC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stop active due to stop command from the PLC
         Bit11 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit12 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit13 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit14 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit15 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit00 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit02 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit03 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit04 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         StopActiveOtherModule { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stop condition is active on a module in the ConveyStop group
         StopActiveLostConn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stop is active due to a loss of communication connection
         StopActiveLostPLC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stop active due to a loss of connection with the PLC
      END_STRUCT;
      AllSensorPortInputs { ExternalVisible := 'False'} : Struct   // Left and Right Sensor Port inputs
         Bit08 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit09 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit10 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit11 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit12 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit13 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit14 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Heartbeat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // This bit toggles every 2 seconds
         LeftPin2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left sensor port Pin2 state
         Bit01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         RightPin2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right sensor port Pin2 state
         Bit03 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         LeftSensor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left sensor port Pin4 state
         Bit05 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         RightSensor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right sensor port Pin4 state
         Bit07 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
      END_STRUCT;
      SensorDetect { ExternalVisible := 'False'} : Struct   // Sensor detection
         Bits08_15 { ExternalVisible := 'False'} : SInt;   // Reserved
         RightSensorDetect { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True when sensor is detected
         LeftSensorDetect { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True when sensor is detected
         Bit02 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit03 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit04 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit05 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit06 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit07 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
      END_STRUCT;
      VoltageMotors { ExternalVisible := 'False'} : Int;   // The Voltage applied to the module's motor power connection in millivolts
      LeftMotorCurrent { ExternalVisible := 'False'} : Int;   // Left motor running current in milliamperes
      LeftMotorFreq { ExternalVisible := 'False'} : Int;   // Left motor running electrical frequency in Hz
      LeftMotorCalcTemp { ExternalVisible := 'False'} : Byte;   // Left motor temperature in degrees C
      ModuleTemp { ExternalVisible := 'False'} : Byte;   // Module CPU temperature in degrees C
      LeftMotorDiagnostic { ExternalVisible := 'False'} : Struct   // Left motor diagnostics .
         Overheat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left motor temperature has exceeded 105 degrees Celsius
         MaxTorque { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left motor at maximum torque output
         ShortCircuit { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left motor short circuit
         MotorNotConnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left motor is not connected
         Overload { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left motor overloaded after more than 20 seconds in Stalled
         Stalled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left motor stalled and speed is less than 10% of the set speed
         BadHall { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left motor Hall Effect Sensor error active
         MotorNotUsed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left motor not used
         MotorStatus1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left motor running and direction status
         MotorStatus2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left motor running and direction status
         MotorPortinDOmode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Left motor port is in digital Output mode .
         ReservedBit03 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         ReservedBit04 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         BoardOverheat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Board temperature has exceeded 90 degrees Celsius
         OverVoltage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Supply voltage + motor back EMF exceeded 30 volts
         LowVoltage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Module power supply is less than 18 Volts
      END_STRUCT;
      RightMotorCurrent { ExternalVisible := 'False'} : Int;   // Right motor running current in milliamperes
      RightMotorFreq { ExternalVisible := 'False'} : Int;   // Right motor running electrical frequency in Hz
      RightMotorCalcTemp { ExternalVisible := 'False'} : Byte;   // Right motor temperature in degrees Celsius
      ModuleTemp1 { ExternalVisible := 'False'} : Byte;   // Module PCB temperature in degrees C (same as ModuleTemp tag)
      RightMotorDiagnostic { ExternalVisible := 'False'} : Struct   // Right motor diagnostics .
         Overheat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right motor temperature has exceeded 105 degrees Celsius
         MaxTorque { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right motor at maximum torque output
         ShortCircuit { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right motor short circuit
         MotorNotConnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right motor is not connected
         Overload { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right motor overloaded after more than 20 seconds in Stalled
         Stalled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right motor stalled and speed is less than 10% of the set speed
         BadHall { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right motor Hall Effect Sensor error active
         MotorNotUsed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right motor is not used
         MotorStatus1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right motor running and direction status
         MotorStatus2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right motor running and direction status
         MotorPortinDOmode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Right motor port is in digital output mode .
         ReservedBit03 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         ReservedBit04 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         BoardOverheat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Board temperature has exceeded 90 degrees Celsius
         OverVoltage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Supply voltage + motor back EMF exceeded 30 volts
         LowVoltage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Module power supply is less than 18 Volts
      END_STRUCT;
      LeftMotorDIOstatus { ExternalVisible := 'False'} : Struct   // Status of Left M8 motor port when used as a digital IO
         Bit08 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit09 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit10 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit11 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         ShortCircuit { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Short circuit between +24V and any of the U,V,W phases
         Bit13 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit14 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit15 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bits00_07 { ExternalVisible := 'False'} : SInt;   // Reserved
      END_STRUCT;
      RightMotorDIOstatus { ExternalVisible := 'False'} : Struct   // Status of Right M8 motor port when used as a digital IO
         Bit08 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit09 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit10 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit11 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         ShortCircuit { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Short circuit between +24V and any of the U,V,W phases
         Bit13 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit14 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit15 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bits00_07 { ExternalVisible := 'False'} : SInt;   // Reserved
      END_STRUCT;
      UpstreamModuleStatus { ExternalVisible := 'False'} : Word;   // The ZPA status from the Upstream ConveyLinx module
      DownstreamModuleStatus { ExternalVisible := 'False'} : Word;   // The ZPA status from the Downstream ConveyLinx module
      TrackingFromUpstream { ExternalVisible := 'False'} : DWord;   // Tracking data from the Upstream ConveyLinx module
      Index18 { ExternalVisible := 'False'} : Word;   // Index
      ServoLocationLeft { ExternalVisible := 'False'} : Int;   // Left motor current location from 0 in mm for MDR and in pulses for PGD
      ServoLocationRight { ExternalVisible := 'False'} : Int;   // Right motor current location from 0 in mm for MDR and in pulses for PGD
      ServoStatusLeft { ExternalVisible := 'False'} : Word;   // Left motor servo commands status
      ServoStatusRight { ExternalVisible := 'False'} : Word;   // Right motor servo commands status
      LeftMotorActualSpeed { ExternalVisible := 'False'} : Word;   // Bits 0 thru 13: Left motor actual speed in mm/sec, Bits 14-15: Status. For PGD, base unit is 1/10 RPM
      RightMotorActualSpeed { ExternalVisible := 'False'} : Word;   // Bits 0 thru 13: Left motor actual speed in mm/sec, Bits 14-15: Status. For PGD, base unit is 1/10 RPM
      Future { ExternalVisible := 'False'} : Array[25..31] of Int;   // Future
   END_STRUCT;

END_TYPE

TYPE "UDT_AixPlcFullOut"
VERSION : 0.1
   STRUCT
      ConveyStopControl { ExternalVisible := 'False'} : Word;   // Writing '1' causes the Stop group to go into STOP state . Transition 0 - 2 is needed to clear the Stop
      LeftMotorAsDIO { ExternalVisible := 'False'} : Struct   // Use the Left M8 motor port as digital IO
         Bit08 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit09 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit10 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit11 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit12 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit13 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit14 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         EnableDIO { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Set bit to enable Left motor M8 port Digital IO mode
         Bit00 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         EnergizeM8Pin4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Energize motor port M8 PIN 4
         EnergizeM8Pin3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Energize motor port M8 PIN 3
         Bit03 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit04 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit05 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit06 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit07 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
      END_STRUCT;
      RightMotorAsDIO { ExternalVisible := 'False'} : Struct   // Use the Right M8 motor port as digital IO
         Bit08 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit09 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit10 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit11 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit12 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit13 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit14 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         EnableDIO { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Set bit to enable Left motor M8 port Digital IO mode
         EnergizeM8Pin2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Energize motor port M8 PIN 2
         Bit01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         EnergizeM8Pin3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Energize motor port M8 PIN 3
         Bit03 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit04 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit05 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit06 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit07 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
      END_STRUCT;
      SensorPortsDO { ExternalVisible := 'False'} : Struct   // The Sensor ports PIN2 as digital outputs
         Bit08 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit09 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit10 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit11 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit12 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit13 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit14 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit15 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         EnergizeLeftPortPin2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Set to turn on Left Port Pin2
         EnergizeRightPortPin2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Set to turn on Right Port Pin2
         Bit02 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit03 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit04 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         EnableLeftPortPin2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Set to enable, reset for Pin2  to be input
         EnableRightPortPin2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Set to enable, reset for Pin2  to be input
         Bit07 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
      END_STRUCT;
      LeftMotorControl { ExternalVisible := 'False'} : Struct   // Run/Stop and Direction control of the Left motor
         MotorDirection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0 = Configured direction /1 = opposite to configured direction
         Bit09 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit10 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit11 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit12 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit13 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit14 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit15 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Run { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Run = 1 / Stop = 0
         Bit01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit02 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit03 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit04 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit05 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit06 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit07 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
      END_STRUCT;
      LeftSetMotorBrakeMode { ExternalVisible := 'False'} : Word;   // Set Left motor Brake Mode.0 = ignore 1 = "Normal" / 2 = "Free" / 3 ="Servo brake"
      LeftSetMotorSlaveMode { ExternalVisible := 'False'} : Word;   // 0 = ignore  1=Off, Left Independant  2=On, Left Mirror Right   3=On, Left Opposite Right direction
      RightMotorControl { ExternalVisible := 'False'} : Struct   // Run/Stop and Direction control of the Right motor
         MotorDirection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0 = Configured direction /1 = opposite to configured direction
         Bit09 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit10 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit11 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit12 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit13 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit14 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit15 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Run { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Run = 1 / Stop = 0
         Bit01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit02 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit03 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit04 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit05 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit06 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit07 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
      END_STRUCT;
      RightSetMotorBrakeMode { ExternalVisible := 'False'} : Word;   // Set Right motor Brake Mode.0 = ignore 1 = "Normal" / 2 = "Free" / 3 ="Servo brake"
      RightSetMotorSlaveMode { ExternalVisible := 'False'} : Word;   // 0 = ignore 1=Off, Right Independant  2=On, Right Mirror Right   3=On, Right Opposite Right direction
      LeftSetMotorSpeed { ExternalVisible := 'False'} : Int;   // Set reference speed for Left motor in mm/s (or 1/10 of an RPM for PGD)
      RightSetMotorSpeed { ExternalVisible := 'False'} : Int;   // Set reference speed for Right motor mm/s  (or 1/10 of an RPM for PGD)
      LeftSetMotorAccel { ExternalVisible := 'False'} : Int;   // Set acceleration distance in mm for Left motor (or pulses for PGD)
      LeftSetMotorDeccel { ExternalVisible := 'False'} : Int;   // Set deceleration distance in mm for Left motor (or pulses for PGD)
      RightSetMotorAccel { ExternalVisible := 'False'} : Int;   // Set acceleration distance in mm for Right motor (or pulses for PGD)
      RightSetMotorDeccel { ExternalVisible := 'False'} : Int;   // Set deceleration distance in mm for Right motor (or pulses for PGD)
      ClearMotorError { ExternalVisible := 'False'} : Word;   // Write '1' to clear motor error, wait 500 msec, then write '0' return to operation
      SendStatusToDownstream { ExternalVisible := 'False'} : Word;   // Write '4' or '5' to signal downstream ConveyLinx module in ZPA mode to wake up
      SendStatusToUpstream { ExternalVisible := 'False'} : Word;   // Write '5' to signal upstream ConveyLinx module in ZPA mode to accumulate, write '1' to signal OK to receive
      SensorPolarity { ExternalVisible := 'False'} : Struct   // Set logic polarity for Sensor Port's PIN2 and PIN4
         Bit08 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit09 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit10 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit11 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit12 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit13 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit14 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Bit15 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Left_Pin2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Set to invert, reset for normal
         Bit01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Right_Pin2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Set to invert, reset for normal
         Bit03 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Left_Pin4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Set to invert, reset for normal
         Bit05 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
         Right_Pin4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Set to invert, reset for normal
         Bit07 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reserved
      END_STRUCT;
      TrackingToDownstream { ExternalVisible := 'False'} : DWord;   // Write Tracking data to be captured by downstream ZPA mode ConveyLinx
      Index22 { ExternalVisible := 'False'} : Word;   // Reserved
      ServoControlDistanceLeft { ExternalVisible := 'False'} : Int;   // Position from 0 in mm for Left motor to move on next command
      ServoControlCommandLeft { ExternalVisible := 'False'} : Word;   // Left motor servo command
      ServoControlDistanceRight { ExternalVisible := 'False'} : Int;   // New position from 0 in mm for Right motor to move on next command
      ServoControlCommandRight { ExternalVisible := 'False'} : Word;   // Right motor servo command
      Future { ExternalVisible := 'False'} : Array[27..31] of Int;   // Reserved
   END_STRUCT;

END_TYPE

TYPE "UDT_PECUpdateStatus"
TITLE = UDT_PECUpdateStatus
VERSION : 0.1
//User-defined structure of FB_PECUpdate function block status.
   STRUCT
      TooManyLost { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Too many parcels lost in a row
      LowPerformance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Performance warning
      PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Current state of the end of section photo eye
      Jam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PEC Jam error
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_Pulse"
TITLE = FB_Pulse
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 26
// END_ATTRIBUTES
//Function block to generate custom pulse signal.
   VAR_INPUT 
      iudi_PulseTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Pulse time [ms]
   END_VAR

   VAR_OUTPUT 
      qx_Pulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Pulse output
   END_VAR

   VAR 
      R_TRIG {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Siemens "R_Trig" - to prepare rising edge trigger on "sx_Pulse" signal
      slr_ActualPulseTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Actual pulse time [ms]
      sx_Pulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Pulse signal
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | K.Pokorski    | first release MHS TIA 15.1
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	27/08/2019  | 2.1       | K.Pokorski    | Comments adjusted
	04/11/2019  | 2.2       | L.Klar        | Prevoius cycle scan changed from memory to DB variable
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Pulse calculation
	    
	    // Pulse timer on
	    IF (#iudi_PulseTime <= #slr_ActualPulseTime)
	    THEN
	        
	        #sx_Pulse := TRUE;
	        #slr_ActualPulseTime := 0;
	        
	    ELSE
	        
	        #slr_ActualPulseTime += "DB_Memory".PrevCycleTime;
	        #sx_Pulse := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Pulse output
	    
	    #R_TRIG(CLK := #sx_Pulse,
	            Q => #qx_Pulse);
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION "FC_BitAllocation" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      ix_Bit0 : Bool;
      ix_Bit1 : Bool;
      ix_Bit2 : Bool;
      ix_Bit3 : Bool;
      ix_Bit4 : Bool;
      ix_Bit5 : Bool;
      ix_Bit6 : Bool;
      ix_Bit7 : Bool;
      ix_Bit8 : Bool;
      ix_Bit9 : Bool;
      ix_Bit10 : Bool;
      ix_Bit11 : Bool;
      ix_Bit12 : Bool;
      ix_Bit13 : Bool;
      ix_Bit14 : Bool;
      ix_Bit15 : Bool;
      ix_Bit16 : Bool;
      ix_Bit17 : Bool;
      ix_Bit18 : Bool;
      ix_Bit19 : Bool;
      ix_Bit20 : Bool;
      ix_Bit21 : Bool;
      ix_Bit22 : Bool;
      ix_Bit23 : Bool;
      ix_Bit24 : Bool;
      ix_Bit25 : Bool;
      ix_Bit26 : Bool;
      ix_Bit27 : Bool;
      ix_Bit28 : Bool;
      ix_Bit29 : Bool;
      ix_Bit30 : Bool;
      ix_Bit31 : Bool;
   END_VAR

   VAR_OUTPUT 
      qdw_Dword : DWord;
   END_VAR


BEGIN
	#qdw_Dword.%X0 := #ix_Bit0;
	#qdw_Dword.%X1 := #ix_Bit1;
	#qdw_Dword.%X2 := #ix_Bit2;
	#qdw_Dword.%X3 := #ix_Bit3;
	#qdw_Dword.%X4 := #ix_Bit4;
	#qdw_Dword.%X5 := #ix_Bit5;
	#qdw_Dword.%X6 := #ix_Bit6;
	#qdw_Dword.%X7 := #ix_Bit7;
	#qdw_Dword.%X8 := #ix_Bit8;
	#qdw_Dword.%X9 := #ix_Bit9;
	#qdw_Dword.%X10 := #ix_Bit10;
	#qdw_Dword.%X11 := #ix_Bit11;
	#qdw_Dword.%X12 := #ix_Bit12;
	#qdw_Dword.%X13 := #ix_Bit13;
	#qdw_Dword.%X14 := #ix_Bit14;
	#qdw_Dword.%X15 := #ix_Bit15;
	#qdw_Dword.%X16 := #ix_Bit16;
	#qdw_Dword.%X17 := #ix_Bit17;
	#qdw_Dword.%X18 := #ix_Bit18;
	#qdw_Dword.%X19 := #ix_Bit19;
	#qdw_Dword.%X20 := #ix_Bit20;
	#qdw_Dword.%X21 := #ix_Bit21;
	#qdw_Dword.%X22 := #ix_Bit22;
	#qdw_Dword.%X23 := #ix_Bit23;
	#qdw_Dword.%X24 := #ix_Bit24;
	#qdw_Dword.%X25 := #ix_Bit25;
	#qdw_Dword.%X26 := #ix_Bit26;
	#qdw_Dword.%X27 := #ix_Bit27;
	#qdw_Dword.%X28 := #ix_Bit28;
	#qdw_Dword.%X29 := #ix_Bit29;
	#qdw_Dword.%X30 := #ix_Bit30;
	#qdw_Dword.%X31 := #ix_Bit31;
	
END_FUNCTION

TYPE "UDT_PECUpdateConfiguration"
TITLE = UDT_PECConfiguration
VERSION : 0.1
//User-defined structure of PEC parameters.
   STRUCT
      Distance : DInt;   // Distance between photo eye and the end of conveyor [mm]
      JamDisplacementLimit : Int;   // Limit displacement with PEC blocked o detect jam [cm]
      TimeOnDelay : UDInt;   // Photo eye time on delay [ms]
      TimeOffDelay : UDInt;   // Photo eye time off delay [ms]
      ParcelLengthFilter : Bool := TRUE;   // Parcel length filter
      ResetWithPECBlocked { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // When 'True' Allow reset system after jam with PEC blocked
      SearchWindowFwd : Int;   // Search window in forward direction [cm]
      SearchWindowRvs : Int;   // Search window in reverse direction [cm]
      GINRangeStart : Int;   // GIN range start value
      GINRangeEnd : Int;   // GIN range end value
      NrOfTeachParcels : Int;   // Number of parcels to teach
      DefaultGIN : Int := 1;   // Default GIN record
      MaxLost : Int;   // Maximum number of lost parcels in a row
      GenerationPoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Generation point
      NegativeGINDelete { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True when negative GIN has to be deleted
      ParcelLengthMeasurement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parcel length measurement
      GapLengthMeasurement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Gap length measurement
   END_STRUCT;

END_TYPE

TYPE "UDT_ValveStatistics"
VERSION : 0.1
   STRUCT
      Open : "UDT_EventStatistic";   // Number of times PEC got jammed
      Fail : "UDT_EventStatistic";
   END_STRUCT;

END_TYPE

TYPE "UDT_PendantVT100Statistics"
VERSION : 0.1
   STRUCT
      PNSlaveError : "UDT_EventStatistic";   // Statistics of a Profinet slave error
      PNSlaveNotOnline : "UDT_EventStatistic";   // Statistics of  Profinet slave not online
   END_STRUCT;

END_TYPE

TYPE "UDT_LoaderStatistics"
TITLE = UDT_LoaderStatistics
VERSION : 0.1
//User-defined structure of FB_Loader function block statistics.
   STRUCT
      EnergySave : "UDT_EventStatistic";   // Number of times that save energy mode occurs
      ExtendableUpTime : "UDT_EventStatistic";   // Conveyor up time
      ExtendableDownTime : "UDT_EventStatistic";   // Conveyor down time
      VFDError : "UDT_EventStatistic";   // VFD Error
      NotHealthy : "UDT_EventStatistic";   // Extendable not healthy
   END_STRUCT;

END_TYPE

TYPE "UDT_LoaderStatus"
TITLE = UDT_LoaderStatus
VERSION : 0.1
//User-defined structure of FB_Loader function block status.
   STRUCT
      Status : Int;   // Status number
      Specific : Struct   // Equipment specific warnings and errors
         Disabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Loader is disabled by HMI
         VFDError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Loader has an VFD error
         NotHealthy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Loader is not healthy
         StoreMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Extendable is in store mode
         FeedMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Extendable is in feed mode
         RunMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Extendable is in run mode
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_PneumaticBrakeConfiguration"
VERSION : 0.1
   STRUCT
      BrakePuls : UDInt;   // Time [ms] brake is up in brake function
      BrakePause : UDInt;   // Time [ms] brake is down in brake function
      BrakeCycles : Int;   // Number of brake cycles
      BrakeInterval : UDInt;   // Time [ms] between brake cycles
      PECBrakeOnDelay : UDInt;   // On delay time PEC brake signal
      PECBrakeOffDelay : UDInt;   // Off delay time PEC brake signal
      PECStopOnDelay : UDInt;   // On delay time PEC stop signal
      PECStopOffDelay : UDInt;   // Off delay time PEC stop signal
      StopFunctionOnDelay : UDInt;   // On delay time stop function
      StopFunctionOffDelay : UDInt;   // Off delay time stop function
      FailSafe { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate output to release
      Slave { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stopper is slave
   END_STRUCT;

END_TYPE

TYPE "UDT_ZPAinterface"
VERSION : 0.1
   STRUCT
      CommonStatus { S7_SetPoint := 'False'} : "UDT_CommonStatus";
      ConveyorInterface { S7_SetPoint := 'False'} : "UDT_ConveyorInterface";
      Handshake { S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";
   END_STRUCT;

END_TYPE

TYPE "UDT_PendantVT100Configuration"
VERSION : 0.1
//Configuration variables for PendantVT100 
   STRUCT
      Line1Cursor : Array[0..7] of Byte := [16#001B, 16#005B, 16#0031, 16#003B, 16#0033, 16#0048, 16#006D, 16#0000];   // Configuration of telegram command to move cursor to line 1
      Line2Cursor : Array[0..7] of Byte := [16#001B, 16#005B, 16#0032, 16#003B, 16#0035, 16#0048, 16#006D, 16#0000];   // Configuration of telegram command to move cursor to line 2
      DisplayName : String[8];   // PLC name with a max of 8 characters
      HornRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True = Request horn to sound before VFD run
      PNDeviceName : String;   // Device name of pendant receiver
   END_STRUCT;

END_TYPE

TYPE "UDT_LoaderConfiguration"
TITLE = UDT_LoaderConfiguration
VERSION : 0.1
//User-defined structure of loader parameters.
   STRUCT
      PEC_EoSTimeOnDelay : UDInt;   // Photo eye time on delay
      PEC_EoSTimeOffDelay : UDInt;   // Photo eye time off delay
      CascadeTimeOnDelay : UDInt;   // Cascade time on delay
      Speedsetpoint : Int;   // Speedsetpoint: 0=Low, 1=Nom, 2=High
      EnergySaveLength : Int;   // Distance conveyor travelled before energy save activate [cm]
      Energy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Energy save mode enable
   END_STRUCT;

END_TYPE

TYPE "UDT_PendantVT100InBytes"
VERSION : 0.1
   STRUCT
      StartButton1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // start button pressed half way
      StartButton2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // start button pressed full way
      Stop_NO { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // NO contact of stop button
      Spare1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // spare
      Spare2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // spare
      Spare3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // spare
      Spare4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // spare
      Stop_NC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // NC contact of stop button
      LeftButton1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // left button pressed half way
      PB_Speed2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Push button for low speed
      RightButton1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // right button pressed half way
      PB_Speed1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Push button for manual speed
      DownButton1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // down button pressed half way
      DownButton2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // down button pressed full way
      UpButton1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // up button pressed half way
      PB_Divert { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Push button to activate divert
      ResetButton1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // reset button pressed half way
      ResetButton2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // reset button pressed full way
      MOT_Button1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // motor button pressed half way
      MOT_Button2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // motor button pressed full way
      Spare5 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // spare
      Spare6 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // spare
      Spare7 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // spare
      Spare8 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // spare
   END_STRUCT;

END_TYPE

TYPE "UDT_PendantVT100LCDOutBytes"
VERSION : 0.1
   STRUCT
      "Byte" : Array[0..7] of Byte;   // Output byte for VT100 LCD
   END_STRUCT;

END_TYPE

TYPE "UDT_PendantVT100Status"
VERSION : 0.1
//Configuation variables for VT100 Radio Pendant
   STRUCT
      Status : Int;   // Status number
      Specific : Struct   // Specific structure
         PNSlaveNotOnline { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet slave is not online
         PNSlaveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet slave is in error
         CommunicationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Tx-Rx Communication error
         ServiceModeEngaged { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Service mode is activated
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_ValveCommand"
TITLE = UDT_ConveyorCommand
VERSION : 0.1
//User-defined structure of conveyor commands.
   STRUCT
      ManualMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual mode command from HMI
      AutoMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Automatic mode command from HMI
      ManualOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual command valve Open / Extend
      ManualClose { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual command valve Close / Retract
   END_STRUCT;

END_TYPE

TYPE "UDT_ValveInterface"
TITLE = UDT_ValveInterface
VERSION : 0.1
//UDT valve interface between modules
   STRUCT
      Open { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Interface command valve Open / Extend
      Close { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Interface command valve Close / Retract
      IsOpened { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Valve feedback opened / extended
      IsClosed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Valve feedback closed / retracted
      Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Valve error
   END_STRUCT;

END_TYPE

TYPE "UDT_FlowConfiguration"
VERSION : 0.1
   STRUCT
      FactorMerges : Array[1..6] of Real := [6(1.0)];
      MiniumGap : Int := 500;   // Minimum Gap setting [mm]
      MaxGap : Int := 2000;   // Maximum Gap setting [mm]
      PeriodSorterCapacity : UDInt := 30;   // Time  to check average empty carriers [s]
      PeriodMergeCapacity : UDInt := 30;   // Timer to check average merge flow [s]
      MaxCapacityMerge : Int;   // Max capacity Merge
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_MergeGenerator"
TITLE = FB_BasicEquipment
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : Equipment
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 17
// END_ATTRIBUTES
//Function block to control basic equipment.
   VAR_INPUT 
      iUDT_MergeGenConfig { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_MergeGeneratorConfig";   // Merge configuration structure
      ii_ConveyorDisplacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Displacement of merge conveyor
   END_VAR

   VAR_IN_OUT 
      iqa_TrackingData : Array[*] of Int;   //  UDT Equipment Control
      iqUDT_Merge : "UDT_Merge";   // UDT Mergedata
      iqUDT_Induct : Array[*] of "UDT_Induct";   // UDT induct
   END_VAR

   VAR 
      sR_TRIG_Full {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sdi_DeactivateDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //  Distance to go before generator deactivates
      si_LoopCounterZero { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Loop Counter to delete empty positons
      si_GenerationGapCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Generate the gap unit in the trackind DB
      si_LastInductNumberUsed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Last Induct number used
      si_ReturnValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Info Code of Move Block Siemens
      si_GenerationPoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Position in tracking at which the window will be generated
      si_NumerOfInduct { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Number of inducts connected to the merge
      si_PositionsPerInduct { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Number of positions each induct has
      si_LoopCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Loopcounter number of inducts
      si_SecondLoopCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Loopcounter number of inducts
      si_LastInductNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Last induct number
      sx_LoopAgain { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Last used position was removed, loop again to find next
      sx_ShiftRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Request to Shift
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	26/09/2019  | 1.0       | M.Roijen      | first release TIA 15.1
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	07/01/2020  | 3.1       | F.Baten       | Added RequesetInFifo handshake 
	13/01/2020  | 3.2       | F.Baten       | Removed i_UDT_ConveyorConfiguration as it was not used anymore
	23/01/2020  | 3.3       | F.Baten       | Renumber region 5-4 to 4-5
	                                        | Removed deletion off negative GIN 
	                                        | Added 1cm to GenerationGapCounter as it has to set the desired gap, before it set the start position of the next parcel
	                                        | Removed i_UDT_ConveyorConfiguration and i_UDT_PECConfiguration as they were not used anymore
	30/03/2022  | 3.4       | H.Rutkowski   | Mode 2 handling
	22/07/2022  | 3.5       | M.Piela       | Check number of induct and numer of positions in induct every cycle
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	//  
	//  This block generates gaps and windows for merge principles
	// 
	REGION 1 - Mode Change Gap Mode / Window Mode
	    
	    // CHeck number of induct and numer of positions in induct 
	    #si_NumerOfInduct := "FC_GetNrOfArrayEl"(#iqUDT_Induct);
	    #si_PositionsPerInduct := "FC_GetNrOfArrayEl"(#iqUDT_Induct[1].Position);
	    
	    #si_GenerationPoint := DINT_TO_INT(#iUDT_MergeGenConfig.GenerationPoint / 10);
	    
	    // activate generation when request from induct is received
	    IF #iqUDT_Merge.ReactivateReq
	    THEN
	        #iqUDT_Merge.GenerationInactive := FALSE;
	        #iqUDT_Merge.ReactivateReq := FALSE;
	        #sdi_DeactivateDistance := #iUDT_MergeGenConfig.ChangeWindowModeDistance / 10;
	    END_IF;
	    
	    //Deactivate generation mode when no generation request or distance traveled to disable mode 
	    //********************************************
	    // #iq_UDT_Merge.GenerationInactive := (#sdi_DeactivateDistance <= 0)
	    // AND NOT #iq_UDT_Merge.ReactivateReq; 
	    
	    IF #iqUDT_Merge.GenerationInactive
	    THEN
	        #si_GenerationGapCounter := #iUDT_MergeGenConfig.GapHeadToHead;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Update/shift FIFO
	    //Get size of FIFO array (without the zero)
	    #iqUDT_Merge.MaxNumberofEntries := ("FC_GetNrOfArrayEl"(#iqUDT_Merge.FIFO) - 1);
	    
	    // Handle shift request merge (FIFO entry is handled induct code is generated in tracking DB)
	    IF #sx_ShiftRequest
	    THEN
	        #si_ReturnValue := MOVE_BLK_VARIANT(SRC := #iqUDT_Merge.FIFO,
	                                            COUNT := INT_TO_UDINT(#iqUDT_Merge.MaxNumberofEntries),
	                                            SRC_INDEX := 1,
	                                            DEST_INDEX := 0,
	                                            DEST => #iqUDT_Merge.FIFO);
	        // reset the last entry and shift request
	        #iqUDT_Merge.FIFO[#iqUDT_Merge.MaxNumberofEntries].GapSize := 0;
	        #iqUDT_Merge.FIFO[#iqUDT_Merge.MaxNumberofEntries].InductNumber := 0;
	        #sx_ShiftRequest := False;
	        
	        //Update last used position of FIFO.    
	        #iqUDT_Merge.LastUsed -= 1;
	        IF #iqUDT_Merge.LastUsed < 0           // value can not be smaller than '0'
	        THEN
	            #iqUDT_Merge.LastUsed := 0;
	        END_IF;
	    END_IF;
	END_REGION
	
	REGION 3 - FIFO checks
	    
	    REGION 3.1 - Remove '0' entry
	        IF NOT (#iUDT_MergeGenConfig.ModeSelection = 2)
	        THEN
	            // There was an entry removed by one of the inducts (remove is true)
	            // now the 'RemoveEntry' is searched for and if found deleted from the FIFO by shifting up
	            IF #iqUDT_Merge.Remove OR #sx_LoopAgain
	            THEN
	                // Loop again bit will be false until a RemoveEntry is found
	                #sx_LoopAgain := FALSE;
	                
	                // check all entries for RemoveEntry = true 
	                FOR #si_LoopCounterZero := 1 TO #iqUDT_Merge.MaxNumberofEntries BY 1 DO
	                    IF #iqUDT_Merge.FIFO[#si_LoopCounterZero].RemoveEntry
	                    THEN
	                        #si_ReturnValue := MOVE_BLK_VARIANT(SRC := #iqUDT_Merge.FIFO,
	                                                            COUNT := INT_TO_UDINT(#iqUDT_Merge.MaxNumberofEntries - #si_LoopCounterZero),
	                                                            SRC_INDEX := #si_LoopCounterZero + 1,
	                                                            DEST_INDEX := #si_LoopCounterZero,
	                                                            DEST => #iqUDT_Merge.FIFO);
	                        // reset the last entry if shift is executed 
	                        #iqUDT_Merge.FIFO[#iqUDT_Merge.MaxNumberofEntries].GapSize := 0;
	                        #iqUDT_Merge.FIFO[#iqUDT_Merge.MaxNumberofEntries].InductNumber := 0;
	                        #iqUDT_Merge.FIFO[#iqUDT_Merge.MaxNumberofEntries].RemoveEntry := FALSE;
	                        
	                        //Update Last Used position of FIFO.
	                        #iqUDT_Merge.LastUsed -= 1;
	                        #iqUDT_Merge.Remove := FALSE;
	                        #sx_LoopAgain := TRUE;
	                    END_IF;
	                    IF #si_LoopCounterZero = #iqUDT_Merge.MaxNumberofEntries
	                        AND #iqUDT_Merge.Remove
	                    THEN
	                        #iqUDT_Merge.Remove := FALSE;
	                    END_IF;
	                END_FOR;
	                // Checking if last used value does not go below 0, if so, write back to 0
	                IF #iqUDT_Merge.LastUsed < 0
	                THEN
	                    #iqUDT_Merge.LastUsed := 0;
	                END_IF;
	            END_IF;
	        END_IF;
	    END_REGION
	    
	    REGION 3.2 - Check if last used bit is accurate and correct if it is not.
	        // Last used can't be an empty entry unless it is equal to '0'
	        IF #iqUDT_Merge.FIFO[#iqUDT_Merge.LastUsed].InductNumber = 0
	            AND #iqUDT_Merge.LastUsed <> 0
	        THEN
	            #iqUDT_Merge.LastUsed -= 1;
	        END_IF;
	        
	        // When the next entry is filled then the number has to be increased
	        IF #iqUDT_Merge.LastUsed < #iqUDT_Merge.MaxNumberofEntries
	        THEN
	            IF #iqUDT_Merge.FIFO[#iqUDT_Merge.LastUsed].InductNumber <> 0
	                AND #iqUDT_Merge.FIFO[#iqUDT_Merge.LastUsed + 1].InductNumber <> 0
	            THEN
	                #iqUDT_Merge.LastUsed += 1;
	            END_IF;
	        END_IF;
	    END_REGION
	END_REGION
	
	REGION 4 - Update on displacement
	    // decrease the gap counter as long the gap counter is bigger than '0'
	    IF #si_GenerationGapCounter > 0
	    THEN
	        #si_GenerationGapCounter -= #ii_ConveyorDisplacement;
	        
	        // check if value does not go negative
	        IF #si_GenerationGapCounter < 0
	        THEN
	            #si_GenerationGapCounter := 0;
	        END_IF;
	    END_IF;
	    
	    // decrease the deactivation distance counter as long as it is bigger than '0'
	    IF #sdi_DeactivateDistance > 0
	    THEN
	        #sdi_DeactivateDistance -= #ii_ConveyorDisplacement;
	        
	        // check if value does not go negative
	        IF #sdi_DeactivateDistance < 0
	        THEN
	            #sdi_DeactivateDistance := 0;
	        END_IF;
	    END_IF;
	    
	    IF (#iUDT_MergeGenConfig.ModeSelection = 2)
	        AND NOT #iqUDT_Merge.GenerationInactive
	        AND #ii_ConveyorDisplacement > 0
	    THEN
	        FOR #si_LoopCounter := 1 TO #si_NumerOfInduct DO
	            #iqUDT_Induct[#si_LoopCounter].DistanceLastReserved -= #ii_ConveyorDisplacement;
	            IF #iqUDT_Induct[#si_LoopCounter].DistanceLastReserved < 0
	            THEN
	                #iqUDT_Induct[#si_LoopCounter].DistanceLastReserved := 0;
	            END_IF;
	        END_FOR;
	    END_IF;
	END_REGION
	
	REGION 5 - Put Value in Tracking array
	    // check if required gap is reached and if the generation is active
	    REGION Mode 0 and 1
	        IF (#si_GenerationGapCounter = 0)
	            AND NOT #iqUDT_Merge.GenerationInactive
	            AND NOT (#iUDT_MergeGenConfig.ModeSelection = 2)
	        THEN
	            // check if FIFO does contain requests to generate induct codes
	            IF #iqUDT_Merge.FIFO[1].InductNumber = 0 AND #iUDT_MergeGenConfig.ModeSelection = 0
	            THEN
	                // If no request generate value -100 in tracking DB with the correpondent fixed window, and set counter to create gap.
	                #iqa_TrackingData[#si_GenerationPoint] := -100;
	                #si_GenerationGapCounter := #iUDT_MergeGenConfig.GapHeadToHead;
	            END_IF;
	            
	            IF #iqUDT_Merge.FIFO[1].InductNumber > 0
	                AND NOT #sx_ShiftRequest
	            THEN
	                // If there is assigned a induct number add 100 and negate the value.
	                // Move the position value into the tracking request variable
	                // Inform that the request was handled.
	                #iqa_TrackingData[#si_GenerationPoint] := - (#iqUDT_Merge.FIFO[1].InductNumber + 100);
	                #iqUDT_Merge.TrackingPointerForInduct[#iqUDT_Merge.FIFO[1].InductNumber] := #si_GenerationPoint;
	                #iqUDT_Merge.RequestInFIFO[#iqUDT_Merge.FIFO[1].InductNumber] := FALSE;
	                
	                // Compares the last entry to be different to 0 and to the actual entry , if they are set the distance.
	                IF (#si_LastInductNumberUsed <> #iqa_TrackingData[#si_GenerationPoint])
	                THEN
	                    #sdi_DeactivateDistance := #iUDT_MergeGenConfig.ChangeWindowModeDistance / 10;
	                END_IF;
	                
	                // write last induct number used to static for next compare
	                #si_LastInductNumberUsed := #iqa_TrackingData[#si_GenerationPoint];
	                
	                // initiate gap counter and set shift request
	                #si_GenerationGapCounter := (#iqUDT_Merge.FIFO[1].GapSize + 1);
	                #sx_ShiftRequest := TRUE;
	                
	            END_IF;
	        END_IF;
	    END_REGION
	    
	    REGION Mode = 2
	        // Statement section REGION
	        IF (#iUDT_MergeGenConfig.ModeSelection = 2)
	            AND NOT #iqUDT_Merge.GenerationInactive
	            AND (#si_GenerationGapCounter = 0)
	        THEN
	            
	            //generate window from last induct to 1st induct 
	            FOR #si_SecondLoopCounter := 1 TO #si_NumerOfInduct DO
	                
	                IF #si_LastInductNumber <= 1
	                THEN
	                    #si_LastInductNumber := #si_NumerOfInduct + 1;
	                    
	                END_IF;
	                
	                #si_LastInductNumber := #si_LastInductNumber - 1;
	                
	                
	                // Check induct buffer conveyor for which window need to be reserved
	                
	                IF #iqUDT_Induct[#si_LastInductNumber].DistanceLastReserved <= 0 AND
	                    NOT #iqUDT_Induct[#si_LastInductNumber].DisableWindowReservation
	                THEN
	                    FOR #si_LoopCounter := 1 TO #si_PositionsPerInduct DO
	                        IF #iqUDT_Induct[#si_LastInductNumber].Position[#si_LoopCounter].GapRequired > 0
	                            AND #iqUDT_Induct[#si_LastInductNumber].Position[#si_LoopCounter].GINNumber > 0
	                            AND NOT #iqUDT_Induct[#si_LastInductNumber].Position[#si_LoopCounter].WindowReserved
	                        THEN
	                            #iqa_TrackingData[#si_GenerationPoint] := - (#si_LastInductNumber + 100);
	                            #iqa_TrackingData[#si_GenerationPoint + 1] := #iqUDT_Induct[#si_LastInductNumber].Position[#si_LoopCounter].GapRequired;
	                            //Test code, write GIN number into tracking array
	                            #iqa_TrackingData[#si_GenerationPoint + 2] := #iqUDT_Induct[#si_LastInductNumber].Position[#si_LoopCounter].GINNumber;
	                            
	                            #iqUDT_Induct[#si_LastInductNumber].Position[#si_LoopCounter].WindowPosition := #si_GenerationPoint;
	                            #iqUDT_Induct[#si_LastInductNumber].Position[#si_LoopCounter].WindowReserved := TRUE;
	                            #si_GenerationGapCounter := #iqUDT_Induct[#si_LastInductNumber].Position[#si_LoopCounter].GapRequired;
	                            #iqUDT_Induct[#si_LastInductNumber].DistanceLastReserved := #iUDT_MergeGenConfig.DelayDistance;
	                            
	                            // Compares the last entry to be different to 0 and to the actual entry , if they are set the distance.
	                            IF (#si_LastInductNumberUsed <> #si_LastInductNumber)
	                            THEN
	                                #sdi_DeactivateDistance := #iUDT_MergeGenConfig.ChangeWindowModeDistance / 10;
	                            END_IF;
	                            
	                            // write last induct number used to static for next compare
	                            #si_LastInductNumberUsed := #si_LastInductNumber;
	                            
	                            EXIT;
	                        END_IF;
	                        IF #iqUDT_Induct[#si_LastInductNumber].Position[#si_LoopCounter].GINNumber = 0
	                        THEN
	                            EXIT;
	                        END_IF;
	                    END_FOR;
	                END_IF;
	                IF #si_GenerationGapCounter > 0
	                THEN
	                    EXIT;
	                END_IF;
	            END_FOR;
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION "FC_NordToSiemensVFDSimulationOutput" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 24
// END_ATTRIBUTES
   VAR_INPUT 
      qUDT_VfdOutputsNord : "UDT_VfdNordPO";
   END_VAR

   VAR_OUTPUT 
      qUDT_VfdOutputsSiemens : "UDT_VfdSiemensPO";
   END_VAR

   VAR_TEMP 
      tx_dummy : Bool;
      ti_dummy : Int;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/11/2021  | 0.1       | M.Roijen      | Initial version TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5            
	*)
	
	REGION 1 - Send VFD Output to Siemens Drive
	    
	    #qUDT_VfdOutputsSiemens.STW_1.ControlViaPLC := TRUE;
	    #qUDT_VfdOutputsSiemens.STW_1.DirectionReversal := FALSE;
	    #qUDT_VfdOutputsSiemens.STW_1.ONOFF1 := #qUDT_VfdOutputsNord.STW.ReadyForOperation;
	    #qUDT_VfdOutputsSiemens.STW_1.OFF2 := TRUE;
	    #qUDT_VfdOutputsSiemens.STW_1.OFF3 := #qUDT_VfdOutputsNord.STW.EmergencyStop;
	    #qUDT_VfdOutputsSiemens.STW_1.EnableOperation := #qUDT_VfdOutputsNord.STW.ReadyForOperation;
	    #qUDT_VfdOutputsSiemens.STW_1.EnableSetpoint := TRUE;
	    #qUDT_VfdOutputsSiemens.SpeedSetpoint := #qUDT_VfdOutputsNord.FrequencySetPoint;
	    #qUDT_VfdOutputsSiemens.SetpointAcceleration := #qUDT_VfdOutputsNord.RampTimeSetPoint * 2;  //#cr_MaximumOutput is 16384 in siemens and 32676 in Nord drive 
	    #qUDT_VfdOutputsSiemens.SetpointDeceleration := #qUDT_VfdOutputsNord.RampTimeSetPoint * 2; //#cr_MaximumOutput is 16384 in siemens and 32676 in Nord drive 
	    
	END_REGION
	
	
END_FUNCTION

FUNCTION "FC_InterPLCHandshake" : Void
TITLE = Interconnection PLC Handshake
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 22
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_HandshakeInput : "UDT_PNCoupler_Interface";   // Input bytes from PN Coupler to the PLC
      ix_ConfigUpstream : Bool;   // True = Conveyor is the upstream conveyor; False = Conveyor is the downstream conveyor.
   END_VAR

   VAR_OUTPUT 
      qUDT_HandshakeOutput : "UDT_PNCoupler_Interface";   // Output bytes from PLC to the PN Coupler
   END_VAR

   VAR_IN_OUT 
      iqUDT_HandshakeDB : "UDT_ConveyorHandshake";   // Handshake Database
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	30/09/2019  | 2.1       | C. Leite      | first release MHS TIA 15.1
	09/10/2019  | 2.2       | C. Leite      | Bug correction
	04/11/2019  | 2.3       | C. Leite      | New PN Coupler handshake
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Downstream Configuration Inputs
	    
	    IF NOT #ix_ConfigUpstream
	    THEN
	        
	        #iqUDT_HandshakeDB.RTS := #iUDT_HandshakeInput.RTS;
	        #iqUDT_HandshakeDB.TIP := #iUDT_HandshakeInput.TIP;
	        #iqUDT_HandshakeDB.ResetEnergySave := #iUDT_HandshakeInput.ResetEnergySave;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Downstream Configuration Outputs
	    
	    IF NOT #ix_ConfigUpstream
	    THEN
	        
	        #qUDT_HandshakeOutput.DownstreamDisplacement := #iqUDT_HandshakeDB.DownstreamDisplacement;
	        #qUDT_HandshakeOutput.RTR := #iqUDT_HandshakeDB.RTR;
	        #qUDT_HandshakeOutput.CascadeStartUp := #iqUDT_HandshakeDB.CascadeStartUp;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Upstream Configuration Inputs
	    
	    IF #ix_ConfigUpstream
	    THEN
	        
	        #iqUDT_HandshakeDB.DownstreamDisplacement := #iUDT_HandshakeInput.DownstreamDisplacement;
	        #iqUDT_HandshakeDB.RTR := #iUDT_HandshakeInput.RTR;
	        #iqUDT_HandshakeDB.CascadeStartUp := #iUDT_HandshakeInput.CascadeStartUp;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Upstream Configuration Outputs
	    
	    IF #ix_ConfigUpstream
	    THEN
	        
	        #qUDT_HandshakeOutput.RTS := #iqUDT_HandshakeDB.RTS;
	        #qUDT_HandshakeOutput.TIP := #iqUDT_HandshakeDB.TIP;
	        #qUDT_HandshakeOutput.ResetEnergySave := #iqUDT_HandshakeDB.ResetEnergySave;
	        
	    END_IF;
	    
	END_REGION
	
	
END_FUNCTION

FUNCTION_BLOCK "FB_InductSpeedControl"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 16
// END_ATTRIBUTES
   VAR_INPUT 
      ix_PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Filtred signal of the PEC
      idiPEC_EoSDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Distance between photo eye and the end of conveyor [mm] in forward direction
      ii_TrackingEndPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Position of the tracking in the end of the conveyor
      ii_SpeedSetpointHigh { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Speed setpoint High [mm/s]
      ii_SpeedSetpointLow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Speed setpoint Low [mm/s]
   END_VAR

   VAR_OUTPUT 
      qi_Speed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
   END_VAR

   VAR_IN_OUT 
      iqi_Displacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Displacement per PLC scan [cm]
   END_VAR

   VAR 
      sR_TRIG_PEC {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sdi_ParcelTailAtEnd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Count tail to next conveyor distance
      sx_PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Auxiliary variable when the PEC detect the parcel
      sx_ParcelTailAtEnd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Tail at the end of the conveyor
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/02/2022  | 3.0       | M.Piela       | First release TIA 16.1
	17/02/2023  | 3.1       | F.Baten       | Added regions 
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Initial
	    // Low speed at startup 
	    IF "DB_Memory".FirstScan
	    THEN
	        #qi_Speed := #ii_SpeedSetpointLow;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Triggers
	    // Rising trigger PEC
	    #sR_TRIG_PEC(CLK := #ix_PEC);
	    
	END_REGION
	
	REGION 3 - Distance
	    
	    //Check if the parcel travels at the end of the conveyor
	    IF #sR_TRIG_PEC.Q AND (#sdi_ParcelTailAtEnd <= 0)
	    THEN
	        #sdi_ParcelTailAtEnd := (#idiPEC_EoSDistance / 10);
	    END_IF;
	    
	    IF #sdi_ParcelTailAtEnd > 0
	    THEN
	        #sdi_ParcelTailAtEnd -= #iqi_Displacement;
	        #sx_ParcelTailAtEnd := FALSE;
	    ELSE
	        #sx_ParcelTailAtEnd := TRUE;
	    END_IF;
	END_REGION
	
	
	REGION 4 - Control speed
	    
	    //When the parcel reach the end of the conveyor are in the last tracking number is no data then set the low speed.
	    IF (#sx_ParcelTailAtEnd AND (#ii_TrackingEndPosition = 0))
	    THEN
	        #qi_Speed := #ii_SpeedSetpointLow;
	    END_IF;
	    
	    // Set the High after detecting parcel on the photo cell
	    IF #sR_TRIG_PEC.Q
	    THEN
	        #qi_Speed := #ii_SpeedSetpointHigh;
	        
	    END_IF;
	END_REGION
	
	
	
	
	
	
	
	
END_FUNCTION_BLOCK

FUNCTION "FC_SeparateMsg" : Void
TITLE = FC_SeparateMsg
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 25
// END_ATTRIBUTES
//Function to separate the delimited message.
   VAR_INPUT 
      iUDT_Message : "UDT_Message";   // Character string to be separated
      ii_Position : Int;   // Start position
      ic_Delimiter : Char;   // Delimiter
      ic_EndSign : Char;   // End of the message sign
   END_VAR

   VAR_OUTPUT 
      qs_Msg : String;   // Separated part of the message
      qui_Length : UInt;   // Length of the separated message
      qx_EndMsg : Bool;   // End message sign found
      qx_NoSeparationSign : Bool;   // Separation sign not detected
   END_VAR

   VAR_TEMP 
      ti_i : Int;   // Loop counter
      tui_NrOfConvChar : UInt;   // Number of converted message characters
      ti_SizeOfMsg : Int;   // Message array size
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | K.Pokorski    | first release MHS TIA 15.1
	14/06/2019  | 0.2       | K.Pokorski    | "ii_Position" input, "qx_NoSeparationSign" output added, additional logic programmed 
	17/06/2019  | 0.3       | L.Klar        | "iqi_Position" deleted
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	26/07/2019  | 2.1       | M.Kurpiers    | Comments adjusted
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – Maximum number of the message characters
	    
	    #ti_SizeOfMsg := "FC_GetNrOfArrayEl"(iv_Array := #iUDT_Message.Character);
	    
	END_REGION
	
	REGION 2 – Message separation
	    
	    IF (#ii_Position <= #ti_SizeOfMsg - 1)                                        // Position is lower than size of a message array                                      
	    THEN
	        
	        // Delimiter and end sign search loop
	        FOR #ti_i := #ii_Position TO #ti_SizeOfMsg - 1 DO
	            
	            
	            IF (#iUDT_Message.Character[#ti_i] = #ic_Delimiter                    // Check if delimiter and the end of the message was found                   
	                OR #iUDT_Message.Character[#ti_i] = #ic_EndSign)
	                
	            THEN
	                
	                // Message length minus start position from INT to UInt conversion
	                #tui_NrOfConvChar := INT_TO_UINT(IN := (#ti_i - #ii_Position));
	                
	                IF #tui_NrOfConvChar <> 0
	                THEN
	                    // Character array into the message character string conversion
	                    Chars_TO_Strg(Chars := #iUDT_Message.Character,
	                                  pChars := #ii_Position,
	                                  Cnt := #tui_NrOfConvChar,
	                                  Strg => #qs_Msg);
	                    
	                ELSE
	                    #qs_Msg := '';
	                END_IF;
	                
	                // Length of the separated message part
	                #qui_Length := #tui_NrOfConvChar;
	                
	                // Separation sign not detected
	                #qx_NoSeparationSign := FALSE;
	                
	                
	                IF (#iUDT_Message.Character[#ti_i] = #ic_EndSign)                   // End of the message sign detected              
	                THEN
	                    
	                    #qx_EndMsg := TRUE;
	                    
	                ELSE
	                    
	                    #qx_EndMsg := FALSE;
	                    
	                END_IF;
	                // Exit the loop if end sign was found
	                EXIT;
	                
	                
	            ELSIF (#ti_i = #ti_SizeOfMsg - 1)                                         // Separate sign is not detected                                     
	            THEN
	                
	                // End of the message and no separation sign detected bits are set
	                #qs_Msg := '';
	                #qui_Length := 0;
	                #qx_EndMsg := TRUE;
	                #qx_NoSeparationSign := TRUE;
	                
	            END_IF;
	            
	        END_FOR;
	        // Clear variables if delimiter and end sign wasn't found    
	    ELSE
	        
	        #qs_Msg := '';
	        #qui_Length := 0;
	        #qx_EndMsg := TRUE;
	        #qx_NoSeparationSign := TRUE;
	        
	    END_IF;
	    
	END_REGION
END_FUNCTION

FUNCTION "FC_NordToSiemensVFDSimulationInput" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 23
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_VFDInputsSiemens : "UDT_VfdSiemensPI";
   END_VAR

   VAR_OUTPUT 
      iUDT_VFDInputsNord : "UDT_VfdNordPI";
   END_VAR

   VAR_TEMP 
      tx_dummy : Bool;
      ti_dummy : Int;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/11/2021  | 0.1       | M.Roijen      | Initial version TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Get VFD input of Siemens drive 
	    
	    #iUDT_VFDInputsNord.ZSW.BusControlActive := TRUE;
	    #iUDT_VFDInputsNord.ZSW.ReadyToStart := TRUE;
	    #iUDT_VFDInputsNord.ZSW.OperationEnabled := TRUE;
	    #iUDT_VFDInputsNord.ZSW.EmergencyStop := FALSE;
	    #iUDT_VFDInputsNord.ZSW.Fault := #iUDT_VFDInputsSiemens.ZSW_1.FaultActive;
	    #iUDT_VFDInputsNord.ZSW.WarningActive := #iUDT_VFDInputsSiemens.ZSW_1.AlarmActive;
	    #iUDT_VFDInputsNord.ActualSpeed := #iUDT_VFDInputsSiemens.ActualSpeed;
	    
	END_REGION
	
	
	
	
END_FUNCTION

FUNCTION "FC_TimeDiff" : Void
TITLE = FC_TimeDiff
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 28
// END_ATTRIBUTES
//Function to calculate time difference.
   VAR_INPUT 
      is_EarlierTimeAsString : String;   // Earlier time in string
      is_LaterTimeAsString : String;   // Later time in sting
   END_VAR

   VAR_OUTPUT 
      qt_TimeDifference : LTime;   // Difference between times
   END_VAR

   VAR_TEMP 
      tt_EarlierDate {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;   // Earlier date in DTL
      tt_LaterDate {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;   // Later date in DTL
      tt_LaterDateInc {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;   // Later date in DTL with one additional day
      tt_TimeDifference : LTime;   // Time differance
   END_VAR

   VAR CONSTANT 
      ct_OneDay : Time := T#1D;   // One day
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | K.Pokorski    | first release MHS TIA 15.1
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	26/08/2019  | 2.1       | M.Kurpiers    | Comments adjusted
	06/09/2019  | 2.2       | M.Kurpiers    | Change in region 2. Correcting the names of inputs variables.
	21/10/2019  | 2.3       | P.Majka       | Logic changed in region 2 and 3. Simpler checking for the date changed
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Conversion string TO DTL
	    
	    // Using MHS "FC_StringToTime" standard function convert time in string format to date in DTL format
	    "FC_StringToTime"(is_StringTime := #is_EarlierTimeAsString,
	                      qt_Date => #tt_EarlierDate);
	    
	    "FC_StringToTime"(is_StringTime := #is_LaterTimeAsString,
	                      qt_Date => #tt_LaterDate);
	    
	END_REGION
	
	REGION 2 - Difference between times   
	    
	    // Calculate difference between times
	    #tt_TimeDifference := #tt_LaterDate - #tt_EarlierDate;
	    
	    // Checking the negativity in the time difference                                              
	    IF (LTIME_TO_DINT(#tt_TimeDifference) < 0)
	    THEN
	        
	        // Add one day to later date - later time is smaller than ealier time 
	        #tt_LaterDateInc := T_ADD(IN1 := #tt_LaterDate, IN2 := #ct_OneDay);
	        
	        // Calculate difference between times 
	        #tt_TimeDifference := #tt_LaterDateInc - #tt_EarlierDate;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Write outputs
	    
	    // Saving time difference to the output    
	    #qt_TimeDifference := #tt_TimeDifference;
	    
	END_REGION
END_FUNCTION

FUNCTION_BLOCK "FB_ConveyorZPAlast"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_OUTPUT 
      qUDT_CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   //           Common status structure
   END_VAR

   VAR_IN_OUT 
      iqUDT_ConveyorInterface : "UDT_ConveyorInterface";   //           Handshake structure in forward direction
      iqUDT_ZPAinterface : "UDT_ZPAinterface";   //           Handshake structure in forward direction
      iqUDT_HandShake : "UDT_ConveyorHandshake";   //           Handshake structure in forward direction
   END_VAR

   VAR 
      sUDT_HandShake { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorHandshake";   //           Handshake structure in forward direction
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	02/10/2024  | 1.0       | R.Willems     | First release TIA 18
	                                       
	                                        
	*)
	
	REGION 1 Common status
	    //Write
	    #qUDT_CommonStatus := #iqUDT_ZPAinterface.CommonStatus;
	END_REGION
	
	REGION 2 Conveyor interface
	    REGION 2.1 Displacement
	        //Write
	        //NOT USED, USES OWN DISPLACEMENT
	        //#iqUDT_ConveyorInterface.Displacement := #iqUDT_ZPAinterface.ConveyorInterface.Displacement;
	        #iqUDT_ConveyorInterface.ActualSpeed := #iqUDT_ZPAinterface.ConveyorInterface.ActualSpeed;
	    END_REGION
	    REGION 2.1 PEC
	        //Connect ZPA Interface to PEC
	        #iqUDT_ConveyorInterface.InternalErrorReset := #iqUDT_ZPAinterface.ConveyorInterface.InternalErrorReset;
	        #iqUDT_ConveyorInterface.ResetStatistics := #iqUDT_ZPAinterface.ConveyorInterface.ResetStatistics;
	        //Read
	        #iqUDT_ZPAinterface.ConveyorInterface.InternalErrorPEC := #iqUDT_ConveyorInterface.InternalErrorPEC;
	    END_REGION
	END_REGION
	
	REGION 3 Handshake
	    //Write
	    #iqUDT_HandShake.GIN := #sUDT_HandShake.GIN := #iqUDT_ZPAinterface.Handshake.GIN;
	    //Write/Read
	    IF #iqUDT_HandShake.RTS <> #sUDT_HandShake.RTS THEN
	        #iqUDT_ZPAinterface.Handshake.RTS := #sUDT_HandShake.RTS := #iqUDT_HandShake.RTS;
	    ELSE
	        #iqUDT_HandShake.RTS := #sUDT_HandShake.RTS := #iqUDT_ZPAinterface.Handshake.RTS;
	    END_IF;
	    IF #iqUDT_HandShake.RTR <> #sUDT_HandShake.RTR THEN
	        #iqUDT_ZPAinterface.Handshake.RTR := #sUDT_HandShake.RTR := #iqUDT_HandShake.RTR;
	    ELSE
	        #iqUDT_HandShake.RTR := #sUDT_HandShake.RTR := #iqUDT_ZPAinterface.Handshake.RTR;
	    END_IF;
	    IF #iqUDT_HandShake.TIP <> #sUDT_HandShake.TIP THEN
	        #iqUDT_ZPAinterface.Handshake.TIP := #sUDT_HandShake.TIP := #iqUDT_HandShake.TIP;
	    ELSE
	        #iqUDT_HandShake.TIP := #sUDT_HandShake.TIP := #iqUDT_ZPAinterface.Handshake.TIP;
	    END_IF;
	END_REGION
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_Sensor"
TITLE = FB_PEC
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : Conveyor
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 219
// END_ATTRIBUTES
   VAR_INPUT 
      ix_PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Signal of the PEC
      iUDT_PECConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";   // PEC configuration structure
   END_VAR

   VAR_OUTPUT 
      qx_PECFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PEC Filtered
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";   // Status structure
   END_VAR

   VAR_IN_OUT 
      iqUDT_ConveyorInterface : "UDT_ConveyorInterface";   // Interface structure
      iqUDT_PECStatistics : "UDT_PECStatistics";   // Statistics structure
   END_VAR

   VAR 
      s_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatus";   // Status structure
      s_StatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatus";   // Auxiliary status structure
      sx_Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Enable
   END_VAR
   VAR RETAIN
      si_AuxJamDisplacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Auxiliary variable to calculate displacement when PEC is blocked
   END_VAR
   VAR 
      sx_PECFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Photo eye filtered
      PEC_TimerOnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Filtering end of section photo eye signal
      R_TRIG_PECJam {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger PEC jam
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	04/10/2019  | 2.0       | S. Nikodem    | first release TIA 15.1
	09/10/2019  | 2.1       | L.Klar        | Internal PEC error added
	28/10/2019  | 2.2       | S. Nikodem    | Change sign in region 2 - equal to greater then
	29/10/2019  | 2.3       | L.Klar        | UDT_PECStatus output variable changed, interface comments adjusted
	29/10/2019  | 2.4       | L.Klar        | Region 4 - time input corrected
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	26/11/2019  | 3.1       | P.Majka       | Static variable name change to PEC from EOS PEC
	12/12/2019  | 3.2       | C. Leite      | Absolute displacement value to control jam error in both directions
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	12/03/2024  | 4.1       | S. Nieswiec   | Small variable name changes according to current standard  
	*)
	
	REGION 1 - Triggers
	    
	    // Rising edge PEC Jam
	    #R_TRIG_PECJam(CLK := #s_Status.Jam);
	    
	END_REGION
	
	REGION 2 - Active function  
	    
	    // To activate the jam monitoring the jam displacement limit  must be configured up to zero. 
	    #sx_Enable := #iUDT_PECConfiguration.JamDisplacementLimit > 0;
	    
	END_REGION
	
	REGION 3 - Reset errors
	    
	    // Jam error is reset when reset bit is active and jam error is active and is connfigured alllow reset jam with PEC blocked or photo eye is not active
	    IF #iqUDT_ConveyorInterface.InternalErrorReset
	        AND (#iUDT_PECConfiguration.ResetWithPECBlocked
	        OR (NOT #iUDT_PECConfiguration.ResetWithPECBlocked
	        AND #sx_PECFiltered))
	        AND #s_Status.Jam
	    THEN
	        
	        #si_AuxJamDisplacement := 0;
	        #s_Status.Jam := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Photo eye filters
	    
	    // End of section photo eye signal filter timer
	    #PEC_TimerOnOffDelay(iudi_OnDelayTime := #iUDT_PECConfiguration.TimeOnDelay,
	                         iudi_OffDelayTime := #iUDT_PECConfiguration.TimeOffDelay,
	                         ix_SignalToDelay := #ix_PEC,
	                         ix_Enable := TRUE,
	                         qx_DelayedSignal => #sx_PECFiltered);
	    
	    // Write the current status of the photo eye
	    #s_Status.PEC := #sx_PECFiltered;
	    #qx_PECFiltered := #sx_PECFiltered;
	    
	END_REGION
	
	REGION 5 - Jam detection   
	    
	    IF NOT #sx_PECFiltered                                                    // Photo eye blocked
	        AND #sx_Enable                                                            // Active of checking the PEC jam 
	    THEN
	        
	        #si_AuxJamDisplacement += ABS(#iqUDT_ConveyorInterface.Displacement);
	        
	    ELSE
	        
	        #si_AuxJamDisplacement := 0;
	        
	    END_IF;
	    
	    // Compare jam auxiliary counter with displacement jam configured
	    IF #si_AuxJamDisplacement > #iUDT_PECConfiguration.JamDisplacementLimit
	    THEN
	        
	        #s_Status.Jam := TRUE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Statistics
	    
	    // Statistics Jam PEC
	    IF #s_Status.Jam                                                                // PEC jam error active
	        OR #iqUDT_ConveyorInterface.ResetStatistics                                       // Reset statistics
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #s_Status.Jam,
	                        ix_RTrigActivate := #R_TRIG_PECJam.Q,
	                        iqUDT_Statistics := #iqUDT_PECStatistics.Jam);
	        
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Internal PEC error
	    
	    IF #s_Status.Jam
	    THEN
	        
	        #iqUDT_ConveyorInterface.InternalErrorPEC := TRUE;
	        
	    END_IF;
	    
	END_REGION
	
	
	REGION 8 - Status
	    
	    // Status update on change
	    IF #s_StatusOld <> #s_Status
	    THEN
	        
	        #qUDT_HMIStatus := #s_Status;
	        #s_StatusOld := #s_Status;
	        
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION "FC_TimeToString" : Void
TITLE = FC_TimeToString
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 29
// END_ATTRIBUTES
//Function to convert date in DTL to the string format.
   VAR_INPUT 
      ia_Date {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;   // DTL format date
   END_VAR

   VAR_OUTPUT 
      qs_Date : String;   // String format date
   END_VAR

   VAR_TEMP 
      ta_StringDate : Struct   // String format date
         Year : String;   //   Year
         Month : String[2];   //   Month
         Day : String[2];   //   Day
         Hour : String[2];   //   Hour
         Minute : String[2];   //   Minunte
         Second : String[2];   //   Second
         Millisecond : String[4];   //   Millisecond
      END_STRUCT;
      ta_HTAReturn : Struct   // HTA operation status
         Year : Word;   //   Year
         Month : Word;   //   Month
         Day : Word;   //   Day
         Hour : Word;   //   Hour
         Minute : Word;   //   Minunte
         Second : Word;   //   Second
         Millisecond : Word;   //   Millisecond
      END_STRUCT;
   END_VAR

   VAR CONSTANT 
      ci_Positions4 : USInt := 4;   // Number of character positions
      ci_DecimalPlaces0 : USInt := 0;   // Number of decimal places
      ci_Format0 : USInt := 0;   // Output format of the characters
      ci_Position1 : USInt := 1;   // Character starting at which the result is written
      cc_Colon : Char := ':';   // Colon sign
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | K.Pokorski    | first release MHS TIA 15.1
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	27/08/2019  | 2.1       | M.Kurpiers    | Comments adjusted
	05/09/2019  | 2.2       | K.Pokorski    | FC changed from unoptimized to optimized
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	16/02/2023  | 3.1       | F.Baten       | Added constants
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Date and time separation
	    
	    // Convert the year into a character string
	    VAL_STRG(IN := #ia_Date.YEAR,
	             SIZE := #ci_Positions4,
	             PREC := #ci_DecimalPlaces0,
	             FORMAT := USINT_TO_WORD(#ci_Format0),
	             P := #ci_Position1,
	             OUT => #ta_StringDate.Year);
	    
	    // Using the HTA function, convert date into a string format
	    #ta_HTAReturn.Month := HTA(IN := WORD_TO_BYTE(INT_TO_BCD16((USINT_TO_INT(#ia_Date.MONTH)))), N := 1, OUT => #ta_StringDate.Month);                          // Convert the month  
	    #ta_HTAReturn.Day := HTA(IN := WORD_TO_BYTE(INT_TO_BCD16((USINT_TO_INT(#ia_Date.DAY)))), N := 1, OUT => #ta_StringDate.Day);                                // Convert the day  
	    #ta_HTAReturn.Hour := HTA(IN := WORD_TO_BYTE(INT_TO_BCD16((USINT_TO_INT(#ia_Date.HOUR)))), N := 1, OUT => #ta_StringDate.Hour);                             // Convert the hour  
	    #ta_HTAReturn.Minute := HTA(IN := WORD_TO_BYTE(INT_TO_BCD16((USINT_TO_INT(#ia_Date.MINUTE)))), N := 1, OUT => #ta_StringDate.Minute);                       // Convert the minute  
	    #ta_HTAReturn.Second := HTA(IN := WORD_TO_BYTE(INT_TO_BCD16((USINT_TO_INT(#ia_Date.SECOND)))), N := 1, OUT => #ta_StringDate.Second);                       // Convert the second  
	    #ta_HTAReturn.Millisecond := HTA(IN := INT_TO_BCD16((UDINT_TO_INT(#ia_Date.NANOSECOND / 1000000))), N := 2, OUT => #ta_StringDate.Millisecond);              // Convert the millisecond  
	    
	END_REGION
	
	REGION 2 - Timestamp preparation
	    
	    // Combine several input strings into one long output string
	    #qs_Date := (CONCAT(IN1 := #ta_StringDate.Year,
	                        IN2 := #cc_Colon,
	                        IN3 := #ta_StringDate.Month,
	                        IN4 := #cc_Colon,
	                        IN5 := #ta_StringDate.Day,
	                        IN6 := #cc_Colon,
	                        IN7 := #ta_StringDate.Hour,
	                        IN8 := #cc_Colon,
	                        IN9 := #ta_StringDate.Minute,
	                        IN10 := #cc_Colon,
	                        IN11 := #ta_StringDate.Second,
	                        IN12 := #cc_Colon,
	                        IN13 := RIGHT(IN := #ta_StringDate.Millisecond, L := 3)));
	    
	END_REGION
END_FUNCTION

FUNCTION_BLOCK "FB_EncoderFault"
TITLE = Block to handle encoder fault , statistics
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 8
// END_ATTRIBUTES
   VAR_INPUT 
      ix_EncoderPulses { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Signal from encoder
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EncoderStatus";   // Encoder fault status
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
      iqUDT_ConveyorInterface : "UDT_ConveyorInterface";   // Interface structure
   END_VAR

   VAR 
      sx_EncoderFault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // When TRUE encoder fault is active
      slr_ActualDelayTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Actual delay time [ms]
   END_VAR

   VAR CONSTANT 
      cudi_EncoderFaultDelayTime : UDInt := 5000;   // Time after which the encoder fault is activated
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	19/07/2022  | 0.1       | M.Kurpiers    | first release MHS TIA 16.0
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Reset encoder error
	    
	    IF #iqUDT_EquipmentControl.Command.Reset OR #iqUDT_ConveyorInterface.InternalErrorReset THEN
	        #sx_EncoderFault := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Set encoder error
	    
	    IF #iqUDT_ConveyorInterface.ActualSpeed > 0
	        AND NOT #ix_EncoderPulses
	        AND NOT #iqUDT_ConveyorInterface.ManualModeActive THEN
	        
	        #slr_ActualDelayTime += "DB_Memory".PrevCycleTime;
	        
	        IF #slr_ActualDelayTime >= #cudi_EncoderFaultDelayTime THEN
	            #sx_EncoderFault := TRUE;
	        END_IF;
	    ELSE
	        #slr_ActualDelayTime := 0;
	    END_IF;
	    
	    #iqUDT_ConveyorInterface.InternalErrorEncoder := #sx_EncoderFault;
	    
	END_REGION
	
	REGION 3 - Status
	    
	    #qUDT_HMIStatus.Fault := #sx_EncoderFault;
	    
	END_REGION
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_Valve"
TITLE = Single ended Valve Control and monitor
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'I.Ajram'
VERSION : 0.1
   VAR_INPUT 
      iUDT_Configuration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ValveConfiguration";   // Valve configuration
      ix_Open { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Open command (Hold if ControlMode = 1, pulse if ControlMode = 2)
      ix_Close { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Close command (Not used if ControlMode = 1, pulse if ControlMode = 2)
      ix_IsOpened { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Feedback Signal ( Not used if #iqUDT_SEVConfiguration.IsOpenFeedBackExist is FALSE)
      ix_IsClosed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Feedback Signal ( Not used if #iqUDT_SEVConfiguration.IsCloseFeedBackExist is FALSE)
      ix_AirPressureOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Air pressure is healthy
   END_VAR

   VAR_OUTPUT 
      qx_Open { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Open command
      qx_Close { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Close command
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ValveStatus";
      qUDT_Statistics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ValveStatistics";
   END_VAR

   VAR_IN_OUT 
      iqUDT_HMICommand : "UDT_ValveCommand";   // Interafce for HMI commands
      iqUDT_Interface : "UDT_ValveInterface";   // Interface with external modules
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
   END_VAR

   VAR 
      sx_ManualModeSelected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_AutoModeSelected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_OpenActivated { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_CloseActivated { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_FaultActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sTON_Opening {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
      sTON_Closing {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
      sTime_Closing { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;
      sTime_Opening { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;
      RTRIG_Open {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      RTRIG_Close {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      RTRIG_FaultActive {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      RTRIG_Opened {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
   END_VAR

   VAR CONSTANT 
      ci_ControlModeHold : Int := 1;   // Energize to hold
      ci_ControlModePulse : Int := 2;   // Pulse energized to change state
      ci_ValveTypeSEV : Int := 1;   // Single coil valve
      ci_ValveTypeDEV : Int := 2;   // Double coil valve, bi-stable, latching
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	08/07/2024  | 0.1       | I. Ajram      | first release TIA 18
	16/07/2024  | 0.2       | I. Ajram      | Changed block name from FB_SEV to FB_Valve
	                                        |  +    Added Configuration to allow for SEV and DEV
	                                        |  +    Added qx_Close Output
	                                        |  +    Added logic to accomodate for DEV
	30/08/2024  | 0.3       | J. Majer      | Added comments, number regions, added iq_UDT_EquipmentInterface, iqUDT_EquipmentControl                                         
	----------------------------------------------------------------------------------------
	
	*)
	
	REGION 1 - Edge detection
	    // Trigger rising edge detection for different signals: Open, Close, FaultActive, and Opened.
	    #RTRIG_Open(CLK := #ix_Open OR #iqUDT_Interface.Open);
	    #RTRIG_Close(CLK := #ix_Close OR #iqUDT_Interface.Close);
	    #RTRIG_FaultActive(CLK := #sx_FaultActive);
	    #RTRIG_Opened(CLK := #qUDT_HMIStatus.Specific.Opened);
	    
	END_REGION
	
	REGION 2 - Auto / Manual
	    
	    // Handle auto mode command.
	    IF #iqUDT_EquipmentControl.Command.Start AND #iqUDT_EquipmentControl.Command.AutomaticOn
	    THEN
	        #sx_AutoModeSelected := TRUE;
	        #sx_ManualModeSelected := FALSE;
	        #iqUDT_HMICommand.AutoMode := FALSE;
	    END_IF;
	    
	    // Manual mode bits inputs can be reset in case of malfunction
	    IF #iqUDT_EquipmentControl.Command.DisableManualMode
	    THEN
	        #iqUDT_HMICommand.ManualMode := FALSE;
	        #iqUDT_EquipmentControl.Command.ManualMode := FALSE;
	    END_IF;
	    
	    // Handle manual mode command.
	    IF (#iqUDT_EquipmentControl.Command.ManualMode OR #iqUDT_HMICommand.ManualMode)
	        AND NOT #iqUDT_EquipmentControl.Command.DisableManualMode
	    THEN
	        #sx_AutoModeSelected := FALSE;
	        #sx_ManualModeSelected := TRUE;
	        #iqUDT_HMICommand.ManualMode := FALSE;
	    END_IF;
	    
	    REGION 2.1 - Restart request
	        
	        // Indicating need for system restart if no mode is selected
	        #iqUDT_EquipmentControl.Request.RestartRequired := NOT #sx_AutoModeSelected
	        AND NOT #sx_AutoModeSelected;
	        
	    END_REGION
	END_REGION
	
	REGION 3 - Faults
	    
	    REGION 3.1 - Configuration Error
	        // Check for configuration errors by validating the ControlMode and ValveType values.
	        IF #iUDT_Configuration.ControlMode < #ci_ControlModeHold
	            OR #iUDT_Configuration.ControlMode > #ci_ControlModePulse
	            OR #iUDT_Configuration.ValveType < #ci_ValveTypeSEV
	            OR #iUDT_Configuration.ValveType > #ci_ValveTypeDEV
	        THEN
	            #qUDT_HMIStatus.Specific.ConfigurationError := TRUE;
	        ELSE
	            #qUDT_HMIStatus.Specific.ConfigurationError := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 3.2 - Low Pressure
	        // Set AirPressureLost flag if air pressure is not okay.
	        IF NOT #ix_AirPressureOk THEN
	            #qUDT_HMIStatus.Specific.AirPressureLost := TRUE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 3.3 - Fail to Open
	        // Set FailToOpen flag if the valve failed to open within the expected time.
	        IF #sTON_Opening.Q AND #iUDT_Configuration.OpenFeedBackExist THEN
	            #qUDT_HMIStatus.Specific.FailToOpen := TRUE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 3.4 - Fail to Close
	        // Set FailToClose flag if the valve failed to close within the expected time.
	        IF #sTON_Closing.Q AND #iUDT_Configuration.CloseFeedBackExist THEN
	            #qUDT_HMIStatus.Specific.FailToClose := TRUE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 3.4 - Collective fault
	        // Set FaultActive flag if any specific fault is detected (fail to open/close, air pressure lost, or configuration error).
	        #sx_FaultActive := #qUDT_HMIStatus.Specific.FailToClose OR
	        #qUDT_HMIStatus.Specific.FailToOpen OR
	        #qUDT_HMIStatus.Specific.AirPressureLost OR
	        #qUDT_HMIStatus.Specific.ConfigurationError;
	        
	        // forward error to the interface with other modules
	        #iqUDT_Interface.Error := #sx_FaultActive;
	        
	        // If FaultActive is set, deactivate open and close commands.
	        IF #sx_FaultActive THEN
	            #sx_OpenActivated := FALSE;
	            #sx_CloseActivated := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 3.5 - Reset
	        // Reset fault flags and set air pressure flag based on the state of AirPressureOk.
	        IF #iqUDT_EquipmentControl.Command.Reset THEN
	            #qUDT_HMIStatus.Specific.FailToOpen := FALSE;
	            #qUDT_HMIStatus.Specific.FailToClose := FALSE;
	            #qUDT_HMIStatus.Specific.AirPressureLost := NOT #ix_AirPressureOk;
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 4 - Command
	    // Process commands based on the current mode (Auto/Manual) and fault state.
	    IF NOT #sx_FaultActive THEN
	        
	        REGION 4.1 - Auto
	            // Handle command logic in Auto mode based on control mode (Hold or Pulse).
	            IF #sx_AutoModeSelected THEN
	                CASE #iUDT_Configuration.ControlMode OF
	                        
	                        // ControlModeHold: Open/close based on the ix_Open signal.
	                    #ci_ControlModeHold:
	                        #sx_OpenActivated := #ix_Open;
	                        #sx_CloseActivated := NOT #ix_Open;
	                        
	                        // ControlModePulse: Open/close based on rising edge detection.
	                    #ci_ControlModePulse:
	                        IF #RTRIG_Open.Q AND NOT #ix_IsOpened THEN
	                            #sx_OpenActivated := TRUE;
	                            #sx_CloseActivated := FALSE;
	                        END_IF;
	                        
	                        IF #RTRIG_Close.Q AND NOT #ix_IsClosed THEN
	                            #sx_OpenActivated := FALSE;
	                            #sx_CloseActivated := TRUE;
	                        END_IF;
	                        
	                END_CASE;
	            END_IF;
	            
	        END_REGION
	        
	        REGION 4.2 - Manual
	            // Handle command logic in Manual mode based on control mode (Hold or Pulse).
	            IF #sx_ManualModeSelected THEN
	                CASE #iUDT_Configuration.ControlMode OF
	                        
	                        // ControlModeHold: Open/close based on manual commands.
	                    #ci_ControlModeHold:
	                        #sx_OpenActivated := #iqUDT_HMICommand.ManualOpen;
	                        #sx_CloseActivated := #iqUDT_HMICommand.ManualClose;
	                        
	                        // ControlModePulse: Open/close based on manual commands with feedback checks.
	                    #ci_ControlModePulse:
	                        IF #iqUDT_HMICommand.ManualOpen AND NOT #ix_IsOpened THEN
	                            #sx_OpenActivated := TRUE;
	                            #sx_CloseActivated := FALSE;
	                            #iqUDT_HMICommand.ManualOpen := FALSE;
	                        END_IF;
	                        
	                        IF #iqUDT_HMICommand.ManualClose AND NOT #ix_IsClosed THEN
	                            #sx_OpenActivated := FALSE;
	                            #sx_CloseActivated := TRUE;
	                            #iqUDT_HMICommand.ManualClose := FALSE;
	                        END_IF;
	                        
	                END_CASE;
	            END_IF;
	            
	        END_REGION
	    ELSE
	        // On fault, clear all open/close commands.
	        #sx_OpenActivated := FALSE;
	        #sx_CloseActivated := FALSE;
	        #iqUDT_HMICommand.ManualClose := FALSE;
	        #iqUDT_HMICommand.ManualOpen := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Statistics
	    // Update statistical data when reset or fault occurs.
	    IF #iqUDT_EquipmentControl.Command.ResetData OR #sx_FaultActive THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sx_FaultActive,
	                        ix_RTrigActivate := #RTRIG_FaultActive.Q,
	                        iqUDT_Statistics := #qUDT_Statistics.Fail);
	    END_IF;
	    
	    // Update open statistics when reset or opened.
	    IF #iqUDT_EquipmentControl.Command.ResetData OR #qUDT_HMIStatus.Specific.Opened THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #qUDT_HMIStatus.Specific.Opened,
	                        ix_RTrigActivate := #RTRIG_Opened.Q,
	                        iqUDT_Statistics := #qUDT_Statistics.Open);
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Status
	    
	    REGION 6.1 - Opened / Closed
	        // Handle open/close status based on feedback or timers.
	        IF #iUDT_Configuration.OpenFeedBackExist THEN
	            // Set opened status based on feedback.
	            #qUDT_HMIStatus.Specific.Opened := #ix_IsOpened;
	        ELSE
	            // Use opening timer as an indicator if feedback is not available.
	            IF #sTON_Opening.Q THEN
	                #qUDT_HMIStatus.Specific.Opened := TRUE;
	            END_IF;
	            IF #sx_CloseActivated THEN
	                #qUDT_HMIStatus.Specific.Opened := FALSE;
	            END_IF;
	        END_IF;
	        
	        // Module interface valve feedback opened 
	        #iqUDT_Interface.IsOpened := #qUDT_HMIStatus.Specific.Opened;
	        
	        IF #iUDT_Configuration.CloseFeedBackExist THEN
	            // Set closed status based on feedback.
	            #qUDT_HMIStatus.Specific.Closed := #ix_IsClosed;
	        ELSE
	            // Use closing timer as an indicator if feedback is not available.
	            IF #sTON_Closing.Q THEN
	                #qUDT_HMIStatus.Specific.Closed := TRUE;
	            END_IF;
	            IF #sx_OpenActivated THEN
	                #qUDT_HMIStatus.Specific.Closed := FALSE;
	            END_IF;
	        END_IF;
	        
	        // Module interface valve feedback closed 
	        #iqUDT_Interface.IsClosed := #qUDT_HMIStatus.Specific.Closed;
	        
	    END_REGION
	    
	    REGION 6.2 - Opening
	        // Handle the logic for the valve opening, including timer initialization and status updates.
	        IF #iUDT_Configuration.OpenTime = 0 THEN
	            #sTime_Opening := T#1s;  // Default to 1 second if not configured.
	        ELSE
	            #sTime_Opening := INT_TO_TIME(#iUDT_Configuration.OpenTime);  // Use configured open time.
	        END_IF;
	        
	        IF #sx_OpenActivated AND NOT #qUDT_HMIStatus.Specific.Opened THEN
	            #qUDT_HMIStatus.Specific.Opening := TRUE;
	        ELSE
	            #qUDT_HMIStatus.Specific.Opening := FALSE;
	        END_IF;
	        
	        // Start the opening timer.
	        #sTON_Opening(IN := #qUDT_HMIStatus.Specific.Opening,
	                      PT := #sTime_Opening);
	        
	    END_REGION
	    
	    REGION 6.3 - Closing
	        // Handle the logic for the valve closing, including timer initialization and status updates.
	        IF #iUDT_Configuration.CloseTime = 0 THEN
	            #sTime_Closing := T#1s;  // Default to 1 second if not configured.
	        ELSE
	            #sTime_Closing := INT_TO_TIME(#iUDT_Configuration.CloseTime);  // Use configured close time.
	        END_IF;
	        
	        IF #sx_CloseActivated AND NOT #qUDT_HMIStatus.Specific.Closed THEN
	            #qUDT_HMIStatus.Specific.Closing := TRUE;
	        ELSE
	            #qUDT_HMIStatus.Specific.Closing := FALSE;
	        END_IF;
	        
	        // Start the closing timer.
	        #sTON_Closing(IN := #qUDT_HMIStatus.Specific.Closing,
	                      PT := #sTime_Closing);
	        
	    END_REGION
	    
	END_REGION
	
	REGION 7 - Output
	    
	    // Select the action based on the valve type configuration
	    CASE #iUDT_Configuration.ValveType OF
	            
	            // SEV Valve Type
	        #ci_ValveTypeSEV:
	            // The valve opens if Open is activated, Close is not activated, and no fault is active
	            #qx_Open :=
	            #sx_OpenActivated AND
	            NOT #sx_CloseActivated AND
	            NOT #sx_FaultActive;
	            
	            // Reset the open signal, SEV logic requires manual reset after operation
	            #qx_Open := FALSE;
	            
	            // DEV Valve Type
	        #ci_ValveTypeDEV:
	            // The valve opens if there are no faults, Open is activated, and the valve is not yet opened
	            #qx_Open :=
	            NOT #sx_FaultActive AND
	            #sx_OpenActivated AND NOT #qUDT_HMIStatus.Specific.Opened;
	            
	            // The valve closes if there are no faults, Close is activated, and the valve is not yet closed
	            #qx_Close :=
	            NOT #sx_FaultActive AND
	            #sx_CloseActivated AND NOT #qUDT_HMIStatus.Specific.Closed;
	            
	            // If the valve is opened, a fault occurs, or the valve is in the closing state, deactivate Open
	            IF #qUDT_HMIStatus.Specific.Opened OR
	                #sx_FaultActive OR
	                #qUDT_HMIStatus.Specific.Closing
	            THEN
	                #sx_OpenActivated := FALSE;
	            END_IF;
	            
	            // If the valve is closed, a fault occurs, or the valve is in the opening state, deactivate Close
	            IF #qUDT_HMIStatus.Specific.Closed OR
	                #sx_FaultActive OR
	                #qUDT_HMIStatus.Specific.Opening
	            THEN
	                #sx_CloseActivated := FALSE;
	            END_IF;
	            
	    END_CASE;
	    
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_ConveyorPanel"
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 6
// END_ATTRIBUTES
//Main switch and 24V feeedback available in VFD cabinet
   VAR_INPUT 
      ix_MainSwitchOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE if main switch with no fault
      ix_CBFeedback { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE if circuit breacker is ON
      ix_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when hardware is Ok
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorPanelStatus";   // HMI status structure
   END_VAR

   VAR_IN_OUT 
      iqUDT_ConveyorInterface : "UDT_ConveyorInterface";   // Conveyor interface structure
      iqUDT_Statistics : "UDT_ConveyorPanelStatistics";   // Statistics structure
   END_VAR

   VAR 
      sUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorPanelStatus";   // Conveyor Panel status UDT
      sR_Trig_24VDC {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rise trigger when a 24VDC fault occurs
      sR_Trig_MainSwitch {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rise trigger when a Main switch fault occurs
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	10/01/2020  | 3.0       | S. Nikodem    | first release MHS TIA 15.1
	16/10/2020  | 3.1       | S. Deulkar    | Changed 24VDc input name to CBFeedback, also UDT are updated
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Triggers
	    
	    // Rise trigger 24VDC status
	    #sR_Trig_24VDC(CLK := #sUDT_HMIStatus.CBFeedbackError);
	    
	    // Rise trigger Main switch status
	    #sR_Trig_MainSwitch(CLK := #sUDT_HMIStatus.MainSwitchOff);
	    
	END_REGION
	
	REGION 2 - Reset error
	    
	    IF #iqUDT_ConveyorInterface.InternalErrorReset
	    THEN
	        
	        #sUDT_HMIStatus.CBFeedbackError := FALSE;
	        #sUDT_HMIStatus.MainSwitchOff := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Faults monitoring 
	    
	    // 24 VDC fault status is set when the 24V error occurred
	    IF NOT #ix_CBFeedback
	    THEN
	        
	        #sUDT_HMIStatus.CBFeedbackError := TRUE;
	        
	    END_IF;
	    
	    // Main switch fault status is set when the main switch error occurred
	    IF NOT #ix_MainSwitchOk
	    THEN
	        
	        #sUDT_HMIStatus.MainSwitchOff := TRUE;
	        
	    END_IF;
	    
	    // Set disconnect bit on Conveyor interface 
	    #iqUDT_ConveyorInterface.Disconnected := #sUDT_HMIStatus.CBFeedbackError OR #sUDT_HMIStatus.MainSwitchOff;
	    
	    // Move static structure to output
	    #qUDT_HMIStatus := #sUDT_HMIStatus;
	    
	END_REGION
	
	REGION 4 - Statistics
	    
	    // 24 VDC Supply fault statistics
	    
	    IF #sUDT_HMIStatus.CBFeedbackError
	        OR #iqUDT_ConveyorInterface.ResetStatistics
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #sUDT_HMIStatus.CBFeedbackError,
	                        ix_RTrigActivate := #sR_Trig_24VDC.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.CBFeedbackError);
	        
	    END_IF;
	    
	    // Main switch fault statistics
	    
	    IF #sUDT_HMIStatus.MainSwitchOff
	        OR #iqUDT_ConveyorInterface.ResetStatistics
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #sUDT_HMIStatus.MainSwitchOff,
	                        ix_RTrigActivate := #sR_Trig_MainSwitch.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.MainSwitchOff);
	        
	    END_IF;
	    
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_ConvertGIN"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 5
// END_ATTRIBUTES
   VAR_INPUT 
      ii_GINRangeStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // GIN range start
      ii_GINRangeEnd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // GIN range end
   END_VAR

   VAR_IN_OUT 
      iqUDT_Handshake : "UDT_ConveyorHandshake";   // Conveyor handshake structure
      iqUDT_UnknownGIN : "UDT_UnknownGIN";   // Unknown GIN structure
   END_VAR

   VAR 
      sR_TRIG_NewGINDetected {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // New GIN detected rising edge
      si_LastGenGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Last generated GIN
      si_GenGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Generated GIN
      si_DetectedGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Last detected GIN
      sx_GINOutOfRange { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // GIN out of range
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	15/01/2020  | 3.0       | L.Klar        | first release MHS TIA 15.1
	03/03/2020  | 3.1       | P. Pielucha   | Adapting reviews
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – GIN generator initialization
	    
	    // Initialize GIN if last generated GIN is out of configured range.
	    IF (#si_LastGenGIN < #ii_GINRangeStart
	        OR #si_LastGenGIN > #ii_GINRangeEnd)
	    THEN
	        
	        #si_LastGenGIN := #ii_GINRangeStart - 1;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 – GIN conversion
	    
	    // Riding edge on new GIN detected
	    #sR_TRIG_NewGINDetected(CLK := #iqUDT_Handshake.GIN > 0 AND #iqUDT_Handshake.GIN <> #si_DetectedGIN);
	    
	    // Check if detected GIN is out of normal and unknown GIN ranges 
	    #sx_GINOutOfRange := (#iqUDT_Handshake.GIN < #ii_GINRangeStart
	    OR #iqUDT_Handshake.GIN > #ii_GINRangeEnd)
	    AND (#iqUDT_Handshake.GIN < #iqUDT_UnknownGIN.Start OR
	    #iqUDT_Handshake.GIN > #iqUDT_UnknownGIN.End);
	    
	    // Generate new GIN if new GIN was detected
	    IF (#sR_TRIG_NewGINDetected.Q
	        AND #sx_GINOutOfRange)
	    THEN
	        
	        #si_DetectedGIN := #iqUDT_Handshake.GIN;
	        
	        IF (#si_LastGenGIN < #ii_GINRangeEnd)
	        THEN
	            
	            #si_GenGIN := #si_LastGenGIN + 1;
	            #si_LastGenGIN += 1;
	            
	        ELSE
	            
	            #si_GenGIN := #ii_GINRangeStart;
	            #si_LastGenGIN := #ii_GINRangeStart;
	            
	        END_IF;
	        
	        // Copy detected GIN record to new generated GIN
	        "DB_GIN".GIN[#si_GenGIN] := "DB_GIN".GIN[#si_DetectedGIN];
	        
	    END_IF;
	    
	    // GIN update
	    IF (#iqUDT_Handshake.GIN > 0
	        AND #sx_GINOutOfRange)
	    THEN
	        
	        #iqUDT_Handshake.GIN := #si_GenGIN;
	        
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_GapOptimizationSystem"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 9
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_GOSConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_GapOptimizationSystemConfiguration";   // UDT of the Gap Optimization System Configuration
      iUDT_ConvA { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorInterface";
      iUDT_ConvB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorInterface";
      iUDT_ConvC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorInterface";
      iUDT_ConvUpstream { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorInterface";
      iUDT_HandshakeUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorHandshake";
      ii_LoopSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 2900;   // Set Speed of Loop conveyors
      ix_PECUpstream { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ix_PECA1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // BOS PEC of conveyor A
      ix_PECA2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // EOS PEC of conveyor A
      ix_PECB1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // BOS PEC of conveyor B
      ix_PECB2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // EOS PEC of conveyor B
      ix_PECC1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // BOS PEC of conveyor C
      ix_PECC2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // EOS PEC of conveyor C
      ix_PECDownstream { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_OUTPUT 
      qUDT_GOSStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_GapOptimizationSystemStatus";   // UDT of the Gap Optimization System Status
   END_VAR

   VAR_IN_OUT 
      iqUDT_GOSInterface : "UDT_GapOptimizationSystemInterface";   // UDT of the Gap Optimization System Interface
      iqUDT_GOSLog : Array[*] of "UDT_GOSLog";
      iqa_TrackingDataUpstream : Array[*] of Int;   // Tracking data of the upstream conveyor
      iqa_TrackingDataA : Array[*] of Int;   // Tracking data of conveyor A
      iqa_TrackingDataB : Array[*] of Int;   // Tracking data of conveyor B
      iqa_TrackingDataC : Array[*] of Int;   // Tracking data of conveyor C
      iqa_TrackingDataDownstream : Array[*] of Int;   // Tracking data of the downstream conveyor
      iqx_ShiftRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request to Shift
   END_VAR

   VAR 
      sr_TravelDistanceUpstreamParc { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Travel distance of the upstream parcel (mm)
      sr_TravelDistanceCurrentParcA { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Travel distance of the current parcel on Conv. A (mm)
      sr_TravelDistanceUpstreamParcA { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Travel distance of the upstream parcel before it reaches Conv. A (mm)
      sr_TravelDistanceCurrentParcB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Travel distance of the current parcel on Conv. B (mm)
      sr_TravelDistanceUpstreamParcB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Travel distance of the upstream parcel before it reaches Conv. B (mm)
      sr_TravelDistanceCurrentParcC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Travel distance of the current parcel on Conv. C (mm)
      sa_ParcelA1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Struct of a parcel
         GIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // GIN number
         Length { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length current parcel (mm)
         GapUpstream { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length of the gap upstream (mm)
         GapDownstream { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length of the gap downstream (mm)
         GapToBeRecovered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length of the recovered gap (mm)
         GapCovered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length of  the covered gap (mm)
         LogNr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         Accelerate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True is acceleration needed
         Decelerate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True is deceleration needed
      END_STRUCT;
      sa_ParcelB1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Struct of a parcel
         GIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // GIN number
         Length { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length current parcel (mm)
         GapUpstream { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length of the gap upstream (mm)
         GapDownstream { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length of the gap downstream (mm)
         GapToBeRecovered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length of the recovered gap (mm)
         GapCovered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length of  the covered gap (mm)
         LogNr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         Accelerate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True is acceleration needed
         Decelerate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True is deceleration needed
      END_STRUCT;
      sa_ParcelC1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Struct of a parcel
         GIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // GIN number
         Length { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length current parcel (mm)
         GapUpstream { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length of the gap upstream (mm)
         GapDownstream { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length of the gap downstream (mm)
         GapToBeRecovered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length of the recovered gap (mm)
         GapCovered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length of  the covered gap (mm)
         LogNr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         Accelerate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True is acceleration needed
         Decelerate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True is deceleration needed
      END_STRUCT;
      sa_ParcelC2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Struct of a parcel
         GIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // GIN number
         Length { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length current parcel (mm)
         GapUpstream { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length of the gap upstream (mm)
         GapDownstream { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length of the gap downstream (mm)
         GapToBeRecovered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length of the recovered gap (mm)
         GapCovered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length of  the covered gap (mm)
         LogNr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         Accelerate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True is acceleration needed
         Decelerate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True is deceleration needed
      END_STRUCT;
      ss_AnotherParcelatB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Struct of a parcel
         GIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // GIN number
         Length { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length current parcel (mm)
         GapUpstream { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length of the gap upstream (mm)
         GapDownstream { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length of the gap downstream (mm)
         GapToBeRecovered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length of the recovered gap (mm)
         GapCovered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length of  the covered gap (mm)
         LogNr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         Accelerate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True is acceleration needed
         Decelerate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True is deceleration needed
      END_STRUCT;
      R_TRIG_PEC_Upstream {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising triggering of the 2ste PEC of the upstream conveyor
      F_TRIG_PEC_Upstream {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling triggering of the 2ste PEC of the upstream conveyor
      R_TRIG_PEC_Downstream {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising triggering of the PEC of the downstream conveyor
      F_TRIG_PEC_Downstream {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling triggering of the PEC of the downstream conveyor
      F_TRIG_PEC_A1 {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling triggering of the 1ste PEC of conveyor A
      F_TRIG_PEC_A2 {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling triggering of the 2nd PEC of conveyor A
      F_TRIG_PEC_B1 {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling triggering of the 1ste PEC of conveyor B
      F_TRIG_PEC_B2 {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling triggering of the 2nd PEC of conveyor B
      F_TRIG_PEC_C1 {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling triggering of the 1ste PEC of conveyor C
      F_TRIG_PEC_C2 {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling triggering of the 2nd PEC of conveyor C
      R_TRIG_PEC_A1 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising triggering of the 1ste PEC of conveyor A
      R_TRIG_PEC_A2 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising triggering of the 2nd PEC of conveyor A
      R_TRIG_PEC_B1 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising triggering of the 1ste PEC of conveyor B
      R_TRIG_PEC_B2 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising triggering of the 2nd PEC of conveyor B
      R_TRIG_PEC_C1 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising triggering of the 1ste PEC of conveyor C
      R_TRIG_PEC_C2 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising triggering of the 2nd PEC of conveyor C
      R_TRIG_DataStartConvA {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      R_TRIG_DataStartConvB {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      R_TRIG_DataStartConvC {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      F_TRIG_TwoParcelsOnConvA {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;
      F_TRIG_TwoParcelsOnConvB {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;
      F_TRIG_TwoParcelsOnConvC {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;
      Slr_TimeSpeedChangeConvA { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;
      Slr_TimeSpeedChangeConvB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;
      Slr_TimeSpeedChangeConvC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;
      si_CountNr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Counting the amount of parcels
      si_SpeedA { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Setpoint speed for conveyor A (mm/s)
      si_SpeedB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Setpoint speed for conveyor B (mm/s)
      si_SpeedC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Setpoint speed for conveyor C (mm/s)
      si_DistanceTravelled_A_B { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Distance travelled for conveyor A and B (mm)
      si_DistanceTravelled_B_C { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Distance travelled for conveyor B and C (mm)
      si_ParcelGapRecovered_A { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Actual gap that is recovered by conveyor A
      si_ParcelGapRecovered_C { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Actual gap that is recovered by conveyor B
      si_ParcelGapRecovered_B { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Actual gap that is recovered by conveyor C
      si_ParcelDownStreamResults { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // The result of the downstream gap recovered
      si_LoopCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Counter for loop
      si_MaxNumberofEntries { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum number of FIFO entries
      si_ReturnValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Info Code of Move Block Siemens
      s_ConveyorA_GIN1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      s_ConveyorA_GIN2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      s_ConveyorB_GIN1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      s_ConveyorB_GIN2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      s_ConveyorC_GIN1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      s_ConveyorC_GIN2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      s_TailPositionParcelA { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      s_TailPositionParcelB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      s_TailPositionParcelC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      sx_ParcelsOnConveyor_A { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True = parcel is on the conveyor A
      sx_ParcelsOnConveyor_B { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;   // True = parcel is on the conveyor B
      sx_ParcelsOnConveyor_C { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;   // True = parcel is on the conveyor C
      sx_ActionConv_A { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True = release for the conveyor to get the setpoint
      sx_ActionConv_B { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True = release for the conveyor to get the setpoint
      sx_ActionConv_C { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True = release for the conveyor to get the setpoint
      sx_WaitCurrentParcel_A_B { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True = wait till next parcel left the next conveyor and then calculate again
      sx_WaitCurrentParcel_B_C { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True = wait till next parcel left the next conveyor and then calculate again
      sx_anotherparcelonConveyorB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sr_TravelDistance_CurrentnewParc_B { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;
      sx_twoParcelsOnConveyor_A { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_twoParcelsOnConveyor_B { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_twoParcelsOnConveyor_C { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      SetNominalSpeedA { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      SetNominalSpeedB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      SetNominalSpeedC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	21/01/2020  | 1.0       | R. Joosse     | first release TIA 15.1
	04/04/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	12/02/2024  | 4.1       | S.Nieswiec    | Variable name changes according to standard
	*)
	REGION 1 - Initialize 
	    
	    REGION 1.1 Firstscan
	        
	        IF "DB_Memory".FirstScan THEN
	            #si_SpeedA := #ii_LoopSpeed;
	            #si_SpeedB := #ii_LoopSpeed;
	            #si_SpeedC := #ii_LoopSpeed;
	        END_IF;
	        #s_ConveyorA_GIN1 := 0;
	        #s_ConveyorA_GIN2 := 0;
	        #s_TailPositionParcelA := 0;
	        #s_ConveyorB_GIN1 := 0;
	        #s_ConveyorB_GIN2 := 0;
	        #s_TailPositionParcelB := 0;
	        #s_ConveyorC_GIN1 := 0;
	        #s_ConveyorC_GIN2 := 0;
	        #s_TailPositionParcelC := 0;
	        
	    END_REGION
	    
	    REGION 1.2 Triggers
	        
	        #R_TRIG_PEC_Upstream(CLK := #ix_PECUpstream);
	        #F_TRIG_PEC_Upstream(CLK := #ix_PECUpstream);
	        #F_TRIG_PEC_A1(CLK := #ix_PECA1);
	        #R_TRIG_PEC_A1(CLK := #ix_PECA1);
	        #F_TRIG_PEC_A2(CLK := #ix_PECA2);
	        #R_TRIG_PEC_A2(CLK := #ix_PECA2);
	        #F_TRIG_PEC_B1(CLK := #ix_PECB1);
	        #R_TRIG_PEC_B1(CLK := #ix_PECB1);
	        #F_TRIG_PEC_B2(CLK := #ix_PECB2);
	        #R_TRIG_PEC_B2(CLK := #ix_PECB2);
	        #F_TRIG_PEC_C1(CLK := #ix_PECC1);
	        #R_TRIG_PEC_C1(CLK := #ix_PECC1);
	        #F_TRIG_PEC_C2(CLK := #ix_PECC2);
	        #R_TRIG_PEC_C2(CLK := #ix_PECC2);
	        #R_TRIG_PEC_Downstream(CLK := #ix_PECDownstream);
	        #F_TRIG_PEC_Downstream(CLK := #ix_PECDownstream);
	        #R_TRIG_DataStartConvA(CLK := (#iqa_TrackingDataUpstream[10] = 0)); // [#i_UDT_GOSConfiguration.Length_Conv_A /10]) = 0 );
	        #R_TRIG_DataStartConvB(CLK := (#iqa_TrackingDataA[10]) = 0);
	        #R_TRIG_DataStartConvC(CLK := (#iqa_TrackingDataB[10]) = 0);
	        
	        
	    END_REGION
	END_REGION
	
	REGION 2- Startup
	    
	    REGION 2.1 - Check parcels on the conveyors
	        //set or reset bit when parcel is on the conveyor or left the conveyor by checking the Tracking Array
	        
	        FOR #si_LoopCounter := 15 TO 95 BY 5 DO
	            
	            IF #iqa_TrackingDataA[#si_LoopCounter] > 0
	            THEN
	                #sx_ParcelsOnConveyor_A := TRUE;
	                EXIT;
	            ELSE
	                #sx_ParcelsOnConveyor_A := FALSE;
	            END_IF;
	        END_FOR;
	        
	        FOR #si_LoopCounter := 15 TO 95 BY 5 DO
	            
	            IF #iqa_TrackingDataB[#si_LoopCounter] > 0
	            THEN
	                #sx_ParcelsOnConveyor_B := TRUE;
	                EXIT;
	            ELSE
	                #sx_ParcelsOnConveyor_B := FALSE;
	            END_IF;
	        END_FOR;
	        
	        FOR #si_LoopCounter := 15 TO 95 BY 5 DO
	            
	            IF #iqa_TrackingDataC[#si_LoopCounter] > 0
	            THEN
	                #sx_ParcelsOnConveyor_C := TRUE;
	                EXIT;
	            ELSE
	                #sx_ParcelsOnConveyor_C := FALSE;
	            END_IF;
	        END_FOR;
	        
	        
	        FOR #si_LoopCounter := 95 TO 5 BY -1 DO
	            
	            IF #iqa_TrackingDataA[#si_LoopCounter] > 0
	            THEN
	                IF #s_ConveyorA_GIN1 = 0
	                THEN
	                    #s_ConveyorA_GIN1 := #iqa_TrackingDataA[#si_LoopCounter];
	                    #sx_twoParcelsOnConveyor_A := FALSE;
	                    #s_TailPositionParcelA := ((#iUDT_GOSConfiguration.LengthConvA / 10) - #si_LoopCounter);
	                END_IF;
	                IF #iqa_TrackingDataA[#si_LoopCounter] <> #s_ConveyorA_GIN1 AND #iqa_TrackingDataA[#si_LoopCounter] > 0
	                THEN
	                    #s_ConveyorA_GIN2 := #iqa_TrackingDataA[#si_LoopCounter];
	                    #sx_twoParcelsOnConveyor_A := TRUE;
	                END_IF;
	                //  EXIT;
	            ELSE
	                #sx_twoParcelsOnConveyor_A := FALSE;
	            END_IF;
	        END_FOR;
	        
	        #F_TRIG_TwoParcelsOnConvA(CLK := #sx_twoParcelsOnConveyor_A);
	        
	        // COnveyor B
	        FOR #si_LoopCounter := 95 TO 5 BY -1 DO
	            
	            IF #iqa_TrackingDataB[#si_LoopCounter] > 0
	            THEN
	                IF #s_ConveyorB_GIN1 = 0
	                THEN
	                    #s_ConveyorB_GIN1 := #iqa_TrackingDataB[#si_LoopCounter];
	                    #sx_twoParcelsOnConveyor_B := FALSE;
	                    #s_TailPositionParcelB := ((#iUDT_GOSConfiguration.LengthConvB / 10) - #si_LoopCounter);
	                END_IF;
	                IF #iqa_TrackingDataB[#si_LoopCounter] <> #s_ConveyorB_GIN1 AND #iqa_TrackingDataB[#si_LoopCounter] > 0
	                THEN
	                    #s_ConveyorB_GIN2 := #iqa_TrackingDataB[#si_LoopCounter];
	                    #sx_twoParcelsOnConveyor_B := TRUE;
	                END_IF;
	                //  EXIT;
	            ELSE
	                #sx_twoParcelsOnConveyor_B := FALSE;
	            END_IF;
	        END_FOR;
	        
	        #F_TRIG_TwoParcelsOnConvB(CLK := #sx_twoParcelsOnConveyor_B);
	        
	        // COnveyor C 
	        FOR #si_LoopCounter := 95 TO 5 BY -1 DO
	            
	            IF #iqa_TrackingDataC[#si_LoopCounter] > 0
	            THEN
	                IF #s_ConveyorC_GIN1 = 0
	                THEN
	                    #s_ConveyorC_GIN1 := #iqa_TrackingDataC[#si_LoopCounter];
	                    #sx_twoParcelsOnConveyor_C := FALSE;
	                    #s_TailPositionParcelC := ((#iUDT_GOSConfiguration.LengthConvC / 10) - #si_LoopCounter);
	                END_IF;
	                IF #iqa_TrackingDataC[#si_LoopCounter] <> #s_ConveyorC_GIN1 AND #iqa_TrackingDataC[#si_LoopCounter] > 0
	                THEN
	                    #s_ConveyorC_GIN2 := #iqa_TrackingDataC[#si_LoopCounter];
	                    #sx_twoParcelsOnConveyor_C := TRUE;
	                END_IF;
	                //  EXIT;
	            ELSE
	                #sx_twoParcelsOnConveyor_C := FALSE;
	            END_IF;
	        END_FOR;
	        
	        #F_TRIG_TwoParcelsOnConvC(CLK := #sx_twoParcelsOnConveyor_C);
	    END_REGION
	    
	    REGION 2.2 Take data from GIN record
	        IF #R_TRIG_DataStartConvA.Q // #R_TRIG_PEC_A1.Q
	        THEN
	            #sa_ParcelA1.GIN := (#iqa_TrackingDataUpstream[5]);
	            //  #ss_ParcelA1.GIN := #iqs_TrackingData_A[(#i_UDT_GOSConfiguration.Pos_PEC_A1 / 10) - 5];
	            #sa_ParcelA1.GapUpstream := 0;
	            #sa_ParcelA1.GapDownstream := 0;
	            IF #sa_ParcelA1.GIN > 0
	            THEN
	                #sa_ParcelA1.Length := ("DB_GIN".GIN[#sa_ParcelA1.GIN].General.Length * 10);
	                #sa_ParcelA1.GapUpstream := ("DB_GIN".GIN[#sa_ParcelA1.GIN].General.TrailingGap * 10);
	                #sa_ParcelA1.GapDownstream := ("DB_GIN".GIN[#sa_ParcelA1.GIN].General.LeadingGap * 10);
	                
	                IF "DB_GIN".GIN[#sa_ParcelA1.GIN].General.LeadingGap > 3200
	                THEN
	                    #sa_ParcelA1.GapDownstream := 10000;
	                END_IF;
	                
	                IF "DB_GIN".GIN[#sa_ParcelA1.GIN].General.TrailingGap > 3200
	                THEN
	                    #sa_ParcelA1.GapUpstream := 10000;
	                END_IF;
	                
	                #sa_ParcelA1.GapToBeRecovered := #sa_ParcelA1.GapDownstream - #iUDT_GOSConfiguration.RequiredGap;
	            END_IF;
	        END_IF;
	        
	        IF #R_TRIG_DataStartConvB.Q//#R_TRIG_PEC_B1.Q
	        THEN
	            #sa_ParcelB1.GIN := #iqa_TrackingDataA[7];
	            #sa_ParcelB1.GapUpstream := 0;
	            #sa_ParcelB1.GapDownstream := 0;
	            
	            IF #sa_ParcelB1.GIN > 0
	            THEN
	                #sa_ParcelB1.Length := ("DB_GIN".GIN[#sa_ParcelB1.GIN].General.Length * 10);
	                #sa_ParcelB1.GapUpstream := ("DB_GIN".GIN[#sa_ParcelB1.GIN].General.TrailingGap * 10);
	                #sa_ParcelB1.GapDownstream := ("DB_GIN".GIN[#sa_ParcelB1.GIN].General.LeadingGap * 10);
	                
	                IF "DB_GIN".GIN[#sa_ParcelB1.GIN].General.LeadingGap > 3200
	                THEN
	                    #sa_ParcelB1.GapDownstream := 10000;
	                END_IF;
	                
	                IF "DB_GIN".GIN[#sa_ParcelB1.GIN].General.TrailingGap > 3200
	                THEN
	                    #sa_ParcelB1.GapUpstream := 10000;
	                END_IF;
	                #sa_ParcelB1.GapToBeRecovered := #sa_ParcelB1.GapDownstream - #iUDT_GOSConfiguration.RequiredGap;
	            END_IF;
	        END_IF;
	        
	        IF #R_TRIG_DataStartConvC.Q///#R_TRIG_PEC_C1.Q
	        THEN
	            #sa_ParcelC1.GIN := #iqa_TrackingDataB[7];
	            #sa_ParcelC1.GapUpstream := 0;
	            #sa_ParcelC1.GapDownstream := 0;
	            
	            IF #sa_ParcelC1.GIN > 0
	            THEN
	                #sa_ParcelC1.Length := ("DB_GIN".GIN[#sa_ParcelC1.GIN].General.Length * 10);
	                #sa_ParcelC1.GapUpstream := ("DB_GIN".GIN[#sa_ParcelC1.GIN].General.TrailingGap * 10);
	                #sa_ParcelC1.GapDownstream := ("DB_GIN".GIN[#sa_ParcelC1.GIN].General.LeadingGap * 10);
	                
	                IF "DB_GIN".GIN[#sa_ParcelC1.GIN].General.LeadingGap > 3200
	                THEN
	                    #sa_ParcelC1.GapDownstream := 10000;
	                END_IF;
	                
	                IF "DB_GIN".GIN[#sa_ParcelC1.GIN].General.TrailingGap > 3200
	                THEN
	                    #sa_ParcelC1.GapUpstream := 10000;
	                END_IF;
	                #sa_ParcelC1.GapToBeRecovered := #sa_ParcelB1.GapDownstream - #iUDT_GOSConfiguration.RequiredGap;
	            END_IF;
	        END_IF;
	        
	        
	        
	        
	    END_REGION
	    
	    REGION 2.3 - Calculations
	        
	        REGION 2.3.1 Mode 100
	            
	            IF ((#R_TRIG_DataStartConvA.Q AND NOT #sx_twoParcelsOnConveyor_A)//#R_TRIG_PEC_A1.Q
	                OR (#F_TRIG_TwoParcelsOnConvA.Q AND #iqa_TrackingDataUpstream[10] = 0))
	                AND NOT #sx_ParcelsOnConveyor_B
	                AND NOT #sx_ParcelsOnConveyor_C
	                AND NOT #sx_ActionConv_A
	                AND NOT #sx_ActionConv_B
	                AND NOT #sx_ActionConv_C
	            THEN
	                IF #R_TRIG_DataStartConvA.Q THEN
	                    #sr_TravelDistanceUpstreamParc := INT_TO_REAL(#sa_ParcelA1.GapUpstream) - INT_TO_REAL(#iUDT_GOSConfiguration.LengthSpaceBetweenConv);
	                    #sr_TravelDistanceCurrentParcA := (INT_TO_REAL(#iUDT_GOSConfiguration.LengthConvA - #sa_ParcelA1.Length) + INT_TO_REAL(#iUDT_GOSConfiguration.LengthConvB) + INT_TO_REAL(#iUDT_GOSConfiguration.LengthConvC) - INT_TO_REAL(#iUDT_GOSConfiguration.PosPECC2));
	                    #sx_ActionConv_A := True;
	                    #sx_ActionConv_B := True;
	                    #sx_ActionConv_C := True;
	                END_IF;
	                IF #F_TRIG_TwoParcelsOnConvA.Q THEN
	                    #sr_TravelDistanceUpstreamParc := INT_TO_REAL(#sa_ParcelA1.GapUpstream) - INT_TO_REAL(#iUDT_GOSConfiguration.LengthSpaceBetweenConv) - #s_TailPositionParcelA;
	                    #sr_TravelDistanceCurrentParcA := (INT_TO_REAL(#iUDT_GOSConfiguration.LengthConvA - #sa_ParcelA1.Length - #s_TailPositionParcelA) + INT_TO_REAL(#iUDT_GOSConfiguration.LengthConvB) + INT_TO_REAL(#iUDT_GOSConfiguration.LengthConvC) - INT_TO_REAL(#iUDT_GOSConfiguration.PosPECC2));
	                    #sx_ActionConv_A := True;
	                    #sx_ActionConv_B := True;
	                    #sx_ActionConv_C := True;
	                END_IF;
	                "FC_GOSCalculation"(ir_TravelDistanceCurrentParc := #sr_TravelDistanceCurrentParcA,
	                                    ir_TravelDistanceUpstreamParc := #sr_TravelDistanceUpstreamParc,
	                                    ir_InitialSpeed := #ii_LoopSpeed,
	                                    ir_Acceleration := #iUDT_GOSConfiguration.Acceleration,
	                                    ir_MaxSpeed := #iUDT_GOSConfiguration.MaximumSpeed,
	                                    ir_MinSpeed := #iUDT_GOSConfiguration.MinimumSpeed,
	                                    ii_ParcelGapDownstream := #sa_ParcelA1.GapDownstream,
	                                    ii_ParcelGapUpstream := #sa_ParcelA1.GapUpstream,
	                                    ii_RequiredGap := #iUDT_GOSConfiguration.RequiredGap,
	                                    ii_MarginGap := #iUDT_GOSConfiguration.MarginLength,
	                                    ii_AllowedUpstreamGap := #iUDT_GOSConfiguration.AllowedUpstreamGap,
	                                    ix_ActionConv := #sx_ActionConv_A,
	                                    qx_Accelerate => #sa_ParcelA1.Accelerate,
	                                    qx_Decelerate => #sa_ParcelA1.Decelerate,
	                                    qi_Speed => #si_SpeedA,
	                                    qi_ParcelGapRecovered => #sa_ParcelA1.GapCovered,
	                                    qi_TimeToChangeSpeed => #Slr_TimeSpeedChangeConvA);
	                
	                #Slr_TimeSpeedChangeConvB := #Slr_TimeSpeedChangeConvA;
	                #Slr_TimeSpeedChangeConvC := #Slr_TimeSpeedChangeConvA;
	                #si_SpeedB := #si_SpeedA;
	                #si_SpeedC := #si_SpeedA;
	                #si_ParcelDownStreamResults := #si_ParcelGapRecovered_A;
	                
	            END_IF;
	        END_REGION
	        
	        REGION 2.3.2 Mode 110 or 111 TRIGGER A1
	            
	            IF ((#R_TRIG_DataStartConvA.Q AND NOT #sx_twoParcelsOnConveyor_A)  // #R_TRIG_PEC_A1.Q
	                OR (#F_TRIG_TwoParcelsOnConvA.Q AND #iqa_TrackingDataUpstream[10] = 0))
	                AND #sx_ParcelsOnConveyor_B
	                AND NOT #sx_ActionConv_A
	            THEN
	                IF #sa_ParcelA1.Length <= #iUDT_GOSConfiguration.AllowedParcelLength
	                THEN
	                    IF #R_TRIG_DataStartConvA.Q THEN
	                        #sr_TravelDistanceCurrentParcA := INT_TO_REAL(#iUDT_GOSConfiguration.LengthConvA - #iUDT_GOSConfiguration.PosPECA2 - #sa_ParcelA1.Length);
	                        #sr_TravelDistanceUpstreamParc := INT_TO_REAL(#sa_ParcelA1.GapUpstream) - INT_TO_REAL(#iUDT_GOSConfiguration.LengthSpaceBetweenConv);
	                        #sx_ActionConv_A := True;
	                    END_IF;
	                    IF #F_TRIG_TwoParcelsOnConvA.Q THEN
	                        #sr_TravelDistanceCurrentParcA := INT_TO_REAL(#iUDT_GOSConfiguration.LengthConvA - #iUDT_GOSConfiguration.PosPECA2 - #sa_ParcelA1.Length - #s_TailPositionParcelA);
	                        #sr_TravelDistanceUpstreamParc := INT_TO_REAL(#sa_ParcelA1.GapUpstream) - INT_TO_REAL(#iUDT_GOSConfiguration.LengthSpaceBetweenConv - #s_TailPositionParcelA);
	                        #sx_ActionConv_A := True;
	                    END_IF;
	                    "FC_GOSCalculation"(ir_TravelDistanceCurrentParc := #sr_TravelDistanceCurrentParcA,
	                                        ir_TravelDistanceUpstreamParc := #sr_TravelDistanceUpstreamParc,
	                                        ir_InitialSpeed := #ii_LoopSpeed,
	                                        ir_Acceleration := #iUDT_GOSConfiguration.Acceleration,
	                                        ir_MaxSpeed := #iUDT_GOSConfiguration.MaximumSpeed,
	                                        ir_MinSpeed := #iUDT_GOSConfiguration.MinimumSpeed,
	                                        ii_ParcelGapDownstream := #sa_ParcelA1.GapDownstream,
	                                        ii_ParcelGapUpstream := #sa_ParcelA1.GapUpstream,
	                                        ii_RequiredGap := #iUDT_GOSConfiguration.RequiredGap,
	                                        ii_MarginGap := #iUDT_GOSConfiguration.MarginLength,
	                                        ii_AllowedUpstreamGap := #iUDT_GOSConfiguration.AllowedUpstreamGap,
	                                        ix_ActionConv := #sx_ActionConv_A,
	                                        qx_Accelerate => #sa_ParcelA1.Accelerate,
	                                        qx_Decelerate => #sa_ParcelA1.Decelerate,
	                                        qi_Speed => #si_SpeedA,
	                                        qi_ParcelGapRecovered => #si_ParcelGapRecovered_A,
	                                        qi_TimeToChangeSpeed => #Slr_TimeSpeedChangeConvA);
	                    
	                    #si_ParcelDownStreamResults := #sa_ParcelA1.GapDownstream + #si_ParcelGapRecovered_A;
	                    
	                    IF #si_ParcelDownStreamResults > #iUDT_GOSConfiguration.RequiredGap
	                    THEN
	                        #si_ParcelDownStreamResults := #iUDT_GOSConfiguration.RequiredGap;
	                    ELSE
	                        #sx_WaitCurrentParcel_A_B := True;
	                    END_IF;
	                ELSE
	                    #sx_WaitCurrentParcel_A_B := True;
	                END_IF;
	            END_IF;
	            
	            IF #sx_WaitCurrentParcel_A_B
	            THEN
	                #si_DistanceTravelled_A_B += (#iUDT_ConvA.Displacement * 10);
	            END_IF;
	            
	            IF #R_TRIG_PEC_B2.Q
	                AND #sx_WaitCurrentParcel_A_B
	                AND NOT #sx_ActionConv_A
	                AND NOT #sx_ActionConv_B
	            THEN
	                #sr_TravelDistanceUpstreamParc := INT_TO_REAL((#sa_ParcelA1.GapUpstream - #si_DistanceTravelled_A_B)) - INT_TO_REAL(#iUDT_GOSConfiguration.LengthSpaceBetweenConv);
	                #sr_TravelDistanceCurrentParcA := (INT_TO_REAL(#iUDT_GOSConfiguration.LengthConvA) + INT_TO_REAL(#iUDT_GOSConfiguration.LengthConvB)) - (INT_TO_REAL(#iUDT_GOSConfiguration.PosPECB2) + INT_TO_REAL(#sa_ParcelA1.Length) + INT_TO_REAL(#si_DistanceTravelled_A_B));
	                #sx_WaitCurrentParcel_A_B := False;
	                #si_DistanceTravelled_A_B := 0;
	                #sx_ActionConv_A := True;
	                #sx_ActionConv_B := True;
	                "FC_GOSCalculation"(ir_TravelDistanceCurrentParc := #sr_TravelDistanceCurrentParcA,
	                                    ir_TravelDistanceUpstreamParc := #sr_TravelDistanceUpstreamParc,
	                                    ir_InitialSpeed := #ii_LoopSpeed,
	                                    ir_Acceleration := #iUDT_GOSConfiguration.Acceleration,
	                                    ir_MaxSpeed := #iUDT_GOSConfiguration.MaximumSpeed,
	                                    ir_MinSpeed := #iUDT_GOSConfiguration.MinimumSpeed,
	                                    ii_ParcelGapDownstream := #sa_ParcelA1.GapDownstream,
	                                    ii_ParcelGapUpstream := #sa_ParcelA1.GapUpstream,
	                                    ii_RequiredGap := #iUDT_GOSConfiguration.RequiredGap,
	                                    ii_MarginGap := #iUDT_GOSConfiguration.MarginLength,
	                                    ii_AllowedUpstreamGap := #iUDT_GOSConfiguration.AllowedUpstreamGap,
	                                    ix_ActionConv := #sx_ActionConv_A,
	                                    qx_Accelerate => #sa_ParcelA1.Accelerate,
	                                    qx_Decelerate => #sa_ParcelA1.Decelerate,
	                                    qi_Speed => #si_SpeedA,
	                                    qi_ParcelGapRecovered => #si_ParcelGapRecovered_A,
	                                    qi_TimeToChangeSpeed => #Slr_TimeSpeedChangeConvA);
	                #si_SpeedB := #si_SpeedA;
	                #Slr_TimeSpeedChangeConvB := #Slr_TimeSpeedChangeConvA;
	                #si_ParcelDownStreamResults := #si_ParcelGapRecovered_A;
	            END_IF;
	        END_REGION
	        
	        REGION 2.3.3 Mode 101 TRIGGER A1
	            
	            IF (#R_TRIG_DataStartConvA.Q AND NOT #sx_twoParcelsOnConveyor_A)
	                AND NOT #sx_ParcelsOnConveyor_B
	                AND #sx_ParcelsOnConveyor_C
	                AND NOT #sx_ActionConv_A
	                AND NOT #sx_ActionConv_B
	            THEN
	                #sr_TravelDistanceCurrentParcA := INT_TO_REAL(#iUDT_GOSConfiguration.LengthConvA) - INT_TO_REAL(#iUDT_GOSConfiguration.PosPECA2) - INT_TO_REAL(#sa_ParcelA1.Length) + INT_TO_REAL(#iUDT_GOSConfiguration.LengthConvB);
	                #sr_TravelDistanceUpstreamParc := INT_TO_REAL(#sa_ParcelA1.GapUpstream) - INT_TO_REAL(#iUDT_GOSConfiguration.LengthSpaceBetweenConv);
	                
	                #sx_ActionConv_A := True;
	                #sx_ActionConv_B := True;
	                "FC_GOSCalculation"(ir_TravelDistanceCurrentParc := #sr_TravelDistanceCurrentParcA,
	                                    ir_TravelDistanceUpstreamParc := #sr_TravelDistanceUpstreamParc,
	                                    ir_InitialSpeed := #ii_LoopSpeed,
	                                    ir_Acceleration := #iUDT_GOSConfiguration.Acceleration,
	                                    ir_MaxSpeed := #iUDT_GOSConfiguration.MaximumSpeed,
	                                    ir_MinSpeed := #iUDT_GOSConfiguration.MinimumSpeed,
	                                    ii_ParcelGapDownstream := #sa_ParcelA1.GapDownstream,
	                                    ii_ParcelGapUpstream := #sa_ParcelA1.GapUpstream,
	                                    ii_RequiredGap := #iUDT_GOSConfiguration.RequiredGap,
	                                    ii_MarginGap := #iUDT_GOSConfiguration.MarginLength,
	                                    ii_AllowedUpstreamGap := #iUDT_GOSConfiguration.AllowedUpstreamGap,
	                                    ix_ActionConv := #sx_ActionConv_A,
	                                    qx_Accelerate => #sa_ParcelA1.Accelerate,
	                                    qx_Decelerate => #sa_ParcelA1.Decelerate,
	                                    qi_Speed => #si_SpeedA,
	                                    qi_ParcelGapRecovered => #si_ParcelGapRecovered_A,
	                                    qi_TimeToChangeSpeed => #Slr_TimeSpeedChangeConvA);
	                
	                #si_SpeedB := #si_SpeedA;
	                #Slr_TimeSpeedChangeConvB := #Slr_TimeSpeedChangeConvA;
	                #si_ParcelDownStreamResults := #si_ParcelGapRecovered_A * 2;
	            END_IF;
	        END_REGION
	        
	        REGION 2.3.4 Mode 110 OR Mode 010 by TRIGGER B1
	            
	            IF ((#R_TRIG_DataStartConvB.Q AND NOT #sx_twoParcelsOnConveyor_B)
	                OR (#F_TRIG_TwoParcelsOnConvB.Q AND #iqa_TrackingDataA[10] = 0))
	                AND NOT #sx_ParcelsOnConveyor_C
	                AND NOT #sx_ActionConv_B
	            THEN
	                IF #R_TRIG_DataStartConvB.Q THEN
	                    #sr_TravelDistanceCurrentParcB := INT_TO_REAL(#iUDT_GOSConfiguration.LengthConvB - #sa_ParcelB1.Length + #iUDT_GOSConfiguration.LengthConvC - #iUDT_GOSConfiguration.PosPECC2);
	                    #sr_TravelDistanceUpstreamParcA := INT_TO_REAL(#sa_ParcelB1.GapUpstream) - INT_TO_REAL(#iUDT_GOSConfiguration.LengthSpaceBetweenConv);
	                    #sx_ActionConv_B := True;
	                    #sx_ActionConv_C := True;
	                END_IF;
	                IF #F_TRIG_TwoParcelsOnConvB.Q THEN
	                    #sr_TravelDistanceCurrentParcB := INT_TO_REAL(#iUDT_GOSConfiguration.LengthConvB - #sa_ParcelB1.Length - #s_TailPositionParcelB + #iUDT_GOSConfiguration.LengthConvC - #iUDT_GOSConfiguration.PosPECC2);
	                    #sr_TravelDistanceUpstreamParcA := INT_TO_REAL(#sa_ParcelB1.GapUpstream - #s_TailPositionParcelB) - INT_TO_REAL(#iUDT_GOSConfiguration.LengthSpaceBetweenConv);
	                    #sx_ActionConv_B := True;
	                    #sx_ActionConv_C := True;
	                END_IF;
	                "FC_GOSCalculation"(ir_TravelDistanceCurrentParc := #sr_TravelDistanceCurrentParcB,
	                                    ir_TravelDistanceUpstreamParc := #sr_TravelDistanceUpstreamParcA,
	                                    ir_InitialSpeed := #ii_LoopSpeed,
	                                    ir_Acceleration := #iUDT_GOSConfiguration.Acceleration,
	                                    ir_MaxSpeed := #iUDT_GOSConfiguration.MaximumSpeed,
	                                    ir_MinSpeed := #iUDT_GOSConfiguration.MinimumSpeed,
	                                    ii_ParcelGapDownstream := #sa_ParcelB1.GapDownstream,
	                                    ii_ParcelGapUpstream := #sa_ParcelB1.GapUpstream,
	                                    ii_RequiredGap := #iUDT_GOSConfiguration.RequiredGap,
	                                    ii_MarginGap := #iUDT_GOSConfiguration.MarginLength,
	                                    ii_AllowedUpstreamGap := #iUDT_GOSConfiguration.AllowedUpstreamGap,
	                                    ix_ActionConv := #sx_ActionConv_B,
	                                    qx_Accelerate => #sa_ParcelB1.Accelerate,
	                                    qx_Decelerate => #sa_ParcelB1.Decelerate,
	                                    qi_Speed => #si_SpeedB,
	                                    qi_ParcelGapRecovered => #si_ParcelGapRecovered_B,
	                                    qi_TimeToChangeSpeed => #Slr_TimeSpeedChangeConvB);
	                
	                #si_SpeedC := #si_SpeedB;
	                #Slr_TimeSpeedChangeConvC := #Slr_TimeSpeedChangeConvB;
	                
	            END_IF;
	        END_REGION
	        
	        REGION 2.3.5 Mode 011 by TRIGGER B1
	            
	            IF ((#R_TRIG_DataStartConvB.Q AND NOT #sx_twoParcelsOnConveyor_B)
	                OR (#F_TRIG_TwoParcelsOnConvB.Q AND #iqa_TrackingDataA[10] = 0))
	                AND #sx_ParcelsOnConveyor_C
	                AND NOT #sx_ActionConv_B
	            THEN
	                IF #sa_ParcelB1.Length <= #iUDT_GOSConfiguration.AllowedParcelLength
	                THEN
	                    IF NOT #sx_ParcelsOnConveyor_A AND #sa_ParcelB1.GapUpstream = 0 THEN
	                        #sr_TravelDistanceUpstreamParcA := INT_TO_REAL(#iUDT_GOSConfiguration.LengthConvB + #sa_ParcelB1.GapUpstream) - INT_TO_REAL(#iUDT_GOSConfiguration.LengthSpaceBetweenConv);
	                    ELSE
	                        #sr_TravelDistanceUpstreamParcA := INT_TO_REAL(#sa_ParcelB1.GapUpstream) - #s_TailPositionParcelB - INT_TO_REAL(#iUDT_GOSConfiguration.LengthSpaceBetweenConv);
	                    END_IF;
	                    #sr_TravelDistanceCurrentParcB := INT_TO_REAL(#iUDT_GOSConfiguration.LengthConvB) - INT_TO_REAL(#sa_ParcelB1.Length) - #s_TailPositionParcelB;
	                    #s_ConveyorA_GIN2 := 0;
	                    #s_TailPositionParcelB := 0;
	                    ;
	                    #sx_ActionConv_B := True;
	                    "FC_GOSCalculation"(ir_TravelDistanceCurrentParc := #sr_TravelDistanceCurrentParcB,
	                                        ir_TravelDistanceUpstreamParc := #sr_TravelDistanceUpstreamParcA,
	                                        ir_InitialSpeed := #ii_LoopSpeed,
	                                        ir_Acceleration := #iUDT_GOSConfiguration.Acceleration,
	                                        ir_MaxSpeed := #iUDT_GOSConfiguration.MaximumSpeed,
	                                        ir_MinSpeed := #iUDT_GOSConfiguration.MinimumSpeed,
	                                        ii_ParcelGapDownstream := #sa_ParcelB1.GapDownstream,
	                                        ii_ParcelGapUpstream := #sa_ParcelB1.GapUpstream,
	                                        ii_RequiredGap := #iUDT_GOSConfiguration.RequiredGap,
	                                        ii_MarginGap := #iUDT_GOSConfiguration.MarginLength,
	                                        ii_AllowedUpstreamGap := #iUDT_GOSConfiguration.AllowedUpstreamGap,
	                                        ix_ActionConv := #sx_ActionConv_B,
	                                        qx_Accelerate => #sa_ParcelB1.Accelerate,
	                                        qx_Decelerate => #sa_ParcelB1.Decelerate,
	                                        qi_Speed => #si_SpeedB,
	                                        qi_ParcelGapRecovered => #si_ParcelGapRecovered_B,
	                                        qi_TimeToChangeSpeed => #Slr_TimeSpeedChangeConvB);
	                    
	                    #si_ParcelDownStreamResults := #sa_ParcelB1.GapDownstream + #si_ParcelGapRecovered_B;
	                    
	                    IF #si_ParcelDownStreamResults > #iUDT_GOSConfiguration.RequiredGap
	                    THEN
	                        #si_ParcelDownStreamResults := #iUDT_GOSConfiguration.RequiredGap;
	                    ELSE
	                        #sx_WaitCurrentParcel_B_C := True;
	                    END_IF;
	                ELSE
	                    #sx_WaitCurrentParcel_B_C := TRUE;
	                END_IF;
	            END_IF;
	            
	            IF #sx_WaitCurrentParcel_B_C
	            THEN
	                #si_DistanceTravelled_B_C += (#iUDT_ConvB.Displacement * 10);
	            END_IF;
	        END_REGION
	        
	        REGION 2.3.6 Mode 001 by TRIGGER C1
	            
	            IF ((#R_TRIG_DataStartConvC.Q AND NOT #sx_twoParcelsOnConveyor_C)// #R_TRIG_PEC_C1.Q
	                OR (#F_TRIG_TwoParcelsOnConvC.Q AND #iqa_TrackingDataA[10] = 0))
	                AND NOT #sx_ActionConv_C
	                
	            THEN
	                IF NOT #sx_ParcelsOnConveyor_A AND NOT #sx_ParcelsOnConveyor_B AND #sa_ParcelC1.GapUpstream = 0 THEN
	                    #sr_TravelDistanceUpstreamParcB := INT_TO_REAL(#iUDT_GOSConfiguration.LengthConvA + #iUDT_GOSConfiguration.LengthConvB + #sa_ParcelC1.GapUpstream) - INT_TO_REAL(#iUDT_GOSConfiguration.LengthSpaceBetweenConv);
	                ELSIF NOT #sx_ParcelsOnConveyor_B AND #sa_ParcelC1.GapUpstream = 0 THEN
	                    #sr_TravelDistanceUpstreamParcB := INT_TO_REAL(#iUDT_GOSConfiguration.LengthConvB + #sa_ParcelC1.GapUpstream) - INT_TO_REAL(#iUDT_GOSConfiguration.LengthSpaceBetweenConv);
	                ELSE
	                    #sr_TravelDistanceUpstreamParcB := INT_TO_REAL(#sa_ParcelC1.GapUpstream) - #s_TailPositionParcelC - INT_TO_REAL(#iUDT_GOSConfiguration.LengthSpaceBetweenConv);
	                END_IF;
	                
	                #sr_TravelDistanceCurrentParcC := INT_TO_REAL(#iUDT_GOSConfiguration.LengthConvC - #iUDT_GOSConfiguration.PosPECC2 - #sa_ParcelC1.Length);
	                #sx_ActionConv_C := True;
	                "FC_GOSCalculation"(ir_TravelDistanceCurrentParc := #sr_TravelDistanceCurrentParcC,
	                                    ir_TravelDistanceUpstreamParc := #sr_TravelDistanceUpstreamParcB,
	                                    ir_InitialSpeed := #ii_LoopSpeed,
	                                    ir_Acceleration := #iUDT_GOSConfiguration.Acceleration,
	                                    ir_MaxSpeed := #iUDT_GOSConfiguration.MaximumSpeed,
	                                    ir_MinSpeed := #iUDT_GOSConfiguration.MinimumSpeed,
	                                    ii_ParcelGapDownstream := #sa_ParcelC1.GapDownstream,
	                                    ii_ParcelGapUpstream := #sa_ParcelC1.GapUpstream,
	                                    ii_RequiredGap := #iUDT_GOSConfiguration.RequiredGap,
	                                    ii_MarginGap := #iUDT_GOSConfiguration.MarginLength,
	                                    ii_AllowedUpstreamGap := #iUDT_GOSConfiguration.AllowedUpstreamGap,
	                                    ix_ActionConv := #sx_ActionConv_C,
	                                    qx_Accelerate => #sa_ParcelC1.Accelerate,
	                                    qx_Decelerate => #sa_ParcelC1.Decelerate,
	                                    qi_Speed => #si_SpeedC,
	                                    qi_ParcelGapRecovered => #si_ParcelGapRecovered_C,
	                                    qi_TimeToChangeSpeed => #Slr_TimeSpeedChangeConvC);
	                
	            END_IF;
	        END_REGION
	    END_REGION
	END_REGION
	
	REGION 3 - Write setpoint speed
	    //When new actual speed is equals to the new setpoint then write the initial speed as the new setpoint
	    
	    IF #Slr_TimeSpeedChangeConvA > 0.0 THEN
	        
	        #Slr_TimeSpeedChangeConvA := #Slr_TimeSpeedChangeConvA - "DB_Memory".PrevCycleTime;
	        #SetNominalSpeedA := true;
	    ELSE
	        #Slr_TimeSpeedChangeConvA := 0;
	        #SetNominalSpeedA := FALSE;
	    END_IF;
	    
	    IF #Slr_TimeSpeedChangeConvB > 0.0 THEN
	        
	        #Slr_TimeSpeedChangeConvB := #Slr_TimeSpeedChangeConvB - "DB_Memory".PrevCycleTime;
	        #SetNominalSpeedB := true;
	    ELSE
	        #Slr_TimeSpeedChangeConvB := 0;
	        #SetNominalSpeedB := FALSE;
	    END_IF;
	    
	    IF #Slr_TimeSpeedChangeConvC > 0.0 THEN
	        
	        #Slr_TimeSpeedChangeConvC := #Slr_TimeSpeedChangeConvC - "DB_Memory".PrevCycleTime;
	        #SetNominalSpeedC := true;
	    ELSE
	        #Slr_TimeSpeedChangeConvC := 0;
	        #SetNominalSpeedC := FALSE;
	    END_IF;
	    
	    
	    IF (#sx_ActionConv_A AND #SetNominalSpeedA AND #si_SpeedA > #ii_LoopSpeed)
	        
	    THEN
	        #si_SpeedA := #iUDT_GOSConfiguration.MaximumSpeed;
	    ELSIF (#sx_ActionConv_A AND #SetNominalSpeedA AND #si_SpeedA < #ii_LoopSpeed)
	    THEN
	        #si_SpeedA := #iUDT_GOSConfiguration.MinimumSpeed;
	    END_IF;
	    
	    IF (#sx_ActionConv_A AND #Slr_TimeSpeedChangeConvA <= 0)
	    THEN
	        #si_SpeedA := #ii_LoopSpeed;
	        #sx_ActionConv_A := FALSE;
	        #SetNominalSpeedA := FALSE;
	    END_IF;
	    
	    IF (#sx_ActionConv_B AND #SetNominalSpeedB AND #si_SpeedB > #ii_LoopSpeed)
	    THEN
	        #si_SpeedB := #iUDT_GOSConfiguration.MaximumSpeed;
	    ELSIF (#sx_ActionConv_B AND #SetNominalSpeedB AND #si_SpeedB < #ii_LoopSpeed)
	    THEN
	        #si_SpeedB := #iUDT_GOSConfiguration.MinimumSpeed;
	    END_IF;
	    
	    IF (#sx_ActionConv_B AND #Slr_TimeSpeedChangeConvB <= 0)
	    THEN
	        #si_SpeedB := #ii_LoopSpeed;
	        #sx_ActionConv_B := FALSE;
	        #SetNominalSpeedB := FALSE;
	    END_IF;
	    
	    IF (#sx_ActionConv_C AND #SetNominalSpeedC AND #si_SpeedC > #ii_LoopSpeed)
	    THEN
	        #si_SpeedC := #iUDT_GOSConfiguration.MaximumSpeed;
	    ELSIF (#sx_ActionConv_C AND #SetNominalSpeedC AND #si_SpeedC < #ii_LoopSpeed)
	    THEN
	        #si_SpeedC := #iUDT_GOSConfiguration.MinimumSpeed;
	    END_IF;
	    
	    IF (#sx_ActionConv_C AND #Slr_TimeSpeedChangeConvC <= 0)
	    THEN
	        #si_SpeedC := #ii_LoopSpeed;
	        #sx_ActionConv_C := FALSE;
	        #SetNominalSpeedC := FALSE;
	    END_IF;
	    
	    //Write new setpoint speed in the UDT_GOSInterface
	    #iqUDT_GOSInterface.SpeedConvA := #si_SpeedA;
	    #iqUDT_GOSInterface.SpeedConvB := #si_SpeedB;
	    #iqUDT_GOSInterface.SpeedConvC := #si_SpeedC;
	    
	END_REGION
	
	REGION 4 Logging
	    
	    //Get size of FIFO array (without the zero)
	    #si_MaxNumberofEntries := ("FC_GetNrOfArrayEl"(#iqUDT_GOSLog) - 1);
	    
	    //Write DB_GOSLog with the parcel values
	    IF (#R_TRIG_PEC_A1.Q AND NOT #sx_twoParcelsOnConveyor_A)
	        OR #F_TRIG_TwoParcelsOnConvA.Q
	        AND #sa_ParcelA1.GIN > 0
	    THEN
	        
	        FOR #si_LoopCounter := 1 TO #si_MaxNumberofEntries DO
	            IF "DB_GOSLog".DB_GOSLog[#si_LoopCounter].GIN_nr = #sa_ParcelA1.GIN THEN
	                
	                "DB_GOSLog".DB_GOSLog[#si_LoopCounter].GIN_nr := #sa_ParcelA1.GIN;
	                "DB_GOSLog".DB_GOSLog[#si_LoopCounter].ParcelLength := #sa_ParcelA1.Length;
	                "DB_GOSLog".DB_GOSLog[#si_LoopCounter].InfeedUpstreamGap := #sa_ParcelA1.GapUpstream;
	                "DB_GOSLog".DB_GOSLog[#si_LoopCounter].InfeedDownstreamGap := #sa_ParcelA1.GapDownstream;
	                "DB_GOSLog".DB_GOSLog[#si_LoopCounter].Accelerate := #sa_ParcelA1.Accelerate;
	                "DB_GOSLog".DB_GOSLog[#si_LoopCounter].Decelerate := #sa_ParcelA1.Decelerate;
	                "DB_GOSLog".DB_GOSLog[#si_LoopCounter].GapToBeRecovered := #sa_ParcelA1.GapToBeRecovered;
	                
	                EXIT;
	            END_IF;
	        END_FOR;
	    END_IF;
	    
	    
	    IF #R_TRIG_PEC_C2.Q
	    THEN
	        #sa_ParcelC2.GIN := #iqa_TrackingDataC[(#iUDT_GOSConfiguration.PosPECC2 / 10) - 5];
	        IF #sa_ParcelC2.GIN > 0
	        THEN
	            FOR #si_LoopCounter := 1 TO #si_MaxNumberofEntries DO
	                IF "DB_GOSLog".DB_GOSLog[#si_LoopCounter].GIN_nr = #sa_ParcelC2.GIN THEN
	                    "DB_GOSLog".DB_GOSLog[#si_LoopCounter].OutfeedDownstreamGap := "DB_GIN".GIN[#sa_ParcelC2.GIN].General.LeadingGap * 10;
	                    "DB_GOSLog".DB_GOSLog[#si_LoopCounter].OutfeedUpstreamGap := "DB_GIN".GIN[#sa_ParcelC2.GIN].General.TrailingGap * 10;
	                    "DB_GOSLog".DB_GOSLog[#si_LoopCounter].ParcelDownStreamResults := #si_ParcelDownStreamResults; // this should be here
	                    EXIT;
	                END_IF;
	            END_FOR;
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Update/shift FIFO
	    
	    
	    // Handle shift request merge (FIFO entry is handled induct code is generated in tracking DB)
	    IF #iqx_ShiftRequest
	    THEN
	        #si_ReturnValue := MOVE_BLK_VARIANT(SRC := #iqUDT_GOSLog,
	                                            COUNT := INT_TO_UDINT(#si_MaxNumberofEntries - 2),
	                                            SRC_INDEX := 0,
	                                            DEST_INDEX := 1,
	                                            DEST => #iqUDT_GOSLog);
	        //Reset values of 0 entry(used oly for shifting)
	        "DB_GOSLog".DB_GOSLog[0].GIN_nr := 0;
	        "DB_GOSLog".DB_GOSLog[0].ParcelLength := 0;
	        "DB_GOSLog".DB_GOSLog[0].InfeedUpstreamGap := 0;
	        "DB_GOSLog".DB_GOSLog[0].InfeedDownstreamGap := 0;
	        "DB_GOSLog".DB_GOSLog[0].Accelerate := 0;
	        "DB_GOSLog".DB_GOSLog[0].Decelerate := 0;
	        "DB_GOSLog".DB_GOSLog[0].GapToBeRecovered := 0;
	        "DB_GOSLog".DB_GOSLog[0].ParcelDownStreamResults := 0;
	        "DB_GOSLog".DB_GOSLog[0].OutfeedDownstreamGap := 0;
	        "DB_GOSLog".DB_GOSLog[0].OutfeedUpstreamGap := 0;
	        "DB_GOSLog".DB_GOSLog[0].ParcelUpStreamResults := 0;
	        "DB_GOSLog".DB_GOSLog[0].PrevConveyorDownstreamGap := 0;
	        "DB_GOSLog".DB_GOSLog[0].PrevConveyorUpstreamGap := 0;
	        "DB_GOSLog".DB_GOSLog[0].NextConveyorDownstreamGap := 0;
	        "DB_GOSLog".DB_GOSLog[0].NextConveyorUpstreamGap := 0;
	        // reset shift request
	        #iqx_ShiftRequest := False;
	        
	    END_IF;
	END_REGION
	
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_AMBASpiralVeyor"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 255
// END_ATTRIBUTES
   VAR_INPUT 
      ix_HardwareOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when hardware is ok
      iudi_DelayHardwareOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // [ms] Delay time for hardware ok signal
      ix_ProxSwitchDriveShaft { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Proximity switch signal drive shaft detection
      ix_ProxSwitchIdlerShaft { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Proximity switch signal idler shaft detection
      ix_ProxSwitchSlat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Proximity switch signal slat detection
   END_VAR

   VAR_IN_OUT 
      iqUDT_Statistics : "UDT_SpiralVeyorStatistics";
      iqUDT_Status : "UDT_SpiralVeyorStatus";
      iqUDT_EquipmentControl : "UDT_EquipmentControl";
      iqUDT_CommonStatus : "UDT_CommonStatus";
   END_VAR

   VAR 
      sFB_HardwareOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer on/off delay for hardware ok signal
      sFB_SlatCheck { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_AMBASpiralSlatCheck";
      sFB_ChainCheck { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_AMBASpiralChainCheck";
   END_VAR


BEGIN
	(*                                                                                      
	Version history:
	Date        | Version   | Author              | Remark
	----------------------------------------------------------------------------------------
	 14/03/2022 | 1.0       | G.Vlooswijk         | Initial version for FedEx Milano
	 11/05/2022 | 2.0       | G.Vlooswijk         | Splitted inner and outerlane status
	 22/09/2022 | 2.1       | G.Vlooswijk         | Removed HMIStatus
	 03/06/2024 | 2.2       | J.Majer             | Adapted to current library 
	*)
	
	REGION Input preparation
	    
	    // Hardware ok timer 
	    #sFB_HardwareOK(iudi_OnDelayTime := #iudi_DelayHardwareOK,
	                    ix_SignalToDelay := #ix_HardwareOK);
	    
	END_REGION
	
	REGION Missing slat dection
	    
	    #sFB_SlatCheck(ix_SlatDetection := #ix_ProxSwitchSlat,
	                   ix_HardwareOk := #sFB_HardwareOK.qx_DelayedSignal,
	                   iqx_MissingSlatDetected := #iqUDT_Status.MissingSlat,
	                   iqUDT_Statistics := #iqUDT_Statistics.MissingSlat,
	                   iqUDT_EquipmentControl := #iqUDT_EquipmentControl);
	    
	END_REGION
	
	REGION Chain check
	    
	    #sFB_ChainCheck(ix_ProxSwitchDriveShaft := #ix_ProxSwitchDriveShaft,
	                    ix_ProxSwitchIdlerShaft := #ix_ProxSwitchIdlerShaft,
	                    ix_HardwareOK := #sFB_HardwareOK.qx_DelayedSignal,
	                    iqx_BrokenChainDetected := #iqUDT_Status.BrokenChain,
	                    iqx_ChainOverlengthDetected := #iqUDT_Status.ChainOverlength,
	                    iqUDT_BrokenChainStatistics := #iqUDT_Statistics.BrokenChain,
	                    iqUDT_ChainOverlengthStatistics := #iqUDT_Statistics.ChainOverlength,
	                    iqUDT_EquipmentControl := #iqUDT_EquipmentControl);
	    
	END_REGION
	
	REGION Update common status
	    
	    //Set/reset warning state on spiralveyor warnings
	    IF #iqUDT_Status.ChainOverlength AND NOT #iqUDT_CommonStatus.Warning THEN
	        #iqUDT_CommonStatus.Warning := TRUE;
	    ELSIF NOT #iqUDT_Status.ChainOverlength AND #iqUDT_CommonStatus.Warning THEN
	        #iqUDT_CommonStatus.Warning := FALSE;
	    END_IF;
	    
	    //Set/reset error status on spiralveyor faults
	    IF (#iqUDT_Status.BrokenChain OR #iqUDT_Status.MissingSlat) AND NOT #iqUDT_CommonStatus.Error THEN
	        #iqUDT_CommonStatus.Error := TRUE;
	    ELSIF NOT #iqUDT_Status.BrokenChain AND NOT #iqUDT_Status.MissingSlat AND #iqUDT_CommonStatus.Error THEN
	        #iqUDT_CommonStatus.Error := FALSE;
	    END_IF;
	    
	END_REGION
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_ControlPowerGroup"
TITLE = Control Power Group
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : CesarLeite
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 4
// END_ATTRIBUTES
//This block is used to monitoring the 24V power supplies.
   VAR_INPUT 
      ix_PowerSupplyOk_1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE if power supply 1 is OK
      ix_PowerSupply_Infeed_1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  400V power supply 1 infeed
      ix_PowerSupplyOk_2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE if power supply 2 is OK
      ix_PowerSupply_Infeed_2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  400V power supply 2 infeed
      ix_PowerSupplyOk_3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE if power supply 3 is OK
      ix_PowerSupply_Infeed_3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  400V power supply 3 infeed
      ix_PowerSupplyOk_4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE if power supply 4 is OK
      ix_PowerSupply_Infeed_4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  400V power supply 4 infeed
      ix_PowerSupplyOk_5 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE if power supply 5 is OK
      ix_PowerSupply_Infeed_5 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  400V power supply 5 infeed
      ix_PowerSupplyOk_6 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE if power supply 6 is OK
      ix_PowerSupply_Infeed_6 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  400V power supply 6 infeed
      ix_PowerSupplyOk_7 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE if power supply 7 is OK
      ix_PowerSupply_Infeed_7 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  400V power supply 7 infeed
      ix_PowerSupplyOk_8 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE if power supply 8 is OK
      ix_PowerSupply_Infeed_8 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  400V power supply 8 infeed
      ix_PowerSupplyOk_9 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE if power supply 9 is OK
      ix_PowerSupply_Infeed_9 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  400V power supply 9 infeed
      ix_PowerSupplyOk_10 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE if power supply 10 is OK
      ix_PowerSupply_Infeed_10 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  400V power supply 10 infeed
      ix_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when hardware is Ok
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ControlPowerGroupStatus";   //  HMI status structure
      qUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   //  Common status structure
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   //  CIP Equipment control
      iqUDT_Statistics : "UDT_ControlPowerGroupStatistics";   //  CPG Statistics structure
   END_VAR

   VAR 
      sUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ControlPowerGroupStatus";   //  HMI status structure
      sUDT_CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //  Common status structure
      sUDT_CommonStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //  Auxiliary status structure
      R_Trig_Warning {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge for warning
      R_Trig_Error {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge for error
      sw_NumberOfFailsAux { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   //  Auxilary number of fails
      si_NumberOfFails { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Number of fails
      sx_WarningAux { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Auxilary warninig
      sx_ErrorAux { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Auxilary error
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	03/10/2019  | 2.0       | C.Leite       | first release TIA 15.1
	15/10/2019  | 2.1       | L.Klar        | Updated status structure
	15/10/2019  | 2.2       | C. Leite      | UDTs and comments update 
	17/10/2019  | 2.3       | S. Deulkar    | Added comments to interface signals
	04/11/2019  | 2.4       | C. Leite      | Power supplu 400V infeed state added
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	04/12/2019  | 3.1       | C.Leite       | Remove number of power supplies input from interface
	25/02/2020  | 3.2       | S. Deulkar    | Modified to update ststus output every cycle
	09/07/2020  | 3.3       | S.Theocharis  | Bug fix in status update. Initialize static status instead output status
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Power Supply monitoring
	    
	    
	    #sw_NumberOfFailsAux.%X0 := NOT #ix_PowerSupplyOk_1;            //  Power supply 1 state
	    #sw_NumberOfFailsAux.%X1 := NOT #ix_PowerSupplyOk_2;            //  Power supply 2 state
	    #sw_NumberOfFailsAux.%X2 := NOT #ix_PowerSupplyOk_3;            //  Power supply 3 state
	    #sw_NumberOfFailsAux.%X3 := NOT #ix_PowerSupplyOk_4;            //  Power supply 4 state
	    #sw_NumberOfFailsAux.%X4 := NOT #ix_PowerSupplyOk_5;            //  Power supply 5 state
	    #sw_NumberOfFailsAux.%X5 := NOT #ix_PowerSupplyOk_6;            //  Power supply 6 state
	    #sw_NumberOfFailsAux.%X6 := NOT #ix_PowerSupplyOk_7;            //  Power supply 7 state
	    #sw_NumberOfFailsAux.%X7 := NOT #ix_PowerSupplyOk_8;            //  Power supply 8 state
	    #sw_NumberOfFailsAux.%X8 := NOT #ix_PowerSupplyOk_9;            //  Power supply 9 state
	    #sw_NumberOfFailsAux.%X9 := NOT #ix_PowerSupplyOk_10;           //  Power supply 10 state
	    
	    #si_NumberOfFails := BITSUM(#sw_NumberOfFailsAux);
	    
	END_REGION
	
	REGION 2 - Reset
	    
	    IF #iqUDT_EquipmentControl.Command.Reset
	    THEN
	        
	        #sUDT_HMIStatus.Specific.Fail_PowerSupply_1 := FALSE;      //  Power supply fault state
	        #sUDT_HMIStatus.Specific.Fail_PowerSupply_2 := FALSE;      //  Power supply fault state
	        #sUDT_HMIStatus.Specific.Fail_PowerSupply_3 := FALSE;      //  Power supply fault state
	        #sUDT_HMIStatus.Specific.Fail_PowerSupply_4 := FALSE;      //  Power supply fault state
	        #sUDT_HMIStatus.Specific.Fail_PowerSupply_5 := FALSE;      //  Power supply fault state
	        #sUDT_HMIStatus.Specific.Fail_PowerSupply_6 := FALSE;      //  Power supply fault state
	        #sUDT_HMIStatus.Specific.Fail_PowerSupply_7 := FALSE;      //  Power supply fault state
	        #sUDT_HMIStatus.Specific.Fail_PowerSupply_8 := FALSE;      //  Power supply fault state
	        #sUDT_HMIStatus.Specific.Fail_PowerSupply_9 := FALSE;      //  Power supply fault state
	        #sUDT_HMIStatus.Specific.Fail_PowerSupply_10 := FALSE;     //  Power supply fault state
	        
	        #sUDT_HMIStatus.Specific.PowerSuppliesError := FALSE;
	        #sUDT_HMIStatus.Specific.PowerSuppliesWarning := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Status
	    
	    // Set warning if there is an error with one power supply
	    IF #si_NumberOfFails = 1
	    THEN
	        
	        #sUDT_HMIStatus.Specific.PowerSuppliesWarning := TRUE;
	        
	    END_IF;
	    
	    #sx_WarningAux := (#si_NumberOfFails = 1);
	    
	    #R_Trig_Warning(CLK := #sx_WarningAux);
	    
	    //  Set error if there are more than one power supply with error
	    IF #si_NumberOfFails > 1
	    THEN
	        
	        #sUDT_HMIStatus.Specific.PowerSuppliesError := TRUE;
	        
	    END_IF;
	    
	    #sx_ErrorAux := (#si_NumberOfFails > 1);
	    
	    #R_Trig_Error(CLK := #sx_ErrorAux);
	    
	    // Set error state if there is an error with the power supply 1
	    IF NOT #ix_PowerSupplyOk_1
	    THEN
	        
	        #sUDT_HMIStatus.Specific.Fail_PowerSupply_1 := TRUE;
	        
	    END_IF;
	    
	    // Set error state if there is an error with the power supply 2
	    IF NOT #ix_PowerSupplyOk_2
	    THEN
	        
	        #sUDT_HMIStatus.Specific.Fail_PowerSupply_2 := TRUE;
	        
	    END_IF;
	    
	    // Set error state if there is an error with the power supply 3
	    IF NOT #ix_PowerSupplyOk_3
	    THEN
	        
	        #sUDT_HMIStatus.Specific.Fail_PowerSupply_3 := TRUE;
	        
	    END_IF;
	    
	    // Set error state if there is an error with the power supply 4
	    IF NOT #ix_PowerSupplyOk_4
	    THEN
	        
	        #sUDT_HMIStatus.Specific.Fail_PowerSupply_4 := TRUE;
	        
	    END_IF;
	    
	    // Set error state if there is an error with the power supply 5
	    IF NOT #ix_PowerSupplyOk_5
	    THEN
	        
	        #sUDT_HMIStatus.Specific.Fail_PowerSupply_5 := TRUE;
	        
	    END_IF;
	    
	    // Set error state if there is an error with the power supply 6
	    IF NOT #ix_PowerSupplyOk_6
	    THEN
	        
	        #sUDT_HMIStatus.Specific.Fail_PowerSupply_6 := TRUE;
	        
	    END_IF;
	    
	    // Set error state if there is an error with the power supply 7
	    IF NOT #ix_PowerSupplyOk_7
	    THEN
	        
	        #sUDT_HMIStatus.Specific.Fail_PowerSupply_7 := TRUE;
	        
	    END_IF;
	    
	    // Set error state if there is an error with the power supply 8
	    IF NOT #ix_PowerSupplyOk_8
	    THEN
	        
	        #sUDT_HMIStatus.Specific.Fail_PowerSupply_8 := TRUE;
	        
	    END_IF;
	    
	    // Set error state if there is an error with the power supply 9
	    IF NOT #ix_PowerSupplyOk_9
	    THEN
	        
	        #sUDT_HMIStatus.Specific.Fail_PowerSupply_9 := TRUE;
	        
	    END_IF;
	    
	    // Set error state if there is an error with the power supply 10
	    IF NOT #ix_PowerSupplyOk_10
	    THEN
	        
	        #sUDT_HMIStatus.Specific.Fail_PowerSupply_10 := TRUE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Statistics
	    
	    //  Warning statistics
	    
	    IF #sx_WarningAux
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.PowerSuppliesWarning,
	                        ix_RTrigActivate := #R_Trig_Warning.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.PowerSupplyGroupWarnning);
	        
	    END_IF;
	    
	    //  Error statistics
	    
	    IF #sx_ErrorAux
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.PowerSuppliesError,
	                        ix_RTrigActivate := #R_Trig_Error.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.PowerSupplyGroupError);
	        
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Status Update
	    
	    #sUDT_CommonStatus.Error := #sUDT_HMIStatus.Specific.PowerSuppliesError;
	    #sUDT_CommonStatus.Warning := #sUDT_HMIStatus.Specific.PowerSuppliesWarning;
	    
	    // HMI status update
	    IF #sUDT_CommonStatusOld <> #sUDT_CommonStatus                    // update on change
	    THEN
	        
	        // HMI status initialization
	        #sUDT_HMIStatus.Status := 0;
	        
	        IF #sUDT_CommonStatus.Error                                    // Error
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Error;
	            
	        END_IF;
	        
	        IF #sUDT_CommonStatus.Warning                                  // Warning
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Warning;
	            
	        END_IF;
	        
	        
	        #qUDT_Status := #sUDT_CommonStatus;                           // Copy status to output
	        #sUDT_CommonStatusOld := #sUDT_CommonStatus;                  // Copy status to memory
	        
	    END_IF;
	    #qUDT_HMIStatus := #sUDT_HMIStatus;                           // Copy HMI status to output
	    
	    
	END_REGION
	
	REGION 6 - Report to control block
	    
	    // Function to manage report between control block and equipment block 
	    
	    "FC_EquipmentReport"(iUDT_Status := #sUDT_CommonStatus,
	                         iqUDT_Control := #iqUDT_EquipmentControl);
	    
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_InductGINControl"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 15
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_InductConfig { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_InductConfiguration";   // Induct configuration parameters
      ii_GINAtLastPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // GIN number at the last position in the FIFO
      ii_ConfirmationGIN2to1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Confirmation GIN number on position 1. Is to be used to confirm the GIN number after shifting data from position 2 to position 1.
      ii_ConfirmationGIN3to2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Confirmation GIN number on position 2. Is to be used to confirm the GIN number after shifting data from position 3 to position 2.
      ii_ConfirmationGIN4to3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Confirmation GIN number on position 3. Is to be used to confirm the GIN number after shifting data from position 4 to position 3.
      ii_ConfirmationGIN5to4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Confirmation GIN number on position 4. Is to be used to confirm the GIN number after shifting data from position 5 to position 4.
      ii_ConfirmationGIN6to5 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Confirmation GIN number on position 5. Is to be used to confirm the GIN number after shifting data from position 6 to position 5.
      ii_FirstShiftCheckPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // First position from which shifting request is required
      ii_InductDisplacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Displacement from the Induct belt, per PLC scan [cm]
      ix_TIP_Induct { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Transfer in progress from Induct conveyor
      ix_ConfirmationRequired1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request for data confirmation on position 1
      ix_ConfirmationRequired2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request for data confirmation on position 2
      ix_ConfirmationRequired3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request for data confirmation on position 3
      ix_ConfirmationRequired4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request for data confirmation on position 4
      ix_ConfirmationRequired5 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request for data confirmation on position 5
      ix_ShiftDataReq2to1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request for data shifting from position 2 to position 1
      ix_ShiftDataReq3to2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request for data shifting from position 3 to position 2
      ix_ShiftDataReq4to3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request for data shifting from position 4 to position 3
      ix_ShiftDataReq5to4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request for data shifting from position 5 to position 4
      ix_ShiftDataReq6to5 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request for data shifting from position 6 to position 5
      ix_EnergySaveActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Energy safe is active
      ix_ExternalError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External error occure
   END_VAR

   VAR_IN_OUT 
      iqUDT_Induct : "UDT_Induct";   // Induct FIFO structure
      iqUDT_MergeInterface : "UDT_ConveyorInterface";   // Interface structure of merge conveyor
      iqUDT_MergeTracking : Array[*] of Int;   // Tracking array of the merge belt
      iqUDT_HandShake : "UDT_ConveyorHandshake";   // Induct conveyor handshake structure
      iqUDT_UnknownGINRange : "UDT_UnknownGIN";   // Unknown GIN range
      iqUDT_InductStatus : "UDT_CommonStatus";   // Induct Status
   END_VAR

   VAR 
      sa_ShiftData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..#ci_Positions] of Struct   // Data shifting structure
         Request { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request to shift the data
         Done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Shifting is done
         OldGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Old GIN number
      END_STRUCT;
      sa_ConfirmData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..#ci_Positions] of Struct   // Data confirmation structure
         Request { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Confirmation request
         Done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Confirmation is done
         OldGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Old GIN number
      END_STRUCT;
      sa_Diagnostic { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Diagnostic structure, only for commissioning purposes
         MissingWindow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         WrongLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         TrackingLost { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      END_STRUCT;
      sUDT_EmptyParcelData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_InductParcelData";   // Empty parcel data
      sR_Trig_ShiftDataReq2to1 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger for data shifting request from position 2 to position 1
      sR_Trig_ShiftDataReq3to2 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger for data shifting request from position 3 to position 2
      sR_Trig_ShiftDataReq4to3 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger for data shifting request from position 4 to position 3
      sR_Trig_ShiftDataReq5to4 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger for data shifting request from position 5 to position 4
      sR_Trig_ShiftDataReq6to5 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger for data shifting request from position 6 to position 5
      sR_Trig_TIP {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger transfer in progress signal
      si_GinOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Old GIN number
      si_ClearDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Distance to check if the conveyor moved after TIP is active
      si_NrOfPositions { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Number of positions
      si_ExceptionPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Position from which is exception handling functionality started
      sx_CheclClearDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Auxiliary variable to check if the conveyor moved after TIP is active
   END_VAR

   VAR_TEMP 
      ti_LoopCounter1 : Int;   // Loop counter
      ti_LoopCounter2 : Int;   // Loop counter
   END_VAR

   VAR CONSTANT 
      ci_Positions : Int := 20;   // Number of positions
      ci_RequestLengthCheckPosition : Int := 100;   // Distance from induct position when the requested length is checked [cm]
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	23/03/2022  | 1.0       | H. Rutkowski  | First release TIA 16
	19/04/2022  | 1.1       | M. Piela      | Rebuild data shifting, add exception handling
	10/06/2022  | 1.2       | M. Piela      | When shifting data checking if the position is empty or the confirmation is not required
	22/07/2022  | 1.3       | M. Piela      | Change the condition to recover when the parcel is at the induct position but has no GIN number
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Intialize and Trigger
	    
	    #sR_Trig_ShiftDataReq2to1(CLK := #ix_ShiftDataReq2to1);
	    #sR_Trig_ShiftDataReq3to2(CLK := #ix_ShiftDataReq3to2);
	    #sR_Trig_ShiftDataReq4to3(CLK := #ix_ShiftDataReq4to3);
	    #sR_Trig_ShiftDataReq5to4(CLK := #ix_ShiftDataReq5to4);
	    #sR_Trig_ShiftDataReq6to5(CLK := #ix_ShiftDataReq6to5);
	    #sR_Trig_TIP(CLK := #ix_TIP_Induct);
	    
	END_REGION
	
	REGION 2 - Queue
	    
	    REGION 2.1 - Position 1
	        
	        //Clear the data on position 1 when TIP is on and the conveyor belt had moved
	        IF #sR_Trig_TIP.Q
	            AND NOT #sx_CheclClearDistance
	        THEN
	            #sx_CheclClearDistance := TRUE;
	            #si_ClearDistance := 0;
	        END_IF;
	        
	        IF #sx_CheclClearDistance
	        THEN
	            #si_ClearDistance += #ii_InductDisplacement;
	        END_IF;
	        
	        //Check if the conveyor belt moved after TIP occur
	        IF #si_ClearDistance > 5
	        THEN
	            #iqUDT_Induct.Position[1] := #sUDT_EmptyParcelData;
	            #sx_CheclClearDistance := FALSE;
	            #si_ClearDistance := 0;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 2.2 - Position 2 to 1
	        
	        //Shift Data        
	        IF #sR_Trig_ShiftDataReq2to1.Q // External request for shifting data
	        THEN
	            #sa_ShiftData[2].Request := TRUE; // Request data shifting
	            #sa_ShiftData[2].Done := FALSE;   // Set shift data done to false
	        END_IF;
	        
	        IF (#sa_ShiftData[2].Request
	            OR #ii_FirstShiftCheckPosition < 1)     // Check if the check position is less than the position from which shifting request is required
	            AND (#iqUDT_Induct.Position[2].GINNumber > 0 AND #iqUDT_Induct.Position[1].GINNumber = 0)  //Check if the data to be moved are present and the position the data will be moved to is empty
	            AND ((#sa_ConfirmData[2].Done AND #ix_ConfirmationRequired2) OR NOT #ix_ConfirmationRequired2)    //Validate if the data were confirmed if confirmation configured
	        THEN
	            #iqUDT_Induct.Position[1] := #iqUDT_Induct.Position[2]; //Shift the data
	            #iqUDT_Induct.Position[2] := #sUDT_EmptyParcelData;    //Clear the data on the position from where the data were shifted
	            #sa_ShiftData[2].Request := FALSE;
	            #sa_ShiftData[2].Done := TRUE;
	            #sa_ConfirmData[1].Request := #ix_ConfirmationRequired1; // Request data confirmation if configured
	            #sa_ConfirmData[1].Done := FALSE;
	        END_IF;
	        
	        // Confirm data
	        IF #sa_ConfirmData[1].Request
	            AND #ii_ConfirmationGIN2to1 <> 0
	            AND #iqUDT_Induct.Position[1].GINNumber > 0
	            AND #sa_ConfirmData[1].OldGIN <> #ii_ConfirmationGIN2to1   //Check if confirmation GIN is different than the old confirmation GIN
	            AND #ii_ConfirmationGIN2to1 <> #ii_ConfirmationGIN3to2    //Check if confirmation GIN is different than confirmation GIN in previous position
	        THEN
	            IF #iqUDT_Induct.Position[1].GINNumber = #ii_ConfirmationGIN2to1 //Validate if the GIN number matches the GIN number on the confirmation position
	            THEN
	                #sa_ConfirmData[1].Done := TRUE;
	                #sa_ConfirmData[1].Request := FALSE;
	                #sa_ConfirmData[1].OldGIN := #ii_ConfirmationGIN2to1;
	                
	            ELSE
	                // Data lost, overwrite with confirmation data
	                #iqUDT_Induct.Position[1] := #sUDT_EmptyParcelData;
	                #iqUDT_Induct.Position[1].GINNumber := #ii_ConfirmationGIN2to1;
	                
	                //Write maximum requested gap
	                #iqUDT_Induct.Position[1].GapRequired := (#iUDT_InductConfig.MaxParcelSize / 10) + #iUDT_InductConfig.GapTailToHead;
	                
	                #sa_ConfirmData[1].OldGIN := #ii_ConfirmationGIN2to1;
	                #sa_ConfirmData[1].Done := TRUE;
	                #sa_ConfirmData[1].Request := FALSE;
	                #si_ExceptionPosition := 1; //Write exception position the same as a position on which data were lost
	            END_IF;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 2.3 - Position 3 to 2
	        
	        IF #sR_Trig_ShiftDataReq3to2.Q // External request for shifting data
	        THEN
	            
	            #sa_ShiftData[3].Request := TRUE; // Request data shifting
	            #sa_ShiftData[3].Done := FALSE;   // Set shift data done to false
	            
	        END_IF;
	        
	        IF (#sa_ShiftData[3].Request
	            OR #ii_FirstShiftCheckPosition < 2)         // Check if the check position is less than the position from which shifting request is required
	            AND (#iqUDT_Induct.Position[3].GINNumber > 0 AND (#iqUDT_Induct.Position[2].GINNumber = 0 OR NOT #ix_ConfirmationRequired2)) //Check if the data to be moved are present and the position the data will be moved to is empty
	            AND ((#sa_ConfirmData[3].Done AND #ix_ConfirmationRequired3) OR NOT #ix_ConfirmationRequired3)    //Validate if the data were confirmed if confirmation configured
	        THEN
	            #iqUDT_Induct.Position[2] := #iqUDT_Induct.Position[3]; //Shift the data
	            #iqUDT_Induct.Position[3] := #sUDT_EmptyParcelData;     //Clear the data on the position from where the data were shifted
	            #sa_ShiftData[3].Request := FALSE;
	            #sa_ShiftData[3].Done := TRUE;
	            #sa_ConfirmData[2].Request := #ix_ConfirmationRequired2;   // Request data confirmation if configured
	            #sa_ConfirmData[2].Done := FALSE;
	        END_IF;
	        
	        //Cofirm data
	        IF #sa_ConfirmData[2].Request
	            AND #ii_ConfirmationGIN3to2 <> 0
	            AND #iqUDT_Induct.Position[2].GINNumber > 0
	            AND #sa_ConfirmData[2].OldGIN <> #ii_ConfirmationGIN3to2 //Check if confirmation GIN is different than the old confirmation GIN
	            AND #ii_ConfirmationGIN4to3 <> #ii_ConfirmationGIN3to2  //Check if confirmation GIN is different than confirmation GIN in previous position
	        THEN
	            
	            IF #iqUDT_Induct.Position[2].GINNumber = #ii_ConfirmationGIN3to2  //Validate if the GIN number matches the GIN number on the confirmation position
	                
	            THEN
	                #sa_ConfirmData[2].Done := TRUE;
	                #sa_ConfirmData[2].Request := FALSE;
	                #sa_ConfirmData[2].OldGIN := #ii_ConfirmationGIN3to2;
	                
	            ELSE
	                // Data lost, overwrite with confirmation data
	                #iqUDT_Induct.Position[2] := #sUDT_EmptyParcelData;
	                #iqUDT_Induct.Position[2].GINNumber := #ii_ConfirmationGIN3to2;
	                
	                //Write maximum requested gap
	                #iqUDT_Induct.Position[2].GapRequired := (#iUDT_InductConfig.MaxParcelSize / 10) + #iUDT_InductConfig.GapTailToHead;
	                
	                #sa_ConfirmData[2].OldGIN := #ii_ConfirmationGIN3to2;
	                #sa_ConfirmData[2].Done := TRUE;
	                #sa_ConfirmData[2].Request := FALSE;
	                #si_ExceptionPosition := 2; //Write exception position the same as a position on which data were lost
	            END_IF;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 2.4 - Position 4 to 3
	        
	        IF #sR_Trig_ShiftDataReq4to3.Q // External request for shifting data
	        THEN
	            
	            #sa_ShiftData[4].Request := TRUE; // Request data shifting
	            #sa_ShiftData[4].Done := FALSE;   // Set shift data done to false
	        END_IF;
	        
	        IF (#sa_ShiftData[4].Request
	            OR #ii_FirstShiftCheckPosition < 3)     // Check if the check position is less than the position from which shifting request is required
	            AND (#iqUDT_Induct.Position[4].GINNumber > 0 AND (#iqUDT_Induct.Position[3].GINNumber = 0 OR NOT #ix_ConfirmationRequired3)) //Check if the data to be moved are present and the position the data will be moved to is empty.
	            AND ((#sa_ConfirmData[4].Done AND #ix_ConfirmationRequired4) OR NOT #ix_ConfirmationRequired4)    //Validate if the data were confirmed if confirmation configured
	        THEN
	            #iqUDT_Induct.Position[3] := #iqUDT_Induct.Position[4]; //Shift the data
	            #iqUDT_Induct.Position[4] := #sUDT_EmptyParcelData;     //Clear the data on the position from where the data were shifted
	            #sa_ShiftData[4].Request := FALSE;
	            #sa_ShiftData[4].Done := TRUE;
	            #sa_ConfirmData[3].Request := #ix_ConfirmationRequired3;   // Request data confirmation if configured
	            #sa_ConfirmData[3].Done := FALSE;
	        END_IF;
	        
	        // Confirm data
	        IF #sa_ConfirmData[3].Request
	            AND #ii_ConfirmationGIN4to3 <> 0
	            AND #iqUDT_Induct.Position[3].GINNumber > 0
	            AND #sa_ConfirmData[3].OldGIN <> #ii_ConfirmationGIN4to3 //Check if confirmation GIN is different than the old confirmation GIN
	            AND #ii_ConfirmationGIN4to3 <> #ii_ConfirmationGIN5to4  //Check if confirmation GIN is different than confirmation GIN in previous position
	            
	        THEN
	            IF #iqUDT_Induct.Position[3].GINNumber = #ii_ConfirmationGIN4to3  //Validate if the GIN number matches the GIN number on the confirmation position
	            THEN
	                #sa_ConfirmData[3].Done := TRUE;
	                #sa_ConfirmData[3].Request := FALSE;
	                #sa_ConfirmData[3].OldGIN := #ii_ConfirmationGIN4to3;
	            ELSE
	                // Data lost, overwrite with confirmation data
	                #iqUDT_Induct.Position[3] := #sUDT_EmptyParcelData;
	                #iqUDT_Induct.Position[3].GINNumber := #ii_ConfirmationGIN4to3;
	                
	                //Write maximum requested gap
	                #iqUDT_Induct.Position[3].GapRequired := (#iUDT_InductConfig.MaxParcelSize / 10) + #iUDT_InductConfig.GapTailToHead;
	                
	                #sa_ConfirmData[3].OldGIN := #ii_ConfirmationGIN4to3;
	                #sa_ConfirmData[3].Done := TRUE;
	                #sa_ConfirmData[3].Request := FALSE;
	                #si_ExceptionPosition := 3; //Write exception position the same as a position on which data were lost
	            END_IF;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 2.5 - Position 5 to 4
	        
	        IF #sR_Trig_ShiftDataReq5to4.Q // External request for shifting data
	        THEN
	            
	            #sa_ShiftData[5].Request := TRUE; // Request data shifting
	            #sa_ShiftData[5].Done := FALSE;   // Set shift data done to false
	            
	        END_IF;
	        
	        IF (#sa_ShiftData[5].Request
	            OR #ii_FirstShiftCheckPosition < 4)     // Check if the check position is less than the position from which shifting request is required
	            AND (#iqUDT_Induct.Position[5].GINNumber > 0 AND (#iqUDT_Induct.Position[4].GINNumber = 0 OR NOT #ix_ConfirmationRequired4)) //Check if the data to be moved are present and the position the data will be moved to is empty.
	            AND ((#sa_ConfirmData[5].Done AND #ix_ConfirmationRequired5) OR NOT #ix_ConfirmationRequired5) //Validate if the data were confirmed if confirmation configured
	        THEN
	            #iqUDT_Induct.Position[4] := #iqUDT_Induct.Position[5]; //Shift the data
	            #iqUDT_Induct.Position[5] := #sUDT_EmptyParcelData;    //Clear the data on the position from where the data were shifted
	            #sa_ShiftData[5].Request := FALSE;
	            #sa_ShiftData[5].Done := TRUE;
	            #sa_ConfirmData[4].Request := #ix_ConfirmationRequired4;   // Request data confirmation if configured
	            #sa_ConfirmData[4].Done := FALSE;
	        END_IF;
	        
	        // Confirm data
	        IF #sa_ConfirmData[4].Request
	            AND #ii_ConfirmationGIN5to4 <> 0
	            AND #iqUDT_Induct.Position[4].GINNumber > 0
	            AND #sa_ConfirmData[4].OldGIN <> #ii_ConfirmationGIN5to4 //Check if confirmation GIN is different than the old confirmation GIN
	            AND #ii_ConfirmationGIN5to4 <> #ii_ConfirmationGIN6to5  //Check IF confirmation GIN is different than confirmation GIN in previous position
	        THEN
	            IF #iqUDT_Induct.Position[4].GINNumber = #ii_ConfirmationGIN5to4  //Validate if the GIN number matches the GIN number on the confirmation position
	            THEN
	                #sa_ConfirmData[4].Done := TRUE;
	                #sa_ConfirmData[4].Request := FALSE;
	                #sa_ConfirmData[4].OldGIN := #ii_ConfirmationGIN5to4;
	            ELSE
	                // Data lost, overwrite with confirmation data
	                #iqUDT_Induct.Position[4] := #sUDT_EmptyParcelData;
	                #iqUDT_Induct.Position[4].GINNumber := #ii_ConfirmationGIN5to4;
	                
	                //Write maximum requested gap
	                #iqUDT_Induct.Position[4].GapRequired := (#iUDT_InductConfig.MaxParcelSize / 10) + #iUDT_InductConfig.GapTailToHead;
	                
	                #sa_ConfirmData[4].OldGIN := #ii_ConfirmationGIN5to4;
	                #sa_ConfirmData[4].Done := TRUE;
	                #sa_ConfirmData[4].Request := FALSE;
	                #si_ExceptionPosition := 4; //Write exception position the same as a position on which data were lost
	            END_IF;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 2.6 - Position 6 to 5 
	        
	        
	        IF #sR_Trig_ShiftDataReq6to5.Q // External request for shifting data
	        THEN
	            
	            #sa_ShiftData[6].Request := TRUE; // Request data shifting
	            #sa_ShiftData[6].Done := FALSE;   // Set shift data done to false
	            
	        END_IF;
	        
	        IF (#sa_ShiftData[6].Request
	            OR #ii_FirstShiftCheckPosition < 5)     // Check if the check position is less than the position from which shifting request is required
	            AND (#iqUDT_Induct.Position[6].GINNumber > 0 AND (#iqUDT_Induct.Position[5].GINNumber = 0 OR NOT #ix_ConfirmationRequired5)) //Check if the data to be moved are present and the position the data will be moved to is empty.
	        THEN
	            #iqUDT_Induct.Position[5] := #iqUDT_Induct.Position[6]; //Shift the data
	            #iqUDT_Induct.Position[6] := #sUDT_EmptyParcelData;     //Clear the data on the position from where the data were shifted
	            #sa_ShiftData[6].Request := FALSE;
	            #sa_ShiftData[6].Done := TRUE;
	            #sa_ConfirmData[5].Request := #ix_ConfirmationRequired5; // Request data confirmation if configured
	            #sa_ConfirmData[5].Done := FALSE;
	        END_IF;
	        
	        // Confirm data
	        IF #sa_ConfirmData[5].Request
	            AND #ii_ConfirmationGIN6to5 <> 0
	            AND #iqUDT_Induct.Position[5].GINNumber > 0
	            AND #sa_ConfirmData[5].OldGIN <> #ii_ConfirmationGIN6to5 //Check if confirmation GIN is different than the old confirmation GIN
	        THEN
	            IF #iqUDT_Induct.Position[5].GINNumber = #ii_ConfirmationGIN6to5 //Validate if the GIN number matches the GIN number on the confirmation position
	            THEN
	                #sa_ConfirmData[5].Done := TRUE;
	                #sa_ConfirmData[5].Request := FALSE;
	                #sa_ConfirmData[5].OldGIN := #ii_ConfirmationGIN6to5;
	            ELSE
	                // Data lost, overwrite with confirmation data
	                #iqUDT_Induct.Position[5] := #sUDT_EmptyParcelData;
	                #iqUDT_Induct.Position[5].GINNumber := #ii_ConfirmationGIN6to5;
	                
	                //Write maximum requested gap
	                #iqUDT_Induct.Position[5].GapRequired := (#iUDT_InductConfig.MaxParcelSize / 10) + #iUDT_InductConfig.GapTailToHead;
	                
	                #sa_ConfirmData[5].OldGIN := #ii_ConfirmationGIN6to5;
	                #sa_ConfirmData[5].Done := TRUE;
	                #sa_ConfirmData[5].Request := FALSE;
	                #si_ExceptionPosition := 5;    //Write exception position the same as a position on which data were lost
	            END_IF;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 2.7 - Adding new parcel to the induct
	        
	        // Check if the GIN number at the last position if grather than 0
	        IF #ii_GINAtLastPosition > 0
	            AND #ii_GINAtLastPosition <> #si_GinOld // Check if the GIN number is different than OLD GIN
	        THEN
	            #iqUDT_Induct.Position[6].GINNumber := #ii_GINAtLastPosition;
	            
	            IF "DB_GIN".GIN[#ii_GINAtLastPosition].General.Length > 0  //Check if the package length for the GIN number is greater than 0
	            THEN
	                #iqUDT_Induct.Position[6].GapRequired := "DB_GIN".GIN[#ii_GINAtLastPosition].General.Length + #iUDT_InductConfig.GapTailToHead; //Required gap is parcel length + configured gap tail to head
	            ELSE
	                #iqUDT_Induct.Position[6].GapRequired := (#iUDT_InductConfig.MaxParcelSize / 10) + #iUDT_InductConfig.GapTailToHead;  //Write maximum requested gap
	            END_IF;
	            
	            #si_GinOld := #ii_GINAtLastPosition;
	        END_IF;
	        
	    END_REGION
	    
	    // Update diagnostic
	    IF #si_ExceptionPosition > 0
	    THEN
	        
	        #sa_Diagnostic.TrackingLost += 1;
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Exceptions
	    
	    REGION 3.1 - Window monitoring
	        
	        //Get the number of array elements
	        #si_NrOfPositions := "FC_GetNrOfArrayEl"(#iqUDT_Induct.Position);
	        
	        //Lookig for the missing window
	        FOR #ti_LoopCounter1 := 1 TO #si_NrOfPositions DO
	            
	            IF #iqUDT_Induct.Position[#ti_LoopCounter1].WindowReserved //Check if window is reserved for induct position
	            THEN
	                //When the window was reserved then decrease the window position based on displacement
	                #iqUDT_Induct.Position[#ti_LoopCounter1].WindowPosition -= #iqUDT_MergeInterface.Displacement;
	                
	                // Check if the window position value does not go negative
	                IF #iqUDT_Induct.Position[#ti_LoopCounter1].WindowPosition < 0
	                THEN
	                    #iqUDT_Induct.Position[#ti_LoopCounter1].WindowPosition := 0;
	                END_IF;
	                //When the window position is less than the induct position it means that the induct miss the window                                                                                                      
	                IF #iqUDT_Induct.Position[#ti_LoopCounter1].WindowPosition < (#iUDT_InductConfig.Induct_Position / 10 - #iUDT_InductConfig.InductPositionWindow)
	                THEN
	                    //Write exception position 
	                    IF #si_ExceptionPosition > #ti_LoopCounter1 OR #si_ExceptionPosition = 0
	                    THEN
	                        #sa_Diagnostic.MissingWindow += 1;
	                        #si_ExceptionPosition := #ti_LoopCounter1;
	                    END_IF;
	                    
	                    EXIT;
	                END_IF;
	                
	            END_IF;
	            
	        END_FOR;
	        
	    END_REGION
	    
	    REGION 3.2 - Requested length check
	        
	        // Checking if the requested length is the same on induct array and reserved in the merge tracking array
	        FOR #ti_LoopCounter2 := ((#iUDT_InductConfig.Induct_Position / 10) + #ci_RequestLengthCheckPosition) TO ((#iUDT_InductConfig.Induct_Position / 10) + #ci_RequestLengthCheckPosition) + 5 DO
	            //When we find request to release in merge tracking array then we can check the requested length and GIN number
	            IF #iqUDT_MergeTracking[#ti_LoopCounter2] = - (#iUDT_InductConfig.Induct_Number + 100) AND
	                (#iqUDT_MergeTracking[#ti_LoopCounter2 + 1] <> #iqUDT_Induct.Position[1].GapRequired)
	                // OR #iq_UDT_MergeTracking[#ti_LoopCounter2 + 2] <> #iq_UDT_Induct.Position[1].GINNumber)
	            THEN
	                //When the requested length is different than the length reserved in the merge tracking array then we reset that request because is not valid
	                #iqUDT_MergeTracking[#ti_LoopCounter2] := 0;
	                #iqUDT_MergeTracking[#ti_LoopCounter2 + 1] := 0;
	                #iqUDT_MergeTracking[#ti_LoopCounter2 + 2] := 0;
	                
	                #sa_Diagnostic.WrongLength += 1;
	                
	                //Write exception position
	                IF #si_ExceptionPosition > 2 OR #si_ExceptionPosition = 0
	                THEN
	                    #si_ExceptionPosition := 1;
	                END_IF;
	                
	                EXIT;
	            END_IF;
	        END_FOR;
	        
	    END_REGION
	    
	    REGION 3.3 - Lack of GIN number, auto recovey
	        
	        // Check if the unknown GIN is within range
	        IF #iqUDT_UnknownGINRange.GIN < #iqUDT_UnknownGINRange.Start
	            OR #iqUDT_UnknownGINRange.GIN > #iqUDT_UnknownGINRange.End
	        THEN
	            #iqUDT_UnknownGINRange.GIN := #iqUDT_UnknownGINRange.Start;
	        END_IF;
	        
	        //When the parcel is at the induct position but has no GIN number
	        IF ((#iqUDT_HandShake.RTS OR #iqUDT_InductStatus.Dieback)
	            AND #iqUDT_InductStatus.AutoON
	            AND (#iqUDT_Induct.Position[1].GINNumber = 0))
	            
	            // Auto recovey signal from induct
	            OR #iqUDT_Induct.AutoRecovery
	            
	        THEN
	            #si_ExceptionPosition := 1;
	            #iqUDT_Induct.Position[1].GINNumber := #iqUDT_UnknownGINRange.GIN;  //Write GIN number from Unknown GIN range
	            #iqUDT_UnknownGINRange.GIN := #iqUDT_UnknownGINRange.GIN + 1; // Update Unknown GIN range
	            #iqUDT_Induct.Position[1].GapRequired := (#iUDT_InductConfig.MaxParcelSize / 10) + #iUDT_InductConfig.GapTailToHead; //Write maximum required gap
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 3.4 - Exception handling
	        
	        //When the exception was found reinitialize the whole array from the exception position
	        IF #si_ExceptionPosition > 0
	        THEN
	            
	            FOR #ti_LoopCounter1 := #si_ExceptionPosition TO #si_NrOfPositions DO
	                
	                IF #iqUDT_Induct.Position[#ti_LoopCounter1].WindowReserved //Check if window is reserved for induct position
	                THEN
	                    FOR #ti_LoopCounter2 := #iqUDT_Induct.Position[#ti_LoopCounter1].WindowPosition - 2 TO #iqUDT_Induct.Position[#ti_LoopCounter1].WindowPosition + 2 DO
	                        IF #iqUDT_MergeTracking[#ti_LoopCounter2] = - (#iUDT_InductConfig.Induct_Number + 100)
	                        THEN
	                            //Delete induct request and induct requested length
	                            #iqUDT_MergeTracking[#ti_LoopCounter2] := 0;
	                            #iqUDT_MergeTracking[#ti_LoopCounter2 + 1] := 0;
	                            #iqUDT_MergeTracking[#ti_LoopCounter2 + 2] := 0;
	                        END_IF;
	                    END_FOR;
	                    //Reset the window
	                    #iqUDT_Induct.Position[#ti_LoopCounter1].WindowPosition := 0;
	                    #iqUDT_Induct.Position[#ti_LoopCounter1].WindowReserved := FALSE;
	                ELSE
	                    EXIT;
	                END_IF;
	                
	            END_FOR;
	            
	        END_IF;
	        //Reset the Exception position
	        #si_ExceptionPosition := 0;
	        
	    END_REGION
	    
	    REGION 3.5 - Data clearing
	        
	        //Clear remaining data when energy save occur
	        IF #ix_EnergySaveActive
	        THEN
	            FOR #ti_LoopCounter1 := 1 TO #si_NrOfPositions DO
	                #iqUDT_Induct.Position[#ti_LoopCounter1] := #sUDT_EmptyParcelData;
	            END_FOR;
	        END_IF;
	        
	        //Disable window reservation when external error occur
	        #iqUDT_Induct.DisableWindowReservation := #ix_ExternalError;
	        
	    END_REGION
	    
	    REGION 3.6 - Confirm no duplicate GIN in FIFO
	        
	        //Check FIFO in case of duplicate GIN number 
	        FOR #ti_LoopCounter1 := 1 TO #si_NrOfPositions - 1 DO
	            FOR #ti_LoopCounter2 := #ti_LoopCounter1 + 1 TO #si_NrOfPositions - 1 DO
	                // When duplicate GIN number is find then clear the duplicate data
	                IF #iqUDT_Induct.Position[#ti_LoopCounter1].GINNumber = #iqUDT_Induct.Position[#ti_LoopCounter2].GINNumber
	                    AND #iqUDT_Induct.Position[#ti_LoopCounter2].GINNumber <> 0
	                THEN
	                    #iqUDT_Induct.Position[#ti_LoopCounter2] := #sUDT_EmptyParcelData;
	                    
	                END_IF;
	            END_FOR;
	            
	        END_FOR;
	        
	    END_REGION
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_GetGIN"
TITLE = FB_GetGIN
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 10
// END_ATTRIBUTES
//Function block to find GIN in tracking array.
   VAR_INPUT 
      ii_TriggerPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Position of trigger [cm]
      ii_SearchWindow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Search window [cm]
      ix_Trigger { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // When TRUE get GIN code
   END_VAR

   VAR_OUTPUT 
      qi_Gin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // General Identification Number found
   END_VAR

   VAR_IN_OUT 
      iqa_TrackingData : Array[*] of Int;   // Tracking data
      iqx_Received { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // When TRUE qi_GIN output is set to '0'
   END_VAR

   VAR 
      sR_Trigger {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      si_Loopcounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_Position { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Position to look for Gin
      si_PosFound { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Position first Gin was found
      sx_Found { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	 
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	28/05/2019  | 0.1       | F.Baten       | first release TIA 15
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	
	
	                               Trigger
	XXX                            position                                       0
	|                                  |                                          |
	|-----------------------------------------------------------------------------|
	|                   |              |                                          |
	|                    <---window--->                               >-- tracking/flow direction -->     
	|                                                                             |
	|-----------------------------------------------------------------------------|
	
	At a trigger pulse a Gin-code is searched in the tracking DB starting from the trigger position. 
	When found the block provides the found GIN and the position it was found on. 
	
	When the Gin was handled it can also reset the found value to 0.
	*)
	
	REGION 1 Get GIN from tracking DB  
	    #sR_Trigger(CLK := #ix_Trigger);
	    
	    IF #sR_Trigger.Q                                                                    // One shot to start searching in tracking DB
	    THEN
	        #qi_Gin := 0;                                                                   // reset GIN found
	        #si_Position := 0;                                                              // reset position found
	        #sx_Found := FALSE;                                                             // reset found bit
	        
	        
	        FOR #si_Loopcounter := 0 TO #ii_SearchWindow BY 1 DO                            // Set loopsize by search window
	            
	            #si_Position := #ii_TriggerPosition + #si_Loopcounter;                      // Set position to look for GIN
	            
	            IF #iqa_TrackingData[#si_Position] <> 0 AND #sx_Found = FALSE THEN          // If there is a value within the search window
	                #si_PosFound := #si_Position;
	                #qi_Gin := #iqa_TrackingData[#si_Position];                             // copy that value to output
	                #sx_Found := TRUE;                                                      // Set found
	                EXIT;
	                // EXIT loop
	            END_IF;
	        END_FOR;
	    END_IF;
	END_REGION
	
	REGION 2 Reset GIN, was handled
	    IF #iqx_Received                                                                    // External signal meaning GIN was received and handled
	    THEN
	        #qi_Gin := 0;                                                                   // Reset output
	        #sx_Found := FALSE;                                                             // Reset found signal
	        #iqx_Received := FALSE;                                                         // Reset handshake
	    END_IF;
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_GetPositionBasic"
TITLE = FB_GetPosition
{ S7_Optimized_Access := 'TRUE' }
FAMILY : MHS
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 11
// END_ATTRIBUTES
//Function to find the position based on the GIN in the tracking. 
   VAR_INPUT 
      ii_Decisionpoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Point in tracking data to look for GIN
   END_VAR

   VAR_IN_OUT 
      iqs_DB_Destination : Array[*] of "UDT_Destinations";   // Array with destination data for parcel
      iqs_TrackingData : Array[*] of Int;   // Tracking data
      iqi_RequestedPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Requested position to go to based on GIN
   END_VAR

   VAR 
      sdi_RequestedDestination { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // The destination for this GIN
      si_Gin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // GIN found in tracking
      si_PreviousGin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Previous GIN processed
      si_RequestedPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Requested position to go to based on GIN
      si_LC_Positions { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Loopcounter positions
      si_LC_Destinations { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Loopcounter destinations
      si_NrPositons { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Number of positions in the search area
      si_NrDestinations { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Number of destinations per position
      sx_NewGinFound { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Memory to start searching
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	
	10-09-2019  | 2.0       | F.Baten       | Doubled search loop and added comment 
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	08/01/2020  | 3.1       | F.Baten       | When no destination is given, also go to default direction
	15/01/2019  | 3.2       | L.Klar        | GIN record structure updated, parcel destination remapped
	19/10/2020  | 3.3       | L.Klar        | Double search loop reprogrammed, issue with default position
	07/12/2020  | 3.4       | L.Klar        | GIN greater than zero condition added to region 2
	11/04/2023  | 4.0       | F.Baten       | Removed VSU interface to be adaptable for more devices
	                                        | 4.0 Release TIA 17.5
	12/
	*)
	
	
	REGION 1 - Determine size OF search area 
	    
	    #si_NrPositons := "FC_GetNrOfArrayEl"(#iqs_DB_Destination);
	    #si_NrDestinations := "FC_GetNrOfArrayEl"(#iqs_DB_Destination[1].Destination);
	    
	END_REGION
	
	REGION 2 - Get GIN from tracking DB  
	    // There is a value in the tracking data on the decision point which is not '0' or equal to the previous GIN
	    
	    IF (#iqs_TrackingData[#ii_Decisionpoint] <> 0) AND (#iqs_TrackingData[#ii_Decisionpoint] <> #si_PreviousGin)
	    THEN
	        #si_Gin := #iqs_TrackingData[#ii_Decisionpoint];
	        #sx_NewGinFound := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Get destination from GIN DB
	    // If new GIN has been detected, get destination from its GIN record 
	    
	    IF #sx_NewGinFound AND #si_Gin > 0
	    THEN
	        #sdi_RequestedDestination := "DB_GIN".GIN[#si_Gin].General.Destination[0];
	        #si_PreviousGin := #si_Gin;
	        #si_Gin := 0;
	        #iqi_RequestedPosition := 0;
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Get requested position when new GIN is found 
	    IF #sx_NewGinFound
	    THEN
	        // If destination is different than 0, find a position in destination arrays. Otherwise, requested position is set to default.
	        IF #sdi_RequestedDestination <> 0 THEN
	            FOR #si_LC_Positions := 1 TO #si_NrPositons BY 1 DO
	                FOR #si_LC_Destinations := 0 TO (#si_NrDestinations - 1) BY 1 DO
	                    IF #iqs_DB_Destination[#si_LC_Positions].Destination[#si_LC_Destinations] = #sdi_RequestedDestination
	                    THEN
	                        #si_RequestedPosition := #si_LC_Positions;
	                        EXIT;
	                    END_IF;
	                END_FOR;
	                // Position found
	                IF #si_RequestedPosition <> 0
	                THEN
	                    #iqi_RequestedPosition := #si_RequestedPosition;
	                    #sx_NewGinFound := FALSE;
	                    #si_RequestedPosition := 0;
	                    EXIT;
	                END_IF;
	            END_FOR;
	        ELSE
	            // Default position
	            #iqi_RequestedPosition := 99;
	            #sx_NewGinFound := FALSE;
	            #si_RequestedPosition := 0;
	        END_IF;
	    END_IF;
	END_REGION
END_FUNCTION_BLOCK

FUNCTION "FC_ExtractCodeFromString" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      is_String : String;
   END_VAR

   VAR_OUTPUT 
      qs_String : String;
   END_VAR

   VAR_TEMP 
      ts_String : Bool;
      ti_StartPoint : Int;
      ti_StopPoint : Int;
      ti_CodeLenght : Int;
   END_VAR

   VAR CONSTANT 
      StartSign : String := '$02';
      StopSign : String := '$03';
   END_VAR


BEGIN
	#ti_StartPoint := FIND(IN1 := #is_String, IN2 := #StartSign);
	#ti_StopPoint := FIND(IN1 := #is_String, IN2 := #StopSign);
	#ti_CodeLenght := #ti_StopPoint - #ti_StartPoint - 1;
	
	#qs_String := MID(IN := #is_String, L := #ti_CodeLenght, P := #ti_StartPoint + 1);
	
END_FUNCTION

FUNCTION_BLOCK "FB_GetPositionVSU"
TITLE = FB_GetPosition
{ S7_Optimized_Access := 'TRUE' }
FAMILY : MHS
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 12
// END_ATTRIBUTES
//Function to find the position based on the GIN in the tracking. 
   VAR_IN_OUT 
      iqa_DBDestination : Array[*] of "UDT_Destinations";   // Array with destination data for parcel
      iqUDT_VSUInterface : "UDT_VSUInterface";   // Interface beween VSU and VFD
      iqa_TrackingData : Array[*] of Int;   // Tracking data
   END_VAR

   VAR 
      sdi_RequestedDestination { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // The destination for this GIN
      si_Gin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_PreviousGin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_RequestedPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_LoopCounterPositions { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Loopcounter positions
      si_LoopCounterDestinations { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Loopcounter destinations
      si_NumberOfPositons { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Number of positions in the search area
      si_NumberOfDestinations { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Number of destinations per position
      sx_NewGinFound { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Memory to start searching
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	10-09-2019  | 2.0       | F.Baten       | Doubled search loop and added comment 
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	08/01/2020  | 3.1       | F.Baten       | When no destination is given, also go to default direction
	15/01/2019  | 3.2       | L.Klar        | GIN record structure updated, parcel destination remapped
	19/10/2020  | 3.3       | L.Klar        | Double search loop reprogrammed, issue with default position
	07/12/2020  | 3.4       | L.Klar        | GIN greater than zero condition added to region 2
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	
	REGION 1 - Determine size OF search area 
	    
	    #si_NumberOfPositons := "FC_GetNrOfArrayEl"(#iqa_DBDestination);
	    #si_NumberOfDestinations := "FC_GetNrOfArrayEl"(#iqa_DBDestination[1].Destination);
	    
	END_REGION
	
	REGION 2 - Get GIN from tracking DB  
	    // There is a value in the tracking data on the decision point which is not '0' or equal to the previous GIN
	    
	    IF (#iqa_TrackingData[#iqUDT_VSUInterface.Decisionpoint] <> 0) AND (#iqa_TrackingData[#iqUDT_VSUInterface.Decisionpoint] <> #si_PreviousGin)
	    THEN
	        #si_Gin := #iqa_TrackingData[#iqUDT_VSUInterface.Decisionpoint];
	        #sx_NewGinFound := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Get destination from GIN DB
	    // If new GIN has been detected, get destination from its GIN record 
	    
	    IF #sx_NewGinFound AND #si_Gin > 0
	    THEN
	        #sdi_RequestedDestination := "DB_GIN".GIN[#si_Gin].General.Destination[0];
	        #si_PreviousGin := #si_Gin;
	        #si_Gin := 0;
	        #iqUDT_VSUInterface.RequestedPosition := 0;
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Get requested position when new GIN is found 
	    IF #sx_NewGinFound
	    THEN
	        // If destination is different than 0, find a position in destination arrays. Otherwise, requested position is set to default.
	        IF #sdi_RequestedDestination <> 0 THEN
	            FOR #si_LoopCounterPositions := 1 TO #si_NumberOfPositons BY 1 DO
	                FOR #si_LoopCounterDestinations := 0 TO (#si_NumberOfDestinations - 1) BY 1 DO
	                    IF #iqa_DBDestination[#si_LoopCounterPositions].Destination[#si_LoopCounterDestinations] = #sdi_RequestedDestination
	                    THEN
	                        #si_RequestedPosition := #si_LoopCounterPositions;
	                        EXIT;
	                    END_IF;
	                END_FOR;
	                // Position found
	                IF #si_RequestedPosition <> 0
	                THEN
	                    #iqUDT_VSUInterface.RequestedPosition := #si_RequestedPosition;
	                    #sx_NewGinFound := FALSE;
	                    #si_RequestedPosition := 0;
	                    EXIT;
	                END_IF;
	            END_FOR;
	        ELSE
	            // Default position
	            #sx_NewGinFound := FALSE;
	            #iqUDT_VSUInterface.RequestedPosition := 99;
	            #si_RequestedPosition := 0;
	        END_IF;
	    END_IF;
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_InchingBulk"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 13
// END_ATTRIBUTES
   VAR_INPUT 
      ix_PECUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PEC Sum signal from upstream conveyor
      ix_InchingActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // If TRUE inching is activate
      ix_ClearCommand { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command to clear full status
      ix_DownstreamFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE if downstream conveyors are full
      ii_OnDelayGap { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Distance to conveyor release [mm]
      ii_InchingGap { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Inching distance [mm]
      ii_Displacement_Upstream { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Upstream conveyor displacement
      ii_Displacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Inching conveyor displacement
   END_VAR

   VAR_OUTPUT 
      qx_ExternalRequestHold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External output to request conveyor hold
      qx_Full { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Inching conveyor is full status
   END_VAR

   VAR 
      sUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_InchingStatus";
      sUDT_StatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_InchingStatus";
      F_TRIG_PECEoSUp {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger PEC EoS
      si_ActualInchingGap { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Distance to request hold
      si_ActualOnGap { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Distance to conveyor release
      sx_StartRelease { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor release
      sx_ConveyorFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	01/04/2021  | 1.0       | M.Kocot       | first release TIA 16
	08/04/2021  | 1.1       | H.Rutkwoski   | Added status full
	14/08/2021  | 1.2       | M. Jager      | Reset sx_full when inching is not active 
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	12/03/2024  | 4.1       | S. Nieswiec   | Removed underscore from function name
	*)
	
	REGION 1 - Triggers
	    
	    // Falling edge trigger PEC EoS.
	    #F_TRIG_PECEoSUp(CLK := #ix_PECUp);
	    
	END_REGION
	
	
	REGION 2 - Inching
	    // Statement section REGION
	    
	    #qx_ExternalRequestHold := #ix_InchingActive;
	    
	    IF #F_TRIG_PECEoSUp.Q AND #ix_InchingActive THEN
	        #si_ActualOnGap := DINT_TO_INT(#ii_OnDelayGap / 10);
	        #si_ActualInchingGap := DINT_TO_INT(#ii_InchingGap / 10);
	        
	    END_IF;
	    
	    IF #si_ActualOnGap > 0 THEN
	        
	        #si_ActualOnGap := #si_ActualOnGap - #ii_Displacement_Upstream;
	        
	    END_IF;
	    
	    IF #ix_PECUp AND #si_ActualInchingGap > 0 THEN
	        #si_ActualInchingGap := #si_ActualInchingGap - #ii_Displacement;
	    END_IF;
	    
	    IF #si_ActualOnGap <= 0
	        OR #sx_StartRelease
	    THEN
	        #sx_StartRelease := TRUE;
	    END_IF;
	    
	    IF #si_ActualInchingGap <= 0
	    THEN
	        #sx_StartRelease := FALSE;
	    END_IF;
	    
	    IF #sx_StartRelease THEN
	        #qx_ExternalRequestHold := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Internal status - convayor full
	    
	    // Set conveyor status to full when:
	    IF #ix_InchingActive                     // inching is active 
	        AND #ix_DownstreamFull               // downstream is full
	        AND NOT #ix_ClearCommand             // there is no clear command active
	    THEN
	        #sx_ConveyorFull := TRUE;
	    END_IF;
	    
	    // Set conveyor status to NOT full when:
	    IF (#ix_InchingActive                   // Inching is active
	        AND #ix_ClearCommand                // clear command is active
	        AND NOT #ix_DownstreamFull)         // downstream is NOT full)             
	        OR NOT #ix_InchingActive            // OR Inching isnt active
	    THEN
	        #sx_ConveyorFull := FALSE;
	    END_IF;
	    
	END_REGION
	
	
	REGION 4 - Status
	    
	    // Convsyor is full status
	    #sUDT_Status.Full := #sx_ConveyorFull;
	    
	    #sUDT_Status.Active := #ix_InchingActive;
	    
	    // Status update on change.
	    IF #sUDT_StatusOld <> #sUDT_Status
	    THEN
	        #qx_Full := #sUDT_Status.Full;
	        #sUDT_StatusOld := #sUDT_Status;
	    END_IF;
	    
	END_REGION
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MainControlPanel"
TITLE = Main Control Panel Cabinet Block
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : CesarLeite
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 253
// END_ATTRIBUTES
   VAR_INPUT 
      is_PNPNCouplerDeviceName { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   //  Name of the PN PN coupler device
      is_SingulatorCouplerDeviceName { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   //  Name of the Singulator coupler device
      is_IOModulePNDeviceName { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String := '';   //  Name of the ET200sp device
      is_ScalanceSwitchName { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Name of the Scalance Switch
      ii_Racksize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Number off slots present in the rack
      ix_UPSOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE if Unit Power Supply with no faults
      ix_NoFireAlarmActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE if Fire alarm is not active
      ix_24V201T1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE if power supply has no warning
      ix_CBTripped101F4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE if MCP circuit breaker is tripped
      ix_CBTripped102F1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE if MCP circuit breaker is not tripped
      ix_CBTripped201F1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE if MCP circuit breaker is not tripped
      ix_CBTripped205F5 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE if MCP circuit breaker is not tripped
      ix_ScalanceSwitchStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE if the scalance switch is Healthy
      ix_SimulationModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE if simulation is active
      ix_SingulatorCouplerAvailable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE if singulator coulper available in cabinet
      ix_ExternalScan { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  External scan
      ix_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when  hardware is Ok
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_MainControlPanelStatus";   //  HMI status structure
      qUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   //  Common status structure
   END_VAR

   VAR_IN_OUT 
      iqUDT_Statistics : "UDT_MainControlPanelStatistics";   //  Statistics structure
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   //  Equipment control structure
   END_VAR

   VAR 
      sUDT_PNCouplerPNDevice { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PNDevice";   //  PN device structure
      sUDT_ScalanceSwitchDevice { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PNDevice";   // Scalance Switch device structure
      sUDT_SingulatorCouplerPNDevice { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PNDevice";   //  PN device structure
      sUDT_CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //  Common status structure
      sUDT_CommonStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //  Auxiliary status structure
      sUDT_MasterControlPanelRIOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //  Common status structure
      sUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MainControlPanelStatus";   //  MCP status UDT
      sUDT_RIOStatistics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RIOStatistics";   //  Statistics structure
      sUDT_MasterControlPanelRIOHMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RIOStatus";   // MCP I/O Module status
      sFB_MasterControlPanelRIO { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_RIO";   // MCP I/O module fucntion block
      sFB_TimerOnOffDelayCheckSupply { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //  MHS "TimerOnOffDelay" - to delay time for VFD supply contactor
      sa_PNCouplerPortsStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..8] of Bool;   // TRUE when specific PN coupler port has an error
      sa_SingulatorPortsStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..8] of Bool;   // TRUE when specific IO module port has an error
      sa_ScalanceSwitchStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..8] of Bool;   // TRUE when specific IO module port has an error
      sa_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //  Status structure
         ErrorCode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //  Error code structure
            ModuleState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Siemens "ModuleState" error code
         END_STRUCT;
      END_STRUCT;
      sR_Trig_UPS {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rise trigger when a UPS fault occurs
      sR_Trig_PNCoupler {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rise trigger when a PN/PN Coupler fault occurs
      sR_Trig_ProSoftCoupler {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rise trigger when a ProSoft Coupler fault occurs
      sR_Trig_MainRackModule {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rise trigger when there is an error on the mainrack modules
      sR_Trig_FireAlarm {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rise trigger when a Fire alarm fault occurs
      sR_Trig_ScalanceSwitchStatus {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rise trigger when a scalance switch status is not healthy
      sR_Trig_ScalanceSwitch {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rise trigger when a scalance switch fault occurs
      sR_Trig_24V_201T1 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rise trigger when a 201T1 circuit braker tripped
      sR_Trig_CB_Tripped_101F4 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rise trigger when a 101F4 circuit braker tripped
      sR_Trig_CB_Tripped_102F1 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rise trigger when a 102F1 circuit braker tripped
      sR_Trig_CB_Tripped_201F1 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rise trigger when a 201F1 circuit braker tripped
      sR_Trig_CB_Tripped_205F5 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rise trigger when a 205F5 circuit braker tripped
      sx_RackCheck { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Start checking the mainrack
      sx_PowerOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  True = External Power OK
   END_VAR

   VAR_TEMP 
      ts_Configured : Array[0..127] of Bool;   //  Configured structure
      ts_Exist : Array[0..127] of Bool;   //  Exits structure
      ts_Error : Array[0..127] of Bool;   //  Error structure
      ti_Racksize : Int;   //  The limited size of the rack
      ti_ModuleNr : Int;   //  The number of the module being processed
   END_VAR

   VAR CONSTANT 
      ci_PowerSupplyDelayTime : UInt := 4000;   //  Power supply delay time
      cui_LADDR : UInt := 32;   //  Local~Device
      cui_ConfiguredDevicesMode : UInt := 1;   //  Scan mode of configured devices
      cui_ExistingDevicesMode : UInt := 4;   //  Scan mode of existing devices
      cui_DevicesErrorMode : UInt := 2;   //  Scan mode of devices error
      ci_NumberOfProfinetPorts : Int := 2;   // Number of Profinet ports in device
      ci_RackMaximumSize : Int := 31;
      ci_RackMinimumSize : Int := 4;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	17/09/2019  | 2.0       | C.Leite       | first release TIA 15.1
	14/10/2019  | 2.1       | L.Klar        | Updated status structure
	16/10/2019  | 2.2       | S. Deulkar    | USed FC_GetDevice PN to create PN error
	30/10/2019  | 2.3       | M. Kurpiers   | Regions renumbering
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	04/11/2019  | 3.1       | F.Baten       | Region 4: ix_SimulationModeActive rearranged to correct position
	25/02/2020  | 3.2       | S. Deulkar    | Modified to update ststus output every cycle 
	06/05/2020  | 3.3       | F.Baten       | New UDT_MCPStatus
	24/06/2020  | 3.4       | F.Baten       | Mainrack module state function added
	29/06/2020  | 3.5       | F.Baten       | Changed statistics for Mainrack modules
	07/07/2020  | 3.6       | S.Theocharis  | Change HMI status to IO
	09/07/2020  | 3.7       | S.Theocharis  | Bug fix in status update. Initialize static status instead output status
	20/07/2020  | 3.8       | K.Pokorski    | Bug fix in PLC module status update. Change HMI status from InOut to Out
	03/11/2020  | 3.9       | K.Pokorski    | Profinet ports diagnostics added
	14/04/2021  | 3.10      | H.Rutkowski   | FB_RIO for MCP Remote IO integarted into the function
	                                        | Added new inputs from MCP Remote IO with the corresponding errors, statuses and statistics
	16/07/2021  | 3.11      | M. roijen     | Bug fix reset errors PN-PN_PNSlaveWarning and PS_201T4_Warning
	14-08-2021  | 3.12      | S. Deulkar    | added set profinet scan when PLC has error region 5    
	16/02/2022  | 3.13      | M.Piela       | FedEx release
	11/05/2022  | 3.14      | M.Singh       | Changes equivalant to name change in UDT MCP status 
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	
	REGION 1 – Get Device Profinet information
	    
	    // PN Coupler
	    "FC_GetDevicePN"(is_PNDeviceName := #is_PNPNCouplerDeviceName,
	                     ix_SimulationModeActive := #ix_SimulationModeActive,
	                     iqUDT_PND := #sUDT_PNCouplerPNDevice);
	    
	    
	    "FC_GetPNPortStatus"(ii_NumberOfPorts := #ci_NumberOfProfinetPorts,
	                         iUDT_DevicePNInfo := #sUDT_PNCouplerPNDevice,
	                         qa_PortFault => #sa_PNCouplerPortsStatus);
	    
	    // Singulator PN coupler   
	    
	    "FC_GetDevicePN"(is_PNDeviceName := #is_SingulatorCouplerDeviceName,
	                     ix_SimulationModeActive := #ix_SimulationModeActive,
	                     iqUDT_PND := #sUDT_SingulatorCouplerPNDevice);
	    
	    "FC_GetPNPortStatus"(ii_NumberOfPorts := #ci_NumberOfProfinetPorts,
	                         iUDT_DevicePNInfo := #sUDT_SingulatorCouplerPNDevice,
	                         qa_PortFault => #sa_SingulatorPortsStatus);
	    
	    // IO Module - Region 4
	    
	    //Scalance switch
	    
	    "FC_GetDevicePN"(is_PNDeviceName := #is_ScalanceSwitchName,
	                     ix_SimulationModeActive := #ix_SimulationModeActive,
	                     iqUDT_PND := #sUDT_ScalanceSwitchDevice);
	    
	    "FC_GetPNPortStatus"(ii_NumberOfPorts := #ci_NumberOfProfinetPorts,
	                         iUDT_DevicePNInfo := #sUDT_ScalanceSwitchDevice,
	                         qa_PortFault => #sa_ScalanceSwitchStatus);
	    
	END_REGION
	
	REGION 2 – Triggers
	    
	    // Rise trigger UPS status
	    #sR_Trig_UPS(CLK := #sUDT_HMIStatus.Specific.UPSSwitchTripped);
	    
	    // Rise trigger Fire alarm status
	    #sR_Trig_FireAlarm(CLK := #sUDT_HMIStatus.Specific.FireAlarmActive);
	    
	    #sR_Trig_24V_201T1(CLK := #sUDT_HMIStatus.Specific.PS_201T1_Tripped);
	    
	    #sR_Trig_CB_Tripped_101F4(CLK := #sUDT_HMIStatus.Specific."230VAC_CB101F4Tripped");
	    
	    #sR_Trig_CB_Tripped_102F1(CLK := #sUDT_HMIStatus.Specific."230VAC_CB102F1Tripped");
	    
	    #sR_Trig_CB_Tripped_201F1(CLK := #sUDT_HMIStatus.Specific."24VDC_CB201F1Tripped");
	    
	    #sR_Trig_CB_Tripped_205F5(CLK := #sUDT_HMIStatus.Specific."24VDC_CB205F5Tripped");
	    
	    #sR_Trig_ScalanceSwitchStatus(CLK := #sUDT_HMIStatus.Specific.ScalanceSwitchStatus);
	    
	    // Rise trigger PN/PN coupler status
	    #sR_Trig_PNCoupler(CLK := #sUDT_HMIStatus.Specific."PN_PN_MSP_PNSlaveNotOnline" OR #sUDT_HMIStatus.Specific."PN_PN_MSP_PNSlaveError");
	    
	    // Rise trigger Singulator coupler status
	    #sR_Trig_ProSoftCoupler(CLK := #sUDT_HMIStatus.Specific.Singulator_PNSlaveNotOnline OR #sUDT_HMIStatus.Specific.Singulator_PNSlaveError);
	    
	    // Rise trigger Scalance switch status
	    #sR_Trig_ScalanceSwitch(CLK := #sUDT_HMIStatus.Specific.ScalanceSwitchPNSlaveNotOnline OR #sUDT_HMIStatus.Specific.ScalanceSwitchPNSlaveError);
	    
	    // rising trigger main rack module status
	    #sR_Trig_MainRackModule(CLK := #sUDT_HMIStatus.Specific.RackSlotError[0]);
	    
	END_REGION
	
	REGION 3 – Reset error   
	    // All faults are reset when the reset input is true
	    
	    IF #iqUDT_EquipmentControl.Command.Reset
	    THEN
	        #sUDT_HMIStatus.Specific.ScalanceSwitchStatus := FALSE;
	        #sUDT_HMIStatus.Specific.PS_201T1_Tripped := FALSE;
	        #sUDT_HMIStatus.Specific."230VAC_CB101F4Tripped" := FALSE;
	        #sUDT_HMIStatus.Specific."230VAC_CB102F1Tripped" := FALSE;
	        #sUDT_HMIStatus.Specific."24VDC_CB201F1Tripped" := FALSE;
	        #sUDT_HMIStatus.Specific."24VDC_CB205F5Tripped" := FALSE;
	        #sUDT_HMIStatus.Specific.FireAlarmActive := FALSE;
	        #sUDT_HMIStatus.Specific.UPSSwitchTripped := FALSE;
	        #sUDT_HMIStatus.Specific."PN_PN_MSP_PNSlaveNotOnline" := FALSE;
	        #sUDT_HMIStatus.Specific."PN_PN_MSP_PNSlaveError" := FALSE;
	        #sUDT_HMIStatus.Specific."PN_PN_MSP_PNSlaveWarning" := FALSE;
	        #sUDT_HMIStatus.Specific.ScalanceSwitchPNSlaveError := FALSE;
	        #sUDT_HMIStatus.Specific.ScalanceSwitchPNSlaveNotOnline := FALSE;
	        #sUDT_HMIStatus.Specific.ScalanceSwitchPNSlaveWarning := FALSE;
	        #sUDT_HMIStatus.Specific.Singulator_PNSlaveNotOnline := FALSE;
	        #sUDT_HMIStatus.Specific.Singulator_PNSlaveError := FALSE;
	        #sUDT_HMIStatus.Specific.Singulator_PNSlaveWarning := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 – Master control panel remote input output
	    
	    #sFB_MasterControlPanelRIO(ix_24VOk := TRUE,
	                               ix_SimulationModeActive := #ix_SimulationModeActive,
	                               is_ET200spPNDeviceName := #is_IOModulePNDeviceName,
	                               qUDT_HMIStatus => #sUDT_MasterControlPanelRIOHMIStatus,
	                               qUDT_Status => #sUDT_MasterControlPanelRIOStatus,
	                               iqUDT_EquipmentControl := #iqUDT_EquipmentControl,
	                               iqUDT_Statistics := #sUDT_RIOStatistics);
	    
	    #sUDT_HMIStatus.Specific.IOModuleSlotError := #sUDT_MasterControlPanelRIOHMIStatus.Specific.ET200sp_ErrorModule;
	    
	    #sUDT_HMIStatus.Specific.IOModule_PNSlaveError := #sUDT_MasterControlPanelRIOHMIStatus.Specific.PNSlaveError;
	    
	    #sUDT_HMIStatus.Specific.IOModule_PNSlaveNotOnline := false;// #s_UDT_MCP_RIO_HMIStatus.Specific.PNSlaveNotOnline;
	    
	    #sUDT_HMIStatus.Specific.IOModule_PNSlaveWarning := #sUDT_MasterControlPanelRIOHMIStatus.Specific.PNSlaveWarning;
	    
	    #iqUDT_Statistics.IOModuleCouplerFault := #sUDT_RIOStatistics.PNSlaveError;
	    
	END_REGION
	
	REGION 5 – Scan request
	    // Start scan when request from diagnostic OB, First PLC cycle or External scan request
	    IF ("DB_Memory".ScanMainRack
	        OR "DB_Memory".FirstScan
	        OR #ix_ExternalScan)
	    THEN
	        #sx_RackCheck := TRUE;
	        "DB_Memory".ScanMainRack := FALSE;
	    END_IF;
	    
	    //Set the profinet scan when the error on the PLC occour
	    IF #sR_Trig_MainRackModule.Q
	    THEN
	        "DB_Memory".ScanProfinet := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 6 – Modules states update 
	    
	    // When in the fault/diagnostic OB 82,83,86 the bit is set, the function activates
	    IF #sx_RackCheck
	    THEN
	        
	        REGION 6.1 - Check racksize
	            // limiting the racksize between 4 and 31 positions
	            #ti_Racksize := #ii_Racksize;
	            IF #ti_Racksize > #ci_RackMaximumSize
	            THEN
	                #ti_Racksize := #ci_RackMaximumSize;
	            END_IF;
	            IF #ti_Racksize < #ci_RackMinimumSize
	            THEN
	                #ti_Racksize := #ci_RackMinimumSize;
	            END_IF;
	        END_REGION
	        
	        REGION 6.2 - Get the module from the io system
	            
	            // Get the module state from the mainrack  
	            #sa_Status.ErrorCode.ModuleState := ModuleStates(LADDR := #cui_LADDR,
	                                                             MODE := #cui_ConfiguredDevicesMode,
	                                                             STATE := #ts_Configured);
	            
	            #sa_Status.ErrorCode.ModuleState := ModuleStates(LADDR := #cui_LADDR,
	                                                             MODE := #cui_ExistingDevicesMode,
	                                                             STATE := #ts_Exist);
	            
	            #sa_Status.ErrorCode.ModuleState := ModuleStates(LADDR := #cui_LADDR,
	                                                             MODE := #cui_DevicesErrorMode,
	                                                             STATE := #ts_Error);
	        END_REGION
	        
	        REGION 6.3 - Set the error
	            // A loop operating on all modules if configured for the selected racksize
	            // If a device is configured and not existing or in error, the error bit is set
	            FOR #ti_ModuleNr := 0 TO #ti_Racksize
	            DO
	                IF (#ts_Configured[#ti_ModuleNr])
	                    AND ((NOT #ts_Exist[#ti_ModuleNr])
	                    OR (#ts_Error[#ti_ModuleNr]))
	                THEN
	                    #sUDT_HMIStatus.Specific.RackSlotError[#ti_ModuleNr] := TRUE;
	                ELSE
	                    IF #iqUDT_EquipmentControl.Command.Reset
	                    THEN
	                        #sUDT_HMIStatus.Specific.RackSlotError[#ti_ModuleNr] := FALSE;
	                    END_IF;
	                END_IF;
	            END_FOR;
	        END_REGION
	        
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Reset the Rackcheck
	    
	    // If the main module is not signalling an error the rackcheck is reset
	    IF #sx_RackCheck AND NOT #sUDT_HMIStatus.Specific.RackSlotError[0]
	    THEN
	        #sx_RackCheck := False;
	    END_IF;
	END_REGION
	
	REGION 8 - Faults monitoring 
	    
	    // Hardware will only be available after the delay, so the device has time for the initialization
	    #sFB_TimerOnOffDelayCheckSupply(iudi_OnDelayTime := #ci_PowerSupplyDelayTime,
	                                    ix_SignalToDelay := #ix_CBTripped205F5,//   //#ix_24VDCOk,
	                                    qx_DelayedSignal => #sx_PowerOk);
	    
	    // check if PN PN coupler is online
	    IF (NOT "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNCouplerPNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNCouplerPNDevice.PNDeviceNumber].DeviceState.Exist
	        OR NOT #sUDT_PNCouplerPNDevice.PNDeviceFound)
	        AND #sx_PowerOk
	        AND NOT #ix_SimulationModeActive
	    THEN
	        #sUDT_HMIStatus.Specific."PN_PN_MSP_PNSlaveNotOnline" := TRUE;
	    END_IF;
	    
	    // Check if PN ports are healthy 
	    IF #sa_PNCouplerPortsStatus[1] XOR #sa_PNCouplerPortsStatus[2] THEN
	        #sUDT_HMIStatus.Specific."PN_PN_MSP_PNSlaveWarning" := TRUE;
	    END_IF;
	    
	    
	    // check if PN PN coupler has an error
	    IF "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNCouplerPNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNCouplerPNDevice.PNDeviceNumber].DeviceState.Error
	        AND #sx_PowerOk
	        AND NOT #ix_SimulationModeActive
	        AND NOT #sUDT_HMIStatus.Specific."PN_PN_MSP_PNSlaveWarning"
	    THEN
	        #sUDT_HMIStatus.Specific."PN_PN_MSP_PNSlaveError" := TRUE;
	    END_IF;
	    
	    // check if Scalance Switch is online
	    IF (NOT "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_ScalanceSwitchDevice.PNNetworknumber].DeviceStatus[#sUDT_ScalanceSwitchDevice.PNDeviceNumber].DeviceState.Exist
	        OR NOT #sUDT_ScalanceSwitchDevice.PNDeviceFound)
	        AND #sx_PowerOk
	        AND NOT #ix_SimulationModeActive
	    THEN
	        #sUDT_HMIStatus.Specific.ScalanceSwitchPNSlaveNotOnline := TRUE;
	    END_IF;
	    
	    // Check if Scalance Switch ports are healthy 
	    IF #sa_ScalanceSwitchStatus[1] XOR #sa_ScalanceSwitchStatus[2] THEN
	        #sUDT_HMIStatus.Specific."PN_PN_MSP_PNSlaveWarning" := TRUE;
	    END_IF;
	    
	    
	    // check if Scalance Switch has an error
	    IF "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_ScalanceSwitchDevice.PNNetworknumber].DeviceStatus[#sUDT_ScalanceSwitchDevice.PNDeviceNumber].DeviceState.Error
	        AND #sx_PowerOk
	        AND NOT #ix_SimulationModeActive
	        AND NOT #sUDT_HMIStatus.Specific.ScalanceSwitchPNSlaveWarning
	    THEN
	        #sUDT_HMIStatus.Specific.ScalanceSwitchPNSlaveError := TRUE;
	    END_IF;
	    
	    // check if Singulator coupler is online
	    IF (NOT "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_SingulatorCouplerPNDevice.PNNetworknumber].DeviceStatus[#sUDT_SingulatorCouplerPNDevice.PNDeviceNumber].DeviceState.Exist
	        OR NOT #sUDT_SingulatorCouplerPNDevice.PNDeviceFound)
	        AND #sx_PowerOk
	        AND NOT #ix_SimulationModeActive
	        AND #ix_SingulatorCouplerAvailable
	    THEN
	        #sUDT_HMIStatus.Specific.Singulator_PNSlaveNotOnline := TRUE;
	    END_IF;
	    
	    // Check if Singulator coupler ports are healthy 
	    IF #sa_SingulatorPortsStatus[1] XOR #sa_SingulatorPortsStatus[2] THEN
	        #sUDT_HMIStatus.Specific.Singulator_PNSlaveWarning := TRUE;
	    END_IF;
	    
	    // check if Singulator coupler has an error
	    IF "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_SingulatorCouplerPNDevice.PNNetworknumber].DeviceStatus[#sUDT_SingulatorCouplerPNDevice.PNDeviceNumber].DeviceState.Error
	        AND #ix_SingulatorCouplerAvailable
	        AND #sx_PowerOk
	        AND NOT #ix_SimulationModeActive
	    THEN
	        #sUDT_HMIStatus.Specific.Singulator_PNSlaveError := TRUE;
	    END_IF;
	    
	    IF NOT #ix_NoFireAlarmActive AND NOT #ix_SimulationModeActive
	    THEN
	        
	        #sUDT_HMIStatus.Specific.FireAlarmActive := TRUE;
	        
	    END_IF;
	    
	    // Unit power supply fault status is set when the input is high
	    
	    IF NOT #ix_UPSOk AND NOT #ix_SimulationModeActive
	    THEN
	        
	        #sUDT_HMIStatus.Specific.UPSSwitchTripped := TRUE;
	        
	    END_IF;
	    
	    IF NOT #ix_24V201T1 AND NOT #ix_SimulationModeActive
	    THEN
	        
	        #sUDT_HMIStatus.Specific.PS_201T1_Tripped := TRUE;
	        
	    END_IF;
	    
	    IF NOT #ix_CBTripped101F4 AND NOT #ix_SimulationModeActive
	    THEN
	        
	        #sUDT_HMIStatus.Specific."230VAC_CB101F4Tripped" := TRUE;
	        
	    END_IF;
	    
	    
	    IF NOT #ix_CBTripped102F1 AND NOT #ix_SimulationModeActive
	    THEN
	        
	        #sUDT_HMIStatus.Specific."230VAC_CB102F1Tripped" := TRUE;
	        
	    END_IF;
	    
	    IF NOT #ix_CBTripped201F1 AND NOT #ix_SimulationModeActive
	    THEN
	        
	        #sUDT_HMIStatus.Specific."24VDC_CB201F1Tripped" := TRUE;
	        
	    END_IF;
	    
	    IF NOT #ix_CBTripped205F5 AND NOT #ix_SimulationModeActive
	    THEN
	        
	        #sUDT_HMIStatus.Specific."24VDC_CB205F5Tripped" := TRUE;
	        
	    END_IF;
	    
	    IF NOT #ix_ScalanceSwitchStatus AND NOT #ix_SimulationModeActive
	    THEN
	        
	        #sUDT_HMIStatus.Specific.ScalanceSwitchStatus := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 9 - Statistics
	    
	    // Unit Power Supply fault statistics
	    
	    IF #sUDT_HMIStatus.Specific.UPSSwitchTripped
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.UPSSwitchTripped,
	                        ix_RTrigActivate := #sR_Trig_UPS.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.UPSFault);
	        
	    END_IF;
	    
	    
	    // 24 VDC Supply fault statistics
	    
	    IF #sUDT_HMIStatus.Specific.FireAlarmActive
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.FireAlarmActive,
	                        ix_RTrigActivate := #sR_Trig_FireAlarm.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.FireAlarm);
	        
	    END_IF;
	    
	    // PN/PN coupler fault statistics
	    
	    IF #sUDT_HMIStatus.Specific."PN_PN_MSP_PNSlaveNotOnline"
	        OR #sUDT_HMIStatus.Specific."PN_PN_MSP_PNSlaveError"
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific."PN_PN_MSP_PNSlaveNotOnline" OR #sUDT_HMIStatus.Specific."PN_PN_MSP_PNSlaveError",
	                        ix_RTrigActivate := #sR_Trig_PNCoupler.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics."PN/PNCouplerFault");
	        
	    END_IF;
	    
	    // ProSoft coupler fault statistics
	    
	    IF #sUDT_HMIStatus.Specific.Singulator_PNSlaveNotOnline
	        OR #sUDT_HMIStatus.Specific.Singulator_PNSlaveError
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.Singulator_PNSlaveNotOnline OR #sUDT_HMIStatus.Specific.Singulator_PNSlaveError,
	                        ix_RTrigActivate := #sR_Trig_ProSoftCoupler.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.SingulatorCouplerFault);
	        
	    END_IF;
	    
	    // Scalance switch fault statistics
	    
	    IF #sUDT_HMIStatus.Specific.ScalanceSwitchPNSlaveNotOnline
	        OR #sUDT_HMIStatus.Specific.ScalanceSwitchPNSlaveError
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.ScalanceSwitchPNSlaveNotOnline OR #sUDT_HMIStatus.Specific.ScalanceSwitchPNSlaveError,
	                        ix_RTrigActivate := #sR_Trig_ScalanceSwitch.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.ScalanceSwitchFault);
	        
	    END_IF;
	    
	    // Main rack module fault statistics
	    
	    IF #sUDT_HMIStatus.Specific.RackSlotError[0]
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.RackSlotError[0],
	                        ix_RTrigActivate := #sR_Trig_MainRackModule.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.RackModuleFault);
	        
	    END_IF;
	    
	    
	    IF #sUDT_HMIStatus.Specific.PS_201T1_Tripped
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.PS_201T1_Tripped,
	                        ix_RTrigActivate := #sR_Trig_24V_201T1.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.PS_201T1_Tripped);
	        
	    END_IF;
	    
	    IF #sUDT_HMIStatus.Specific."230VAC_CB101F4Tripped"
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific."230VAC_CB101F4Tripped",
	                        ix_RTrigActivate := #sR_Trig_CB_Tripped_101F4.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics."230VAC_CB101F4Tripped");
	    END_IF;
	    
	    IF #sUDT_HMIStatus.Specific."230VAC_CB102F1Tripped"
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific."230VAC_CB102F1Tripped",
	                        ix_RTrigActivate := #sR_Trig_CB_Tripped_102F1.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics."230VAC_CB102F1Tripped");
	    END_IF;
	    
	    IF #sUDT_HMIStatus.Specific."24VDC_CB201F1Tripped"
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific."24VDC_CB201F1Tripped",
	                        ix_RTrigActivate := #sR_Trig_CB_Tripped_201F1.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics."24VDC_CB201F1Tripped");
	    END_IF;
	    
	    IF #sUDT_HMIStatus.Specific."24VDC_CB205F5Tripped"
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific."24VDC_CB205F5Tripped",
	                        ix_RTrigActivate := #sR_Trig_CB_Tripped_205F5.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics."24VDC_CB205F5Tripped");
	    END_IF;
	    
	    IF #sUDT_HMIStatus.Specific.ScalanceSwitchStatus
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.ScalanceSwitchStatus,
	                        ix_RTrigActivate := #sR_Trig_ScalanceSwitchStatus.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.ScalanceSwitchStatus);
	    END_IF;
	    
	    
	END_REGION
	
	REGION 10 - Status
	    
	    // Set common error to report 
	    #sUDT_CommonStatus.Error := #sUDT_HMIStatus.Specific.PS_201T1_Tripped
	    OR #sUDT_HMIStatus.Specific."230VAC_CB101F4Tripped"
	    OR #sUDT_HMIStatus.Specific."230VAC_CB102F1Tripped"
	    OR #sUDT_HMIStatus.Specific."24VDC_CB201F1Tripped"
	    OR #sUDT_HMIStatus.Specific."24VDC_CB205F5Tripped"
	    OR #sUDT_HMIStatus.Specific.ScalanceSwitchStatus
	    OR #sUDT_HMIStatus.Specific.FireAlarmActive
	    OR #sUDT_HMIStatus.Specific.UPSSwitchTripped
	    OR #sUDT_HMIStatus.Specific."PN_PN_MSP_PNSlaveNotOnline"
	    OR #sUDT_HMIStatus.Specific."PN_PN_MSP_PNSlaveError"
	    OR #sUDT_HMIStatus.Specific.Singulator_PNSlaveNotOnline
	    OR #sUDT_HMIStatus.Specific.Singulator_PNSlaveError
	    OR #sUDT_HMIStatus.Specific.ScalanceSwitchPNSlaveError
	    OR #sUDT_HMIStatus.Specific.ScalanceSwitchPNSlaveNotOnline
	    OR #sUDT_HMIStatus.Specific.IOModule_PNSlaveError
	    OR #sUDT_HMIStatus.Specific.IOModule_PNSlaveNotOnline
	    OR #sUDT_HMIStatus.Specific.RackSlotError[0];
	    
	    // HMI status update
	    IF #sUDT_CommonStatusOld <> #sUDT_CommonStatus                   // update on change
	    THEN
	        
	        // HMI status initialization
	        #sUDT_HMIStatus.Status := 0;
	        
	        
	        // HMI status calculation
	        IF #sUDT_HMIStatus.Specific."PN_PN_MSP_PNSlaveNotOnline"         // Hardware error
	            OR #sUDT_HMIStatus.Specific."PN_PN_MSP_PNSlaveError"
	            OR #sUDT_HMIStatus.Specific.Singulator_PNSlaveNotOnline
	            OR #sUDT_HMIStatus.Specific.Singulator_PNSlaveError
	            OR #sUDT_HMIStatus.Specific.IOModule_PNSlaveError
	            OR #sUDT_HMIStatus.Specific.IOModule_PNSlaveNotOnline
	            OR #sUDT_HMIStatus.Specific.ScalanceSwitchPNSlaveError
	            OR #sUDT_HMIStatus.Specific.ScalanceSwitchPNSlaveNotOnline
	            //  OR #s_UDT_HMIStatus.Specific.RackSlotError[0]
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Error;
	            
	        END_IF;
	        
	        
	        IF #sUDT_HMIStatus.Specific."230VAC_CB101F4Tripped"
	            OR #sUDT_HMIStatus.Specific."230VAC_CB102F1Tripped"
	            OR #sUDT_HMIStatus.Specific."24VDC_CB201F1Tripped"
	            OR #sUDT_HMIStatus.Specific."24VDC_CB205F5Tripped"
	            OR #sUDT_HMIStatus.Specific.PS_201T1_Tripped
	            OR #sUDT_HMIStatus.Specific.UPSSwitchTripped
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".CBError;
	            
	        END_IF;
	        
	        IF #sUDT_HMIStatus.Specific.FireAlarmActive                    // Fire alarm
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".FireAlarm;
	            
	        END_IF;
	        #sUDT_CommonStatusOld := #sUDT_CommonStatus;                  // Copy status to memory
	        #qUDT_Status := #sUDT_CommonStatus;                           // Copy status to output
	    END_IF;
	    
	    #qUDT_HMIStatus := #sUDT_HMIStatus;                           // Copy HMI status to output
	    
	END_REGION
	
	REGION 11 - Report to control block
	    
	    // Function to manage report between control block and conveyor block
	    
	    "FC_EquipmentReport"(iUDT_Status := #sUDT_CommonStatus,
	                         iqUDT_Control := #iqUDT_EquipmentControl);
	    
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION "FC_TPConveyorMapping" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 30
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_ConveyorStatus : "UDT_ConveyorStatus";
      iv_VfdStatus : Variant;
      iUDT_ConveyorInterface : "UDT_ConveyorInterface";
      iUDT_ConveyorConfiguration : "UDT_ConveyorConfiguration";
      is_ConveyorID : String;
   END_VAR

   VAR_OUTPUT 
      qUDT_TPConveyorStatus : "UDT_ConveyorStatus";
      qUDT_TPConveyorInterface : "UDT_ConveyorInterface";
      qUDT_TPCommandState : "UDT_ConveyorCommand";   // Actual state of conveyor commands in DB_HMICommands
      qUDT_TPConveyorConfiguration : "UDT_ConveyorConfiguration";
      qs_TPSelectedConveyorName : String;
   END_VAR

   VAR_IN_OUT 
      iqUDT_TPCommandButton : "UDT_TPManualControlButtons";
      iqUDT_ConveyorCommand : "UDT_ConveyorCommand";
      qUDT_TPVfdStatus : "UDT_VfdStatus";
   END_VAR

   VAR_TEMP 
      tUDT_VfdStatus : "UDT_VfdStatus";
      tUDT_Ai2Status : "UDT_AixPlcFull4McoStatus";
      temp_ret_val : Int;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	18/10/2021  | 1.0       | S.Theocharis  | first release MHS TIA 16
	20/10/2021  | 1.1       | S.Theocharis  | change udt vfd status to variant
	03/06/2022  | 1.2       | M.Krystek     | change MOVE_BLK_VARIANT parameters
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Command Start
	    
	    IF #iqUDT_TPCommandButton.ManualStart THEN
	        #iqUDT_ConveyorCommand.ManualStartStop := TRUE;
	        #iqUDT_TPCommandButton.ManualStart := False;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Command Stop
	    
	    IF #iqUDT_TPCommandButton.ManualStop THEN
	        #iqUDT_ConveyorCommand.ManualStartStop := FALSE;
	        #iqUDT_TPCommandButton.ManualStop := False;
	    END_IF;
	END_REGION
	
	REGION 3 - Command Nominal Speed
	    
	    IF #iqUDT_TPCommandButton.ManualFullSpeed THEN
	        #iqUDT_ConveyorCommand.ManualFullSpeed := TRUE;
	        #iqUDT_TPCommandButton.ManualFullSpeed := False;
	    END_IF;
	END_REGION
	
	REGION 4 - Command Low Speed
	    
	    IF #iqUDT_TPCommandButton.ManualLowSpeed THEN
	        #iqUDT_ConveyorCommand.ManualFullSpeed := FALSE;
	        #iqUDT_TPCommandButton.ManualLowSpeed := False;
	    END_IF;
	END_REGION
	
	REGION 5 - Command Reverse
	    
	    IF #iqUDT_TPCommandButton.ManualReverse THEN
	        #iqUDT_ConveyorCommand.Reverse := NOT #iqUDT_ConveyorCommand.Reverse;
	        #iqUDT_ConveyorCommand.ManualStartStop := FALSE; //Stop always to avoid on the fly reverse
	        #iqUDT_TPCommandButton.ManualReverse := False;
	    END_IF;
	END_REGION
	
	REGION 6 - Command jog
	    
	    #iqUDT_ConveyorCommand.ManualJog := #iqUDT_TPCommandButton.ManualJog;
	    
	    IF #iqUDT_TPCommandButton.ManualJog THEN
	        #iqUDT_ConveyorCommand.ManualStartStop := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Status
	    
	    #qUDT_TPCommandState := #iqUDT_ConveyorCommand;  //actual status of conveyor commands
	    
	    #qUDT_TPConveyorStatus := #iUDT_ConveyorStatus; //conveyor status
	    
	    //VFD status. Ignore Pulse roller
	    IF TypeOf(#iv_VfdStatus) = TypeOf(#tUDT_VfdStatus) THEN
	        
	        #temp_ret_val := MOVE_BLK_VARIANT(SRC := #iv_VfdStatus,
	                                          COUNT := 1,
	                                          SRC_INDEX := 0,
	                                          DEST_INDEX := 0,
	                                          DEST => #qUDT_TPVfdStatus);
	        
	    ELSE
	        #tUDT_VfdStatus.ErrorCode := #tUDT_VfdStatus.SubErrorCode := 0;
	        #qUDT_TPVfdStatus := #tUDT_VfdStatus;
	        
	    END_IF;
	    
	    //#q_TP_VFDStatus := #i_VFDStatus;
	    
	    #qUDT_TPConveyorInterface := #iUDT_ConveyorInterface; //conveyor interface
	    
	    #qs_TPSelectedConveyorName := #is_ConveyorID; //conveyor ID
	    
	    #qUDT_TPConveyorConfiguration.Bi_Directional_Enable := #iUDT_ConveyorConfiguration.Bi_Directional_Enable; //read only bi directional enable bit from configuration
	    
	    
	END_REGION
	
END_FUNCTION

FUNCTION_BLOCK "FB_Induct"
TITLE = FB_Induct
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : Equipment
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 14
// END_ATTRIBUTES
//Function block to control inducting the parcels to a merge conveyor
   VAR_INPUT 
      iUDT_InductConfig { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_InductConfiguration";   //       Induct configuration parameters
      iUDT_MergeGenConfig { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_MergeGeneratorConfig";   //       Merge generator configuration parameters
      iUDT_MergeConvConfig { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorCommonConfiguration";   //       Merge conveyor common configuration parameters
      iUDT_InductConvConfig { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorConfiguration";   //       Induct conveyor configuration parameters
      iUDT_InductConvCommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";
      idi_PECEoSDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //       Distance between photo eye and the end of conveyor [mm]
      ii_Gin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //       GIN from induct at photoeye position
      ix_SafetyOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //       Safety is ok
      ix_inductEnable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;   //      Enable the induct to make request
      ix_TrackingClear { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Tracking area is clear of parcels
   END_VAR

   VAR_OUTPUT 
      qx_ExternalRequestDieBack { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External request dieback
      qx_EnableAutoRecovey { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request to enable auto recovery
   END_VAR

   VAR_IN_OUT 
      iqs_TrackingData : Array[*] of Int;   //       Tracking data
      iqUDT_Merge : "UDT_Merge";   //       Gapgeneration data
      iqUDT_MergeInterface : "UDT_ConveyorInterface";
      iqUDT_InductInterface : "UDT_ConveyorInterface";
      iqUDT_HandShake : "UDT_ConveyorHandshake";
      iqa_ActualTimeData : Struct
         Offset : Int;
         Max_number_of_records : Int;
         Data {InstructionName := 'DTL'; LibVersion := '1.0'} : Array[0..99] of DTL;
      END_STRUCT;
   END_VAR

   VAR 
      sR_TRIG_Displacement {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //       Signal rising edge displacement changed
      sR_TRIG_SetDelay {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //       Signal rising edge of parcel entering
      sR_TRIG_TIP {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sR_TRIG_Enable {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising Edge of  Induct Enable signal
      sF_TRIG_sx_Parcel {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling Trigger of sx_Parcel
      sdi_DelayReactivateReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //       Actual counter delaying the reactivation request
      sdi_RunningEmpty { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //       Actual counter distance running empty
      si_RequestLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //       Calculated length to be requested
      si_GINlength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //       Length found in GIN DN or set beacuse of invalid length
      si_Gaplength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //       Length for this parcel
      si_ArrayLengthFlexGap { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //       Size of the flexGapsize
      si_ArrayLengthTracking { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //       Size of the tracking array
      si_ArrayLengthFIFO { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //       Size of the FIFO
      si_DistanceToEnd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //       Parcels distance to end of induct conveyor
      si_InductPoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //       Calculated induct point
      si_StartSearch { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //       Value declaring the start of the search area
      si_EndSearch { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //       Value declaring the end of the search area
      si_LoopCountFlexgap { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //       Loopcounter searching in configuration for a match for the parcellength
      si_LoopCountGapSearch { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //       Loopcounter searching in Trackingdata for a gap
      si_LoopCountCodeSearch { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //       Loopcounter searching for code -100
      si_LoopCountSyncSearch { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //       Loopcounter searching for code -100
      si_LoopCountFIFOSearch { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //       Loopcounter searching FIFO for request to remove
      si_LoopCountWriteGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //       Loopcounter to write the GIN for the length of the parcel
      si_LastGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //       Last processed GIN
      si_Flexgap { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //       Found flexible gapsize [cm]
      si_PosDataInSearchArea { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //       Length to wait to search for a gap
      si_WritePosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //       Position to write to in tracking
      si_Syncdifference { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //       Difference in positions pec and tracking
      si_SyncDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //       Distance to perform the synchronisation in
      si_MergeRunLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //     Distance the merge conveyor has run when Inudct is waiting
      si_DelayDiebackLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //     length Run before applying die back [cm]
      si_TrackingPointer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Tracking poitner to search in the tracking
      sx_Sync { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //       Code search to synchronise
      sx_ConfigError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //       Error in the configuration
      sx_FindLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //       Find the length of the new parcel
      sx_Parcel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //       The parcel is present an not yet handled completely
      sx_GapRequested { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //       The request is done for the latest parcel
      sx_SearchGapInTracking { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //       True = Search for space in tracking to induct without merge generation
      sx_LastCodeNeg { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //       True = Last found code was a negative one
      sx_FreeGapAvailable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //       There is a free space found, big enough to insert the parcel
      sx_ValidWindowCodeFound { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //       There is a valid window code found
      sx_CodeAtposition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_InductEnable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //       The parcel is enabled to induct
      sx_DiebackInductConveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //       Memory to stop the induct conveyor
      sx_Hold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //       Hold inducting
      sx_Active { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_EnableAutoRecovery { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //     Enable Auto Recovery for Induct
      sx_RecoveryRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR CONSTANT 
      ci_SearchArea : Int := 3;
   END_VAR


BEGIN
	(* 
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/09/2019  | 1.0       | F.Baten       | first release TIA 15.1
	31/10/2019  | 1.1       | F.Baten       | qi_SpeedSetpoint changed to int because of conveyor interface change
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	07/01/2020  | 3.1       | F.Baten       | Changed RequestInFifo to be handshaking
	                                        | Merged region 4.3 and 4.4
	09/01/2020  | 3.2       | F.Baten       | Removed speed calculation
	14/01/2020  | 3.3       | F.Baten       | Removed global FIFO full signal as it was not generated and made it local
	14/01/2020  | 3.4       | F.Baten       | Changed displacement detection equal to 0 and not to be 1 as it can also be bigger
	            | 3.5       |               | Renamed ii_PEC_EoSDistance to idi_PEC_EoSDistance
	15/01/2020  | 3.6       | L.Klar        | GIN record structure updated, parcel length remapped
	23/01/2020  | 3.7       | F.Baten       | Added reset when parcel is at end of conveyor but for some reason not detected
	                                          Modified dieback: alsways goto dieback when parcel is handled
	18/02/2020  | 3.8       | F.Baten       | Modified "Search 1: Gap '0'" , added +1 to wait to search again. 
	15/10/2020  | 3.9       | F.Baten       | Reqactivation request: added if active to keep active
	                                          removed displacement check out of search
	20/05/2021  | 3.10      | M.Singh       | Enabled Auto Recovery based on the displacemt on Merge
	20/04/2022  | 3.11      | M.Piela       | Added Auto recovery output
	24/05/2022  | 3.12      | M.Roijen      | Changed FOR loop region 5.2 copy gin to tracking (add -1).
	22/07/2022  | 3.13      | M.Piela       | Reset the sx_Active and set dieback induct on falling edge of sx_Parcel instead of rising edge of TIP. 
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5  
	*)
	
	REGION 1 - New GIN received
	    // When the new GIN is received:
	    // - first save the GIN and set/reset statuses
	    // - calculate the requested length for this parcel
	    // - requeset a gap for this parcel
	    
	    REGION 1.1 - New gin received is NOT equal TO '0' AND NOT equal TO last gin
	        //#s_R_TRIG_TIP(CLK := #iq_UDT_HandShake.TIP);
	        // IF #ii_Gin <> 0 AND #ii_Gin <> #si_LastGIN AND NOT #iq_UDT_HandShake.TIP AND NOT #s_F_TRIG_TIP.Q
	        
	        IF #ii_Gin <> 0 AND #ii_Gin <> #si_LastGIN AND #ix_inductEnable
	        THEN
	            #sx_FindLength := FALSE;                                                    // To set length for a flexible gap
	            #sx_GapRequested := FALSE;                                                  // To initiate length calculation for gap and request the gap to FIFO
	            #sx_DiebackInductConveyor := TRUE;                                             // Activate dieback to stop the conveyor while waiting on a gap
	            #sx_Sync := FALSE;                                                          // Sync speed is not calculated 
	            #sx_Parcel := TRUE;                                                         // Activate the induct search
	            #sx_Active := TRUE;                                                         // The parcel is not transferred to the next conveyor 
	            #si_LastGIN := #ii_Gin;                                                     // Memorise
	            #si_DistanceToEnd := DINT_TO_INT(#idi_PECEoSDistance) / 10;                // Actual distance to end (in tracking array units) 
	            #si_GINlength := DINT_TO_INT("DB_GIN".GIN[#si_LastGIN].General.Length);     // set length
	            IF #si_GINlength = 0
	            THEN
	                #si_GINlength := #iUDT_InductConfig.MaxParcelSize / 10;
	            END_IF;
	            
	            IF #sx_RecoveryRequest
	            THEN
	                
	                #si_DistanceToEnd := #iUDT_InductConfig.ParcelStopPositionAutoRecovery;                                                     // Actual distance to end (in tracking array units) 
	                #si_GINlength := (#iUDT_InductConfig.MaxParcelSize / 10) + #iUDT_InductConfig.RecoveryAdditionalGap;
	                #sx_RecoveryRequest := FALSE;
	            END_IF;
	            
	        END_IF;
	        
	        // There is a parcel on the inductconveyor but it had no GIN (not even UFO) 
	        IF (#iqUDT_HandShake.RTS                                                       // If Induct is ready to Send  
	            OR #iUDT_InductConvCommonStatus.Dieback)                                   // Or is in die back 
	            AND NOT #sx_Active                                                          // And Induct is not active
	            AND #ix_inductEnable
	        THEN
	            #si_MergeRunLength := #si_MergeRunLength - #iqUDT_MergeInterface.Displacement;
	        ELSE
	            #si_MergeRunLength := #iUDT_InductConfig.DistanceRunBeforeAutoRecovery;
	        END_IF;
	        
	        #sx_EnableAutoRecovery := FALSE;
	        
	        IF #si_MergeRunLength <= 0
	        THEN
	            #sx_EnableAutoRecovery := True;
	            #si_MergeRunLength := #iUDT_InductConfig.DistanceRunBeforeAutoRecovery;
	        END_IF;
	        
	        #sR_TRIG_Enable(CLK := #ix_inductEnable);
	        
	        IF #sx_EnableAutoRecovery                                                     // Make a new request to autorecover
	            OR (#sR_TRIG_Enable.Q
	            AND NOT #ix_TrackingClear)
	        THEN
	            #sx_FindLength := FALSE;                                                    // To set length for a flexible gap
	            #sx_GapRequested := FALSE;                                                  // To initiate length calculation for gap and request the gap to FIFO
	            #sx_DiebackInductConveyor := TRUE;                                             // Activate dieback to stop the conveyor while waiting on a gap
	            #sx_Sync := FALSE;                                                          // Sync speed is not calculated 
	            #sx_Parcel := TRUE;                                                         // Activate the induct search
	            #sx_Active := TRUE;                                                         // The parcel is not transferred to the next conveyor 
	            #si_LastGIN := -50;                                                         // Memorise
	            #si_DistanceToEnd := #iUDT_InductConfig.ParcelStopPositionAutoRecovery;                                                     // Actual distance to end (in tracking array units) 
	            #si_GINlength := (#iUDT_InductConfig.MaxParcelSize / 10) + #iUDT_InductConfig.RecoveryAdditionalGap;
	            #sx_RecoveryRequest := TRUE;
	            
	            
	            
	            // temp code 
	            #iqa_ActualTimeData.Data[#iqa_ActualTimeData.Offset] := "DB_Time".ActualTimeDTL;
	            #iqa_ActualTimeData.Offset := #iqa_ActualTimeData.Offset + 1;
	        END_IF;
	        
	        #qx_EnableAutoRecovey := #sx_EnableAutoRecovery;
	        
	        IF #iqa_ActualTimeData.Offset = #iqa_ActualTimeData.Max_number_of_records
	        THEN
	            #iqa_ActualTimeData.Offset := 1;
	        END_IF;
	        
	        
	    END_REGION
	    
	    REGION 1.2 - Calculate the required gap depending on the mode
	        CASE #iUDT_InductConfig.GapMode OF
	                
	            1:  // Gap is Head to head
	                #si_RequestLength := #iUDT_InductConfig.GapHeadToHead;
	                #si_Gaplength := #si_RequestLength - #si_GINlength;
	                #sx_FindLength := TRUE;                                                 // New GIN length is set 
	                
	            2:  // Gap is parcel length + tail to head (fixed)
	                #si_RequestLength := #si_GINlength + #iUDT_InductConfig.GapTailToHead;
	                #si_Gaplength := #iUDT_InductConfig.GapTailToHead;
	                #sx_FindLength := TRUE;                                                 // New GIN length is set
	                
	            3:  // Gap is parcel length + gap depending on length of parcel
	                IF NOT #sx_FindLength
	                THEN
	                    #si_ArrayLengthFlexGap := "FC_GetNrOfArrayEl"(#iUDT_InductConfig.FlexGap); // Determine size of search area 
	                    FOR #si_LoopCountFlexgap := 1 TO #si_ArrayLengthFlexGap BY 1 DO                   // Set the loopcounter
	                        #si_Flexgap := #iUDT_InductConfig.MinParcelSize / 10;      // set minimal gapsize
	                        IF #si_GINlength < #iUDT_InductConfig.FlexGap[#si_LoopCountFlexgap]."Maximal length"
	                        THEN
	                            #si_Flexgap := #iUDT_InductConfig.FlexGap[#si_LoopCountFlexgap].Gap;
	                            EXIT;
	                        END_IF;
	                    END_FOR;
	                    #sx_FindLength := TRUE;                                             // New GIN length is calculated    
	                END_IF;
	                #si_RequestLength := #si_GINlength + #si_Flexgap;
	                #si_Gaplength := #si_Flexgap;
	                ;
	                
	        END_CASE;
	    END_REGION
	    
	    REGION 1.3 - General
	        // When the transfer is finished set the induct to dieback
	        
	        // IF #s_R_TRIG_TIP.Q  AND NOT #sx_Parcel
	        IF #sF_TRIG_sx_Parcel.Q
	        THEN
	            //     #si_DelayDiebackLength := #i_UDT_InductConfig.MinParcelSize;
	            
	            // END_IF;
	            
	            // IF #si_DelayDiebackLength > 0
	            // THEN
	            //     #si_DelayDiebackLength := #si_DelayDiebackLength - #iq_UDT_InductInterface.Displacement;
	            // END_IF;
	            // IF #si_DelayDiebackLength <= 0
	            // THEN
	            #sx_DiebackInductConveyor := TRUE;                                             // Activate dieback to stop the conveyor while waiting on a gap
	            #sx_Active := FALSE;                                                            // The parcel is now transferred to the next conveyor 
	        END_IF;
	        //  #s_R_TRIG_TIP(CLK := #iq_UDT_HandShake.TIP);
	        #sF_TRIG_sx_Parcel(CLK := #sx_Parcel);
	        // When safety is not ok, load the run empty distance
	        IF NOT #ix_SafetyOk
	        THEN
	            #sdi_RunningEmpty := #iUDT_InductConfig.RunEmptyDistance;
	        END_IF;
	        
	        // Hold inducting functions while mergeconveyor runs empty
	        #sx_Hold := (#sdi_RunningEmpty <> 0);
	        
	        // Check every change of the merge conveyor's displacement
	        #sR_TRIG_Displacement(CLK := #iqUDT_MergeInterface.Displacement = 0);             // The merge conveyor has had displacement
	    END_REGION
	END_REGION
	
	REGION 2 - Request
	    REGION 2.1 - FIFO request
	        // request gap/window for induct
	        IF #sx_Parcel
	            AND NOT #sx_Hold                                                            // Holding all actions
	            AND NOT #sx_GapRequested                                                    // Gap is NOT requested 
	            AND NOT #iqUDT_Merge.RequestInFIFO[#iUDT_InductConfig.Induct_Number]      // Requeset is in FIFO
	            AND NOT #iqUDT_Merge.GenerationInactive                                    // Generation is active
	            AND NOT #iUDT_InductConfig.SearchOnly                                      // Only searching for a gap
	            AND NOT (#iqUDT_Merge.LastUsed = #iqUDT_Merge.MaxNumberofEntries)         // The FIFO is full
	        THEN
	            #iqUDT_Merge.LastUsed += 1;                                                // Increase 
	            #iqUDT_Merge.RequestInFIFO[#iUDT_InductConfig.Induct_Number] := TRUE;     // Memorise 
	            #iqUDT_Merge.FIFO[#iqUDT_Merge.LastUsed].InductNumber := #iUDT_InductConfig.Induct_Number;   // Write the induct number
	            #iqUDT_Merge.FIFO[#iqUDT_Merge.LastUsed].GapSize := DINT_TO_INT(#si_RequestLength);           // Write the requested length
	            #iqUDT_Merge.FIFO[#iqUDT_Merge.LastUsed].RemoveEntry := FALSE;                                // Reset remove bit
	            #sx_GapRequested := TRUE;                                                   // Gap is requested
	        END_IF;
	    END_REGION
	    
	    REGION 2.2 - Reactivation of merge generator block
	        // If not in searchmode, every time a parcel enters, the waiting distance is set 
	        IF NOT #iUDT_InductConfig.SearchOnly
	        THEN
	            #sR_TRIG_SetDelay(CLK := #sx_Parcel);
	        ELSE
	            #sR_TRIG_SetDelay.Q := FALSE;
	        END_IF;
	        
	        IF #sR_TRIG_SetDelay.Q
	        THEN
	            #sdi_DelayReactivateReq := #iUDT_InductConfig.ReactivationRequestDelay / 10;
	        END_IF;
	        
	        // Reactivation request merge generator block 
	        // In gapmode 3 the generator is not allowed to deactivate
	        #iqUDT_Merge.ReactivateReq :=
	        ((#sdi_DelayReactivateReq = 0)
	        AND #sx_Parcel
	        AND #iqUDT_Merge.GenerationInactive
	        AND NOT #iUDT_InductConfig.SearchOnly)
	        OR (#iUDT_InductConfig.GapMode = 3)
	        OR #iqUDT_Merge.ReactivateReq;
	        
	    END_REGION
	END_REGION
	
	REGION 3 - Displacement
	    
	    REGION 3.1 - Track induct point
	        IF #iqUDT_Merge.TrackingPointerForInduct[#iUDT_InductConfig.Induct_Number] > 0
	        THEN
	            #iqUDT_Merge.TrackingPointerForInduct[#iUDT_InductConfig.Induct_Number] -= #iqUDT_MergeInterface.Displacement;
	            IF #iqUDT_Merge.TrackingPointerForInduct[#iUDT_InductConfig.Induct_Number] < 0                                              // check if the value does not go negative
	            THEN
	                #iqUDT_Merge.TrackingPointerForInduct[#iUDT_InductConfig.Induct_Number] := 0;
	            END_IF;
	        END_IF;
	    END_REGION
	    
	    REGION 3.2 - Wait distance
	        // If a value is found during the search for an empty position, the position of the tracking is saved. 
	        // This value is decreased by displacement to wait for the next time the tracking should be searched again.
	        IF #si_PosDataInSearchArea > 0
	        THEN
	            #si_PosDataInSearchArea -= #iqUDT_MergeInterface.Displacement;
	            IF #si_PosDataInSearchArea < 0                                              // check if the value does not go negative
	            THEN
	                #si_PosDataInSearchArea := 0;
	            END_IF;
	        END_IF;
	        
	        // The parcel is waiting to be inducted
	        IF #sdi_DelayReactivateReq > 0 AND NOT #sx_Hold
	        THEN
	            #sdi_DelayReactivateReq -= #iqUDT_MergeInterface.Displacement;
	            IF #sdi_DelayReactivateReq < 0                                              // check if the value does not go negative
	            THEN
	                #sdi_DelayReactivateReq := 0;
	            END_IF;
	        END_IF;
	        
	        // the distance to the end of the induct conveyor, the parcel travelling on the induct conveyor
	        IF #si_DistanceToEnd > 0 // AND #iq_UDT_InductInterface.RunFwd
	        THEN
	            #si_DistanceToEnd -= #iqUDT_InductInterface.Displacement;
	            IF #si_DistanceToEnd < 0                                                    // check if the value does not go negative
	            THEN
	                #si_DistanceToEnd := 0;
	            END_IF;
	        END_IF;
	        
	        // the distance to run empty      
	        IF #sdi_RunningEmpty > 0
	        THEN
	            #sdi_RunningEmpty -= #iqUDT_MergeInterface.Displacement;
	            IF #sdi_RunningEmpty < 0                                                    // check if the value does not go negative
	            THEN
	                #sdi_RunningEmpty := 0;
	            END_IF;
	        END_IF;
	    END_REGION
	END_REGION
	
	REGION 4 - Search position
	    REGION 4.1 - General
	        // When the generator is not active and there is no active request
	        // search for gap which is completely empty only when generator is switched off or the mode is search only
	        #sx_SearchGapInTracking := #iqUDT_Merge.GenerationInactive
	        OR #iUDT_InductConfig.SearchOnly;
	        
	        // set the Induct position to cm and a moving box while searching is a moving inductpoint
	        #si_InductPoint := (#iUDT_InductConfig.Induct_Position / 10);//- ((DINT_TO_INT(#idi_PEC_EoSDistance) / 10) - #si_DistanceToEnd);
	        // #si_InductPoint := (#i_UDT_InductConfig.Induct_Position / 10) - ((DINT_TO_INT(#idi_PEC_EoSDistance) / 10));
	        // In mode 3 the gap in front of the parcel is determined by the size of the parcel, this means the gap is leading. This is needed for some devices such as weighing scales.
	        // To get the gap in front of the parcel, the point of detecting the requested code is delayed by the gapsize.
	        // When the parcel starts now, it should be the length of the gap after the detected code. When writing in tracking the GIN is written aligned with the parcel, in the back of the window. 
	        // So, it moves the inductionpoint forwards in the tracking (downstream) with the parcels Flexgap.
	        
	        CASE #iUDT_InductConfig.GapMode OF
	            3:
	                #si_InductPoint -= #si_Flexgap;
	        END_CASE;
	        
	    END_REGION
	    
	    REGION 4.2 - Search 1: Gap '0'  
	        // 1: Search for a gap (tracking is filled with '0')
	        // When a value is found in the tracking, we do not have to search again until that value has passed.
	        // 
	        // search from  :  Induct position forward (gaptailtohead) because the last parcel can just have passed the position
	        // to           :  induct position + length of the parcel and its gap tail to next head
	        // 
	        IF #sx_Parcel                                                                   // A parcel is present
	            //    AND #s_R_TRIG_Displacement.Q                                                // There was a displacement
	            AND #si_PosDataInSearchArea = 0                                             // No wait length
	            AND #sx_SearchGapInTracking                                                 // Search for empty gap is activated
	            AND NOT #sx_Hold                                                            // merge conveyor is available 
	        THEN
	            #si_StartSearch := (#si_InductPoint - #iUDT_InductConfig.GapTailToHead);
	            #si_EndSearch := (#si_InductPoint + DINT_TO_INT(#si_RequestLength));
	            FOR #si_LoopCountGapSearch := #si_StartSearch TO #si_EndSearch BY 1 DO
	                
	                IF (#iqs_TrackingData[#si_LoopCountGapSearch] <> 0)                       // There is a value in the tracking area
	                THEN
	                    IF #iqs_TrackingData[#si_LoopCountGapSearch] < 0                      // the value was a negative value so wait for that to pass
	                    THEN
	                        #si_PosDataInSearchArea := #si_LoopCountGapSearch - #si_StartSearch + 1; // Save the distance added by 1 to wait to search again on the next position  
	                        EXIT;
	                    END_IF;
	                    
	                    IF #iqs_TrackingData[#si_LoopCountGapSearch] > 0                      // The value is positive: GIN
	                    THEN
	                        #si_PosDataInSearchArea := #si_LoopCountGapSearch - #si_StartSearch + 1;  // As long as the GIN is found the wait distance is increased 
	                    END_IF;
	                END_IF;
	            END_FOR;
	            
	            IF #si_PosDataInSearchArea = 0                                          // memory is empty after search
	            THEN
	                #sx_FreeGapAvailable := True;                                       // There is a gap, large enough to put the parcel in
	                #si_WritePosition := #si_InductPoint;
	            END_IF;
	        END_IF;
	    END_REGION
	    
	    
	    
	    REGION 4.3 - Search 2: code -100, -10(x) or -200-
	        IF #sx_Parcel                                                               // A parcel is present
	            //       AND #s_R_TRIG_Displacement.Q                                            // There was a displacement          
	            AND NOT #sx_SearchGapInTracking                                         // Search for empty gap is not activated
	            AND NOT #sx_Hold                                                        // merge conveyor is available 
	        THEN
	            // 2: search for the code -100 around the induct position within search area, displacement can be more than 1
	            //    search for the code -200- , code (-)200 + size of the gap . This was a gap requested but not used, the value over 200 indicates the size 
	            
	            #sx_ValidWindowCodeFound := FALSE;                                      // reset the memory
	            FOR #si_LoopCountCodeSearch := #si_InductPoint TO (#si_InductPoint + #ci_SearchArea) BY 1 DO
	                
	                IF (#iqs_TrackingData[#si_LoopCountCodeSearch] = -100)                    // If the value is -100  
	                    OR (#iqs_TrackingData[#si_LoopCountCodeSearch] = (-100 - (#iUDT_InductConfig.Induct_Number)))
	                THEN
	                    #sx_ValidWindowCodeFound := TRUE;                               // Set the memory 
	                    #si_WritePosition := #si_LoopCountCodeSearch;                         // save the position to write to
	                    EXIT;                                                           // Stop searchloop
	                    
	                ELSIF (#iqs_TrackingData[#si_LoopCountCodeSearch] <= -200)               // If the value is less than -200 (a not used gap)
	                    AND ((#iqs_TrackingData[#si_LoopCountCodeSearch] + 200) * -1) > #si_RequestLength // The length of this gap is bigger than the one which is needed
	                THEN
	                    #sx_ValidWindowCodeFound := TRUE;                               // Set the memory 
	                    #si_WritePosition := #si_LoopCountCodeSearch;                         // save the position to write to
	                    EXIT;                                                           // Stop searchloop
	                END_IF;
	            END_FOR;
	        END_IF;
	    END_REGION
	    
	END_REGION
	
	REGION 5 - Do induct
	    
	    // enable induct
	    #sx_InductEnable :=
	    #sx_FreeGapAvailable                                                            // There is a gap, large enough to put the parcel in
	    OR #sx_ValidWindowCodeFound;                                                    // A valid induct code is found
	    
	    IF #sx_Parcel AND #sx_InductEnable
	    THEN
	        
	        // check if position can be written in tracking array
	        #si_ArrayLengthTracking := "FC_GetNrOfArrayEl"(#iqs_TrackingData);          // Determine size of search area 
	        #sx_ConfigError := (#si_WritePosition + #si_RequestLength) > #si_ArrayLengthTracking;
	        #si_DistanceToEnd := 0;                                                     // Release conveyors nominal speed
	        
	        REGION 5.1 - Update FIFO      
	            // If the RequestIsInFIFO is still true, it  means the merge generator did not handle this request yet.
	            // Now the FIFO is searched for the induct number.
	            // On this entry the bit remove is set and also the Remove hanshake is set to indicate to the merge generator an entry has to be removed
	            
	            IF #iqUDT_Merge.RequestInFIFO[#iUDT_InductConfig.Induct_Number]
	            THEN
	                #si_ArrayLengthFIFO := "FC_GetNrOfArrayEl"(#iqUDT_Merge.FIFO);     // Determine size of search area 
	                FOR #si_LoopCountFIFOSearch := 0 TO (#si_ArrayLengthFIFO - 1) BY 1 DO
	                    IF #iqUDT_Merge.FIFO[#si_LoopCountFIFOSearch].InductNumber = #iUDT_InductConfig.Induct_Number
	                    THEN
	                        #iqUDT_Merge.FIFO[#si_LoopCountFIFOSearch].RemoveEntry := TRUE;
	                        #iqUDT_Merge.Remove := TRUE;
	                        EXIT;
	                    END_IF;
	                END_FOR;
	                #iqUDT_Merge.RequestInFIFO[#iUDT_InductConfig.Induct_Number] := False;
	            END_IF;
	        END_REGION
	        
	        REGION 5.2 - Copy GIN to tracking
	            // write GIN to merge conveyor tracking for the length of the parcel
	            FOR #si_LoopCountWriteGIN := #si_WritePosition TO (#si_WritePosition + #si_RequestLength - 1) BY 1 DO
	                #iqs_TrackingData[#si_LoopCountWriteGIN] := 0;
	            END_FOR;
	            CASE #iUDT_InductConfig.GapMode OF
	                1, 2: // write data leading
	                    FOR #si_LoopCountWriteGIN := #si_WritePosition TO (#si_WritePosition + #si_GINlength) BY 1 DO
	                        #iqs_TrackingData[#si_LoopCountWriteGIN] := #si_LastGIN;
	                    END_FOR;
	                3: // write gap leading    
	                    FOR #si_LoopCountWriteGIN := #si_WritePosition + #si_Gaplength TO (#si_WritePosition + #si_RequestLength) BY 1 DO
	                        #iqs_TrackingData[#si_LoopCountWriteGIN] := #si_LastGIN;
	                    END_FOR;
	            END_CASE;
	        END_REGION
	        
	        REGION 5.3 - Update request in tracking
	            // reset the request in the tracking if the request is there 
	            IF #iqs_TrackingData[#iqUDT_Merge.TrackingPointerForInduct[#iUDT_InductConfig.Induct_Number]] = (-100 - (#iUDT_InductConfig.Induct_Number))
	            THEN
	                CASE #iUDT_InductConfig.GapMode OF
	                    1:  // All gaps are head to headsize: reserved window code to be overwritted with fixed window code -100
	                        #iqs_TrackingData[#iqUDT_Merge.TrackingPointerForInduct[#iUDT_InductConfig.Induct_Number]] := -100;
	                    2, 3:  // Mark as NOT used (-200) AND give the gapsize as was requested
	                        #iqs_TrackingData[#iqUDT_Merge.TrackingPointerForInduct[#iUDT_InductConfig.Induct_Number]] := (-200 - #si_RequestLength);
	                END_CASE;
	            END_IF;
	        END_REGION
	        
	        REGION 5.4 - Reset data (end of cycle)
	            // reset the inducting data
	            #iqUDT_Merge.TrackingPointerForInduct[#iUDT_InductConfig.Induct_Number] := 0;     // reset the pointer, the parcel is handled
	            #sx_FreeGapAvailable := FALSE;                                              // There is a gap, large enough to put the parcel in
	            #sx_ValidWindowCodeFound := FALSE;                                          // A free induct code is found
	            #sx_DiebackInductConveyor := FALSE;                                            // Release the parcel
	            #sx_GapRequested := FALSE;                                                  // To initiate length calculation for gap and request the gap to FIFO
	            #sx_Parcel := FALSE;                                                        // The parcel is handled
	        END_REGION
	    END_IF;
	    
	    REGION 5.5 - Missed request, do again
	        IF #sx_GapRequested = TRUE                                                      // Gap is requested
	            AND NOT #iqUDT_Merge.RequestInFIFO[#iUDT_InductConfig.Induct_Number]      // No request in FIFO
	            AND #iqUDT_Merge.TrackingPointerForInduct[#iUDT_InductConfig.Induct_Number] = 0   // pointer elapsed
	        THEN
	            #sx_GapRequested := FALSE;                                                  // Reset the gap was requested and do request again
	        END_IF;
	    END_REGION
	END_REGION
	
	REGION 6 - Conveyor
	    
	    // Stop the induct conveyor 
	    #qx_ExternalRequestDieBack := #sx_DiebackInductConveyor;
	END_REGION
	
	//#iq_UDT_Merge.ReactivateReq := true;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_AirPressureFault"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 3
// END_ATTRIBUTES
   VAR_INPUT 
      ix_AirPressureSwitch { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Air Pressure switch input
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus : "UDT_AirPressureSwitchStatus";   // Air pressure switch  fault status
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
   END_VAR

   VAR 
      sx_AirPressureFault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // When TRUE air pressure fault is active
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	19/07/2022  | 0.1       | M.Piela       | first release MHS TIA 16.0
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Reset encoder error
	    
	    IF #iqUDT_EquipmentControl.Command.Reset THEN
	        #sx_AirPressureFault := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Set air pressure switch error
	    
	    IF NOT #ix_AirPressureSwitch
	    THEN
	        #sx_AirPressureFault := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Status
	    
	    #qUDT_HMIStatus.Specific.AirPressureOK := NOT #sx_AirPressureFault;
	    
	    IF #sx_AirPressureFault
	    THEN
	        #qUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Error;
	    END_IF;
	    
	    IF NOT #sx_AirPressureFault
	    THEN
	        #qUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".AutoON;
	    END_IF;
	    
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_OnOffDevices"
TITLE = FB_OnOffDevices
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 19
// END_ATTRIBUTES
//Function block to enable and disable profinet devices.
   VAR_INPUT 
      ix_Simulation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Simulation on or off
   END_VAR

   VAR_OUTPUT 
      qx_Done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Operation done
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective error output
   END_VAR

   VAR_IN_OUT 
      iqa_ProfinetNetworks : Array[*] of "UDT_ProfinetNetwork";   // Profinet networks structure
   END_VAR

   VAR 
      sR_TRIG_StartSim {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge simulation bit
      sF_TRIG_StartSim {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge simulation bit
      si_ActualStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Status structure
      si_Mode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;   // Simulation mode 1 - simulation off 2 - simulation on
      sx_OperationReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Operation required
   END_VAR

   VAR_TEMP 
      ti_LoopCounterDevices : Int;   // Temporary counter of "for" loop
      ti_LoopCounterNetworks : Int;   // Temporary counter of "for" loop
      ti_NrOfProfinetDevices : Int;   // Number of profinet devices
      ti_NrOfNetworks : Int;   // Number of Profinet networks
      tx_Busy : Bool;   // D_ACT_DP busy
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | K.Pokorski    | first release MHS TIA 15.1
	24/06/2019  | 0.2       | L.Klar        | Status running added
	19/07/2019  | 0.5       | L.Klar        | Status handling changed, output qx_Done added
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	14/08/2019  | 2.1       | K.Pokorski    | Devices HW_ID extract deleted
	26/08/2019  | 2.2       | K.Pokorski    | Comments adjusted
	30/09/2019  | 2.3       | K.Pokorski    | Network seach started from 1 instead 0
	04/11/2019  | 2.4       | L.Klar        | First scan bit changed from memory bit to DB variable
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – Mode selection
	    
	    #sR_TRIG_StartSim(CLK := #ix_Simulation);
	    
	    #sF_TRIG_StartSim(CLK := #ix_Simulation);
	    
	    // Set operation request and operation mode (2 - devices deactivation) (1 - devices activation) when the simulation input has changed or the first PLC scan occurred
	    IF (#sR_TRIG_StartSim.Q            // Device activation required
	        OR #sF_TRIG_StartSim.Q         // Device deactivation required
	        OR "DB_Memory".FirstScan)       // First PLC scan occured
	    THEN
	        
	        #sx_OperationReq := TRUE;
	        
	        IF (NOT #ix_Simulation)                                             // Simulation turned off 
	        THEN
	            
	            #si_Mode := 1;
	            
	        END_IF;
	        
	        IF (#ix_Simulation)                                                 // Simulation turned on 
	        THEN
	            
	            #si_Mode := 2;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 – Activation or deactivation of devices
	    
	    // Change of device state if request is active
	    IF (#sx_OperationReq)                       // Change the device mode twice
	    THEN
	        
	        // Maximum number of Profinet networks 
	        #ti_NrOfNetworks := "FC_GetNrOfArrayEl"(iv_Array := #iqa_ProfinetNetworks);
	        
	        // Initial operation request reset
	        #sx_OperationReq := FALSE;
	        
	        // Reset summary error output 
	        #qx_Error := FALSE;
	        
	        // A loop operating on Profinet networks
	        FOR #ti_LoopCounterNetworks := 1 TO #ti_NrOfNetworks DO
	            
	            // Maximum number of Profinet devices
	            #ti_NrOfProfinetDevices := "FC_GetNrOfArrayEl"(#iqa_ProfinetNetworks[#ti_LoopCounterNetworks].DeviceStatus);
	            
	            // A loop operating on Profinet devices
	            FOR #ti_LoopCounterDevices := 1 TO ((#ti_NrOfProfinetDevices) - 1) DO
	                
	                // Activation or deactivation device if the device is configured
	                IF (#iqa_ProfinetNetworks[#ti_LoopCounterNetworks].DeviceStatus[#ti_LoopCounterDevices].DeviceState.Configure)                                         // Device configured
	                THEN
	                    // Turning off (mode = 2) or turning on (mode = 1) devices
	                    #si_ActualStatus := D_ACT_DP(REQ := TRUE,
	                                                 MODE := #si_Mode,
	                                                 LADDR := #iqa_ProfinetNetworks[#ti_LoopCounterNetworks].DeviceStatus[#ti_LoopCounterDevices].DeviceState.HW_ID,
	                                                 BUSY => #tx_Busy);
	                    
	                    // Operation still required when function "D_ACT_DP" is busy 
	                    #sx_OperationReq := #sx_OperationReq OR #tx_Busy;
	                    
	                    // Set the output error when D_ACT_DP has an error
	                    IF (INT_TO_WORD(#si_ActualStatus) > 16#8000)    // Error during disabling the devices 
	                    THEN
	                        
	                        #qx_Error := TRUE;
	                        
	                    END_IF;
	                    
	                END_IF;
	                
	            END_FOR;
	            
	        END_FOR;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 – Operation done
	    
	    // Update simulation done output
	    #qx_Done := NOT #sx_OperationReq;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_Loader"
TITLE = FB_Loader
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : Equimpent
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 216
// END_ATTRIBUTES
//Function block to control loader.
   VAR_INPUT 
      iUDT_LoaderConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_LoaderConfiguration";   //  Loader configuration structure
      ix_SafetyReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ix_SafetyOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when Safety Circuit of the Conveyor is healthy
      ix_24vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when 24VDC is healthy
      ix_400vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when 400VAC is healthy
      ix_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when  hardware is Ok
      ix_ReadyLoad { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when Loader is ready to load
      ix_Running { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when Loader is running
      ix_VFDError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when Loader has an VFD error
      ix_Healthy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when Loader has no Errors
      ix_PECEoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when the end of section photoeye is not blocked
      ix_PECFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ix_ManualControlled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Loader is manually controlled
      iw_Mode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   //  Mode selected on Loader control
      ix_ExternalRequestHold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  External request hold
      ix_ResetEnergySave { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Reset save energy mode timer
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_LoaderStatus";   //  HMI status structure
      qUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   //  Common status structure
      qi_SpeedSelect { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Speed select (slow, normal or fast)
      qx_EStopReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      qx_FaultReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      qx_ReleaseLoad { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Release Loader
      qx_PECBoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_IN_OUT 
      iqUDT_Statistics : "UDT_LoaderStatistics";   //  Statistics structure
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   //  Equipment control structure
      iqUDT_loaderCommand : "UDT_LoaderCommand";   //  Loader HMI control
      iqUDT_HandShakeUp : "UDT_ConveyorHandshake";   //  Handshake structure
      iqUDT_EquipmentInterface : "UDT_ConveyorInterface";   //  Conveyor interface structure
   END_VAR

   VAR 
      sUDT_CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //  Common status structure
      sUDT_CommonStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //  Auxiliary status structure
      sUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_LoaderStatus";   //  HMI status structure
      sFB_PECEoSFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //  Filtering end of section photo eye signal
      sFB_EnergySaveTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //  Timer to start energy save mode
      sFB_CascadeModeTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //  Timer to cascade start
      sR_TRIG_NotHealthy {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger if extendable not healthy
      sR_TRIG_EnergySave {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger save energy mode active
      sR_TRIG_VFDError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge of VFD error
      sR_TRIG_ConveyorUp {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge of automatic active
      sR_TRIG_ConveyorDown {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge of automatic not active
      sR_TRIG_StoreMode {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge of extendable in store mode
      sR_TRIG_FeedMode {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge of extendable in feed mode
      sR_TRIG_RunMode {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge of extendable in run mode
      si_AuxEnergySave { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Auxinalary energy save
      sx_Disabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Operation is enabled
      sx_PECEoSFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  End of section photo eye filtered
      sx_EnergySaveActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Active energy save mode
      sx_Ready { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Conveyor Ready to operate in Automatic mode
      sx_AutomaticActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Running in automatic
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | F.Baten       | first release MHS TIA 15.1
	17/06/2019  | 0.3       | L.Klar        | Manual mode added to "UDT_EquipmentControl"
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	14/10/2019  | 2.1       | L.Klar        | Updated status structure
	15/10/2019  | 2.2       | S.Deulkar     | Deleted unused symbol, added status
	30/10/2019  | 2.3       | F.Baten       | Pec timer on/off delaytimes interchanged
	04/11/2019  | 2.4       | L.Klar        | First scan bit changed from memory bit to DB variable
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	02/03/2020  | 3.1       | P.Majka       | Adapting reviews
	31/03/2020  | 3.2       | F.Baten       | UDT_UnloaderCommand added
	                                        | Disable by HMI added
	11/01/2021  | 3.3       | L.Klar        | Input safety ok added to stop conveyor condition
	16/02/2021  | 3.4       | K.Pokorski    | HMI Disable fixed 
	02/03/2021  | 3.5       | K. Pokorski   | Halted status enable only when automatic on
	15/03/2021  | 3.6       | K. Pokorski   | Energy safe corrected
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Initial
	    
	    REGION 1.1 - First PLC cycle
	        
	        // Bits initialization.
	        IF "DB_Memory".FirstScan
	        THEN
	            #qx_ReleaseLoad := FALSE;
	            #sx_AutomaticActive := FALSE;
	            #iqUDT_HandShakeUp.RTR := FALSE;
	            #iqUDT_HandShakeUp.CascadeStartUp := FALSE;
	            #sx_Disabled := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 1.2 Triggers and filters
	        
	        // Rising edge trigger Energy save mode.
	        #sR_TRIG_EnergySave(CLK := #sUDT_CommonStatus.EnergySave);
	        
	        // Rising edge extendable up.
	        #sR_TRIG_ConveyorUp(CLK := #sx_AutomaticActive AND #sx_Ready);
	        
	        // Rising edge extendable down.
	        #sR_TRIG_ConveyorDown(CLK := #sx_AutomaticActive AND NOT #sx_Ready);
	        
	        // Rising edge extendable VFD error.
	        #sR_TRIG_VFDError(CLK := #sUDT_HMIStatus.Specific.VFDError);
	        
	        // Rising edge extendable not healthy .
	        #sR_TRIG_NotHealthy(CLK := #sUDT_HMIStatus.Specific.NotHealthy);
	        
	        // Rising edge extendable feed mode .
	        #sR_TRIG_FeedMode(CLK := #sUDT_HMIStatus.Specific.FeedMode);
	        
	        // Rising edge extendable Store mode .
	        #sR_TRIG_StoreMode(CLK := #sUDT_HMIStatus.Specific.StoreMode);
	        
	        // Rising edge extendable Run mode. 
	        #sR_TRIG_RunMode(CLK := #sUDT_HMIStatus.Specific.RunMode);
	        
	        // Filter - End of section photo eye signal filtering.
	        #sFB_PECEoSFiltered(iudi_OnDelayTime := #iUDT_LoaderConfiguration."PEC_EoSTimeOnDelay",
	                            iudi_OffDelayTime := #iUDT_LoaderConfiguration."PEC_EoSTimeOffDelay",
	                            ix_SignalToDelay := #ix_PECEoS,
	                            ix_Enable := #ix_Running,
	                            qx_DelayedSignal => #sx_PECEoSFiltered);
	        
	    END_REGION
	    
	    REGION HMI button Disable/Enable operation
	        IF #iqUDT_loaderCommand.Disable
	        THEN
	            #sx_Disabled := TRUE;
	        ELSE
	            #sx_Disabled := FALSE;
	        END_IF;
	        #iqUDT_loaderCommand.Disable := FALSE;
	        
	        // Copy status to HMI
	        #sUDT_HMIStatus.Specific.Disabled := #sx_Disabled;
	        
	    END_REGION
	END_REGION
	
	REGION 2 - Errors
	    
	    // VFD Error.
	    #sUDT_HMIStatus.Specific.VFDError := (#ix_VFDError AND #ix_400vOk AND #ix_HardwareOk);
	    
	    // Not healthy.
	    #sUDT_HMIStatus.Specific.NotHealthy := (NOT #ix_Healthy AND #ix_400vOk AND #ix_24vOk AND #ix_HardwareOk);
	    
	    // Common Error.
	    #sUDT_CommonStatus.Error := NOT #ix_24vOk
	    OR NOT #ix_400vOk
	    OR NOT #ix_HardwareOk
	    OR NOT #ix_SafetyOk
	    OR #sUDT_HMIStatus.Specific.VFDError
	    OR #sUDT_HMIStatus.Specific.NotHealthy;
	    
	    // Warning.
	    #sUDT_CommonStatus.Warning := FALSE;
	    
	    // Mode selected = 1.
	    IF #iw_Mode = 1
	    THEN
	        #sUDT_HMIStatus.Specific.StoreMode := TRUE;
	        #sUDT_HMIStatus.Specific.FeedMode := FALSE;
	        #sUDT_HMIStatus.Specific.RunMode := FALSE;
	    END_IF;
	    
	    // Mode selected = 2.
	    IF #iw_Mode = 2
	    THEN
	        #sUDT_HMIStatus.Specific.StoreMode := FALSE;
	        #sUDT_HMIStatus.Specific.FeedMode := TRUE;
	        #sUDT_HMIStatus.Specific.RunMode := FALSE;
	    END_IF;
	    
	    // Mode selected = 3.
	    IF #iw_Mode = 3
	    THEN
	        #sUDT_HMIStatus.Specific.StoreMode := FALSE;
	        #sUDT_HMIStatus.Specific.FeedMode := FALSE;
	        #sUDT_HMIStatus.Specific.RunMode := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Check conditions to set loader ready
	    
	    // Ready to operate. 
	    #sx_Ready := NOT #sUDT_CommonStatus.Error
	    AND #ix_Healthy
	    AND NOT #ix_ManualControlled;
	    
	END_REGION
	
	REGION 4 - Stop loader
	    
	    // Reset bits to stop loader.
	    IF NOT #iqUDT_EquipmentControl.Command.AutomaticOn
	        OR #sUDT_CommonStatus.Error
	        OR #ix_ManualControlled
	    THEN
	        #sx_AutomaticActive := FALSE;
	        #iqUDT_HandShakeUp.RTR := FALSE;
	        #iqUDT_HandShakeUp.CascadeStartUp := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Start Automatic mode
	    
	    REGION 5.1 - Start 
	        
	        // Activating automatic mode. 
	        IF #iqUDT_EquipmentControl.Command.Start
	            AND #sx_Ready
	        THEN
	            #sx_AutomaticActive := TRUE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 5.2 - Cascade mode
	        
	        // Timer to cascade mode.
	        #sFB_CascadeModeTimer(iudi_OnDelayTime := #iUDT_LoaderConfiguration.CascadeTimeOnDelay,
	                              ix_SignalToDelay := #sx_AutomaticActive,
	                              ix_Enable := NOT #iqUDT_HandShakeUp.CascadeStartUp,
	                              qx_DelayedSignal => #iqUDT_HandShakeUp.CascadeStartUp);
	        
	    END_REGION
	    
	END_REGION
	
	REGION 6 - Automatic mode active
	    
	    REGION 6.1 - Operation                        
	        
	        // Run/release load: starting and stopping is controlled by loader controls.
	        #qx_ReleaseLoad := #sx_AutomaticActive
	        AND #sx_Ready
	        AND #ix_ReadyLoad
	        AND NOT #sx_Disabled
	        AND NOT #ix_ExternalRequestHold
	        AND NOT #sx_EnergySaveActive;
	        
	        // Ready to receive.
	        #iqUDT_HandShakeUp.RTR := #sx_AutomaticActive
	        AND #sx_Ready
	        AND #ix_ReadyLoad
	        AND NOT #ix_ExternalRequestHold;
	        
	    END_REGION
	    
	    REGION 6.2 - Energy save
	        IF #iUDT_LoaderConfiguration.Energy THEN
	            
	            // Set Energy save active.
	            IF #si_AuxEnergySave >= #iUDT_LoaderConfiguration.EnergySaveLength
	            THEN
	                #sx_EnergySaveActive := TRUE;
	            END_IF;
	            
	            // Reset or increment displacement calculation to use for energy save.
	            IF (NOT #sx_PECEoSFiltered
	                OR #iqUDT_HandShakeUp.RTS
	                OR #iqUDT_HandShakeUp.ResetEnergySave
	                OR #ix_ResetEnergySave
	                OR #ix_ManualControlled
	                OR NOT #ix_ReadyLoad)
	            THEN
	                #si_AuxEnergySave := 0;
	                #sx_EnergySaveActive := FALSE;
	            ELSE
	                #si_AuxEnergySave += #iqUDT_EquipmentInterface.Displacement;
	            END_IF;
	            
	        ELSE
	            
	            #si_AuxEnergySave := 0;
	            #sx_EnergySaveActive := FALSE;
	            
	        END_IF;
	    END_REGION
	    
	END_REGION
	
	REGION 7 - Speed control
	    
	    // Copy speed setpoint from configuration.
	    #qi_SpeedSelect := #iUDT_LoaderConfiguration.Speedsetpoint;
	    
	    // Clear speed setpoint depending on wrong configuration.
	    IF #iUDT_LoaderConfiguration.Speedsetpoint < 0
	        OR #iUDT_LoaderConfiguration.Speedsetpoint > 2
	    THEN
	        #qi_SpeedSelect := 0;
	    END_IF;
	    
	END_REGION
	
	REGION 8 - Reset
	    // Fault and Estop reset outputs
	    #qx_FaultReset := #ix_SafetyReset OR #iqUDT_EquipmentControl.Command.Reset;
	    #qx_EStopReset := #ix_SafetyReset;
	    
	END_REGION
	
	REGION 9 Output enable
	    
	    #qx_PECBoS := #ix_PECFull;
	    
	END_REGION
	
	REGION 10 - Statistics
	    
	    // Up Time.
	    IF #sx_AutomaticActive
	        AND #sx_Ready
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sx_AutomaticActive AND #sx_Ready,
	                        ix_RTrigActivate := #sR_TRIG_ConveyorUp.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.ExtendableUpTime);
	    END_IF;
	    
	    // Down Time.
	    IF #sx_AutomaticActive
	        AND #sx_Ready
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sx_AutomaticActive AND NOT #sx_Ready,
	                        ix_RTrigActivate := #sR_TRIG_ConveyorDown.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.ExtendableDownTime);
	    END_IF;
	    
	    // Energy save mode active.
	    IF #sx_EnergySaveActive
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_CommonStatus.EnergySave,
	                        ix_RTrigActivate := #sR_TRIG_EnergySave.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.EnergySave);
	    END_IF;
	    
	    // VFD Error.
	    IF #sUDT_HMIStatus.Specific.VFDError
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.VFDError,
	                        ix_RTrigActivate := #sR_TRIG_VFDError.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.VFDError);
	    END_IF;
	    
	    // Not healthy.
	    IF #sUDT_HMIStatus.Specific.NotHealthy
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.NotHealthy,
	                        ix_RTrigActivate := #sR_TRIG_NotHealthy.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.NotHealthy);
	    END_IF;
	    
	END_REGION
	
	REGION 11 - Status
	    
	    // Set statuses.
	    #sUDT_CommonStatus.Stopped := NOT #sx_AutomaticActive;
	    #sUDT_CommonStatus.Running := #ix_Running;
	    #sUDT_CommonStatus.AutoON := #sx_Ready AND #sx_AutomaticActive;
	    #sUDT_CommonStatus.Halted := #ix_ExternalRequestHold AND #sUDT_CommonStatus.AutoON;
	    #sUDT_CommonStatus.Manual := #ix_ManualControlled;
	    #sUDT_CommonStatus.ManualRun := #sUDT_CommonStatus.Manual AND #sUDT_CommonStatus.Running;
	    #sUDT_CommonStatus.EnergySave := #sx_EnergySaveActive;
	    #sUDT_CommonStatus.SafetyStop := NOT #ix_SafetyOk;
	    
	    
	    // HMI status update on change.
	    IF #sUDT_CommonStatusOld <> #sUDT_CommonStatus
	        OR (#sR_TRIG_FeedMode.Q OR #sR_TRIG_StoreMode.Q OR #sR_TRIG_RunMode.Q)
	    THEN
	        // HMI status initialization.
	        #sUDT_HMIStatus.Status := 0;
	        
	        // Energy save.
	        IF #sUDT_CommonStatus.EnergySave
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".EnergySave;
	        END_IF;
	        
	        // Running.
	        IF #sUDT_CommonStatus.Running
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Running;
	        END_IF;
	        
	        // Stopped.
	        IF #sUDT_CommonStatus.Stopped
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Stopped;
	        END_IF;
	        
	        // Dieback.
	        IF #sUDT_CommonStatus.Dieback
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Dieback;
	        END_IF;
	        
	        // Halted.
	        IF #sUDT_CommonStatus.Halted
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Halted;
	        END_IF;
	        
	        // Manual.
	        IF #sUDT_CommonStatus.Manual
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Manual;
	        END_IF;
	        
	        // Running in manual mode.
	        IF #sUDT_CommonStatus.ManualRun
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".ManualRun;
	        END_IF;
	        
	        // Not healthy.
	        IF #sUDT_HMIStatus.Specific.NotHealthy
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".VFDNotHealthy;
	        END_IF;
	        
	        // VFD error.
	        IF #sUDT_HMIStatus.Specific.VFDError
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".VFDError;
	        END_IF;
	        
	        // Safety stop.
	        IF (#sUDT_CommonStatus.SafetyStop)
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".SafetyStop;
	        END_IF;
	        
	        // Copy statuses.
	        
	        #sUDT_CommonStatusOld := #sUDT_CommonStatus;
	        
	    END_IF;
	    #qUDT_HMIStatus := #sUDT_HMIStatus;
	    #qUDT_Status := #sUDT_CommonStatus;
	    
	END_REGION
	
	REGION 11 - Report to control block
	    
	    "FC_EquipmentReport"(iUDT_Status := #sUDT_CommonStatus,
	                         iqUDT_Control := #iqUDT_EquipmentControl);
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_PECUpdateD"
TITLE = FB_PECUpdate
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 23
// END_ATTRIBUTES
//Function block to update parcel data in a tracking array at PEC position.
   VAR_INPUT 
      iUDT_PECUpdateConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECDUpdateConfiguration";   //   PEC update configuration
      iUDT_ConveyorCommonConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorCommonConfiguration";   //   Conveyor configuration
      ix_PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when the end of section photoeye is not blocked
      ix_TeachingMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Teaching mode enable
   END_VAR

   VAR_OUTPUT 
      qUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateStatus";   //   Status structure
      qi_GINwrite { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Gin found or generated
      qx_PECFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Filtered photoeye signal
   END_VAR

   VAR_IN_OUT 
      iqa_TrackingData : Array[*] of Int;   //   Tracking data
      iqUDT_ConveyorInterface : "UDT_ConveyorInterface";   //   Conveyor interface
      iqUDT_UnknownGINRange : "UDT_UnknownGIN";   //   Unknown GIN
      iqUDT_FifoHeader : "UDT_FifoHeader";   //   FIFO header
      iqa_FifoData : Array[*] of Int;   //   FIFO data
      iqUDT_Statistics : "UDT_PECUpdateStatistics";   //   Statistic structure
   END_VAR

   VAR 
      sFB_PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PECD";   //   Photoeye function
      sFB_LengthMeasurement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ParcelLength";   //   Length measurement
      s_R_TRIG_Parcel {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Parcel detected rising edge to count parcels
      s_R_TRIG_ParcelFound {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Parcel detected rising edge to update the PEC position tracking record
      s_R_TRIG_DataFound {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Any data found at a PEC position rising edge
      s_R_TRIG_PositiveDataFound {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Positive data found at a PEC position rising edge
      s_R_TRIG_TeachMode {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Teaching mode activation rising edge
      s_R_TRIG_TooManyLost {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Too many lost parcels error statistics trigger
      sUDT_LostGINFIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoStatus";   //   Lost GIN FIFO status
      "ss_PEC/DataDeviation" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // PEC/Data deviation calculation structure
         "Type" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 1= match, 2 = PEC no Data, 3= Data no PEC, 4 Double data, 5 = Pec no data Lost
         Last { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Last deviation of found data [cm]
         GIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Last GIN deviation
         Sum { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Deviation sum [cm]
         Nr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Deviation number
      END_STRUCT;
      ss_ValidGINRange { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //   Valid GIN range
         Start { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         End { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         GIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      END_STRUCT;
      ss_AlignedParcelsCounters { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //   Aligned parcels counters
         Total { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Total aligned parcels
         DataNoPEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Parcels aligned in case data detected without photoeye signal
         PECNoData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Parcels aligned in case parcel detected without data
      END_STRUCT;
      ss_LostParcelsCounters { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //   Lost parcels counters
         Total { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Total number of lost parcels
         DoubleData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Parcels lost due to double data found in a search window
         ParcelNotFound { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Parcels lost due to no parcel detected after travelling search window distance
      END_STRUCT;
      ss_LostValidParcelsCounters { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //   Lost parcels counters
         Total { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Total number of lost parcels
         DoubleData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Parcels lost due to double data found in a search window
         ParcelNotFound { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Parcels lost due to no parcel detected after travelling search window distance
      END_STRUCT;
      si_UnknownParcelsCounters { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //   Unknown parcels counters
         Total { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Total number of unknown parcels
         LostParcelFound { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Parcel found with a lost data, unknown GIN created
         DataNotFound { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Data not found during search window scan
      END_STRUCT;
      slr_Performance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal := 100.0;   //   Update performance [%]
      sdi_TotalNumberOfParcels { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   Total number of parcels detected
      sdi_TotalNumberOfData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   Total number of data detected
      si_PECPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Photoeye position [cm]
      si_SearchWindow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Data search distance from photoeye position [cm]
      si_GINToWrite { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Found or generated GIN, which will be used to update photoeye position in the tracking array
      si_PositionToUpdate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Position in a tracking array to be updated
      si_Direction { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Direction of the displacement to parametrize loops
      si_Displacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Displacement [cm]
      si_ParcelWaitDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Parcel delay [cm]
      si_LastUpdatedGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Last updated GIN to check if next data is a new one
      si_LastCountedData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Last counted data
      si_LostParcelsInARow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Number of lost parcel in a row
      si_NumberOfTeachedParcels { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Number of teached parcels
      si_AverageSlip { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Average parcel slip [cm]
      si_CalculatedLengthCorrection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Calculated length correction after teaching
      si_ParcelLengthFilterCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Parcel length filter counter [cm]
      si_ParcelLengthFilterOldGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Parcel length filter old GIN
      si_i { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Loop counter
      sx_ParcelDetected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Parcel detected
      sx_ParcelWaitEnable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Missing parcel monitoring
      sx_TeachingMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Teaching mode
      sx_GenerateGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Request to generate GIN
      sx_LostGINFIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Lost GIN FIFO error
      sx_LostGINFIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Lost GIN FIFO warning
      sx_InvalidDirection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Invalid direction
      sx_InvalidGINRange { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Invalid GIN range
      sx_InvalidDisplacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Invalid displacement
      sx_InvalidSearchWindow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Invalid search window
      sx_DoubleDataFound { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Double data detected
      sx_LengthMeasurementEnable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_TEMP 
      tUDT_PECConfiguration : "UDT_PECDConfiguration";   //   PEC configuration
      tUDT_PECStatus : "UDT_PECStatus";   //   PEC status
   END_VAR

   VAR CONSTANT 
      ci_ZeroGIN : Int;   //   GIN = 0
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHSE TIA 15.1
	13/06/2019  | 0.2       | A.Nowak       | Replacement of instruction if for direct write into variable
	21/06/2019  | 0.3       | A.Nowak       | Add gap mesurement function and reorganise block (regions) 
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHSE library release TIA 15.1
	23/08/2019  | 2.1       | L.Klar        | "UDT_ConveyorConfiguration" changed to "UDT_ConveyorCommonConfiguration"
	XX/08/2019  | 2.2       | L.Klar        | Update logic changed
	19/09/2019  | 2.3       | P.Majka       | Updating checking PEC and PEC filtered signals
	30/09/2019  | 2.4       | L.Klar        | FB_PEC added, Filtered PEC signal output added
	21/10/2019  | 2.6       | L.Klar        | Configuration UDT chanaged to input, PEC configuration interface input name changed
	23/10/2019  | 2.7       | P.Majka       | Added Region 1, renumerating Regions, changed logic in Region 10.3 and Region 5
	29/10/2019  | 2.8       | L.Klar        | FB_PEC call changed
	14/11/2019  | 2.9       | L.Klar        | Deviations calculation corrected
	14/11/2019  | 3.0       | P.Majka       | 3.0 MHSE library release TIA 15.1
	20/12/2019  | 3.1       | S.Deulkar     | Used configureation error bit to report to conveyor block     
	07/01/2020  | 3.2       | L.Klar        | GIN record structure updated, GIN cleared with default one during generation
	                                        | PECUpdate configuration UDT update - search window DINT -> INT, 
	                                        | Conveyor common configuration UDT update - length INT -> DINT  conversion added
	29/01/2020  | 3.3       | L.Klar        | Negative GIN handling fixed, configuration bit added to delete negative GIN instead of ignoing it.
	24/02/2020  | 3.4       | L.Klar        | Formating changes, statistics counter added 
	10/03/2020  | 3.5       | F.Baten       | Range check unknown GIN region 7
	26/03/2020  | 3.6       | F.Baten       | Added output 'qi_GINwrite'
	25/11/2020  | 3.7       | L.Klar        | Length filter added
	07/12/2020  | 3.8       | L.Klar        | Length filter bug fix
	22/01/2021  | 3.9       | L.Klar        | Total number of parcels and lost parcels counter fixed
	14/08/2021  | 3.10      | S. Deulkar    | Update from EMA
	20/04/2023  | 4.0       | F.Baten       | Added deviation parameter for easier configuration
	                                        | PEC delay changed to distance
	                                        | 4.0 Release TIA 17.5
	*)
	
	
	
	REGION 1 – FIFO header status update
	    
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #sUDT_LostGINFIFOStatus,
	              qx_Error => #sx_LostGINFIFOError,
	              qx_Warning => #sx_LostGINFIFOWarning,
	              iqv_Data := #si_GINToWrite,
	              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	              iqv_DataBuffer := #iqa_FifoData);
	    
	END_REGION
	
	REGION 2 – Displacement read
	    
	    #si_Displacement := #iqUDT_ConveyorInterface.Displacement;
	    
	END_REGION
	
	REGION 3 – PEC Position conversion from mm to cm
	    
	    // The conversion is required because the photoeye position is given in mm and the tracking resolution is 1 cm. 
	    #si_PECPosition := DINT_TO_INT(#iUDT_PECUpdateConfiguration.Distance / 10);
	    
	END_REGION
	
	REGION 4 – Teaching mode enable
	    
	    (* Teaching mode is used to calculate conveyor length correction, which allows to align real conveyor length with a tracking array length.
	       Correction is calculated as a difference between photoeye signal and tracking data deviations.
	       Calculated correction has to be manually copied from a FB_PECUpdate instance data block to conveyor configuration.*)
	    
	    // Teaching mode is initialized and activated manually via block input.
	    #s_R_TRIG_TeachMode(CLK := #ix_TeachingMode);
	    
	    IF (#s_R_TRIG_TeachMode.Q
	        AND NOT #sx_TeachingMode)
	    THEN
	        #"ss_PEC/DataDeviation".Type := 0;
	        #"ss_PEC/DataDeviation".Nr := 0;
	        #"ss_PEC/DataDeviation".Sum := 0;
	        #si_NumberOfTeachedParcels := 0;
	        #sx_TeachingMode := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 5 – Photoeye
	    
	    (*FB_PEC block call to filter photoeye signal and calculate jam status.*)
	    
	    // Copy PEC configuration.
	    #tUDT_PECConfiguration.Distance := #iUDT_PECUpdateConfiguration.Distance;
	    #tUDT_PECConfiguration.JamDisplacementLimit := #iUDT_PECUpdateConfiguration.JamDisplacementLimit;
	    #tUDT_PECConfiguration.OnDelayDistance := #iUDT_PECUpdateConfiguration.OnDelayDistance;
	    #tUDT_PECConfiguration.OffDelayDistance := #iUDT_PECUpdateConfiguration.OffDelayDistance;
	    #tUDT_PECConfiguration.ResetWithPECBlocked := #iUDT_PECUpdateConfiguration.ResetWithPECBlocked;
	    
	    //Call FB_PEC.
	    #sFB_PEC(ix_PEC := #ix_PEC,
	             iUDT_PECConfiguration := #tUDT_PECConfiguration,
	             qUDT_HMIStatus => #tUDT_PECStatus,
	             iqUDT_ConveyorInterface := #iqUDT_ConveyorInterface,
	             iqUDT_PECStatistics := #iqUDT_Statistics.PEC);
	    
	    // Parcel length filter
	    IF NOT #ix_PEC
	        AND #iUDT_PECUpdateConfiguration.ParcelLengthFilter
	        AND #iqa_TrackingData[#si_PECPosition - 1] > 0
	        AND #iqa_TrackingData[#si_PECPosition - 1] <> #si_ParcelLengthFilterOldGIN THEN
	        
	        IF "DB_GIN".GIN[#iqa_TrackingData[#si_PECPosition - 1]].General.Length > 0 THEN
	            #si_ParcelLengthFilterCounter := "DB_GIN".GIN[#iqa_TrackingData[#si_PECPosition - 1]].General.Length;
	        END_IF;
	        
	        #si_ParcelLengthFilterOldGIN := #iqa_TrackingData[#si_PECPosition - 1];
	        
	    END_IF;
	    
	    IF #si_ParcelLengthFilterCounter > 0 THEN
	        
	        #qUDT_Status.PEC := FALSE;
	        #qx_PECFiltered := FALSE;
	        #si_ParcelLengthFilterCounter -= #iqUDT_ConveyorInterface.Displacement;
	        
	    ELSE
	        
	        #qUDT_Status.PEC := #sFB_PEC.qx_PECFiltered;
	        #qx_PECFiltered := #sFB_PEC.qx_PECFiltered;
	        
	    END_IF;
	    
	    #qUDT_Status.Jam := #tUDT_PECStatus.Jam;
	    
	    // Parcel detected variable to simplify further photoeye position tracking record update.
	    #sx_ParcelDetected := NOT #qUDT_Status.PEC;
	    
	END_REGION
	
	REGION 6 – Error reset
	    
	    // Reset errors when reset signal is given.
	    IF (#iqUDT_ConveyorInterface.InternalErrorReset)
	    THEN
	        #si_LostParcelsInARow := 0;
	        #qUDT_Status.TooManyLost := FALSE;
	        #sx_InvalidDisplacement := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 7 – GIN generator initialization
	    
	    // Valid GIN range configuration is moved to a structure.
	    #ss_ValidGINRange.Start := #iUDT_PECUpdateConfiguration.GINRangeStart;
	    #ss_ValidGINRange.End := #iUDT_PECUpdateConfiguration.GINRangeEnd;
	    
	    // Check if the unknown GIN is within range
	    IF #iqUDT_UnknownGINRange.GIN < #iqUDT_UnknownGINRange.Start
	        OR #iqUDT_UnknownGINRange.GIN > #iqUDT_UnknownGINRange.End
	    THEN
	        #iqUDT_UnknownGINRange.GIN := #iqUDT_UnknownGINRange.Start;
	    END_IF;
	    
	    // Whenever valid GIN range is changed and the generated GIN doesn't fit, it's initialized.
	    IF (#ss_ValidGINRange.GIN < #ss_ValidGINRange.Start
	        OR #ss_ValidGINRange.GIN > #ss_ValidGINRange.End)
	    THEN
	        #ss_ValidGINRange.GIN := #ss_ValidGINRange.Start;
	    END_IF;
	    
	    // Valid GIN range is set locally in PEC update configuration structure and it can't overlap with a global unknown GIN range.
	    #sx_InvalidGINRange := #iUDT_PECUpdateConfiguration.GenerationPoint
	    AND (#ss_ValidGINRange.End <= #ss_ValidGINRange.Start
	    OR #ss_ValidGINRange.Start <= #iqUDT_UnknownGINRange.End
	    OR #iqUDT_UnknownGINRange.End <= #iqUDT_UnknownGINRange.Start)
	    AND #ss_ValidGINRange.Start < 1000;   // Until 1000 it is UFO range
	    
	END_REGION
	
	REGION 8 – Search window and displacement validation
	    
	    (*Both parameters have to be checked to prevent tracking array exceeding.*)
	    
	    // Search window cannot be lower than zero and greater than distance between PEC position and conveyor edge.
	    #sx_InvalidSearchWindow := #iUDT_PECUpdateConfiguration.SearchWindowFwd < 0
	    OR #iUDT_PECUpdateConfiguration.SearchWindowFwd >= #iUDT_ConveyorCommonConfiguration.Length + #iUDT_ConveyorCommonConfiguration.LengthCorrection - #si_PECPosition
	    OR #iUDT_PECUpdateConfiguration.SearchWindowRvs < 0
	    OR #iUDT_PECUpdateConfiguration.SearchWindowRvs >= #si_PECPosition;
	    
	    // Displacement cannot be greater than the photoeye position.
	    IF (ABS(#si_Displacement) > #si_PECPosition)
	    THEN
	        #sx_InvalidDisplacement := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 9 – Total number of parcels counter
	    
	    (*Parcels are counted basing on parcel detection rising edge trigger. Counting is blocked
	      during PLC first scan, when photoeye signal becomes 0.*)
	    
	    #s_R_TRIG_Parcel(CLK := #sx_ParcelDetected);
	    
	    IF (#s_R_TRIG_Parcel.Q
	        AND NOT "DB_Memory".FirstScan)
	    THEN
	        // Total number of parcels.
	        #sdi_TotalNumberOfParcels += 1;
	        
	        // Every detected parcel resets lost parcels in a row counter.
	        #si_LostParcelsInARow := 0;
	        
	        // Number of teached parcels is incremented if teaching mode is activated.
	        IF (#sx_TeachingMode)
	        THEN
	            #si_NumberOfTeachedParcels += 1;
	        END_IF;
	    END_IF;
	    
	END_REGION
	
	REGION 10 – PEC Update
	    (* Photoeye position record is updated after every tracking register shift, basing on
	       actual situation - photoeye signal and data availability. In case of displacement
	       graeter than one, the loop will be executed the proper number of times. The update loop
	       can be executed if there is no configuration errors and the displacement was given.*)
	    
	    WHILE #si_Displacement <> 0
	        AND NOT #sx_InvalidGINRange
	        AND NOT #sx_InvalidDisplacement
	        AND NOT #sx_InvalidSearchWindow
	    DO
	        
	        REGION 10.1 – Direction
	            
	            (*Depending on displacement sign, the direction of movement is determinated. This allows to choose 
	            ` correct search window and parametrize all search loops to count up or down.*)
	            
	            IF (#si_Displacement < 0)
	            THEN
	                #si_Direction := -1;
	                #si_SearchWindow := #iUDT_PECUpdateConfiguration.SearchWindowRvs;
	            ELSIF (#si_Displacement > 0)
	            THEN
	                #si_Direction := 1;
	                #si_SearchWindow := #iUDT_PECUpdateConfiguration.SearchWindowFwd;
	            END_IF;
	            
	        END_REGION
	        
	        REGION 10.2 – Position to update
	            
	            // Position pointer used to specify the tracking array record to be updated.
	            #si_PositionToUpdate := #si_PECPosition - #si_Displacement + #si_Direction;
	            
	        END_REGION
	        
	        
	        REGION 10.3 – Total number of data counter
	            
	            (*Total number of data is incremented every time when new GIN is detected.*)
	            
	            IF (#iqa_TrackingData[#si_PositionToUpdate + 1] > 0
	                AND #iqa_TrackingData[#si_PositionToUpdate + 1] <> #si_LastCountedData)
	            THEN
	                #sdi_TotalNumberOfData += 1;
	                #si_LastCountedData := #iqa_TrackingData[#si_PositionToUpdate + 1];
	            END_IF;
	            
	        END_REGION
	        
	        REGION 10.4 – GIN detection
	            
	            (* Data found and parcel found triggers are used to determine the update case,
	               whether the data occurred first or a parcel.*)
	            
	            // Trigger on any data found at a PEC position to detect the front of the parcel data. 
	            #s_R_TRIG_DataFound(CLK := #iqa_TrackingData[#si_PositionToUpdate] <> 0);
	            
	            // Trigger on positive data found at a PEC position to detect the front of the parcel data.   
	            #s_R_TRIG_PositiveDataFound(CLK := #iqa_TrackingData[#si_PositionToUpdate] > 0);
	            
	            // Trigger to detect front of the parcel.
	            #s_R_TRIG_ParcelFound(CLK := #sx_ParcelDetected);
	            
	(*
	Data detected without PEC signal
	
	                         Search window
	                          <--------|
	Data                              PEC
	|----------------------------------|------------------------------------------|
	|                           XXXXXXXX                                          |
	|----------------------------------|------------------------------------------|
	                                   |
	Conveyor                           |
	|----------------------------------|------------------------------------------|
	|                      YYYYYYYY    |                                          | 
	|                      YYYYYYYY    |                                          |
	|                      YYYYYYYY    |                                          |
	|----------------------------------|------------------------------------------|
	*)
	(* Data detected without PEC signal.*)
	            IF (#s_R_TRIG_PositiveDataFound.Q
	                AND NOT #sx_ParcelDetected)
	            THEN
	                #si_GINToWrite := 0;
	                // Double data detection loop.
	                FOR #si_i := #si_PositionToUpdate TO #si_PECPosition + (#si_SearchWindow * #si_Direction) BY #si_Direction DO
	                    // Data found in a search window.
	                    IF (#iqa_TrackingData[#si_i] > 0)
	                    THEN
	                        // First GIN found.
	                        IF (#si_GINToWrite = 0)
	                        THEN
	                            // Get the GIN if it's different than last updated GIN.
	                            IF #iqa_TrackingData[#si_i] <> #si_LastUpdatedGIN THEN
	                                #si_GINToWrite := #iqa_TrackingData[#si_i];
	                            END_IF;
	                            // If the first GIN was found, the scan loop conitues to check if there is no other data.
	                        ELSE
	                            // Next found data is different than the first one. Double data detected.
	                            IF (#iqa_TrackingData[#si_i] <> #si_GINToWrite)
	                            THEN
	                                #sx_DoubleDataFound := TRUE;
	                                // First found GIN is marked as a lost one and the GIN is stored in a FIFO register.
	                                IF ("DB_GIN".GIN[#si_GINToWrite].General.Lost = FALSE)
	                                THEN
	                                    "DB_GIN".GIN[#si_GINToWrite].General.Lost := TRUE;
	                                    
	                                    "FC_Fifo"(ic_Mode := 'W',
	                                              qUDT_Status => #sUDT_LostGINFIFOStatus,
	                                              qx_Error => #sx_LostGINFIFOError,
	                                              qx_Warning => #sx_LostGINFIFOWarning,
	                                              iqv_Data := #si_GINToWrite,
	                                              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                                              iqv_DataBuffer := #iqa_FifoData);
	                                    
	                                    // Update statistics
	                                    #ss_LostParcelsCounters.Total += 1;
	                                    #ss_LostParcelsCounters.DoubleData += 1;
	                                    
	                                    
	                                    ////////////////////
	                                    
	                                    IF #si_GINToWrite >= 1000 THEN
	                                        #ss_LostValidParcelsCounters.Total += 1;
	                                        #ss_LostValidParcelsCounters.DoubleData += 1;
	                                    END_IF;
	                                    
	                                    ////////////////
	                                END_IF;
	                                
	                                // Second found GIN is marked as a lost one and the GIN is stored in a FIFO register.
	                                IF ("DB_GIN".GIN[#iqa_TrackingData[#si_i]].General.Lost = FALSE)
	                                THEN
	                                    "DB_GIN".GIN[#iqa_TrackingData[#si_i]].General.Lost := TRUE;
	                                    
	                                    "FC_Fifo"(ic_Mode := 'W',
	                                              qUDT_Status => #sUDT_LostGINFIFOStatus,
	                                              qx_Error => #sx_LostGINFIFOError,
	                                              qx_Warning => #sx_LostGINFIFOWarning,
	                                              iqv_Data := #iqa_TrackingData[#si_i],
	                                              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                                              iqv_DataBuffer := #iqa_FifoData);
	                                    
	                                    // Update statistics
	                                    #ss_LostParcelsCounters.Total += 1;
	                                    #ss_LostParcelsCounters.DoubleData += 1;
	                                    
	                                    ////////////////////
	                                    
	                                    IF #iqa_TrackingData[#si_i] >= 1000 THEN
	                                        #ss_LostValidParcelsCounters.Total += 1;
	                                        #ss_LostValidParcelsCounters.DoubleData += 1;
	                                    END_IF;
	                                    
	                                    ////////////////
	                                    //
	                                END_IF;
	                                // Stop search window scan in case of double data detection
	                                EXIT;
	                            END_IF;
	                        END_IF;
	                    END_IF;
	                END_FOR;
	                
	                // Becasue the data was found as a first one, GIN is stored and the logic to wait for a parcel is enebaled.
	                // If the double data was found there is no need to wait for a parcel. Data has been marked as a lost one.
	                IF NOT #sx_DoubleDataFound
	                THEN
	                    #sx_ParcelWaitEnable := TRUE;
	                END_IF;
	                
	                #sx_DoubleDataFound := FALSE;
	(*
	Data and PEC signal detected at the same time - perfect match
	
	                         Search window
	                          <--------|
	Data                              PEC
	|----------------------------------|------------------------------------------|
	|                           XXXXXXXX                                          |
	|----------------------------------|------------------------------------------|
	                                   |
	Conveyor                           |
	|----------------------------------|------------------------------------------|
	|                           XXXXXXXX                                          | 
	|                           XXXXXXXX                                          |
	|                           XXXXXXXX                                          |
	|----------------------------------|------------------------------------------|
	
	or PEC signal found without data or with old ones
	
	                         Search window
	                          <--------|
	Data                              PEC
	|----------------------------------|------------------------------------------|
	|                    XXXXXXXX      |                                          |
	|----------------------------------|------------------------------------------|
	                                   |
	Conveyor                           |
	|----------------------------------|------------------------------------------|
	|                           XXXXXXXX                                          | 
	|                           XXXXXXXX                                          |
	|                           XXXXXXXX                                          |
	|----------------------------------|------------------------------------------|
	*)
	(*Data and PEC signal detected at the same time (perfect match) or PEC signal found without data or with old ones.*)
	            ELSIF (#s_R_TRIG_ParcelFound.Q
	                AND (#s_R_TRIG_PositiveDataFound.Q
	                OR (#iqa_TrackingData[#si_PositionToUpdate] = 0
	                OR #iqa_TrackingData[#si_PositionToUpdate] = #si_LastUpdatedGIN)
	                AND NOT #sx_ParcelWaitEnable))
	            THEN
	                // If the PEC is set as a GIN generation point, skip data detection loop and go to GIN generator.
	                IF (#iUDT_PECUpdateConfiguration.GenerationPoint)
	                THEN
	                    #sx_GenerateGIN := TRUE;
	                    // If the the PEC isn't a generation point, data search loop is enabled.
	                ELSE
	                    #si_GINToWrite := 0;
	                    
	                    // Double data detection loop.
	                    FOR #si_i := #si_PositionToUpdate TO
	                        (#si_PECPosition + (#si_SearchWindow * #si_Direction)) BY #si_Direction DO
	                        
	                        // Data found in a search window.
	                        IF (#iqa_TrackingData[#si_i] > 0)
	                        THEN
	                            // First GIN found.
	                            IF (#si_GINToWrite = 0)
	                            THEN
	                                // Get the GIN if it's different than last updated GIN.
	                                IF #iqa_TrackingData[#si_i] <> #si_LastUpdatedGIN THEN
	                                    #si_GINToWrite := #iqa_TrackingData[#si_i];
	                                    
	                                    // PEC/Data deviation acquisition 
	                                    #"ss_PEC/DataDeviation".Last := DINT_TO_INT(#si_PECPosition - #si_i);
	                                    #"ss_PEC/DataDeviation".GIN := #si_GINToWrite;
	                                    #"ss_PEC/DataDeviation".Sum -= ABS(#"ss_PEC/DataDeviation".Last);
	                                    #"ss_PEC/DataDeviation".Nr += 1;
	                                    IF #"ss_PEC/DataDeviation".Last = 0 THEN
	                                        #"ss_PEC/DataDeviation".Type := 1;
	                                    ELSIF #"ss_PEC/DataDeviation".Last < 0 THEN
	                                        #"ss_PEC/DataDeviation".Type := 2;
	                                    END_IF;
	                                    
	                                    // Parcel aligned statistics
	                                    IF (ABS(#"ss_PEC/DataDeviation".Last) > ABS(#si_Displacement - 1))
	                                    THEN
	                                        #ss_AlignedParcelsCounters.Total += 1;
	                                        #ss_AlignedParcelsCounters.PECNoData += 1;
	                                    END_IF;
	                                END_IF;
	                                // If the first GIN was found, the scan loop conitues to check if there is no other data.
	                            ELSE
	                                // Next found data is different than the first one. Double data detected.
	                                IF (#iqa_TrackingData[#si_i] <> #si_GINToWrite)
	                                THEN
	                                    // First found GIN is marked as a lost one and the GIN is stored in a FIFO register.
	                                    IF ("DB_GIN".GIN[#si_GINToWrite].General.Lost = FALSE)
	                                    THEN
	                                        "DB_GIN".GIN[#si_GINToWrite].General.Lost := TRUE;
	                                        "FC_Fifo"(ic_Mode := 'W',
	                                                  qUDT_Status => #sUDT_LostGINFIFOStatus,
	                                                  qx_Error => #sx_LostGINFIFOError,
	                                                  qx_Warning => #sx_LostGINFIFOWarning,
	                                                  iqv_Data := #si_GINToWrite,
	                                                  iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                                                  iqv_DataBuffer := #iqa_FifoData);
	                                        
	                                        // PEC/Data deviation acquisition 
	                                        #"ss_PEC/DataDeviation".GIN := #si_GINToWrite;
	                                        #"ss_PEC/DataDeviation".Type := 4;
	                                        
	                                        // Update statistics
	                                        #ss_LostParcelsCounters.Total += 1;
	                                        #ss_LostParcelsCounters.DoubleData += 1;
	                                        
	                                        ////////////////////
	                                        
	                                        IF #si_GINToWrite >= 1000 THEN
	                                            #ss_LostValidParcelsCounters.Total += 1;
	                                            #ss_LostValidParcelsCounters.DoubleData += 1;
	                                        END_IF;
	                                        
	                                        ////////////////
	                                        //
	                                    END_IF;
	                                    
	                                    // Second found GIN is marked as a lost one and the GIN is stored in a FIFO register.
	                                    IF ("DB_GIN".GIN[#iqa_TrackingData[#si_i]].General.Lost = FALSE)
	                                    THEN
	                                        "DB_GIN".GIN[#iqa_TrackingData[#si_i]].General.Lost := TRUE;
	                                        "FC_Fifo"(ic_Mode := 'W',
	                                                  qUDT_Status => #sUDT_LostGINFIFOStatus,
	                                                  qx_Error => #sx_LostGINFIFOError,
	                                                  qx_Warning => #sx_LostGINFIFOWarning,
	                                                  iqv_Data := #iqa_TrackingData[#si_i],
	                                                  iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                                                  iqv_DataBuffer := #iqa_FifoData);
	                                        
	                                        // Update statistics
	                                        #ss_LostParcelsCounters.Total += 1;
	                                        #ss_LostParcelsCounters.DoubleData += 1;
	                                        
	                                        ////////////////////
	                                        
	                                        IF #iqa_TrackingData[#si_i] >= 1000 THEN
	                                            #ss_LostValidParcelsCounters.Total += 1;
	                                            #ss_LostValidParcelsCounters.DoubleData += 1;
	                                        END_IF;
	                                        
	                                        ////////////////
	                                        //
	                                    END_IF;
	                                    // Stop search window scan in case of double data detection
	                                    EXIT;
	                                END_IF;
	                            END_IF;
	                        END_IF;
	                    END_FOR;
	                    
	                    // GIN not found in a search window
	                    IF (#si_GINToWrite = 0)
	                    THEN
	                        #sx_GenerateGIN := TRUE;
	                        #si_UnknownParcelsCounters.DataNotFound += 1;
	                    END_IF;
	                    
	                    // Found GIN is a lost one - generate unknown GIN
	                    // Found GIN isn't lost or it's negative - don't do anything
	                    IF (#si_GINToWrite > 0)
	                    THEN
	                        IF ("DB_GIN".GIN[#si_GINToWrite].General.Lost)
	                        THEN
	                            #sx_GenerateGIN := TRUE;
	                            #si_UnknownParcelsCounters.LostParcelFound += 1;
	                        END_IF;
	                    END_IF;
	                END_IF;
	                
	                (*Second parcel has been found during data update. Situation can occur when search window is too short
	                  and the data is shifted. In that case found GIN will be marked as a lost one and new unknown GIN will be 
	                  generated. Negative GIN will be ignored.*)
	            ELSIF (#s_R_TRIG_ParcelFound.Q
	                AND (#iqa_TrackingData[#si_PositionToUpdate] <> 0
	                AND #iqa_TrackingData[#si_PositionToUpdate] <> #si_LastUpdatedGIN)
	                AND NOT #sx_ParcelWaitEnable)
	            THEN
	                IF (#iqa_TrackingData[#si_PositionToUpdate] > 0)
	                THEN
	                    IF ("DB_GIN".GIN[#iqa_TrackingData[#si_PositionToUpdate]].General.Lost = FALSE)
	                    THEN
	                        "DB_GIN".GIN[#iqa_TrackingData[#si_PositionToUpdate]].General.Lost := TRUE;
	                        "FC_Fifo"(ic_Mode := 'W',
	                                  qUDT_Status => #sUDT_LostGINFIFOStatus,
	                                  qx_Error => #sx_LostGINFIFOError,
	                                  qx_Warning => #sx_LostGINFIFOWarning,
	                                  iqv_Data := #iqa_TrackingData[#si_PositionToUpdate],
	                                  iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                                  iqv_DataBuffer := #iqa_FifoData);
	                        
	                        // Update statistics
	                        #ss_LostParcelsCounters.Total += 1;
	                        #ss_LostParcelsCounters.DoubleData += 1;
	                        
	                        ////////////////////
	                        
	                        IF #iqa_TrackingData[#si_PositionToUpdate] >= 1000 THEN
	                            #ss_LostValidParcelsCounters.Total += 1;
	                            #ss_LostValidParcelsCounters.DoubleData += 1;
	                        END_IF;
	                        
	                        ////////////////
	                        //
	                    END_IF;
	                END_IF;
	                
	                // Generate GIN 
	                #sx_GenerateGIN := TRUE;
	                #si_UnknownParcelsCounters.LostParcelFound += 1;
	                
	                (*Second data has been found during data update. Situation can occur when search window is too short
	                  and the data is shifted. In that case found GIN will be marked as a lost one.*)
	            ELSIF (#s_R_TRIG_PositiveDataFound.Q
	                AND #sx_ParcelDetected
	                AND #iqa_TrackingData[#si_PositionToUpdate] <> #si_GINToWrite)
	            THEN
	                // Mark GIN as a lost one
	                IF ("DB_GIN".GIN[#iqa_TrackingData[#si_PositionToUpdate]].General.Lost = FALSE)
	                THEN
	                    "DB_GIN".GIN[#iqa_TrackingData[#si_PositionToUpdate]].General.Lost := TRUE;
	                    "FC_Fifo"(ic_Mode := 'W',
	                              qUDT_Status => #sUDT_LostGINFIFOStatus,
	                              qx_Error => #sx_LostGINFIFOError,
	                              qx_Warning => #sx_LostGINFIFOWarning,
	                              iqv_Data := #iqa_TrackingData[#si_PositionToUpdate],
	                              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                              iqv_DataBuffer := #iqa_FifoData);
	                    
	                    // Update statistics
	                    #ss_LostParcelsCounters.Total += 1;
	                    #ss_LostParcelsCounters.DoubleData += 1;
	                    
	                    ////////////////////
	                    
	                    IF #iqa_TrackingData[#si_PositionToUpdate] >= 1000 THEN
	                        #ss_LostValidParcelsCounters.Total += 1;
	                        #ss_LostValidParcelsCounters.DoubleData += 1;
	                    END_IF;
	                    
	                    ////////////////
	                END_IF;
	            END_IF;
	            
	        END_REGION
	        
	        REGION 10.5 – GIN generator
	            
	            (*Used to generate new GIN. If the PEC position is a generation point, the number is taken from an internal GIN range.
	              If it's not, then GIN is taken from a global unknown GIN range.*)
	            
	            IF (#sx_GenerateGIN)
	            THEN
	                // Generation point.
	                IF (#iUDT_PECUpdateConfiguration.GenerationPoint)
	                THEN
	                    // Generate GIN from a valid GIN range.
	                    IF (#ss_ValidGINRange.GIN <= #ss_ValidGINRange.End)
	                    THEN
	                        #si_GINToWrite := #ss_ValidGINRange.GIN;
	                        #ss_ValidGINRange.GIN += 1;
	                    ELSE
	                        #si_GINToWrite := #ss_ValidGINRange.Start;
	                        #ss_ValidGINRange.GIN := #ss_ValidGINRange.Start + 1;
	                    END_IF;
	                    // Unknown GIN generator.
	                ELSE
	                    // Generate GIN from a unknown GIN range.
	                    IF (#iqUDT_UnknownGINRange.GIN <= #iqUDT_UnknownGINRange.End)
	                    THEN
	                        #si_GINToWrite := #iqUDT_UnknownGINRange.GIN;
	                        #iqUDT_UnknownGINRange.GIN += 1;
	                    ELSE
	                        #si_GINToWrite := #iqUDT_UnknownGINRange.Start;
	                        #iqUDT_UnknownGINRange.GIN := #iqUDT_UnknownGINRange.Start + 1;
	                    END_IF;
	                    
	                    // Unknwn parcels statistics.
	                    #si_UnknownParcelsCounters.Total += 1;
	                END_IF;
	                
	                // Reset generte GIN command.
	                #sx_GenerateGIN := FALSE;
	                
	                // GIN record is cleared with configured default GIN record while it's generated.
	                "DB_GIN".GIN[#si_GINToWrite] := "DB_GINDefault".GIN[#iUDT_PECUpdateConfiguration.DefaultGIN];
	            END_IF;
	            
	            #qi_GINwrite := #si_GINToWrite;
	            
	        END_REGION
	        
	        
	        REGION 10.6 – PEC position data update
	            
	            (*While parcel is detected, calculated GIN is written into the PEC position record.
	              If not, then the record is cleared with 0. Negative GIN is ignored or deleted, depending on configuration.*)
	            
	            IF (#sx_ParcelDetected)
	            THEN
	                
	                "FC_WriteGIN"(ii_GIN := #si_GINToWrite,
	                              ii_PositionToWrite := #si_PositionToUpdate,
	                              ii_NumberOfPositions := 1,
	                              ix_Direction := TRUE,
	                              iqa_TrackingData := #iqa_TrackingData);
	                
	            ELSE
	                IF (#iqa_TrackingData[#si_PositionToUpdate] > 0
	                    OR #iUDT_PECUpdateConfiguration.NegativeGINDelete)
	                THEN
	                    
	                    "FC_WriteGIN"(ii_GIN := #ci_ZeroGIN,
	                                  ii_PositionToWrite := #si_PositionToUpdate,
	                                  ii_NumberOfPositions := 1,
	                                  ix_Direction := TRUE,
	                                  iqa_TrackingData := #iqa_TrackingData);
	                    
	                END_IF;
	            END_IF;
	            
	        END_REGION
	        
	        REGION 10.7 – Parcel waiting logic
	            
	            (*Parcel waiting logic is used to wait for the photoeye signal for a search window distance.*)
	            IF (#sx_ParcelWaitEnable)
	            THEN
	                // Counting parcel wait distance depending on conveyor running direction if not detected.
	                IF (NOT #sx_ParcelDetected)
	                THEN
	                    IF (#si_Direction = 1)
	                    THEN
	                        #si_ParcelWaitDistance += 1;
	                        
	                    ELSE
	                        #si_ParcelWaitDistance -= ABS(#si_Displacement);   //1;
	                    END_IF;
	                    
	                    // Parcel detected - stop waiting, use found GIN to update.   
	                ELSE
	                    // PEC/Data deviation acquisition
	                    #"ss_PEC/DataDeviation".Type := 3;
	                    #"ss_PEC/DataDeviation".Last := #si_ParcelWaitDistance;
	                    #"ss_PEC/DataDeviation".GIN := #si_GINToWrite;
	                    #"ss_PEC/DataDeviation".Sum += ABS(#"ss_PEC/DataDeviation".Last);
	                    #"ss_PEC/DataDeviation".Nr += 1;
	                    
	                    
	                    // Parcel aligned statistics
	                    IF (#"ss_PEC/DataDeviation".Last > ABS(#si_Displacement - 1))
	                    THEN
	                        #ss_AlignedParcelsCounters.Total += 1;
	                        #ss_AlignedParcelsCounters.DataNoPEC += 1;
	                    END_IF;
	                    
	                    // Parcel waiting logic reset.
	                    #sx_ParcelWaitEnable := FALSE;
	                    #si_ParcelWaitDistance := 0;
	                END_IF;
	            END_IF;
	            
	            // Parcel not found in a search window - stop waiting, mark found GIN as a lost one.
	            IF (ABS(#si_ParcelWaitDistance) = #si_SearchWindow)
	                AND (#si_GINToWrite > 0)
	            THEN
	                // Parcel lost
	                IF "DB_GIN".GIN[#si_GINToWrite].General.Lost = FALSE THEN
	                    "DB_GIN".GIN[#si_GINToWrite].General.Lost := TRUE;
	                    "FC_Fifo"(ic_Mode := 'W',
	                              qUDT_Status => #sUDT_LostGINFIFOStatus,
	                              qx_Error => #sx_LostGINFIFOError,
	                              qx_Warning => #sx_LostGINFIFOWarning,
	                              iqv_Data := #si_GINToWrite,
	                              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                              iqv_DataBuffer := #iqa_FifoData);
	                    
	                    // PEC/Data deviation acquisition
	                    #"ss_PEC/DataDeviation".Type := 5;
	                    #"ss_PEC/DataDeviation".Last := #si_ParcelWaitDistance;
	                    #"ss_PEC/DataDeviation".GIN := #si_GINToWrite;
	                    #"ss_PEC/DataDeviation".Sum += ABS(#"ss_PEC/DataDeviation".Last);
	                    #"ss_PEC/DataDeviation".Nr += 1;
	                    
	                    // Parcel waiting logic reset.
	                    #si_ParcelWaitDistance := 0;
	                    #sx_ParcelWaitEnable := FALSE;
	                    
	                    // Lost parcels ina  row counter.
	                    #si_LostParcelsInARow += 1;
	                    
	                    // Update statistics.
	                    #ss_LostParcelsCounters.Total += 1;
	                    #ss_LostParcelsCounters.ParcelNotFound += 1;
	                    
	                    ////////////////////
	                    
	                    IF #si_GINToWrite >= 1000 THEN
	                        #ss_LostValidParcelsCounters.Total += 1;
	                        #ss_LostValidParcelsCounters.ParcelNotFound += 1;
	                    END_IF;
	                    
	                    ////////////////
	                    //
	                END_IF;
	                
	            END_IF;
	            
	            // Reset monitoring in case of going backwards.
	            IF (#si_ParcelWaitDistance = 0
	                AND NOT #sx_ParcelDetected
	                AND #sx_InvalidDirection)
	            THEN
	                #sx_ParcelWaitEnable := FALSE;
	            END_IF;
	            
	            #sx_InvalidDirection := ((#si_Direction = 1
	            AND #si_ParcelWaitDistance < 0)
	            OR (#si_Direction = -1
	            AND #si_ParcelWaitDistance > 0));
	            
	        END_REGION
	        
	        REGION 10.8 – Last updated GIN
	            
	            (*Last updated GIN to avoid processing the same data.*)
	            IF (#s_R_TRIG_DataFound.Q)
	            THEN
	                #si_LastUpdatedGIN := #iqa_TrackingData[#si_PositionToUpdate];
	            END_IF;
	            
	        END_REGION
	        
	        REGION 10.8 – Update displacement
	            
	            #si_Displacement := #si_Displacement - #si_Direction;
	            
	        END_REGION
	        
	    END_WHILE;
	    
	END_REGION
	
	REGION 11 – Length measurement
	    
	    
	    
	    (*Length and gap measurements can be enabled via PEC update configuration*)
	    #sFB_LengthMeasurement(ii_PECPosition := #si_PECPosition,
	                           ii_Displacement := #iqUDT_ConveyorInterface.Displacement,
	                           ix_LengthMeasurementEnable := #iUDT_PECUpdateConfiguration.ParcelLengthMeasurement OR #sx_LengthMeasurementEnable,
	                           ix_GapMeasurementEnable := #iUDT_PECUpdateConfiguration.GapLengthMeasurement,
	                           iqa_TrackingData := #iqa_TrackingData);
	    
	    IF #iqa_TrackingData[#si_PECPosition] > 0
	        AND #iqa_TrackingData[#si_PECPosition] >= #iqUDT_UnknownGINRange.Start
	        AND #iqa_TrackingData[#si_PECPosition] <= #iqUDT_UnknownGINRange.End
	    THEN
	        
	        #sx_LengthMeasurementEnable := "DB_GIN".GIN[#iqa_TrackingData[#si_PECPosition]].General.Length = 0;
	    ELSE
	        
	        #sx_LengthMeasurementEnable := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 12 – Teaching done 
	    
	    // Average slip calculation
	    #si_AverageSlip := #"ss_PEC/DataDeviation".Sum / #"ss_PEC/DataDeviation".Nr;
	    #si_CalculatedLengthCorrection := DINT_TO_INT(#iUDT_ConveyorCommonConfiguration.LengthCorrection) + #si_AverageSlip * 10;
	    IF (#sx_TeachingMode                                                                                                            // Teaching mode enabled 
	        AND #si_NumberOfTeachedParcels = #iUDT_PECUpdateConfiguration.NrOfTeachParcels)                                                 // Number of teaching parcels equal to the preset one                                                                                                                                                              // Teaching mode enabled ("sx_TeachMode") 
	    THEN
	        
	        #si_CalculatedLengthCorrection := DINT_TO_INT(#iUDT_ConveyorCommonConfiguration.LengthCorrection) + #si_AverageSlip * 10;
	        #sx_TeachingMode := FALSE;
	        #si_NumberOfTeachedParcels := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 13 – Performance    
	    
	    (*Performnce is a percentage ratio between number of lost parcels and total number of data, used to monitor data update efficiency.*)
	    
	    IF (#sdi_TotalNumberOfData >= #ss_LostParcelsCounters.Total
	        AND #sdi_TotalNumberOfData > 0)
	    THEN
	        #slr_Performance := 100.0 - INT_TO_LREAL(#ss_LostParcelsCounters.Total) / #sdi_TotalNumberOfData * 100.0;
	    END_IF;
	    
	    // Warning is generated if performance drops below 80%.
	    #qUDT_Status.LowPerformance := #slr_Performance < 80;
	    
	END_REGION
	
	REGION 14 – Reset statistics
	    
	    // Statistics are reset if reset signal is given.
	    IF #iqUDT_ConveyorInterface.ResetStatistics
	    THEN
	        #sdi_TotalNumberOfParcels := 0;
	        #ss_AlignedParcelsCounters.Total := 0;
	        #ss_AlignedParcelsCounters.PECNoData := 0;
	        #ss_AlignedParcelsCounters.DataNoPEC := 0;
	        #ss_LostParcelsCounters.Total := 0;
	        #ss_LostParcelsCounters.DoubleData := 0;
	        #ss_LostParcelsCounters.ParcelNotFound := 0;
	        #ss_LostValidParcelsCounters.Total := 0;
	        #ss_LostValidParcelsCounters.DoubleData := 0;
	        #ss_LostValidParcelsCounters.ParcelNotFound := 0;
	        #sdi_TotalNumberOfData := 0;
	        #si_UnknownParcelsCounters.Total := 0;
	        #si_UnknownParcelsCounters.LostParcelFound := 0;
	        #si_UnknownParcelsCounters.DataNotFound := 0;
	        #"ss_PEC/DataDeviation".Sum := 0;
	        #"ss_PEC/DataDeviation".Nr := 0;
	        #slr_Performance := 100;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 15 – Too many lost parcels error
	    
	    (*Error is generated if too many parcels will is marked as a lost one in a row*)
	    IF (#si_LostParcelsInARow >= #iUDT_PECUpdateConfiguration.MaxLost)
	    THEN
	        #qUDT_Status.TooManyLost := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 16 – Statistics
	    
	    // Too many lost
	    #s_R_TRIG_TooManyLost(CLK := #qUDT_Status.TooManyLost);
	    IF #qUDT_Status.TooManyLost
	        OR #iqUDT_ConveyorInterface.ResetStatistics
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #qUDT_Status.TooManyLost,
	                        ix_RTrigActivate := #s_R_TRIG_TooManyLost.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.TooManyLost);
	    END_IF;
	    
	    // Total number of parcels
	    #iqUDT_Statistics.TotalNrOfParcels := #sdi_TotalNumberOfParcels;
	    
	END_REGION
	
	REGION 17 – Internal tracking warning and error
	    
	    // Internal tracking warning
	    IF (#qUDT_Status.LowPerformance
	        OR #sx_LostGINFIFOWarning)
	    THEN
	        #iqUDT_ConveyorInterface.InternalWarningTracking := TRUE;
	    END_IF;
	    
	    // Internal tracking error
	    IF #qUDT_Status.TooManyLost
	    THEN
	        #iqUDT_ConveyorInterface.InternalErrorTracking := TRUE;
	    END_IF;
	    
	    // Configuration error
	    IF (#sx_InvalidDisplacement
	        OR #sx_InvalidGINRange
	        OR #sx_InvalidSearchWindow)
	    THEN
	        #iqUDT_ConveyorInterface.ConfigurationError := TRUE;
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_CaljanV2"
TITLE = FB_Unloader
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : Equimpent
VERSION : 1.2
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 201
// END_ATTRIBUTES
//Function block to control unloader.
   VAR_INPUT 
      iUDT_CaljanConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CaljanConfigurationV2";   // Caljan configuration structure
      iUDT_CaljanReceive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CaljanReceiveV2";   // Caljan receive structure
      ix_SafetyReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Safety reset
      ix_SafetyOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when Safety Circuit of the Conveyor is healthy
      ix_24vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 24VDC is healthy
      ix_400vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 400VAC is healthy
      ix_HardwareOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when the PN node(s) are ok
      ix_ExternalRequestDieBack { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External request die back
      ix_ExternalRequestHold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External request hold
      ix_ExternalRunReverse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External request only for unloder mode - TRUE when conveyor should run in reverse direction
      ix_ResetEnergySave { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset energy save mode timer
      ix_SimulationModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when simulation mode is active
      ix_CaljanMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Choosing device 1=loader, 2=unloader
      ix_BufferPEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Buufer PEC
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CaljanStatusV2";   // HMI status structure
      qUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   // Common status structure
      qUDT_CaljanSend { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CaljanSendV2";   // Caljan send structure
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
      iqUDT_CaljanCommand : "UDT_CaljanCommand";   // Caljan HMI control
      iqUDT_ConveyorInterface : "UDT_ConveyorInterface";   // Interface structure
      iqUDT_HandShake : "UDT_ConveyorHandshake";   // Handshake structure
      iqUDT_HandShakeUp : "UDT_ConveyorHandshake";   // Upstream handshake structure
      iqUDT_Statistics : "UDT_CaljanStatisticsV2";   // Statistics structure
   END_VAR

   VAR 
      s_FB_ResetPulseTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer on/off delay for reset pulse
      s_FB_CascadeModeTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer on/off delay for cascade mode
      s_FB_TimerOnOffDelayCheck24V { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer on/off delay to allow startup before fault is generated
      s_FB_TimerOnOffDelayCheck400V { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer on/off delay to allow startup before fault is generated
      s_UDT_CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Common status structure
      s_UDT_CommonStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Auxiliary status structure
      s_UDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CaljanStatusV2";   // HMI status structure
      s_UDT_PNDevice { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PNDevice";   // PN device info structure
      sa_PNPortsStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..8] of Bool;   // TRUE when specific port has an error
      R_TRIG_EnergySave {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for energy save
      R_TRIG_ConveyorUp {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge of automatic active
      R_TRIG_ConveyorDown {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge of automatic not active
      R_TRIG_NotHealthy {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger if extendable not healthy
      R_TRIG_SafetyOk {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger safety is ok
      s_R_TRIG_PNSlaveError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for PN error
      s_R_TRIG_PNSlaveNotOnline {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for PN not online
      s_R_TRIG_ResetEnergySaveRunMode {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger reset energy save mode
      s_R_TRIG_ResetEnergySaveBufferMode {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger reset energy save mode
      s_R_TRIG_ResetEnergySaveActive {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger reset energy save mode
   END_VAR
   VAR RETAIN
      sdi_EnergySave { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Energy save displacement
   END_VAR
   VAR 
      sx_Disabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Operation is enabled
      sx_Ready { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor Ready to operate in Forward mode
      sx_EnergySaveActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Active energy save mode
      sx_AutomaticActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Forward active
      sx_CascadeStartUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Cascade startup auxiliary bit
      sx_24VOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 24V ok
      sx_400VOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 400V ok
   END_VAR

   VAR CONSTANT 
      ci_NumberOfProfinetPorts : Int := 2;   // Number of Profinet ports in device
      ci_PowerSupplyDelayTime : UInt := 4000;   // Power supply delay time
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------
	
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	07/03/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	20/12/2023  | 1.1       | M. Diebel    | Update 
	20/12/2023  | 1.2       | L.Klar       | Energy save mode added
	05/02/20234 | 1.3       | P.Gryszczyk  | Added HardwareOk to Profinet faults reset
	05/02/20234 | 1.4       | L.Klar       | Added dieback condition to unload function
	07/02/20234 | 1.5       | L.Klar       | Buffer mode corrected
	09/02/2024  | 1.6       | P.Gryszczyk  | Changed logic for BufferPEC when using Caljan sensor
	*)
	
	REGION 1 - Get Device Profinet information
	    
	    "FC_GetDevicePN"(is_PNDeviceName := #iUDT_CaljanConfiguration.PNDeviceName,
	                     ix_SimulationModeActive := #ix_SimulationModeActive,
	                     iqUDT_PND := #s_UDT_PNDevice);
	    
	    "FC_GetPNPortStatus"(ii_NumberOfPorts := #ci_NumberOfProfinetPorts,
	                         iUDT_DevicePNInfo := #s_UDT_PNDevice,
	                         qa_PortFault => #sa_PNPortsStatus);
	    
	END_REGION
	
	REGION 2 - Initial
	    
	    REGION 2.1 - First PLC cycle
	        
	        IF "DB_Memory".FirstScan
	        THEN
	            #sx_AutomaticActive := FALSE;
	            #iqUDT_HandShakeUp.RTR := FALSE;
	            #iqUDT_HandShakeUp.CascadeStartUp := FALSE;
	            #sx_Disabled := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 2.2 - Triggers
	        
	        // Rising edge trigger energy save
	        #R_TRIG_EnergySave(CLK := #s_UDT_CommonStatus.EnergySave);
	        
	        // Rising edge extendable up
	        #R_TRIG_ConveyorUp(CLK := #sx_AutomaticActive AND #sx_Ready);
	        
	        // Rising edge extendable down
	        #R_TRIG_ConveyorDown(CLK := #sx_AutomaticActive AND NOT #sx_Ready);
	        
	        // Rising edge extendable not healthy 
	        #R_TRIG_NotHealthy(CLK := #s_UDT_HMIStatus.Specific.NotHealthy);
	        
	        // Rising edge for Profinet error
	        #s_R_TRIG_PNSlaveError(CLK := #s_UDT_HMIStatus.Specific.PNSlaveError);
	        
	        // Rising edge for Profinet not online
	        #s_R_TRIG_PNSlaveNotOnline(CLK := #s_UDT_HMIStatus.Specific.PNSlaveNotOnline);
	        
	        // Rising edge for reset energy save mode
	        
	        #s_R_TRIG_ResetEnergySaveRunMode(CLK := #iUDT_CaljanReceive.RunModeActivated);
	        #s_R_TRIG_ResetEnergySaveBufferMode(CLK := #iUDT_CaljanReceive.StoreModeActivated);
	        #s_R_TRIG_ResetEnergySaveActive(CLK := #sx_EnergySaveActive);
	        
	        
	    END_REGION
	    
	    REGION 2.3 - HMI button Disable operation
	        
	        // Copy HMI command to static memory
	        #sx_Disabled := #iqUDT_CaljanCommand.Disable;
	        
	        // Copy status to HMI
	        #s_UDT_HMIStatus.Specific.Disabled := #sx_Disabled;
	        
	    END_REGION
	    
	    REGION 2.6 - Timers 
	        
	        // Hardware will only be available after the delay, so the device has time for the initialisation
	        #s_FB_TimerOnOffDelayCheck24V(iudi_OnDelayTime := #ci_PowerSupplyDelayTime,
	                                      ix_SignalToDelay := #ix_24vOk,
	                                      qx_DelayedSignal => #sx_24VOk);
	        
	        #s_FB_TimerOnOffDelayCheck400V(iudi_OnDelayTime := #ci_PowerSupplyDelayTime,
	                                       ix_SignalToDelay := #ix_400vOk,
	                                       qx_DelayedSignal => #sx_400VOk);
	        
	    END_REGION
	    
	END_REGION
	
	REGION 3 - Reset Profinet errors 
	    
	    IF #iqUDT_EquipmentControl.Command.Reset OR (NOT #ix_HardwareOK AND #s_UDT_HMIStatus.Specific.PNSlaveNotOnline) THEN
	        
	        #s_UDT_HMIStatus.Specific.PNSlaveNotOnline := FALSE;
	        #s_UDT_HMIStatus.Specific.PNSlaveError := FALSE;
	        #s_UDT_HMIStatus.Specific.PNSlaveWarning := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Errors
	    
	    // Check if PN device is online
	    IF NOT "DB_ProfinetDiagnostic".ProfinetNetworks[#s_UDT_PNDevice.PNNetworknumber].DeviceStatus[#s_UDT_PNDevice.PNDeviceNumber].DeviceState.Exist
	        AND NOT #ix_SimulationModeActive
	        AND #sx_24VOk
	        AND #ix_HardwareOK
	    THEN
	        #s_UDT_HMIStatus.Specific.PNSlaveNotOnline := TRUE;
	        
	    END_IF;
	    
	    // Check if PN ports are healthy 
	    IF #sa_PNPortsStatus[1] XOR #sa_PNPortsStatus[2] THEN
	        #s_UDT_HMIStatus.Specific.PNSlaveWarning := TRUE;
	    END_IF;
	    
	    // Check if PN device has an error
	    IF "DB_ProfinetDiagnostic".ProfinetNetworks[#s_UDT_PNDevice.PNNetworknumber].DeviceStatus[#s_UDT_PNDevice.PNDeviceNumber].DeviceState.Error
	        AND NOT #ix_SimulationModeActive
	        AND #sx_24VOk
	        AND NOT #s_UDT_HMIStatus.Specific.PNSlaveWarning
	        AND #ix_HardwareOK
	    THEN
	        #s_UDT_HMIStatus.Specific.PNSlaveError := TRUE;
	    END_IF;
	    
	    // Not healthy
	    #s_UDT_HMIStatus.Specific.NotHealthy := NOT #iUDT_CaljanReceive.Healthy
	    AND #sx_400VOk
	    AND #sx_24VOk
	    AND #ix_HardwareOK
	    AND #ix_SafetyOk;
	    
	    // Common Error
	    #s_UDT_CommonStatus.Error := NOT #sx_24VOk
	    OR NOT #sx_400VOk
	    OR NOT #ix_HardwareOK
	    OR NOT #ix_SafetyOk
	    OR #s_UDT_HMIStatus.Specific.PEC_EoS.Jam
	    OR #s_UDT_HMIStatus.Specific.NotHealthy;
	    
	    
	END_REGION
	
	REGION 5 - Speed
	    
	    #iqUDT_ConveyorInterface.ActualSpeed := #iUDT_CaljanReceive.ActualSpeed;
	    
	END_REGION
	
	REGION 6 - Check conditions to set caljan ready    
	    
	    #sx_Ready := NOT #s_UDT_CommonStatus.Error;
	    
	END_REGION
	
	REGION 7 - Stop caljan
	    
	    IF NOT #iqUDT_EquipmentControl.Command.AutomaticOn
	        OR #s_UDT_CommonStatus.Error
	    THEN
	        #sx_AutomaticActive := FALSE;
	        #qUDT_CaljanSend.AllowLoading := FALSE;
	        #qUDT_CaljanSend.AllowUnloading := FALSE;
	        #iqUDT_HandShakeUp.RTR := FALSE;
	        #iqUDT_HandShakeUp.CascadeStartUp := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 8 - Start automatic mode  
	    
	    // If start (one shot) is received from system, this is memorised until started in cascade. Later the unloader is started
	    IF #iqUDT_EquipmentControl.Command.Start
	        AND #sx_Ready
	    THEN
	        #sx_AutomaticActive := TRUE;
	    END_IF;
	    
	    //Timer to cascade mode
	    #s_FB_CascadeModeTimer(iudi_OnDelayTime := #iUDT_CaljanConfiguration.CascadeTimeOnDelay,
	                           ix_SignalToDelay := #sx_AutomaticActive,
	                           ix_Enable := #sx_Ready,
	                           qx_DelayedSignal => #sx_CascadeStartUp);
	    
	    #iqUDT_HandShakeUp.CascadeStartUp := #sx_CascadeStartUp;
	    
	    //Automatic mode active
	    #qUDT_CaljanSend.Enable := #sx_AutomaticActive AND NOT #s_R_TRIG_ResetEnergySaveActive.Q;
	    
	END_REGION
	
	REGION 9 - Automatic mode active
	    
	    REGION 9.1 - Operation
	        
	        (* *******LOADER ******** *)
	        IF #ix_CaljanMode = 1 THEN
	            
	            // Release loading
	            #qUDT_CaljanSend.AllowLoading := #sx_AutomaticActive
	            AND #sx_Ready
	            AND NOT #sx_Disabled
	            AND NOT #ix_ExternalRequestHold
	            AND NOT #sx_EnergySaveActive
	            AND (#iUDT_CaljanReceive.RunModeActivated OR #iUDT_CaljanReceive.StoreModeActivated);
	            
	            #iqUDT_HandShakeUp.RTR := #qUDT_CaljanSend.AllowLoading AND ABS(#iUDT_CaljanReceive.ActualSpeed) > 400;
	            
	        END_IF;
	        
	        (* *******UNLOADER ******** *)
	        IF #ix_CaljanMode = 2
	        THEN
	            
	            // Release unloading
	            #qUDT_CaljanSend.AllowUnloading := #sx_AutomaticActive
	            AND #sx_Ready
	            AND (#iqUDT_HandShake.RTR OR #iUDT_CaljanReceive.PECUnloader)
	            AND NOT #sx_Disabled
	            AND NOT #ix_ExternalRequestHold
	            AND NOT #sx_EnergySaveActive
	            AND NOT #ix_ExternalRunReverse;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 9.2 - Energy save
	        
	        IF #iUDT_CaljanConfiguration.Energy THEN
	            
	            
	            IF #sdi_EnergySave >= #iUDT_CaljanConfiguration.EnergySaveLenght        // Compare energy save counter with configured lenght
	            THEN
	                #sx_EnergySaveActive := TRUE;                                           // Set energy save active true
	            END_IF;
	            
	            (* *******LOADER ******** *)
	            // Reset 
	            IF (#ix_CaljanMode = 1
	                AND (NOT #iUDT_CaljanReceive.PECUnloader
	                OR NOT #iUDT_CaljanReceive.PECLoader)
	                AND NOT #sx_EnergySaveActive)
	                OR #ix_ResetEnergySave
	                OR #iqUDT_HandShakeUp.RTS
	                OR #iqUDT_HandShakeUp.ResetEnergySave
	                OR NOT #iqUDT_EquipmentControl.Command.AutomaticOn
	                OR #s_R_TRIG_ResetEnergySaveBufferMode.Q
	                OR #s_R_TRIG_ResetEnergySaveRunMode.Q
	            THEN
	                #sx_EnergySaveActive := FALSE;
	                #sdi_EnergySave := 0;
	                
	                (* *******UNLOADER ******** *)
	            ELSIF (#ix_CaljanMode = 2
	                AND (NOT #iUDT_CaljanReceive.PECUnloader
	                OR NOT #iUDT_CaljanReceive.PECLoader)
	                AND NOT #sx_EnergySaveActive)
	                OR #ix_ResetEnergySave
	                OR #s_R_TRIG_ResetEnergySaveBufferMode.Q
	                OR #s_R_TRIG_ResetEnergySaveRunMode.Q
	            THEN
	                #sx_EnergySaveActive := FALSE;
	                #sdi_EnergySave := 0;
	                
	            ELSE
	                
	                #sdi_EnergySave += ABS(#iqUDT_ConveyorInterface.Displacement);
	                
	            END_IF;
	        ELSE
	            
	            #sx_EnergySaveActive := FALSE;
	            #sdi_EnergySave := 0;
	            
	        END_IF;
	        
	        IF #sx_AutomaticActive
	        THEN
	            #iqUDT_HandShake.ResetEnergySave := NOT #iUDT_CaljanReceive.PECUnloader AND NOT #sx_EnergySaveActive;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 9.3 Buffer PEC
	        
	        IF #iUDT_CaljanConfiguration.BufferPEC THEN
	            
	            #qUDT_CaljanSend.BufferPEC := #ix_BufferPEC;
	            
	        ELSE
	            //When in store mode we using Caljan's Unloader PEC the state TRUE,
	            //means there is a parcel on sensor and Caljan runs to rising edge of BufferPEC and 300MS longer
	            
	            #qUDT_CaljanSend.BufferPEC := NOT #iUDT_CaljanReceive.PECUnloader;
	            
	        END_IF;
	        
	    END_REGION
	    
	    
	END_REGION
	
	REGION 10 - Reverse run
	    
	    IF #ix_CaljanMode = 2 THEN
	        
	        #qUDT_CaljanSend.JogReverseCommand := #ix_ExternalRunReverse;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 11 - Reset
	    
	    // Safety ok extended pulse
	    #R_TRIG_SafetyOk(CLK := #ix_SafetyReset);
	    
	    #s_FB_ResetPulseTimer(iudi_OffDelayTime := #iUDT_CaljanConfiguration.ResetDelay,
	                          ix_SignalToDelay := #R_TRIG_SafetyOk.Q);
	    
	    // Send reset signal to Caljan 
	    #qUDT_CaljanSend.Reset := #ix_SafetyReset OR #iqUDT_EquipmentControl.Command.Reset OR #s_FB_ResetPulseTimer.qx_DelayedSignal;
	    
	END_REGION
	
	REGION 12 - Status
	    
	    //Status
	    #s_UDT_HMIStatus.Specific.StoreMode := #iUDT_CaljanReceive.StoreModeActivated;
	    #s_UDT_HMIStatus.Specific.RunMode := #iUDT_CaljanReceive.RunModeActivated;
	    #s_UDT_HMIStatus.Specific.LowerOngoing := #iUDT_CaljanReceive.LowerOngoing;
	    #s_UDT_HMIStatus.Specific.RaisingOngoing := #iUDT_CaljanReceive.RaisingOngoing;
	    #s_UDT_HMIStatus.Specific.ChuteBlocked := #iUDT_CaljanReceive.ChuteBlockedActivated;
	    
	    //Status
	    #s_UDT_CommonStatus.Stopped := NOT #sx_AutomaticActive;
	    #s_UDT_CommonStatus.Running := (#iUDT_CaljanReceive.BeltDirection_Unloading OR #iUDT_CaljanReceive.BeltDirection_Loading);
	    #s_UDT_CommonStatus.AutoON := #sx_Ready AND #sx_AutomaticActive;
	    #s_UDT_CommonStatus.Halted := #ix_ExternalRequestHold AND #s_UDT_CommonStatus.AutoON AND NOT #sx_EnergySaveActive;
	    #s_UDT_CommonStatus.Dieback := (NOT #iqUDT_HandShake.RTR OR #ix_ExternalRequestDieBack) AND #s_UDT_CommonStatus.AutoON AND NOT #sx_EnergySaveActive
	    AND NOT #s_UDT_CommonStatus.EnergySave AND NOT #s_UDT_CommonStatus.Running;
	    
	    #s_UDT_CommonStatus.EnergySave := #sx_EnergySaveActive;
	    #s_UDT_CommonStatus.SafetyStop := NOT #ix_SafetyOk;
	    
	    // HMI status update on change
	    IF #s_UDT_CommonStatusOld <> #s_UDT_CommonStatus
	    THEN
	        // HMI status initialization
	        #s_UDT_HMIStatus.Status := 0;
	        
	        // Running
	        IF #s_UDT_CommonStatus.Running
	        THEN
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Running;
	        END_IF;
	        
	        // AutoON
	        IF #s_UDT_CommonStatus.AutoON
	        THEN
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".AutoON;
	        END_IF;
	        
	        // Stopped
	        IF #s_UDT_CommonStatus.Stopped
	        THEN
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Stopped;
	        END_IF;
	        
	        // Energy save
	        IF #s_UDT_CommonStatus.EnergySave
	        THEN
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".EnergySave;
	        END_IF;
	        
	        // Dieback
	        IF #s_UDT_CommonStatus.Dieback
	        THEN
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Dieback;
	        END_IF;
	        
	        // Halted
	        IF #s_UDT_CommonStatus.Halted
	        THEN
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Halted;
	        END_IF;
	        
	        //  PEC error
	        IF #s_UDT_HMIStatus.Specific.PEC_EoS.Jam
	        THEN
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".PECJam;
	        END_IF;
	        
	        // Not healthy
	        IF #s_UDT_HMIStatus.Specific.NotHealthy
	        THEN
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".VFDNotHealthy;
	        END_IF;
	        
	        // Safety stop
	        IF #s_UDT_CommonStatus.SafetyStop
	        THEN
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".SafetyStop;
	        END_IF;
	        
	        // Copy statuses
	        
	        #s_UDT_CommonStatusOld := #s_UDT_CommonStatus;
	        #qUDT_Status := #s_UDT_CommonStatus;
	    END_IF;
	    
	    #qUDT_HMIStatus := #s_UDT_HMIStatus;
	    
	END_REGION
	
	REGION 13 - Statistics
	    
	    // Up time
	    IF #sx_AutomaticActive
	        AND #sx_Ready
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sx_AutomaticActive AND #sx_Ready,
	                        ix_RTrigActivate := #R_TRIG_ConveyorUp.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.ExtendableUpTime);
	    END_IF;
	    
	    // Down time
	    IF NOT #sx_AutomaticActive
	        AND #sx_Ready
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := NOT #sx_AutomaticActive AND #sx_Ready,
	                        ix_RTrigActivate := #R_TRIG_ConveyorDown.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.ExtendableDownTime);
	    END_IF;
	    
	    // Energy save mode active
	    IF #sx_EnergySaveActive
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #s_UDT_CommonStatus.EnergySave,
	                        ix_RTrigActivate := #R_TRIG_EnergySave.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.EnergySave);
	    END_IF;
	    
	    // Not healthy
	    IF #s_UDT_HMIStatus.Specific.NotHealthy
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #s_UDT_HMIStatus.Specific.NotHealthy,
	                        ix_RTrigActivate := #R_TRIG_NotHealthy.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.NotHealthy);
	    END_IF;
	    
	    // PN Slave not online
	    IF #iqUDT_EquipmentControl.Command.ResetData OR #s_UDT_HMIStatus.Specific.PNSlaveNotOnline
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #s_UDT_HMIStatus.Specific.PNSlaveNotOnline,
	                        ix_RTrigActivate := #s_R_TRIG_PNSlaveNotOnline.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.PNNodeNotOnline);
	    END_IF;
	    
	    // PN Slave error
	    IF #iqUDT_EquipmentControl.Command.ResetData OR #s_UDT_HMIStatus.Specific.PNSlaveError
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #s_UDT_HMIStatus.Specific.PNSlaveError,
	                        ix_RTrigActivate := #s_R_TRIG_PNSlaveError.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.PNNodeError);
	    END_IF;
	    
	END_REGION
	
	REGION 14 - Report to control block
	    
	    "FC_EquipmentReport"(iUDT_Status := #s_UDT_CommonStatus,
	                         iqUDT_Control := #iqUDT_EquipmentControl);
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_PNNode"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 224
// END_ATTRIBUTES
   VAR_INPUT 
      is_PNNodeDeviceName { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   //   Name of the slave device
      ix_24VOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when 24VDC is healthy
      ix_SimulationModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when simulation mode active
      ix_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when  hardware is Ok
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PNNodeStatus";   //   HMI status structure
      qUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   //   Common status structure
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   //   Equipment control structure
      iqUDT_Statistics : "UDT_PNNodeStatistics";   //   Statistics structure
   END_VAR

   VAR 
      sUDT_CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //   Common status structure
      sUDT_CommonStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //   Common status structure
      sUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PNNodeStatus";   //   HMI status structure
      s_DT_PNDevice { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PNDevice";   //   PN device info structure
      sa_PNPortsStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..8] of Bool;   // TRUE when specific port has an error
      sFB_TimerOnOffDelayCheckSupply { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //   MHS "TimerOnOffDelay" - to delay time for VFD supply contactor
      sR_TRIG_PNSlaveNotOnline {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge for trigger Profinet slave not online statistics
      sR_TRIG_PNSlaveError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge for trigger Profinet slave error statistics
      sx_PowerOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   True = External Power OK
   END_VAR

   VAR CONSTANT 
      ci_PowerSupplyDelayTime : UInt := 4000;   //   Power supply delay time
      ci_NumberOfProfinetPorts : Int := 2;   // Number of Profinet ports in device
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	28/01/2020  | 3.0       | M. Kurpiers   | first release MHS TIA 15.1
	21/04/2020  | 3.1       | S. Theocharis | renamed to PN Node
	09/07/2020  | 3.2       | S.Theocharis  | Bug fix in status update. Initialize static status instead output status
	03/11/2020  | 3.5       | K.Pokorski    | Profinet ports diagnostics added 
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	REGION 1 - Get Device Profinet information
	    
	    "FC_GetDevicePN"(is_PNDeviceName := #is_PNNodeDeviceName,
	                     ix_SimulationModeActive := #ix_SimulationModeActive,
	                     iqUDT_PND := #s_DT_PNDevice);
	    
	    
	    "FC_GetPNPortStatus"(ii_NumberOfPorts := #ci_NumberOfProfinetPorts,
	                         iUDT_DevicePNInfo := #s_DT_PNDevice,
	                         qa_PortFault => #sa_PNPortsStatus);
	    
	END_REGION
	
	REGION 2 - Reset errors
	    
	    // Reset Profinet Slave error/not online  
	    IF #iqUDT_EquipmentControl.Command.Reset
	    THEN
	        
	        #sUDT_HMIStatus.Specific.PNSlaveNotOnline := FALSE;
	        #sUDT_HMIStatus.Specific.PNSlaveError := FALSE;
	        #sUDT_HMIStatus.Specific.PNSlaveWarning := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Update PN slave device status
	    
	    // Hardware will only be available after the delay, so the device has time for the initialisation
	    #sFB_TimerOnOffDelayCheckSupply(iudi_OnDelayTime := #ci_PowerSupplyDelayTime,
	                                    ix_SignalToDelay := #ix_24VOk,
	                                    qx_DelayedSignal => #sx_PowerOk);
	    
	    
	    // Check if PN device is online
	    IF (NOT "DB_ProfinetDiagnostic".ProfinetNetworks[#s_DT_PNDevice.PNNetworknumber].DeviceStatus[#s_DT_PNDevice.PNDeviceNumber].DeviceState.Exist
	        OR NOT #s_DT_PNDevice.PNDeviceFound)
	        AND #sx_PowerOk
	        AND NOT #ix_SimulationModeActive
	    THEN
	        
	        #sUDT_HMIStatus.Specific.PNSlaveNotOnline := TRUE;
	        
	    END_IF;
	    
	    // Check if PN ports are healthy 
	    IF #sa_PNPortsStatus[1] XOR #sa_PNPortsStatus[2] THEN
	        #sUDT_HMIStatus.Specific.PNSlaveWarning := TRUE;
	    END_IF;
	    
	    // Check if PN device has an error
	    IF "DB_ProfinetDiagnostic".ProfinetNetworks[#s_DT_PNDevice.PNNetworknumber].DeviceStatus[#s_DT_PNDevice.PNDeviceNumber].DeviceState.Error
	        AND #sx_PowerOk
	        AND NOT #ix_SimulationModeActive
	        AND NOT #sUDT_HMIStatus.Specific.PNSlaveWarning
	    THEN
	        
	        #sUDT_HMIStatus.Specific.PNSlaveError := TRUE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Statistics
	    
	    // Create trigger on error and create statistics for profinet slave not online
	    #sR_TRIG_PNSlaveNotOnline(CLK := #sUDT_HMIStatus.Specific.PNSlaveNotOnline);
	    
	    IF #iqUDT_EquipmentControl.Command.ResetData OR #sUDT_HMIStatus.Specific.PNSlaveNotOnline
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.PNSlaveNotOnline,
	                        ix_RTrigActivate := #sR_TRIG_PNSlaveNotOnline.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.PNSlaveNotOnline);
	        
	    END_IF;
	    
	    // Create trigger on error and create statistics for profinet slave error
	    #sR_TRIG_PNSlaveError(CLK := #sUDT_HMIStatus.Specific.PNSlaveError);
	    
	    IF #iqUDT_EquipmentControl.Command.ResetData OR #sUDT_HMIStatus.Specific.PNSlaveError
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.PNSlaveError,
	                        ix_RTrigActivate := #sR_TRIG_PNSlaveError.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.PNSlaveError);
	        
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Status
	    
	    #sUDT_CommonStatus.Error := #sUDT_HMIStatus.Specific.PNSlaveError
	    OR #sUDT_HMIStatus.Specific.PNSlaveNotOnline;
	    
	    
	    // HMI status update
	    IF #sUDT_CommonStatusOld <> #sUDT_CommonStatus                    // update on change
	    THEN
	        
	        // HMI status initialization
	        #sUDT_HMIStatus.Status := 0;
	        
	        // HMI status calculation
	        IF #sUDT_HMIStatus.Specific.PNSlaveError                       // Profinet error
	            OR #sUDT_HMIStatus.Specific.PNSlaveNotOnline
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".ProfinetError;
	            
	        END_IF;
	        
	        #sUDT_CommonStatusOld := #sUDT_CommonStatus;                 // Copy status to memory
	        #qUDT_Status := #sUDT_CommonStatus;                          // Copy status to output
	        
	    END_IF;
	    
	    #qUDT_HMIStatus := #sUDT_HMIStatus;                          // Copy HMI status to output
	    
	END_REGION
	
	REGION 6 - Report to control block
	    
	    // Function to manage report between control block and conveyor block
	    "FC_EquipmentReport"(iUDT_Status := #sUDT_CommonStatus,
	                         iqUDT_Control := #iqUDT_EquipmentControl);
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_PneumaticBrakeUnit"
TITLE = FB_PneumaticBrakeUnit
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'F.Baten'
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 223
// END_ATTRIBUTES
//Function to control a pneumatic brake contol
   VAR_INPUT 
      iUDT_PneumaticBreakConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PneumaticBrakeConfiguration";   // Pneumatic brake configuration structure
      ix_PECBrake { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when the brake photoye is not blocked
      ix_PECStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when the stop photoye is not blocked
      ix_PECdownstream { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when the photoye downstream is not blocked
      ix_DownstreamStopActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when the downstream stop is active
      ix_MasterValve { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when master valve is on
      ix_SafetyOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when safety is ok
   END_VAR

   VAR_OUTPUT 
      qx_Valve { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when valve is activated
      qx_StopActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when stop is activated to upstream
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
   END_VAR

   VAR 
      s_PECBreakTimerOnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Filtering end of section photo eye signal
      s_PECStopTimerOnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Filtering end of section photo eye signal
      s_StopFunctionTimerOnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Filtering end of section photo eye signal
      s_StopReleaseOnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sR_TRIG_PECStop {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger PEC jam
      slr_StepTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Step timer
      slr_BrakeInterval { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Brake interval
      si_BrakeFunction { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Brake function step
      si_BrakeCycles { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Number of cyles
      sx_Cycle { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Cycle
      sx_PECBrakeFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PEC signal filtered
      sx_PECStopFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PEC signal filtered
      sx_DownstreamStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Downstream is stopped
      sx_StopFunctionActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stop function is activated
      sx_BrakePulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Brake pulse 1 is active
      sx_BrakeAssemblyValve { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Brake assembly valve
      sx_NoCycles { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // No cycles
      sx_Enable_release { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR CONSTANT 
      ci_ReleaseStopBreakTimeOnDelay : UInt := 10000;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	23/06/2021  | 0.0       | F. Baten      | first release TIA 15.1
	20/10/2021  | 0.1       | M. Piela      | Add equipment control. Stylistic correction
	25/06/2021  | 0.2       | M. Kurpiers   | Add stop break release
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	 *)
	
	REGION 1 - Timers
	    
	    // Filtering brake photo eye signal
	    #s_PECBreakTimerOnOffDelay(iudi_OnDelayTime := #iUDT_PneumaticBreakConfiguration.PECBrakeOnDelay,
	                               iudi_OffDelayTime := #iUDT_PneumaticBreakConfiguration.PECBrakeOffDelay,
	                               ix_SignalToDelay := #ix_PECBrake,
	                               ix_Enable := TRUE,
	                               qx_DelayedSignal => #sx_PECBrakeFiltered);
	    
	    // Filtering stop photo eye signal
	    #s_PECStopTimerOnOffDelay(iudi_OnDelayTime := #iUDT_PneumaticBreakConfiguration.PECStopOnDelay,
	                              iudi_OffDelayTime := #iUDT_PneumaticBreakConfiguration.PECStopOffDelay,
	                              ix_SignalToDelay := #ix_PECStop,
	                              ix_Enable := TRUE,
	                              qx_DelayedSignal => #sx_PECStopFiltered);
	    
	    // Filtering downstream stop photo eye signal
	    #s_StopFunctionTimerOnOffDelay(iudi_OnDelayTime := #iUDT_PneumaticBreakConfiguration.StopFunctionOnDelay,
	                                   iudi_OffDelayTime := #iUDT_PneumaticBreakConfiguration.StopFunctionOffDelay,
	                                   ix_SignalToDelay := #ix_DownstreamStopActive,
	                                   ix_Enable := TRUE,
	                                   qx_DelayedSignal => #sx_DownstreamStop);
	    
	    #s_StopReleaseOnOffDelay(iudi_OnDelayTime := #ci_ReleaseStopBreakTimeOnDelay,
	                             iudi_OffDelayTime := 0,
	                             ix_SignalToDelay := #ix_PECdownstream AND NOT #ix_PECBrake,
	                             ix_Enable := TRUE,
	                             qx_DelayedSignal => #sx_Enable_release);
	    
	    // Sequence Timer
	    IF #slr_StepTimer > 0
	    THEN
	        #slr_StepTimer -= "DB_Memory".PrevCycleTime;
	        IF #slr_StepTimer < 0
	        THEN
	            #slr_StepTimer := 0;
	        END_IF;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Brake function
	    // Braking of the parcel is activated when first parcel arrives in brake PEC and stop function is not active.
	    // Now the brake is raised configured number of times with the configured brakepuls time and the configured delay. this is done every time again with the configured
	    // interval time as long as the PEC brake is occupied.
	    
	    #sR_TRIG_PECStop(CLK := #ix_PECStop);
	    // Restart sequence
	    IF #sR_TRIG_PECStop.Q AND NOT #sx_PECStopFiltered
	    THEN
	        #si_BrakeFunction := 1;
	    END_IF;
	    
	    IF #sx_NoCycles AND #ix_PECBrake THEN
	        #sx_NoCycles := FALSE;
	    END_IF;
	    
	    IF #iUDT_PneumaticBreakConfiguration.BrakeCycles = 1
	    THEN
	        #slr_BrakeInterval := #iUDT_PneumaticBreakConfiguration.BrakePause;
	    ELSE
	        #slr_BrakeInterval := #iUDT_PneumaticBreakConfiguration.BrakeInterval;
	    END_IF;
	    // Sequence
	    IF #si_BrakeFunction = 1 AND #slr_StepTimer = 0 AND (NOT #ix_PECBrake OR #sx_BrakePulse)
	    THEN
	        #sx_BrakePulse := TRUE;
	        #slr_StepTimer := #iUDT_PneumaticBreakConfiguration.BrakePuls;
	        #si_BrakeFunction := 2;
	        #sx_Cycle := TRUE;
	    END_IF;
	    
	    IF (#si_BrakeFunction = 2 OR #sx_Enable_release) AND #slr_StepTimer = 0 AND #ix_SafetyOk
	    THEN
	        #sx_BrakePulse := False;
	        #si_BrakeCycles += 1;
	        IF #iUDT_PneumaticBreakConfiguration.BrakeCycles > 0
	        THEN
	            IF #si_BrakeCycles >= #iUDT_PneumaticBreakConfiguration.BrakeCycles
	            THEN
	                #si_BrakeCycles := 0;
	                #slr_StepTimer := #slr_BrakeInterval;
	                #si_BrakeFunction := 3;
	                #sx_Cycle := TRUE;
	            ELSE
	                #slr_StepTimer := #iUDT_PneumaticBreakConfiguration.BrakePause;
	                #si_BrakeFunction := 1;
	                #sx_Cycle := TRUE;
	            END_IF;
	        ELSE
	            #sx_NoCycles := TRUE;
	            #si_BrakeCycles := 0;
	            #si_BrakeFunction := 4;
	        END_IF;
	    END_IF;
	    // Waiting time between interval
	    IF (#si_BrakeFunction = 3 AND #slr_StepTimer = 0) OR #sx_StopFunctionActive
	    THEN
	        #si_BrakeFunction := 1;
	    END_IF;
	    // Wait for pec to clear, one puls only
	    IF (#si_BrakeFunction = 4 AND NOT #sx_NoCycles) OR #sx_StopFunctionActive
	    THEN
	        #si_BrakeFunction := 1;
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Brake valve
	    
	    REGION 3.1 - Brake assembly valve function
	        
	        IF #sx_StopFunctionActive AND NOT #sx_DownstreamStop
	        THEN
	            #sx_StopFunctionActive := FALSE;
	        END_IF;
	        
	        IF #sx_DownstreamStop AND NOT #sx_PECStopFiltered AND NOT #sx_PECBrakeFiltered
	        THEN
	            #sx_StopFunctionActive := TRUE;
	        END_IF;
	        
	        #sx_BrakeAssemblyValve := (#sx_StopFunctionActive
	        AND ((#iUDT_PneumaticBreakConfiguration.Slave AND #ix_MasterValve)
	        OR NOT #iUDT_PneumaticBreakConfiguration.Slave))
	        OR (NOT #sx_StopFunctionActive
	        AND #sx_BrakePulse);
	        
	    END_REGION
	    
	    REGION 3.2 Valve activation
	        
	        IF #iUDT_PneumaticBreakConfiguration.FailSafe
	        THEN
	            #qx_Valve := NOT (#sx_BrakeAssemblyValve OR NOT #ix_SafetyOk);
	        ELSE
	            #qx_Valve := #sx_BrakeAssemblyValve AND #ix_SafetyOk;
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 4 - Stop Active
	    
	    #qx_StopActive := #sx_StopFunctionActive AND NOT #sx_PECStopFiltered AND NOT #sx_PECBrakeFiltered;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_Capacity"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 202
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_CapacityConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CapacityConfiguration";   // Capacity configuration structure
      ix_PECFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when the end of section photoeye is not blocked
      ix_ResetData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset data
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block error occurred
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block warning occurred
      qi_Capacity { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Capacity value
      qa_CapacityBuffer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..#Samples] of Int;   // Capacity buffer
      qa_PPHBuffer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..#Samples] of Int;   // Parcel per hour buffer
   END_VAR

   VAR_IN_OUT 
      iqUDT_ConveyorInterface : "UDT_ConveyorInterface";   // Conveyor interface
   END_VAR

   VAR 
      sFB_Pulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Pulse";   // Function block to generate custom pulse signal.
      sR_TRIG_ParcelDetect {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Parcel detect
      sa_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FifoError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    FIFO block error
         FifoWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    FIFO block warning
         ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Collective configuration error
      END_STRUCT;
      sr_CollectiveParcelLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Colletive parcel length [mm]
      sr_ParcelCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Parcel count
      sr_RecalculatedWindow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Window recalculated based on configured avg parcel length
      sr_ParcelPerHour { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Parcel(s) per hour
      sr_AveragePackageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Average parcel length [mm]
      sr_AverageGap { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Average gap size [mm]
      sr_AverageWindow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Average window size [mm]
      sudi_Interval { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Interval [ms]
      si_Capacity { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Capacity value for the configured package length
      si_ConveyorDistanceTraveled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Distance the conveyour travelled this interval
      sx_ParcelDetected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;   // Parcel detected
      sx_SendData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send data signal
   END_VAR

   VAR CONSTANT 
      Samples : ULInt := 120;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	21/01/2020  | 3.0       | A.Nowak       | Initial version
	14/02/2020  | 3.1       | A.Nowak       | Add sample amount and treshold to the configuration and reset data functionality
	13/03/2020  | 3.2       | M.Kurpiers    | Adapting reviews
	23/03/2020  | 3.3       | A. Nowak      | Change the values to the mm
	20/04/2022  | 3.4       | M.Roijen      | Remove MFC logging and added the shift of data
	06/08/2022  | 3.5       | M.Singh       | add Reset PPH Buffer and used avg Length from Config. 
	15/05/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	                                          Removed 'si_DataCounter', 'si_Displacement', 'iUDT_CapacityConfiguration.SampleAmount', fixed 'sr_AveragePackageLength' calculation
	                                          Added constant 'Samples' for length of arrays.
	*)
	
	REGION 1 - Configuration check
	    
	    // If the block is configured properly, convert interval to the ms and reset the error. Otherwise, set configuration error.
	    IF #iUDT_CapacityConfiguration.Interval > 0
	        AND #iUDT_CapacityConfiguration.AveragePackageLengthConfiguration > 0
	        AND #iUDT_CapacityConfiguration.Treshold >= 0
	    THEN
	        #sudi_Interval := #iUDT_CapacityConfiguration.Interval * 1000;
	        #sa_Status.ConfigurationError := FALSE;
	    ELSE
	        #sa_Status.ConfigurationError := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Reset data
	    
	    // If there is reset data request, initialize sample amount and data buffer.
	    IF #ix_ResetData
	    THEN
	        FILL_BLK(IN := 0,
	                 COUNT := #Samples,
	                 OUT => #qa_CapacityBuffer[0]);
	        FILL_BLK(IN := 0,
	                 COUNT := #Samples,
	                 OUT => #qa_PPHBuffer[0]);
	    END_IF;
	    
	END_REGION
	
	REGION 4 - PEC
	    
	    #sx_ParcelDetected := NOT #ix_PECFiltered;
	    
	END_REGION
	
	REGION 5 - Interval check
	    
	    // Generate puls signal every interval. 
	    #sFB_Pulse(iudi_PulseTime := #sudi_Interval,
	               qx_Pulse => #sx_SendData);
	    
	END_REGION
	
	REGION 6 - Package length measurement and parcel count
	    
	    // Parcel is detected.
	    IF #sx_ParcelDetected
	    THEN
	        // Add displacement to the collective parcel length.
	        #sr_CollectiveParcelLength += (ABS(#iqUDT_ConveyorInterface.Displacement)) * 10;
	    END_IF;
	    
	    #sR_TRIG_ParcelDetect(CLK := #sx_ParcelDetected);
	    // Increment parcel count when package is detected.
	    IF #sR_TRIG_ParcelDetect.Q
	    THEN
	        #sr_ParcelCount += 1;
	    END_IF;
	    
	    // Measure the distance traveled by conveyor
	    #si_ConveyorDistanceTraveled += (ABS(#iqUDT_ConveyorInterface.Displacement)) * 10;
	    
	END_REGION
	
	REGION 7 - Capacity calculation and data send
	    
	    // There is no configuration error and there are send data and enable signals.
	    IF NOT #sa_Status.ConfigurationError
	        AND #sx_SendData
	    THEN
	        // Parcel was detected.
	        IF #sr_ParcelCount <> 0
	            AND #sr_CollectiveParcelLength <> 0
	        THEN
	            // Calculate average values.
	            #sr_AveragePackageLength := #sr_CollectiveParcelLength / #sr_ParcelCount;
	            #sr_AverageWindow := #si_ConveyorDistanceTraveled / #sr_ParcelCount;
	            #sr_AverageGap := #sr_AverageWindow - #sr_AveragePackageLength;
	            
	            // Windowsize calculated based on configured average parcel length
	            #sr_RecalculatedWindow := #sr_AverageGap + #iUDT_CapacityConfiguration.AveragePackageLengthConfiguration;
	            
	            // Calculate parcel per hour value for the configured average parcel length.
	            #si_Capacity := DINT_TO_INT(TRUNC((#sr_ParcelPerHour * #sr_AverageWindow) / #sr_RecalculatedWindow));
	            
	            // Calculate parcel per hour value using data from the interval.
	            #sr_ParcelPerHour := (#sr_ParcelCount / UDINT_TO_REAL(#iUDT_CapacityConfiguration.Interval)) * 3600;
	            
	        ELSE
	            #si_Capacity := 0;
	        END_IF;
	        
	        #qi_Capacity := #si_Capacity;
	        
	        // Capacity value is greater than configured treshold.
	        IF #si_Capacity >= #iUDT_CapacityConfiguration.Treshold
	        THEN
	            MOVE_BLK(IN := #qa_CapacityBuffer[0],
	                     COUNT := #Samples,
	                     OUT => #qa_CapacityBuffer[1]);
	            #qa_CapacityBuffer[0] := #si_Capacity;
	            
	            MOVE_BLK(IN := #qa_PPHBuffer[0],
	                     COUNT := #Samples,
	                     OUT => #qa_PPHBuffer[1]);
	            #qa_PPHBuffer[0] := REAL_TO_INT(#sr_ParcelPerHour);
	        END_IF;
	        
	        // Initialize parcel count and collective parcel length.
	        #sr_ParcelCount := 0;
	        #sr_CollectiveParcelLength := 0;
	        #si_ConveyorDistanceTraveled := 0;
	    END_IF;
	    
	END_REGION
	
	REGION 8 - Status 
	    
	    // Collective error.
	    #qx_Error :=
	    #sa_Status.ConfigurationError
	    OR #sa_Status.FifoError;
	    
	    // Collective warning.
	    #qx_Warning := #sa_Status.FifoWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_Chute1PEC"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 203
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_ChuteConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_Chute1PECConfiguration";   // Chute Configuration structure
      iUDT_UpstreamConveyorStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   // Upstream conveyor status
      ix_PECFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when Chute Full photoeye is not blocked
      ix_Disabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when chute is disabled
      ix_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when chute hardware is Ok
      iudi_DelayHardwareOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Time to delay for hardware ok signal
   END_VAR

   VAR_OUTPUT 
      qx_Lamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Output Chute Lamp full
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_Chute1PECStatus";   // HMI status structure
      qUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   // Common status structure
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
      iqUDT_UpstreamConveyorHandshake : "UDT_ConveyorHandshake";   // Upstream handshake structure
      iqUDT_Statistics : "UDT_Chute1PECStatistics";   // Statistics structure
   END_VAR

   VAR 
      s_UDT_CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Common status structure
      s_UDT_CommonStatus_1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";
      s_UDT_CommonStatus_2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";
      s_UDT_CommonStatus_3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";
      s_UDT_CommonStatus_4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";
      s_UDT_CommonStatus_5 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";
      s_UDT_CommonStatus_6 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";
      s_UDT_CommonStatus_7 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";
      s_UDT_CommonStatus_8 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";
      s_UDT_CommonStatus_9 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";
      s_UDT_CommonStatus_10 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";
      s_UDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Chute1PECStatus";   // HMI status structure
      s_UDT_CommonStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Auxiliary status structure
      s_FB_HardwareOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer on/off delay for hardware ok signal
      s_FB_ChuteFullDetectionDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer on/off delay for chute full detection
      s_R_TRIG_ChuteFull {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger on chute full signal
      s_R_TRIG_Disabled {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger on chute disabled signal
      s_F_TRIG_UpdateStatus {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger on status change
      sx_Full { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Full status
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	13/10/2021  | 0.1       | J. Krawczuk   | first release TIA 16.0
	29/10/2021  | 0.1       | M. Piela      | Design change, comments corrections
	14/01/2022  | 0.2       | G. Vlooswijk  | Fixed statistics reset
	25/07/2022  | 0.3       | M. Kurpiers   | HMI Initilization added
	30/07/2022  | 0.3       | G. Vlooswijk  | Removed running and energy save status for FedEx Scada
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	12/03/2024  | 4.1       | S. Nieswiec   | Updated variable names to current standard
	 *)
	
	REGION 1 - Timers
	    
	    // Full detection timer
	    #s_FB_ChuteFullDetectionDelay(iudi_OnDelayTime := #iUDT_ChuteConfiguration.FullDetectionTime,
	                                  iudi_OffDelayTime := #iUDT_ChuteConfiguration.FullReleaseTime,
	                                  ix_SignalToDelay := NOT #ix_PECFull,
	                                  qx_DelayedSignal => #sx_Full);
	    
	    // Hardware ok timer 
	    #s_FB_HardwareOK(iudi_OnDelayTime := #iudi_DelayHardwareOK,
	                     ix_SignalToDelay := #ix_HardwareOk);
	    
	END_REGION
	
	REGION 2 - Stop upstream conveyor 
	    
	    // Stop upstream conveyor when chute is full or disabled
	    #iqUDT_UpstreamConveyorHandshake.RTR := NOT #sx_Full AND NOT #ix_Disabled AND #s_FB_HardwareOK.qx_DelayedSignal;
	    
	END_REGION
	
	REGION 3 - Update output
	    
	    // Update the outputs
	    #qx_Lamp := #sx_Full;
	    
	END_REGION
	
	REGION 4 - Status
	    
	    // HMI status initialization
	    #s_UDT_HMIStatus.Status := 0;
	    
	    // Update chute full specific status
	    #s_UDT_HMIStatus.Specific.ChuteFull := #sx_Full AND #s_FB_HardwareOK.qx_DelayedSignal;
	    
	    //Update chute disabled specific status
	    #s_UDT_HMIStatus.Specific.ChuteDisabled := #ix_Disabled AND #s_FB_HardwareOK.qx_DelayedSignal;
	    
	    // Update common safety stop
	    #s_UDT_CommonStatus.SafetyStop := #iUDT_UpstreamConveyorStatus.SafetyStop;
	    
	    // Update common automatic on 
	    #s_UDT_CommonStatus.AutoON := #iUDT_UpstreamConveyorStatus.AutoON;
	    
	    // Update common stopped
	    #s_UDT_CommonStatus.Stopped := #iUDT_UpstreamConveyorStatus.Stopped;
	    
	    // Update HMI status number for chute disabled
	    IF #s_UDT_HMIStatus.Specific.ChuteDisabled AND NOT #s_UDT_CommonStatus.SafetyStop
	    THEN
	        #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".DisableByManagement;
	        
	    END_IF;
	    
	    // Update HMI status number for chute full
	    IF #s_UDT_HMIStatus.Specific.ChuteFull AND NOT #s_UDT_CommonStatus.SafetyStop
	    THEN
	        #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".ChuteFull;
	        
	    END_IF;
	    
	    // Collecting F_TRIG on chute full or chute disabled status to update common status 
	    #s_F_TRIG_UpdateStatus(CLK := #s_UDT_HMIStatus.Specific.ChuteFull OR #s_UDT_HMIStatus.Specific.ChuteDisabled);
	    
	    // HMI status number calculation
	    IF #s_UDT_CommonStatusOld <> #s_UDT_CommonStatus OR #s_F_TRIG_UpdateStatus.Q
	    THEN
	        
	        // Update auto on status number
	        IF #s_UDT_CommonStatus.AutoON
	        THEN
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".AutoON;
	            
	        END_IF;
	        
	        IF #s_UDT_CommonStatus.Stopped
	        THEN
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Stopped;
	            
	        END_IF;
	        
	        IF #s_UDT_CommonStatus.SafetyStop
	        THEN
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".SafetyStop;
	            
	        END_IF;
	        
	        // Copy common status structure to the old common status structure
	        #s_UDT_CommonStatusOld := #s_UDT_CommonStatus;
	        #qUDT_Status := #s_UDT_CommonStatus;
	        
	    END_IF;
	    
	    #qUDT_HMIStatus := #s_UDT_HMIStatus;
	    
	    
	END_REGION
	
	REGION 5 - Statistics
	    
	    // Chute full R_TRIG for statistics purpose
	    #s_R_TRIG_ChuteFull(CLK := #s_UDT_HMIStatus.Specific.ChuteFull);
	    
	    // Chute full statistics
	    IF #s_UDT_HMIStatus.Specific.ChuteFull
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #s_UDT_HMIStatus.Specific.ChuteFull,
	                        ix_RTrigActivate := #s_R_TRIG_ChuteFull.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.ChuteFull);
	        
	    END_IF;
	    
	    // Chute disabled R_TRIG for statistics purpose 
	    #s_R_TRIG_Disabled(CLK := #s_UDT_HMIStatus.Specific.ChuteDisabled);
	    
	    // Chute disabled statistics
	    IF #s_UDT_HMIStatus.Specific.ChuteDisabled
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #s_UDT_HMIStatus.Specific.ChuteDisabled,
	                        ix_RTrigActivate := #s_R_TRIG_Disabled.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.ChuteDisabled);
	        
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Equipment Report
	    
	    "FC_EquipmentReport"(iUDT_Status := #s_UDT_CommonStatus,
	                         iqUDT_Control := #iqUDT_EquipmentControl);
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_Chute2PEC"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 204
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_ChuteConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_Chute2PECConfiguration";   // Chute Configuration structure
      iUDT_UpstreamConveyorStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   // Upstream conveyor status
      ix_PECFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when Chute Full photoeye is not blocked
      ix_PECHalfFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when Chute Half Full photoeye is not blocked
      ix_Disabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when chute is disabled
      ix_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when chute hardware is Ok
      iudi_DelayHardwareOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Time to delay for hardware ok signal
   END_VAR

   VAR_OUTPUT 
      qx_Lamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Output Chute Lamp half full/ full
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_Chute2PECStatus";   // HMI status structure
      qUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   // Common status structure
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
      iqUDT_UpstreamConveyorHandshake : "UDT_ConveyorHandshake";   // Upstream handshake structure
      iqUDT_Statistics : "UDT_Chute2PECStatistics";   // Statistics structure
   END_VAR

   VAR 
      sUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Chute2PECStatus";   // HMI status structure
      sUDT_CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Common status structure
      sUDT_CommonStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Auxiliary status structure
      sFB_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer on/off delay for hardware ok signal
      sFB_ChuteHalfFullDetectionDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer on/off delay for chute half  full detection
      sFB_ChuteFullDetectionDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer on/off delay for chute full detection
      sR_TRIG_HalfFull {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger on chute half full signal
      sR_TRIG_Disabled {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger on chute disabled signal
      sR_TRIG_ChuteFull {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger on chute full signal
      sF_TRIG_UpdateStatus {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger on status change
      sx_Full { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Full status
      sx_HalfFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Half full status
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	19/10/2021  | 0.1       | J. Krawczuk   | first release TIA 16.0
	29/10/2021  | 0.1       | M. Piela      | Design change, comments corrections
	14/01/2022  | 0.2       | G. Vlooswijk  | Fixed statistics reset
	30/07/2022  | 0.3       | G. Vlooswijk  | Removed running and energy save status for FedEx Scada
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	 *)
	
	REGION 1 - Timers
	    
	    // Chute full detection timer 
	    #sFB_ChuteFullDetectionDelay(iudi_OnDelayTime := #iUDT_ChuteConfiguration.FullDetectionTime,
	                                 iudi_OffDelayTime := #iUDT_ChuteConfiguration.FullReleaseTime,
	                                 ix_SignalToDelay := NOT #ix_PECFull,
	                                 qx_DelayedSignal => #sx_Full);
	    
	    // Chute half full detection timer
	    #sFB_ChuteHalfFullDetectionDelay(iudi_OnDelayTime := #iUDT_ChuteConfiguration.HalfFullDetectionTime,
	                                     iudi_OffDelayTime := #iUDT_ChuteConfiguration.HalfFullReleaseTime,
	                                     ix_SignalToDelay := NOT #ix_PECHalfFull,
	                                     qx_DelayedSignal => #sx_HalfFull);
	    
	    // Hardware ok signal delay
	    #sFB_HardwareOk(iudi_OnDelayTime := #iudi_DelayHardwareOK,
	                    ix_SignalToDelay := #ix_HardwareOk);
	    
	    
	END_REGION
	
	REGION 2 - Stop upstream conveyor 
	    
	    // Stop upstream conveyor when chute is full or disabled
	    #iqUDT_UpstreamConveyorHandshake.RTR := NOT #sx_Full AND NOT #ix_Disabled AND #sFB_HardwareOk.qx_DelayedSignal;
	    
	END_REGION
	
	REGION 3 - Update output
	    
	    // Update the outputs
	    #qx_Lamp := #sx_Full OR (#sx_HalfFull AND "DB_Memory".Clock_1Hz);
	    
	END_REGION
	
	REGION 4 - Status
	    
	    // Update chute full specific status
	    #sUDT_HMIStatus.Specific.ChuteFull := #sx_Full AND #sFB_HardwareOk.qx_DelayedSignal;
	    
	    // Update chute half full specific status
	    #sUDT_HMIStatus.Specific.ChuteHalfFull := #sx_HalfFull AND #sFB_HardwareOk.qx_DelayedSignal;
	    
	    //Update chute disabled specific status
	    #sUDT_HMIStatus.Specific.ChuteDisabled := #ix_Disabled AND #sFB_HardwareOk.qx_DelayedSignal;
	    
	    // Update common safety stop
	    #sUDT_CommonStatus.SafetyStop := #iUDT_UpstreamConveyorStatus.SafetyStop;
	    
	    // Update common automatic on 
	    #sUDT_CommonStatus.AutoON := #iUDT_UpstreamConveyorStatus.AutoON;
	    
	    // Update common stopped
	    #sUDT_CommonStatus.Stopped := #iUDT_UpstreamConveyorStatus.Stopped;
	    
	    // Update HMI status number for chute disabled
	    IF #sUDT_HMIStatus.Specific.ChuteDisabled AND NOT #sUDT_CommonStatus.SafetyStop
	    THEN
	        #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".DisableByManagement;
	        
	    END_IF;
	    
	    // Update HMI status number for chute half full
	    IF #sUDT_HMIStatus.Specific.ChuteHalfFull AND NOT #sUDT_CommonStatus.SafetyStop
	    THEN
	        #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".ChuteHalfFull;
	        
	    END_IF;
	    
	    // Update HMI status number for chute full
	    IF #sUDT_HMIStatus.Specific.ChuteFull AND NOT #sUDT_CommonStatus.SafetyStop
	    THEN
	        #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".ChuteFull;
	        
	    END_IF;
	    
	    // Collecting F_TRIG on chute full, chute half full or chute disabled status to update common status 
	    #sF_TRIG_UpdateStatus(CLK := #sUDT_HMIStatus.Specific.ChuteFull
	                          OR #sUDT_HMIStatus.Specific.ChuteDisabled
	                          OR #sUDT_HMIStatus.Specific.ChuteHalfFull);
	    
	    // HMI status number calculation
	    IF #sUDT_CommonStatusOld <> #sUDT_CommonStatus OR #sF_TRIG_UpdateStatus.Q
	    THEN
	        
	        // Update auto on status number
	        IF #sUDT_CommonStatus.AutoON
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".AutoON;
	            
	        END_IF;
	        
	        IF #sUDT_CommonStatus.Stopped
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Stopped;
	            
	        END_IF;
	        
	        IF #sUDT_CommonStatus.SafetyStop
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".SafetyStop;
	            
	        END_IF;
	        
	        // Copy common status structure to the old common status structure
	        #sUDT_CommonStatusOld := #sUDT_CommonStatus;
	        #qUDT_Status := #sUDT_CommonStatus;
	        
	    END_IF;
	    
	    #qUDT_HMIStatus := #sUDT_HMIStatus;
	    
	END_REGION
	
	REGION 5 - Statistics
	    
	    // Chute full R_TRIG for statistics purpose
	    #sR_TRIG_ChuteFull(CLK := #sUDT_HMIStatus.Specific.ChuteFull);
	    
	    // Chute full statistics
	    IF #sUDT_HMIStatus.Specific.ChuteFull
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.ChuteFull,
	                        ix_RTrigActivate := #sR_TRIG_ChuteFull.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.ChuteFull);
	        
	    END_IF;
	    
	    // Chute disabled R_TRIG for statistics purpose 
	    #sR_TRIG_Disabled(CLK := #sUDT_HMIStatus.Specific.ChuteDisabled);
	    
	    // Chute disabled statistics
	    IF #sUDT_HMIStatus.Specific.ChuteDisabled
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.ChuteDisabled,
	                        ix_RTrigActivate := #sR_TRIG_Disabled.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.ChuteDisabled);
	        
	    END_IF;
	    
	    // Chute half full R_TRIG for statistics purpose
	    #sR_TRIG_HalfFull(CLK := #sUDT_HMIStatus.Specific.ChuteHalfFull);
	    
	    // Chute half full statistics
	    IF #sUDT_HMIStatus.Specific.ChuteHalfFull
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.ChuteHalfFull,
	                        ix_RTrigActivate := #sR_TRIG_HalfFull.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.ChuteHalfFull);
	        
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Equipment Report
	    
	    "FC_EquipmentReport"(iUDT_Status := #sUDT_CommonStatus,
	                         iqUDT_Control := #iqUDT_EquipmentControl);
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_PendantVT100"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 222
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_Configuration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PendantVT100Configuration" := ([16#001B, 16#005B, 16#0031, 16#003B, 16#0033, 16#0048, 16#006D, 16#0000], [16#001B, 16#005B, 16#0032, 16#003B, 16#0035, 16#0048, 16#006D, 16#0000], (), (), ());
      iUDT_PendantInputs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PendantVT100InBytes";   //   Input Bytes 1,2 and 3 of HW Config
      ix_HMIDivertSelectionEnabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   When 'TRUE' The divert selection screen is activated from the HMI
      ix_SimulationModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   When 'TRUE' Simulation mode active
      ix_LCDDS1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   When 'TRUE' Display is busy writing a message row 1
      ix_PowerOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   When 'TRUE' 24VDC available
      ix_ServiceMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   When 'TRUE' Service Mode ON
      ix_VFDRunFeedback { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   When 'TRUE' VFD Run
      ix_SorterSTOActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   VFD STO active feedback
      ix_SorterSS1Active { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   VFD SS1 active feedback
   END_VAR

   VAR_OUTPUT 
      qUDT_Display { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PendantVT100LCDOutBytes";   //   Display bytes
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PendantVT100Status";   //   Configuation variables for VT100 Radio Pendant
      qUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   //   Common status structure
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";
      iqUDT_PendantInterface : "UDT_PendantVT100Interface";   //   Interface structure
      iqUDT_Statistics : "UDT_PendantVT100Statistics";   //   Staristic structure
      iq_ConveyorInterface : "UDT_ConveyorInterface";
   END_VAR

   VAR 
      sUDT_Display { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PendantVT100LCDOutBytes";   //    Array of 8 bytes for the display message
      sUDT_CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //    Common status structure
      sUDT_CommonStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //    Common status structure
      sUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PendantVT100Status";
      sUDT_PNDevice { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PNDevice";   //    PN device info structure
      sFB_TimerOnOffDelayCheckSupply { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sF_TRIG_Servicemode {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //   Falling edge trigger service mode
      sF_TRIG_DisplayReady {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //   Falling edge trigger display ready
      sR_TRIG_RunCommand {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge trigger run command
      sR_TRIG_PNReceiverNotOnline {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge trigger PN receiver not online
      sR_TRIG_PNReceiverError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge trigger PN device error
      sR_TRIG_ControlHealthy {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge trigger control healthy
      sa_Int { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //   Integer structure
         Step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Int;   //    Step of the message sequence
      END_STRUCT;
      sa_Bool { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //   Bool structure
         DivertUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    When 'TRUE' Any divert is up
         HardwareAvailable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    When 'TRUE' Hardware available and ready to use
         PermissionRequested { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    When 'TRUE' Permission requested for horn to sound
         PermissionGranted { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    When 'TRUE' Horn sounded before start of VFD
         PowerOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    When 'TRUE' Power is present at receiver
         PNDeviceHealthy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    When 'TRUE' Receiver is healthy
         RadioConnection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    When 'TRUE' Initial connection with radio
         RunRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    When 'TRUE' Request to run
         ServiceModeEngaged { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    True = Service mode is engaged
      END_STRUCT;
   END_VAR

   VAR_TEMP 
      ti_index : Int;   //   temporary integer for loops
   END_VAR

   VAR CONSTANT 
      cudi_PowerSupplyDelayTime : UDInt := 7000;   //   Power supply delay time [ms]
   END_VAR


BEGIN
	
	(*
	----------------------------------------------------------------------------------------
	                                                                                     
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	14/04/2019  | 1.0       | S. Theocharis | first release TIA15.1
	11/09/2019  | 1.1       | S. Theocharis | update for UPS EMA Baseline
	04/11/2019  | 1.2       | S. Theocharis | Key Switch wired@safety input
	30/01/2020  | 3.0       | S. Theocharis | Different button for fast speed, 
	                                        | code to activate diverters
	                                        | Status, statistics and equipement control
	                                        | structures added
	04/03/2020  | 3.1       | M. Piela      | Changed comments and subregions names, added constants to timers 
	25/06/2020  | 3.2       | L. Klar       | Horn delay deleted      
	07/07/2020  | 3.3       | M. Piela      | Delete unused signal from the interface, change condition to enable step 1
	                                        | in service mode
	07/07/2020  | 3.4       | M. Piela      | Added conditions to set the signaling request signal
	28/07/2020  | 3.5       | S. Theocharis | Changed input name 
	11/08/2020  | 3.6       | S. Theocharis | Update the divert functionality  
	03/06/2021  | 3.7       | S. Theocharis | Force to slow speed for missing pin at service point  
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION Notes
	(* 
	
	Note1: 
	 ib_Buttons.xxxxxx1 is  the signal when the associate button is pressed half way
	 ib_buttons.xxxxxx2 is  the signal when the associate button is pressed full
	 
	 Not Pressed:                 Halfway Pressed                    Full way Pressed
	                             ib_Buttons.xxxxxx1 = TRUE           ib_Buttons.xxxxxx1 = TRUE
	                             ib_Buttons.xxxxxx2 = FALSE          ib_Buttons.xxxxxx2 = TRUE
	     ________  
	     |      |                        ________
	     |      |                        |      |                       ________
	     |      |                        |      |                       |      |
	 ____|      |____                 ___|      |____                ___|      |____
	 
	  
	 Note2:
	 The block is designed for the following remote controller: 
	 Danfoss TM70/1.13DC  (Ikusi) 
	 https://www.danfoss.com/en/products/electronic-controls/dps/plus1-remote-controls/transmitters/legacy-handheld-transmitters/
	  *)
	END_REGION
	
	REGION 1 -  Get Receiver Profinet number
	    
	    "FC_GetDevicePN"(is_PNDeviceName := #iUDT_Configuration.PNDeviceName,
	                     ix_SimulationModeActive := #ix_SimulationModeActive,
	                     iqUDT_PND := #sUDT_PNDevice);
	    
	END_REGION
	
	REGION 2 - Reset errors
	    
	    IF #iqUDT_EquipmentControl.Command.Reset                         // Reser errors when Reset from HMI or MCP is given
	    THEN
	        #sUDT_HMIStatus.Specific.PNSlaveNotOnline := FALSE;
	        #sUDT_HMIStatus.Specific.PNSlaveError := FALSE;
	        #sUDT_HMIStatus.Specific.CommunicationError := FALSE;          // Not in use
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Hardware checks
	    // PN Receiver will only be available after the delay, so the device has time for the initialisation
	    #sFB_TimerOnOffDelayCheckSupply(iudi_OnDelayTime := #cudi_PowerSupplyDelayTime,
	                                    ix_SignalToDelay := #ix_PowerOk,
	                                    ix_Enable := TRUE,
	                                    qx_DelayedSignal => #sa_Bool.PowerOk);
	    
	    // Check if PN receiver device is online
	    IF NOT "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.Exist
	        AND NOT #ix_SimulationModeActive
	        AND #sa_Bool.PowerOk
	    THEN
	        #sUDT_HMIStatus.Specific.PNSlaveNotOnline := TRUE;
	    END_IF;
	    
	    // Check if PN Receiver device has an error
	    IF "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.Error
	        AND NOT #ix_SimulationModeActive
	        AND #sa_Bool.PowerOk
	    THEN
	        #sUDT_HMIStatus.Specific.PNSlaveError := TRUE;
	    END_IF;
	    
	    // Set bit when PN Receiver device is healthy (online and no error)
	    #sa_Bool.PNDeviceHealthy := NOT #sUDT_HMIStatus.Specific.PNSlaveNotOnline
	    AND NOT #sUDT_HMIStatus.Specific.PNSlaveError
	    AND #sUDT_PNDevice.PNDeviceFound
	    AND #sa_Bool.PowerOk;
	    
	    // Set hardware available bit when all conditions are met
	    #sa_Bool.HardwareAvailable := (#sa_Bool.PowerOk
	    AND #sa_Bool.PNDeviceHealthy)
	    OR #ix_SimulationModeActive;
	    
	END_REGION
	
	REGION 4 -  Detect service mode selection changes
	    
	    //static memory to engage the service mode. Only when the sorter is standstill
	    IF #sa_Bool.HardwareAvailable AND #ix_ServiceMode AND NOT #ix_VFDRunFeedback
	    THEN
	        #sa_Bool.ServiceModeEngaged := TRUE;
	    END_IF;
	    
	    //disengage service mode when hardware is not available or switch is off
	    IF NOT #sa_Bool.HardwareAvailable OR NOT #ix_ServiceMode
	    THEN
	        #sa_Bool.ServiceModeEngaged := FALSE;
	    END_IF;
	    
	    //service mode to interface
	    #iqUDT_PendantInterface.ServiceModeEngaged := #sa_Bool.ServiceModeEngaged;
	    
	    
	    //Detect falling edge of service mode
	    #sF_TRIG_Servicemode(CLK := #sa_Bool.ServiceModeEngaged);
	    
	END_REGION
	
	REGION 5 -  Service mode
	    
	    IF #sa_Bool.ServiceModeEngaged
	    THEN
	        
	        REGION 5.1 - Detect Tx connection & LCD readiness to receive message
	            
	            #sR_TRIG_ControlHealthy(CLK := #iUDT_PendantInputs.Stop_NC);//Rising edge of communication 
	            
	            //set radio Tx-Rx connection 
	            IF #sR_TRIG_ControlHealthy.Q
	            THEN    (* or replace it directly with the input #iudt_PendantInputs.Stop_NO) *)
	                #sa_Bool.RadioConnection := True;
	            END_IF;
	            
	            #sF_TRIG_DisplayReady(CLK := #ix_LCDDS1);//LCD Status Signal. When ix_LCD_DS1 is False, the LCD is ready to receive a new message
	            
	        END_REGION
	        
	        REGION 5.2 - LCD messages
	            //First communication established. Activate message one to move cursor in the begin of line 1
	            
	            IF #sa_Bool.RadioConnection
	            THEN
	                #sa_Int.Step := 1;           // step 1 - new message is activated 
	                #sa_Bool.RadioConnection := FALSE;
	            END_IF;
	            
	            //reset variables for display. that can be used to move the step to eg 98 and there reset the variables and move the step to 0 again 
	            IF NOT #iUDT_PendantInputs.Stop_NC
	            THEN
	                // #st_Int.Step := 98;
	                FOR #ti_index := 0 TO 7 BY 1 DO
	                    #qUDT_Display."Byte"[#ti_index] := b#16#0;
	                    #sUDT_Display."Byte"[#ti_index] := b#16#0;
	                END_FOR;
	            END_IF;
	            
	            // Screen  Messages
	            CASE #sa_Int.Step OF
	                    
	                1: // Move Cursor in the Start Point  
	                    #sUDT_Display."Byte" := #iUDT_Configuration.Line1Cursor;  // message
	                    #sa_Int.Step := 2;                                 //  is written static memory
	                    
	                2: // when display is not busy write the output 
	                    IF NOT #ix_LCDDS1
	                    THEN
	                        #qUDT_Display."Byte" := #sUDT_Display."Byte";
	                        #sa_Int.Step := 3;    // move to next step                                 
	                    END_IF;
	                    
	                3: //Write PLC name
	                    FOR #ti_index := 0 TO 7 BY 1 DO
	                        #sUDT_Display."Byte"[#ti_index] := CHAR_TO_BYTE(#iUDT_Configuration.DisplayName[#ti_index + 1]);
	                    END_FOR;
	                    #sa_Int.Step := 4;     //move to next step                                
	                    
	                4: //when display is not busy write the output
	                    IF #sF_TRIG_DisplayReady.Q
	                    THEN   (* may need to be replaced with :NOT #ix_LCD_DS1 *)
	                        #qUDT_Display."Byte" := #sUDT_Display."Byte";
	                        #sa_Int.Step := 99;// move to next step 
	                    END_IF;
	            END_CASE;
	            
	        END_REGION
	        
	        REGION 5.3 - Output to the sorter control function
	            //Stop Button         
	            #iqUDT_PendantInterface.PendantStopHealthy := #iUDT_PendantInputs.Stop_NC AND NOT #iUDT_PendantInputs.Stop_NO;
	            
	            // Reset - Control On
	            #iqUDT_PendantInterface.PendantReset := #iUDT_PendantInputs.ResetButton1;
	            
	        END_REGION
	        
	        REGION 5.4 - Motion control
	            // STO request to safety program
	            #iqUDT_PendantInterface.RequestSTO := #iUDT_PendantInputs.PB_Speed1 OR #iUDT_PendantInputs.PB_Speed2;
	            
	            //Run reuqest condition 
	            #sa_Bool.RunRequest := (#iUDT_PendantInputs.PB_Speed2 XOR #iUDT_PendantInputs.PB_Speed1) AND NOT #sa_Bool.DivertUp;
	            
	            //Check permission to run after horn sounded
	            IF #iUDT_Configuration.HornRequest
	            THEN
	                
	                //Detect new run request 
	                #sR_TRIG_RunCommand(CLK := #sa_Bool.RunRequest AND NOT #ix_VFDRunFeedback);
	                
	                //On the positie edge of the new run command which requires permission set the control request and reset the permissiong granted bit
	                IF #sR_TRIG_RunCommand.Q AND NOT #ix_SorterSS1Active AND NOT #iq_ConveyorInterface.InternalErrorVFD
	                THEN
	                    #iqUDT_EquipmentControl.Request.SignalingRequest := TRUE;
	                    #sa_Bool.PermissionRequested := TRUE;
	                    #sa_Bool.PermissionGranted := FALSE;
	                END_IF;
	                
	                //when the requested memory is true but the control request is false, it means that the horn sounded and the permission to run is granted again
	                IF #sa_Bool.PermissionRequested AND NOT #iqUDT_EquipmentControl.Request.SignalingRequest
	                THEN
	                    #sa_Bool.PermissionRequested := FALSE;
	                    #sa_Bool.PermissionGranted := TRUE;
	                END_IF;
	                
	            ELSE  //when horn request is deactivated via the configuration 
	                #sa_Bool.PermissionGranted := TRUE;
	                #sa_Bool.PermissionRequested := FALSE;
	            END_IF;
	            
	            //assign commands to run and speed only when associate button is pressed and not divert is detected up
	            #iqUDT_PendantInterface.CmdRun := NOT #ix_SorterSTOActive AND #sa_Bool.PermissionGranted AND #sa_Bool.RunRequest;
	            
	            #iqUDT_PendantInterface.LowSpeedSelected := (#iUDT_PendantInputs.PB_Speed1
	            OR
	            (#iUDT_PendantInputs.PB_Speed2 AND #iqUDT_PendantInterface.ForceLowSpeed))
	            AND #sa_Bool.PermissionGranted
	            AND #sa_Bool.RunRequest;
	            
	            
	            #iqUDT_PendantInterface.ManualSpeedSelected := (#iUDT_PendantInputs.PB_Speed2 AND NOT #iqUDT_PendantInterface.ForceLowSpeed)
	            AND #sa_Bool.PermissionGranted
	            AND #sa_Bool.RunRequest;
	            
	        END_REGION
	        
	    ELSE
	        
	        REGION 5.7 - Reset interface bits when service mode is disengaged
	            
	            #iqUDT_PendantInterface.CmdRun := FALSE;
	            #iqUDT_PendantInterface.LowSpeedSelected := FALSE;
	            #iqUDT_PendantInterface.ManualSpeedSelected := FALSE;
	            #iqUDT_PendantInterface.PendantReset := FALSE;
	            #iqUDT_PendantInterface.PendantStopHealthy := FALSE;
	            
	            
	        END_REGION
	        
	    END_IF;
	    
	END_REGION
	
	REGION 6 Divert functionality 
	    
	    #iqUDT_PendantInterface.CmdDivert := #iUDT_PendantInputs.PB_Divert
	    AND #sa_Bool.ServiceModeEngaged
	    AND #ix_HMIDivertSelectionEnabled
	    AND NOT #ix_VFDRunFeedback;
	    
	END_REGION
	
	
	REGION 7 - Statistics
	    
	    // Create trigger on error and create statistics for profinet slave not online
	    #sR_TRIG_PNReceiverNotOnline(CLK := #sUDT_HMIStatus.Specific.PNSlaveNotOnline);
	    
	    IF #iqUDT_EquipmentControl.Command.ResetData OR #sUDT_HMIStatus.Specific.PNSlaveNotOnline
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.PNSlaveNotOnline,
	                        ix_RTrigActivate := #sR_TRIG_PNReceiverNotOnline.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.PNSlaveNotOnline);
	    END_IF;
	    
	    // Create trigger on error and create statistics for profinet slave error
	    #sR_TRIG_PNReceiverError(CLK := #sUDT_HMIStatus.Specific.PNSlaveError);
	    
	    IF #iqUDT_EquipmentControl.Command.ResetData OR #sUDT_HMIStatus.Specific.PNSlaveError
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.PNSlaveError,
	                        ix_RTrigActivate := #sR_TRIG_PNReceiverError.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.PNSlaveError);
	    END_IF;
	    
	END_REGION
	
	REGION 8 - Status
	    
	    //update status of service mode engaged
	    #sUDT_HMIStatus.Specific.ServiceModeEngaged := #sa_Bool.ServiceModeEngaged;
	    
	    //prepare commont status for equipment report 
	    #sUDT_CommonStatus.Error := (#sUDT_HMIStatus.Specific.PNSlaveError OR #sUDT_HMIStatus.Specific.PNSlaveNotOnline OR #sUDT_HMIStatus.Specific.CommunicationError);
	    
	    // HMI status update
	    IF #sUDT_CommonStatusOld <> #sUDT_CommonStatus      // update on change
	    THEN
	        // HMI status initialization
	        #sUDT_HMIStatus.Status := 0;
	        
	        // HMI status calculation 
	        IF #sUDT_HMIStatus.Specific.PNSlaveError OR #sUDT_HMIStatus.Specific.PNSlaveNotOnline
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".ProfinetError;
	        END_IF;
	    END_IF;
	    
	    #qUDT_HMIStatus := #sUDT_HMIStatus;                          // Copy HMI status to output
	    #sUDT_CommonStatusOld := #sUDT_CommonStatus;                 // Copy status to memory
	    #qUDT_Status := #sUDT_CommonStatus;                          // Copy status to output
	    
	END_REGION
	
	REGION 9 - Report to control block
	    // Function to manage report between control block and conveyor block
	    "FC_EquipmentReport"(iUDT_Status := #sUDT_CommonStatus,
	                         iqUDT_Control := #iqUDT_EquipmentControl);
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_ConnectionCheck"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 3.2
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 205
// END_ATTRIBUTES
   VAR_INPUT 
      ib_Watchdog { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Input watchdog
      ix_Trigger100ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Cycled 100 ms trigger
   END_VAR

   VAR_OUTPUT 
      qb_Watchdog { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Generated watchdog
   END_VAR

   VAR_IN_OUT 
      iqudt_ConnectionStatus : "UDT_ConnectStatus";   // Connection status
   END_VAR

   VAR 
      s_FB_ConnectionFaultTimerOnDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Connection fault timer on delay
      sb_InWatchdogOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Watch dog old
      sb_GeneratedWatchdog { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Generated watchdog
      sx_SetConnectionFaultTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Set connection fault timer
      sx_ConnectionFault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Connection faulr
   END_VAR

   VAR CONSTANT 
      cudi_ConnectionFaultOnDelay : UDInt := 10000;   // Connection On Delay
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------   
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	31/03/2022  | 3.0       | M. Piela      | First release TIA 16
	06/09/2023  | 3.1       | S. Nikodem    | Added watchdog generations on output
	11/09/2023  | 3.2       | S. Theocharis | Corrected variable prefixes
	*)
	
	REGION 1 - Connection check
	    
	    #sx_SetConnectionFaultTimer := (#ib_Watchdog = #sb_InWatchdogOld);
	    
	    IF #ib_Watchdog <> #sb_InWatchdogOld
	    THEN
	        #sb_InWatchdogOld := #ib_Watchdog;
	    END_IF;
	    
	    #s_FB_ConnectionFaultTimerOnDelay(iudi_OnDelayTime := #cudi_ConnectionFaultOnDelay,
	                                      ix_SignalToDelay := #sx_SetConnectionFaultTimer,
	                                      ix_Enable := TRUE,
	                                      qx_DelayedSignal => #sx_ConnectionFault);
	    
	END_REGION
	
	REGION 2 - Status update
	    
	    #iqudt_ConnectionStatus.Specific.CommunicationFault := #sx_ConnectionFault;
	    #iqudt_ConnectionStatus.Specific.Connected := NOT #sx_ConnectionFault;
	    
	    IF #sx_ConnectionFault
	    THEN
	        #iqudt_ConnectionStatus.Status := "DB_HMIStatusConfiguration".CommunicationError;
	    END_IF;
	    
	    IF NOT #sx_ConnectionFault
	    THEN
	        #iqudt_ConnectionStatus.Status := "DB_HMIStatusConfiguration".AutoON;
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Watchdog generations
	    
	    //Watchdog counter to be updated after every 100 msec
	    IF #ix_Trigger100ms THEN
	        
	        IF #sb_GeneratedWatchdog >= 255 OR #sb_GeneratedWatchdog < 0
	        THEN
	            #sb_GeneratedWatchdog := 0;
	        END_IF;
	        
	        #sb_GeneratedWatchdog := INT_TO_BYTE(BYTE_TO_INT(#sb_GeneratedWatchdog) + 1);
	        
	    END_IF;
	    
	    //Copy value
	    #qb_Watchdog := #sb_GeneratedWatchdog;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_ControlPowerGroupWOR"
TITLE = Control Power Group
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : CesarLeite
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 206
// END_ATTRIBUTES
//This block is used to monitoring the 24V power supplies.
   VAR_INPUT 
      ix_PowerSupplyOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE if power supply is OK
      ix_HardwareOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Hardware is ok
      iudi_DelayPowerSupplyOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   //  Time to delay power supply ok signal
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ControlPowerGroupWORStatus";   //   HMI status structure
      qUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   //   Common status structure
      qx_ResetPowerSupply { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   //   CIP Equipment control
      iqUDT_Statistics : "UDT_ControlPowerGroupWORStatistics";   //   CPG Statistics structure
   END_VAR

   VAR 
      sUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ControlPowerGroupWORStatus";   //   HMI status structure
      sUDT_CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //   Common status structure
      sUDT_CommonStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //   Auxiliary status structure
      sFB_DelayInput { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sFB_DelayHardwarOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sFB_DelayResetPowerSupply { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sR_TRIG_Error {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge for error
      sx_ResetPowerSupply { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR CONSTANT 
      cudi_ResetPowerSupplyTime : UDInt := 3000;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	12/10/2021  | 0.1       | J.Krawczuk    | first release TIA 15.1
	12/11/2021  | 0.2       | S.Theocharis  | Change code to match names of new status UDT
	06/06/2021  | 0.3       | K. Pokorski   | Added PSC reset output
	25/07/2022  | 0.4       | M.Piela       | Change running status to AutoOn
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Power Supply monitoring
	    
	    // Delay on power supply ok signal to mask wrong SPG power errors 
	    #sFB_DelayInput(iudi_OnDelayTime := 0,
	                    iudi_OffDelayTime := #iudi_DelayPowerSupplyOK,
	                    ix_SignalToDelay := #ix_PowerSupplyOK);
	    
	    #sFB_DelayHardwarOK(iudi_OnDelayTime := #iudi_DelayPowerSupplyOK,
	                        iudi_OffDelayTime := 0,
	                        ix_SignalToDelay := #ix_HardwareOK);
	    
	END_REGION
	
	REGION 2 - Reset
	    
	    #sx_ResetPowerSupply := FALSE;
	    IF #iqUDT_EquipmentControl.Command.Reset
	    THEN
	        #sUDT_HMIStatus.Specific.PowerSuppliesError := FALSE;
	        #sx_ResetPowerSupply := TRUE;
	    END_IF;
	    
	    #sFB_DelayResetPowerSupply(iudi_OffDelayTime := #cudi_ResetPowerSupplyTime,
	                               ix_SignalToDelay := #sx_ResetPowerSupply,
	                               qx_DelayedSignal => #qx_ResetPowerSupply);
	    
	    
	END_REGION
	
	REGION 3 - Status
	    
	    // Set error state if there is an error with the power supply 
	    IF NOT #sFB_DelayInput.qx_DelayedSignal            // Delayed power ok signal
	        AND #sFB_DelayHardwarOK.qx_DelayedSignal       // Delayed hardware ok signal
	    THEN
	        #sUDT_HMIStatus.Specific.PowerSuppliesError := TRUE;
	        
	    END_IF;
	    
	    // R_TRIG for statistics purposes
	    #sR_TRIG_Error(CLK := #sUDT_HMIStatus.Specific.PowerSuppliesError);
	    
	END_REGION
	
	REGION 4 - Statistics
	    
	    //  Error statistics
	    IF #sUDT_HMIStatus.Specific.PowerSuppliesError
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.PowerSuppliesError,
	                        ix_RTrigActivate := #sR_TRIG_Error.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.PowerSupplyError);
	        
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Status Update
	    
	    #sUDT_CommonStatus.Error := #sUDT_HMIStatus.Specific.PowerSuppliesError;
	    #sUDT_CommonStatus.AutoON := NOT #sUDT_HMIStatus.Specific.PowerSuppliesError;
	    
	    
	    // HMI status update
	    IF #sUDT_CommonStatusOld <> #sUDT_CommonStatus                    // update on change
	    THEN
	        
	        // HMI status initialization
	        #sUDT_HMIStatus.Status := 0;
	        
	        IF #sUDT_CommonStatus.AutoON
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".AutoON;
	        END_IF;
	        
	        
	        IF #sUDT_CommonStatus.Error                                    // Error
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Error;
	            
	        END_IF;
	        
	        
	        #qUDT_Status := #sUDT_CommonStatus;                           // Copy status to output
	        #sUDT_CommonStatusOld := #sUDT_CommonStatus;                  // Copy status to memory
	        
	    END_IF;
	    #qUDT_HMIStatus := #sUDT_HMIStatus;                               // Copy HMI status to output
	    
	    
	END_REGION
	
	REGION 6 - Report to control block
	    
	    // Function to manage report between control block and equipment block 
	    
	    "FC_EquipmentReport"(iUDT_Status := #sUDT_CommonStatus,
	                         iqUDT_Control := #iqUDT_EquipmentControl);
	    
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_Conveyor"
TITLE = FB_Conveyor_BiDirectional
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : Equimpent
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 207
// END_ATTRIBUTES
//Function block to control the bi-directional conveyor.
   VAR_INPUT 
      iUDT_ConveyorConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorConfiguration";   //           Conveyor configuration structure
      idi_PECEoSDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Distance between photo eye and the end of conveyor [mm] in forward direction
      idi_PECBoSDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Distance between photo eye and the end of conveyor [mm] in reverse direction
      ii_ExternalSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //           External speed [mm/s]
      ix_SafetyOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           TRUE when safety is ok
      ix_24vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           TRUE when 24VDC is healthy
      ix_400vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           TRUE when 400VAC is healthy
      ix_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           TRUE when  hardware is Ok
      ix_PECEoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;   //           TRUE when the end of section photoeye in forward direction is not blocked
      ix_PECBoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;   //           TRUE when the end of section photoeye in reverse direction is not blocked
      ix_ReverseDirection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           FALSE when to run in forward direction and True to run in Reverse direction
      ix_ExternalRequestDieBack { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           External input to request die back
      ix_ExternalRequestHold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           External input to request conveyor hold
      ix_ResetEnergySave { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Reset energy save mode timer
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorStatus";   //           HMI status structure
      qUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   //           Common status structure
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   //           Equipment control structure
      iqUDT_ConveyorCommand : "UDT_ConveyorCommand";   //           Conveyor command stucture
      iqUDT_ConveyorInterface : "UDT_ConveyorInterface";   //           Interface structure
      iqUDT_HandShakeUp : "UDT_ConveyorHandshake";   //           Upstream handshake structure in forward direction
      iqUDT_HandShake : "UDT_ConveyorHandshake";   //           Handshake structure in forward direction
      iqUDT_Statistics : "UDT_ConveyorStatistics";   //           Statistics structure
   END_VAR

   VAR 
      sUDT_CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //           Common status structure
      sUDT_CommonStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //           Auxiliary status structure
      sUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";   //           HMI status structure
      sFB_CascadeModeTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //           Timer to cascade start
   END_VAR
   VAR RETAIN
      sdi_GapHeadToHeadConfigurationFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Preset forward gap head to head with correction [cm]
      sdi_GapTailToHeadConfigurationFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Preset forward gap tail to head with correction [cm]
      sdi_GapHeadToHeadConfigurationRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Preset reverse gap head to head with correction [cm]
      sdi_GapTailToHeadConfigurationRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Preset reverse gap tail to head with correction [cm]
      sdi_AuxGapHeadToHeadCounterFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Aux variable to count the head to head
      sdi_AuxGapTailtoHeadCounterFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Aux variable to count the gap
      sdi_AuxGapHeadToHeadCounterRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Aux variable to count the head to head
      sdi_AuxGapTailtoHeadCounterRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Aux variable to count the gap
      sdi_GapFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Gap between two products
      sdi_GapHeadToHeadFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Head to head between two products
      sdi_Gap_Rvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Gap between two products
      sdi_GapHeadToHeadRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Head to head between two products
      sdi_TailToBeginFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Count tail to next conveyor distance
      sdi_HeadToEndFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Count head to end distance
      sdi_TailToBeginRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Count tail to next conveyor distance
      sdi_HeadToEndRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Count head to end distance
      sdi_PECEoSDistanceFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Real distance between PEC and the end of distance
      sdi_PECtoEndDistanceFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Distance between photeye and the end of the conveyor in cm
      sdi_PEC_EoSDistanceRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Real distance between PEC and the end of distance
      sdi_PECtoEndDistanceRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Distance between photeye and the end of the conveyor in cm
      sdi_AuxEnergySaveFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Auxiliary variable to calculate energy save displacement
      sdi_AuxEnergySaveRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Auxiliary variable to calculate energy save displacement
      sdi_DownstreamGapTailtoHeadFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Gap between the beginning of the conveyor and the closer parcel in that conveyor
      sdi_DownstreamGapHeadToHeadFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Head to head between the beginning of the conveyor and the closer parcel in that conveyor
      sdi_DownstreamGapTailtoHeadRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Gap between the beginning of the conveyor and the closer parcel in that conveyor
      sdi_DownstreamGapHeadToHeadRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Head to head between the beginning of the conveyor and the closer parcel in that conveyor
      sdi_TransitionZone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Counter of product in transition zone
   END_VAR
   VAR 
      sR_TRIG_ManualMode {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge trigger manual mode
      sR_TRIG_Jog {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge trigger manual jog
      sR_TRIG_PE_EoSFiltered_Rvs {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge trigger end of section photo eye filtered
      sR_TRIG_PE_EoSFiltered_Fwd {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge trigger end of section photo eye filtered
      sR_TRIG_TailToBegin_Rvs {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge trigger Tail arrive at the beginning of next conveyor
      sR_TRIG_TailToBegin_Fwd {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge trigger Tail arrive at the beginning of next conveyor
      sF_TRIG_ManualMode {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //           Falling edge trigger manual mode
      sF_TRIG_Jog {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //           Falling edge trigger manual mode jog
      sF_TRIG_PEC_EoSFiltered_Rvs {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //           Falling edge trigger end of section photo eye filtered
      sF_TRIG_PEC_EoSFiltered_Fwd {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //           Falling edge trigger end of section photo eye filtered
      sF_TRIG_AuxHeadToEnd_Rvs {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //           Falling edge trigger Aux head to end bit
      sF_TRIG_AuxHeadToEnd_Fwd {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //           Falling edge trigger Aux head to end bit
      sR_TRIG_ConveyorUp {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge trigger conveyor up time
      sR_TRIG_EnergySave {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge trigger energy save
      sR_TRIG_VFDRunning {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge trigger VFD running
      sR_TRIG_ConveyorDownTime {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge trigger conveyor down
      sR_TRIG_RunManual {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge run conveyor in manual mode
      sR_TRIG_Transfering_Rvs {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge transfering
      sR_TRIG_Transfering_Fwd {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge transfering
      sF_TRIG_HeadAtEnd_Rvs {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //           Falling edge head at the end of the conveyor
      sF_TRIG_HeadAtEnd_Fwd {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //           Falling edge head at the end of the conveyor
      sR_TRIG_Reverse {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge of reverse direction
      sF_TRIG_Reverse {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //           Falling edge of reverse direction
      sR_Trig_DirectionChange {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge of change direction
      sF_Trig_DirectionChange {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //           Falling edge of change direction
      sR_TRIG_PrestartManual {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge of manual prestart
      sR_TRIG_ConveyorStopped {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge of stop
      sx_Ready { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Conveyor Ready to operate in Automatic mode
   END_VAR
   VAR RETAIN
      sx_StartReceived { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Save start trigger from the system
      sx_EnergySaveActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Active energy save mode
      sx_AuxHeadToEndFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Aux bit to control head to end positioning in forward direction
      sx_AuxHeadToEndRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Aux bit to control head to end positioning in reverse direction
      sx_TailToBeginFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Tail to begin done in forward direction
      sx_TailToBeginRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Tail to begin done in reverse direction
      sx_GappingFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Gapping in process in forward direction
      sx_GappingRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Gapping in process in reverse direction
   END_VAR
   VAR 
      sx_AutomaticActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Automatic active
   END_VAR
   VAR RETAIN
      sx_RecoveryGapFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Recovery gap activated in forward direction
      sx_RecoveryGapRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Recovery gap activated in reverse direction
   END_VAR
   VAR 
      sx_ManualModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Manual mode active
      sx_PreStartManual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Pre conditions to run conveyor in manual mode
   END_VAR
   VAR RETAIN
      sx_AuxHeadAtEndFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Parcel reach the end of the conveyor in forward direction
      sx_AuxHeadAtEndRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Parcel reach the end of the conveyor in reverse direction
   END_VAR
   VAR 
      sx_CascadeStartUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Cascade startup auxiliary bit
      sx_DirectionChanged { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Change direction until stop
      sx_ReverseDirection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Direction Selection auxiliary bit
      sx_ManualRunning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //          Conveyor running in manual mode
      sx_Up { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Conveyor is up
      sx_Down { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Conveyor is down
      sx_Stopped { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Conveyor is stopped
   END_VAR

   VAR_TEMP 
      tx_CascadeStart : Bool;
   END_VAR

   VAR CONSTANT 
      ci_OverflowLimit : Int := 32000;   //           Limit int overflow
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	            | 3.0       | C.Leite       | First release TIA 15.1
	01/01/2020  | 3.1       | S. Deulkar    | Modified error loging, added reset to reset internal error
	                                        | Cosidered commissioning error to put conveyor in ready state
	07/01/2020  | 3.2       | C. Leite      | Manual mode bug corrected related with conveyor start 
	10/01/2020  | 3.3       | C. Leite      | Manual mode start\stop change
	                                        | Lenght conveyor data type was changed to DInt  
	14/01/2020  | 3.4       | F.Baten       | Renamed Trail to Tail
	                                        | Renamed ii_PEC_EosDistance_EoS to idi_PEC_EoSDistance same for BoS 
	21/01/2020  | 3.5       | C.Leite       | Reset gapping bits when the direction changes 
	06/01/2020  | 3.6       | S. Deulkar    | Added safety Ok in condition to make ready status
	25/02/2020  | 3.7       | S. Deulkar    | Modified to update ststus output every cycle
	21/04/2020  | 3.8       | F.Baten       | Modified energysave reset
	23/04/2020  | 3.9       | S. Deulkar    | Modified logic for reset energy save command if it is slave conveyor
	22/06/2020  | 3.10      | K. Pokorski   | Modified singaling request activation, modified stop conditions (Handshake ReqStop)
	02/07/2020  | 3.11      | K. Pokorski   | Modified condition to disable manual mode (safety ok)
	30/07/2020  | 3.12      | S. Theocharis | Reset HMI commands of manual mode when conveyor no ready
	                                        | Keep downstream running when the a PEC error occurs 
	04/08/2020  | 3.13      | S. Deulkar    | Deletded Manual run stop command and Modified code to let 
	                                        | let slave conveyor go in energy save, Optimized energy save logic
	17/08/2020  | 3.14      | L.Klar        | Gapping corrected to work with PEC offset. Gap correction configuration added
	17/08/2020  | 3.15      | S. Theocharis | Encoder fault added. Manual mode active to interface. Stop trigger added for statistics
	                                        | Fix  statistics 
	11/01/2021  | 3.16      | L.Klar        | Input safety ok added to stop conveyor condition
	02/03/2021  | 3.17      | K. Pokorski   | Halted status enable only when automatic on
	11/03/2021  | 3.18      | S. Theocharis | Added bulk flow mode 3
	13/03/2021  | 3.19      | S. Theocharis | Warning color commented, line 665 added, sensors initial values changed to true
	15/03/2021  | 3.20      | S. Theocharis | Energy safe corrected
	29/03/2021  | 3.21      | M. Kocot      | Added HMI command for manual speed percetage selection and modified logic for cascade 
	                                        | startup
	31/03/2021  | 3.22      | H.Rutkowski   | Changed logic for TransitionZone calculation in mode 3( Converted PEC distance to cm)
	14/05/2021  | 3.23      | S. Nikodem    | Reset value from iq_UDT_HandShakeUp.DownstreamDisplacement and iq_UDT_HandShake.DownstreamDisplacement
	28/06/2021  | 3.24      | N.Kadam       | Modified logic for conveyor downtime and Esave statistics
	29/07/2021  | 3.25      | S. Deulkar    | Autotic ON condition is added to excecut region 7: Automatic mode active
	                                        | Statistics are updated after status
	11/11/2021  | 3.26      | M.Singh       |Shared Hardware signal over Interface
	28/03/2022  | 3.27      | M.Singh       |Solved Esave Bug, Swapped regions "Operation modes" and "Energy Save"
	28/07/2022  | 3.28      | M.Singh       |Removed handsakeUP.RTR from conditions determining downstream TIP and RTS
	30/07/2022  | 3.28      | M.Singh       |Addded hardware ok as condition to show safety status 
	                                        |Added Aux Head at end and TIP to Esave Reset conditions
	                                        
	                                        
	*)
	
	REGION 1 - Initial
	    
	    REGION 1.1 - First PLC cycle
	        
	        // Conveyor stops in the first scan of the PLC
	        IF "DB_Memory".FirstScan
	        THEN
	            #iqUDT_EquipmentControl.Command.Start := FALSE;    // Command start
	            #sx_AutomaticActive := FALSE;                       // switch of automatic active
	            #iqUDT_HandShakeUp.RTR := False;                   // Reset RTR signal
	            
	            #iqUDT_HandShakeUp.CascadeStartUp := FALSE;        // Reset cascade start signal
	            
	            #iqUDT_ConveyorInterface.RunFwd := FALSE;          // Order to run forward to VFD
	            #iqUDT_ConveyorInterface.RunRvs := FALSE;          // Order to run reverse to VFD
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 1.2 - Conversion distance between PEC and end of conveyor [mm to cm]
	        
	        // Move PEC Distance into a static variable. Added on version 2.8
	        #sdi_PECEoSDistanceFwd := #idi_PECEoSDistance;
	        #sdi_PEC_EoSDistanceRvs := #iUDT_ConveyorConfiguration.Common.Length - #idi_PECBoSDistance;
	        
	        // Limit to prevent malfunctions with zero or negative values. Added on version 2.8
	        IF #sdi_PECEoSDistanceFwd < 10
	        THEN
	            #sdi_PECEoSDistanceFwd := 10;
	        END_IF;
	        
	        IF #sdi_PEC_EoSDistanceRvs < 10
	        THEN
	            #sdi_PEC_EoSDistanceRvs := 10;
	        END_IF;
	        
	        //  Convertion of the distance between photo eye and the end of the conveyor from mm to cm.
	        #sdi_PECtoEndDistanceFwd := (#sdi_PECEoSDistanceFwd
	        - #iUDT_ConveyorConfiguration.Forward_Direction.PEC_EoSDistanceOffset) / 10;
	        
	        #sdi_PECtoEndDistanceRvs := (#sdi_PEC_EoSDistanceRvs
	        - #iUDT_ConveyorConfiguration.Reverse_Direction.PEC_BoSDistanceOffset) / 10;
	        
	        
	        // Limit the Pec to End distance in positive ranges. Added on version 2.7
	        IF #sdi_PECtoEndDistanceFwd < 1 THEN
	            #sdi_PECtoEndDistanceFwd := 1;
	        END_IF;
	        
	        IF #sdi_PECtoEndDistanceRvs < 1 THEN
	            #sdi_PECtoEndDistanceRvs := 1;
	        END_IF;
	        
	        #sx_ReverseDirection := (#iqUDT_ConveyorCommand.Reverse OR #ix_ReverseDirection) AND #iUDT_ConveyorConfiguration.Bi_Directional_Enable;
	        
	        
	    END_REGION
	    
	    REGION 1.3 Conditions Up - Down - Stopped
	        //Used for statistics
	        
	        #sx_Up := (#sx_AutomaticActive                               // Automatic active
	        AND #sx_Ready                                                // Ready active
	        AND NOT #sx_EnergySaveActive);                              // Not in energy save
	        
	        #sx_Down := (NOT #sx_ManualModeActive                                                   // Not in manual mode
	        AND #sUDT_CommonStatus.Error                                                           // in error 
	        AND NOT #sx_Ready                                                                       // Conveyor not ready
	        AND NOT #sx_EnergySaveActive);                                                          // Not in energy save
	        
	        #sx_Stopped := (NOT #sx_AutomaticActive AND #sx_Ready);
	        
	    END_REGION
	    
	    REGION 1.3 - Triggers
	        
	        // Rising edge trigger manual mode
	        #sR_TRIG_ManualMode(CLK := #iqUDT_ConveyorCommand.ManualMode
	                            OR #iqUDT_EquipmentControl.Command.ManualMode);
	        
	        // Falling edge trigger manual mode
	        #sF_TRIG_ManualMode(CLK := #iqUDT_ConveyorCommand.ManualMode
	                            OR #iqUDT_EquipmentControl.Command.ManualMode);
	        
	        // Rising edge trigger manual mode jog
	        #sR_TRIG_Jog(CLK := #iqUDT_ConveyorCommand.ManualJog);
	        
	        // Falling edge trigger manual mode jog
	        #sF_TRIG_Jog(CLK := #iqUDT_ConveyorCommand.ManualJog);
	        
	        // Rising edge trigger to start in manual mode
	        #sR_TRIG_RunManual(CLK := #iqUDT_ConveyorCommand.ManualStartStop);
	        
	        // Rising edge trigger end of section photo eye filtered
	        #sR_TRIG_PE_EoSFiltered_Fwd(CLK := #ix_PECEoS);
	        #sR_TRIG_PE_EoSFiltered_Rvs(CLK := #ix_PECBoS);
	        
	        // Falling edge trigger end of section photo eye filtered
	        #sF_TRIG_PEC_EoSFiltered_Fwd(CLK := #ix_PECEoS);
	        #sF_TRIG_PEC_EoSFiltered_Rvs(CLK := #ix_PECBoS);
	        
	        // Rising edge conveyor up
	        #sR_TRIG_ConveyorUp(CLK := #sx_Up);
	        
	        // Rising edge energy save mode
	        #sR_TRIG_EnergySave(CLK := #sx_EnergySaveActive);
	        
	        // Rising edge running
	        #sR_TRIG_VFDRunning(CLK := #iqUDT_ConveyorInterface.VFDRunning);
	        
	        // Rising edge conveyor conveyor down
	        #sR_TRIG_ConveyorDownTime(CLK := #sx_Down);
	        
	        //Rising edge conveyor stopped
	        #sR_TRIG_ConveyorStopped(CLK := #sx_Stopped);
	        
	        // Rising edge conveyor command reverse direction
	        #sR_TRIG_Reverse(CLK := #iqUDT_ConveyorCommand.Reverse);
	        
	        // Falling edge conveyor command reverse direction
	        #sF_TRIG_Reverse(CLK := #iqUDT_ConveyorCommand.Reverse);
	        
	        // Rising edge conveyor change direction
	        #sR_Trig_DirectionChange(CLK := #sx_ReverseDirection);
	        
	        // Falling edge conveyor change direction
	        #sF_Trig_DirectionChange(CLK := #sx_ReverseDirection);
	        
	    END_REGION
	    
	    REGION 1.4 - Move displacement to upstream
	        
	        // Downstream displacement is mode to upstream conveyor to calculate gap
	        
	        IF NOT #sx_ReverseDirection
	        THEN
	            #iqUDT_HandShakeUp.DownstreamDisplacement := #iqUDT_ConveyorInterface.Displacement;
	        ELSE
	            #iqUDT_HandShake.DownstreamDisplacement := #iqUDT_ConveyorInterface.Displacement;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 1.5 - Change direction
	        
	        // The memory bit to change direction is activated when the input is trigger
	        
	        IF #sR_Trig_DirectionChange.Q
	            OR #sF_Trig_DirectionChange.Q
	        THEN
	            #sx_DirectionChanged := TRUE;
	        END_IF;
	        
	        // The direction changed memory bit is just reset when the conveyor stops to prevente mechanical problems
	        
	        IF #sx_DirectionChanged
	            AND #iUDT_ConveyorConfiguration.Bi_Directional_Enable
	            AND NOT #iqUDT_ConveyorInterface.VFDatSpeed
	            AND NOT #iqUDT_ConveyorInterface.VFDRunning
	            AND (#iqUDT_ConveyorInterface.ActualSpeed <= 0)
	        THEN
	            #sx_DirectionChanged := FALSE;
	            
	            #sx_AuxHeadAtEndFwd := FALSE;
	            #sx_AuxHeadAtEndRvs := FALSE;
	            
	            #sdi_AuxGapHeadToHeadCounterFwd := 0;
	            #sdi_AuxGapHeadToHeadCounterRvs := 0;
	            
	            #sdi_AuxGapTailtoHeadCounterRvs := 0;
	            #sdi_AuxGapTailtoHeadCounterFwd := 0;
	            
	            #sx_GappingRvs := FALSE;
	            #sx_GappingFwd := FALSE;
	            
	            #iqUDT_HandShake.TIP := FALSE;
	            #iqUDT_HandShakeUp.TIP := FALSE;
	            
	            #iqUDT_HandShakeUp.DownstreamDisplacement := 0;     // v3.23
	            #iqUDT_HandShake.DownstreamDisplacement := 0;       // v3.23
	            
	        END_IF;
	        
	        IF (#sR_Trig_DirectionChange.Q
	            AND NOT #ix_PECBoS)
	            OR (#sF_Trig_DirectionChange.Q
	            AND NOT #ix_PECEoS)
	            AND #iUDT_ConveyorConfiguration.Bi_Directional_Enable
	        THEN
	            #sdi_AuxGapHeadToHeadCounterFwd := 0;
	            #sdi_AuxGapHeadToHeadCounterRvs := 0;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 1.5 - Gaps configuration
	        
	        // Forward head to head
	        #sdi_GapHeadToHeadConfigurationFwd := #iUDT_ConveyorConfiguration.Forward_Direction.GapHeadToHead + #iUDT_ConveyorConfiguration.Forward_Direction.GapCorrection;
	        // Forward tail to head
	        #sdi_GapTailToHeadConfigurationFwd := #iUDT_ConveyorConfiguration.Forward_Direction.GapTailToHead + #iUDT_ConveyorConfiguration.Forward_Direction.GapCorrection;
	        // Reverse head to head
	        #sdi_GapHeadToHeadConfigurationRvs := #iUDT_ConveyorConfiguration.Reverse_Direction.GapHeadToHead + #iUDT_ConveyorConfiguration.Reverse_Direction.GapCorrection;
	        // Reverse tail to head
	        #sdi_GapTailToHeadConfigurationRvs := #iUDT_ConveyorConfiguration.Reverse_Direction.GapTailToHead + #iUDT_ConveyorConfiguration.Reverse_Direction.GapCorrection;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 2 - Reset faults
	    
	    REGION 2.1 - Send reset request to interface UDT
	        
	        // Reset signal is sent to the interface UDT (VFD block, Tracking block, PEC update block)
	        #iqUDT_ConveyorInterface.InternalErrorReset := #iqUDT_EquipmentControl.Command.Reset;
	        
	        #iqUDT_ConveyorInterface.ResetStatistics := #iqUDT_EquipmentControl.Command.ResetData;
	        
	    END_REGION
	    
	    
	    REGION 2.2 - Error / warning
	        
	        #sUDT_CommonStatus.Error := #iqUDT_ConveyorInterface.InternalErrorPEC               // Internal PEC error status
	        OR #iqUDT_ConveyorInterface.InternalErrorVFD               // Internal VFD error status
	        OR #iqUDT_ConveyorInterface.InternalErrorTracking          // Internal tracking error status
	        OR #iqUDT_ConveyorInterface.Disconnected                   // Isolator switch error status 
	        OR #iqUDT_ConveyorInterface.InternalErrorEncoder;          // Encoder error
	        
	        
	        #sUDT_CommonStatus.Warning := #iqUDT_ConveyorInterface.InternalWarningTracking        // v2.3 Internal Warning Tracking  added
	        OR #iqUDT_ConveyorInterface.InternalWarningVFD;                                        // v2.3 Internal Warning VFD added
	        
	    END_REGION
	    
	END_REGION
	
	REGION 3 - Check conditions to set conveyor ready
	    //Share HardwareOK signal over interface
	    #iqUDT_ConveyorInterface.HardwareOk := #ix_HardwareOk;
	    
	    //  Conditions to set bit sx_Ready to operate in automatic mode
	    #sx_Ready := NOT #sUDT_CommonStatus.Error                              // Ready bit is set true when common error status its false
	    AND #ix_SafetyOk
	    AND #ix_24vOk                                                        // 24V error status
	    AND #ix_400vOk                                                       // 400V error status
	    AND #ix_HardwareOk                                                   // Profinet error status
	    AND NOT #iqUDT_ConveyorInterface.ConfigurationError;                // No configuration error      
	    
	END_REGION
	
	REGION 4 - Stop conveyor
	    
	    // Conditions to stop conveyor
	    IF (#sF_TRIG_Jog.Q                                           // Trigger when conveyor stops jogging by HMI
	        AND #sx_ManualModeActive)                                   // Manual mode is active
	        
	        OR (NOT #iqUDT_EquipmentControl.Command.AutomaticOn        // Conveyor stops if the bit AutomaticOn from control block is false
	        AND NOT #sx_ManualModeActive)                               // Manual mode active bit
	        
	        OR (NOT #sx_Ready                                           // Bit conveyor ready to run in automatic mode
	        AND NOT #sx_ManualModeActive)                               // Manual mode active
	        
	        OR #sR_TRIG_ManualMode.Q                                     // Trigger when manual mode is set on
	        OR #sF_TRIG_ManualMode.Q                                     // Trigger when manual mode is set off
	        
	        OR (#iqUDT_HandShakeUp.ReqStop                             // Stop request from upstream if direction not changed
	        AND NOT #sx_DirectionChanged)
	        
	        OR (#iqUDT_HandShake.ReqStop                               // Stop request from downstream if direction changed
	        AND #sx_DirectionChanged)
	        
	        OR NOT #ix_SafetyOk
	        
	    THEN
	        //  Order to stop VFD
	        #iqUDT_ConveyorInterface.RunFwd := FALSE;                  // Set false order to VFD run in forward direction
	        #iqUDT_ConveyorInterface.RunRvs := FALSE;                  // Set false order to VFD run in reverse direction
	        
	        IF NOT #sx_ReverseDirection
	        THEN
	            
	            #iqUDT_HandShakeUp.RTR := FALSE;                       // Set false the bit ready to receive
	            #iqUDT_HandShakeUp.CascadeStartUp := FALSE;            // Set false cascade start up bit
	            
	        ELSE
	            
	            #iqUDT_HandShake.RTR := FALSE;                       // Set false the bit ready to receive
	            #iqUDT_HandShake.CascadeStartUp := FALSE;            // Set false cascade start up bit
	            
	        END_IF;
	        
	        #sx_AutomaticActive := FALSE;                               // Automatic mode is disable
	        //    #sx_StartReceived := FALSE;                                 // Clear start receive bit 
	        
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Start
	    
	    REGION 5.1 - Save Start bit request
	        
	        // The conditions to set the bit "startReceived" are: 
	        // - Conveyor not in manual mode.
	        // - Conveyor ready to run.
	        // - Bit AutomaticOn from control block must be on.
	        // - Bit start form control block on.
	        
	        IF #iqUDT_EquipmentControl.Command.Start
	            AND #iqUDT_EquipmentControl.Command.AutomaticOn
	        THEN
	            #sx_StartReceived := TRUE;          // Start bit from control block received
	        END_IF;
	        
	    END_REGION
	    
	    REGION 5.2 - Cascade mode
	        
	        (* If the bit "StartReceived" is set, automatic mode is activated if the conveyor is set as the first one to run
	         or the bit cascadestartup from downstream is on. *)
	        
	        IF #iqUDT_EquipmentControl.Command.Start
	            AND #iqUDT_EquipmentControl.Command.AutomaticOn
	            AND NOT #sx_ManualModeActive
	            AND #sx_Ready
	        THEN
	            #sx_AutomaticActive := TRUE;        // Conveyor active automatic mode
	        END_IF;
	        
	        //Timer to cascade mode
	        #tx_CascadeStart := #sx_StartReceived
	        AND ((NOT #sx_ReverseDirection
	        AND (#iUDT_ConveyorConfiguration.Forward_Direction.FirstConveyorToStart
	        OR #iqUDT_HandShake.CascadeStartUp))
	        OR (#sx_ReverseDirection
	        AND (#iUDT_ConveyorConfiguration.Reverse_Direction.FirstConveyorToStart
	        OR #iqUDT_HandShakeUp.CascadeStartUp)));
	        
	        #sFB_CascadeModeTimer(iudi_OnDelayTime := #iUDT_ConveyorConfiguration.CascadeTimeOnDelay,      // Cascade mode timer
	                              ix_SignalToDelay := #tx_CascadeStart,
	                              ix_Enable := TRUE,                                                   // Signal ready to enable cascade mode
	                              qx_DelayedSignal => #sx_CascadeStartUp);
	        
	        IF NOT #iqUDT_EquipmentControl.Command.AutomaticOn
	        THEN
	            #sx_StartReceived := False;
	        END_IF;
	        
	        
	        // Cascade mode signal to upstream
	        IF NOT #sx_ReverseDirection
	        THEN
	            #iqUDT_HandShakeUp.CascadeStartUp := #sx_CascadeStartUp;
	        ELSE
	            #iqUDT_HandShake.CascadeStartUp := #sx_CascadeStartUp;
	        END_IF;
	        
	        
	        
	    END_REGION
	    
	END_REGION
	
	REGION 6 - Manual mode
	    
	    REGION 6.1 - Manual mode force disable
	        
	        // Manual mode bits inputs can be reset in case of malfunction
	        IF #iqUDT_EquipmentControl.Command.DisableManualMode
	        THEN
	            #iqUDT_ConveyorCommand.ManualMode := False;
	            #iqUDT_EquipmentControl.Command.ManualMode := False;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 6.2 - Manual mode activation 
	        
	        // Manual mode is active if it is active from hmi or by control block  
	        #sx_ManualModeActive := #iqUDT_ConveyorCommand.ManualMode
	        OR #iqUDT_EquipmentControl.Command.ManualMode;
	        
	        //Send manual mode active to PEC/VFD blocks to supress errors
	        #iqUDT_ConveyorInterface.ManualModeActive := #sx_ManualModeActive;
	        
	    END_REGION
	    
	    REGION 6.3 - Reset manual commands 
	        //When the system is not any more in manual mode or when fatal error occurs the HMI commands should be reset
	        //Added in V3.12 as bug fix. 
	        IF NOT #ix_SafetyOk
	            OR NOT #ix_24vOk                                                        // 24V error status
	            OR NOT #ix_400vOk                                                       // 400V error status
	            OR NOT #ix_HardwareOk                                                   // Profinet error status
	            OR #iqUDT_ConveyorInterface.ConfigurationError                          // No configuration err
	            OR #iqUDT_ConveyorInterface.InternalErrorVFD
	            OR #iqUDT_ConveyorInterface.Disconnected
	            OR NOT #sx_ManualModeActive
	        THEN
	            #iqUDT_ConveyorCommand.ManualStartStop := FALSE;
	            #iqUDT_ConveyorCommand.ManualFullSpeed := FALSE;
	            #iqUDT_ConveyorCommand.ManualJog := FALSE;
	            #iqUDT_ConveyorCommand.Reverse := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 6.4 - Start/Stop
	        
	        // Pre start conditions to run in manual mode
	        #sx_PreStartManual := #sx_ManualModeActive              // Manual mode active bit
	        AND #ix_SafetyOk                                        // Safety healthy bit
	        AND NOT #iqUDT_ConveyorInterface.Disconnected          // Isolator switch connected
	        AND #ix_HardwareOk                                      // Profinet comunication 
	        AND NOT #iqUDT_ConveyorInterface.InternalErrorVFD;     // Internal error from VFD
	        
	        #sR_TRIG_PrestartManual(CLK := #sx_PreStartManual);
	        
	        
	        IF (#sx_PreStartManual                                  // Pre start conditions to run in manual mode
	            AND (#sR_TRIG_RunManual.Q                            // Trigger when conveyor start running in manual mode
	            OR (#iqUDT_ConveyorCommand.ManualStartStop             // Conveyor start running in manual mode active
	            AND #sR_TRIG_PrestartManual.Q)                       // Trigger when pre start conditions ti run in manual mode
	            AND NOT #iqUDT_ConveyorCommand.ManualJog)          // Conveyor is not running in jog
	            OR (#sx_PreStartManual AND #sR_TRIG_Jog.Q                                   // Trigger to start jogging
	            AND NOT #iqUDT_ConveyorCommand.ManualStartStop))       // Conveyor is not running in manual mode
	        THEN
	            
	            #iqUDT_EquipmentControl.Request.SignalingRequest := TRUE;  // Request signaling to control block before conveyor run in manual mode
	            
	        END_IF;
	        
	        // Run conveyor forward in manual mode
	        #iqUDT_ConveyorInterface.RunFwd := #sx_PreStartManual           // Pre start conditions to run in manual mode
	        AND NOT #iqUDT_ConveyorCommand.Reverse                          // Not in reverse direction
	        AND (NOT #iqUDT_EquipmentControl.Request.SignalingRequest       // Signaling request done
	        OR #sx_ManualRunning)
	        AND (#iqUDT_ConveyorCommand.ManualStartStop                         // Manual mode start to run
	        OR #iqUDT_ConveyorCommand.ManualJog);                           // Jogging
	        
	        // Run conveyor reverse in manual mode
	        #iqUDT_ConveyorInterface.RunRvs := #sx_PreStartManual           // Pre start conditions to run in manual mode
	        AND #iqUDT_ConveyorCommand.Reverse                              // Reverse direction
	        AND (NOT #iqUDT_EquipmentControl.Request.SignalingRequest       // Signaling request done
	        OR #sx_ManualRunning)
	        AND (#iqUDT_ConveyorCommand.ManualStartStop                         // Manual mode start to run
	        OR #iqUDT_ConveyorCommand.ManualJog);                           // Jogging
	        
	        #sx_ManualRunning := #iqUDT_ConveyorInterface.RunFwd
	        OR #iqUDT_ConveyorInterface.RunRvs;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 7 - Automatic mode active
	    
	    IF NOT #sx_ManualModeActive // Manual mode is not active
	    THEN
	        REGION 7.1 - Head to End
	            
	            (*  Function to calculate when the head of the parcel reaches the end of the conveyor
	                When PEC detects parcels head, the functionality increments the displacement of the conveyor until reach the value of the distance
	                between PEC and the end of the conveyor. After that, the counter is reset and the bit #sx_AuxHeadToEnd is triggered to inform the system. *)
	            IF NOT #sx_ReverseDirection
	            THEN
	                REGION 7.1.1 - Forward
	                    
	                    IF #sF_TRIG_PEC_EoSFiltered_Fwd.Q      // Detects the product's head
	                    THEN
	                        
	                        #sdi_HeadToEndFwd := #sdi_PECtoEndDistanceFwd;                // move the distance between PE and the end of the conveyor to auxiliary variable 
	                        #sx_AuxHeadToEndFwd := TRUE;                             // Active head to end function
	                        
	                        #sdi_GapHeadToHeadFwd := #sdi_AuxGapHeadToHeadCounterFwd;     // Move gap calculated to variable
	                        #sdi_AuxGapHeadToHeadCounterFwd := 0;                     // Reset gap counter
	                        
	                        #sdi_GapFwd := #sdi_AuxGapTailtoHeadCounterFwd;    // Move gap calculated to variable
	                        #sdi_AuxGapTailtoHeadCounterFwd := 0;                     // Reset gap counter
	                        
	                        #iqUDT_HandShake.RTS := TRUE;                         // Set ready to send true when a parcel is detected in the PEC
	                        
	                    END_IF;
	                    
	                    IF #sx_AuxHeadToEndFwd                 // Parcel's head detected in photo cell
	                        AND (#sdi_HeadToEndFwd > 0)         // Psrcel's head do not arrive in the end of the conveyor yet
	                    THEN
	                        
	                        #sdi_HeadToEndFwd -= #iqUDT_ConveyorInterface.Displacement;   // Count displacement until arrive to the end of the conveyor
	                        
	                    ELSE
	                        
	                        #sx_AuxHeadToEndFwd := FALSE;      // Stop function head to end
	                        
	                    END_IF;
	                    
	                    // Falling edge trigger Aux Head to End bit
	                    #sF_TRIG_AuxHeadToEnd_Fwd(CLK := #sx_AuxHeadToEndFwd);
	                    
	                    IF #sF_TRIG_AuxHeadToEnd_Fwd.Q
	                    THEN
	                        #sx_AuxHeadAtEndFwd := TRUE;                       // The head of the parcel is at the front positon of the conveyor
	                    END_IF;
	                    
	                    
	                    #sF_TRIG_HeadAtEnd_Fwd(CLK := #sx_AuxHeadAtEndFwd);
	                    
	                END_REGION
	            ELSE
	                REGION 7.1.2 - Reverse
	                    
	                    IF #sF_TRIG_PEC_EoSFiltered_Rvs.Q      // Detects the product's head
	                    THEN
	                        
	                        #sdi_HeadToEndRvs := #sdi_PECtoEndDistanceRvs;                // move the distance between PE and the end of the conveyor to auxiliary variable 
	                        #sx_AuxHeadToEndRvs := TRUE;                             // Active head to end function
	                        
	                        #sdi_GapHeadToHeadRvs := #sdi_AuxGapHeadToHeadCounterRvs;     // Move gap calculated to variable
	                        #sdi_AuxGapHeadToHeadCounterRvs := 0;                     // Reset gap counter
	                        
	                        #sdi_Gap_Rvs := #sdi_AuxGapTailtoHeadCounterRvs;    // Move gap calculated to variable
	                        #sdi_AuxGapTailtoHeadCounterRvs := 0;                     // Reset gap counter
	                        
	                        #iqUDT_HandShakeUp.RTS := TRUE;                         // Set ready to send true when a parcel is detected in the PEC
	                        
	                    END_IF;
	                    
	                    IF #sx_AuxHeadToEndRvs                 // Parcel's head detected in photo cell
	                        AND (#sdi_HeadToEndRvs > 0)         // Psrcel's head do not arrive in the end of the conveyor yet
	                    THEN
	                        
	                        #sdi_HeadToEndRvs += #iqUDT_ConveyorInterface.Displacement;   // Count displacement until arrive to the end of the conveyor
	                        
	                    ELSE
	                        
	                        #sx_AuxHeadToEndRvs := FALSE;      // Stop function head to end
	                        
	                    END_IF;
	                    
	                    // Falling edge trigger Aux Head to End bit
	                    #sF_TRIG_AuxHeadToEnd_Rvs(CLK := #sx_AuxHeadToEndRvs);
	                    
	                    IF #sF_TRIG_AuxHeadToEnd_Rvs.Q
	                    THEN
	                        #sx_AuxHeadAtEndRvs := TRUE;                       // The head of the parcel is at the front positon of the conveyor
	                    END_IF;
	                    
	                    
	                    #sF_TRIG_HeadAtEnd_Rvs(CLK := #sx_AuxHeadAtEndRvs);
	                    
	                END_REGION
	            END_IF;
	        END_REGION
	        
	        REGION 7.2 - Tail to Begin
	            
	            (*   This function tracks when parcels tail reaches the begin of downstream conveyor
	                 When the PEC is clear, the function start to increase the displacement until reaches the distance
	                 between PEC and the end of conveyor. *)
	            IF NOT #sx_ReverseDirection
	            THEN
	                REGION 7.2.1 - Forward
	                    
	                    IF #sR_TRIG_PE_EoSFiltered_Fwd.Q                     // Detects product's tail
	                    THEN
	                        
	                        #sdi_TailToBeginFwd := (#sdi_PECEoSDistanceFwd / 10);   // move distance between PE and the end of the conveyor to auxiliar variable
	                        
	                    END_IF;
	                    
	                    IF (#sdi_TailToBeginFwd > 0)                                           // While tails parcel do not reach the beginning of next conveyor
	                    THEN
	                        
	                        #sdi_TailToBeginFwd -= #iqUDT_ConveyorInterface.Displacement;   // count displacement until the product's tail arrive to the next conveyor
	                        #sx_TailToBeginFwd := FALSE;                                    // Reset tail to begin bit
	                        
	                    ELSE
	                        
	                        #sx_TailToBeginFwd := TRUE;                                     // Product's tail arrived at the begin OF next conveyor
	                        
	                    END_IF;
	                    
	                    // Rising edge trigger Aux tail to Begin bit
	                    #sR_TRIG_TailToBegin_Fwd(CLK := #sx_TailToBeginFwd);
	                    
	                END_REGION
	            ELSE
	                REGION 7.2.2 - Reverse
	                    
	                    IF #sR_TRIG_PE_EoSFiltered_Rvs.Q                     // Detects product's tail
	                    THEN
	                        
	                        #sdi_TailToBeginRvs := (#sdi_PEC_EoSDistanceRvs / 10);   // move distance between PE and the end of the conveyor to auxiliar variable
	                        
	                    END_IF;
	                    
	                    IF (#sdi_TailToBeginRvs > 0)                                           // While tails parcel do not reach the beginning of next conveyor
	                    THEN
	                        
	                        #sdi_TailToBeginRvs += #iqUDT_ConveyorInterface.Displacement;   // count displacement until the product's tail arrive to the next conveyor
	                        #sx_TailToBeginRvs := FALSE;                                    // Reset tail to begin bit
	                        
	                    ELSE
	                        
	                        #sx_TailToBeginRvs := TRUE;                                     // Product's tail arrived at the begin OF next conveyor
	                        
	                    END_IF;
	                    
	                    // Rising edge trigger Aux tail to Begin bit
	                    #sR_TRIG_TailToBegin_Rvs(CLK := #sx_TailToBeginRvs);
	                    
	                END_REGION
	            END_IF;
	        END_REGION
	        
	        REGION 7.3 - Gap
	            
	            (*    Gap tail TO head function calculates the distance (Gap) between two parcels.                                       
	                  The function increases the Counter WHILE the photo eye is clear.                                                    
	                  Everytime a parcel trigger the photo eye, gap value is save AND the counter is reset.  *)
	            IF NOT #sx_ReverseDirection
	            THEN
	                REGION 7.3.1 - Forward
	                    
	                    IF #ix_PECEoS       // Count displacement when the PE do not detects the product
	                    THEN
	                        
	                        IF #sdi_AuxGapTailtoHeadCounterFwd < #ci_OverflowLimit        // Prevent integer variable overflow
	                        THEN
	                            IF #iqUDT_HandShake.RTR THEN
	                                #sdi_AuxGapTailtoHeadCounterFwd += #iqUDT_ConveyorInterface.Displacement;    // Calculate the gap
	                            END_IF;
	                            
	                        END_IF;
	                        
	                    END_IF;
	                    
	                END_REGION
	            ELSE
	                REGION 7.3.2 - Reverse
	                    
	                    IF #ix_PECBoS       // Count displacement when the PE do not detects the product
	                    THEN
	                        
	                        IF #sdi_AuxGapTailtoHeadCounterRvs < #ci_OverflowLimit        // Prevent integer variable overflow
	                        THEN
	                            
	                            #sdi_AuxGapTailtoHeadCounterRvs -= #iqUDT_ConveyorInterface.Displacement;    // Calculate the gap
	                            
	                        END_IF;
	                    END_IF;
	                    
	                END_REGION
	            END_IF;
	        END_REGION
	        
	        REGION 7.4 - Head to head
	            
	            // The functionality head to head is used to calculate the distance between one head's parcel and the head's parcel behind.
	            // To do it, everytime the PEC is triggered, the function save the distance calculated and reset the counter to start
	            // counting again, over and over again.
	            IF NOT #sx_ReverseDirection
	            THEN
	                REGION 7.4.1 - Forward
	                    
	                    IF #sdi_AuxGapHeadToHeadCounterFwd < #ci_OverflowLimit        // Prevent integer variable overflow
	                    THEN
	                        
	                        #sdi_AuxGapHeadToHeadCounterFwd += #iqUDT_ConveyorInterface.Displacement;   // measure the distance between two products
	                        
	                    END_IF;
	                    
	                END_REGION
	            ELSE
	                REGION 7.4.2 - Reverse
	                    
	                    IF #sdi_AuxGapHeadToHeadCounterRvs < #ci_OverflowLimit        // Prevent integer variable overflow
	                    THEN
	                        
	                        #sdi_AuxGapHeadToHeadCounterRvs -= #iqUDT_ConveyorInterface.Displacement;   // measure the distance between two products
	                        
	                    END_IF;
	                    
	                END_REGION
	            END_IF;
	        END_REGION
	        
	        REGION 7.5 - Check gaps between products
	            
	            // Check gaps is a routine that checks all the time if the gap and head to head distance is acording to the configuration.
	            // If not, the bit "sx_Gapping" is set true and the conveyor stops to gap.
	            // Compare gaps calculated with the configured gaps 
	            IF NOT #sx_ReverseDirection
	            THEN
	                REGION 7.5.1 - Forward
	                    
	                    IF ((#sdi_GapHeadToHeadConfigurationFwd > #sdi_GapHeadToHeadFwd               // Compare head to head configured with real distance
	                        OR #sdi_GapTailToHeadConfigurationFwd > #sdi_GapFwd
	                        OR #sdi_GapTailToHeadConfigurationFwd > #sdi_DownstreamGapTailtoHeadFwd           // Compare gap configured with real gap
	                        OR #sdi_GapHeadToHeadConfigurationFwd > #sdi_DownstreamGapHeadToHeadFwd)
	                        AND #sF_TRIG_AuxHeadToEnd_Fwd.Q)                                                         // Trigger when parcel arrive in the end of the conveyor
	                    THEN
	                        
	                        #sx_GappingFwd := TRUE;        // Bit to inform the system that conveyor needs to stop to apply gap
	                        
	                    END_IF;
	                    
	                END_REGION
	            ELSE
	                REGION 7.5.1 - Reverse
	                    
	                    IF ((#sdi_GapHeadToHeadConfigurationRvs > #sdi_GapHeadToHeadRvs               // Compare head to head configured with real distance
	                        OR #sdi_GapTailToHeadConfigurationRvs > #sdi_Gap_Rvs
	                        OR #sdi_GapTailToHeadConfigurationRvs > #sdi_DownstreamGapTailtoHeadRvs           // Compare gap configured with real gap
	                        OR #sdi_GapHeadToHeadConfigurationRvs > #sdi_DownstreamGapHeadToHeadRvs)
	                        AND #sF_TRIG_AuxHeadToEnd_Rvs.Q)                                                         // Trigger when parcel arrive in the end of the conveyor
	                    THEN
	                        
	                        #sx_GappingRvs := TRUE;        // Bit to inform the system that conveyor needs to stop to apply gap
	                        
	                    END_IF;
	                    
	                END_REGION
	            END_IF;
	            //    When conveyor stops to gapping, displacement values from downstream are used to 
	            //    apply new gap.
	            //    When the new gap applied fits with the configured one, the conveyor starts running again.
	            //    If the conveyor stops for die back reason and the gap its been applied, and extra gap value it will be applied.
	            //    This recovery gap it helps to recovery the system after die back.
	            IF NOT #sx_ReverseDirection
	            THEN
	                REGION 7.5.3 - Forward
	                    
	                    IF (#sx_GappingFwd          // Gapping needs to be applied bit
	                        AND ((#sdi_GapHeadToHeadConfigurationFwd > #sdi_GapHeadToHeadFwd    // Configured head to head bigger than the actual one
	                        OR #sdi_GapHeadToHeadConfigurationFwd - #idi_PECEoSDistance / 10 + #sdi_PECtoEndDistanceFwd > #sdi_DownstreamGapHeadToHeadFwd
	                        OR #sdi_GapTailToHeadConfigurationFwd > #sdi_GapFwd     // Configured gap bigger than the actual one
	                        OR #sdi_GapTailToHeadConfigurationFwd - #idi_PECEoSDistance / 10 + #sdi_PECtoEndDistanceFwd > #sdi_DownstreamGapTailtoHeadFwd)
	                        AND NOT #sx_RecoveryGapFwd)                                                // Die back recovery gap bit not active
	                        OR (((#sdi_GapHeadToHeadConfigurationFwd + #iUDT_ConveyorConfiguration.ExtraGapRecovery)   // Add recovery gap to the configured
	                        > #sdi_GapHeadToHeadFwd                                                                                 // Actual head to head distance
	                        OR (#sdi_GapHeadToHeadConfigurationFwd - #idi_PECEoSDistance / 10 + #sdi_PECtoEndDistanceFwd + #iUDT_ConveyorConfiguration.ExtraGapRecovery)
	                        > #sdi_DownstreamGapHeadToHeadFwd
	                        OR (#sdi_GapTailToHeadConfigurationFwd + #iUDT_ConveyorConfiguration.ExtraGapRecovery)    // Add recovery gap to the configured
	                        > #sdi_GapFwd                                                                               // Actual gap between parcels
	                        OR (#sdi_GapTailToHeadConfigurationFwd - #idi_PECEoSDistance / 10 + #sdi_PECtoEndDistanceFwd + #iUDT_ConveyorConfiguration.ExtraGapRecovery)
	                        > #sdi_DownstreamGapTailtoHeadFwd)
	                        AND #sx_RecoveryGapFwd))                                                                       // Recovery gap bit activate
	                    THEN
	                        
	                        #sdi_GapHeadToHeadFwd += #iqUDT_HandShake.DownstreamDisplacement;      // Increase head to head counter with conveyor downstream displacement
	                        #sdi_GapFwd += #iqUDT_HandShake.DownstreamDisplacement;     // Increase gap counter with conveyor downstream displacement
	                        
	                    ELSE
	                        
	                        #sx_GappingFwd := FALSE;                   // Set gapping bit to false
	                        
	                    END_IF;
	                    
	                    IF #sx_GappingFwd                              // Gapping bit active
	                        AND NOT #iqUDT_HandShake.RTR           // Ready to receive not active
	                    THEN
	                        
	                        #sx_RecoveryGapFwd := TRUE;                // Recovery gap activation after die back
	                        
	                    END_IF;
	                    
	                    IF #sx_RecoveryGapFwd                          // Recovery gap active
	                        AND NOT #sx_GappingFwd                     // Gapping bit not active
	                    THEN
	                        
	                        #sx_RecoveryGapFwd := FALSE;               // Recovery gap disable
	                        
	                    END_IF;
	                    
	                END_REGION
	            ELSE
	                REGION 7.5.4 - Reverse
	                    
	                    IF (#sx_GappingRvs          // Gapping needs to be applied bit
	                        AND ((#sdi_GapHeadToHeadConfigurationRvs > #sdi_GapHeadToHeadRvs    // Configured head to head bigger than the actual one
	                        OR #sdi_GapHeadToHeadConfigurationRvs - #idi_PECBoSDistance / 10 + #sdi_PECtoEndDistanceRvs > #sdi_DownstreamGapHeadToHeadRvs
	                        OR #sdi_GapTailToHeadConfigurationRvs > #sdi_Gap_Rvs     // Configured gap bigger than the actual one
	                        OR #sdi_GapTailToHeadConfigurationRvs - #idi_PECBoSDistance / 10 + #sdi_PECtoEndDistanceRvs > #sdi_DownstreamGapTailtoHeadRvs)
	                        AND NOT #sx_RecoveryGapRvs)                                                // Die back recovery gap bit not active
	                        OR (((#sdi_GapHeadToHeadConfigurationRvs + #iUDT_ConveyorConfiguration.ExtraGapRecovery)   // Add recovery gap to the configured
	                        > #sdi_GapHeadToHeadRvs                                                                                 // Actual head to head distance
	                        OR (#sdi_GapHeadToHeadConfigurationRvs - #idi_PECBoSDistance / 10 + #sdi_PECtoEndDistanceRvs + #iUDT_ConveyorConfiguration.ExtraGapRecovery)
	                        > #sdi_DownstreamGapHeadToHeadRvs
	                        OR (#sdi_GapTailToHeadConfigurationRvs + #iUDT_ConveyorConfiguration.ExtraGapRecovery)    // Add recovery gap to the configured
	                        > #sdi_Gap_Rvs                                                                               // Actual gap between parcels
	                        OR (#sdi_GapTailToHeadConfigurationRvs - #idi_PECBoSDistance / 10 + #sdi_PECtoEndDistanceRvs + #iUDT_ConveyorConfiguration.ExtraGapRecovery)
	                        > #sdi_DownstreamGapTailtoHeadRvs)
	                        AND #sx_RecoveryGapRvs))                                                                                // Recovery gap bit activate
	                    THEN
	                        
	                        #sdi_GapHeadToHeadRvs -= #iqUDT_HandShakeUp.DownstreamDisplacement;      // Increase head to head counter with conveyor downstream displacement
	                        #sdi_Gap_Rvs -= #iqUDT_HandShakeUp.DownstreamDisplacement;     // Increase gap counter with conveyor downstream displacement
	                        
	                    ELSE
	                        
	                        #sx_GappingRvs := FALSE;                   // Set gapping bit to false
	                        
	                    END_IF;
	                    
	                    IF #sx_GappingRvs                              // Gapping bit active
	                        AND NOT #iqUDT_HandShakeUp.RTR           // Ready to receive not active
	                    THEN
	                        
	                        #sx_RecoveryGapRvs := TRUE;                // Recovery gap activation after die back
	                        
	                    END_IF;
	                    
	                    IF #sx_RecoveryGapRvs                          // Recovery gap active
	                        AND NOT #sx_GappingRvs                     // Gapping bit not active
	                    THEN
	                        
	                        #sx_RecoveryGapRvs := FALSE;               // Recovery gap disable
	                        
	                    END_IF;
	                    
	                END_REGION
	            END_IF;
	        END_REGION
	        
	        REGION 7.6 - Ready to send and Transfer in progress
	            IF NOT #sx_ReverseDirection
	            THEN
	                REGION 7.6.1 - Forward
	                    
	                    IF #iqUDT_HandShake.RTR                                            // Ready to receive bit
	                        AND NOT #sx_GappingFwd
	                        AND #sx_AuxHeadAtEndFwd                                            // Parcel is at end of conveyor
	                        AND NOT #ix_ExternalRequestDieBack
	                    THEN
	                        
	                        #iqUDT_HandShake.TIP := TRUE;      // Transfer in progress bit
	                        #iqUDT_HandShake.RTS := FALSE;     // Ready to send bit
	                        #sx_AuxHeadAtEndFwd := FALSE;
	                        
	                    END_IF;
	                    
	                    IF #sR_TRIG_TailToBegin_Fwd.Q               // Reset TIP when the parcel leaves interlock
	                    THEN
	                        
	                        #iqUDT_HandShake.TIP := FALSE;     // Transfer in progress bit
	                        
	                    END_IF;
	                    
	                END_REGION
	            ELSE
	                REGION 7.6.2 - Reverse
	                    
	                    IF #iqUDT_HandShakeUp.RTR                                            // Ready to receive bit
	                        AND #iqUDT_HandShake.RTR
	                        AND NOT #sx_GappingRvs
	                        AND #sx_AuxHeadAtEndRvs                                            // Parcel is at end of conveyor
	                        AND NOT #ix_ExternalRequestDieBack
	                    THEN
	                        
	                        #iqUDT_HandShakeUp.TIP := TRUE;      // Transfer in progress bit
	                        #iqUDT_HandShakeUp.RTS := FALSE;     // Ready to send bit
	                        #sx_AuxHeadAtEndRvs := FALSE;
	                        
	                    END_IF;
	                    
	                    IF #sR_TRIG_TailToBegin_Rvs.Q               // Reset TIP when the parcel leaves interlock
	                    THEN
	                        
	                        #iqUDT_HandShakeUp.TIP := FALSE;     // Transfer in progress bit
	                        
	                    END_IF;
	                    
	                END_REGION
	            END_IF;
	        END_REGION
	        
	        REGION 7.7 - Downstream gap
	            
	            (* This functionality is used to maintain the gap between parcel conveyor's downstream.
	               To do this, is used the downstream displacement.  *)
	            IF NOT #sx_ReverseDirection
	            THEN
	                REGION 7.7.1 - Forward
	                    
	                    IF #sR_TRIG_TailToBegin_Fwd.Q                       // When the parcel's tail reach the beginning of downstream conveyor
	                    THEN
	                        
	                        #sdi_DownstreamGapTailtoHeadFwd := 0;                     // Reset downstream gap counter
	                        
	                    END_IF;
	                    
	                    IF #sdi_DownstreamGapTailtoHeadFwd < #ci_OverflowLimit        // Prevent integer variable overflow
	                    THEN
	                        
	                        #sdi_DownstreamGapTailtoHeadFwd += #iqUDT_HandShake.DownstreamDisplacement;          // Downstream displacement gap counter
	                        
	                    END_IF;
	                    
	                END_REGION
	            ELSE
	                REGION 7.7.2 - Reverse
	                    
	                    IF #sR_TRIG_TailToBegin_Rvs.Q                       // When the parcel's tail reach the beginning of downstream conveyor
	                    THEN
	                        
	                        #sdi_DownstreamGapTailtoHeadRvs := 0;                     // Reset downstream gap counter
	                        
	                    END_IF;
	                    
	                    IF #sdi_DownstreamGapTailtoHeadRvs < #ci_OverflowLimit        // Prevent integer variable overflow
	                    THEN
	                        
	                        #sdi_DownstreamGapTailtoHeadRvs -= #iqUDT_HandShakeUp.DownstreamDisplacement;          // Downstream displacement gap counter
	                        
	                    END_IF;
	                    
	                END_REGION
	            END_IF;
	        END_REGION
	        
	        REGION 7.8 - Downstream Head to Head
	            IF NOT #sx_ReverseDirection
	            THEN
	                REGION 7.8.1 - Forward
	                    
	                    #sR_TRIG_Transfering_Fwd(CLK := #iqUDT_HandShake.TIP);
	                    
	                    IF #sR_TRIG_Transfering_Fwd.Q                                                           // Transfering aux bit rising trigger
	                    THEN
	                        
	                        #sdi_DownstreamGapHeadToHeadFwd := 0;                                              // Downstream head to head reset counter
	                        
	                    END_IF;
	                    
	                    IF #sdi_DownstreamGapHeadToHeadFwd < #ci_OverflowLimit                                 // Prevent integer variable overflow
	                    THEN
	                        
	                        #sdi_DownstreamGapHeadToHeadFwd += #iqUDT_HandShake.DownstreamDisplacement;       // Downstream displacement head to head counter 
	                        
	                    END_IF;
	                    
	                END_REGION
	            ELSE
	                REGION 7.8.2 - Reverse
	                    
	                    #sR_TRIG_Transfering_Rvs(CLK := #iqUDT_HandShake.TIP);
	                    
	                    IF #sR_TRIG_Transfering_Rvs.Q                                                           // Transfering aux bit rising trigger
	                    THEN
	                        
	                        #sdi_DownstreamGapHeadToHeadRvs := 0;                                              // Downstream head to head reset counter
	                        
	                    END_IF;
	                    
	                    IF #sdi_DownstreamGapHeadToHeadRvs < #ci_OverflowLimit                                 // Prevent integer variable overflow
	                    THEN
	                        
	                        #sdi_DownstreamGapHeadToHeadRvs -= #iqUDT_HandShakeUp.DownstreamDisplacement;       // Downstream displacement head to head counter 
	                        
	                    END_IF;
	                    
	                END_REGION
	            END_IF;
	        END_REGION
	        
	        REGION 7.9 - Energy save
	            
	            (* Save energy functionality is used to stop conveyor if no parcels are in the system to save energy
	               Save energy function counts displacement if the photo eye do not detects parcels. The counter is reset if:
	               - Photo eye is triggered.
	               - Reset is required from external.
	               - Ready to send is active from upstream. *)
	            
	            IF #iUDT_ConveyorConfiguration.Energy                                       // Energy save functionality enable from configuration
	            THEN
	                
	                IF #sdi_AuxEnergySaveFwd >= #iUDT_ConveyorConfiguration.Forward_Direction.EnergySaveLenght        // Compare energy save counter with configured lenght
	                    OR #sdi_AuxEnergySaveRvs >= #iUDT_ConveyorConfiguration.Reverse_Direction.EnergySaveLenght
	                THEN
	                    #sx_EnergySaveActive := TRUE;                                           // Set energy save active true
	                END_IF;
	                
	                IF ((NOT #ix_PECEoS OR NOT #ix_PECBoS)                                  // Photo eye detects a parcel
	                    AND NOT #sx_EnergySaveActive)                                         // Energy save active bit
	                    OR #ix_ResetEnergySave                                               // Reset energy save
	                    OR (#iqUDT_HandShakeUp.ResetEnergySave AND NOT #sx_ReverseDirection)                               // Reset energy save externaly 
	                    OR (#iqUDT_HandShake.ResetEnergySave AND #sx_ReverseDirection)
	                    OR NOT #iqUDT_EquipmentControl.Command.AutomaticOn                  // Automatic ON from control block
	                    OR #iqUDT_EquipmentControl.Command.Stop                             // Stop command from control block
	                THEN
	                    #sdi_AuxEnergySaveFwd := 0;                                        // Reset energy save counter
	                    #sdi_AuxEnergySaveRvs := 0;                                        // Reset energy save counter
	                    #sx_EnergySaveActive := FALSE;                                      // Set energy save active to false
	                ELSE
	                    // Increament displacement counter
	                    IF NOT #sx_ReverseDirection
	                    THEN
	                        #sdi_AuxEnergySaveFwd += #iqUDT_ConveyorInterface.Displacement;
	                    ELSE
	                        #sdi_AuxEnergySaveRvs -= #iqUDT_ConveyorInterface.Displacement;
	                    END_IF;
	                END_IF;
	                
	            ELSE
	                // If energy save functionality is disable from configuration
	                #sdi_AuxEnergySaveFwd := 0;                                             // Reset energy save counter
	                #sx_EnergySaveActive := FALSE;                                      // Set energy save false
	            END_IF;
	            // Reset to downstream when not already in enery save on signal of PEC
	            // When slave conveyor pass reset esave command to master conveyor
	            
	            IF NOT #sx_ReverseDirection
	            THEN
	                #iqUDT_HandShake.ResetEnergySave := (NOT #ix_PECEoS OR #sx_AuxHeadAtEndFwd OR #iqUDT_HandShake.TIP) AND NOT #sx_EnergySaveActive
	                OR (#iUDT_ConveyorConfiguration.Forward_Direction.Mode = 1 AND #iqUDT_HandShakeUp.ResetEnergySave);
	            ELSE
	                #iqUDT_HandShakeUp.ResetEnergySave := NOT #ix_PECBoS AND NOT #sx_EnergySaveActive
	                OR (#iUDT_ConveyorConfiguration.Reverse_Direction.Mode = 1 AND #iqUDT_HandShake.ResetEnergySave);
	            END_IF;
	        END_REGION
	        
	        REGION 7.10 - Operation modes
	            
	            // Different modes in automatic can be configured
	            // 1 - Slave
	            // 2 - Queue
	            // 3 - Bulk flow
	            
	            IF #sx_AutomaticActive                                          // Automatic mode active
	                AND #tx_CascadeStart                                        // Cascade startup
	            THEN
	                
	                IF NOT #sx_ReverseDirection
	                THEN
	                    
	                    CASE #iUDT_ConveyorConfiguration.Forward_Direction.Mode OF                   // Operation mode configured 
	                            
	                        1:  // Slave
	                            
	                            // Run conveyor if ready to receive if on, and conveyor is not gapping,
	                            // and not halt request and not energy save active
	                            
	                            #iqUDT_ConveyorInterface.RunFwd := #sx_AutomaticActive     // Automatic mode active
	                            AND #sx_Ready                                               // Ready active
	                            AND NOT #ix_ExternalRequestHold                             // Halt request is not active
	                            AND NOT #sx_EnergySaveActive                                // Energy save not active
	                            AND #iqUDT_HandShake.RTR                               // Ready to receive active
	                            AND NOT #sx_DirectionChanged;
	                            
	                            #iqUDT_HandShakeUp.RTR := #iqUDT_ConveyorInterface.RunFwd;
	                            
	                        2:  // Master 
	                            
	                            // With queue configuration, conveyor runs if ready to receive is true.
	                            // If ready to receive is false, conveyor runs until parcel reach the end of the conveyor.
	                            
	                            // Conveyor stops if heads parcel reache the end of the conveyor and:
	                            // - Ready to receive is false
	                            // - Or die back requested.
	                            // - Or halt requested
	                            // Conveyor also stops if gapping is active or energy save mode active.
	                            
	                            #iqUDT_ConveyorInterface.RunFwd := #sx_AutomaticActive             // Automatic mode active
	                            AND #sx_Ready                                                       // Ready active
	                            AND NOT #sx_DirectionChanged
	                            AND NOT #sx_GappingFwd                                                 // Gapping request
	                            AND NOT #sx_EnergySaveActive                                        // Energy save request
	                            AND NOT #ix_ExternalRequestHold                                     // Halt requested from external
	                            AND ((NOT #ix_ExternalRequestDieBack
	                            AND #iqUDT_HandShake.RTR)
	                            OR (NOT #sx_AuxHeadAtEndFwd
	                            AND NOT #iqUDT_HandShake.TIP)
	                            OR (#iqUDT_HandShake.RTR
	                            AND NOT #sx_AuxHeadAtEndFwd));
	                            
	                            #iqUDT_HandShakeUp.RTR := #iqUDT_ConveyorInterface.RunFwd;
	                            
	                            
	                        3: //Master at bulk flow
	                            
	                            #iqUDT_ConveyorInterface.RunFwd := #sx_AutomaticActive             // Automatic mode active
	                            AND #sx_Ready                                                       // Ready active
	                            AND NOT #sx_DirectionChanged
	                            AND NOT #sx_EnergySaveActive                                        // Energy save request
	                            AND NOT #ix_ExternalRequestHold                                     // Halt requested from external
	                            AND (
	                            (NOT #ix_ExternalRequestDieBack                                     //no die back request and the downstream is running
	                            AND #iqUDT_HandShake.RTR)
	                            OR                                                                  //..or..
	                            (#sdi_TransitionZone = 0)                                            // no parcels at the transition zone
	                            OR                                                                  //..or..
	                            (#iqUDT_HandShake.RTR
	                            AND NOT #ix_ExternalRequestDieBack
	                            AND NOT (#sdi_TransitionZone = 0)));                                  //downstream is running and there are   
	                            
	                            //If PEC is blocked, reset tracking counter
	                            IF NOT #ix_PECEoS THEN
	                                #sdi_TransitionZone := (#idi_PECEoSDistance / 10);
	                            END_IF;
	                            
	                            //Track parcels at the zone between EoS and conveyor end (Transition Zone)
	                            #sdi_TransitionZone := #sdi_TransitionZone - #iqUDT_ConveyorInterface.Displacement;
	                            
	                            //If Value is negative then set to 0
	                            IF #sdi_TransitionZone < 0 THEN
	                                #sdi_TransitionZone := 0;
	                            END_IF;
	                            
	                            #iqUDT_HandShakeUp.RTR := #iqUDT_ConveyorInterface.RunFwd;
	                            
	                    END_CASE;
	                    
	                ELSE
	                    
	                    CASE #iUDT_ConveyorConfiguration.Reverse_Direction.Mode OF                   // Operation mode configured 
	                            
	                        1:  // Slave
	                            
	                            // Run conveyor if ready to receive if on, and conveyor is not gapping,
	                            // and not halt request and not energy save active
	                            
	                            #iqUDT_ConveyorInterface.RunRvs := #sx_AutomaticActive     // Automatic mode active
	                            AND #sx_Ready                                               // Ready active
	                            AND NOT #ix_ExternalRequestHold                             // Halt request is not active
	                            AND NOT #sx_EnergySaveActive                                // Energy save not active
	                            AND #iqUDT_HandShakeUp.RTR                                 // Ready to receive active
	                            AND NOT #sx_DirectionChanged;
	                            
	                            #iqUDT_HandShake.RTR := #iqUDT_ConveyorInterface.RunRvs;
	                            
	                        2:  // Master 
	                            
	                            // With queue configuration, conveyor runs if ready to receive is true.
	                            // If ready to receive is false, conveyor runs until parcel reach the end of the conveyor.
	                            
	                            // Conveyor stops if heads parcel reache the end of the conveyor and:
	                            // - Ready to receive is false
	                            // - Or die back requested.
	                            // - Or halt requested
	                            // Conveyor also stops if gapping is active or energy save mode active.
	                            
	                            #iqUDT_ConveyorInterface.RunRvs := #sx_AutomaticActive             // Automatic mode active
	                            AND #sx_Ready                                                       // Ready active
	                            AND NOT #sx_DirectionChanged
	                            AND NOT #sx_GappingRvs                                             // Gapping request
	                            AND NOT #sx_EnergySaveActive                                        // Energy save request
	                            AND NOT #ix_ExternalRequestHold                                     // Halt requested from external
	                            AND ((NOT #ix_ExternalRequestDieBack
	                            AND #iqUDT_HandShakeUp.RTR)
	                            OR (NOT #sx_AuxHeadAtEndRvs
	                            AND NOT #iqUDT_HandShakeUp.TIP)
	                            OR (#iqUDT_HandShakeUp.RTR
	                            AND NOT #sx_AuxHeadAtEndRvs));
	                            
	                            #iqUDT_HandShake.RTR := #iqUDT_ConveyorInterface.RunRvs;
	                            
	                            
	                        3: //Master at bulk flow
	                            
	                            #iqUDT_ConveyorInterface.RunRvs := #sx_AutomaticActive             // Automatic mode active
	                            AND #sx_Ready                                                       // Ready active
	                            AND NOT #sx_DirectionChanged
	                            AND NOT #sx_EnergySaveActive                                        // Energy save request
	                            AND NOT #ix_ExternalRequestHold                                     // Halt requested from external
	                            AND (
	                            (NOT #ix_ExternalRequestDieBack                                     //no die back request and the downstream is running
	                            AND #iqUDT_HandShakeUp.RTR)
	                            OR                                                                  //..or..
	                            (#sdi_TransitionZone = 0)                                            // no parcels at the transition zone
	                            OR                                                                  //..or..
	                            (#iqUDT_HandShakeUp.RTR
	                            AND NOT #ix_ExternalRequestDieBack
	                            AND NOT (#sdi_TransitionZone = 0)));                                  //downstream is running and there are   
	                            
	                            //If PEC is blocked, reset tracking counter
	                            IF NOT #ix_PECBoS THEN
	                                #sdi_TransitionZone := #idi_PECEoSDistance / 10;
	                            END_IF;
	                            //Track parcels at the zone between EoS and conveyor end (Transition Zone)
	                            #sdi_TransitionZone := #sdi_TransitionZone - #iqUDT_ConveyorInterface.Displacement;
	                            
	                            //If Value is negative then set to 0
	                            IF #sdi_TransitionZone < 0 THEN
	                                #sdi_TransitionZone := 0;
	                            END_IF;
	                            
	                            #iqUDT_HandShake.RTR := #iqUDT_ConveyorInterface.RunRvs;
	                    END_CASE;
	                    
	                END_IF;
	                
	            ELSE
	                
	                // If conveyor is not in manual mode and not ready
	                IF NOT #sx_ReverseDirection
	                THEN
	                    #iqUDT_ConveyorInterface.RunFwd := FALSE;                      // Order to VFD stop conveyor
	                    #iqUDT_HandShakeUp.RTR := FALSE;                               // Set ready to receive false
	                ELSE
	                    #iqUDT_ConveyorInterface.RunRvs := FALSE;                      // Order to VFD stop conveyor
	                    #iqUDT_HandShake.RTR := FALSE;                               // Set ready to receive false
	                END_IF;
	                
	            END_IF;
	            
	        END_REGION
	        
	    END_IF;
	END_REGION
	
	REGION 8 - Speed control
	    
	    (*In manual mode, conveyor default runs with manual speed which is calculated as a percentage of nominal speed. If "ManualFullSpeed" is set true, conveyor runs with high speed in manual mode. 
	     In jog mode conveyor always runs in low speed. In automatic mode, conveyor runs with full speed if external is zero. If external speed is bigger than zero, conveyor will run with that speed. *)
	    
	    
	    // security
	    IF #iqUDT_ConveyorCommand.ManualSpeed > 100 THEN
	        #iqUDT_ConveyorCommand.ManualSpeed := 100;
	    END_IF;
	    
	    IF #iqUDT_ConveyorCommand.ManualSpeed < 0 THEN
	        #iqUDT_ConveyorCommand.ManualSpeed := 0;
	    END_IF;
	    
	    
	    
	    IF #sx_ManualModeActive                                                                         // Manual mode active
	    THEN
	        
	        IF #iqUDT_ConveyorCommand.ManualStartStop                                              // Full speed in manual mode
	        THEN
	            
	            IF #iqUDT_ConveyorCommand.ManualFullSpeed                                                  // Full speed in manual mode
	            THEN
	                #iqUDT_ConveyorInterface.SpeedSetpoint := #iUDT_ConveyorConfiguration.SpeedSetpointNominal;    // Move nominal setpoint to the VDF
	                
	            ELSE
	                #iqUDT_ConveyorInterface.SpeedSetpoint := REAL_TO_INT(INT_TO_REAL(#iqUDT_ConveyorCommand.ManualSpeed) * (INT_TO_REAL(#iUDT_ConveyorConfiguration.SpeedSetpointNominal) / 100));     // Calculate and Move manual speed setpoint to VFD
	                
	            END_IF;
	            
	        ELSE                                                                                             //low speed for jog mode
	            
	            IF #iUDT_ConveyorConfiguration.SpeedSetpointLow < #iUDT_ConveyorConfiguration.SpeedSetpointNominal  //Low speed can't be higher than nominal speed 
	            THEN
	                #iqUDT_ConveyorInterface.SpeedSetpoint := #iUDT_ConveyorConfiguration.SpeedSetpointLow;    // Move low speed setpoint to the VDF
	                
	            ELSE
	                
	                #iqUDT_ConveyorInterface.SpeedSetpoint := #iUDT_ConveyorConfiguration.SpeedSetpointNominal;    // Move low speed setpoint to the VDF
	            END_IF;
	        END_IF;
	        
	        
	        
	    ELSE
	        
	        IF #ii_ExternalSpeed > 0                                                                      // If external speed bigger than zero
	        THEN
	            #iqUDT_ConveyorInterface.SpeedSetpoint := #ii_ExternalSpeed;                                     // Move external speed to VFD
	        ELSE
	            #iqUDT_ConveyorInterface.SpeedSetpoint := #iUDT_ConveyorConfiguration.SpeedSetpointNominal;       // Move nominal setpoint to VFD
	        END_IF;
	        
	    END_IF;
	    
	    
	    
	END_REGION
	
	
	REGION 9 - Status
	    #sUDT_HMIStatus.Specific.Reverse := #sx_ReverseDirection;
	    
	    // stopped 
	    #sUDT_CommonStatus.Stopped := NOT #sx_Ready OR NOT #sx_AutomaticActive;
	    
	    // Auto ON
	    #sUDT_CommonStatus.AutoON := #sx_Ready AND #sx_AutomaticActive;
	    
	    // Running
	    #sUDT_CommonStatus.Running := #iqUDT_ConveyorInterface.RunFwd
	    OR #iqUDT_ConveyorInterface.RunRvs;
	    
	    // Halted
	    #sUDT_CommonStatus.Halted := #ix_ExternalRequestHold
	    AND #sUDT_CommonStatus.AutoON
	    AND NOT #sUDT_CommonStatus.EnergySave;
	    
	    // Energy save active
	    #sUDT_CommonStatus.EnergySave := #sx_EnergySaveActive AND #sx_AutomaticActive;
	    
	    // Die back
	    #sUDT_CommonStatus.Dieback := #sUDT_CommonStatus.AutoON
	    AND NOT #sUDT_CommonStatus.EnergySave
	    AND NOT #sUDT_CommonStatus.Running;
	    
	    // Manual
	    #sUDT_CommonStatus.Manual := #sx_ManualModeActive;
	    
	    // Manual Running
	    #sUDT_CommonStatus.ManualRun := #sx_ManualModeActive AND #sUDT_CommonStatus.Running;
	    
	    // Safety not ok
	    #sUDT_CommonStatus.SafetyStop := NOT #ix_SafetyOk AND #ix_HardwareOk;
	    
	    // HMI status update
	    IF #sUDT_CommonStatusOld <> #sUDT_CommonStatus                                            // update on change
	        OR (#sR_TRIG_Reverse.Q OR #sF_TRIG_Reverse.Q)
	    THEN
	        // HMI status initialization
	        #sUDT_HMIStatus.Status := 0;
	        
	        // Energy save
	        IF #sUDT_CommonStatus.EnergySave
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".EnergySave;
	        END_IF;
	        
	        // Running
	        IF #sUDT_CommonStatus.Running
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Running;
	        END_IF;
	        
	        // Stopped
	        IF #sUDT_CommonStatus.Stopped
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Stopped;
	        END_IF;
	        
	        // Dieback
	        IF #sUDT_CommonStatus.Dieback
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Dieback;
	        END_IF;
	        
	        // Halted
	        IF #sUDT_CommonStatus.Halted
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Halted;
	        END_IF;
	        
	        // Manual
	        IF #sUDT_CommonStatus.Manual
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Manual;
	        END_IF;
	        
	        // Running in manual mode
	        IF #sUDT_CommonStatus.ManualRun
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".ManualRun;
	        END_IF;
	        
	(*        // Internal tracking warning
	        IF #iq_UDT_ConveyorInterface.InternalWarningTracking
	        THEN
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Warning;
	        END_IF; *)
	        
	        // Internal tracking error
	        IF #iqUDT_ConveyorInterface.InternalErrorTracking
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".TrackingError;
	        END_IF;
	        
	        // Internal PEC error
	        IF #iqUDT_ConveyorInterface.InternalErrorPEC
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".PECJam;
	        END_IF;
	        
	        // Internal Encoder error
	        IF #iqUDT_ConveyorInterface.InternalErrorEncoder
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".EncoderError;
	        END_IF;
	        
	        // Internal VFD error
	        IF #iqUDT_ConveyorInterface.InternalErrorVFD
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".VFDError;
	        END_IF;
	        
	        // Disconnect error
	        IF #iqUDT_ConveyorInterface.Disconnected
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".CBError;
	        END_IF;
	        
	        // Safety stop
	        IF (#sUDT_CommonStatus.SafetyStop)
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".SafetyStop;
	        END_IF;
	        
	        #sUDT_CommonStatusOld := #sUDT_CommonStatus;              // Copy status to memory
	        #qUDT_Status := #sUDT_CommonStatus;                       // Copy status to output
	        
	    END_IF;
	    
	    // Copy HMI status to output
	    #qUDT_HMIStatus := #sUDT_HMIStatus;
	    
	END_REGION
	
	
	REGION 10 - Statistics
	    
	    REGION 10.1 - Conveyor up time
	        
	        IF #sx_Up OR #iqUDT_EquipmentControl.Command.ResetData    // Reset statistics
	        THEN
	            
	            "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,      // Reset statistics input
	                            ix_Activate := #sx_Up,
	                            ix_RTrigActivate := #sR_TRIG_ConveyorUp.Q,                     // Statistics active trigger
	                            iqUDT_Statistics := #iqUDT_Statistics.ConveyorUp);      // Statistics values output
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 10.2 - Energy save
	        
	        // Statistics Energy save mode active
	        IF #sUDT_CommonStatus.EnergySave(* #sx_EnergySaveActive *)                                                        // Energy save active
	            OR #iqUDT_EquipmentControl.Command.ResetData                               // Reset statistics
	        THEN
	            "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,      // Reset statistics input
	                            ix_Activate := #sUDT_CommonStatus.EnergySave,                         // Activate statistics functions input
	                            ix_RTrigActivate := #sR_TRIG_EnergySave.Q,                    // Statistics active trigger
	                            iqUDT_Statistics := #iqUDT_Statistics.EnergySave);         // Statistics values output
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 10.3 - Conveyor down time
	        
	        // Conveyor down is when conveyor is not in manual mode and has an error
	        IF #sx_Down OR #iqUDT_EquipmentControl.Command.ResetData OR #sUDT_CommonStatus.SafetyStop                                    // Reset statistics
	        THEN
	            
	            "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,             // Reset statistics input
	                            ix_Activate := #sx_Down OR #sUDT_CommonStatus.SafetyStop, // Activate statistics functions input
	                            ix_RTrigActivate := #sR_TRIG_ConveyorDownTime.Q,                     // Statistics active trigger
	                            iqUDT_Statistics := #iqUDT_Statistics.ConveyorDown);              // Statistics values output
	            
	        END_IF;
	    END_REGION
	    
	    REGION 10.4 - Conveyor stop time
	        
	        IF #sx_Stopped OR #iqUDT_EquipmentControl.Command.ResetData                                           // Reset statistics
	        THEN
	            
	            "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,        // Reset statistics input
	                            ix_Activate := #sx_Stopped,                                           // Activate statistics functions input
	                            ix_RTrigActivate := #sR_TRIG_ConveyorStopped.Q,                        // Statistics active trigger
	                            iqUDT_Statistics := #iqUDT_Statistics.ConveyorStop);                  // Statistics values output
	            
	        END_IF;
	    END_REGION
	    
	END_REGION
	
	REGION 11 - Report to control block    
	    // Function to manage report between control block and conveyor block
	    "FC_EquipmentReport"(iUDT_Status := #sUDT_CommonStatus,
	                         iqUDT_Control := #iqUDT_EquipmentControl);
	    
	END_REGION
	
	REGION 12 - Internal errors and warnings reset
	    
	    IF #iqUDT_EquipmentControl.Command.Reset
	    THEN
	        
	        #iqUDT_ConveyorInterface.InternalErrorEncoder := FALSE;
	        #iqUDT_ConveyorInterface.InternalErrorPEC := FALSE;
	        #iqUDT_ConveyorInterface.InternalWarningTracking := FALSE;
	        #iqUDT_ConveyorInterface.InternalErrorTracking := FALSE;
	        #iqUDT_ConveyorInterface.InternalWarningVFD := FALSE;
	        #iqUDT_ConveyorInterface.InternalErrorVFD := FALSE;
	        #iqUDT_ConveyorInterface.Disconnected := FALSE;
	        #iqUDT_ConveyorInterface.ConfigurationError := FALSE;
	    END_IF;
	    
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_DimensionsCheck"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 208
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_DimensionsCheckConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_DimensionsCheckConfiguration";   //    Dimensions check configuration structure
      ix_LenghtPEC1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Length 1  PEC
      ix_LenghtPEC2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Length 2 PEC
      ix_HeightPEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Height PEC
      ix_WidthPEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Width  PEC
      ix_Reset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when reset errors or reset energy save required
      ix_ReverseRun { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when run conveyor in reverse direction is required
      ix_ResetStatistics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when reset statistics required
      ix_ConveyorEsaveStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor Energy save Status: In Esave
      ix_HardwareOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 24V on RIO with DMC signals is OK
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_DimensionsCheckStatus";   //    Dimensions check status error structure
      qx_Lamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    TRUE when lamp requested
      qx_ButtonLamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Button lamp
      qx_Halt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    TRUE when conveyor halt
      qx_WakeUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    TRUE when reset enery save mode requested
      qx_RunReverse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    TRUE when conveyor run in reverse direction
   END_VAR

   VAR_IN_OUT 
      iqUDT_DimensionsCheckStatistics : "UDT_DimensionsCheckStatistics";   //    Dimensions check statistics
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   //  Equipment control structure
      iqUDT_ConveyorInterface : "UDT_ConveyorInterface";   // Conveyor interface structure
   END_VAR

   VAR 
      sFB_HardwareOKSignalDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sFB_FirstLengthPECTimerOnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //    Length PEC 1 filter
      sFB_SecLengthPECTimerOnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //    Length PEC 2 filter
      sFB_HeightPECTimerOnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //    Heigh PEC filter
      sFB_Width1PECTimerOnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //    Width PEC 1 filter
      sFB_Width2PECTimerOnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //    Width PEC 2 filter
      sR_TRIG_ParcelTooLong {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //    Rising edge trigger of parcel too long error
      sR_TRIG_ParcelTooHigh {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //    Rising edge trigger of parcel too long error
      sR_TRIG_ParcelTooWide {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //    Rising edge trigger of parcel too wide trigger
      sR_TRIG_WidthPEC {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //    Detect parcel on the Width 1 PEC
      sUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_DimensionsCheckStatus";   //    Dimension check status structure
      sui_ActualParcelLenght { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //    Actual parcel lenght
      sui_LengthPEC2Displacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // displacement of the parcel after length pec trigger
      sui_widthPECDisplacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // displacement of the parcel after width pec trigger
      si_1stPackageDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //    Distance traveled by the first package after hitting the first Width PEC
      si_2ndPackageDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //    Distance traveled by the second package after hitting the first Width PEC
      si_SickDistance1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Distance from the SICK1 [cm]
      si_SickDistance2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Distance from the SICK2 [cm]
      si_ParcelTooWideDisplacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Displacement of the parcel
      sx_ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Configuration error
      sx_FirstLengthPEC_Filtered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Filtered signal of Length 1 PEC
      sx_SecLengthPEC_Filtered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Filtered signal of Length 2 PEC
      sx_HeightPEC_Filtered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Filtered signal of Heigth PEC
      sx_Width1PEC_Filtered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Filtered signal of Width 1 PEC
      sx_Width2PEC_Filtered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Filtered signal of Width 2 PEC
      sx_Halt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Static variable for halt conveyor
      sx_Lamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Static variable for lamp control
      sx_WakeUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Static variable for wake up from energy save signal
      sx_RunReverse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Run reverse request
      sx_Count1stDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Request to count distance traveled by parcel after hitting width 1 PEC
      sx_Count2ndDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Request to count distance traveled by parcel after hitting width 1 PEC in case where there is already another package between PECs
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	23/10/2019  | 3.0       | J.Krawczuk    | Initial version
	13/03/2020  | 3.1       | A.Nowak       | Change the too long width detection and variables
	16/03/2020  | 3.2       | M.Kurpiers    | Adapting reviews
	27/08/2020  | 3.3       | A.Nowak       | Add status number creating
	31/08/2020  | 3.4       | A.Nowak       | Change reset of the too wide parcel status
	09/09/2021  | 3.5       | N.Kadam       | Change for Fedex Milano
	01/02/2022  | 3.6       | M.Piela       | Change signaling lamp into solid light when the parcel is too long 
	16/03/2022  | 3.7       | M.Piela       | Width check fix
	16/05/2022  | 3.8       | M.Kurpiers    | ABS added to package length calculation
	17/06/2022  | 3.9       | M.Kurpiers    | HMI status initialization added
	19/07/2022  | 3.10      | M.Kurpiers    | Check if downstream conveyor is not running reverse during too wide check
	29/07/2022  | 3.10      | M.Piela       | Check heigth pec only when conveyor is running
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Triggers
	    
	    // Preparing triggers for statistics.
	    #sR_TRIG_ParcelTooLong(CLK := #sUDT_Status.Specific.ParcelTooLong);
	    #sR_TRIG_ParcelTooHigh(CLK := #sUDT_Status.Specific.ParcelTooHigh);
	    #sR_TRIG_ParcelTooWide(CLK := #sUDT_Status.Specific.ParcelTooWide);
	    
	END_REGION
	
	REGION 2 - 24v OK signal delay
	    
	    #sFB_HardwareOKSignalDelay(iudi_OnDelayTime := 5000,
	                               ix_SignalToDelay := #ix_HardwareOK);
	    
	END_REGION
	
	REGION 2 - Photo eye's filters
	    
	    // First length check photo eye filter. 
	    #sFB_FirstLengthPECTimerOnOffDelay(iudi_OffDelayTime := #iUDT_DimensionsCheckConfiguration.PECLength1OnTime,
	                                       iudi_OnDelayTime := #iUDT_DimensionsCheckConfiguration.PECLength1OffTime,
	                                       ix_Enable := TRUE,
	                                       ix_SignalToDelay := NOT #ix_LenghtPEC1,
	                                       qx_DelayedSignal => #sx_FirstLengthPEC_Filtered);
	    // Second length check photo eye filter.
	    #sFB_SecLengthPECTimerOnOffDelay(iudi_OnDelayTime := #iUDT_DimensionsCheckConfiguration.PECLength2OnTime,
	                                     iudi_OffDelayTime := #iUDT_DimensionsCheckConfiguration.PECLength2OffTime,
	                                     ix_SignalToDelay := NOT #ix_LenghtPEC2,
	                                     ix_Enable := TRUE,
	                                     qx_DelayedSignal => #sx_SecLengthPEC_Filtered);
	    // High check photo eye filter.
	    #sFB_HeightPECTimerOnOffDelay(iudi_OnDelayTime := #iUDT_DimensionsCheckConfiguration.PECHeightTimeOn,
	                                  iudi_OffDelayTime := #iUDT_DimensionsCheckConfiguration.PECHeightTimeOff,
	                                  ix_SignalToDelay := NOT #ix_HeightPEC,
	                                  ix_Enable := TRUE,
	                                  qx_DelayedSignal => #sx_HeightPEC_Filtered);
	    // Width 1 check photo eye filter.
	    #sFB_Width1PECTimerOnOffDelay(iudi_OnDelayTime := #iUDT_DimensionsCheckConfiguration.PECWidthOnTime,
	                                  iudi_OffDelayTime := #iUDT_DimensionsCheckConfiguration.PECWidthOffTime,
	                                  ix_SignalToDelay := NOT #ix_WidthPEC,
	                                  ix_Enable := TRUE,
	                                  qx_DelayedSignal => #sx_Width1PEC_Filtered);
	    
	END_REGION
	
	REGION 3 - Error reset
	    
	    // Reseting errors.
	    IF #ix_Reset
	    THEN
	        #sUDT_Status.Specific.ParcelTooHigh := FALSE;
	        #sUDT_Status.Specific.ParcelTooLong := FALSE;
	        
	        IF NOT #sx_Width1PEC_Filtered
	        THEN
	            #sUDT_Status.Specific.ParcelTooWide := FALSE;
	        END_IF;
	    END_IF;
	    
	    // Reseting conveyor energy save mode. 
	    #sx_WakeUp := #ix_Reset;
	    
	END_REGION
	
	REGION 4 - Configuration check
	    
	    #sx_ConfigurationError :=
	    #iUDT_DimensionsCheckConfiguration.DistanceBetweenLenghtPECs <= 0
	    OR #iUDT_DimensionsCheckConfiguration.PECWidthCheckLimit <= 0;
	    
	END_REGION
	
	REGION 5 - Package length calculation
	    
	    // When first lenght check PEC is active displacement is added to actual parcel lenght. 
	    IF #sx_FirstLengthPEC_Filtered
	    THEN
	        #sui_ActualParcelLenght += ABS(#iqUDT_ConveyorInterface.Displacement);
	        // When parcel leaves the first PEC then actual parcel lenght is reset.    
	    ELSE
	        #sui_ActualParcelLenght := 0;
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Length check PEC long parcel detection 
	    
	    // If Length 2 PEC  is triggered for more than configured distance then set too long parcel error
	    
	    IF #sx_SecLengthPEC_Filtered
	        AND #iqUDT_ConveyorInterface.RunFwd
	    THEN
	        #sui_LengthPEC2Displacement += ABS(#iqUDT_ConveyorInterface.Displacement);
	    ELSE
	        #sui_LengthPEC2Displacement := 0;
	    END_IF;
	    
	    IF #sui_LengthPEC2Displacement > #iUDT_DimensionsCheckConfiguration.PECLength2CheckLimit
	    THEN
	        #sUDT_Status.Specific.ParcelTooLong := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Too long parcel detection
	    
	    // Too long parcel error is set only when two length check PECs are covered by parcel and actual parcel lenght is greater than the distance between the Length PECs.
	    // If configured distance between two PECs is 0 then length check is disabled.
	    IF #iUDT_DimensionsCheckConfiguration.DistanceBetweenLenghtPECs > 0
	        AND #sx_SecLengthPEC_Filtered
	        AND #sx_FirstLengthPEC_Filtered
	        AND #sui_ActualParcelLenght > (#iUDT_DimensionsCheckConfiguration.DistanceBetweenLenghtPECs - #iUDT_DimensionsCheckConfiguration.ParcelLengthAllowedDeviation)
	        AND #sFB_HardwareOKSignalDelay.qx_DelayedSignal
	    THEN
	        #sUDT_Status.Specific.ParcelTooLong := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Too high parcel detection 
	    
	    IF #sx_HeightPEC_Filtered
	        AND #sFB_HardwareOKSignalDelay.qx_DelayedSignal
	        AND #iqUDT_ConveyorInterface.RunFwd
	    THEN
	        #sUDT_Status.Specific.ParcelTooHigh := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 8 - Too wide parcel detection
	    
	    // When width detection check PEC is active then displacement is added to actual parcel lenght. 
	    IF #sx_Width1PEC_Filtered AND NOT #iqUDT_ConveyorInterface.RunRvs
	    THEN
	        #sui_widthPECDisplacement += ABS(#iqUDT_ConveyorInterface.Displacement);
	        // When parcel leaves the PEC then actual parcel lenght is reset.    
	    ELSE
	        #sui_widthPECDisplacement := 0;
	    END_IF;
	    
	    IF #sui_widthPECDisplacement > #iUDT_DimensionsCheckConfiguration.PECWidthCheckLimit
	    THEN
	        #sUDT_Status.Specific.ParcelTooWide := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 9 - Halt request and lamp handling
	    
	    IF #sUDT_Status.Specific.ParcelTooHigh
	        OR #sUDT_Status.Specific.ParcelTooWide
	        OR #sUDT_Status.Specific.ParcelTooLong
	    THEN
	        #sx_RunReverse := #ix_ReverseRun;
	        #sx_Halt := NOT #sx_RunReverse;
	        #sx_Lamp := TRUE;
	    END_IF;
	    
	    IF NOT #sUDT_Status.Specific.ParcelTooHigh
	        AND NOT #sUDT_Status.Specific.ParcelTooLong
	        AND NOT #sUDT_Status.Specific.ParcelTooWide
	    THEN
	        #sx_Halt := FALSE;
	        #sx_Lamp := FALSE;
	        #sx_RunReverse := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 10 - Statistics
	    
	    REGION 10.1 - Too long parcels statistics
	        
	        IF #sUDT_Status.Specific.ParcelTooLong
	            OR #ix_ResetStatistics
	        THEN
	            "FC_Statistics"(ix_Reset := #ix_ResetStatistics,
	                            ix_Activate := #sUDT_Status.Specific.ParcelTooLong,
	                            ix_RTrigActivate := #sR_TRIG_ParcelTooLong.Q,
	                            iqUDT_Statistics := #iqUDT_DimensionsCheckStatistics.TooLongParcels);
	        END_IF;
	        
	    END_REGION
	    
	    REGION 10.2 - Too high parcels statistics 
	        
	        IF #sUDT_Status.Specific.ParcelTooHigh
	            OR #ix_ResetStatistics
	        THEN
	            "FC_Statistics"(ix_Reset := #ix_ResetStatistics,
	                            ix_Activate := #sUDT_Status.Specific.ParcelTooHigh,
	                            ix_RTrigActivate := #sR_TRIG_ParcelTooHigh.Q,
	                            iqUDT_Statistics := #iqUDT_DimensionsCheckStatistics.TooHighParcels);
	        END_IF;
	        
	    END_REGION
	    
	    REGION 10.3 - Too wide parcels statistics 
	        
	        IF #sUDT_Status.Specific.ParcelTooWide
	            OR #ix_ResetStatistics
	        THEN
	            "FC_Statistics"(ix_Reset := #ix_ResetStatistics,
	                            ix_Activate := #sUDT_Status.Specific.ParcelTooWide,
	                            ix_RTrigActivate := #sR_TRIG_ParcelTooWide.Q,
	                            iqUDT_Statistics := #iqUDT_DimensionsCheckStatistics.TooWideParcels);
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 11 - Button lamp
	    
	    IF #iqUDT_EquipmentControl.Report.Stopped
	    THEN
	        #qx_ButtonLamp := FALSE;
	    END_IF;
	    
	    IF (#iqUDT_EquipmentControl.Report.Running
	        AND NOT #iqUDT_EquipmentControl.Report.EnergySave)
	        OR (#iqUDT_EquipmentControl.Report.Dieback
	        OR #iqUDT_EquipmentControl.Report.Error)
	    THEN
	        #qx_ButtonLamp := TRUE;
	    END_IF;
	    
	    IF #ix_ConveyorEsaveStatus
	    THEN
	        #qx_ButtonLamp := "mx_Clock_0.5Hz";
	    END_IF;
	    
	END_REGION
	
	REGION 12 - Status 
	    
	    // HMI status initialization
	    #sUDT_Status.Status := 0;
	    
	    IF #iqUDT_EquipmentControl.Report.EnergySave
	    THEN
	        #sUDT_Status.Status := "DB_HMIStatusConfiguration".EnergySave;
	    END_IF;
	    
	    IF #iqUDT_EquipmentControl.Report.Running
	    THEN
	        #sUDT_Status.Status := "DB_HMIStatusConfiguration".Running;
	    END_IF;
	    
	    IF #iqUDT_EquipmentControl.Report.Stopped
	    THEN
	        #sUDT_Status.Status := "DB_HMIStatusConfiguration".Stopped;
	    END_IF;
	    
	    IF #sUDT_Status.Specific.ParcelTooHigh
	        OR #sUDT_Status.Specific.ParcelTooLong
	        OR #sUDT_Status.Specific.ParcelTooWide
	    THEN
	        #sUDT_Status.Status := "DB_HMIStatusConfiguration".DimensionError;
	    END_IF;
	    
	    IF #iqUDT_EquipmentControl.Report.SafetyStop
	    THEN
	        #sUDT_Status.Status := "DB_HMIStatusConfiguration".SafetyStop;
	    END_IF;
	    
	END_REGION
	
	REGION 13 - Update outputs
	    
	    #qUDT_HMIStatus := #sUDT_Status;
	    #qx_Halt := #sx_Halt;
	    #qx_Lamp := #sx_Lamp;
	    #qx_WakeUp := #sx_WakeUp;
	    #qx_RunReverse := #sx_RunReverse;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_DimensionsCheckV2"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 209
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_DimensionsCheckConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_DimensionsCheckConfigurationV2";   // Dimensions check configuration structure
      iUDT_DimensionsCheckCommand { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_DimensionsCheckCommandV2";   // HMI control structure
      ix_Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE -  function is active only when parcels are loaded into the system
      ix_PECBos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;   // TRUE -  when the beginning end of section photoeye is not blocked or nothing is connected
      ix_LenghtPECLaser { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Length sensor - FALSE when sensor detect the parcel
      ix_MinHeightPECArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Minimum height sensor - FALSE when sensor detect the parcel
      ix_MaxHeightPEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Maximum height sensor - FALSE when sensor detect the parcel
      ii_DistanceSensor1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Distance measured by sensor between it and parcel [mm]
      ii_DistanceSensor2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Distance measured by sensor between it and parcel [mm]
      ii_Displacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Conveyor displacement [cm]
      ix_Reset_Button { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset button
      ix_ReverseRunButton { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reverse run button
      ix_HardwareOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 24V on RIO with DMC signals is OK
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_DimensionsCheckStatusV2";   // Dimensions check status error structure
      qUDT_HMIData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_DimensionsCheckHMIDataV2";   // Dimensions check HMI data structure
      qx_RequestHoldConveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when conveyor should be stopped
      qx_RequestRunReverseConveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when conveyor should run in reverse direction
      qx_BuzzerColumn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Buzzer on column
      qx_LightColumn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Light on column blue color
      qx_LightResetButton { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Light button blue color
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
   END_VAR

   VAR 
      s_HeightPEC_TimerOnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Heigh sensor filter
      s_FB_HardwareOKSignalDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Hardware OK signal delay
      s_R_TRIG_ParcelTooLong {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of too long parcel error
      s_R_TRIG_ParcelTooShort {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of too short parcel error
      s_R_TRIG_ParcelTooHigh {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of  too high parcel error
      s_R_TRIG_ParcelTooLow {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of  too low parcel error
      s_R_TRIG_ParcelTooWide {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of parcel too wide trigger
      s_R_TRIG_ParcelTooNarrow {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of  too narrow parcel error
      s_R_TRIG_IncorrectShape {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of  incorrect shape error
      s_R_TRIG_GeneralError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of general error
      s_R_TRIG_MinHeightPEC_Array {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of lenght sensor
      s_R_TRIG_ResetButton {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of reset button
      s_R_TRIG_ButtonOffsetDistanceSensor1 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of offset button
      s_R_TRIG_ButtonOffsetDistanceSensor2 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of offset button
      s_F_TRIG_MinHeightPEC_Array {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger of lenght sensor
      s_F_TRIG_WaitForAllScanData {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger of parcel scaned
      s_UDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_DimensionsCheckStatusV2";   // Dimension check status structure
      s_UDT_DimensionsCheckStatistics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_DimensionsCheckStatisticsV2";   // Dimensions check statistics
      sa_Measurement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..200] of Struct   // Array with measurement data
         MaxHeightPEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         MinHeight_Array { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         LenghtPEC_Laser { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Distance_Sensor_1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;
         Distance_Sensor_2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;
      END_STRUCT;
      ss_Parcel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Structure with parcel data
         Lenght { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Lenght [mm]
         Size { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..200] of Struct   // size arrray
            Width { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;
            TooHigh { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
            TooLow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         END_STRUCT;
      END_STRUCT;
      ss_Positions_Distance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Distance is calculeted from firts sensor to the next one
         MinHeight_PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Distance between Lenght_PEC_1 and ix_MinHeightPEC [mm]
         Width_Distance_Sensor_1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Distance between Lenght_PEC_1 and Width_Distance_Sensor_1 [mm]
         Width_Distance_Sensor_2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Distance between Lenght_PEC_1 and Width_Distance_Sensor_2 [mm]
      END_STRUCT;
      si_CounterTooLow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Error detection counter - too low
      si_CounterTooHigh { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Error detection counter - too high
      si_CounterTooWide { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Error detection counter - too wide
      si_CounterTooNarrow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Error detection counter - too narrow
      si_MaxWidthParcel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Error detection counter - max parcel width
      sr_Tolerance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Tolerance used to active the error
   END_VAR
   VAR RETAIN
      si_Offset_DistanceSensor1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Distance sensor 1 offset value
      si_Offset_DistanceSensor2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Distance sensor 2 offset value
   END_VAR
   VAR 
      si_ParcelLenght { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Parcel lenght
      si_RejectDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Reject distance
      si_StatusMoveBLKVariant { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Move BLK status
      si_DistanceToLastSensor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Distance to last sensor
      si_DistanceCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Distance counter used in teaching mode
      si_ParcelCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Parcel counter - count up each scaned parcel
      si_DistanceTooHighSensor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Distance for how long "too high sensor" is active
      si_DistanceTooLongSensor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Distance for how long "too long sensor" is active
      sx_ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Configuration error
      sx_MinHeight_PEC_Filtered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Filtered signal of Heigth PEC
      sx_RequestHold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Static variable for hold conveyor
      sx_RequestRunReverse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Run reverse request
      sx_ParcelScanning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parcel scanning in progress
      sx_ParcelScanned { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parcel scanned
      sx_WaitForAllScanData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Funcion is waiting for all data
      sx_NextParcelInSensorsRange { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Next parcel in sensors range
      sx_ParcelRejecte { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parcel reject
      sx_ActiveTeachingMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;   // Active teaching mode
      si_RejectWindow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - when some parcel is on the sensor line
      sui_ProductWidth { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Product width
   END_VAR

   VAR_TEMP 
      ti_LoopParcelLength : Int;   // Loop counter - Parcel length
      ti_LoopCleanArrayMeasurement : Int;   // Loop counter - Clean array measurement
      ti_LoopCleanArray : Int;   // Loop counter - Clean array
      ti_LoopErrorDetection : Int;   // Loop counter - Error detection
      ti_LoopDisplacement : Int;   // Loop counter - Displacement
      ti_ArraySize : Int;   // Array size
      ts_Position : Struct   // Sensors position
         MinHeightPEC : Int;   // PEC position
         WidthDistanceSensor1 : Int;   // Distance sensor position
         WidthDistanceSensor2 : Int;   // Distance sensor position
      END_STRUCT;
   END_VAR

   VAR CONSTANT 
      ci_MeasurementArraySize : Int := 199;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             Fortna Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |
	|                                                                                      |     
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------                                          
	29/03/2023  | 1.0       | S. Nikodem    | First release TIA V17 | DHL Munich 2023
	15/12/2023  | 1.1       | S. Nikodem    | On site update
	04/01/2024  | 1.2       | M.Diebel      | Added "not" to "too long parcel" condition    
	22/01/2024  | 1.3       | L.Klar        | New configuration error condition to avoid PLC stop
	02/02/2024  | 1.4       | R.Golonka     | Product width HMI status, HMI error status
	12/02/2024  | 1.5       | L.Klar        | Stop measuring condition changed
	12/03/2024  | 1.6       | S.Nieswiec    | Added from Munich, variable names changes according to standard 
	
	*)
	
	REGION 1 - Triggers
	    
	    // Preparating triggers for statistics.
	    #s_R_TRIG_ParcelTooLong(CLK := #s_UDT_Status.Specific.ParcelTooLongError);
	    #s_R_TRIG_ParcelTooShort(CLK := #s_UDT_Status.Specific.ParcelTooShortError);
	    #s_R_TRIG_ParcelTooHigh(CLK := #s_UDT_Status.Specific.ParcelTooHighError);
	    #s_R_TRIG_ParcelTooLow(CLK := #s_UDT_Status.Specific.ParcelTooLowError);
	    #s_R_TRIG_ParcelTooWide(CLK := #s_UDT_Status.Specific.ParcelTooWideError);
	    #s_R_TRIG_ParcelTooNarrow(CLK := #s_UDT_Status.Specific.ParcelTooNarrowError);
	    #s_R_TRIG_IncorrectShape(CLK := #s_UDT_Status.Specific.IncorrectParcelOrientationError);
	    
	    // Sensor triggers
	    #s_R_TRIG_MinHeightPEC_Array(CLK := #sx_MinHeight_PEC_Filtered);
	    #s_F_TRIG_MinHeightPEC_Array(CLK := #sx_MinHeight_PEC_Filtered);
	    
	    // Button trigger
	    #s_R_TRIG_ResetButton(CLK := #ix_Reset_Button);
	    #s_R_TRIG_ButtonOffsetDistanceSensor1(CLK := #iUDT_DimensionsCheckCommand.ButtonOffsetDistanceSensor1);
	    #s_R_TRIG_ButtonOffsetDistanceSensor2(CLK := #iUDT_DimensionsCheckCommand.ButtonOffsetDistanceSensor2);
	    
	    // Parcel scaned
	    #s_F_TRIG_WaitForAllScanData(CLK := #sx_WaitForAllScanData);
	    
	END_REGION
	
	REGION 2 - 24V OK signal delay
	    
	    #s_FB_HardwareOKSignalDelay(iudi_OnDelayTime := 5000,
	                                ix_SignalToDelay := #ix_HardwareOK);
	    
	END_REGION
	
	REGION 2 - Photo eye filter
	    
	    // Minimum high check photo eye filter.
	    #s_HeightPEC_TimerOnOffDelay(iudi_OnDelayTime := #iUDT_DimensionsCheckConfiguration.PEC_Time_Delay.On_MinHeight,
	                                 iudi_OffDelayTime := #iUDT_DimensionsCheckConfiguration.PEC_Time_Delay.Off_MinHeight,
	                                 ix_SignalToDelay := NOT #ix_MinHeightPECArray,
	                                 ix_Enable := TRUE,
	                                 qx_DelayedSignal => #sx_MinHeight_PEC_Filtered);
	    
	END_REGION
	
	REGION 3 - Error reset
	    
	    // Reseting errors.
	    // 
	    IF #s_R_TRIG_ResetButton.Q OR #iqUDT_EquipmentControl.Command.Reset THEN
	        #s_UDT_Status.Specific.GeneralError := False;
	    END_IF;
	    
	    IF #s_R_TRIG_ResetButton.Q AND #si_RejectWindow
	    THEN
	        
	        #s_UDT_Status.Specific.ParcelTooLongError := False;
	        #s_UDT_Status.Specific.ParcelTooShortError := False;
	        #s_UDT_Status.Specific.ParcelTooHighError := False;
	        #s_UDT_Status.Specific.ParcelTooLowError := False;
	        #s_UDT_Status.Specific.ParcelTooWideError := False;
	        #s_UDT_Status.Specific.ParcelTooNarrowError := False;
	        #s_UDT_Status.Specific.IncorrectParcelOrientationError := False;
	        
	        
	        //Check array size
	        #ti_ArraySize := "FC_GetNrOfArrayEl"(iv_Array := #sa_Measurement);
	        
	        //Reset all data in measurement array
	        FOR #ti_LoopCleanArrayMeasurement := 0 TO (#ti_ArraySize - 1) DO
	            
	            #sa_Measurement[#ti_LoopCleanArrayMeasurement].Distance_Sensor_1 := 0;
	            #sa_Measurement[#ti_LoopCleanArrayMeasurement].Distance_Sensor_2 := 0;
	            #sa_Measurement[#ti_LoopCleanArrayMeasurement].MaxHeightPEC := False;
	            #sa_Measurement[#ti_LoopCleanArrayMeasurement].MinHeight_Array := False;
	            #sa_Measurement[#ti_LoopCleanArrayMeasurement].LenghtPEC_Laser := False;
	            
	        END_FOR;
	        
	        //Check array size
	        #ti_ArraySize := "FC_GetNrOfArrayEl"(iv_Array := #ss_Parcel.Size);
	        
	        //Reset all parcel data
	        FOR #ti_LoopCleanArray := 0 TO (#ti_ArraySize - 1) DO
	            
	            #ss_Parcel.Size[#ti_LoopCleanArray].Width := 0;
	            #ss_Parcel.Size[#ti_LoopCleanArray].TooHigh := 0;
	            #ss_Parcel.Size[#ti_LoopCleanArray].TooLow := 0;
	            #ss_Parcel.Lenght := 0;
	            
	        END_FOR;
	        
	        //Reset all value after parcel reject
	        #sx_ParcelScanning := FALSE;
	        #sx_ParcelScanned := FALSE;
	        #sx_WaitForAllScanData := FALSE;
	        #sx_NextParcelInSensorsRange := FALSE;
	        #si_DistanceToLastSensor := 0;
	        #sx_RequestHold := False;
	        #sx_ParcelRejecte := False;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Configuration check
	    
	    // Save offset 
	    // Offset it is a distance from sensor to side guards
	    IF #s_R_TRIG_ButtonOffsetDistanceSensor1.Q THEN
	        #si_Offset_DistanceSensor1 := #ii_DistanceSensor1;
	    END_IF;
	    
	    IF #s_R_TRIG_ButtonOffsetDistanceSensor2.Q THEN
	        #si_Offset_DistanceSensor2 := #ii_DistanceSensor2;
	    END_IF;
	    
	    //Copy sensors positions
	    #ts_Position.MinHeightPEC := #iUDT_DimensionsCheckConfiguration.Position.MinHeightPEC_Array / 10;
	    #ts_Position.WidthDistanceSensor1 := #iUDT_DimensionsCheckConfiguration.Position.Width_Distance_Sensor_1 / 10;
	    #ts_Position.WidthDistanceSensor2 := #iUDT_DimensionsCheckConfiguration.Position.Width_Distance_Sensor_2 / 10;
	    
	    //Configuration check
	    #sx_ConfigurationError := #iUDT_DimensionsCheckConfiguration.Position.MinHeightPEC_Array <= 0
	    OR #iUDT_DimensionsCheckConfiguration.Position.Width_Distance_Sensor_1 <= 0
	    OR #iUDT_DimensionsCheckConfiguration.Position.Width_Distance_Sensor_2 <= 0
	    OR #iUDT_DimensionsCheckConfiguration.Position.Width_Distance_Sensor_1 >= #iUDT_DimensionsCheckConfiguration.Position.Width_Distance_Sensor_2
	    OR #si_Offset_DistanceSensor1 <= 0
	    OR #si_Offset_DistanceSensor2 <= 0;
	    
	END_REGION
	
	REGION 5 - Collect data from sensors
	    
	    IF #ix_Enable
	        AND NOT #sx_ConfigurationError
	        AND #ii_Displacement > 0
	    THEN
	        
	        //Copy data from sensors to array
	        FOR #ti_LoopDisplacement := 1 TO #ii_Displacement DO
	            
	            // Switch data in the array
	            #si_StatusMoveBLKVariant := MOVE_BLK_VARIANT(SRC := #sa_Measurement, COUNT := 199, SRC_INDEX := 0, DEST_INDEX := 1, DEST => #sa_Measurement);
	            
	            //Max height PEC - Laser
	            #sa_Measurement[0].MaxHeightPEC := NOT #ix_MaxHeightPEC;
	            
	            //Min height - RAY 26
	            #sa_Measurement[0].MinHeight_Array := NOT #ix_MinHeightPECArray;
	            
	            //Lenght PEC - Laser
	            #sa_Measurement[0].LenghtPEC_Laser := NOT #ix_LenghtPECLaser;
	            
	            //Distance sensor 1
	            #sa_Measurement[0].Distance_Sensor_1 := #ii_DistanceSensor1 - #si_Offset_DistanceSensor1;
	            
	            //Distance sensor 2
	            #sa_Measurement[0].Distance_Sensor_2 := #ii_DistanceSensor2 - #si_Offset_DistanceSensor2;
	            
	        END_FOR;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Create virtual parcel
	    
	    IF #ix_Enable
	        AND NOT #sx_ConfigurationError
	        AND NOT #sx_RequestRunReverse
	    THEN
	        
	        //Start measuring process. Beginning of the parcel detected 
	        IF
	            (#s_R_TRIG_MinHeightPEC_Array.Q OR (#sx_NextParcelInSensorsRange AND NOT #sx_ParcelScanning))
	        THEN
	            
	            //Two parcels in the sensor range
	            #sx_NextParcelInSensorsRange := #sx_ParcelScanning;
	            
	            //Active when parcel is detected
	            #sx_ParcelScanning := True;
	            
	        END_IF;
	        
	        //End of the parcel detected, wait for data from all sensors. 
	        IF #s_F_TRIG_MinHeightPEC_Array.Q
	            AND #sx_ParcelScanning
	        THEN
	            
	            #sx_ParcelScanning := False;
	            #sx_WaitForAllScanData := True;
	            
	        END_IF;
	        
	        //Calculate the distance to last sensor
	        IF #sx_WaitForAllScanData THEN
	            
	            #si_DistanceToLastSensor += #ii_Displacement;
	            
	            //Stop measuring process.
	            IF #ts_Position.WidthDistanceSensor2 <= #si_DistanceToLastSensor THEN
	                
	                #si_DistanceToLastSensor := 0;
	                #sx_ParcelScanned := True;
	                #sx_WaitForAllScanData := False;
	                
	                //Clean parcel data
	                FOR #ti_LoopCleanArray := 0 TO #ci_MeasurementArraySize DO
	                    
	                    #ss_Parcel.Size[#ti_LoopCleanArray].Width := 0;
	                    #ss_Parcel.Size[#ti_LoopCleanArray].TooHigh := 0;
	                    #ss_Parcel.Size[#ti_LoopCleanArray].TooLow := 0;
	                    #ss_Parcel.Lenght := 0;
	                    
	                END_FOR;
	                
	            END_IF;
	            
	        END_IF;
	        
	    END_IF;
	    
	    REGION 6.1 - Parcel calculation
	        
	        IF #sx_ParcelScanned THEN
	            
	            //Check array size
	            #ti_ArraySize := "FC_GetNrOfArrayEl"(iv_Array := #sa_Measurement);
	            
	            FOR #ti_LoopParcelLength := #ts_Position.WidthDistanceSensor2 TO (#ti_ArraySize - 1) DO
	                
	                // Length
	                IF #sa_Measurement[#ti_LoopParcelLength].MinHeight_Array THEN
	                    
	                    // Height 
	                    #ss_Parcel.Size[#ss_Parcel.Lenght].TooHigh := #sa_Measurement[#ti_LoopParcelLength].MaxHeightPEC;
	                    #ss_Parcel.Size[#ss_Parcel.Lenght].TooLow := #sa_Measurement[#ti_LoopParcelLength].MinHeight_Array AND NOT #sa_Measurement[#ti_LoopParcelLength + #ts_Position.MinHeightPEC].LenghtPEC_Laser;
	                    
	                    // Width
	                    IF ((#sa_Measurement[#ti_LoopParcelLength - #ts_Position.WidthDistanceSensor1 + #ts_Position.MinHeightPEC].Distance_Sensor_1 < #iUDT_DimensionsCheckConfiguration.Position.BeltWidth)
	                        AND ((#sa_Measurement[#ti_LoopParcelLength - #ts_Position.WidthDistanceSensor2 + #ts_Position.MinHeightPEC].Distance_Sensor_2) < #iUDT_DimensionsCheckConfiguration.Position.BeltWidth))
	                    THEN
	                        #ss_Parcel.Size[#ss_Parcel.Lenght].Width :=
	                        INT_TO_UINT(#iUDT_DimensionsCheckConfiguration.Position.BeltWidth) -
	                        ((#sa_Measurement[#ti_LoopParcelLength - #ts_Position.WidthDistanceSensor1 + #ts_Position.MinHeightPEC].Distance_Sensor_1) +
	                        (#sa_Measurement[#ti_LoopParcelLength - #ts_Position.WidthDistanceSensor2 + #ts_Position.MinHeightPEC].Distance_Sensor_2));
	                        
	                        //Override overflow of UINT
	                        IF #ss_Parcel.Size[#ss_Parcel.Lenght].Width > #iUDT_DimensionsCheckConfiguration.Position.BeltWidth THEN
	                            #ss_Parcel.Size[#ss_Parcel.Lenght].Width := 0;
	                        END_IF;
	                        
	                    END_IF;
	                    
	                    #ss_Parcel.Lenght += 1;
	                    
	                END_IF;
	                
	            END_FOR;
	            
	            // Muliplay by 10 to have a lenght in mm
	            #ss_Parcel.Lenght *= 10;
	            
	            //Reset data in array of measurement
	            FOR #ti_LoopCleanArrayMeasurement := #ts_Position.WidthDistanceSensor2 TO #ci_MeasurementArraySize DO
	                
	                #sa_Measurement[#ti_LoopCleanArrayMeasurement].Distance_Sensor_1 := 0;
	                #sa_Measurement[#ti_LoopCleanArrayMeasurement].Distance_Sensor_2 := 0;
	                #sa_Measurement[#ti_LoopCleanArrayMeasurement].MaxHeightPEC := False;
	                #sa_Measurement[#ti_LoopCleanArrayMeasurement].MinHeight_Array := False;
	                #sa_Measurement[#ti_LoopCleanArrayMeasurement].LenghtPEC_Laser := False;
	                
	            END_FOR;
	            
	            //Only for test - Parcel counter 
	            #si_ParcelCounter += 1;
	            
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 7 - Error detection 
	    
	    REGION 7.1 -General Error
	        
	        IF NOT #iUDT_DimensionsCheckCommand.DisableGeneral
	            AND #s_FB_HardwareOKSignalDelay.qx_DelayedSignal
	            AND #sx_ConfigurationError
	        THEN
	            
	            #s_UDT_Status.Specific.GeneralError := True;
	            
	        END_IF;
	        
	    END_REGION
	    
	    //Errors detection is only check when new parcel was scanned 
	    
	    //Errors counter
	    IF #sx_ParcelScanned THEN
	        
	        //Clean counter
	        #si_CounterTooHigh := 0;
	        #si_CounterTooLow := 0;
	        #si_CounterTooWide := 0;
	        #si_CounterTooNarrow := 0;
	        #si_MaxWidthParcel := 0;
	        
	        // Too wide parcel tolerance
	        #sr_Tolerance := INT_TO_REAL(#iUDT_DimensionsCheckConfiguration.Limit.MaxWidth) / 100 * INT_TO_REAL(#iUDT_DimensionsCheckConfiguration.Tolerance.TooWide);
	        
	        //Value in cm
	        #si_ParcelLenght := #ss_Parcel.Lenght / 10;
	        
	        FOR #ti_LoopErrorDetection := 1 TO #si_ParcelLenght DO
	            
	            // Too High
	            IF #ss_Parcel.Size[#ti_LoopErrorDetection].TooHigh THEN
	                #si_CounterTooHigh += 1;
	            END_IF;
	            // Too Low
	            IF #ss_Parcel.Size[#ti_LoopErrorDetection].TooLow THEN
	                #si_CounterTooLow += 1;
	            END_IF;
	            // Too Wide
	            IF #ss_Parcel.Size[#ti_LoopErrorDetection].Width >= #iUDT_DimensionsCheckConfiguration.Limit.MaxWidth + #sr_Tolerance THEN
	                #si_CounterTooWide += 1;
	            END_IF;
	            // Too Narrow
	            IF (#ss_Parcel.Size[#ti_LoopErrorDetection].Width <= #iUDT_DimensionsCheckConfiguration.Limit.MinWidth) AND #ss_Parcel.Size[#ti_LoopErrorDetection].Width <> 0 THEN
	                #si_CounterTooNarrow += 1;
	            END_IF;
	            // Orientation detection
	            IF #si_MaxWidthParcel < #ss_Parcel.Size[#ti_LoopErrorDetection].Width THEN
	                #si_MaxWidthParcel := UINT_TO_INT(#ss_Parcel.Size[#ti_LoopErrorDetection].Width);
	            END_IF;
	            
	        END_FOR;
	        
	        // Tolerance
	        #si_MaxWidthParcel -= #si_MaxWidthParcel / 100.0 * INT_TO_REAL(#iUDT_DimensionsCheckConfiguration.Tolerance.Orientation);
	        
	    END_IF;
	    
	    REGION 7.2 - Too long parcel detection
	        
	        //Active error when "too long" sensor is active as configured value.
	        IF NOT #ix_MinHeightPECArray
	            AND NOT #iUDT_DimensionsCheckCommand.DisableTooLongParcelError
	            AND #iUDT_DimensionsCheckConfiguration.Functionality.TooLongParcelError
	        THEN
	            
	            #si_DistanceTooLongSensor += #ii_Displacement;
	            
	            IF (#si_DistanceTooLongSensor * 10) > #iUDT_DimensionsCheckConfiguration.Limit.TooLongDistance THEN
	                #s_UDT_Status.Specific.ParcelTooLongError := TRUE;
	                #sx_ParcelRejecte := True;
	            END_IF;
	            
	        ELSE
	            #si_DistanceTooLongSensor := 0;
	        END_IF;
	        
	        IF NOT #iUDT_DimensionsCheckCommand.DisableTooLongParcelError
	            AND #sx_ParcelScanned
	            AND (#ss_Parcel.Lenght > #iUDT_DimensionsCheckConfiguration.Limit.MaxLength)
	        THEN
	            #s_UDT_Status.Specific.ParcelTooLongError := TRUE;
	            #sx_ParcelRejecte := True;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 7.3 - Too short parcel detection
	        
	        IF NOT #iUDT_DimensionsCheckCommand.DisableTooShortParcelError
	            AND #iUDT_DimensionsCheckConfiguration.Functionality.TooShortParcelError
	            AND #sx_ParcelScanned
	            AND (#ss_Parcel.Lenght < #iUDT_DimensionsCheckConfiguration.Limit.MinLength)
	        THEN
	            #s_UDT_Status.Specific.ParcelTooShortError := TRUE;
	            #sx_ParcelRejecte := True;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 7.4 - Too high parcel detection 
	        
	        //Active error when "too high" sensor is active as configured value.
	        IF NOT #ix_MaxHeightPEC AND
	            NOT #iUDT_DimensionsCheckCommand.DisableTooHighParcelError
	            AND #iUDT_DimensionsCheckConfiguration.Functionality.TooHighParcelError
	        THEN
	            
	            #si_DistanceTooHighSensor += #ii_Displacement;
	            
	            IF (#si_DistanceTooHighSensor * 10) > #iUDT_DimensionsCheckConfiguration.Limit.TooHighDistance THEN
	                
	                #s_UDT_Status.Specific.ParcelTooHighError := TRUE;
	                #sx_ParcelRejecte := True;
	                
	            END_IF;
	            
	        ELSE
	            
	            #si_DistanceTooHighSensor := 0;
	            
	        END_IF;
	        
	        //Tolerance
	        #sr_Tolerance := INT_TO_REAL(#si_ParcelLenght) / 100.0 * INT_TO_REAL(#iUDT_DimensionsCheckConfiguration.Tolerance.TooHigh);
	        
	        //Check how many times this error occurred in the array, then compare this value to tolerance.
	        //When is bigger like configured value, then set the error message.
	        IF NOT #iUDT_DimensionsCheckCommand.DisableTooHighParcelError
	            AND #sx_ParcelScanned
	            AND (#sr_Tolerance < #si_CounterTooHigh)
	        THEN
	            #s_UDT_Status.Specific.ParcelTooHighError := TRUE;
	            #sx_ParcelRejecte := True;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 7.5 - Too low parcel detection
	        
	        //Tolerance
	        #sr_Tolerance := INT_TO_REAL(#si_ParcelLenght) / 100.0 * INT_TO_REAL(#iUDT_DimensionsCheckConfiguration.Tolerance.TooLow);
	        
	        //Check how many times this error occurred in the array, then compare this value to tolerance.
	        //When is bigger like configured value, then set the error message.
	        IF NOT #iUDT_DimensionsCheckCommand.DisableTooLowParcelError
	            AND #iUDT_DimensionsCheckConfiguration.Functionality.TooLowParcelError
	            AND #sx_ParcelScanned
	            AND (#sr_Tolerance < #si_CounterTooLow)
	        THEN
	            #s_UDT_Status.Specific.ParcelTooLowError := TRUE;
	            #sx_ParcelRejecte := True;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 7.6 - Too wide parcel detection
	        
	        //Tolerance
	        #sr_Tolerance := (INT_TO_REAL(#si_ParcelLenght) / 100.0 * INT_TO_REAL(#iUDT_DimensionsCheckConfiguration.Tolerance.TooWide));
	        
	        //Check how many times this error occurred in the array, then compare this value to tolerance.
	        //When is bigger like configured value, then set the error message.
	        IF NOT #iUDT_DimensionsCheckCommand.DisableTooWideParcelError
	            AND #iUDT_DimensionsCheckConfiguration.Functionality.TooWideParcelError
	            AND #sx_ParcelScanned
	            AND (#sr_Tolerance < #si_CounterTooWide)
	        THEN
	            #s_UDT_Status.Specific.ParcelTooWideError := TRUE;
	            #sx_ParcelRejecte := True;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 7.7 - Too narrow parcel detection
	        
	        //Tolerance
	        #sr_Tolerance := INT_TO_REAL(#si_ParcelLenght) / 100.0 * INT_TO_REAL(#iUDT_DimensionsCheckConfiguration.Tolerance.TooNarrow);
	        
	        //Check how many times this error occurred in the array, then compare this value to tolerance.
	        //When is bigger like configured value, then set the error message.
	        IF NOT #iUDT_DimensionsCheckCommand.DisableTooNarrowParcelError
	            AND #iUDT_DimensionsCheckConfiguration.Functionality.TooNarrowParcelError
	            AND #sx_ParcelScanned
	            AND (#sr_Tolerance < #si_CounterTooNarrow)
	        THEN
	            #s_UDT_Status.Specific.ParcelTooNarrowError := TRUE;
	            #sx_ParcelRejecte := True;
	        END_IF;
	    END_REGION
	    
	    REGION 7.8 - Orientation detection
	        
	        // Check the package position
	        IF NOT #iUDT_DimensionsCheckCommand.DisableParcelOrientationError
	            AND #iUDT_DimensionsCheckConfiguration.Functionality.ParcelOrientationError
	            AND #sx_ParcelScanned
	            AND (#ss_Parcel.Lenght < #si_MaxWidthParcel)
	        THEN
	            #s_UDT_Status.Specific.IncorrectParcelOrientationError := TRUE;
	            #sx_ParcelRejecte := True;
	        END_IF;
	        
	    END_REGION
	    
	    //Reset
	    #sx_ParcelScanned := false;
	    
	END_REGION
	
	REGION 8 - Sequences for removing parcel 
	    
	    IF #sx_ParcelRejecte THEN
	        
	        //To run reverse Operator must press button and BoS sensor should be free. 
	        #sx_RequestRunReverse := #ix_ReverseRunButton AND #ix_PECBos;
	        
	        #sx_RequestHold := True;
	        #si_RejectDistance -= #ii_Displacement;
	        
	    ELSE
	        
	        #sx_RequestRunReverse := False;
	        #si_RejectDistance := 0;
	        
	    END_IF;
	    
	    #si_RejectWindow := #sx_ParcelRejecte
	    AND (#si_RejectDistance > 10)
	    AND #ix_LenghtPECLaser
	    AND #ix_MinHeightPECArray
	    AND #ix_MaxHeightPEC
	    AND (#ii_DistanceSensor1 > #iUDT_DimensionsCheckConfiguration.Position.BeltWidth)
	    AND (#ii_DistanceSensor2 > #iUDT_DimensionsCheckConfiguration.Position.BeltWidth);
	    
	END_REGION
	
	REGION 9 - Statistics
	    
	    REGION 9.1 - Too long parcels statistics
	        
	        IF #s_UDT_Status.Specific.ParcelTooLongError
	            OR #iqUDT_EquipmentControl.Command.ResetData
	        THEN
	            "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                            ix_Activate := #s_UDT_Status.Specific.ParcelTooLongError,
	                            ix_RTrigActivate := #s_R_TRIG_ParcelTooLong.Q,
	                            iqUDT_Statistics := #s_UDT_DimensionsCheckStatistics.TooLongParcels);
	        END_IF;
	        
	    END_REGION
	    
	    REGION 9.2 - Too short parcels statistics
	        
	        IF #s_UDT_Status.Specific.ParcelTooShortError
	            OR #iqUDT_EquipmentControl.Command.ResetData
	        THEN
	            "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                            ix_Activate := #s_UDT_Status.Specific.ParcelTooShortError,
	                            ix_RTrigActivate := #s_R_TRIG_ParcelTooShort.Q,
	                            iqUDT_Statistics := #s_UDT_DimensionsCheckStatistics.TooShortParcels);
	        END_IF;
	        
	    END_REGION
	    
	    REGION 9.3 - Too high parcels statistics 
	        
	        IF #s_UDT_Status.Specific.ParcelTooHighError
	            OR #iqUDT_EquipmentControl.Command.ResetData
	        THEN
	            "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                            ix_Activate := #s_UDT_Status.Specific.ParcelTooHighError,
	                            ix_RTrigActivate := #s_R_TRIG_ParcelTooHigh.Q,
	                            iqUDT_Statistics := #s_UDT_DimensionsCheckStatistics.TooHighParcels);
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 9.4 - Too Low parcels statistics 
	        
	        IF #s_UDT_Status.Specific.ParcelTooLowError
	            OR #iqUDT_EquipmentControl.Command.ResetData
	        THEN
	            "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                            ix_Activate := #s_UDT_Status.Specific.ParcelTooLowError,
	                            ix_RTrigActivate := #s_R_TRIG_ParcelTooLow.Q,
	                            iqUDT_Statistics := #s_UDT_DimensionsCheckStatistics.TooLowParcels);
	        END_IF;
	        
	    END_REGION
	    
	    REGION 9.5 - Too wide parcels statistics 
	        
	        IF #s_UDT_Status.Specific.ParcelTooWideError
	            OR #iqUDT_EquipmentControl.Command.ResetData
	        THEN
	            "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                            ix_Activate := #s_UDT_Status.Specific.ParcelTooWideError,
	                            ix_RTrigActivate := #s_R_TRIG_ParcelTooWide.Q,
	                            iqUDT_Statistics := #s_UDT_DimensionsCheckStatistics.TooWideParcels);
	        END_IF;
	        
	    END_REGION
	    
	    REGION 9.6 - Too narrow parcels statistics 
	        
	        IF #s_UDT_Status.Specific.ParcelTooNarrowError
	            OR #iqUDT_EquipmentControl.Command.ResetData
	        THEN
	            "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                            ix_Activate := #s_UDT_Status.Specific.ParcelTooNarrowError,
	                            ix_RTrigActivate := #s_R_TRIG_ParcelTooNarrow.Q,
	                            iqUDT_Statistics := #s_UDT_DimensionsCheckStatistics.TooNarrowParcels);
	        END_IF;
	        
	    END_REGION
	    
	    REGION 9.7 - Incorrect parcel orientation statistics 
	        
	        IF #s_UDT_Status.Specific.IncorrectParcelOrientationError
	            OR #iqUDT_EquipmentControl.Command.ResetData
	        THEN
	            "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                            ix_Activate := #s_UDT_Status.Specific.IncorrectParcelOrientationError,
	                            ix_RTrigActivate := #s_R_TRIG_IncorrectShape.Q,
	                            iqUDT_Statistics := #s_UDT_DimensionsCheckStatistics.IncorrectShape);
	        END_IF;
	        
	    END_REGION
	    
	    REGION 9.8 - General error statistics 
	        
	        IF #s_UDT_Status.Specific.GeneralError
	            OR #iqUDT_EquipmentControl.Command.ResetData
	        THEN
	            "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                            ix_Activate := #s_UDT_Status.Specific.GeneralError,
	                            ix_RTrigActivate := #s_R_TRIG_GeneralError.Q,
	                            iqUDT_Statistics := #s_UDT_DimensionsCheckStatistics.GeneralError);
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 10 - Status 
	    
	    //Status
	    IF #iqUDT_EquipmentControl.Report.EnergySave
	    THEN
	        #s_UDT_Status.Status := "DB_HMIStatusConfiguration".EnergySave;
	    END_IF;
	    
	    IF #iqUDT_EquipmentControl.Report.Running
	    THEN
	        #s_UDT_Status.Status := "DB_HMIStatusConfiguration".Running;
	    END_IF;
	    
	    IF #iqUDT_EquipmentControl.Report.Stopped
	    THEN
	        #s_UDT_Status.Status := "DB_HMIStatusConfiguration".Stopped;
	    END_IF;
	    
	    IF #s_UDT_Status.Specific.ParcelTooLongError
	        OR #s_UDT_Status.Specific.ParcelTooShortError
	        OR #s_UDT_Status.Specific.ParcelTooHighError
	        OR #s_UDT_Status.Specific.ParcelTooLowError
	        OR #s_UDT_Status.Specific.ParcelTooWideError
	        OR #s_UDT_Status.Specific.ParcelTooNarrowError
	        OR #s_UDT_Status.Specific.IncorrectParcelOrientationError
	        OR #s_UDT_Status.Specific.GeneralError
	        
	    THEN
	        #s_UDT_Status.Status := "DB_HMIStatusConfiguration".DimensionError;
	    END_IF;
	    
	(*    IF #iq_UDT_EquipmentControl.Report.SafetyStop
	    THEN
	        #s_UDT_Status.Status := "DB_HMIStatusConfiguration".SafetyStop;
	    END_IF; *)
	    
	END_REGION
	
	REGION 11 - Update outputs
	    
	    #qUDT_HMIStatus := #s_UDT_Status;
	    #qx_RequestHoldConveyor := (#sx_RequestHold AND NOT #sx_RequestRunReverse) OR #s_UDT_Status.Specific.GeneralError;
	    #qx_RequestRunReverseConveyor := #sx_RequestRunReverse;
	    
	    //Column buzzer
	    #qx_BuzzerColumn := (#sx_ParcelRejecte AND "mx_Clock_1Hz") AND NOT #ix_ReverseRunButton;
	    //Column blue light  
	    #qx_LightColumn := (#sx_ParcelRejecte AND "mx_Clock_1Hz") AND NOT #ix_ReverseRunButton;
	    
	    //Button blue light 
	    //Steady - Reset and restart line
	    //Blink - Restart not possible, sensor dimensioning check is still covered
	    #qx_LightResetButton := (#sx_ParcelRejecte AND "mx_Clock_1Hz") OR (NOT #sx_ParcelRejecte AND #sx_RequestHold);
	    
	    //Data to HMI 
	    //Sensor 1
	    #qUDT_HMIData.ActualSensor1 := #ii_DistanceSensor1;
	    #qUDT_HMIData.OffsetSensor1 := #si_Offset_DistanceSensor1;
	    #qUDT_HMIData.PositionSensor1 := #ii_DistanceSensor1 - #si_Offset_DistanceSensor1;
	    
	    //Sensor 2
	    #qUDT_HMIData.ActualSensor2 := #ii_DistanceSensor2;
	    #qUDT_HMIData.OffsetSensor2 := #si_Offset_DistanceSensor2;
	    #qUDT_HMIData.PositionSensor2 := #ii_DistanceSensor2 - #si_Offset_DistanceSensor2;
	    
	    #qUDT_HMIData.BeltWidth := INT_TO_UINT(#iUDT_DimensionsCheckConfiguration.Position.BeltWidth);
	    
	    
	    IF #s_F_TRIG_WaitForAllScanData.Q THEN
	        IF (#ss_Parcel.Size[0].Width < INT_TO_UINT(#iUDT_DimensionsCheckConfiguration.Position.BeltWidth)) THEN
	            #sui_ProductWidth := #ss_Parcel.Size[0].Width;
	        ELSE
	            #sui_ProductWidth := 0;
	        END_IF;
	        
	        FOR #ti_LoopParcelLength := 0 TO #ci_MeasurementArraySize DO
	            
	            IF (#ss_Parcel.Size[#ti_LoopParcelLength].Width > #sui_ProductWidth) AND (#ss_Parcel.Size[#ti_LoopParcelLength].Width < INT_TO_UINT(#iUDT_DimensionsCheckConfiguration.Position.BeltWidth)) THEN
	                #sui_ProductWidth := #ss_Parcel.Size[#ti_LoopParcelLength].Width;
	            END_IF;
	            
	        END_FOR;
	        
	    END_IF;
	    
	    IF (#sui_ProductWidth > 0)
	        AND (#sui_ProductWidth < #iUDT_DimensionsCheckConfiguration.Position.BeltWidth)
	    THEN
	        
	        #qUDT_HMIData.ProductWidth := #sui_ProductWidth;
	        
	    ELSE
	        
	        #qUDT_HMIData.ProductWidth := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 12 - Deactivation of functionality
	    
	    #s_UDT_Status.Specific.DisabledGeneralFunctionality := #iUDT_DimensionsCheckCommand.DisableGeneral;
	    #s_UDT_Status.Specific.DisabledTooLongParcel := #iUDT_DimensionsCheckConfiguration.Functionality.TooLongParcelError AND #iUDT_DimensionsCheckCommand.DisableTooLongParcelError;
	    #s_UDT_Status.Specific.DisabledTooShortParcelError := #iUDT_DimensionsCheckConfiguration.Functionality.TooShortParcelError AND #iUDT_DimensionsCheckCommand.DisableTooShortParcelError;
	    #s_UDT_Status.Specific.DisabledTooHighParcelError := #iUDT_DimensionsCheckConfiguration.Functionality.TooHighParcelError AND #iUDT_DimensionsCheckCommand.DisableTooHighParcelError;
	    #s_UDT_Status.Specific.DisabledTooLowParcelError := #iUDT_DimensionsCheckConfiguration.Functionality.TooLowParcelError AND #iUDT_DimensionsCheckCommand.DisableTooLowParcelError;
	    #s_UDT_Status.Specific.DisabledTooWideParcelError := #iUDT_DimensionsCheckConfiguration.Functionality.TooWideParcelError AND #iUDT_DimensionsCheckCommand.DisableTooWideParcelError;
	    #s_UDT_Status.Specific.DisabledTooNarrowParcelError := #iUDT_DimensionsCheckConfiguration.Functionality.TooNarrowParcelError AND #iUDT_DimensionsCheckCommand.DisableTooNarrowParcelError;
	    #s_UDT_Status.Specific.DisabledParcelOrientationError := #iUDT_DimensionsCheckConfiguration.Functionality.ParcelOrientationError AND #iUDT_DimensionsCheckCommand.DisableParcelOrientationError;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_PECUpdate"
TITLE = FB_PECUpdate
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 221
// END_ATTRIBUTES
//Function block to update parcel data in a tracking array at PEC position.
   VAR_INPUT 
      iUDT_PECUpdateConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateConfiguration";   //   PEC update configuration
      iUDT_ConveyorCommonConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorCommonConfiguration";   //   Conveyor configuration
      ix_PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when the end of section photoeye is not blocked
      ix_TeachingMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Teaching mode enable
   END_VAR

   VAR_OUTPUT 
      qUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateStatus";   //   Status structure
      qi_GINwrite { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Gin found or generated
      qx_PECFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Filtered photoeye signal
   END_VAR

   VAR_IN_OUT 
      iqUDT_ConveyorInterface : "UDT_ConveyorInterface";   //   Conveyor interface
      iqUDT_UnknownGINRange : "UDT_UnknownGIN";   //   Unknown GIN
      iqUDT_FifoHeader : "UDT_FifoHeader";   //   FIFO header
      iqUDT_Statistics : "UDT_PECUpdateStatistics";   //   Statistic structure
      iqa_TrackingData : Array[*] of Int;   //   Tracking data
      iqa_FifoData : Array[*] of Int;   //   FIFO data
   END_VAR

   VAR 
      sFB_PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   //   Photoeye function
      sFB_LengthMeasurement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ParcelLength";   //   Length measurement
      sUDT_LostGINFIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoStatus";   //   Lost GIN FIFO status
      ss_PECDataDeviation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // PEC/Data deviation calculation structure
         Last { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Last deviation [cm]
         GIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Last GIN deviation
         Sum { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Deviation sum [cm]
         Nr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Deviation number
      END_STRUCT;
      ss_ValidGINRange { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //   Valid GIN range
         Start { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         End { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         GIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      END_STRUCT;
      ss_AlignedParcelsCounters { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //   Aligned parcels counters
         Total { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Total aligned parcels
         DataNoPEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Parcels aligned in case data detected without photoeye signal
         PECNoData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Parcels aligned in case parcel detected without data
      END_STRUCT;
      ss_LostParcelsCounters { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //   Lost parcels counters
         Total { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Total number of lost parcels
         DoubleData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Parcels lost due to double data found in a search window
         ParcelNotFound { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Parcels lost due to no parcel detected after travelling search window distance
      END_STRUCT;
      ss_LostValidParcelsCounters { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //   Lost parcels counters
         Total { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Total number of lost parcels
         DoubleData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Parcels lost due to double data found in a search window
         ParcelNotFound { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Parcels lost due to no parcel detected after travelling search window distance
      END_STRUCT;
      si_UnknownParcelsCounters { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //   Unknown parcels counters
         Total { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Total number of unknown parcels
         LostParcelFound { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Parcel found with a lost data, unknown GIN created
         DataNotFound { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Data not found during search window scan
      END_STRUCT;
      sR_TRIG_Parcel {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Parcel detected rising edge to count parcels
      sR_TRIG_ParcelFound {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Parcel detected rising edge to update the PEC position tracking record
      sR_TRIG_DataFound {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Any data found at a PEC position rising edge
      sR_TRIG_PositiveDataFound {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Positive data found at a PEC position rising edge
      sR_TRIG_TeachMode {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Teaching mode activation rising edge
      sR_TRIG_TooManyLost {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Too many lost parcels error statistics trigger
      slr_Performance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal := 100.0;   //   Update performance [%]
      sdi_TotalNumberOfParcels { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   Total number of parcels detected
      sdi_TotalNumberOfData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   Total number of data detected
      si_PECPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Photoeye position [cm]
      si_SearchWindow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Data search distance from photoeye position [cm]
      si_GINToWrite { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Found or generated GIN, which will be used to update photoeye position in the tracking array
      si_PositionToUpdate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Position in a tracking array to be updated
      si_Direction { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Direction of the displacement to parametrize loops
      si_Displacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Displacement [cm]
      si_ParcelWaitDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Parcel delay [cm]
      si_LastUpdatedGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Last updated GIN to check if next data is a new one
      si_LastCountedData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Last counted data
      si_LostParcelsInARow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Number of lost parcel in a row
      si_NumberOfTeachedParcels { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Number of teached parcels
      si_AverageSlip { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Average parcel slip [cm]
      si_CalculatedLengthCorrection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Calculated length correction after teaching
      si_ParcelLengthFilterCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Parcel length filter counter [cm]
      si_ParcelLengthFilterOldGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Parcel length filter old GIN
      si_LoopCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Loop counter
      sx_ParcelDetected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Parcel detected
      sx_ParcelWaitEnable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Missing parcel monitoring
      sx_TeachingMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Teaching mode
      sx_GenerateGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Request to generate GIN
      sx_LostGINFIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Lost GIN FIFO error
      sx_LostGINFIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Lost GIN FIFO warning
      sx_InvalidDirection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Invalid direction
      sx_InvalidGINRange { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Invalid GIN range
      sx_InvalidDisplacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Invalid displacement
      sx_InvalidSearchWindow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Invalid search window
      sx_DoubleDataFound { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Double data detected
      sx_LengthMeasurementEnable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_TEMP 
      tUDT_PECConfiguration : "UDT_PECConfiguration";   //   PEC configuration
      tUDT_PECStatus : "UDT_PECStatus";   //   PEC status
   END_VAR

   VAR CONSTANT 
      ci_ZeroGIN : Int;   //   GIN = 0
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHSE TIA 15.1
	13/06/2019  | 0.2       | A.Nowak       | Replacement of instruction if for direct write into variable
	21/06/2019  | 0.3       | A.Nowak       | Add gap mesurement function and reorganise block (regions) 
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHSE library release TIA 15.1
	23/08/2019  | 2.1       | L.Klar        | "UDT_ConveyorConfiguration" changed to "UDT_ConveyorCommonConfiguration"
	XX/08/2019  | 2.2       | L.Klar        | Update logic changed
	19/09/2019  | 2.3       | P.Majka       | Updating checking PEC and PEC filtered signals
	30/09/2019  | 2.4       | L.Klar        | FB_PEC added, Filtered PEC signal output added
	21/10/2019  | 2.6       | L.Klar        | Configuration UDT chanaged to input, PEC configuration interface input name changed
	23/10/2019  | 2.7       | P.Majka       | Added Region 1, renumerating Regions, changed logic in Region 10.3 and Region 5
	29/10/2019  | 2.8       | L.Klar        | FB_PEC call changed
	14/11/2019  | 2.9       | L.Klar        | Deviations calculation corrected
	14/11/2019  | 3.0       | P.Majka       | 3.0 MHSE library release TIA 15.1
	20/12/2019  | 3.1       | S.Deulkar     | Used configureation error bit to report to conveyor block     
	07/01/2020  | 3.2       | L.Klar        | GIN record structure updated, GIN cleared with default one during generation
	                                        | PECUpdate configuration UDT update - search window DINT -> INT, 
	                                        | Conveyor common configuration UDT update - length INT -> DINT  conversion added
	29/01/2020  | 3.3       | L.Klar        | Negative GIN handling fixed, configuration bit added to delete negative GIN instead of ignoing it.
	24/02/2020  | 3.4       | L.Klar        | Formating changes, statistics counter added 
	10/03/2020  | 3.5       | F.Baten       | Range check unknown GIN region 7
	26/03/2020  | 3.6       | F.Baten       | Added output 'qi_GINwrite'
	25/11/2020  | 3.7       | L.Klar        | Length filter added
	07/12/2020  | 3.8       | L.Klar        | Length filter bug fix
	22/01/2021  | 3.9       | L.Klar        | Total number of parcels and lost parcels counter fixed
	14/08/2021  | 3.10      | S. Deulkar    | Update from EMA
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	
	REGION 1 – FIFO header status update
	    
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #sUDT_LostGINFIFOStatus,
	              qx_Error => #sx_LostGINFIFOError,
	              qx_Warning => #sx_LostGINFIFOWarning,
	              iqv_Data := #si_GINToWrite,
	              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	              iqv_DataBuffer := #iqa_FifoData);
	    
	END_REGION
	
	REGION 2 – Displacement read
	    
	    #si_Displacement := #iqUDT_ConveyorInterface.Displacement;
	    
	END_REGION
	
	REGION 3 – PEC Position conversion from mm to cm
	    
	    // The conversion is required because the photoeye position is given in mm and the tracking resolution is 1 cm. 
	    #si_PECPosition := DINT_TO_INT(#iUDT_PECUpdateConfiguration.Distance / 10);
	    
	END_REGION
	
	REGION 4 – Teaching mode enable
	    
	    (* Teaching mode is used to calculate conveyor length correction, which allows to align real conveyor length with a tracking array length.
	       Correction is calculated as a difference between photoeye signal and tracking data deviations.
	       Calculated correction has to be manually copied from a FB_PECUpdate instance data block to conveyor configuration.*)
	    
	    // Teaching mode is initialized and activated manually via block input.
	    #sR_TRIG_TeachMode(CLK := #ix_TeachingMode);
	    
	    IF (#sR_TRIG_TeachMode.Q
	        AND NOT #sx_TeachingMode)
	    THEN
	        #ss_PECDataDeviation.Nr := 0;
	        #ss_PECDataDeviation.Sum := 0;
	        #si_NumberOfTeachedParcels := 0;
	        #sx_TeachingMode := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 5 – Photoeye
	    
	    (*FB_PEC block call to filter photoeye signal and calculate jam status.*)
	    
	    // Copy PEC configuration.
	    #tUDT_PECConfiguration.Distance := #iUDT_PECUpdateConfiguration.Distance;
	    #tUDT_PECConfiguration.JamDisplacementLimit := #iUDT_PECUpdateConfiguration.JamDisplacementLimit;
	    #tUDT_PECConfiguration.TimeOnDelay := #iUDT_PECUpdateConfiguration.TimeOnDelay;
	    #tUDT_PECConfiguration.TimeOffDelay := #iUDT_PECUpdateConfiguration.TimeOffDelay;
	    #tUDT_PECConfiguration.ResetWithPECBlocked := #iUDT_PECUpdateConfiguration.ResetWithPECBlocked;
	    
	    //Call FB_PEC.
	    #sFB_PEC(ix_PEC := #ix_PEC,
	             iUDT_PECConfiguration := #tUDT_PECConfiguration,
	             qUDT_HMIStatus => #tUDT_PECStatus,
	             iqUDT_ConveyorInterface := #iqUDT_ConveyorInterface,
	             iqUDT_PECStatistics := #iqUDT_Statistics.PEC);
	    
	    // Parcel length filter
	    IF NOT #ix_PEC
	        AND #iUDT_PECUpdateConfiguration.ParcelLengthFilter
	        AND #iqa_TrackingData[#si_PECPosition - 1] > 0
	        AND #iqa_TrackingData[#si_PECPosition - 1] <> #si_ParcelLengthFilterOldGIN THEN
	        
	        IF "DB_GIN".GIN[#iqa_TrackingData[#si_PECPosition - 1]].General.Length > 0 THEN
	            #si_ParcelLengthFilterCounter := "DB_GIN".GIN[#iqa_TrackingData[#si_PECPosition - 1]].General.Length;
	        END_IF;
	        
	        #si_ParcelLengthFilterOldGIN := #iqa_TrackingData[#si_PECPosition - 1];
	        
	    END_IF;
	    
	    IF #si_ParcelLengthFilterCounter > 0 THEN
	        
	        #qUDT_Status.PEC := FALSE;
	        #qx_PECFiltered := FALSE;
	        #si_ParcelLengthFilterCounter -= #iqUDT_ConveyorInterface.Displacement;
	        
	    ELSE
	        
	        #qUDT_Status.PEC := #sFB_PEC.qx_PECFiltered;
	        #qx_PECFiltered := #sFB_PEC.qx_PECFiltered;
	        
	    END_IF;
	    
	    #qUDT_Status.Jam := #tUDT_PECStatus.Jam;
	    
	    // Parcel detected variable to simplify further photoeye position tracking record update.
	    #sx_ParcelDetected := NOT #qUDT_Status.PEC;
	    
	END_REGION
	
	REGION 6 – Error reset
	    
	    // Reset errors when reset signal is given.
	    IF (#iqUDT_ConveyorInterface.InternalErrorReset)
	    THEN
	        #si_LostParcelsInARow := 0;
	        #qUDT_Status.TooManyLost := FALSE;
	        #sx_InvalidDisplacement := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 7 – GIN generator initialization
	    
	    // Valid GIN range configuration is moved to a structure.
	    #ss_ValidGINRange.Start := #iUDT_PECUpdateConfiguration.GINRangeStart;
	    #ss_ValidGINRange.End := #iUDT_PECUpdateConfiguration.GINRangeEnd;
	    
	    // Check if the unknown GIN is within range
	    IF #iqUDT_UnknownGINRange.GIN < #iqUDT_UnknownGINRange.Start
	        OR #iqUDT_UnknownGINRange.GIN > #iqUDT_UnknownGINRange.End
	    THEN
	        #iqUDT_UnknownGINRange.GIN := #iqUDT_UnknownGINRange.Start;
	    END_IF;
	    
	    // Whenever valid GIN range is changed and the generated GIN doesn't fit, it's initialized.
	    IF (#ss_ValidGINRange.GIN < #ss_ValidGINRange.Start
	        OR #ss_ValidGINRange.GIN > #ss_ValidGINRange.End)
	    THEN
	        #ss_ValidGINRange.GIN := #ss_ValidGINRange.Start;
	    END_IF;
	    
	    // Valid GIN range is set locally in PEC update configuration structure and it can't overlap with a global unknown GIN range.
	    #sx_InvalidGINRange := #iUDT_PECUpdateConfiguration.GenerationPoint
	    AND (#ss_ValidGINRange.End <= #ss_ValidGINRange.Start
	    OR #ss_ValidGINRange.Start <= #iqUDT_UnknownGINRange.End
	    OR #iqUDT_UnknownGINRange.End <= #iqUDT_UnknownGINRange.Start)
	    AND #ss_ValidGINRange.Start < 1000;   // Until 1000 it is UFO range
	    
	END_REGION
	
	REGION 8 – Search window and displacement validation
	    
	    (*Both parameters have to be checked to prevent tracking array exceeding.*)
	    
	    // Search window cannot be lower than zero and greater than distance between PEC position and conveyor edge.
	    #sx_InvalidSearchWindow := #iUDT_PECUpdateConfiguration.SearchWindowFwd < 0
	    OR #iUDT_PECUpdateConfiguration.SearchWindowFwd >= #iUDT_ConveyorCommonConfiguration.Length + #iUDT_ConveyorCommonConfiguration.LengthCorrection - #si_PECPosition
	    OR #iUDT_PECUpdateConfiguration.SearchWindowRvs < 0
	    OR #iUDT_PECUpdateConfiguration.SearchWindowRvs >= #si_PECPosition;
	    
	    // Displacement cannot be greater than the photoeye position.
	    IF (ABS(#si_Displacement) > #si_PECPosition)
	    THEN
	        #sx_InvalidDisplacement := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 9 – Total number of parcels counter
	    
	    (*Parcels are counted basing on parcel detection rising edge trigger. Counting is blocked
	      during PLC first scan, when photoeye signal becomes 0.*)
	    
	    #sR_TRIG_Parcel(CLK := #sx_ParcelDetected);
	    
	    IF (#sR_TRIG_Parcel.Q
	        AND NOT "DB_Memory".FirstScan)
	    THEN
	        // Total number of parcels.
	        #sdi_TotalNumberOfParcels += 1;
	        
	        // Every detected parcel resets lost parcels in a row counter.
	        #si_LostParcelsInARow := 0;
	        
	        // Number of teached parcels is incremented if teaching mode is activated.
	        IF (#sx_TeachingMode)
	        THEN
	            #si_NumberOfTeachedParcels += 1;
	        END_IF;
	    END_IF;
	    
	END_REGION
	
	REGION 10 – PEC Update
	    (* Photoeye position record is updated after every tracking register shift, basing on
	       actual situation - photoeye signal and data availability. In case of displacement
	       graeter than one, the loop will be executed the proper number of times. The update loop
	       can be executed if there is no configuration errors and the displacement was given.*)
	    
	    WHILE #si_Displacement <> 0
	        AND NOT #sx_InvalidGINRange
	        AND NOT #sx_InvalidDisplacement
	        AND NOT #sx_InvalidSearchWindow
	    DO
	        
	        REGION 10.1 – Direction
	            
	            (*Depending on displacement sign, the direction of movement is determinated. This allows to choose 
	            ` correct search window and parametrize all search loops to count up or down.*)
	            
	            IF (#si_Displacement < 0)
	            THEN
	                #si_Direction := -1;
	                #si_SearchWindow := #iUDT_PECUpdateConfiguration.SearchWindowRvs;
	            ELSIF (#si_Displacement > 0)
	            THEN
	                #si_Direction := 1;
	                #si_SearchWindow := #iUDT_PECUpdateConfiguration.SearchWindowFwd;
	            END_IF;
	            
	        END_REGION
	        
	        REGION 10.2 – Position to update
	            
	            // Position pointer used to specify the tracking array record to be updated.
	            #si_PositionToUpdate := #si_PECPosition - #si_Displacement + #si_Direction;
	            
	        END_REGION
	        
	        
	        REGION 10.3 – Total number of data counter
	            
	            (*Total number of data is incremented every time when new GIN is detected.*)
	            
	            IF (#iqa_TrackingData[#si_PositionToUpdate + 1] > 0
	                AND #iqa_TrackingData[#si_PositionToUpdate + 1] <> #si_LastCountedData)
	            THEN
	                #sdi_TotalNumberOfData += 1;
	                #si_LastCountedData := #iqa_TrackingData[#si_PositionToUpdate + 1];
	            END_IF;
	            
	        END_REGION
	        
	        REGION 10.4 – GIN detection
	            
	            (* Data found and parcel found triggers are used to determine the update case,
	               whether the data occurred first or a parcel.*)
	            
	            // Trigger on any data found at a PEC position to detect the front of the parcel data. 
	            #sR_TRIG_DataFound(CLK := #iqa_TrackingData[#si_PositionToUpdate] <> 0);
	            
	            // Trigger on positive data found at a PEC position to detect the front of the parcel data.   
	            #sR_TRIG_PositiveDataFound(CLK := #iqa_TrackingData[#si_PositionToUpdate] > 0);
	            
	            // Trigger to detect front of the parcel.
	            #sR_TRIG_ParcelFound(CLK := #sx_ParcelDetected);
	            
	(*
	Data detected without PEC signal
	
	                         Search window
	                          <--------|
	Data                              PEC
	|----------------------------------|------------------------------------------|
	|                           XXXXXXXX                                          |
	|----------------------------------|------------------------------------------|
	                                   |
	Conveyor                           |
	|----------------------------------|------------------------------------------|
	|                      YYYYYYYY    |                                          | 
	|                      YYYYYYYY    |                                          |
	|                      YYYYYYYY    |                                          |
	|----------------------------------|------------------------------------------|
	*)
	(* Data detected without PEC signal.*)
	            IF (#sR_TRIG_PositiveDataFound.Q
	                AND NOT #sx_ParcelDetected)
	            THEN
	                #si_GINToWrite := 0;
	                // Double data detection loop.
	                FOR #si_LoopCounter := #si_PositionToUpdate TO
	                    #si_PECPosition + (#si_SearchWindow * #si_Direction) BY #si_Direction DO
	                    // Data found in a search window.
	                    IF (#iqa_TrackingData[#si_LoopCounter] > 0)
	                    THEN
	                        // First GIN found.
	                        IF (#si_GINToWrite = 0)
	                        THEN
	                            // Get the GIN if it's different than last updated GIN.
	                            IF #iqa_TrackingData[#si_LoopCounter] <> #si_LastUpdatedGIN THEN
	                                #si_GINToWrite := #iqa_TrackingData[#si_LoopCounter];
	                            END_IF;
	                            // If the first GIN was found, the scan loop conitues to check if there is no other data.
	                        ELSE
	                            // Next found data is different than the first one. Double data detected.
	                            IF (#iqa_TrackingData[#si_LoopCounter] <> #si_GINToWrite)
	                            THEN
	                                #sx_DoubleDataFound := TRUE;
	                                // First found GIN is marked as a lost one and the GIN is stored in a FIFO register.
	                                IF ("DB_GIN".GIN[#si_GINToWrite].General.Lost = FALSE)
	                                THEN
	                                    "DB_GIN".GIN[#si_GINToWrite].General.Lost := TRUE;
	                                    
	                                    "FC_Fifo"(ic_Mode := 'W',
	                                              qUDT_Status => #sUDT_LostGINFIFOStatus,
	                                              qx_Error => #sx_LostGINFIFOError,
	                                              qx_Warning => #sx_LostGINFIFOWarning,
	                                              iqv_Data := #si_GINToWrite,
	                                              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                                              iqv_DataBuffer := #iqa_FifoData);
	                                    
	                                    // Update statistics
	                                    #ss_LostParcelsCounters.Total += 1;
	                                    #ss_LostParcelsCounters.DoubleData += 1;
	                                    
	                                    
	                                    ////////////////////
	                                    
	                                    IF #si_GINToWrite >= 1000 THEN
	                                        #ss_LostValidParcelsCounters.Total += 1;
	                                        #ss_LostValidParcelsCounters.DoubleData += 1;
	                                    END_IF;
	                                    
	                                    ////////////////
	                                END_IF;
	                                
	                                // Second found GIN is marked as a lost one and the GIN is stored in a FIFO register.
	                                IF ("DB_GIN".GIN[#iqa_TrackingData[#si_LoopCounter]].General.Lost = FALSE)
	                                THEN
	                                    "DB_GIN".GIN[#iqa_TrackingData[#si_LoopCounter]].General.Lost := TRUE;
	                                    
	                                    "FC_Fifo"(ic_Mode := 'W',
	                                              qUDT_Status => #sUDT_LostGINFIFOStatus,
	                                              qx_Error => #sx_LostGINFIFOError,
	                                              qx_Warning => #sx_LostGINFIFOWarning,
	                                              iqv_Data := #iqa_TrackingData[#si_LoopCounter],
	                                              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                                              iqv_DataBuffer := #iqa_FifoData);
	                                    
	                                    // Update statistics
	                                    #ss_LostParcelsCounters.Total += 1;
	                                    #ss_LostParcelsCounters.DoubleData += 1;
	                                    
	                                    ////////////////////
	                                    
	                                    IF #iqa_TrackingData[#si_LoopCounter] >= 1000 THEN
	                                        #ss_LostValidParcelsCounters.Total += 1;
	                                        #ss_LostValidParcelsCounters.DoubleData += 1;
	                                    END_IF;
	                                    
	                                    ////////////////
	                                    //
	                                END_IF;
	                                // Stop search window scan in case of double data detection
	                                EXIT;
	                            END_IF;
	                        END_IF;
	                    END_IF;
	                END_FOR;
	                
	                // Becasue the data was found as a first one, GIN is stored and the logic to wait for a parcel is enebaled.
	                // If the double data was found there is no need to wait for a parcel. Data has been marked as a lost one.
	                IF NOT #sx_DoubleDataFound
	                THEN
	                    #sx_ParcelWaitEnable := TRUE;
	                END_IF;
	                
	                #sx_DoubleDataFound := FALSE;
	(*
	Data and PEC signal detected at the same time - perfect match
	
	                         Search window
	                          <--------|
	Data                              PEC
	|----------------------------------|------------------------------------------|
	|                           XXXXXXXX                                          |
	|----------------------------------|------------------------------------------|
	                                   |
	Conveyor                           |
	|----------------------------------|------------------------------------------|
	|                           XXXXXXXX                                          | 
	|                           XXXXXXXX                                          |
	|                           XXXXXXXX                                          |
	|----------------------------------|------------------------------------------|
	
	or PEC signal found without data or with old ones
	
	                         Search window
	                          <--------|
	Data                              PEC
	|----------------------------------|------------------------------------------|
	|                    XXXXXXXX      |                                          |
	|----------------------------------|------------------------------------------|
	                                   |
	Conveyor                           |
	|----------------------------------|------------------------------------------|
	|                           XXXXXXXX                                          | 
	|                           XXXXXXXX                                          |
	|                           XXXXXXXX                                          |
	|----------------------------------|------------------------------------------|
	*)
	(*Data and PEC signal detected at the same time (perfect match) or PEC signal found without data or with old ones.*)
	            ELSIF (#sR_TRIG_ParcelFound.Q
	                AND (#sR_TRIG_PositiveDataFound.Q
	                OR (#iqa_TrackingData[#si_PositionToUpdate] = 0
	                OR #iqa_TrackingData[#si_PositionToUpdate] = #si_LastUpdatedGIN)
	                AND NOT #sx_ParcelWaitEnable))
	            THEN
	                // If the PEC is set as a GIN generation point, skip data detection loop and go to GIN generator.
	                IF (#iUDT_PECUpdateConfiguration.GenerationPoint)
	                THEN
	                    #sx_GenerateGIN := TRUE;
	                    // If the the PEC isn't a generation point, data search loop is enabled.
	                ELSE
	                    #si_GINToWrite := 0;
	                    
	                    // Double data detection loop.
	                    FOR #si_LoopCounter := #si_PositionToUpdate TO
	                        #si_PECPosition + (#si_SearchWindow * #si_Direction) BY #si_Direction DO
	                        
	                        // Data found in a search window.
	                        IF (#iqa_TrackingData[#si_LoopCounter] > 0)
	                        THEN
	                            // First GIN found.
	                            IF (#si_GINToWrite = 0)
	                            THEN
	                                // Get the GIN if it's different than last updated GIN.
	                                IF #iqa_TrackingData[#si_LoopCounter] <> #si_LastUpdatedGIN THEN
	                                    #si_GINToWrite := #iqa_TrackingData[#si_LoopCounter];
	                                    
	                                    // PEC/Data deviation acquisition
	                                    #ss_PECDataDeviation.Last := DINT_TO_INT(#si_PECPosition - #si_LoopCounter);
	                                    #ss_PECDataDeviation.GIN := #si_GINToWrite;
	                                    #ss_PECDataDeviation.Sum -= ABS(#ss_PECDataDeviation.Last);
	                                    #ss_PECDataDeviation.Nr += 1;
	                                    
	                                    // Parcel aligned statistics
	                                    IF (ABS(#ss_PECDataDeviation.Last) > ABS(#si_Displacement - 1))
	                                    THEN
	                                        #ss_AlignedParcelsCounters.Total += 1;
	                                        #ss_AlignedParcelsCounters.PECNoData += 1;
	                                    END_IF;
	                                END_IF;
	                                // If the first GIN was found, the scan loop conitues to check if there is no other data.
	                            ELSE
	                                // Next found data is different than the first one. Double data detected.
	                                IF (#iqa_TrackingData[#si_LoopCounter] <> #si_GINToWrite)
	                                THEN
	                                    // First found GIN is marked as a lost one and the GIN is stored in a FIFO register.
	                                    IF ("DB_GIN".GIN[#si_GINToWrite].General.Lost = FALSE)
	                                    THEN
	                                        "DB_GIN".GIN[#si_GINToWrite].General.Lost := TRUE;
	                                        "FC_Fifo"(ic_Mode := 'W',
	                                                  qUDT_Status => #sUDT_LostGINFIFOStatus,
	                                                  qx_Error => #sx_LostGINFIFOError,
	                                                  qx_Warning => #sx_LostGINFIFOWarning,
	                                                  iqv_Data := #si_GINToWrite,
	                                                  iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                                                  iqv_DataBuffer := #iqa_FifoData);
	                                        
	                                        // Update statistics
	                                        #ss_LostParcelsCounters.Total += 1;
	                                        #ss_LostParcelsCounters.DoubleData += 1;
	                                        
	                                        ////////////////////
	                                        
	                                        IF #si_GINToWrite >= 1000 THEN
	                                            #ss_LostValidParcelsCounters.Total += 1;
	                                            #ss_LostValidParcelsCounters.DoubleData += 1;
	                                        END_IF;
	                                        
	                                        ////////////////
	                                        //
	                                    END_IF;
	                                    
	                                    // Second found GIN is marked as a lost one and the GIN is stored in a FIFO register.
	                                    IF ("DB_GIN".GIN[#iqa_TrackingData[#si_LoopCounter]].General.Lost = FALSE)
	                                    THEN
	                                        "DB_GIN".GIN[#iqa_TrackingData[#si_LoopCounter]].General.Lost := TRUE;
	                                        "FC_Fifo"(ic_Mode := 'W',
	                                                  qUDT_Status => #sUDT_LostGINFIFOStatus,
	                                                  qx_Error => #sx_LostGINFIFOError,
	                                                  qx_Warning => #sx_LostGINFIFOWarning,
	                                                  iqv_Data := #iqa_TrackingData[#si_LoopCounter],
	                                                  iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                                                  iqv_DataBuffer := #iqa_FifoData);
	                                        
	                                        // Update statistics
	                                        #ss_LostParcelsCounters.Total += 1;
	                                        #ss_LostParcelsCounters.DoubleData += 1;
	                                        
	                                        ////////////////////
	                                        
	                                        IF #iqa_TrackingData[#si_LoopCounter] >= 1000 THEN
	                                            #ss_LostValidParcelsCounters.Total += 1;
	                                            #ss_LostValidParcelsCounters.DoubleData += 1;
	                                        END_IF;
	                                        
	                                        ////////////////
	                                        //
	                                    END_IF;
	                                    // Stop search window scan in case of double data detection
	                                    EXIT;
	                                END_IF;
	                            END_IF;
	                        END_IF;
	                    END_FOR;
	                    
	                    // GIN not found in a search window
	                    IF (#si_GINToWrite = 0)
	                    THEN
	                        #sx_GenerateGIN := TRUE;
	                        #si_UnknownParcelsCounters.DataNotFound += 1;
	                    END_IF;
	                    
	                    // Found GIN is a lost one - generate unknown GIN
	                    // Found GIN isn't lost or it's negative - don't do anything
	                    IF (#si_GINToWrite > 0)
	                    THEN
	                        IF ("DB_GIN".GIN[#si_GINToWrite].General.Lost)
	                        THEN
	                            #sx_GenerateGIN := TRUE;
	                            #si_UnknownParcelsCounters.LostParcelFound += 1;
	                        END_IF;
	                    END_IF;
	                END_IF;
	                
	                (*Second parcel has been found during data update. Situation can occur when search window is too short
	                  and the data is shifted. In that case found GIN will be marked as a lost one and new unknown GIN will be 
	                  generated. Negative GIN will be ignored.*)
	            ELSIF (#sR_TRIG_ParcelFound.Q
	                AND (#iqa_TrackingData[#si_PositionToUpdate] <> 0
	                AND #iqa_TrackingData[#si_PositionToUpdate] <> #si_LastUpdatedGIN)
	                AND NOT #sx_ParcelWaitEnable)
	            THEN
	                IF (#iqa_TrackingData[#si_PositionToUpdate] > 0)
	                THEN
	                    IF ("DB_GIN".GIN[#iqa_TrackingData[#si_PositionToUpdate]].General.Lost = FALSE)
	                    THEN
	                        "DB_GIN".GIN[#iqa_TrackingData[#si_PositionToUpdate]].General.Lost := TRUE;
	                        "FC_Fifo"(ic_Mode := 'W',
	                                  qUDT_Status => #sUDT_LostGINFIFOStatus,
	                                  qx_Error => #sx_LostGINFIFOError,
	                                  qx_Warning => #sx_LostGINFIFOWarning,
	                                  iqv_Data := #iqa_TrackingData[#si_PositionToUpdate],
	                                  iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                                  iqv_DataBuffer := #iqa_FifoData);
	                        
	                        // Update statistics
	                        #ss_LostParcelsCounters.Total += 1;
	                        #ss_LostParcelsCounters.DoubleData += 1;
	                        
	                        ////////////////////
	                        
	                        IF #iqa_TrackingData[#si_PositionToUpdate] >= 1000 THEN
	                            #ss_LostValidParcelsCounters.Total += 1;
	                            #ss_LostValidParcelsCounters.DoubleData += 1;
	                        END_IF;
	                        
	                        ////////////////
	                        //
	                    END_IF;
	                END_IF;
	                
	                // Generate GIN 
	                #sx_GenerateGIN := TRUE;
	                #si_UnknownParcelsCounters.LostParcelFound += 1;
	                
	                (*Second data has been found during data update. Situation can occur when search window is too short
	                  and the data is shifted. In that case found GIN will be marked as a lost one.*)
	            ELSIF (#sR_TRIG_PositiveDataFound.Q
	                AND #sx_ParcelDetected
	                AND #iqa_TrackingData[#si_PositionToUpdate] <> #si_GINToWrite)
	            THEN
	                // Mark GIN as a lost one
	                IF ("DB_GIN".GIN[#iqa_TrackingData[#si_PositionToUpdate]].General.Lost = FALSE)
	                THEN
	                    "DB_GIN".GIN[#iqa_TrackingData[#si_PositionToUpdate]].General.Lost := TRUE;
	                    "FC_Fifo"(ic_Mode := 'W',
	                              qUDT_Status => #sUDT_LostGINFIFOStatus,
	                              qx_Error => #sx_LostGINFIFOError,
	                              qx_Warning => #sx_LostGINFIFOWarning,
	                              iqv_Data := #iqa_TrackingData[#si_PositionToUpdate],
	                              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                              iqv_DataBuffer := #iqa_FifoData);
	                    
	                    // Update statistics
	                    #ss_LostParcelsCounters.Total += 1;
	                    #ss_LostParcelsCounters.DoubleData += 1;
	                    
	                    ////////////////////
	                    
	                    IF #iqa_TrackingData[#si_PositionToUpdate] >= 1000 THEN
	                        #ss_LostValidParcelsCounters.Total += 1;
	                        #ss_LostValidParcelsCounters.DoubleData += 1;
	                    END_IF;
	                    
	                    ////////////////
	                END_IF;
	            END_IF;
	            
	        END_REGION
	        
	        REGION 10.5 – GIN generator
	            
	            (*Used to generate new GIN. If the PEC position is a generation point, the number is taken from an internal GIN range.
	              If it's not, then GIN is taken from a global unknown GIN range.*)
	            
	            IF (#sx_GenerateGIN)
	            THEN
	                // Generation point.
	                IF (#iUDT_PECUpdateConfiguration.GenerationPoint)
	                THEN
	                    // Generate GIN from a valid GIN range.
	                    IF (#ss_ValidGINRange.GIN <= #ss_ValidGINRange.End)
	                    THEN
	                        #si_GINToWrite := #ss_ValidGINRange.GIN;
	                        #ss_ValidGINRange.GIN += 1;
	                    ELSE
	                        #si_GINToWrite := #ss_ValidGINRange.Start;
	                        #ss_ValidGINRange.GIN := #ss_ValidGINRange.Start + 1;
	                    END_IF;
	                    // Unknown GIN generator.
	                ELSE
	                    // Generate GIN from a unknown GIN range.
	                    IF (#iqUDT_UnknownGINRange.GIN <= #iqUDT_UnknownGINRange.End)
	                    THEN
	                        #si_GINToWrite := #iqUDT_UnknownGINRange.GIN;
	                        #iqUDT_UnknownGINRange.GIN += 1;
	                    ELSE
	                        #si_GINToWrite := #iqUDT_UnknownGINRange.Start;
	                        #iqUDT_UnknownGINRange.GIN := #iqUDT_UnknownGINRange.Start + 1;
	                    END_IF;
	                    
	                    // Unknwn parcels statistics.
	                    #si_UnknownParcelsCounters.Total += 1;
	                END_IF;
	                
	                // Reset generte GIN command.
	                #sx_GenerateGIN := FALSE;
	                
	                // GIN record is cleared with configured default GIN record while it's generated.
	                "DB_GIN".GIN[#si_GINToWrite] := "DB_GINDefault".GIN[#iUDT_PECUpdateConfiguration.DefaultGIN];
	            END_IF;
	            
	            #qi_GINwrite := #si_GINToWrite;
	            
	        END_REGION
	        
	        
	        REGION 10.6 – PEC position data update
	            
	            (*While parcel is detected, calculated GIN is written into the PEC position record.
	              If not, then the record is cleared with 0. Negative GIN is ignored or deleted, depending on configuration.*)
	            
	            IF (#sx_ParcelDetected)
	            THEN
	                
	                "FC_WriteGIN"(ii_GIN := #si_GINToWrite,
	                              ii_PositionToWrite := #si_PositionToUpdate,
	                              ii_NumberOfPositions := 1,
	                              ix_Direction := TRUE,
	                              iqa_TrackingData := #iqa_TrackingData);
	                
	            ELSE
	                IF (#iqa_TrackingData[#si_PositionToUpdate] > 0
	                    OR #iUDT_PECUpdateConfiguration.NegativeGINDelete)
	                THEN
	                    
	                    "FC_WriteGIN"(ii_GIN := #ci_ZeroGIN,
	                                  ii_PositionToWrite := #si_PositionToUpdate,
	                                  ii_NumberOfPositions := 1,
	                                  ix_Direction := TRUE,
	                                  iqa_TrackingData := #iqa_TrackingData);
	                    
	                END_IF;
	            END_IF;
	            
	        END_REGION
	        
	        REGION 10.7 – Parcel waiting logic
	            
	            (*Parcel waiting logic is used to wait for the photoeye signal for a search window distance.*)
	            IF (#sx_ParcelWaitEnable)
	            THEN
	                // Counting parcel wait distance depending on conveyor running direction if not detected.
	                IF (NOT #sx_ParcelDetected)
	                THEN
	                    IF (#si_Direction = 1)
	                    THEN
	                        #si_ParcelWaitDistance += 1;
	                    ELSE
	                        #si_ParcelWaitDistance -= 1;
	                    END_IF;
	                    
	                    // Parcel detected - stop waiting, use found GIN to update.   
	                ELSE
	                    // PEC/Data deviation acquisition
	                    #ss_PECDataDeviation.Last := #si_ParcelWaitDistance;
	                    #ss_PECDataDeviation.GIN := #si_GINToWrite;
	                    #ss_PECDataDeviation.Sum += ABS(#ss_PECDataDeviation.Last);
	                    #ss_PECDataDeviation.Nr += 1;
	                    
	                    
	                    // Parcel aligned statistics
	                    IF (#ss_PECDataDeviation.Last > ABS(#si_Displacement - 1))
	                    THEN
	                        #ss_AlignedParcelsCounters.Total += 1;
	                        #ss_AlignedParcelsCounters.DataNoPEC += 1;
	                    END_IF;
	                    
	                    // Parcel waiting logic reset.
	                    #sx_ParcelWaitEnable := FALSE;
	                    #si_ParcelWaitDistance := 0;
	                END_IF;
	            END_IF;
	            
	            // Parcel not found in a search window - stop waiting, mark found GIN as a lost one.
	            IF (ABS(#si_ParcelWaitDistance) = #si_SearchWindow)
	                AND (#si_GINToWrite > 0)
	            THEN
	                // Parcel lost
	                IF "DB_GIN".GIN[#si_GINToWrite].General.Lost = FALSE THEN
	                    "DB_GIN".GIN[#si_GINToWrite].General.Lost := TRUE;
	                    "FC_Fifo"(ic_Mode := 'W',
	                              qUDT_Status => #sUDT_LostGINFIFOStatus,
	                              qx_Error => #sx_LostGINFIFOError,
	                              qx_Warning => #sx_LostGINFIFOWarning,
	                              iqv_Data := #si_GINToWrite,
	                              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                              iqv_DataBuffer := #iqa_FifoData);
	                    
	                    // Parcel waiting logic reset.
	                    #si_ParcelWaitDistance := 0;
	                    #sx_ParcelWaitEnable := FALSE;
	                    
	                    // Lost parcels ina  row counter.
	                    #si_LostParcelsInARow += 1;
	                    
	                    // Update statistics.
	                    #ss_LostParcelsCounters.Total += 1;
	                    #ss_LostParcelsCounters.ParcelNotFound += 1;
	                    
	                    ////////////////////
	                    
	                    IF #si_GINToWrite >= 1000 THEN
	                        #ss_LostValidParcelsCounters.Total += 1;
	                        #ss_LostValidParcelsCounters.ParcelNotFound += 1;
	                    END_IF;
	                    
	                    ////////////////
	                    //
	                END_IF;
	                
	            END_IF;
	            
	            // Reset monitoring in case of going backwards.
	            IF (#si_ParcelWaitDistance = 0
	                AND NOT #sx_ParcelDetected
	                AND #sx_InvalidDirection)
	            THEN
	                #sx_ParcelWaitEnable := FALSE;
	            END_IF;
	            
	            #sx_InvalidDirection := ((#si_Direction = 1
	            AND #si_ParcelWaitDistance < 0)
	            OR (#si_Direction = -1
	            AND #si_ParcelWaitDistance > 0));
	            
	        END_REGION
	        
	        REGION 10.8 – Last updated GIN
	            
	            (*Last updated GIN to avoid processing the same data.*)
	            IF (#sR_TRIG_DataFound.Q)
	            THEN
	                #si_LastUpdatedGIN := #iqa_TrackingData[#si_PositionToUpdate];
	            END_IF;
	            
	        END_REGION
	        
	        REGION 10.8 – Update displacement
	            
	            #si_Displacement := #si_Displacement - #si_Direction;
	            
	        END_REGION
	        
	    END_WHILE;
	    
	END_REGION
	
	REGION 11 – Length measurement
	    
	    
	    
	    (*Length and gap measurements can be enabled via PEC update configuration*)
	    #sFB_LengthMeasurement(ii_PECPosition := #si_PECPosition,
	                           ii_Displacement := #iqUDT_ConveyorInterface.Displacement,
	                           ix_LengthMeasurementEnable := #iUDT_PECUpdateConfiguration.ParcelLengthMeasurement OR #sx_LengthMeasurementEnable,
	                           ix_GapMeasurementEnable := #iUDT_PECUpdateConfiguration.GapLengthMeasurement,
	                           iqa_TrackingData := #iqa_TrackingData);
	    
	    IF #iqa_TrackingData[#si_PECPosition] > 0
	        AND #iqa_TrackingData[#si_PECPosition] >= #iqUDT_UnknownGINRange.Start
	        AND #iqa_TrackingData[#si_PECPosition] <= #iqUDT_UnknownGINRange.End
	    THEN
	        
	        #sx_LengthMeasurementEnable := "DB_GIN".GIN[#iqa_TrackingData[#si_PECPosition]].General.Length = 0;
	    ELSE
	        
	        #sx_LengthMeasurementEnable := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 12 – Teaching done 
	    
	    // Average slip calculation
	    #si_AverageSlip := #ss_PECDataDeviation.Sum / #ss_PECDataDeviation.Nr;
	    #si_CalculatedLengthCorrection := DINT_TO_INT(#iUDT_ConveyorCommonConfiguration.LengthCorrection) + #si_AverageSlip * 10;
	    IF (#sx_TeachingMode                                                                                                            // Teaching mode enabled 
	        AND #si_NumberOfTeachedParcels = #iUDT_PECUpdateConfiguration.NrOfTeachParcels)                                                 // Number of teaching parcels equal to the preset one                                                                                                                                                              // Teaching mode enabled ("sx_TeachMode") 
	    THEN
	        
	        #si_CalculatedLengthCorrection := DINT_TO_INT(#iUDT_ConveyorCommonConfiguration.LengthCorrection) + #si_AverageSlip * 10;
	        #sx_TeachingMode := FALSE;
	        #si_NumberOfTeachedParcels := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 13 – Performance    
	    
	    (*Performnce is a percentage ratio between number of lost parcels and total number of data, used to monitor data update efficiency.*)
	    
	    IF (#sdi_TotalNumberOfData >= #ss_LostParcelsCounters.Total
	        AND #sdi_TotalNumberOfData > 0)
	    THEN
	        #slr_Performance := 100.0 - INT_TO_LREAL(#ss_LostParcelsCounters.Total) / #sdi_TotalNumberOfData * 100.0;
	    END_IF;
	    
	    // Warning is generated if performance drops below 80%.
	    #qUDT_Status.LowPerformance := #slr_Performance < 80;
	    
	END_REGION
	
	REGION 14 – Reset statistics
	    
	    // Statistics are reset if reset signal is given.
	    IF #iqUDT_ConveyorInterface.ResetStatistics
	    THEN
	        #sdi_TotalNumberOfParcels := 0;
	        #ss_AlignedParcelsCounters.Total := 0;
	        #ss_AlignedParcelsCounters.PECNoData := 0;
	        #ss_AlignedParcelsCounters.DataNoPEC := 0;
	        #ss_LostParcelsCounters.Total := 0;
	        #ss_LostParcelsCounters.DoubleData := 0;
	        #ss_LostParcelsCounters.ParcelNotFound := 0;
	        #ss_LostValidParcelsCounters.Total := 0;
	        #ss_LostValidParcelsCounters.DoubleData := 0;
	        #ss_LostValidParcelsCounters.ParcelNotFound := 0;
	        #sdi_TotalNumberOfData := 0;
	        #si_UnknownParcelsCounters.Total := 0;
	        #si_UnknownParcelsCounters.LostParcelFound := 0;
	        #si_UnknownParcelsCounters.DataNotFound := 0;
	        #ss_PECDataDeviation.Sum := 0;
	        #ss_PECDataDeviation.Nr := 0;
	        #slr_Performance := 100;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 15 – Too many lost parcels error
	    
	    (*Error is generated if too many parcels will is marked as a lost one in a row*)
	    IF (#si_LostParcelsInARow >= #iUDT_PECUpdateConfiguration.MaxLost)
	    THEN
	        #qUDT_Status.TooManyLost := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 16 – Statistics
	    
	    // Too many lost
	    #sR_TRIG_TooManyLost(CLK := #qUDT_Status.TooManyLost);
	    IF #qUDT_Status.TooManyLost
	        OR #iqUDT_ConveyorInterface.ResetStatistics
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #qUDT_Status.TooManyLost,
	                        ix_RTrigActivate := #sR_TRIG_TooManyLost.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.TooManyLost);
	    END_IF;
	    
	    // Total number of parcels
	    #iqUDT_Statistics.TotalNrOfParcels := #sdi_TotalNumberOfParcels;
	    
	END_REGION
	
	REGION 17 – Internal tracking warning and error
	    
	    // Internal tracking warning
	    IF (#qUDT_Status.LowPerformance
	        OR #sx_LostGINFIFOWarning)
	    THEN
	        #iqUDT_ConveyorInterface.InternalWarningTracking := TRUE;
	    END_IF;
	    
	    // Internal tracking error
	    IF #qUDT_Status.TooManyLost
	    THEN
	        #iqUDT_ConveyorInterface.InternalErrorTracking := TRUE;
	    END_IF;
	    
	    // Configuration error
	    IF (#sx_InvalidDisplacement
	        OR #sx_InvalidGINRange
	        OR #sx_InvalidSearchWindow)
	    THEN
	        #iqUDT_ConveyorInterface.ConfigurationError := TRUE;
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_PECBulk"
TITLE = FB_PEC
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : Conveyor
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 220
// END_ATTRIBUTES
   VAR_INPUT 
      ix_PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Signal of the PEC
      ix_PECDownstream { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Downstream PEC signal
      ix_DownstreamRunning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Downstream conveyor is running
      iUDT_PECConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECConfiguration";   //   PEC configuration structure
   END_VAR

   VAR_OUTPUT 
      qx_PECFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   PEC Filtered
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";   //   Status structure
   END_VAR

   VAR_IN_OUT 
      iqUDT_ConveyorInterface : "UDT_ConveyorInterface";   //   Interface structure
      iqUDT_PECStatistics : "UDT_PECStatistics";   //   Statistics structure
   END_VAR

   VAR 
      s_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatus";   //   Status structure
      s_StatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatus";   //   Auxiliary status structure
      PEC_TimerOnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //   Filtering end of section photo eye signal
      sR_TRIG_PECJam {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge trigger PEC jam
   END_VAR
   VAR RETAIN
      si_AuxJamDisplacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Auxiliary variable to calculate displacement when PEC is blocked
   END_VAR
   VAR 
      sx_Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Enable
      sx_PECFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Photo eye filtered
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	16/03/2020  | 3.0       | K.Pokorski    | 3.0 MHS library release TIA 15.1
	20/03/2020  | 3.1       | S.Theocharis  | Changed check to upsteam and jam condition
	24/03/2020  | 3.2       | S.Theocharis  | Add input ix Changed ix_UpstreamRunning
	30/03/2020  | 3.3       | K.Pokorski    | Changed error reset condition
	02/04/2020  | 3.4       | S.Theocharis  | Changed check to downsteam
	11/07/2022  | 3.5       | G.Vlooswijk   | Removed #ix_PECDownstream as jam reset condition
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	12/03/2024  | 4.1       | S. Nieswiec   | Small variable name changes according to current standard 
	*)
	
	REGION 1 - Triggers
	    
	    // Rising edge PEC Jam.
	    #sR_TRIG_PECJam(CLK := #s_Status.Jam);
	    
	END_REGION
	
	REGION 2 - Active function  
	    
	    // To activate the Jam monitoring, the jam displacement limit must be greater than zero. 
	    #sx_Enable := #iUDT_PECConfiguration.JamDisplacementLimit > 0;
	    
	END_REGION
	
	REGION 3 - Reset errors
	    
	    // Reset Jam error and initialize Jam displacement counter, when reset signal occurs.
	    IF #iqUDT_ConveyorInterface.InternalErrorReset
	        AND (#iUDT_PECConfiguration.ResetWithPECBlocked
	        OR (NOT #iUDT_PECConfiguration.ResetWithPECBlocked
	        AND #sx_PECFiltered))
	        AND #s_Status.Jam
	    THEN
	        #si_AuxJamDisplacement := 0;
	        #s_Status.Jam := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Photo eye filters
	    
	    // End of section photo eye signal filter timer.
	    #PEC_TimerOnOffDelay(iudi_OnDelayTime := #iUDT_PECConfiguration.TimeOnDelay,
	                         iudi_OffDelayTime := #iUDT_PECConfiguration.TimeOffDelay,
	                         ix_SignalToDelay := #ix_PEC,
	                         ix_Enable := TRUE,
	                         qx_DelayedSignal => #sx_PECFiltered);
	    
	    // Write the current status of the photo eye.
	    #s_Status.PEC := #sx_PECFiltered;
	    #qx_PECFiltered := #sx_PECFiltered;
	    
	END_REGION
	
	REGION 5 - Jam detection   
	    
	    // Increasing Jam displacement counter by conveyor displacement, when photo eyes on conveyor and downstream conveyor are blocked and jam functionality is enable.
	    IF #ix_PECDownstream AND (NOT #sx_PECFiltered) AND #sx_Enable AND #ix_DownstreamRunning
	        
	    THEN
	        #si_AuxJamDisplacement += #iqUDT_ConveyorInterface.Displacement;
	    ELSE
	        #si_AuxJamDisplacement := 0;
	    END_IF;
	    
	    // Set jam error when total jam displacement exceeded limit.
	    IF (#si_AuxJamDisplacement > #iUDT_PECConfiguration.JamDisplacementLimit)
	        OR (#si_AuxJamDisplacement < (#iUDT_PECConfiguration.JamDisplacementLimit * -1))
	    THEN
	        #s_Status.Jam := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Statistics
	    
	    // Jam Photo eye blocked statistics.
	    IF #s_Status.Jam
	        OR #iqUDT_ConveyorInterface.ResetStatistics
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #s_Status.Jam,
	                        ix_RTrigActivate := #sR_TRIG_PECJam.Q,
	                        iqUDT_Statistics := #iqUDT_PECStatistics.Jam);
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Internal PEC error
	    
	    // Set Internal photo eye error .
	    IF #s_Status.Jam
	    THEN
	        #iqUDT_ConveyorInterface.InternalErrorPEC := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 8 - Status
	    
	    // Status update on change.
	    IF #s_StatusOld <> #s_Status
	    THEN
	        #qUDT_HMIStatus := #s_Status;
	        #s_StatusOld := #s_Status;
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_EuchnerLock"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 210
// END_ATTRIBUTES
   VAR_INPUT 
      ix_ButtonReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset button
      ix_ButtonRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request open button
      ix_DoorClosed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Feedback from lock - door is closed
      ix_BoltTongueClosed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Feedback from lock - bolt tongue closed
      ix_SafelyLoced { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Feedback from lock - Safely locked
      ix_LockFault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Lock has an internal fault
      ix_SystemStopped { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Feedback from system - System is stopped
      ix_SafetyLockOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Safety lock status OK
      ix_SafetyLockAckReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Safety lock need acknowledgement
   END_VAR

   VAR_OUTPUT 
      qx_StopSystem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Signal to stop the system
      qx_ResetButtonLed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset button lamp
      qx_RequestButtonLed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request button lamp
      qx_FaultReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset internal lock fault
      qx_ReleaseLock { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Signal to safety logic to release lock
      qUDT_Status : "UDT_EuchnerLockStatus";   // Status structure
   END_VAR

   VAR 
      sFB_OpenRequestDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Function block to generate on signal delay - emergency request button
      sFB_ResetDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sR_TRIG_RequestButton {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger from reqest button
      sx_Request { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request to open the door
      sx_EmergencyReqest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Emergency request to open the door
   END_VAR

   VAR CONSTANT 
      c_Time : UDInt := 10000;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	11/03/2022  | 0.1       | S.Nikodem     | first release MHS TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Request open
	    
	    //Button
	    //Rising edge trigger 
	    #sR_TRIG_RequestButton(CLK := #ix_ButtonRequest);
	    
	    // Flip-flop
	    IF #sR_TRIG_RequestButton.Q THEN
	        
	        IF #sx_Request THEN
	            
	            #sx_Request := FALSE;
	            #sx_EmergencyReqest := FALSE;
	            
	        ELSE
	            
	            #sx_Request := TRUE;
	            
	        END_IF;
	        
	    END_IF;
	    
	    // Reset Flip-Flop
	    IF NOT #ix_BoltTongueClosed THEN
	        
	        #sx_Request := FALSE;
	        #sx_EmergencyReqest := FALSE;
	        
	    END_IF;
	    
	    //Emergency open reqest
	    #sFB_OpenRequestDelay(iudi_OnDelayTime := #c_Time,
	                          iudi_OffDelayTime := 0,
	                          ix_SignalToDelay := #ix_ButtonRequest,
	                          ix_Enable := True);
	    
	    
	    IF #sFB_OpenRequestDelay.qx_DelayedSignal THEN
	        
	        #sx_EmergencyReqest := True;
	        
	    END_IF;
	    
	    //Stop system
	    #qx_StopSystem := #sx_Request OR #sx_EmergencyReqest;
	    
	    //If system is stopped and is safe then open lock
	    #qx_ReleaseLock := (#sx_Request AND #ix_SystemStopped) OR #sx_EmergencyReqest;
	    
	END_REGION
	
	REGION 2 - Lamp controlling 
	    
	    // Reset button LED - Blue
	    // Lamp active - Safety is open
	    // Lamp flashing - Euchner lock has a fault or safety lock must be acknowledged and bolt is inside.
	    
	    #qx_ResetButtonLed := (NOT #ix_SafetyLockOK AND NOT #ix_SafetyLockAckReq) OR ("mx_Clock_1Hz" AND (#ix_SafetyLockAckReq OR #ix_LockFault));
	    
	    // Request button LED - White
	    // Lamp active - Request to open the lock is active Aand lock is opened and bolt is inside.
	    // Lamp flashing - Request to open is active, the area is not safe and the lock is closed.
	    
	    #qx_RequestButtonLed := #sx_Request AND ((NOT #ix_SafelyLoced AND #ix_BoltTongueClosed) OR "mx_Clock_1Hz");
	    
	END_REGION
	
	REGION 3 - Falut reset
	    
	    #sFB_ResetDelay(iudi_OnDelayTime := 0,
	                    iudi_OffDelayTime := 3500,
	                    ix_SignalToDelay := (#ix_LockFault) AND (#ix_ButtonReset));
	    
	    
	    // Set reset signal
	    #qx_FaultReset := #sFB_ResetDelay.qx_DelayedSignal;
	    
	END_REGION
	
	REGION 4 - Status
	    
	    // Copy status
	    #qUDT_Status.LockFault := #ix_LockFault;
	    #qUDT_Status.DoorClosed := #ix_DoorClosed;
	    #qUDT_Status.DoorOpened := NOT #ix_DoorClosed;
	    #qUDT_Status.BoltTongueClosed := #ix_BoltTongueClosed;
	    #qUDT_Status.Safelylocked := #ix_SafelyLoced;
	    #qUDT_Status.SafetyLockAckReq := #ix_SafetyLockAckReq;
	    
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MergeCapacity"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 218
// END_ATTRIBUTES
   VAR_INPUT 
      ix_PEC_Merge { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      iUDT_FlowConfig { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FlowConfiguration" := ([6(1.0)], (), (), (), (), ());
      ix_XBSInductAvailable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_OUTPUT 
      qr_FlowCountMerge { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";
   END_VAR

   VAR 
      s_R_TRIG_ParcelDetect_Merge {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge of PEC signal
      ss_CountingRegMerge { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..50] of Real;   //  Counting registers parcels
      s_FB_Pulse_TimerEndMergePeriod { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Pulse";
      sr_FlowMerge { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;
   END_VAR

   VAR_TEMP 
      tx_EndMergePeriod : Bool;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2022             MHS                                                     |
	|  All Rights Reserved         Larenweg 90                                             |
	|                              5234 KC 's-Hertogenbosch,                               |
	|                              Netherlands                                             |
	|                                                                                      |
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	20/04/2022  | 3.0       | M.Roijen     | first release MHS TIA 15.1
	13/03/2024  | 4.1       | S.Nieswiec   | first release MHS TIA 18
	
	*)
	
	REGION 1 - Obtain capacity of Merge
	    
	    // Rising edge PEC signal
	    #s_R_TRIG_ParcelDetect_Merge(CLK := #ix_PEC_Merge);
	    
	    // Increase first counting register when new parcel detect
	    // 
	    IF (#s_R_TRIG_ParcelDetect_Merge.Q)
	    THEN
	        #ss_CountingRegMerge[1] += 1;
	    END_IF;
	    
	    
	    #s_FB_Pulse_TimerEndMergePeriod(iudi_PulseTime := #iUDT_FlowConfig.PeriodMergeCapacity * 1000,
	                                    qx_Pulse => #tx_EndMergePeriod);
	    
	    //Save capacity at the end of the period to array
	    
	    IF (#tx_EndMergePeriod)
	    THEN
	        
	        #sr_FlowMerge := (#ss_CountingRegMerge[1] / UDINT_TO_REAL(#iUDT_FlowConfig.PeriodMergeCapacity) * 3600);
	        
	        IF NOT #ix_XBSInductAvailable THEN
	            #sr_FlowMerge := 0;
	        END_IF;
	        
	        // Shifted counting register by one element down  
	        MOVE_BLK(IN := #ss_CountingRegMerge[1],
	                 COUNT := 49,
	                 OUT => #ss_CountingRegMerge[2]);
	        
	        // Reset first register
	        #ss_CountingRegMerge[1] := 0;
	        
	    END_IF;
	    
	    
	    
	END_REGION
	
	
	REGION 2 - Flow count reset
	    
	    IF #iqUDT_EquipmentControl.Command.ResetData
	        
	    THEN
	        FILL_BLK(IN := 0,
	                 COUNT := 50,
	                 OUT => #ss_CountingRegMerge[1]);
	        #sr_FlowMerge := 0;
	    END_IF;
	    
	    
	    
	END_REGION
	
	
	REGION 3 - Write outputs   
	    
	    #qr_FlowCountMerge := #sr_FlowMerge;
	    
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_FlowSplitter"
TITLE = Flow Splitter
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : CLeite
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 211
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_FlowSplitterConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FlowSplitterConfiguration";   //  Flow splitter configuration structure
      iui_ExternalSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  External speed [mm/s]
      ix_AirPressureOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Air pressure circuit healthy
      ix_SafetyOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when safety is ok
      ix_24vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when 24VDC is healthy
      ix_400vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when 400VAC is healthy
      ix_Connected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when the Isolator is electrically closed
      ix_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when  hardware is Ok
      ix_DebrisSensor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Signal from debris sensor
      ix_PECEos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  End of section photo eye
      ix_PECUpstream { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Upstream end of section photo eye
      ix_PECDivertChute { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  PEC of the divert chute
      ix_FlowSplitterEncoderError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  True if there is an error with the flow splitter encoder
      ix_ExternalRequestHold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  External request hold
      ix_HMICommunicationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  HMI Communication Error
      ix_ResetEnergySave { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Reset save energy mode timer
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FlowSplitterStatus";   //  HMI status structure
      qUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   //  Common status structure
      qx_Zone1Divert { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Activation of the divert in zone divert side
      qx_Zone2Divert { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Activation of the divert in zone straight side
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   //  Equipment control structure
      iqUDT_FlowSplitterCommand : "UDT_FlowSplitterCommand";   //  Flow splitter command structure
      iqUDT_FlowSplitterInterface : "UDT_ConveyorInterface";   //  Interface structure
      iqUDT_HandShakeUp : "UDT_ConveyorHandshake";   //  Handshake upstream structure
      iqUDT_HandShakeStraight : "UDT_ConveyorHandshake";   //  Handshake downstream straight structure
      iqUDT_HandShakeDivert : "UDT_ConveyorHandshake";   //  Handshake downstream divert structure
      iqUDT_Statistics : "UDT_FlowSplitterStatistics";   //  Statistics structure
   END_VAR

   VAR 
      sUDT_CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //  Common status structure
      sUDT_CommonStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //  Auxiliary status structure
      sUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FlowSplitterStatus";   //  HMI status structure
      sFB_DebrisTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //  Filtering debris photo eye signal
      sFB_CascadeModeTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //  Timer to cascade start
      PEC_TimerOnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //  Timer to filter EOS PEC signal
      PEC_ChuteTimerOnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //  Timer to filter chute PEC signal
      PEC_UpstreamTimerOnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //  Timer to filter upstream PEC signal
      sFB_DivertsActivationTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //  Timer to delay divert activation
      sR_TRIG_ManualMode {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger manual mode
      sF_TRIG_ManualMode {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //  Falling edge trigger manual mode
      sR_TRIG_PECJam {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger PEC jam
      sR_TRIG_PECDivertChuteJam {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger PEC divert chute jam
      sR_TRIG_RunManual {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge run conveyor in manual mode
      sF_TRIG_RunManual {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //  Falling edge run conveyor in manual mode
      sR_TRIG_Jog {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger manual jog
      sF_TRIG_Jog {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //  Falling edge trigger manual mode jog
      sR_TRIG_FlowSplitterUpTime {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger flow splitter up time
      sR_TRIG_FlowSplitterDownTime {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger flow splitter down
      sR_TRIG_AirPressureError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger air pressure error
      sR_TRIG_DebrisDetected {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge debris detected
      sR_TRIG_EnconderError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge enconder error
      sR_TRIG_Mode1 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge Mode 1 active
      sR_TRIG_Mode2 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge Mode 2 active
      sR_TRIG_Mode3 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge Mode 3 active
      sR_TRIG_Mode4 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge Mode 4 active
      sR_TRIG_Mode5 {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge Mode 5 active
      sR_TRIG_EnergySave {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger save energy mode active
   END_VAR
   VAR RETAIN
      si_AuxJamDisplacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Auxiliary jam displacement
      si_AuxJamDivertChuteDisplacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Divert chute displcement
      si_Mode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Mode
      si_SwitchDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Switch delay time
      si_Mode4AuxTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Auxiliary variable to count time
      si_Mode4DivertTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Auxiliary variable divert time
   END_VAR
   VAR 
      si_AuxEnergySave { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Auxinalary energy save
      sx_DebrisSignalFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Debris detected
      sx_Ready { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Flow splitter ready to operate in Automatic mode
   END_VAR
   VAR RETAIN
      sx_ManualModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Manual mode active
      sx_StartReceived { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Save start trigger from the system
      sx_AutomaticActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Automatic active
   END_VAR
   VAR 
      sx_PEC_EoSFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  End of section photo eye filtered
      sx_PEC_ChuteFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Divert chute eye filtered
      sx_PEC_UpstreamFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Upstream PEC filtered signal
   END_VAR
   VAR RETAIN
      sx_PreStartManual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Pre conditions to run conveyor in manual mode
      sx_Switch1To3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Auxiliary bit when switch from mode 1 to 3
      sx_Switch3To1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Auxiliary bit when switch from mode 3 to 1
      sx_Zone1_Divert { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Static variable to active divert zone 1
      sx_Zone2_Divert { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Static variable to active divert zone 2
      sx_EnableDiverts { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  When is true the diverts activation is enable
   END_VAR
   VAR 
      sx_EnergySaveActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Active energy save mode
   END_VAR

   VAR_TEMP 
      tx_AuxBaseTimeDivert1 : Bool;   //  Temp variable to activate diverts zone 1
      tx_AuxBaseTimeDivert2 : Bool;   //  Temp variable to activate diverts zone 2
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	//2019      | 1.0       | C.Leite       | first release TIA 15.1
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	28/08/2019  | 2.1       | S.Deulkar     | modified fault logic, mode logic, reset logic
	                                        | And deleted sub region
	03/10/2019  | 2.2       | S.Deulkar     | Added comments       
	03/10/2019  | 2.3       | S.Deulkar     | Updated UDT interface
	10/10/2019  | 2.4       | S. Deulkar    | Modified coulor status logic
	10/10/2019  | 2.5       | S. Deulkar    | Reverse logic is removed
	04/11/2019  | 2.6       | L.Klar        | 1 second pulse and frost scan changed from memory bit to DB variable
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	20/12/2019  | 3.1       | S. Deulkar    | Added configuration error in make ready status
	11/01/2021  | 3.2       | L.Klar        | Input safety ok added to stop conveyor condition
	12/01/2021  | 3.3       | K. Pokorski   | Reset HMI commands of manual mode when conveyor no ready. Manual mode active to interface.
	12/01/2021  | 3.4       | S. Nikodem    | Added energy save mode
	04/02/2021  | 3.5       | K. Pokorski   | Status update fix
	17/02/2021  | 3.6       | K. Pokorski   | Internal error PEC handling
	02/03/2021  | 3.7       | K. Pokorski   | Halted status only if automatic on
	15/03/2021  | 3.8       | K. Pokorski   | Energy save corrected
	16/03/2021  | 3.9       | K. Pokorski   | On fly change mode corrected
	19/03/2021  | 3.10      | K.Pokorski    | Energy save pec eos changed
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Initial
	    
	    // First PLC cycle
	    IF "DB_Memory".FirstScan
	    THEN
	        #sx_AutomaticActive := FALSE;                            // Automatic active
	        #iqUDT_HandShakeUp.RTR := False;                        // Reset RTR signal 
	        #iqUDT_HandShakeUp.CascadeStartUp := FALSE;             // Reset cascade start signal
	        #iqUDT_FlowSplitterInterface.RunFwd := FALSE;           // Order to run forward to VFD
	        #iqUDT_FlowSplitterInterface.RunRvs := FALSE;           // Order to run reverse to VFD
	        
	    END_IF;
	    
	    // Mode selection
	    #si_Mode := #iqUDT_FlowSplitterCommand.Mode;                                   // Select mode from HMI inputs
	    
	    IF (#si_Mode < 1) OR (#si_Mode > 5) OR #ix_HMICommunicationError THEN           // If there is no mode delected from HMI or HMI communication error is active 
	        #si_Mode := #iUDT_FlowSplitterConfiguration.DefaultMode;                   // Select default mode from configuration
	    END_IF;
	    
	    // Triggers
	    #sR_TRIG_ManualMode(CLK := #iqUDT_FlowSplitterCommand.ManualMode                // Rising edge trigger manual mode
	                        OR #iqUDT_EquipmentControl.Command.ManualMode);
	    
	    #sF_TRIG_ManualMode(CLK := #iqUDT_FlowSplitterCommand.ManualMode                // Falling edge trigger manual mode
	                        OR #iqUDT_EquipmentControl.Command.ManualMode);
	    
	    #sR_TRIG_Jog(CLK := #iqUDT_FlowSplitterCommand.ManualJog);                      // Rising edge trigger manual mode jog
	    
	    #sF_TRIG_Jog(CLK := #iqUDT_FlowSplitterCommand.ManualJog);                      // Falling edge trigger manual mode jog
	    
	    #sR_TRIG_RunManual(CLK := #iqUDT_FlowSplitterCommand.ManualStartStop);          // Rising edge trigger to start in manual mode
	    
	    #sF_TRIG_RunManual(CLK := #iqUDT_FlowSplitterCommand.ManualStartStop);          // Falling edge trigger run in manual mode
	    
	    #sR_TRIG_FlowSplitterUpTime(CLK := #sx_AutomaticActive AND #sx_Ready);           // Rising edge conveyor up
	    
	    #sR_TRIG_PECJam(CLK := #sUDT_HMIStatus.Specific.PEC_EoSJam);                           // Rising edge PE Jam
	    
	    #sR_TRIG_PECDivertChuteJam(CLK := #sUDT_HMIStatus.Specific.PEC_DivertChuteJam);        // Rising edge PE Jam
	    
	    #sR_TRIG_FlowSplitterDownTime(CLK := #sx_AutomaticActive AND NOT #sx_Ready);     // Rising edge conveyor conveyor down
	    
	    #sR_TRIG_AirPressureError(CLK := NOT #ix_AirPressureOk);                         // Rising edge air pressure error
	    
	    #sR_TRIG_DebrisDetected(CLK := #ix_DebrisSensor);                                // Rising edge debris detection
	    
	    #sR_TRIG_EnconderError(CLK := #ix_FlowSplitterEncoderError);                    // Rising edge encoder error
	    
	    #sR_TRIG_Mode1(CLK := (#si_Mode = 1));                                          // Rising edge Mode 1
	    
	    #sR_TRIG_Mode2(CLK := (#si_Mode = 2));                                          // Rising edge Mode 2
	    
	    #sR_TRIG_Mode3(CLK := (#si_Mode = 3));                                          // Rising edge Mode 3
	    
	    #sR_TRIG_Mode4(CLK := (#si_Mode = 4));                                          // Rising edge Mode 4
	    
	    #sR_TRIG_Mode5(CLK := (#si_Mode = 5));                                          // Rising edge Mode 5
	    
	    #sR_TRIG_EnergySave(CLK := #sUDT_CommonStatus.EnergySave);                     // Rising edge trigger Energy save mode.
	    
	    // Timers
	    
	    #PEC_TimerOnOffDelay(iudi_OnDelayTime := #iUDT_FlowSplitterConfiguration.PEC_EoSTimeOnDelay,                       // Off delay time to filter PEC signal
	                         iudi_OffDelayTime := #iUDT_FlowSplitterConfiguration.PEC_EoSTimeOffDelay,                     // On delay time to filter PEC signal
	                         ix_SignalToDelay := #ix_PECEos,                                                               // PEC input signal
	                         ix_Enable := #iUDT_FlowSplitterConfiguration.PEC_Present,                                     // PEC present bit is true if the flow splitter is equiped with PEC 
	                         qx_DelayedSignal => #sx_PEC_EoSFiltered);                                                      // PEC signal filtered
	    
	    #PEC_ChuteTimerOnOffDelay(iudi_OnDelayTime := #iUDT_FlowSplitterConfiguration.PEC_FilterChuteTimeOnDelay,          // Off delay time to filter chute PEC signal
	                              iudi_OffDelayTime := #iUDT_FlowSplitterConfiguration.PEC_FilterChuteTimeOffDelay,        // On delay time to filter chute PEC signal
	                              ix_SignalToDelay := #ix_PECDivertChute,                                                  // PEC chute signal
	                              ix_Enable := TRUE,                                                                        // Enable function
	                              qx_DelayedSignal => #sx_PEC_ChuteFiltered);                                               // PEC chute siganl filtered
	    
	    #PEC_UpstreamTimerOnOffDelay(iudi_OnDelayTime := #iUDT_FlowSplitterConfiguration.PEC_FilterUpstreamTimeOnDelay,    // On delay time to filter upstream PEC
	                                 iudi_OffDelayTime := #iUDT_FlowSplitterConfiguration.PEC_FilterUpstreamTimeOffDelay,  // Off delay time to filter upstream PEC
	                                 ix_SignalToDelay := #ix_PECUpstream,                                                  // Signal to filter upstream PEC
	                                 ix_Enable := TRUE,                                                                     // Function enable
	                                 qx_DelayedSignal => #sx_PEC_UpstreamFiltered);                                         // Upstream PEC signal filtered
	    
	    #sFB_DivertsActivationTimer(iudi_OnDelayTime := 0,
	                                iudi_OffDelayTime := #iUDT_FlowSplitterConfiguration.DivertsTimeActivation,                // Off delay to pop-up diverts
	                                ix_SignalToDelay := NOT #sx_PEC_UpstreamFiltered,                                           // Upstream signal filtered,
	                                ix_Enable := TRUE,
	                                qx_DelayedSignal => #sx_EnableDiverts);                                                     // Enabling diverts pop-up
	    
	END_REGION
	
	REGION 2 - Reset faults
	    
	    // Send reset request TO interface UDT
	    #iqUDT_FlowSplitterInterface.InternalErrorReset := #iqUDT_EquipmentControl.Command.Reset;
	    #iqUDT_FlowSplitterInterface.ResetStatistics := #iqUDT_EquipmentControl.Command.ResetData;
	    
	    // Reset errors
	    // Reset PEC Jam if PEC is clear and reset command is received.
	    IF #iqUDT_EquipmentControl.Command.Reset THEN                      // Reset bit from control block
	        
	        IF #ix_PECEos = TRUE THEN
	            #sUDT_HMIStatus.Specific.PEC_EoSJam := FALSE;                     // PEC jam reset
	        END_IF;
	        
	        IF #ix_DebrisSensor = TRUE THEN
	            #sUDT_HMIStatus.Specific.Debris := FALSE;                         // Debris fault reset
	        END_IF;
	        
	        IF #ix_PECDivertChute = TRUE THEN
	            #sUDT_HMIStatus.Specific.PEC_DivertChuteJam := FALSE;             // Divert chute jam reset
	        END_IF;
	        
	        IF #ix_AirPressureOk = TRUE THEN
	            #sUDT_HMIStatus.Specific.AirPressure := FALSE;                    // Air pressure error reset
	        END_IF;
	        
	        IF #ix_FlowSplitterEncoderError = FALSE THEN
	            #sUDT_HMIStatus.Specific.EncoderError := FALSE;                   // Encoder error reset
	        END_IF;
	        
	    END_IF;
	    
	    // Error
	    #sUDT_CommonStatus.Error := NOT #ix_SafetyOk                               // safety error status
	    OR #sUDT_HMIStatus.Specific.EncoderError                                   // Enconder error status
	    OR #sUDT_HMIStatus.Specific.PEC_EoSJam                                     // PEC blockage error status
	    OR #sUDT_HMIStatus.Specific.PEC_DivertChuteJam                             // PEC divert chute blockage error status
	    OR #sUDT_HMIStatus.Specific.Debris                                         // Debris detected error status
	    OR #sUDT_HMIStatus.Specific.DivertsActivationError                         // Diverts position error status
	    OR #iqUDT_FlowSplitterInterface.InternalErrorVFD                           // Internal VFD error status
	    OR NOT #ix_Connected                                                        // Isolator switch error status
	    OR #iqUDT_FlowSplitterInterface.InternalErrorPEC;                          // External PEC fault
	    // Warning
	    #sUDT_CommonStatus.Warning := #sUDT_HMIStatus.Specific.AirPressure;       // Air pressure status;                         
	    
	    // Ready
	    #sx_Ready := NOT #sUDT_CommonStatus.Error                                  // Ready bit is set true when common error status its false
	    AND #ix_24vOk                                                               // 24V is okay 
	    AND #ix_400vOk                                                              // 400V is okay
	    AND NOT #iqUDT_FlowSplitterInterface.ConfigurationError;                   // not configuration error
	    
	END_REGION
	
	REGION 3 - Stop conveyor
	    
	    // Conditions to stop conveyor
	    IF ((#sF_TRIG_RunManual.Q OR #sF_TRIG_Jog.Q) AND #sx_ManualModeActive)                        // If in manula mode and Rising or falling edge for jog occur
	        OR (NOT #iqUDT_EquipmentControl.Command.AutomaticOn AND NOT #sx_ManualModeActive)      // or Not automatic ON and Not in manual mode
	        OR (NOT #sx_Ready AND NOT #sx_ManualModeActive)                                         // Or not ready and not in automatic mode
	        OR (#sR_TRIG_ManualMode.Q OR #sF_TRIG_ManualMode.Q)                                       // or Rising edge or falling edge of manual mode active command occur
	        OR NOT #ix_SafetyOk                                                                     // or safety not ok    
	        
	    THEN
	        //  Order to stop VFD
	        #iqUDT_FlowSplitterInterface.RunFwd := FALSE;                  // Reset order to VFD run in forward direction
	        #iqUDT_FlowSplitterInterface.RunRvs := FALSE;                  // Reset order to VFD run in reverse direction
	        #iqUDT_HandShakeUp.RTR := FALSE;                               // Reset the bit ready to receive
	        #iqUDT_HandShakeUp.CascadeStartUp := FALSE;                    // Reset cascade start up bit
	        
	        #sx_AutomaticActive := FALSE;                                   // Automatic mode is disable
	        #sx_StartReceived := FALSE;                                     // Clear start receive bit 
	        
	        #sx_Zone1_Divert := FALSE;                                      // Reset diverts from zone 1
	        #sx_Zone2_Divert := FALSE;                                      // Reset diverts from zone 2
	        
	        #sx_Switch1To3 := FALSE;                                        // Reset switch from mode 1 to mode 3 auxiliary bit
	        #sx_Switch3To1 := FALSE;                                        // Reset switch from mode 3 to mode 1 auxiliary bit
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Start   
	    // Save Start bit request
	    IF NOT #sx_ManualModeActive                                         // If Manual mode iis not active
	        AND #sx_Ready                                                   // and Flow splitter is ready
	        AND #iqUDT_EquipmentControl.Command.Start                      // Start command from control block received
	        AND #iqUDT_EquipmentControl.Command.AutomaticOn                // Automatic on signal from control block is active
	    THEN                                                                // then
	        #sx_StartReceived := TRUE;                                      // Set start received bit
	    END_IF;
	    
	    // Cascade mode
	    
	    CASE #si_Mode OF
	        1:  // Statement section case 1 (Flow splitter in straight direction)
	            IF #sx_StartReceived                                                 // If Start received memory bit is active
	                AND (#iqUDT_HandShakeStraight.CascadeStartUp                    // And Cascade start bit from downstream straight conveyor handshake is active
	                OR #iUDT_FlowSplitterConfiguration.FirstConveyorToStart)        // Or flow splitter conveyor is the first conveyor to start
	            THEN                                                                 // then
	                #sx_AutomaticActive := TRUE;                                     // Automatic active is set true
	                #sx_StartReceived := FALSE;                                      // and reset start received memory bit
	            END_IF;
	            ;
	        3:  // Statement section case 3 (Flow splitter in divert direction)
	            IF #sx_StartReceived                                                 // If Start received memory bit is active
	                AND (#iqUDT_HandShakeDivert.CascadeStartUp                      // And Cascade start bit from downstream divert conveyor handshake is avtive
	                OR #iUDT_FlowSplitterConfiguration.FirstConveyorToStart)        // Or flow splitter conveyor is the first conveyor to start
	            THEN                                                                 // Then
	                #sx_AutomaticActive := TRUE;                                     //  Automatic active is set true
	                #sx_StartReceived := FALSE;                                      //and reset start received memory bit
	            END_IF;
	            ;
	        ELSE  // Statement section ELSE
	            IF #sx_StartReceived                                                 // If Start received memory bit is activ
	                AND (#iqUDT_HandShakeStraight.CascadeStartUp                    // And Cascade start bit from downstream straight conveyor handshake is active
	                AND #iqUDT_HandShakeDivert.CascadeStartUp                       // And Cascade start bit from downstream divert conveyor handshake is active
	                OR #iUDT_FlowSplitterConfiguration.FirstConveyorToStart)        // Or flow splitter conveyor is the first conveyor to start
	            THEN                                                                 // Then
	                #sx_AutomaticActive := TRUE;                                     // Automatic active is set true
	                #sx_StartReceived := FALSE;                                      // and reset start received memory bit
	            END_IF;
	            ;
	    END_CASE;
	    
	    //Timer to cascade mode
	    
	    #sFB_CascadeModeTimer(iudi_OnDelayTime := #iUDT_FlowSplitterConfiguration.CascadeTimeOnDelay,      // Cascade mode timer
	                          ix_SignalToDelay := #sx_AutomaticActive,                                      // Signal to activate the timer
	                          ix_Enable := #sx_Ready,                                                       // Bit ready to enable cascade mode
	                          qx_DelayedSignal => #iqUDT_HandShakeUp.CascadeStartUp);                      // Cascade mode signal to upstream
	    
	END_REGION
	
	REGION 5 - Manual mode
	    
	    // Manual mode activation 
	    #sx_ManualModeActive := #iqUDT_FlowSplitterCommand.ManualMode                                  // Manual mode is active if the bits that activate manual mode is active from hmi or from control block  
	    OR #iqUDT_EquipmentControl.Command.ManualMode;
	    
	    //Send manual mode active to PEC/VFD blocks to supress errors
	    #iqUDT_FlowSplitterInterface.ManualModeActive := #sx_ManualModeActive;
	    
	    //When the system is not any more in manual mode or when fatal error occurs the HMI commands should be reset
	    
	    IF NOT #ix_SafetyOk
	        OR NOT #ix_24vOk                                                        // 24V error status
	        OR NOT #ix_400vOk                                                       // 400V error status
	        OR NOT #ix_HardwareOk                                                   // Profinet error status
	        OR #iqUDT_FlowSplitterInterface.ConfigurationError                          // No configuration err
	        OR #iqUDT_FlowSplitterInterface.InternalErrorVFD
	        OR #iqUDT_FlowSplitterInterface.Disconnected
	        OR NOT #sx_ManualModeActive
	    THEN
	        #iqUDT_FlowSplitterCommand.ManualStartStop := FALSE;
	        #iqUDT_FlowSplitterCommand.ManualFullSpeed := FALSE;
	        #iqUDT_FlowSplitterCommand.ManualJog := FALSE;
	    END_IF;
	    
	    // Manual mode force disable
	    IF #iqUDT_EquipmentControl.Command.DisableManualMode THEN
	        #iqUDT_FlowSplitterCommand.ManualMode := False;
	        #iqUDT_FlowSplitterCommand.ManualFullSpeed := False;
	        #iqUDT_FlowSplitterCommand.ManualJog := False;
	        #iqUDT_FlowSplitterCommand.ManualStartStop := False;
	    END_IF;
	    
	    // Start/Stop in manual mode
	    IF #sx_ManualModeActive THEN                                            // If Manual mode is active then check prestart status for manual mode
	        #sx_PreStartManual := #ix_SafetyOk                                  // If Safety is Okay
	        AND #ix_Connected                                                   // And Isolator switch is connected
	        AND #ix_HardwareOk                                                  // And Profinet connection is okay 
	        AND NOT #iqUDT_FlowSplitterInterface.InternalErrorVFD;             // Add no error on VFD // Then conveyor is allowed to run in manual mode.
	        
	        IF (#sx_PreStartManual                                                              // If Pre start conditions to run in manual mode is okay
	            AND (#sR_TRIG_RunManual.Q AND NOT #iqUDT_FlowSplitterCommand.ManualJog)         // and rising edge to run in manual mode is detected and it is not running in jogging mode
	            OR (#sR_TRIG_Jog.Q AND NOT #iqUDT_FlowSplitterCommand.ManualStartStop))         // Or rising edge to start jogging is detected and it is not running in manual mode
	        THEN
	            #iqUDT_EquipmentControl.Request.SignalingRequest := TRUE;                      //then Request signaling to control block before conveyor run in manual mode
	        END_IF;
	        
	        // To Run conveyor forward in manual mode 
	        #iqUDT_FlowSplitterInterface.RunFwd := #sx_PreStartManual          // Prestart conditions to run in manual mode is active
	        AND NOT #iqUDT_EquipmentControl.Request.SignalingRequest           // And Signaling request done
	        AND (#iqUDT_FlowSplitterCommand.ManualStartStop                    // And Command to manual Run or manual jog is active
	        OR #iqUDT_FlowSplitterCommand.ManualJog);                          // Then run motor in forward direction
	        
	        // Flow splitter belt should not run in reverse direction
	        #iqUDT_FlowSplitterInterface.RunRvs := FALSE;
	        
	        // Pop up diverts in manual mode
	        #sx_Zone1_Divert := #sx_PreStartManual AND #iqUDT_FlowSplitterCommand.Zone1DivertActivation;          // Output bit to active zone 1 diverts
	        #sx_Zone2_Divert := #sx_PreStartManual AND #iqUDT_FlowSplitterCommand.Zone2DivertActivation;          // Output bit to active zone 2 diverts
	        
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Automatic mode active
	    
	    IF NOT #sx_ManualModeActive THEN                                        // Manual mode is not active
	        IF #sx_AutomaticActive AND #sx_Ready THEN                           // Automatic mode active AND ready
	            
	            #iqUDT_HandShakeUp.RTR := #iqUDT_FlowSplitterInterface.VFDatSpeed;            // Ready to receive handshake to upstream if VFD is at speed
	            
	            CASE #si_Mode OF                                                // Operation mode case selection
	                    
	                1:  // 100% straight
	                    
	                    // Order to VFD to run
	                    #iqUDT_FlowSplitterInterface.RunFwd := NOT #ix_ExternalRequestHold             // Halt request is not active
	                    AND #iqUDT_HandShakeStraight.RTR                                               // Ready to receive active
	                    AND NOT #sx_EnergySaveActive;                                                   // Energy save is not active
	                    
	                    #sx_Zone2_Divert := FALSE;                                                      // Output bit to active zone 2 diverts
	                    #sx_Zone1_Divert := #sx_Switch3To1;                                             // Output bit to active zone 1 diverts
	                    
	                    IF #sx_Switch3To1 THEN                                                          // Memory bit switch from mode 3 to mode 1
	                        IF "DB_Memory".OS_1sec THEN                                                 // Memory bit 1 second trigger
	                            #si_SwitchDelay += 1;                                                   // Memory integer to count time to delay switch
	                        END_IF;
	                        
	                        IF #si_SwitchDelay >= #iUDT_FlowSplitterConfiguration.DivertSwitchDelay THEN    // Comparation between memory integer switch delay and configuration divert switch delay
	                            #si_SwitchDelay := 0;                                                   // Reset memory integer switch delay counter
	                            #sx_Switch3To1 := FALSE;                                                // Reset switch from mode 3 to mode 1 memory bit
	                        END_IF;
	                    END_IF;
	                    
	                    #sx_Switch1To3 := TRUE;                                                         // Set memory bit switch from mode 1 to mode 3
	                    ;
	                    
	                2:  // 50% straight - 50% divert 
	                    
	                    #iqUDT_FlowSplitterInterface.RunFwd := ((#iqUDT_HandShakeStraight.RTR         // Ready to receive downstream straight
	                    AND #iqUDT_HandShakeDivert.RTR)                                                // Ready to receive downstream divert chute
	                    OR (#iUDT_FlowSplitterConfiguration.OnFlyChangeOfMode                          // On fly change mode
	                    AND (#iqUDT_HandShakeStraight.RTR                                              // Ready to receive downstream straight
	                    OR (#iqUDT_HandShakeDivert.RTR AND NOT #sUDT_HMIStatus.Specific.AirPressure))))// Ready to receive downstream divert chute
	                    //   AND (NOT #i_UDT_FlowSplitterConfiguration.OnFlyChangeOfMode
	                    //   AND NOT #s_UDT_HMIStatus.Specific.AirPressure)
	                    AND NOT #ix_ExternalRequestHold                                                // External requesto to halt
	                    AND NOT #sx_EnergySaveActive;                                                   // Energy save is not active
	                    
	                    #sx_Zone1_Divert := (#iqUDT_HandShakeDivert.RTR                                // Ready to receive downstream divert chute
	                    OR NOT #iqUDT_HandShakeStraight.RTR                                            // Ready to receive downstream straight
	                    OR NOT #iUDT_FlowSplitterConfiguration.OnFlyChangeOfMode)                      // On fly change mode
	                    AND NOT #sUDT_HMIStatus.Specific.AirPressure;                                         // And Air pressure is OK 
	                    
	                    #sx_Zone2_Divert := (#iUDT_FlowSplitterConfiguration.OnFlyChangeOfMode         // On fly change mode
	                    AND NOT #iqUDT_HandShakeStraight.RTR                                           // Ready to receive downstream straight
	                    AND #iqUDT_HandShakeDivert.RTR)
	                    AND NOT #sUDT_HMIStatus.Specific.AirPressure;                                         // Ready to receive downstream divert chute
	                    
	                    #sx_Switch1To3 := FALSE;                                                        // Switch from mode 1 to mode 3
	                    #sx_Switch3To1 := FALSE;                                                        // Switch from mode 3 to mode 1
	                    ;
	                    
	                3:  // 0% straight - 100% divert 
	                    
	                    // Order to VFD to run
	                    #iqUDT_FlowSplitterInterface.RunFwd := NOT #ix_ExternalRequestHold             // Halt request is not active
	                    AND #iqUDT_HandShakeDivert.RTR                                                 // Handshake Ready to receive from downstream divert conveyor
	                    AND NOT #sUDT_HMIStatus.Specific.AirPressure
	                    AND NOT #sx_EnergySaveActive;                                                   // Energy save is not active
	                    
	                    #sx_Zone1_Divert := NOT #sUDT_HMIStatus.Specific.AirPressure;                         // Output bit to active zone 1 diverts
	                    #sx_Zone2_Divert := NOT #sx_Switch1To3 AND NOT #sUDT_HMIStatus.Specific.AirPressure;  // Output bit to active zone 2 diverts
	                    
	                    IF #sx_Switch1To3 THEN                                                          // Memory bit switch mode 1 to mode 3
	                        IF "DB_Memory".OS_1sec THEN                                                 // Memory bit 1 second trigger
	                            #si_SwitchDelay += 1;                                                   // Memory integer to count time to delay switch
	                        END_IF;
	                        
	                        IF #si_SwitchDelay > #iUDT_FlowSplitterConfiguration.DivertSwitchDelay     // Comparation between memory integer switch delay and configuration divert switch delay
	                        THEN
	                            #si_SwitchDelay := 0;                                                   // Reset memory integer switch delay counter
	                            #sx_Switch1To3 := FALSE;                                                // Reset switch from mode 1 to mode 3 memory bit
	                        END_IF;
	                    END_IF;
	                    #sx_Switch3To1 := TRUE;                                                         // Set memory bit switch from mode 3 to mode 1
	                    ;
	                    
	                4:  // Based on time 
	                    
	                    #iqUDT_FlowSplitterInterface.RunFwd := ((#iqUDT_HandShakeStraight.RTR         // Ready to receive downstream straight
	                    AND #iqUDT_HandShakeDivert.RTR)                                                // Ready to receive downstream divert chute
	                    OR (#iUDT_FlowSplitterConfiguration.OnFlyChangeOfMode                          // On fly change mode
	                    AND (#iqUDT_HandShakeStraight.RTR                                              // Ready to receive downstream straight
	                    OR (#iqUDT_HandShakeDivert.RTR AND NOT #sUDT_HMIStatus.Specific.AirPressure))))      // Ready to receive downstream divert chute
	                    //  AND (NOT #i_UDT_FlowSplitterConfiguration.OnFlyChangeOfMode
	                    //  AND NOT #s_UDT_HMIStatus.Specific.AirPressure)
	                    AND NOT #ix_ExternalRequestHold                                                 // External requesto to halt 
	                    AND NOT #sx_EnergySaveActive;                                                   // Energy save is not active
	                    
	                    #sx_Switch1To3 := FALSE;                                                        // Reset switch from mode 1 to mode 3 memory bit
	                    #sx_Switch3To1 := FALSE;                                                        // Reset switch from mode 3 to mode 1 memory bit
	                    
	                    #si_Mode4DivertTime := REAL_TO_INT(#iqUDT_FlowSplitterCommand.PercentageSplit * #iUDT_FlowSplitterConfiguration.TimeBasedSplit) / 100;      // Memory integer to calculate time base
	                    
	                    IF "DB_Memory".OS_1sec AND #iqUDT_HandShakeDivert.RTR THEN                     // Memory bit 1 second trigger and Handshake bit ready to receive to upstream
	                        #si_Mode4AuxTimer += 1;                                                     // Increment counter to time base mode
	                    END_IF;
	                    
	                    #tx_AuxBaseTimeDivert1 := FALSE;                                                // Auxiliary base time divert zone 1
	                    #tx_AuxBaseTimeDivert2 := FALSE;                                                // Auxiliary base time divert zone 2
	                    
	                    IF (#si_Mode4AuxTimer <= #si_Mode4DivertTime)                                   // If the counter time is lower than calculated time from configuration
	                    THEN
	                        #tx_AuxBaseTimeDivert1 := TRUE;                                             // Auxiliary base time divert zone 1
	                        #tx_AuxBaseTimeDivert2 := TRUE;                                             // Auxiliary base time divert zone 2
	                    END_IF;
	                    
	                    IF (#si_Mode4AuxTimer > #si_Mode4DivertTime)                                    // If the counter time is bigger than calculated time from configuration 
	                        AND (#si_Mode4AuxTimer < #iUDT_FlowSplitterConfiguration.TimeBasedSplit)   // If the counter time is lower than time based split configured
	                    THEN
	                        #tx_AuxBaseTimeDivert1 := FALSE;                                            // Auxiliary base time divert zone 1
	                        #tx_AuxBaseTimeDivert2 := FALSE;                                            // Auxiliary base time divert zone 2
	                    END_IF;
	                    
	                    IF (#si_Mode4AuxTimer >= #iUDT_FlowSplitterConfiguration.TimeBasedSplit) THEN  // If the counter time is bigger or equal than time based split configured
	                        #si_Mode4AuxTimer := 0;                                                     // Reset counter time
	                    END_IF;
	                    
	                    IF (#iqUDT_HandShakeDivert.RTR                                                 // Ready to receive downstream divert chute
	                        AND ((#tx_AuxBaseTimeDivert1 AND #tx_AuxBaseTimeDivert2)
	                        OR (NOT #iqUDT_HandShakeStraight.RTR AND #iUDT_FlowSplitterConfiguration.OnFlyChangeOfMode)))
	                        AND NOT #sUDT_HMIStatus.Specific.AirPressure
	                    THEN
	                        #sx_Zone1_Divert := TRUE;
	                        #sx_Zone2_Divert := TRUE;
	                        
	                    ELSIF #iqUDT_HandShakeStraight.RTR
	                        AND ((NOT #tx_AuxBaseTimeDivert1 AND NOT #tx_AuxBaseTimeDivert2)
	                        OR (NOT #iqUDT_HandShakeDivert.RTR AND #iUDT_FlowSplitterConfiguration.OnFlyChangeOfMode))
	                        OR #sUDT_HMIStatus.Specific.AirPressure
	                    THEN
	                        #sx_Zone1_Divert := FALSE;
	                        #sx_Zone2_Divert := FALSE;
	                    END_IF
	                    ;
	                    
	                5:  // Semi automatic mode
	                    
	                    #iqUDT_FlowSplitterInterface.RunFwd := NOT #ix_ExternalRequestHold     // External requesto to halt
	                    AND NOT #sx_EnergySaveActive                                            // Energy save is not active
	                    AND ((#iqUDT_HandShakeStraight.RTR                                     // Ready to receive downstream straight
	                    AND NOT #iqUDT_FlowSplitterCommand.Zone1DivertActivation               // Command divert activation zone 1
	                    AND NOT #iqUDT_FlowSplitterCommand.Zone2DivertActivation)              // Command divert activation zone 2
	                    OR (#iqUDT_HandShakeDivert.RTR                                         // Ready to receive downstream divert chute
	                    AND #iqUDT_FlowSplitterCommand.Zone1DivertActivation                   // Command divert activation zone 1
	                    AND #iqUDT_FlowSplitterCommand.Zone2DivertActivation                   // Command divert activation zone 2
	                    AND NOT #sUDT_HMIStatus.Specific.AirPressure)                                 // Air preassure is OK
	                    OR (#iqUDT_HandShakeStraight.RTR                                       // Ready to receive downstream straight
	                    AND #iqUDT_HandShakeDivert.RTR                                         // Ready to receive downstream divert chute
	                    AND #iqUDT_FlowSplitterCommand.Zone1DivertActivation                   // Command divert activation zone 1
	                    AND NOT #iqUDT_FlowSplitterCommand.Zone2DivertActivation               // Command divert activation zone 2
	                    AND NOT #sUDT_HMIStatus.Specific.AirPressure));
	                    
	                    #sx_Zone1_Divert := #iqUDT_FlowSplitterCommand.Zone1DivertActivation   // Command divert activation zone 1
	                    AND NOT #sUDT_HMIStatus.Specific.AirPressure;
	                    
	                    #sx_Zone2_Divert := #iqUDT_FlowSplitterCommand.Zone2DivertActivation   // Command divert activation zone 2
	                    AND NOT #sUDT_HMIStatus.Specific.AirPressure;
	                    
	                    #sx_Switch1To3 := FALSE;                                                // Reset switch from mode 1 to mode 3 memory bit
	                    #sx_Switch3To1 := FALSE;                                                // Reset switch from mode 3 to mode 1 memory bit
	                    ;
	            END_CASE;
	            
	            // Flow splitter end OF section PEC jam
	            
	            IF #iUDT_FlowSplitterConfiguration.PEC_Present THEN
	                
	                IF NOT #sx_PEC_EoSFiltered AND #ix_HardwareOk THEN                                      // Photo eye blocked
	                    #si_AuxJamDisplacement += #iqUDT_FlowSplitterInterface.Displacement;               // Increases displacement values in auxiliary variable
	                ELSE
	                    #si_AuxJamDisplacement := 0;                                                        // Reset jam auxiliary counter variable
	                END_IF;
	                
	                IF #si_AuxJamDisplacement > #iUDT_FlowSplitterConfiguration.JamDisplacementLimit THEN  // Compare jam auxiliary counter with displacement jam configured
	                    #sUDT_HMIStatus.Specific.PEC_EoSJam := TRUE;                                              // PEC jam status set true
	                END_IF;
	                
	            END_IF;
	            
	            // Chute PEC jam
	            
	            IF #iUDT_FlowSplitterConfiguration.PEC_ChutePesent THEN
	                IF NOT #sx_PEC_ChuteFiltered AND #ix_HardwareOk THEN
	                    #si_AuxJamDivertChuteDisplacement += #iqUDT_FlowSplitterInterface.Displacement;
	                ELSE
	                    #si_AuxJamDivertChuteDisplacement := 0;
	                END_IF;
	                
	                IF #si_AuxJamDivertChuteDisplacement > #iUDT_FlowSplitterConfiguration.DivertChuteJamDisplacLimit THEN     // Compare jam auxiliary counter with displacement jam configured
	                    #sUDT_HMIStatus.Specific.PEC_DivertChuteJam := TRUE;                                                          // PEC jam status set true
	                END_IF;
	                
	            END_IF;
	            
	            // Debris detection
	            #sFB_DebrisTimer(iudi_OnDelayTime := #iUDT_FlowSplitterConfiguration.DebrisTimeFilter,      // Debris filtering time configuration
	                             iudi_OffDelayTime := 0,
	                             ix_SignalToDelay := NOT #ix_DebrisSensor AND #ix_HardwareOk,                // Debris sensor signal input
	                             ix_Enable := TRUE,                                                          // Enable timer
	                             qx_DelayedSignal => #sx_DebrisSignalFiltered);                              // Debris sensor signal filtered
	            
	            #sUDT_HMIStatus.Specific.Debris := #sx_DebrisSignalFiltered;                                              // Debris error status
	            
	            // Energy save
	            #iqUDT_HandShakeStraight.ResetEnergySave := NOT #ix_PECUpstream;
	            #iqUDT_HandShakeDivert.ResetEnergySave := NOT #ix_PECUpstream AND #sx_EnableDiverts;
	            
	        ELSE
	            // If conveyor is not in manual mode and not ready
	            #iqUDT_FlowSplitterInterface.RunFwd := FALSE;                                                      // Order to VFD stop conveyor
	            #iqUDT_HandShakeUp.RTR := FALSE;                                                                   // Set ready to receive false
	            
	        END_IF;
	    END_IF;
	    
	    // Air pressure error
	    IF NOT #ix_AirPressureOk AND #ix_HardwareOk THEN
	        #sUDT_HMIStatus.Specific.AirPressure := TRUE;
	    END_IF;
	    
	    // Encoder error
	    IF #ix_FlowSplitterEncoderError AND #ix_HardwareOk THEN
	        #sUDT_HMIStatus.Specific.EncoderError := TRUE;
	    END_IF;
	    
	    // Diverts output control
	    #qx_Zone1Divert := #sx_Zone1_Divert AND (#sx_EnableDiverts OR NOT #iUDT_FlowSplitterConfiguration.DivertsTimeSave);
	    #qx_Zone2Divert := #sx_Zone2_Divert AND (#sx_EnableDiverts OR NOT #iUDT_FlowSplitterConfiguration.DivertsTimeSave);
	    
	    // Divert activation error is true when the diverts from zone 2 is active and the diverts from zone 1 is not pop up.
	    #sUDT_HMIStatus.Specific.DivertsActivationError := NOT #qx_Zone1Divert AND #qx_Zone2Divert;
	    
	    // Update mode status for HMI, IF not in manual mode update selected mode otherwise write 0   
	    IF NOT #sx_ManualModeActive THEN
	        #sUDT_HMIStatus.Specific.Mode := #si_Mode;
	    ELSE
	        #sUDT_HMIStatus.Specific.Mode := 0;
	    END_IF;
	    
	    //Update actual direction status of divert for HMI
	    #sUDT_HMIStatus.Specific.Zone1Divert := #qx_Zone1Divert;
	    #sUDT_HMIStatus.Specific.Zone2Divert := #qx_Zone2Divert;
	    
	END_REGION
	
	REGION 7 - Energy save
	    
	    IF #iUDT_FlowSplitterConfiguration.Energy THEN
	        
	        // Set Energy save active.
	        IF #si_AuxEnergySave >= #iUDT_FlowSplitterConfiguration.EnergySaveLength
	        THEN
	            #sx_EnergySaveActive := TRUE;
	        END_IF;
	        
	        IF ((NOT #sx_PEC_EoSFiltered AND #iUDT_FlowSplitterConfiguration.PEC_Present)
	            OR #iqUDT_HandShakeUp.RTS
	            OR #iqUDT_HandShakeUp.ResetEnergySave
	            OR #ix_ResetEnergySave
	            OR #sx_ManualModeActive)
	        THEN
	            #si_AuxEnergySave := 0;
	            #sx_EnergySaveActive := FALSE;
	        ELSE
	            #si_AuxEnergySave += #iqUDT_FlowSplitterInterface.Displacement;
	        END_IF;
	        
	    ELSE
	        
	        #si_AuxEnergySave := 0;
	        #sx_EnergySaveActive := FALSE;
	        
	    END_IF;
	    
	    
	    
	END_REGION
	
	REGION 8 - Speed control   
	    (*In manual mode, conveyor runs with low speed by default. If "ManualFullSpeed" is set true, conveyor runs with high speed in manual mode.
	      In automatic mode, conveyor runs with full speed if external is zero. If external speed is bigger than zero, conveyor will run with that speed. *)
	    
	    IF #sx_ManualModeActive                                                                                 // Manual mode active
	    THEN
	        IF #iqUDT_FlowSplitterCommand.ManualFullSpeed                                                      // Full speed in manual mode
	            AND #iqUDT_FlowSplitterCommand.ManualStartStop                                                 // Start/stop conveyor in manual mode
	        THEN
	            #iqUDT_FlowSplitterInterface.SpeedSetpoint := #iUDT_FlowSplitterConfiguration.SpeedSetpointNominal;   // Move nominal setpoint to the VDF
	        ELSE
	            #iqUDT_FlowSplitterInterface.SpeedSetpoint := #iUDT_FlowSplitterConfiguration.SpeedSetpointLow;       // Move low speed setpoint to VFD
	        END_IF;
	        
	    ELSE
	        
	        IF #iui_ExternalSpeed > 0                                                                           // If external speed bigger than zero
	        THEN
	            #iqUDT_FlowSplitterInterface.SpeedSetpoint := #iui_ExternalSpeed;                                      // Move external speed to VFD
	        ELSE
	            #iqUDT_FlowSplitterInterface.SpeedSetpoint := #iUDT_FlowSplitterConfiguration.SpeedSetpointNominal;   // Move nominal setpoint to VFD
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 9 - Statistics
	    
	    // Flow splitter up Time
	    IF #sx_AutomaticActive AND #sx_Ready OR #iqUDT_EquipmentControl.Command.ResetData THEN                 // Automatic active
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,                             // Reset statistics input
	                        ix_Activate := #sx_AutomaticActive                                                  // Activate statistics functions input
	                        AND #sx_Ready,
	                        ix_RTrigActivate := #sR_TRIG_FlowSplitterUpTime.Q,                                   // Statistics active trigger
	                        iqUDT_Statistics := #iqUDT_Statistics.FlowSplitterUpTime);                        // Statistics values output
	    END_IF;
	    
	    // 9.2 - Flow splitter down Time
	    IF #sx_AutomaticActive AND NOT #sx_Ready OR #iqUDT_EquipmentControl.Command.ResetData THEN             // Automatic active
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,                             // Reset statistics input
	                        ix_Activate := #sx_AutomaticActive                                                  // Activate statistics functions input
	                        AND NOT #sx_Ready,
	                        ix_RTrigActivate := #sR_TRIG_FlowSplitterDownTime.Q,                                 // Statistics active trigger
	                        iqUDT_Statistics := #iqUDT_Statistics.FlowSplitterDownTime);                      // Statistics values output
	    END_IF;
	    
	    // Chute PEC Blockage error
	    IF #sUDT_HMIStatus.Specific.PEC_DivertChuteJam OR #iqUDT_EquipmentControl.Command.ResetData THEN             // PEC jam error active
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,                             // Reset statistics input
	                        ix_Activate := #sUDT_HMIStatus.Specific.PEC_DivertChuteJam,                               // Activate statistics functions input
	                        ix_RTrigActivate := #sR_TRIG_PECDivertChuteJam.Q,                                    // Statistics active trigger
	                        iqUDT_Statistics := #iqUDT_Statistics.PECChuteDivertJam);                         // Statistics values output
	    END_IF;
	    
	    // PEC Blockage error
	    IF (#sUDT_HMIStatus.Specific.PEC_EoSJam OR #iqUDT_EquipmentControl.Command.ResetData) THEN                   // PEC jam error active
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,                             // Reset statistics input
	                        ix_Activate := #sUDT_HMIStatus.Specific.PEC_EoSJam,                                       // Activate statistics functions input
	                        ix_RTrigActivate := #sR_TRIG_PECJam.Q,                                               // Statistics active trigger
	                        iqUDT_Statistics := #iqUDT_Statistics.PEC_EoSJam);                                // Statistics values output
	    END_IF;
	    
	    // Air pressure error
	    IF #sUDT_HMIStatus.Specific.AirPressure OR #iqUDT_EquipmentControl.Command.ResetData THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.AirPressure,
	                        ix_RTrigActivate := #sR_TRIG_AirPressureError.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.AirPressure);
	    END_IF;
	    
	    // Debris detecting
	    IF #sUDT_HMIStatus.Specific.Debris OR #iqUDT_EquipmentControl.Command.ResetData THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.Debris,
	                        ix_RTrigActivate := #sR_TRIG_DebrisDetected.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.DebrisSensor);
	    END_IF;
	    
	    // Encoder error
	    IF #ix_FlowSplitterEncoderError OR #iqUDT_EquipmentControl.Command.ResetData THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #ix_FlowSplitterEncoderError,
	                        ix_RTrigActivate := #sR_TRIG_EnconderError.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.EncoderError);
	    END_IF;
	    
	    // Mode 1
	    IF (#si_Mode = 1 AND NOT #sx_ManualModeActive) OR #iqUDT_EquipmentControl.Command.ResetData THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := (#si_Mode = 1)
	                        AND #iqUDT_FlowSplitterInterface.VFDRunning,
	                        ix_RTrigActivate := #sR_TRIG_Mode1.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.Mode100Divert);
	    END_IF;
	    
	    // Mode 2
	    IF (#si_Mode = 2 AND NOT #sx_ManualModeActive) OR #iqUDT_EquipmentControl.Command.ResetData THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := (#si_Mode = 2)
	                        AND #iqUDT_FlowSplitterInterface.VFDRunning,
	                        ix_RTrigActivate := #sR_TRIG_Mode2.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics."Mode50/50");
	    END_IF;
	    
	    // Mode 3
	    IF (#si_Mode = 3 AND NOT #sx_ManualModeActive) OR #iqUDT_EquipmentControl.Command.ResetData THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := (#si_Mode = 3)
	                        AND #iqUDT_FlowSplitterInterface.VFDRunning,
	                        ix_RTrigActivate := #sR_TRIG_Mode3.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.Mode100Divert);
	    END_IF;
	    
	    // Mode 4
	    IF (#si_Mode = 4 AND NOT #sx_ManualModeActive) OR #iqUDT_EquipmentControl.Command.ResetData THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := (#si_Mode = 4)
	                        AND #iqUDT_FlowSplitterInterface.VFDRunning,
	                        ix_RTrigActivate := #sR_TRIG_Mode4.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.ModeTimeBasedSplit);
	    END_IF;
	    
	    // Mode 5
	    IF (#si_Mode = 5 AND NOT #sx_ManualModeActive) OR #iqUDT_EquipmentControl.Command.ResetData THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := (#si_Mode = 5)
	                        AND #iqUDT_FlowSplitterInterface.VFDRunning,
	                        ix_RTrigActivate := #sR_TRIG_Mode5.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.ModeSemiAutomatic);
	    END_IF;
	    
	    // Enegry save mode
	    IF #sx_EnergySaveActive
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_CommonStatus.EnergySave,
	                        ix_RTrigActivate := #sR_TRIG_EnergySave.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.EnergySave);
	    END_IF;
	    
	END_REGION
	
	REGION 10 - Status
	    
	    #sUDT_CommonStatus.Stopped := #sx_Ready AND NOT #sx_AutomaticActive;               // stopped
	    
	    #sUDT_CommonStatus.Running := #iqUDT_FlowSplitterInterface.RunFwd
	    OR #iqUDT_FlowSplitterInterface.RunRvs;                                            // Running
	    
	    #sUDT_CommonStatus.Halted := #ix_ExternalRequestHold AND #sx_Ready AND #sx_AutomaticActive;   // Halted
	    
	    #sUDT_CommonStatus.Dieback := #sx_Ready AND #sx_AutomaticActive
	    AND NOT #sUDT_CommonStatus.EnergySave
	    AND NOT #sUDT_CommonStatus.Running;                                                // Die back
	    
	    #sUDT_CommonStatus.Manual := #sx_ManualModeActive;                                 // Manual
	    
	    #sUDT_CommonStatus.ManualRun := #sx_ManualModeActive AND #sUDT_CommonStatus.Running;     // Manual Running
	    
	    #sUDT_CommonStatus.EnergySave := #sx_EnergySaveActive;                             // Energy save active
	    
	    #sUDT_CommonStatus.SafetyStop := NOT #ix_SafetyOk;                                 // Safety not ok
	    
	    #sUDT_CommonStatus.Warning := #sUDT_HMIStatus.Specific.AirPressure;
	    
	    IF #sUDT_CommonStatusOld <> #sUDT_CommonStatus THEN                               // update on change
	        
	        // Set status to status number
	        
	        #sUDT_HMIStatus.Status := 0;                                                   // Initialise status number              
	        
	        IF #sUDT_CommonStatus.EnergySave                                               // Energy save
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".EnergySave;
	            
	        END_IF;
	        
	        IF #sUDT_CommonStatus.Running                                                  // Running
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Running;
	            
	        END_IF;
	        
	        IF #sUDT_CommonStatus.Stopped                                                  // Stopped
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Stopped;
	            
	        END_IF;
	        
	        IF #sUDT_CommonStatus.Dieback                                                  // Dieback
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Dieback;
	            
	        END_IF;
	        
	        IF #sUDT_CommonStatus.Halted                                                   // Halted
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Halted;
	            
	        END_IF;
	        
	        IF #sUDT_CommonStatus.Manual                                                    // Manual
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Manual;
	            
	        END_IF;
	        
	        IF #sUDT_CommonStatus.ManualRun                                                // Running in manual mode
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".ManualRun;
	            
	        END_IF;
	        
	        IF #sUDT_HMIStatus.Specific.DivertsActivationError                             // Divert activation error
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".OperationalError;
	            
	        END_IF;
	        
	        IF #sUDT_HMIStatus.Specific.EncoderError                                       // Encoder error
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".EncoderError;
	            
	        END_IF;
	        
	        IF #sUDT_HMIStatus.Specific.PEC_EoSJam                                          // IF EOS PEC jam or
	            OR #sUDT_HMIStatus.Specific.PEC_DivertChuteJam                              // Divert chute PEC jam
	            OR #iqUDT_FlowSplitterInterface.InternalErrorPEC                           // Error pec outside of flowsplitter block
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".PECJam;
	            
	        END_IF;
	        
	        IF #iqUDT_FlowSplitterInterface.InternalErrorVFD                               // VFD error
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".VFDError;
	            
	        END_IF;
	        
	        IF #sUDT_HMIStatus.Specific.Debris                                             // Debris sensor error
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Error;
	            
	        END_IF;
	        
	        IF #sUDT_HMIStatus.Specific.AirPressure                                         // Air pressure error
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Error;
	            
	        END_IF;
	        
	        IF #sUDT_CommonStatus.SafetyStop                                                // Safety stop 
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".SafetyStop;
	            
	        END_IF;
	        
	        
	        #sUDT_CommonStatusOld := #sUDT_CommonStatus;                                  // Copy status to memory
	        #qUDT_Status := #sUDT_CommonStatus;                                           // Copy status to output
	        
	    END_IF;
	    
	    #qUDT_HMIStatus := #sUDT_HMIStatus;                                           // Copy HMI status to output
	    
	END_REGION
	
	REGION 11 - Report to control block
	    "FC_EquipmentReport"(iUDT_Status := #sUDT_CommonStatus,                              // Function to manage report between control block and conveyor block
	                         iqUDT_Control := #iqUDT_EquipmentControl);
	END_REGION
	
	REGION 12 - Internal errors and warnings reset
	    IF #iqUDT_EquipmentControl.Command.Reset
	    THEN
	        #iqUDT_FlowSplitterInterface.InternalErrorPEC := FALSE;
	        #iqUDT_FlowSplitterInterface.InternalWarningTracking := FALSE;
	        #iqUDT_FlowSplitterInterface.InternalErrorTracking := FALSE;
	        #iqUDT_FlowSplitterInterface.InternalWarningVFD := FALSE;
	        #iqUDT_FlowSplitterInterface.InternalErrorVFD := FALSE;
	        #iqUDT_FlowSplitterInterface.ConfigurationError := FALSE;
	        
	    END_IF;
	END_REGION
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_G120ForceDormantErrorDetection"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 212
// END_ATTRIBUTES
   VAR_INPUT 
      ix_SystemStopped { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE = System is stopped
      ix_VFDRunning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE = VFD is running
      ix_VFDSTOActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE = STO applied on VFD
      ix_VFDSS1Active { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE = SS1 applied on VFD
      ix_VFDSLSActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE = SLS applied on VFD
      ix_FDEDMonitoringTimeElaplsed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE= Monitoring time in VFD elapsed
   END_VAR

   VAR_IN_OUT 
      iqUDT_OuputVFD : "UDT_VfdSiemensPO";
   END_VAR

   VAR 
      sx_TestRequired { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE = Test is required
      sFB_Pulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	2020-7-09   | 0.1       | S.Theocharis  | Initial version 
	2020-7-14   | 0.2       | Mateusz Piela | Remove timer from the block 
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION Check time 
	    
	    //Time to perform test is set to 10 mounth
	    IF #ix_FDEDMonitoringTimeElaplsed
	        AND #ix_SystemStopped
	        AND NOT #ix_VFDRunning
	        AND NOT #ix_VFDSTOActive
	        AND NOT #ix_VFDSS1Active
	        AND NOT #ix_VFDSLSActive
	    THEN
	        #sx_TestRequired := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION Trigger Test
	    
	    //create extended pulse for the test signal
	    #sFB_Pulse(iudi_OffDelayTime := 300,
	               ix_SignalToDelay := #sx_TestRequired);
	    
	    //write extended pulse in the test signal 
	    #iqUDT_OuputVFD.STW_1.ForceDormantErrorTest := #sFB_Pulse.qx_DelayedSignal;
	    
	    //reset test required trigger and initiate time interval
	    IF #sx_TestRequired
	    THEN
	        #sx_TestRequired := FALSE;
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MCOConveyLinxAixController"
TITLE = FB_VfdConveyLinxAixController
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Fortna
VERSION : 4.0
//Function to interface with ConveyLinx Aix Controller. On the controller is the possibility to connect two motors with two photoeyes and run the motors independent from each other. Also can each motor output used as a "normal" on/off output
//--V4.0 split the function to accomodate only 1 Motor
   VAR_INPUT 
      iUDT_AixConfig { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullControllerConfiguration";   // Configuration structure
      iUDT_AixInputsModule { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixPlcFullIn";   // ConveyLinxAix inputs structure
      ii_MotorPositionId { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 1 = Master Left, 2 = Master Right, 11 Slave Left, 12 Slave Right
      ii_PositionSetpoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ix_24vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 24VDC is healthy
      ix_SimulationModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when Simulation mode active
      ix_StartPositioning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ix_ResetPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixControllerStatus";   // HMI status structure for right motor
      qx_Positioned { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_IN_OUT 
      iqUDT_AixOutputsModule : "UDT_AixPlcFullOut";   // ConveyLinxAix nr.1 outputs structure
      iqUDT_ConveyorInterface : "UDT_ConveyorInterface";   // Conveyor interface structure Motor
      iqUDT_MCOStatistics : "UDT_VfdStatistics";   // Satistics structure
   END_VAR

   VAR 
      sFB_TimerOnOffDelayMCOSpeedFeedbackError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sFB_TimerOnOffDelayCheck24V { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // MHS "TimerOnOffDelay" - to delay time for MCO 24V contactor
      sFB_TimerOnOffDelayMCO { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sFB_TimerOnOffDelayMCOReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // MHS "TimerOnOffDelay" - to extend MCO reset
      sFB_TimerOnOffDelayMCORunningFeedbackError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sFB_TimerOnOffDelayAcceleration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_AixControllerStatus";   // Detailed MCO status overview
      sUDT_PNDeviceController { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PNDevice";   // PN device info structure, Controller 1
      ss_PNPortsStatusController { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..8] of Bool;   // TRUE when specific port has an error, Controller
      sR_TRIG_PNSlaveNotOnline {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for trigger Profinet slave not online statistics
      sR_TRIG_PNSlaveError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for trigger Profinet slave error statistics
      sR_TRIG_MCOInternalError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for trigger Internal MCO Error statistics
      sR_TRIG_Running {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for trigger running motor
      sR_TRIG_CommunicationErrorMCO {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for trigger communication error
      sR_TRIG_ResetPosition {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge reset position
      sF_TRIG_RunFwd {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge for run forward signal
      sF_TRIG_RunRvs {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge for run reverse signal
      sr_ActualSpeedSetpoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Actual speed setpoint motor
      si_ActualSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Actual speed motor
      si_MotorAcceleration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Left motor acceleration
      si_MotorDeceleration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Motor deceleration
      si_LeftMotorPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Left motor actual position
      si_LastLeftMotorPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Left motor last cycle position
      si_RightMotorPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Right motor actual position
      si_LastRightMotorPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Right motor last cycle position
      sx_GeneralStatisticsReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset from or right conveyor
      sx_HardwareOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Hardware is ok
      sx_ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Commissioning: configuration error
      sx_PNDeviceHealthyControler { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet device is online and error free, Controller 1
      sx_AixAvailableControler { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Hardware of MCO is ok and no communication error with movikit, Controller 1
      sx_24vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 24VDC is healthy
      sx_ErrorActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block has an error
      sx_EnableOperation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Enable operation signal
      sx_RunForward { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start MCO forward
      sx_RunReverse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start MCO backward
      sx_SpeedSetpointReached { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Speed setpoint reached motor
      sx_SpeedFeedbackError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // motor speed feedback error
      sx_ErrorController { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Active if any erorr from controller 1 is active
      sx_ErrorCMotor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE if error from controler motor is active
      sx_Accelerating { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor acceleration
      sx_HardwareOk_Motor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor hardware ok
      sx_LeftServoHomeHasBeenSet { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Servo position has beeen reset to 0
      sx_RightServoHomeHasBeenSet { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Servo position has beeen reset to 0
      sb_MotorRotationStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // 0 Motor not running, Normal or Servo Braking Mode applied; 1 Motor running in CCW Direction; 2 Motor running in CW Direction; 3 Motor not running and Free Braking Mode applied
   END_VAR

   VAR CONSTANT 
      ci_MCOArea : UInt := 1;   // Area ID of IO Profinet devices
      ci_SubmoduleHWType : UInt := 5;   // Submodule HW_type number
      ci_TelegramSlot : UInt := 1;   // Free Siemens telegram slot
      ci_TelegramSubslot : UInt := 3;   // Free Siemens telegram subslot
      ci_NumberOfProfinetPorts : Int := 2;   // Number of Profinet ports in device
      cr_MaximumOutput : Real := 16384.0;   // PLC maximum output value
      cw_ActualSpeedMask : Word := 2#0011_1111_1111_1111;   // Mask to get the speed from the profinet MotorActualSpeed Word
      cudi_ExtendedResetTime : UDInt := 500;   // Extending the reset puls
      cudi_HardwareCheckDelay : UDInt := 2000;   // Delay to enable hardware to start up, checking will start after this time
      cudi_FeedbackErrorDelay : UDInt := 10000;   // Maximum delaytime deviation from setpoint is allowed
      cudi_TimeOffsetSpeedmonitoring : UDInt := 2000;   // Additional time
      cudi_HeartbeatDelay : UDInt := 5000;   // Maximum dely between heartbeat
      ci_Master_Left : Int := 1;
      ci_Master_Right : Int := 2;
      ci_Slave_Left : Int := 11;
      ci_Slave_Right : Int := 12;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                       
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	03/01/2022  | 1.0       | N.Kadam       | First release MHSE TIA 16.0
	24/03/2022  | 1.1       | M.Piela       | Bug fix, adding running feedback error
	05/05/2022  | 1.2       | M.Piela       | Status update
	31/05/2022  | 1.3       | M.Piela       | Ramp up/down calculation fix
	21/07/2022  | 1.4       | M.Piela       | Prevent motor to go below the minimum speed
	29/07/2022  | 1.5       | M.Piela       | Status update, add hardware ok to the profinet checking
	01/08/2022  | 1.6       | M.Piela       | Add Hardware ok to reset internal error
	01/08/2022  | 1.7       | G.Vlooswijk   | Fix to make it possible to run 1 of the 2 motors
	                                        | Check setpoint instead of sx_EnableOperation for Feedback Error check
	                                        | Removed if statement i_UDT_Ai2Config.DirectionReversal, speed from controller always positive
	06/08/2022  | 1.8       | G.Vlooswijk   | Removed minimal speedsetpoint
	05/07/2023  | 1.9       | F.Baten       | Complete separation of 2 motors
	13/09/2023  | 4.0       | F.Baten       | Reorganised structure and took out unused symbolics
	                                        | Status as 1 controller with 2 seperate controlled motors
	02/05/2024  | 5.0       | I.Ajram       | Split the function to accomodate only 1 Motor, added an input to indicate which motor to control
	08/05/2024  | 5.1       | S.Nieswiec    | qUDT_AixOutputsModule move to in/out variables, name changed to iqUDT_AixOutputsModule
	08/05/2024  | 5.2       | K. Pokorski   | Add displacement calculation
	13/05/2024  | 5.3       | K. Pokorski   | Add roller ratio
	08/06/2024  | 5.4       | S.Nieswiec    | Fixed servo delta calculation (went back to previous functioning version), adjusted region numbering
	                                        | displacement was negative on some conveyors while positive on others
	21/06/2024  | 5.5       | I.Ajram       | Added Master / Slave Mod, Slave is used when one conveyor is controlling more than 1 MCO, the rest will act/ be configured as slaves
	*)
	
	REGION 1 - Get Device Profinet information
	    
	    //Get Device Profinet name, Controller 
	    "FC_GetDevicePN"(is_PNDeviceName := #iUDT_AixConfig.AixContrlPNDeviceName,
	                     ix_SimulationModeActive := #ix_SimulationModeActive,
	                     iqUDT_PND := #sUDT_PNDeviceController);
	    
	    //Get number of ports, Controller 
	    "FC_GetPNPortStatus"(ii_NumberOfPorts := #ci_NumberOfProfinetPorts,
	                         iUDT_DevicePNInfo := #sUDT_PNDeviceController,
	                         qa_PortFault => #ss_PNPortsStatusController);
	    
	END_REGION
	
	REGION 2 - Reset errors
	    
	    
	    REGION 2.1 - Motor
	        
	        // Reset errors when InternalErrorReset is given
	        IF #iqUDT_ConveyorInterface.InternalErrorReset OR (NOT #iqUDT_ConveyorInterface.HardwareOk AND #sUDT_HMIStatus.PNSlaveNotOnline)
	        THEN
	            #sUDT_HMIStatus.PNSlaveNotOnline := FALSE;
	            #sUDT_HMIStatus.PNSlaveError := FALSE;
	            #sUDT_HMIStatus.InternalError := FALSE;
	            #sUDT_HMIStatus.PNSlaveWarning := FALSE;
	            #sUDT_HMIStatus.SpeedFeedbackError := FALSE;
	            #sx_SpeedFeedbackError := FALSE;
	            #sx_ErrorCMotor := FALSE;
	            #sUDT_HMIStatus.MotorStatus.Overheat := FALSE;
	            #sUDT_HMIStatus.MotorStatus.MaxTorque := FALSE;
	            #sUDT_HMIStatus.MotorStatus.ShortCircuit := FALSE;
	            #sUDT_HMIStatus.MotorStatus.MotorNotConnected := FALSE;
	            #sUDT_HMIStatus.MotorStatus.Overload := FALSE;
	            #sUDT_HMIStatus.MotorStatus.Stalled := FALSE;
	            #sUDT_HMIStatus.MotorStatus.BadHall := FALSE;
	            #sUDT_HMIStatus.MotorStatus.BoardOverheat := FALSE;
	            #sUDT_HMIStatus.MotorStatus.OverVoltage := FALSE;
	            #sUDT_HMIStatus.MotorStatus.LowVoltage := FALSE;
	            #iqUDT_ConveyorInterface.InternalErrorVFD := FALSE;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 2.2 - Reset pulse
	        // Create extended pulse for MCO Reset
	        #sFB_TimerOnOffDelayMCOReset(iudi_OnDelayTime := #cudi_ExtendedResetTime,
	                                     iudi_OffDelayTime := 0,
	                                     ix_SignalToDelay := #iqUDT_AixOutputsModule.ClearMotorError = 1,
	                                     ix_Enable := TRUE);
	        // set the reset signal directly when reset is active
	        IF #iqUDT_ConveyorInterface.InternalErrorReset THEN
	            #iqUDT_AixOutputsModule.ClearMotorError := 1;
	        END_IF;
	        
	        // Reset the ClearMotorError after 500[ms] pulse
	        IF #sFB_TimerOnOffDelayMCOReset.qx_DelayedSignal
	        THEN
	            #iqUDT_AixOutputsModule.ClearMotorError := 0;
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 3 - Hardware checks
	    
	    // Hardware will only be available after the delay, so the device has time for the initialisation
	    #sFB_TimerOnOffDelayCheck24V(iudi_OnDelayTime := #cudi_HardwareCheckDelay,
	                                 ix_SignalToDelay := #ix_24vOk);
	    
	    #sx_24vOk := #sFB_TimerOnOffDelayCheck24V.qx_DelayedSignal;
	    
	    #sx_HardwareOk_Motor := #iqUDT_ConveyorInterface.HardwareOk AND #iUDT_AixConfig.Motor.MotorExist;
	    
	    #sx_HardwareOK := NOT #ix_SimulationModeActive
	    AND #sx_24vOk
	    AND (#sx_HardwareOk_Motor OR NOT #iUDT_AixConfig.Motor.MotorExist)
	    AND (#ss_PNPortsStatusController[1] OR #ss_PNPortsStatusController[2])
	    AND #iqUDT_ConveyorInterface.HardwareOk;
	    
	    
	    // Check if PN device is online
	    IF NOT "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDeviceController.PNNetworknumber].DeviceStatus[#sUDT_PNDeviceController.PNDeviceNumber].DeviceState.Exist
	        AND #sx_HardwareOK
	    THEN
	        #sUDT_HMIStatus.PNSlaveNotOnline := TRUE;
	    END_IF;
	    
	    // Check IF PN ports are healthy 
	    IF #ss_PNPortsStatusController[1] XOR #ss_PNPortsStatusController[2]
	        
	    THEN
	        #sUDT_HMIStatus.PNSlaveWarning := TRUE;
	    END_IF;
	    
	    // Check if PN device has an error
	    IF "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDeviceController.PNNetworknumber].DeviceStatus[#sUDT_PNDeviceController.PNDeviceNumber].DeviceState.Error
	        AND #sx_HardwareOK
	        AND NOT #sUDT_HMIStatus.PNSlaveWarning
	    THEN
	        #sUDT_HMIStatus.PNSlaveError := TRUE;
	    END_IF;
	    
	    // Set bit when PN device is healthy (online and no error)
	    #sx_PNDeviceHealthyControler := NOT #sUDT_HMIStatus.PNSlaveNotOnline
	    AND NOT #sUDT_HMIStatus.PNSlaveError
	    AND #sUDT_PNDeviceController.PNDeviceFound
	    AND #sx_24vOk;
	    
	    // Set hardware available bit when all conditions are met
	    #sx_AixAvailableControler := (#sx_24vOk
	    AND #sx_PNDeviceHealthyControler
	    AND (#sx_HardwareOk_Motor OR NOT #iUDT_AixConfig.Motor.MotorExist))
	    OR #ix_SimulationModeActive;
	    
	    // Check communication (heartbeat)
	    #sFB_TimerOnOffDelayMCO(iudi_OnDelayTime := #cudi_HeartbeatDelay,
	                            ix_SignalToDelay := NOT #iUDT_AixInputsModule.AllSensorPortInputs.Heartbeat);
	    
	    // Set error when MoviKit communication is not available
	    IF #sFB_TimerOnOffDelayMCO.qx_DelayedSignal AND #sx_HardwareOK
	    THEN
	        
	        #sUDT_HMIStatus.CommunicationErrorVFD := TRUE;
	        
	    END_IF;
	END_REGION
	
	REGION 4 - Check errors and warnings 
	    REGION 4.1 - Error from controller for right motor 
	        IF #ii_MotorPositionId = #ci_Master_Right OR #ii_MotorPositionId = #ci_Slave_Right THEN
	            //Write errors to UDT_Status
	            IF #iUDT_AixInputsModule.RightMotorDiagnostic.Overheat
	            THEN
	                #sUDT_HMIStatus.MotorStatus.Overheat := TRUE;
	            END_IF;
	            
	            #sUDT_HMIStatus.MotorStatus.MaxTorque := #iUDT_AixInputsModule.RightMotorDiagnostic.MaxTorque;
	            
	            IF #iUDT_AixInputsModule.RightMotorDiagnostic.ShortCircuit
	            THEN
	                #sUDT_HMIStatus.MotorStatus.ShortCircuit := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModule.RightMotorDiagnostic.MotorNotConnected
	            THEN
	                #sUDT_HMIStatus.MotorStatus.MotorNotConnected := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModule.RightMotorDiagnostic.Overload
	            THEN
	                #sUDT_HMIStatus.MotorStatus.Overload := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModule.RightMotorDiagnostic.Stalled
	            THEN
	                #sUDT_HMIStatus.MotorStatus.Stalled := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModule.RightMotorDiagnostic.BadHall
	            THEN
	                #sUDT_HMIStatus.MotorStatus.BadHall := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModule.RightMotorDiagnostic.BoardOverheat
	            THEN
	                #sUDT_HMIStatus.MotorStatus.BoardOverheat := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModule.RightMotorDiagnostic.OverVoltage
	            THEN
	                #sUDT_HMIStatus.MotorStatus.OverVoltage := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModule.RightMotorDiagnostic.LowVoltage
	            THEN
	                #sUDT_HMIStatus.MotorStatus.LowVoltage := TRUE;
	            END_IF;
	            
	        END_IF;
	    END_REGION
	    
	    REGION 4.2 - Error from controller for left motor             
	        IF #ii_MotorPositionId = #ci_Master_Left OR #ii_MotorPositionId = #ci_Slave_Left THEN
	            //Write errors to UDT_Status
	            IF #iUDT_AixInputsModule.LeftMotorDiagnostic.Overheat
	            THEN
	                #sUDT_HMIStatus.MotorStatus.Overheat := TRUE;
	            END_IF;
	            
	            #sUDT_HMIStatus.MotorStatus.MaxTorque := #iUDT_AixInputsModule.LeftMotorDiagnostic.MaxTorque;
	            
	            IF #iUDT_AixInputsModule.LeftMotorDiagnostic.ShortCircuit
	            THEN
	                #sUDT_HMIStatus.MotorStatus.ShortCircuit := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModule.LeftMotorDiagnostic.MotorNotConnected
	            THEN
	                #sUDT_HMIStatus.MotorStatus.MotorNotConnected := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModule.LeftMotorDiagnostic.Overload
	            THEN
	                #sUDT_HMIStatus.MotorStatus.Overload := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModule.LeftMotorDiagnostic.Stalled
	            THEN
	                #sUDT_HMIStatus.MotorStatus.Stalled := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModule.LeftMotorDiagnostic.BadHall
	            THEN
	                #sUDT_HMIStatus.MotorStatus.BadHall := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModule.LeftMotorDiagnostic.BoardOverheat
	            THEN
	                #sUDT_HMIStatus.MotorStatus.BoardOverheat := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModule.LeftMotorDiagnostic.OverVoltage
	            THEN
	                #sUDT_HMIStatus.MotorStatus.OverVoltage := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModule.LeftMotorDiagnostic.LowVoltage
	            THEN
	                #sUDT_HMIStatus.MotorStatus.LowVoltage := TRUE;
	            END_IF;
	        END_IF;
	    END_REGION
	    
	    REGION 4.3 - Collective Error
	        //If any error from controller motor ocursed then set error to TRUE
	        IF #iUDT_AixConfig.Motor.MotorExist
	        THEN
	            #sx_ErrorCMotor := #sUDT_HMIStatus.MotorStatus.Overheat OR
	            // #sUDT_HMIStatus.MotorError.MaxTorque OR
	            #sUDT_HMIStatus.MotorStatus.ShortCircuit OR
	            #sUDT_HMIStatus.MotorStatus.MotorNotConnected OR
	            #sUDT_HMIStatus.MotorStatus.Overload OR
	            #sUDT_HMIStatus.MotorStatus.Stalled OR
	            #sUDT_HMIStatus.MotorStatus.BadHall OR
	            #sUDT_HMIStatus.MotorStatus.BoardOverheat OR
	            #sUDT_HMIStatus.MotorStatus.OverVoltage OR
	            #sUDT_HMIStatus.MotorStatus.LowVoltage OR
	            #sUDT_HMIStatus.SpeedFeedbackError OR
	            #sUDT_HMIStatus.PNSlaveNotOnline OR
	            #sUDT_HMIStatus.PNSlaveError;
	        END_IF;
	    END_REGION
	    
	    REGION 4.4 - Controller general
	        
	        // Error Controller is two drives combined 
	        #sx_ErrorController :=
	        #iUDT_AixInputsModule.ConveyStopStatus.StopActiveLostConn OR
	        #iUDT_AixInputsModule.ConveyStopStatus.StopActiveLostPLC OR
	        #sx_ErrorCMotor OR
	        FALSE;
	        
	        // Check if a Controller has an error
	        #sx_ErrorActive := (#sx_ErrorController AND #iUDT_AixConfig.Motor.MotorExist)
	        OR #sFB_TimerOnOffDelayMCORunningFeedbackError.qx_DelayedSignal
	        OR #sFB_TimerOnOffDelayMCOSpeedFeedbackError.qx_DelayedSignal;
	        
	        // Internal error 
	        #sUDT_HMIStatus.InternalError := #sx_AixAvailableControler AND #sx_ErrorController;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 5 - Check if configuration is ok for commissioning purposes
	    
	    IF (
	        #iUDT_AixConfig.Motor.MotorExist                            // Check only if motor exists
	        AND (#iUDT_AixConfig.Motor.RampUpTime > 0)                  // If ramp up time is greater than 0
	        AND (#iUDT_AixConfig.Motor.RampDownTime > 0)                // and ramp down time is greater than 0
	        )
	        AND
	        (
	        #sUDT_PNDeviceController.PNDeviceFound
	        OR NOT #iUDT_AixConfig.Motor.MotorExist                       // and device found in PN structure
	        OR #ix_SimulationModeActive                                 // or simulation mode is active
	        )
	    THEN
	        #sx_ConfigurationError := FALSE;                                // Reset configuration error
	    ELSE
	        #sx_ConfigurationError := TRUE;                                 // Set configuration error
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Prepare output data for Controller
	    
	    REGION 6.1 - Set direction for motor
	        
	        // If Run forward is requested, set direction to forward
	        IF #iqUDT_ConveyorInterface.RunFwd
	            AND #iUDT_AixConfig.Motor.InterlockFwd
	        THEN
	            #sx_RunForward := TRUE;
	            #sx_RunReverse := FALSE;
	        END_IF;
	        
	        // If Run reverse is requested, set direction into reverse
	        IF #iqUDT_ConveyorInterface.RunRvs
	            AND #iUDT_AixConfig.Motor.InterlockRvs
	        THEN
	            #sx_RunReverse := TRUE;
	            #sx_RunForward := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    
	    REGION 6.3 - Stopping motor
	        
	        // Create trigger when direction signal falling
	        #sF_TRIG_RunFwd(CLK := #iqUDT_ConveyorInterface.RunFwd);
	        #sF_TRIG_RunRvs(CLK := #iqUDT_ConveyorInterface.RunRvs);
	        
	        // When no run signal is given the controllers should stop
	        IF (NOT #iqUDT_ConveyorInterface.RunRvs AND NOT #iqUDT_ConveyorInterface.RunFwd)
	            OR (#iqUDT_ConveyorInterface.RunRvs AND #iqUDT_ConveyorInterface.RunFwd)
	            OR (#sF_TRIG_RunRvs.Q)
	            OR (#sF_TRIG_RunFwd.Q)
	            OR #sx_ErrorActive
	        THEN
	            #sx_RunReverse := FALSE;
	            #sx_RunForward := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 6.5 - Check for enable operation signal
	        
	        //Enable operation if there is no error active and there is an given direction
	        #sx_EnableOperation := NOT #sx_ErrorActive
	        AND NOT #sx_ConfigurationError
	        AND (#sx_RunForward OR #sx_RunReverse);
	    END_REGION
	    
	    REGION 6.6 - Calculate acceleration and deceleration values
	        
	        //Motor
	        //Recalculating Acceleration (from ms to mm)
	        #si_MotorAcceleration := REAL_TO_INT((INT_TO_REAL(#iqUDT_ConveyorInterface.SpeedSetpoint) * #iUDT_AixConfig.Motor.Ratio / 2) * (UDINT_TO_REAL(#iUDT_AixConfig.Motor.RampUpTime) / 1000));
	        
	        //Recalculating Deceleration (from ms to mm) 
	        #si_MotorDeceleration := REAL_TO_INT((INT_TO_REAL(#iqUDT_ConveyorInterface.SpeedSetpoint) * #iUDT_AixConfig.Motor.Ratio / 2) * (UDINT_TO_REAL(#iUDT_AixConfig.Motor.RampDownTime) / 1000));
	        
	    END_REGION
	    
	END_REGION
	
	REGION 7 - Write outputs to controller  
	    // Clear speed setpoint when no run request or above direction request or is configuration error
	    IF #sx_EnableOperation
	    THEN
	        #sr_ActualSpeedSetpoint := INT_TO_REAL(#iqUDT_ConveyorInterface.SpeedSetpoint) / #iUDT_AixConfig.Motor.Ratio;
	    ELSE
	        #sr_ActualSpeedSetpoint := 0;
	    END_IF;
	    
	    REGION 7.1 - Controller Left motor
	        
	        IF #ii_MotorPositionId = #ci_Master_Left OR #ii_MotorPositionId = #ci_Slave_Left THEN
	            //Seting up speed for Left motor
	            #iqUDT_AixOutputsModule.LeftSetMotorSpeed := REAL_TO_INT(#sr_ActualSpeedSetpoint);
	            IF #iqUDT_AixOutputsModule.LeftSetMotorSpeed > #cr_MaximumOutput
	            THEN
	                // if actual value is greater than maximmu output value then write maximmu output value
	                #iqUDT_AixOutputsModule.LeftSetMotorSpeed := REAL_TO_INT(#cr_MaximumOutput);
	            END_IF;
	            
	            //Check if motor is in use, if yes set parameters from conveyor to the controller and motor
	            IF #iUDT_AixConfig.Motor.MotorExist
	            THEN
	                //Setting up run bit, acceleration, deceleration
	                #iqUDT_AixOutputsModule.LeftMotorControl.Run := #sx_EnableOperation
	                AND (#iqUDT_ConveyorInterface.RunFwd OR #iqUDT_ConveyorInterface.RunRvs);
	                
	                // Position setpoint
	                #iqUDT_AixOutputsModule.ServoControlDistanceLeft := #ii_PositionSetpoint;
	                
	                //Start positioning
	                #iqUDT_AixOutputsModule.ServoControlCommandLeft.%X1 := #ix_StartPositioning
	                AND #sx_EnableOperation
	                AND (#iqUDT_ConveyorInterface.RunFwd OR #iqUDT_ConveyorInterface.RunRvs);
	                
	                // Reset position
	                #sR_TRIG_ResetPosition(CLK := #ix_ResetPosition);
	                
	                // Reset position after every operation
	                IF #sR_TRIG_ResetPosition.Q THEN
	                    
	                    #iqUDT_AixOutputsModule.ServoControlCommandLeft.%X0 := TRUE;
	                    
	                END_IF;
	                
	                // End homing procedure when motor is reset
	                IF #iUDT_AixInputsModule.ServoStatusLeft.%X1 THEN
	                    
	                    #iqUDT_AixOutputsModule.ServoControlCommandLeft.%X0 := FALSE;
	                    
	                END_IF;
	                
	                
	                #iqUDT_AixOutputsModule.LeftSetMotorAccel := #si_MotorAcceleration;
	                #iqUDT_AixOutputsModule.LeftSetMotorDeccel := #si_MotorDeceleration;
	                
	                //Setting direction
	                IF (#sx_RunReverse AND NOT #iUDT_AixConfig.Motor.DirectionReversal)
	                    OR (#sx_RunForward AND #iUDT_AixConfig.Motor.DirectionReversal)
	                THEN
	                    #iqUDT_AixOutputsModule.LeftMotorControl.MotorDirection := 1;
	                ELSE
	                    #iqUDT_AixOutputsModule.LeftMotorControl.MotorDirection := 0;
	                END_IF;
	            ELSE
	                #iqUDT_AixOutputsModule.LeftMotorControl.Run := FALSE;
	            END_IF;
	        END_IF;
	    END_REGION
	    
	    REGION 7.2 - Controller right motor
	        IF #ii_MotorPositionId = #ci_Master_Right OR #ii_MotorPositionId = #ci_Slave_Right THEN
	            //Seting up speed for Right motor
	            #iqUDT_AixOutputsModule.RightSetMotorSpeed := REAL_TO_INT(#sr_ActualSpeedSetpoint);
	            IF #iqUDT_AixOutputsModule.RightSetMotorSpeed > #cr_MaximumOutput
	            THEN
	                // if actual value is greater than maximmu output value then write maximmu output value
	                #iqUDT_AixOutputsModule.RightSetMotorSpeed := REAL_TO_INT(#cr_MaximumOutput);
	            END_IF;
	            
	            //Check if motor is in use, if yes set parameters from conveyor to the controller and motor
	            IF #iUDT_AixConfig.Motor.MotorExist
	            THEN
	                //Setting up run bit, acceleration, deceleration
	                #iqUDT_AixOutputsModule.RightMotorControl.Run := #sx_EnableOperation
	                AND (#iqUDT_ConveyorInterface.RunFwd OR #iqUDT_ConveyorInterface.RunRvs);
	                
	                // Position setpoint
	                #iqUDT_AixOutputsModule.ServoControlDistanceRight := #ii_PositionSetpoint;
	                
	                //Start positioning
	                #iqUDT_AixOutputsModule.ServoControlCommandRight.%X1 := #ix_StartPositioning
	                AND #sx_EnableOperation
	                AND (#iqUDT_ConveyorInterface.RunFwd OR #iqUDT_ConveyorInterface.RunRvs);
	                
	                // Reset position
	                #sR_TRIG_ResetPosition(CLK := #ix_ResetPosition);
	                
	                // Reset position after every operation
	                IF #sR_TRIG_ResetPosition.Q THEN
	                    
	                    #iqUDT_AixOutputsModule.ServoControlCommandRight.%X0 := TRUE;
	                    
	                END_IF;
	                
	                // End homing procedure when motor is reset
	                IF #iUDT_AixInputsModule.ServoStatusRight.%X1 THEN
	                    
	                    #iqUDT_AixOutputsModule.ServoControlCommandRight.%X0 := FALSE;
	                    
	                END_IF;
	                
	                
	                #iqUDT_AixOutputsModule.RightSetMotorAccel := #si_MotorAcceleration;
	                #iqUDT_AixOutputsModule.RightSetMotorDeccel := #si_MotorDeceleration;
	                
	                //Setting direction
	                IF (#sx_RunReverse AND NOT #iUDT_AixConfig.Motor.DirectionReversal)
	                    OR (#sx_RunForward AND #iUDT_AixConfig.Motor.DirectionReversal)
	                THEN
	                    #iqUDT_AixOutputsModule.RightMotorControl.MotorDirection := 1;
	                ELSE
	                    #iqUDT_AixOutputsModule.RightMotorControl.MotorDirection := 0;
	                END_IF;
	            ELSE
	                #iqUDT_AixOutputsModule.RightMotorControl.Run := FALSE;
	            END_IF;
	        END_IF;
	    END_REGION
	    
	END_REGION
	
	REGION 8 - Reading actual speed
	    
	    REGION 8.1 - Left Motor
	        IF #ii_MotorPositionId = #ci_Master_Left OR #ii_MotorPositionId = #ci_Slave_Left THEN
	            //When motors are in constant speed use motor actual speed
	            IF #iUDT_AixConfig.Motor.MotorExist
	            THEN
	                #si_ActualSpeed := REAL_TO_INT(INT_TO_REAL(WORD_TO_INT(#iUDT_AixInputsModule.LeftMotorActualSpeed & #cw_ActualSpeedMask)) * #iUDT_AixConfig.Motor.Ratio);
	            ELSE
	                #si_ActualSpeed := 0;
	            END_IF;
	        END_IF;
	    END_REGION
	    
	    REGION 8.2 - Right Motor
	        IF #ii_MotorPositionId = #ci_Master_Right OR #ii_MotorPositionId = #ci_Slave_Right THEN
	            //When motors are in constant speed use motor actual speed
	            IF #iUDT_AixConfig.Motor.MotorExist
	            THEN
	                #si_ActualSpeed := REAL_TO_INT(INT_TO_REAL(WORD_TO_INT(#iUDT_AixInputsModule.RightMotorActualSpeed & #cw_ActualSpeedMask)) * #iUDT_AixConfig.Motor.Ratio);
	            ELSE
	                #si_ActualSpeed := 0;
	            END_IF;
	        END_IF;
	    END_REGION
	    
	    REGION 8.3 - Calculation
	        //Actual speed is in mm/s 
	        //Sets error signal if an motor is running for a longer time with a diferent speed than speed setpoint but after a certain time 
	        #sFB_TimerOnOffDelayMCORunningFeedbackError(iudi_OnDelayTime := #cudi_FeedbackErrorDelay,
	                                                    ix_SignalToDelay := #sr_ActualSpeedSetpoint <> 0.0 AND NOT (#si_ActualSpeed <> 0));
	        
	        //The motor should start running after specific time. If not the MCORunningFeedback error occured
	        #sFB_TimerOnOffDelayMCOSpeedFeedbackError(iudi_OnDelayTime := #cudi_FeedbackErrorDelay,
	                                                  ix_SignalToDelay := #sx_SpeedFeedbackError);
	        
	        IF #sFB_TimerOnOffDelayMCORunningFeedbackError.qx_DelayedSignal OR #sFB_TimerOnOffDelayMCOSpeedFeedbackError.qx_DelayedSignal
	        THEN
	            #sUDT_HMIStatus.SpeedFeedbackError := TRUE;
	        END_IF;
	        
	        //Sets signal for the time in which the motors are accelerating
	        #sFB_TimerOnOffDelayAcceleration(iudi_OnDelayTime := 0,
	                                         iudi_OffDelayTime := #iUDT_AixConfig.Motor.RampUpTime + #cudi_TimeOffsetSpeedmonitoring,
	                                         ix_SignalToDelay := #sR_TRIG_Running.Q,
	                                         ix_Enable := TRUE,
	                                         qx_DelayedSignal => #sx_Accelerating);
	        
	        
	        //If conveyor is running and runs forwad or backwards and is not accelerating, when any motor is running at a lower/greater speed than set speed then set an error
	        IF #iqUDT_ConveyorInterface.VFDRunning AND (#iqUDT_ConveyorInterface.RunFwd OR #iqUDT_ConveyorInterface.RunRvs) AND NOT #sx_Accelerating
	        THEN
	            //Check if the difference betwen acctual speed and set speed is bigger than deviation then set error
	            #sx_SpeedFeedbackError := #iUDT_AixConfig.Motor.SpeedSetpointWindow < (ABS(#si_ActualSpeed) - (#iqUDT_ConveyorInterface.SpeedSetpoint));
	        END_IF;
	        
	        
	        // Check IF speed setpoint is reached FOR motor
	        #sx_SpeedSetpointReached := (ABS(#si_ActualSpeed) >= ((#iqUDT_ConveyorInterface.SpeedSetpoint) - #iUDT_AixConfig.Motor.SpeedSetpointWindow))
	        AND (ABS(#si_ActualSpeed) <= ((#iqUDT_ConveyorInterface.SpeedSetpoint) + #iUDT_AixConfig.Motor.SpeedSetpointWindow));
	    END_REGION
	    
	END_REGION
	
	(* REGION 9 - Reading actual position
	    
	    REGION 9.1 - Left Motor
	        
	        #sx_LeftServoHomeHasBeenSet := #iUDT_AixInputsModule.ServoStatusLeft.%X1;
	        IF #ix_MotorPositionId = #ci_Left
	        THEN
	            IF #sx_LeftServoHomeHasBeenSet THEN
	                #si_LastLeftMotorPosition := 0;
	            END_IF;
	            // Add last position change to static memory
	            #si_LeftMotorPosition += - #si_LastLeftMotorPosition;
	            // Save last motor position
	            #si_LastLeftMotorPosition := #iUDT_AixInputsModule.ServoLocationLeft;
	            
	            // Copy displacement if motor position change is greater or equal to 1 cm and store rest
	            IF #si_LeftMotorPosition > 10 THEN
	                #iqUDT_ConveyorInterface.DeltaPosition := REAL_TO_INT(INT_TO_REAL(#si_LeftMotorPosition) * #iUDT_AixConfig.Motor.Ratio) / 10;
	                #si_LeftMotorPosition := #si_LeftMotorPosition MOD 10;
	            ELSE
	                #iqUDT_ConveyorInterface.DeltaPosition := 0;
	            END_IF;
	            
	            // allocate Motor Rotation status
	            #sb_MotorRotationStatus.%X0 := #iUDT_AixInputsModule.LeftMotorDiagnostic.MotorStatus1;
	            #sb_MotorRotationStatus.%X1 := #iUDT_AixInputsModule.LeftMotorDiagnostic.MotorStatus2;
	            
	            // Change direction sign if motor running reverse
	            IF ((#sb_MotorRotationStatus = #cb_MotorInCW) AND NOT #iUDT_AixConfig.Motor.DirectionReversal) OR
	                ((#sb_MotorRotationStatus = #cb_MotorInCCW) AND #iUDT_AixConfig.Motor.DirectionReversal)
	            THEN
	                
	                #iqUDT_ConveyorInterface.DeltaPosition *= -1;
	                
	            END_IF;
	            
	            // Motor positioned
	            #qx_Positioned := #iUDT_AixInputsModule.ServoStatusLeft.%X0;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 9.2 - Right motor 
	        #sx_RightServoHomeHasBeenSet := #iUDT_AixInputsModule.ServoStatusRight.%X1;
	        IF #ix_MotorPositionId = #ci_Right
	        THEN
	            IF #sx_RightServoHomeHasBeenSet THEN
	                #si_LastRightMotorPosition := 0;
	            END_IF;
	            // Add last position change to static memory
	            #si_RightMotorPosition += - #si_LastRightMotorPosition;
	            // Save last motor position
	            #si_LastRightMotorPosition := #iUDT_AixInputsModule.ServoLocationRight;
	            
	            // Copy displacement if motor position change is greater or equal to 1 cm and store rest
	            IF #si_RightMotorPosition > 10 THEN
	                #iqUDT_ConveyorInterface.DeltaPosition := REAL_TO_INT(INT_TO_REAL(#si_RightMotorPosition) * #iUDT_AixConfig.Motor.Ratio) / 10;
	                #si_RightMotorPosition := #si_RightMotorPosition MOD 10;
	            ELSE
	                #iqUDT_ConveyorInterface.DeltaPosition := 0;
	            END_IF;
	            
	            // allocate Motor Rotation status
	            #sb_MotorRotationStatus.%X0 := #iUDT_AixInputsModule.RightMotorDiagnostic.MotorStatus1;
	            #sb_MotorRotationStatus.%X1 := #iUDT_AixInputsModule.RightMotorDiagnostic.MotorStatus2;
	            
	            // Change direction sign if motor running reverse
	            IF ((#sb_MotorRotationStatus = #cb_MotorInCW) AND NOT #iUDT_AixConfig.Motor.DirectionReversal) OR
	                ((#sb_MotorRotationStatus = #cb_MotorInCCW) AND #iUDT_AixConfig.Motor.DirectionReversal)
	            THEN
	                
	                #iqUDT_ConveyorInterface.DeltaPosition *= -1;
	                
	            END_IF;
	            
	            // Motor positioned
	            #qx_Positioned := #iUDT_AixInputsModule.ServoStatusRight.%X0;
	            
	        END_IF;
	        
	    END_REGION
	    
	    
	END_REGION *)
	
	REGION 9 - Reading actual position
	    
	    REGION 9.1 - Left motor 
	        
	        IF #ii_MotorPositionId = #ci_Master_Left OR #ii_MotorPositionId = #ci_Slave_Left
	        THEN
	            IF #iUDT_AixInputsModule.ServoLocationLeft = 0 THEN
	                #si_LastLeftMotorPosition := 0;
	            END_IF;
	            // Add last position change to static memory
	            #si_LeftMotorPosition += ABS(ABS(#iUDT_AixInputsModule.ServoLocationLeft) - ABS(#si_LastLeftMotorPosition));
	            // Save last motor position
	            #si_LastLeftMotorPosition := #iUDT_AixInputsModule.ServoLocationLeft;
	            
	            // Copy delta position if motor position change is greater or equal to 1 cm and store rest
	            IF #si_LeftMotorPosition > 10 THEN
	                IF #ii_MotorPositionId = #ci_Master_Left THEN
	                    #iqUDT_ConveyorInterface.DeltaPosition := REAL_TO_INT(INT_TO_REAL(#si_LeftMotorPosition) * #iUDT_AixConfig.Motor.Ratio) / 10;
	                END_IF;
	                #si_LeftMotorPosition := #si_LeftMotorPosition MOD 10;
	            ELSE
	                IF #ii_MotorPositionId = #ci_Master_Left THEN
	                    #iqUDT_ConveyorInterface.DeltaPosition := 0;
	                END_IF;
	            END_IF;
	            // Change direction sign if motor running reverse
	            IF #iUDT_AixInputsModule.LeftMotorDiagnostic.MotorStatus1 AND NOT #iUDT_AixInputsModule.LeftMotorDiagnostic.MotorStatus2 AND NOT #iUDT_AixConfig.Motor.DirectionReversal
	                OR NOT #iUDT_AixInputsModule.LeftMotorDiagnostic.MotorStatus1 AND #iUDT_AixInputsModule.LeftMotorDiagnostic.MotorStatus2 AND #iUDT_AixConfig.Motor.DirectionReversal
	            THEN
	                IF #ii_MotorPositionId = #ci_Master_Left THEN
	                    #iqUDT_ConveyorInterface.DeltaPosition *= -1;
	                END_IF;
	            END_IF;
	            
	            // Motor positioned
	            #qx_Positioned := #iUDT_AixInputsModule.ServoStatusLeft.%X0;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 9.2 - Right motor 
	        
	        IF #ii_MotorPositionId = #ci_Master_Right OR #ii_MotorPositionId = #ci_Slave_Right
	        THEN
	            IF #iUDT_AixInputsModule.ServoLocationRight = 0 THEN
	                #si_LastRightMotorPosition := 0;
	            END_IF;
	            // Add last position change to static memory
	            #si_RightMotorPosition += ABS(ABS(#iUDT_AixInputsModule.ServoLocationRight) - ABS(#si_LastRightMotorPosition));
	            // Save last motor position
	            #si_LastRightMotorPosition := #iUDT_AixInputsModule.ServoLocationRight;
	            
	            // Copy delta position if motor position change is greater or equal to 1 cm and store rest
	            IF #si_RightMotorPosition > 10 THEN
	                IF #ii_MotorPositionId = #ci_Master_Right THEN
	                    #iqUDT_ConveyorInterface.DeltaPosition := REAL_TO_INT(INT_TO_REAL(#si_RightMotorPosition) * #iUDT_AixConfig.Motor.Ratio) / 10;
	                END_IF;
	                #si_RightMotorPosition := #si_RightMotorPosition MOD 10;
	            ELSE
	                IF #ii_MotorPositionId = #ci_Master_Right THEN
	                    #iqUDT_ConveyorInterface.DeltaPosition := 0;
	                END_IF;
	            END_IF;
	            // Change direction sign if motor running reverse
	            IF #iUDT_AixInputsModule.RightMotorDiagnostic.MotorStatus1 AND NOT #iUDT_AixInputsModule.RightMotorDiagnostic.MotorStatus2 AND NOT #iUDT_AixConfig.Motor.DirectionReversal
	                OR NOT #iUDT_AixInputsModule.RightMotorDiagnostic.MotorStatus1 AND #iUDT_AixInputsModule.RightMotorDiagnostic.MotorStatus2 AND #iUDT_AixConfig.Motor.DirectionReversal
	            THEN
	                IF #ii_MotorPositionId = #ci_Master_Right THEN
	                    #iqUDT_ConveyorInterface.DeltaPosition *= -1;
	                END_IF;
	            END_IF;
	            
	            // Motor positioned
	            #qx_Positioned := #iUDT_AixInputsModule.ServoStatusRight.%X0;
	            
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	
	REGION 10 - Copy signals to interface DB and to status output UDT
	    
	    REGION 10.1 - Motor
	        
	        // Create internal error status
	        // Write Conveyor interface bits only if it is a Master
	        IF #ii_MotorPositionId = #ci_Master_Left OR #ii_MotorPositionId = #ci_Master_Right THEN
	            
	            #iqUDT_ConveyorInterface.VFDRunning := #sx_AixAvailableControler AND
	            (#si_ActualSpeed <> 0);                 // Write true on output Conveyor interface structure if Ai2's are in operation and motor is turning 
	            
	            #iqUDT_ConveyorInterface.VFDatSpeed := #sx_SpeedSetpointReached AND
	            #sx_AixAvailableControler AND
	            #si_ActualSpeed <> 0 AND
	            NOT #sx_SpeedFeedbackError;             // Copy setpoint speed reached state from static to the output conveyor interface structure
	            
	            #iqUDT_ConveyorInterface.InternalWarningVFD := #sUDT_HMIStatus.PNSlaveWarning;                                                       // Set the internal warning bit if any warning is active
	            
	            #iqUDT_ConveyorInterface.InternalErrorVFD := #sx_ErrorCMotor;                   // Set the internal error bit if any fault is active 
	            
	            #iqUDT_ConveyorInterface.ActualSpeed := ABS(#si_ActualSpeed);                   // Copy the calculated value to the output
	            
	            #iqUDT_ConveyorInterface.ConfigurationError := #sx_ConfigurationError;          // Copy the calculated value to the output
	            
	        END_IF;
	        
	        
	    END_REGION
	    
	    REGION 10.2 - Move error status TO HMI Status 
	        
	        // Copy error status to output
	        #qUDT_HMIStatus := #sUDT_HMIStatus;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 11 - Statistic
	    
	    REGION 11.1 - General
	        // Statement section REGION
	        #sx_GeneralStatisticsReset := #iqUDT_ConveyorInterface.ResetStatistics;
	    END_REGION
	    
	    // Create trigger on error and create statistics for profinet slave not online
	    #sR_TRIG_PNSlaveNotOnline(CLK := #sUDT_HMIStatus.PNSlaveNotOnline);                 // Detect the rising edge of the error
	    
	    IF #sx_GeneralStatisticsReset OR #sUDT_HMIStatus.PNSlaveNotOnline
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #sx_GeneralStatisticsReset,
	                        ix_Activate := #sUDT_HMIStatus.PNSlaveNotOnline,
	                        ix_RTrigActivate := #sR_TRIG_PNSlaveNotOnline.Q,
	                        iqUDT_Statistics := #iqUDT_MCOStatistics.PNSlaveNotOnline);
	        
	        #iqUDT_MCOStatistics.PNSlaveNotOnline := #iqUDT_MCOStatistics.PNSlaveNotOnline;
	    END_IF;
	    
	    // Create trigger on error and create statistics for profinet slave error
	    #sR_TRIG_PNSlaveError(CLK := #sUDT_HMIStatus.PNSlaveError);                                                                          // Detect the rising edge of the error
	    
	    IF #sx_GeneralStatisticsReset OR #sUDT_HMIStatus.PNSlaveError
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #sx_GeneralStatisticsReset,
	                        ix_Activate := #sUDT_HMIStatus.PNSlaveError,
	                        ix_RTrigActivate := #sR_TRIG_PNSlaveError.Q,
	                        iqUDT_Statistics := #iqUDT_MCOStatistics.PNSlaveError);
	        
	        #iqUDT_MCOStatistics.PNSlaveError := #iqUDT_MCOStatistics.PNSlaveError;
	    END_IF;
	    
	    
	    // Create trigger on error and create statistics for MCO communication error
	    #sR_TRIG_CommunicationErrorMCO(CLK := #qUDT_HMIStatus.CommunicationErrorVFD);            // Detect the rising edge of the error
	    
	    IF #sx_GeneralStatisticsReset OR #qUDT_HMIStatus.CommunicationErrorVFD
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #sx_GeneralStatisticsReset,
	                        ix_Activate := #qUDT_HMIStatus.CommunicationErrorVFD,
	                        ix_RTrigActivate := #sR_TRIG_CommunicationErrorMCO.Q,
	                        iqUDT_Statistics := #iqUDT_MCOStatistics.CommunicationErrorMovikit);
	        
	    END_IF;
	    
	    REGION 11.1 - Motor       
	        
	        // Create trigger on error and create statistics for internal MCO Error
	        #sR_TRIG_MCOInternalError(CLK := #sUDT_HMIStatus.InternalError);         // Detect the rising edge of the error
	        
	        IF #iqUDT_ConveyorInterface.ResetStatistics OR #sUDT_HMIStatus.InternalError
	        THEN
	            
	            "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                            ix_Activate := #sUDT_HMIStatus.InternalError,
	                            ix_RTrigActivate := #sR_TRIG_MCOInternalError.Q,
	                            iqUDT_Statistics := #iqUDT_MCOStatistics.VFDInternalError);
	            
	        END_IF;
	        
	        // Create trigger on running signal and create statistics for running status
	        #sR_TRIG_Running(CLK := #iqUDT_ConveyorInterface.VFDRunning);                           // Detect the rising edge of the signal
	        
	        IF #iqUDT_ConveyorInterface.ResetStatistics OR #iqUDT_ConveyorInterface.VFDRunning
	        THEN
	            
	            "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                            ix_Activate := #iqUDT_ConveyorInterface.VFDRunning,
	                            ix_RTrigActivate := #sR_TRIG_Running.Q,
	                            iqUDT_Statistics := #iqUDT_MCOStatistics.Running);
	        END_IF;
	        
	        
	    END_REGION
	    REGION 12 Status bit allocation
	        "FC_BitAllocation"(ix_Bit0 := #qUDT_HMIStatus.SpeedFeedbackError,
	                           ix_Bit1 := #qUDT_HMIStatus.InternalWarning,
	                           ix_Bit2 := #qUDT_HMIStatus.InternalError,
	                           ix_Bit3 := #qUDT_HMIStatus.CommunicationErrorVFD,
	                           ix_Bit4 := #qUDT_HMIStatus.PNSlaveNotOnline,
	                           ix_Bit5 := #qUDT_HMIStatus.PNSlaveError,
	                           ix_Bit6 := #qUDT_HMIStatus.PNSlaveWarning,
	                           ix_Bit7 := FALSE,
	                           ix_Bit8 := FALSE,
	                           ix_Bit9 := FALSE,
	                           ix_Bit10 := FALSE,
	                           ix_Bit11 := FALSE,
	                           ix_Bit12 := FALSE,
	                           ix_Bit13 := FALSE,
	                           ix_Bit14 := FALSE,
	                           ix_Bit15 := FALSE,
	                           ix_Bit16 := FALSE,
	                           ix_Bit17 := FALSE,
	                           ix_Bit18 := FALSE,
	                           ix_Bit19 := FALSE,
	                           ix_Bit20 := FALSE,
	                           ix_Bit21 := FALSE,
	                           ix_Bit22 := FALSE,
	                           ix_Bit23 := FALSE,
	                           ix_Bit24 := FALSE,
	                           ix_Bit25 := FALSE,
	                           ix_Bit26 := FALSE,
	                           ix_Bit27 := FALSE,
	                           ix_Bit28 := FALSE,
	                           ix_Bit29 := FALSE,
	                           ix_Bit30 := FALSE,
	                           ix_Bit31 := FALSE,
	                           qdw_Dword => #qUDT_HMIStatus.ControllerStatus);
	    END_REGION
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_GateSection"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 213
// END_ATTRIBUTES
   VAR_INPUT 
      ix_GateOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // When TRUE gate is open, when FALSE gate is close
      ix_OperatorButton { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // When TRUE then operator button is pressed
      iudi_TimeOnDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Time on delay to enable the horn when the gate is closed
   END_VAR

   VAR_OUTPUT 
      qx_Horn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // When TRUE enable horn sound
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_GateStatus";   // HMI status structure
   END_VAR

   VAR 
      sFB_GateIsClosed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer on delay to enable the horn signal when the gate is closed
      sR_TRIG_OperatorButton {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger operator button
      sx_GateClosedAndNoOperatorPresent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Auxiliary variable TRUE when the gare is closed and no operator is present
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	26/01/2022  | 0.0       | M. Piela      | first release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	 *)
	
	REGION 1 - Push button trigger
	    
	    #sR_TRIG_OperatorButton(CLK := #ix_OperatorButton);  //Operator button
	    
	END_REGION
	
	REGION 2 - Gate open time counting
	    
	    //Enable the horn signal when the gate is closed for 10 minutes
	    #sFB_GateIsClosed(iudi_OnDelayTime := #iudi_TimeOnDelay,
	                      ix_SignalToDelay := NOT #ix_GateOpen AND NOT #sR_TRIG_OperatorButton.Q,
	                      ix_Enable := TRUE,
	                      qx_DelayedSignal => #sx_GateClosedAndNoOperatorPresent);
	    
	END_REGION
	
	REGION 3 - Status
	    
	    #qUDT_HMIStatus.Specific.GateClosed := NOT #ix_GateOpen;
	    #qUDT_HMIStatus.Specific.GateClosedAndNoOperatorPresent := #sx_GateClosedAndNoOperatorPresent;
	    
	    IF NOT #qUDT_HMIStatus.Specific.GateClosed
	    THEN
	        #qUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".GateOpen;
	    END_IF;
	    
	    IF #qUDT_HMIStatus.Specific.GateClosed
	    THEN
	        #qUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".GateClosed;
	    END_IF;
	    
	    IF #qUDT_HMIStatus.Specific.GateClosedAndNoOperatorPresent
	    THEN
	        #qUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".GateClosedAndNoOperatorPresent;
	    END_IF;
	    
	    
	END_REGION
	
	
	REGION 4 - Output enable
	    
	    #qx_Horn := #sx_GateClosedAndNoOperatorPresent;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_Inching"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 214
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_InchingConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_InchingConfiguration";   //  Inching configuration structure
      iUDT_FeedConveyorConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorConfiguration";   //  Feed conveyor configuration structure
      iUDT_ConveyorConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorConfiguration";   //  Conveyor configuration structure
      ii_PECEoSDistanceUpstream { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //  Distance between photo eye and the end of conveyor [mm]
      ii_PECEoSDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //  Distance between photo eye and the end of conveyor [mm]
      ix_PECEoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  PEC signal End of Section
      ix_Release { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Release button
      ix_Clockpulse1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Clock pulse to flash when emptying
      ix_Clockpulse2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Clock pulse to flash when emptied
   END_VAR

   VAR_OUTPUT 
      qx_ExternalRequestHold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  External output to request conveyor hold
      qx_ExternalRequestDieBack { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  External output to request die back
      qx_IndicationSignal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Output to indication: flashing with clockpuls 1 then emptying, flashing with clockpuls 2 then emptied, continuously on then full
   END_VAR

   VAR_IN_OUT 
      iqUDT_FeedConveyor : "UDT_ConveyorInterface";   //  Feed conveyor interface structure
      iqUDT_InchingConveyor : "UDT_ConveyorInterface";   //  Inching conveyor interface structure
      iqUDT_HandShakeUp : "UDT_ConveyorHandshake";   //  Conveyor handshake structure
   END_VAR

   VAR 
      sFB_ButtonTimerFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //  Delaytime of the release button to set the conveyor full
      sFB_ButtonTimerRelease { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //  Delaytime of the release button to release the conveyor to emty
      sR_TRIG_RTSUp {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger ready to send upstream
      sR_TRIG_TIP {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger tip
      sF_TRIG_PECEoS {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //  Falling edge trigger PEC EoS
      sdi_FirstParcelPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //  The position the front of the first parcel is where '0' is end of conveyor [cm]
      sdi_ActualGapCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //  The number of centimeters the conveyor has to run to complete the gap
      sdi_ActualRunningEmpty { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //  The number of centimeters the conveyor has to run to run empty
      sdi_ActualTIPDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //  Actual distance befor TIP will be activated
      sdi_FullDegree { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //  Filling degree
      sx_Emptied { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Inching conveyor condition is emptied, wait to start
      sx_Inching { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Inching conveyor condition is inching
      sx_Full { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Inching conveyor condition is full
      sx_Emptying { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Inching conveyor condition is emptying
      sx_Run { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Run inching conveyor (release hold)
      sx_FirstParcel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  First parcel entering the inching conveyor
      sx_UpdateFirst { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  The first parcel has entered the PEC
      sx_ReleaseButton { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Release button is pressed to set Full condidition, first release the button to set Release function
   END_VAR

   VAR CONSTANT 
      ci_Startvalue : Int := 2;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	28/10/2019  | 3.0       | F.Baten       | first release TIA 15
	14/01/2020  | 3.1       | F.Baten       | Updatet "UDT_ConveyorConfiguration"
	22/04/2020  | 3.2       | L.Klar        | Adjusted after conveyor UDT's change
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Triggers
	    
	    // Beginning of transporting the parcel in.
	    #sR_TRIG_TIP(CLK := #iqUDT_HandShakeUp.TIP);
	    
	    // The upstream conveyor is ready to transport.
	    #sR_TRIG_RTSUp(CLK := #iqUDT_HandShakeUp.RTS);
	    
	    // Falling edge trigger PEC EoS.
	    #sF_TRIG_PECEoS(CLK := #ix_PECEoS);
	    
	END_REGION
	
	REGION 2 - Set distances
	    
	    REGION 2.1 - Set the desired gap distance when the TIP starts.
	        
	        // The actual starting of the inching conveyor is the offset earlier so that has to be deducted from the desired gap.
	        IF #sR_TRIG_TIP.Q
	        THEN
	            // Distance the parcel starts at the tipping position is smaller than the disired gapsize.
	            IF (#iUDT_FeedConveyorConfiguration.Forward_Direction.PEC_EoSDistanceOffset / 10) < #iUDT_InchingConfiguration.GapSize
	            THEN
	                // Then decrease the gapsize (to be done at the inching conveyor) with the offset because both conveyors are running when the TIP is active.
	                #sdi_ActualGapCounter :=
	                #iUDT_InchingConfiguration.GapSize -
	                (#iUDT_FeedConveyorConfiguration.Forward_Direction.PEC_EoSDistanceOffset / 10) -
	                #ci_Startvalue;
	            ELSE
	                // The distance for the gap is already covered by the offset distance.
	                #sdi_ActualGapCounter := 0;
	            END_IF;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 2.2 - Track the parcel on the upstream conveyor
	        
	        //  Set the distance from the trigger signal until the point the TIP would start.
	        IF #sR_TRIG_RTSUp.Q
	        THEN
	            // PEC distance - Offset = TIP distance on the upstream conveyor.
	            #sdi_ActualTIPDistance := (#ii_PECEoSDistanceUpstream - #iUDT_FeedConveyorConfiguration.Forward_Direction.PEC_EoSDistanceOffset) / 10;
	            IF #sdi_ActualTIPDistance < 0
	            THEN
	                #sdi_ActualTIPDistance := 0;
	            END_IF;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 2.3 - Update the first parcel position
	        
	        IF #sF_TRIG_PECEoS.Q
	            AND NOT #sx_UpdateFirst
	        THEN
	            // Set the position of the PEC as the first parcel position.
	            #sdi_FirstParcelPosition := #ii_PECEoSDistance / 10;
	            // First parcel is updated.
	            #sx_UpdateFirst := TRUE;
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 3 - Button
	    
	    // When the button is pressed for a longer time it is accepted as setting full action.
	    #sFB_ButtonTimerRelease(iudi_OnDelayTime := #iUDT_InchingConfiguration.ButtonReleaseDelayTime,
	                            iudi_OffDelayTime := 0,
	                            ix_SignalToDelay := #sx_Full AND #ix_Release AND NOT #sx_ReleaseButton);
	    
	    // When the button is pressed for a longer time it is accepted as release action.
	    #sFB_ButtonTimerFull(iudi_OnDelayTime := #iUDT_InchingConfiguration.ButtonReleaseDelayTime,
	                         iudi_OffDelayTime := 0,
	                         ix_SignalToDelay := #sx_Inching AND #ix_Release);
	    
	    #sx_ReleaseButton := (#sx_Inching
	    OR #sx_ReleaseButton)
	    AND #ix_Release;
	    
	    // When full, the release is started by the release button.
	    IF #sx_Full
	        AND #sFB_ButtonTimerRelease.qx_DelayedSignal
	    THEN
	        #sx_Emptying := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Displacement update
	    
	    REGION 4.1 - Update the gap between the parcel and the beginning of the conveyor
	        
	        // The Inching conveyor is allowed to run and not transferring to upstream and the gapcounter is still bigger than '0'.
	        IF #sx_Run
	            AND NOT #iqUDT_HandShakeUp.TIP
	            AND #sdi_ActualGapCounter > 0
	        THEN
	            // Decrease the counter by the conveyors displacement.
	            #sdi_ActualGapCounter -= #iqUDT_InchingConveyor.Displacement;
	            IF #sdi_ActualGapCounter < 0
	            THEN
	                #sdi_ActualGapCounter := 0;
	            END_IF;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 4.2 - Update the first parcel position (the head OF the cue)
	        
	        // The counter is still bigger than '0'.
	        IF #sdi_FirstParcelPosition > 0
	        THEN
	            // Decrease the counter by the conveyors displacement.
	            #sdi_FirstParcelPosition -= #iqUDT_InchingConveyor.Displacement;
	            IF #sdi_FirstParcelPosition < 0
	            THEN
	                #sdi_FirstParcelPosition := 0;
	            END_IF;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 4.3 - Update running empty distance
	        
	        // The counter is still bigger than '0'.
	        IF #sdi_ActualRunningEmpty > 0
	            AND #sx_Emptying
	        THEN
	            // Decrease the counter by the conveyors displacement.
	            #sdi_ActualRunningEmpty -= #iqUDT_InchingConveyor.Displacement;
	            IF #sdi_ActualRunningEmpty < 0
	            THEN
	                #sdi_ActualRunningEmpty := 0;
	            END_IF;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 4.4 - Update the parcel position on the upstream conveyor
	        
	        // The counter is still bigger than '0'.
	        IF #sdi_ActualTIPDistance > 0
	        THEN
	            // Decrease the counter by the conveyors displacement.
	            #sdi_ActualTIPDistance -= #iqUDT_FeedConveyor.Displacement;
	            IF #sdi_ActualTIPDistance < 0
	            THEN
	                #sdi_ActualTIPDistance := 0;
	            END_IF;
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	
	REGION 5 - Status mode
	    
	    (* The positions are counting back from the maximal to '0'.
	     When the inching conveyor is full, set the running empty distance. *)
	    IF (#sdi_FirstParcelPosition < #iUDT_InchingConfiguration.MaximalFillingPosition
	        AND #sx_FirstParcel
	        AND NOT #iqUDT_HandShakeUp.TIP
	        AND NOT #sx_Full)
	        OR (#sdi_FirstParcelPosition < 2
	        AND #sx_FirstParcel
	        AND NOT #sx_Full)
	        OR #sFB_ButtonTimerFull.qx_DelayedSignal
	    THEN
	        // The length of the conveyor is the run empty length.
	        #sdi_ActualRunningEmpty := #iUDT_ConveyorConfiguration.Common.Length / 10;
	        #sx_Full := TRUE;
	        #sx_Inching := FALSE;
	    END_IF;
	    
	    // Running epmty and the distance is done.
	    IF #sx_Emptying
	        AND #sdi_ActualRunningEmpty <= 0
	    THEN
	        #sx_UpdateFirst := FALSE;
	        #sx_FirstParcel := FALSE;
	        #sx_Emptying := FALSE;
	        #sx_Full := FALSE;
	        #sx_Emptied := TRUE;
	    END_IF;
	    
	    // Acknowledge from operator to start again.
	    IF #sx_Emptied
	        AND (#ix_Release
	        OR NOT #iUDT_InchingConfiguration.WaitForStartConf)
	    THEN
	        #sx_Inching := TRUE;
	        #sx_Emptied := FALSE;
	    END_IF;
	    
	    // Activate first parcel.
	    IF #sx_Inching
	        AND NOT #sx_FirstParcel
	        AND #iqUDT_HandShakeUp.TIP
	    THEN
	        // Set the position the parcel actual is. 
	        #sdi_FirstParcelPosition := (#iUDT_ConveyorConfiguration.Common.Length + #iUDT_FeedConveyorConfiguration.Forward_Direction.PEC_EoSDistanceOffset) / 10;
	        // Indicating the first parcel is detected.
	        #sx_FirstParcel := TRUE;
	    END_IF;
	    
	    // If no mode is active the conveyor is set to full so an operator has to check and release.
	    IF NOT #sx_Emptied AND NOT #sx_Emptying AND NOT #sx_Full AND NOT #sx_Inching
	    THEN
	        #sx_Full := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Hold inching conveyor
	    
	    (* Run inching conveyor
	       - inching mode - RTS signal and parcel is 1 cm before it will stop
	                      - Gap is not there yet
	       - running empty *)
	    #sx_Run :=
	    #sx_Inching
	    AND (((#iqUDT_HandShakeUp.RTS OR #iqUDT_HandShakeUp.TIP)
	    AND (#sdi_ActualTIPDistance < #ci_Startvalue)
	    OR #iqUDT_HandShakeUp.RTS
	    AND NOT (#iqUDT_FeedConveyor.RunFwd OR #iqUDT_FeedConveyor.RunRvs))
	    OR #sdi_ActualGapCounter > 1)
	    OR #sx_Emptying;
	    
	    #qx_ExternalRequestHold := NOT #sx_Run;
	    
	END_REGION
	
	REGION 7 - External dieback signal    
	    
	    (* Stop feeding in new parcels 
	       - Gap has to be there
	       - Conveyor is full
	       - Conveyor is running empty *)
	    #qx_ExternalRequestDieBack :=
	    (#iqUDT_HandShakeUp.RTS
	    AND (#sdi_ActualGapCounter > 1)
	    AND NOT #iqUDT_HandShakeUp.TIP)
	    OR #sx_Full
	    OR #sx_Emptying;
	    
	END_REGION
	
	REGION 8 - Signal
	    
	    // Signalling full and emptying.
	    #qx_IndicationSignal :=
	    (NOT #sx_Emptying
	    AND #sx_Full)
	    OR (#sx_Emptying
	    AND #ix_Clockpulse1)
	    OR (#sx_Emptied
	    AND #ix_Clockpulse2);
	    
	    // Percentage of conveyor used.
	    #sdi_FullDegree := 100 - (#sdi_FirstParcelPosition / (#iUDT_ConveyorConfiguration.Common.Length / 1000));
	    
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_RIOVSU"
TITLE = FB_RIOVSU
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 226
// END_ATTRIBUTES
   VAR_INPUT 
      is_ET200spPNDeviceName { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   //   Name of the ET200sp device
      ix_400VintOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE if internal circuit breaker 400V is ok
      ix_400VextOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE if external 400V Main cabinet is ok
      ix_BrakeSupplyOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE if circuit breaker of brake power supply is ok
      ix_ThermalBrake { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when No thermal error
      ix_24VOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when 24V power supply to RIO is ok
      ix_SimulationModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   True when Simulation mode active
      ix_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when  hardware is Ok
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_RIOVSUStatus";   //   HMI status structure
   END_VAR

   VAR_IN_OUT 
      iqUDT_Statistics : "UDT_RIOVSUStatistics";   //   Statistics structure
      iqUDT_VSUInterface : "UDT_VSUInterface";   //   Interface RIO and VSU
   END_VAR

   VAR 
      sUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RIOVSUStatus";   //   HMI status structure
      sUDT_PNDevice { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PNDevice";   //   PN device structure
      sa_PNPortsStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..8] of Bool;   // TRUE when specific port has an error
      sFB_TimerOnOffDelayCheckSupply { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //   MHS "TimerOnOffDelay" - to delay time for VFD supply contactor
      sR_TRIG_Int400VCBError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge for trigger 400v internal error
      sR_TRIG_Int24VError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge for trigger 24v internal error
      sR_TRIG_BrakeCBerror {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge for trigger brake circuit breaker tripped
      sR_TRIG_BrakeThermError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge for trigger brake thermal error
      sR_TRIG_DeviceFound {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge for trigger scan modules
      sR_TRIG_PNSlaveNotOnline {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge for trigger Profinet slave not online statistics
      sR_TRIG_PNSlaveError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge for trigger Profinet slave error statistics
      si_ModuleStateReturn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Status structure
      si_NrOfModulesWithError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Number of the faulty modules
      sx_PNSlaveOnline { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Profinet device is online and error free
      sx_PowerOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   True = External Power OK
      sx_ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Commissioning: configuration error
   END_VAR

   VAR_TEMP 
      ta_Configured : Array[0..127] of Bool;   //   Configured modules array
      ta_Exist : Array[0..127] of Bool;   //   Existing modules array
      ta_Error : Array[0..127] of Bool;   //   Faulty modules array
      ti_NrOfModule : Int;   //   Number of current module
      ti_DiagArraySize : Int;   //   Diagnostic array size
   END_VAR

   VAR CONSTANT 
      cui_ConfiguredModulesMode : UInt := 1;   //   Mode selector: 1 = Configured modules scan mode
      cui_ModuleErrorMode : UInt := 2;   //   Mode selector: 2 = Existing modules scan mode
      cui_ExistingModulesMode : UInt := 4;   //   Mode selector: 3 = Module Error scan mode
      ci_PowerSupplyDelayTime : UInt := 4000;   //   Power supply delay time
      ci_NumberOfProfinetPorts : Int := 2;   // Number of Profinet ports in device
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	03/09-2019  | 2.1       | F.Baten       | first release MHS TIA 15.1
	23/09/2019  | 2.2       | F.Baten       | Changed region 1 contents to FC
	12/10/2019  | 2.3       | L. Klar       | Updated status structure
	14/10/2019  | 2.4       | S. Deulkar    | Added equipment control structure and created 
	                                        | region for status
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1   
	29/11/2019  | 3.1       | F.Baten       | Updated interface to VSU
	04/12/2019  | 3.2       | F.Baten       | Region 3: ix_SimulationModeActive rearranged to correct position
	09/12/2019  | 3.3       | F.Baten       | Region 5: added #ix_SimulationModeActive to PNDeviceOk
	04/03/2020  | 3.4       | F.Baten       | Updated errors and warnings and interface to VSU
	06/08/2020  | 3.5       | L.Klar        | Initialize the #si_NrOfModulesWithError on the reset
	03/11/2020  | 3.9       | K.Pokorski    | Profinet ports diagnostics added 
	02/08/2021  | 3.5       | S. Deulkar    | Added logic to reset error when 24V is not okay. 
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Get Device Profinet information
	    
	    "FC_GetDevicePN"(is_PNDeviceName := #is_ET200spPNDeviceName,
	                     ix_SimulationModeActive := #ix_SimulationModeActive,
	                     iqUDT_PND := #sUDT_PNDevice);
	    
	    
	    "FC_GetPNPortStatus"(ii_NumberOfPorts := #ci_NumberOfProfinetPorts,
	                         iUDT_DevicePNInfo := #sUDT_PNDevice,
	                         qa_PortFault => #sa_PNPortsStatus);
	    
	END_REGION
	
	REGION 2 - Reset errors
	    // reset Profinet Slave error/not online  
	    IF #iqUDT_VSUInterface.InternalErrorReset
	        OR NOT #ix_24VOk
	    THEN
	        #sUDT_HMIStatus."400VCircuitBreaker" := FALSE;
	        #sUDT_HMIStatus.BrakeCircuitBreaker := FALSE;
	        #sUDT_HMIStatus.BrakeThermalError := FALSE;
	        #sUDT_HMIStatus.PNSlaveNotOnline := FALSE;
	        #sUDT_HMIStatus.PNSlaveError := FALSE;
	        #sUDT_HMIStatus."24VPowersupplyError" := FALSE;
	        #sUDT_HMIStatus.PNSlaveWarning := FALSE;
	        #si_NrOfModulesWithError := 0;
	        
	    END_IF;
	    
	    // reset ET200sp module error status
	    IF #sUDT_HMIStatus.PNSlaveNotOnline OR #iqUDT_VSUInterface.InternalErrorReset OR NOT #ix_24VOk
	    THEN
	        FILL_BLK(IN := FALSE,
	                 COUNT := 32,
	                 OUT => #sUDT_HMIStatus.ET200sp_ErrorModule[0]);
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Update PN slave device status
	    // Hardware will only be available after the delay, so the device has time for the initialisation
	    #sFB_TimerOnOffDelayCheckSupply(iudi_OnDelayTime := #ci_PowerSupplyDelayTime,
	                                    ix_SignalToDelay := #ix_24VOk,
	                                    qx_DelayedSignal => #sx_PowerOk);
	    
	    // check if PN device is online
	    IF ((NOT "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.Exist
	        AND #sx_PowerOk)
	        OR NOT #sUDT_PNDevice.PNDeviceFound)
	        AND NOT #ix_SimulationModeActive
	    THEN
	        #sUDT_HMIStatus.PNSlaveNotOnline := TRUE;
	    END_IF;
	    
	    // Check if PN ports are healthy 
	    IF #sa_PNPortsStatus[1] XOR #sa_PNPortsStatus[2] THEN
	        #sUDT_HMIStatus.PNSlaveWarning := TRUE;
	    END_IF;
	    
	    // check if PN device has an error
	    IF "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.Error
	        AND #sx_PowerOk
	        AND NOT #ix_SimulationModeActive
	        AND NOT #sUDT_HMIStatus.PNSlaveWarning
	        
	    THEN
	        #sUDT_HMIStatus.PNSlaveError := TRUE;
	    END_IF;
	    
	    // set bit when PN device is healthy (online and no error)
	    #sx_PNSlaveOnline := NOT #sUDT_HMIStatus.PNSlaveNotOnline
	    AND #sUDT_PNDevice.PNDeviceFound
	    AND #sx_PowerOk
	    OR #ix_SimulationModeActive;
	    
	    // create rising edge to scan module status when device is found
	    #sR_TRIG_DeviceFound(CLK := #sUDT_PNDevice.PNDeviceFound);
	    
	END_REGION
	
	REGION 4 - Status update modules ET200sp
	    // update ET200sp module status 
	    IF (#sx_PNSlaveOnline
	        AND (#sUDT_HMIStatus.PNSlaveError
	        OR #sUDT_HMIStatus.PNSlaveWarning))
	        OR #sR_TRIG_DeviceFound.Q
	    THEN
	        // get configured modules
	        #si_ModuleStateReturn := ModuleStates(LADDR := "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.HW_ID,
	                                              MODE := #cui_ConfiguredModulesMode,
	                                              STATE := #ta_Configured);
	        
	        // get module online status
	        #si_ModuleStateReturn := ModuleStates(LADDR := "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.HW_ID,
	                                              MODE := #cui_ExistingModulesMode,
	                                              STATE := #ta_Exist);
	        
	        // get module error status
	        #si_ModuleStateReturn := ModuleStates(LADDR := "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.HW_ID,
	                                              MODE := #cui_ModuleErrorMode,
	                                              STATE := #ta_Error);
	        
	        // Handle ET200sp module errors/offline
	        IF (#si_ModuleStateReturn = 0)
	        THEN
	            #si_NrOfModulesWithError := 0;
	            
	            #ti_DiagArraySize := "FC_GetNrOfArrayEl"(iv_Array := "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].Module);
	            
	            FOR #ti_NrOfModule := 0 TO (#ti_DiagArraySize - 1) DO
	                
	                // check if the module is configured
	                IF (#ta_Configured[#ti_NrOfModule])
	                THEN
	                    "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].Module[#ti_NrOfModule].Configured := TRUE;
	                    // and check if the module is online
	                    IF (#ta_Exist[#ti_NrOfModule])
	                    THEN
	                        "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].Module[#ti_NrOfModule].Exist := TRUE;
	                        
	                    ELSE
	                        "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].Module[#ti_NrOfModule].Exist := FALSE;
	                        #sUDT_HMIStatus.ET200sp_ErrorModule[#ti_NrOfModule] := TRUE;
	                        // count number of modules with error/offline
	                        #si_NrOfModulesWithError += 1;
	                    END_IF;
	                    
	                    // and check if the module has an error
	                    IF (NOT #ta_Error[#ti_NrOfModule])
	                    THEN
	                        "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].Module[#ti_NrOfModule].Error := FALSE;
	                        
	                    ELSE
	                        "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].Module[#ti_NrOfModule].Error := TRUE;
	                        #sUDT_HMIStatus.ET200sp_ErrorModule[#ti_NrOfModule] := TRUE;
	                        // count number OF modules with error/offline
	                        #si_NrOfModulesWithError += 1;
	                    END_IF;
	                    
	                ELSE
	                    // reset module status when module is not configured
	                    "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].Module[#ti_NrOfModule].Configured := FALSE;
	                    "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].Module[#ti_NrOfModule].Exist := FALSE;
	                    "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].Module[#ti_NrOfModule].Error := FALSE;
	                    
	                END_IF;
	            END_FOR;
	        END_IF;
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Check RIO Panel Status
	    
	    // create 400v internal error
	    IF NOT #ix_400VintOk
	    THEN
	        #sUDT_HMIStatus."400VCircuitBreaker" := TRUE;
	    END_IF;
	    
	    // create error circuit breaker brake tripped
	    IF NOT #ix_BrakeSupplyOk
	    THEN
	        #sUDT_HMIStatus.BrakeCircuitBreaker := TRUE;
	    END_IF;
	    
	    // Create error thermal overload brake
	    IF NOT #ix_ThermalBrake
	    THEN
	        #sUDT_HMIStatus.BrakeThermalError := TRUE;
	    END_IF;
	    
	    // Create error thermal overload brake
	    IF NOT #ix_24VOk
	    THEN
	        #sUDT_HMIStatus."24VPowersupplyError" := TRUE;
	    END_IF;
	    
	    // check if 400 v to VFD positioning is ok
	    #iqUDT_VSUInterface.VSUMainPowerOk := #ix_400VextOk;
	    
	    // set config not ok bit if no device found
	    #sx_ConfigurationError := NOT #sUDT_PNDevice.PNDeviceFound;
	    
	END_REGION
	
	REGION 6 - Statistics
	    // create trigger on error and create statistics 
	    #sR_TRIG_Int400VCBError(CLK := #sUDT_HMIStatus."400VCircuitBreaker");
	    
	    IF #iqUDT_VSUInterface.ResetStatistics OR #sUDT_HMIStatus."400VCircuitBreaker"
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics,
	                        ix_Activate := #sUDT_HMIStatus."400VCircuitBreaker",
	                        ix_RTrigActivate := #sR_TRIG_Int400VCBError.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.Int400VCBError);
	    END_IF;
	    
	    // create trigger on error and create statistics 
	    #sR_TRIG_Int24VError(CLK := #sUDT_HMIStatus."24VPowersupplyError");
	    
	    IF #iqUDT_VSUInterface.ResetStatistics OR #sUDT_HMIStatus."24VPowersupplyError"
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics,
	                        ix_Activate := #sUDT_HMIStatus."24VPowersupplyError",
	                        ix_RTrigActivate := #sR_TRIG_Int24VError.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics."24VError");
	    END_IF;
	    
	    // create trigger on error and create statistics 
	    #sR_TRIG_BrakeCBerror(CLK := #sUDT_HMIStatus.BrakeCircuitBreaker);
	    
	    IF #iqUDT_VSUInterface.ResetStatistics OR #sUDT_HMIStatus.BrakeCircuitBreaker
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics,
	                        ix_Activate := #sUDT_HMIStatus.BrakeCircuitBreaker,
	                        ix_RTrigActivate := #sR_TRIG_BrakeCBerror.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.BrakeCBerror);
	    END_IF;
	    
	    // create trigger on error and create statistics 
	    #sR_TRIG_BrakeThermError(CLK := #sUDT_HMIStatus.BrakeThermalError);
	    
	    IF #iqUDT_VSUInterface.ResetStatistics OR #sUDT_HMIStatus.BrakeThermalError
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics,
	                        ix_Activate := #sUDT_HMIStatus.BrakeThermalError,
	                        ix_RTrigActivate := #sR_TRIG_BrakeThermError.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.BrakeThermError);
	    END_IF;
	    
	    // create trigger on error and create statistics for profinet slave not online
	    #sR_TRIG_PNSlaveNotOnline(CLK := #sUDT_HMIStatus.PNSlaveNotOnline);
	    
	    IF #iqUDT_VSUInterface.ResetStatistics OR #sUDT_HMIStatus.PNSlaveNotOnline
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics,
	                        ix_Activate := #sUDT_HMIStatus.PNSlaveNotOnline,
	                        ix_RTrigActivate := #sR_TRIG_PNSlaveNotOnline.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.PNSlaveNotOnline);
	    END_IF;
	    
	    // create trigger on error and create statistics for profinet slave error
	    #sR_TRIG_PNSlaveError(CLK := #sUDT_HMIStatus.PNSlaveError);
	    
	    IF #iqUDT_VSUInterface.ResetStatistics OR #sUDT_HMIStatus.PNSlaveError
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics,
	                        ix_Activate := #sUDT_HMIStatus.PNSlaveError,
	                        ix_RTrigActivate := #sR_TRIG_PNSlaveError.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.PNSlaveError);
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Status
	    // Statement section REGION
	    #iqUDT_VSUInterface.InternalErrorRIOPanel := #sUDT_HMIStatus.PNSlaveError
	    OR #sUDT_HMIStatus.PNSlaveNotOnline
	    OR #si_NrOfModulesWithError <> 0
	    OR #sUDT_HMIStatus."400VCircuitBreaker"
	    OR #sUDT_HMIStatus."24VPowersupplyError"
	    OR #sUDT_HMIStatus.BrakeCircuitBreaker
	    OR #sUDT_HMIStatus.BrakeThermalError;
	    
	    // HMI status update
	    
	    #qUDT_HMIStatus := #sUDT_HMIStatus;                       // Copy HMI status to output
	    
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_XrayHS10080XCT"
TITLE = FB_Xray_HS10080XCT
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : Equipment
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 44
// END_ATTRIBUTES
//Function block to control X-Ray.
   VAR_INPUT 
      iUDT_EquipmentConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_HS10080XCTConfiguration";   //  Configuration XCT 10080 structure
      iUDT_HMICommand { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_HS10080XCTHMICommand";   //  Command structure
      idi_TakeoutConveyorLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //  Takeout Conveyor Length [mm]
      ix_SafetyReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE Safety reset command is active
      ix_SafetyOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when Safety Circuit is healthy
      ix_24vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when 24VDC is healthy
      ix_400vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when 400VAC is healthy
      ix_ProfinetOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when the PN node(s) of VSU are OK
      ix_Interlock { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Contact from XCT . Closed: All doors are closed.Open: One of the doors of the tunnel is opened, machine is stopped
      ix_TempOutOfRange { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Contact from XCT Closed: XCT doesn’t work because XCT operating temperature isn’t given. Open: XCT is in the right temperature range and it is possible to power on
      ix_PowerOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  The power-on acknowledgement. Open: The X-ray is shut down. Closed: The X-ray is turned on.
      ix_RepairSwitch { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  The main power switch. Open: Mains power on. Closed: Mains power off.
      ix_ServiceMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Service mode state. Open: The X-ray is not in service mode. Closed: The X-ray is in service mode.
      ix_TransitActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Transit mode state. Open: The transit mode is not active. Closed: The transit mode is active.
      ix_MachineOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  The X-ray is OK. Open: The X-ray has a fatal error; no operation is possible. Closed: The X-ray is initialised and working properly.
      ix_IQTestActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when IQ test is active
      ix_CalReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  True when XCT is requesting callibration
      ix_AllowCalibration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Use to inhibit calibration in heavy flow if necessary
      ix_XrayReady { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Ready to receive a bag state. Open: Not ready to receive a bag. Closed: X-ray is ready receive a bag.
      ix_PECInfeedEoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when the end of section photoeye is not blocked
      ix_PECOutfeedEoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when the end of section photoeye is not blocked
      ix_PECOutfeedPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when the data acailable at PEC position
      ix_InfConveyorError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Infeed conveyor error
      ix_MainSpeedOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Main Conveyor speed OK. Open: The X-ray conveyor is not running or not running at specified speed. Closed: The X-ray conveyor is activated and running at specified speed.
      ix_OutfConveyorError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Outfeed Conveyor error.
      ix_NoScanActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Acknowledgement of the no-scan mode. Open: The X-ray is not in the no-scan mode. Closed: The X-ray is in the no-scan mode.
      ix_ReadyToScan { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Contract from XCT (Gantry Control) Closed: Gantry is ready and have the nominal Speed.
      ix_GINinMainTrack { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  GIN is detected in the tracking configured area
      ix_ResetEnergySave { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Reset energy save mode timer
      ix_TakeoutConveyorRunning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Outfeef conveyor running
      ix_IQTestSelection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  IQ test enable
      ix_IQTestStopPEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  IQ test outfeed conveyor stop PEC
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_HS10080XCTStatus";   //  HMI status structure
      qUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   //  Common status structure
      qx_NoScan { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Request for the no-scan mode. Open: X-ray out of no-scan mode (screening mode). Closed: X-ray in no-scan mode.
      qx_InfeedConveyorOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  The infeed conveyor control. (HDX only in no-scan mode) Open: The BHS-PLC has no need for running the X-ray infeed conveyor. Closed: Run the X-ray infeed conveyor.
      qx_MainConveyorOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  The main conveyor control. (HDX only in no-scan mode) Open: The BHS-PLC has no need for running the X-ray main conveyor. Closed: Run the X-ray main conveyor.
      qx_OutfeedConveyorOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  The outfeed conveyor control. (HDX only in no-scan mode) Open: The BHS-PLC has no need for running the X-ray outfeed conveyor. Closed: Run the X-ray outfeed conveyor.
      qx_ESReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Emergency stop reset. Open: No action. Closed: Resets the last emergency stop event. Must be closed for approximately 0.5 seconds.
      qx_PowerOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Remote power-on for the X-ray. Open: Power down. Closed: Power up and start of initialisation.
      qx_PrepareToScan { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Control of gantry rotation Closed: Gantry start rotation, acceleration time ~90 sec. Open: Gantry stop,decelerationtime ~100 sec,
      qx_ReadyForCal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Accept of Calibration request. Closed: External infeed conveyors are stopped. Waiting for calibration to end.
      qx_IQTestInfeedHold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  IQ test infeed belt hold
      qx_IQTestOutfeedHold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  IQ test outfeed belt hold
      qx_IQTestIndication { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  IQ test lamp indication
   END_VAR

   VAR_IN_OUT 
      iqUDT_Statistics : "UDT_HS10080XCTStatistics";   //  Statistics structure
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   //  Equipment control stucture
      iqUDT_InfeedConveyorInterface : "UDT_ConveyorInterface";   //  Infeed conveyor interface structure
      iqUDT_MainConveyorInterface : "UDT_ConveyorInterface";   //  Main conveyor interface structure
      iqUDT_OutfeedConveyorInterface : "UDT_ConveyorInterface";   //  Outfeed conveyor interface structure
      iqUDT_HandShakeUp : "UDT_ConveyorHandshake";   //  Upstream handshake structure
      iqUDT_Handshake : "UDT_ConveyorHandshake";   //  Downstream handshake structure
   END_VAR

   VAR 
      sUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_HS10080XCTStatus";   //  HMI status structure
      sUDT_CommonStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //  Common status structure
      sUDT_CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //  Common status structure
      sUDT_InfeedConvCommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //  Common status for infeed conveyor
      sUDT_MainConvCommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //  Common status for main conveyor
      sUDT_OutfeedConvCommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //  Common status for outfeed conveyor
      sUDT_InfeedConvCommonStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //  Common status for infeed conveyor
      sUDT_MainConvCommonStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //  Common status for main conveyor
      sUDT_OutfeedConvCommonStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //  Common status for outfeed conveyor
      s_OutfeedPECEoSFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //  Filtering end of section photo eye signal
      s_InfeedPECEoSFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //  Filtering end of section photo eye signal
      s_CascadeModeTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //  Timer to cascade start
      s_CallibrationForceDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //  Delay before callibration is forced on
      s_MainConvRunFeedback { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //  Conveyor run feeback
      s_IQTestRealese { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //  Conveyor run feeback
      s_EntryEncoderFault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //  Entry encoder fault
      s_MainEncoderFault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //  Main encoder fault
      s_ExitEncoderFault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //  Exit encoder fault
      R_TRIG_Stop {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger to stop conveyor
      R_TRIG_Running {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger running
      R_TRIG_MainRunning {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger running
      R_TRIG_OutfeedRunning {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger running
      R_TRIG_XRayMode {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger in X-ray mode
      R_TRIG_ServiceMode {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger in service mode
      R_TRIG_TransitMode {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger in transitmode
      R_TRIG_Estop {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger E-stop active
      R_TRIG_RepairSwitch {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger Repairswitch
      R_TRIG_TempOutOfRange {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger Temperature Out Of Range
      R_TRIG_TailToBegin {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger Tail arrive at the beginning of next conveyor
      R_TRIG_Calibrating {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger Calibrating
      R_TRIG_CalibrationForce {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger Callibration is forced
      R_TRIG_InfConvErr {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger Infeed conveyor error
      R_TRIG_OutfConvErr {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger Outfeed conveyor error
      R_TRIG_EncoderErr {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger encoder error
      F_TRIG_Callibrating {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //  Falling edge trigger Callibrating
      F_TRIG_Interlock {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //  Falling edge trigger Interlock
      R_TRIG_PEC_EoSFiltered {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger end of section photo eye filtered
      F_TRIG_PEC_EosFiltered {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //  Falling edge PEC EOS
      F_TRIG_SignalingRequest {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //  Falling edge signaling request
      F_TRIG_EnergySaveActive {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //  Falling edge Energy save active
      F_TRIG_AuxHeadToEnd {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //  Falling edge trigger Aux head to end bit
      R_TRIG_TakeoutConveyorRuning {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Falling edge trigger takeout conveyors running
      R_TRIG_IQTest {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Falling edge trigger takeout conveyors running
   END_VAR
   VAR RETAIN
      sdi_DistanceStopping { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //  Actual distance after stop signal (cm)
   END_VAR
   VAR 
      sdi_PECOutfeedDistanceOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //  Distance offset between photo eye and the end of conveyor [mm]
   END_VAR
   VAR RETAIN
      sdi_DistanceRunEmptyMain { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //  Actual distance running empty
      sdi_DistanceRunEmptyOutfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //  Actual distance running empty
   END_VAR
   VAR 
      sdi_ClearDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //  Distance on takeout conveyor to clear before start
      si_IQTestEmptyDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
   END_VAR
   VAR RETAIN
      si_GapTailToHead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Actual size gap tail to head
      si_OutfeedAuxJamDisplacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Auxiliary variable to calculate displacement when PEC is blocked
      si_InfeedAuxJamDisplacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Auxiliary variable to calculate displacement when PEC is blocked
      si_AuxEnergySave { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Auxiliary variable to calculate energy save displacement
      si_TailToBegin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Count tail to next conveyor distance
      si_HeadToEnd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Count head to end distance
      sx_AuxHeadToEnd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Aux bit to control head to end positioning
      sx_AuxHeadAtEnd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Aux bit to memorise head at end positioning
      sx_TailToBegin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Trail to begin done
      sx_EnergySaveActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Active energy save mode
   END_VAR
   VAR 
      sx_PEC_OutfeedEoSFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  End of section photo eye filtered
      sx_PEC_InfeedEoSFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  End of section photo eye filtered
      sx_MainConvReady { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Conveyor Ready to operate in Automatic mode
      sx_StartReceived { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Start command received from system
      sx_MainAutomaticActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Running in automatic
      sx_OutfeedAutomaticActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Running in automatic
      sx_ManualModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Manual mode active
      sx_RunningEmptyMain { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  X-Ray main is running empty
      sx_RunningEmptyOutfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  X-Ray outfeed is running empty
      sx_ReqToCal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Request to calibrate received
      sx_ParcelAtEnd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Parcel is detected in window at end of main conveyor
      sx_Stopping { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Stopping seuence is activated
      sx_Stopped { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Stopping sequence is ended
      sx_Gapping { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  The outfeed conveyor is creating a gap downstream
      sx_calibrating { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  XCT Calibration is ongoing
      sx_CallibrateForceOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  XCT Callibration is forced on because wating timed out
      sx_MainConvRunFeedbackError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Main conveyor running feedback error
      sx_MachineHealthy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Machine healthy status
      sx_ResetRunEmptyESave { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Resent energy save to run empty
      sx_MainConveyorOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Main conveyor control
      sx_ReadyForCal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Ready for calibration
      sx_TakeoutConveyorClear { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Takeout conveyor clear
      sx_IQTestReady { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_InfeedConveyorOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Infeed conveyor control
      sx_OutfeedConveyorOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Oufeed conveyor control
   END_VAR

   VAR_TEMP 
      tx_PowerOn : Bool;   //  Startup the machine
      tx_PrepareToScan : Bool;   //  Power on X-Ray generator
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	29/05/2019  | 0.1       | Frank Baten   | first release TIA 15
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	07/08/2019  | 2.1       | S.Theocharis  | 2.1 Updates during test at SMITHS Detection
	09/08/2019  | 2.2       | Frank Baten   | 2.2 Add control of infeed conveyor
	13/08/2019  | 2.3       | S.Theocharis  | 2.3 Updated with interface of infeed conveyor
	20/08/2019  | 2.4       | S.Theocharis  | 2.4 Add the internal tracking error
	26/08/2019  | 2.5       | S.Theocharis  | Update the "UDT_HS10080XCT_Configuration"
	25/09/2019  | 2.6       | S. Deulkar    | Created 3 different entity for 3 conveyor, automatic active, error etc.
	                                        | Added infeed PEC blockage logic
	                                        | Modified logic for Infeed and outfeed conveyor run
	                                        | Adeed 3 status and report block call for 3 xray belts
	                                        | No scan HMI command is added,ON commands output activates  
	11/10/2019  | 2.7       | S.Deulkar     | Update new status structure   
	04/11/2019  | 2.8       | L.Klar        | First scan bit changed from memory bit to DB variable
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	13/01/2020  | 3.2       | F.Baten       | Changed length related tags from Int to Dint 
	11/01/2021  | 3.3       | L.Klar        | Sinput safety ok added to stop conveyor condition
	09/02/2021  | 3.4       | L.Klar        | IQ test added
	04/03/2021  | 3.5       | M.Kurpiers    | HMI status updated - xray ready warning added
	13/03/2021  | 3.6       | L.Klar        | HMI status updated- warning commented, energy save added, diaback added when machine in startup
	20/03/2021  | 3.7       | L.Klar        | Encoders errors added
	09/06/2021  | 3.8       | M.Kurpiers    | E-Stop Active statistics changed
	04/04/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Initial and Calibration
	    
	    // First PLC cycle
	    IF "DB_Memory".FirstScan
	    THEN
	        #sx_MainAutomaticActive := FALSE;                                                                           // switch of automatic activ
	        #iqUDT_HandShakeUp.RTR := False;                                                                           // Reset RTR signal
	        #iqUDT_HandShakeUp.CascadeStartUp := FALSE;                                                                // Reset cascade start signal
	        #sx_Stopping := FALSE;                                                                                      // Reset stopping sequence
	        #sx_Stopped := TRUE;                                                                                        // Set machine is stopped
	    END_IF;
	    
	    // Calibrating Condition 
	    (* Xray do not share calibrating status with PLC, hence follwoing condtions are used to check if machine is calibrating)*)
	    #sx_calibrating := #ix_CalReq AND #sx_ReadyForCal AND NOT #ix_XrayReady;
	    
	END_REGION
	
	REGION 2 - Triggers
	    // Statement section REGION
	    
	    #R_TRIG_XRayMode(CLK := NOT #sUDT_CommonStatus.Stopped AND NOT #ix_ServiceMode AND NOT #ix_TransitActive);      // Rising edge trigger X-Ray mode
	    
	    #R_TRIG_ServiceMode(CLK := NOT #sUDT_CommonStatus.Stopped AND #ix_ServiceMode);                                 // Rising edge trigger in service mode
	    
	    #R_TRIG_TransitMode(CLK := NOT #sUDT_CommonStatus.Stopped AND #ix_TransitActive);                               // Rising edge trigger in transitmode
	    
	    #R_TRIG_Estop(CLK := NOT #ix_SafetyOk);                                                                          // Rising edge trigger E-stop active
	    
	    #R_TRIG_RepairSwitch(CLK := #ix_RepairSwitch);                                                                   // Rising edge trigger Repairswitch
	    
	    #R_TRIG_TempOutOfRange(CLK := #ix_TempOutOfRange);                                                               // Rising edge trigger Temperature Out Of Range
	    
	    #R_TRIG_Calibrating(CLK := #sx_calibrating);                                                                     // Rising edge trigger Calibrating
	    
	    #F_TRIG_Interlock(CLK := #ix_Interlock);                                                                         // Falling edge trigger interlock (1=ok)
	    
	    #R_TRIG_Running(CLK := #sUDT_CommonStatus.Running);                                                             // Rising edge trigger running X-Ray system
	    
	    #R_TRIG_Stop(CLK := #sUDT_CommonStatus.Stopped);                                                                // Rising edge trigger x-ray stopped
	    
	    #R_TRIG_MainRunning(CLK := #ix_MainSpeedOk);                                                                     // Rising edge trigger running main conveyor
	    
	    #F_TRIG_Callibrating(CLK := #sx_calibrating);                                                                    // Falling edge trigger callibrating
	    
	    #R_TRIG_PEC_EoSFiltered(CLK := #sx_PEC_OutfeedEoSFiltered);                                                      // Rising edge trigger PEC EOS
	    
	    #F_TRIG_PEC_EosFiltered(CLK := #sx_PEC_OutfeedEoSFiltered);                                                      // Falling edge trigger PEC EOS
	    
	    #F_TRIG_SignalingRequest(CLK := #iqUDT_EquipmentControl.Request.SignalingRequest); // Falling edge trigger signaling request
	    
	    #R_TRIG_TakeoutConveyorRuning(CLK := #ix_TakeoutConveyorRunning);
	    
	    
	    // PEC Filter
	    #s_OutfeedPECEoSFiltered(iudi_OnDelayTime := #iUDT_EquipmentConfiguration.PEC_OutfeedTimeOnDelay,
	                             iudi_OffDelayTime := #iUDT_EquipmentConfiguration.PEC_OutfeedTimeOffDelay,
	                             ix_SignalToDelay := #ix_PECOutfeedEoS,
	                             ix_Enable := TRUE,
	                             qx_DelayedSignal => #sx_PEC_OutfeedEoSFiltered);
	    
	    #s_InfeedPECEoSFiltered(iudi_OnDelayTime := #iUDT_EquipmentConfiguration.PEC_InfeedTimeOnDelay,
	                            iudi_OffDelayTime := #iUDT_EquipmentConfiguration.PEC_InfeedTimeOffDelay,
	                            ix_SignalToDelay := #ix_PECInfeedEoS,
	                            ix_Enable := TRUE,
	                            qx_DelayedSignal => #sx_PEC_InfeedEoSFiltered);
	    
	END_REGION
	
	REGION 3 - Error handling         
	    REGION 3.1 - Reset Errors
	        IF #iqUDT_EquipmentControl.Command.Reset                                                                   // If Reset command appeared from system control
	        THEN
	            
	            IF #sUDT_HMIStatus.OutfeedConvSpecific.PEC_EoSJam                                                          // If Outfeed EOS PEC Jammed error is active
	                AND ((#iUDT_EquipmentConfiguration.ResetWithPECBlocked)                                            // And Reset with PEC blocked is enabled
	                OR (NOT #iUDT_EquipmentConfiguration.ResetWithPECBlocked AND #sx_PEC_OutfeedEoSFiltered))          // Or reset is not enabled and PEC is unblocked
	            THEN                                                                                                    // Then 
	                #sUDT_HMIStatus.OutfeedConvSpecific.PEC_EoSJam := FALSE;                                               // reset PEC jam error
	            END_IF;
	            
	            IF #sUDT_HMIStatus.InfeedConvSpecific.PEC_EoSJam                                                           // If Infeed EOS PEC Jammed error is active
	                AND ((#iUDT_EquipmentConfiguration.ResetWithPECBlocked)                                            // And Reset with PEC blocked is enabled
	                OR (NOT #iUDT_EquipmentConfiguration.ResetWithPECBlocked AND #sx_PEC_InfeedEoSFiltered))           // Or reset is not enabled and PEC is unblocked
	            THEN                                                                                                    // Then 
	                #sUDT_HMIStatus.InfeedConvSpecific.PEC_EoSJam := FALSE;                                                // reset PEC jam error
	            END_IF;
	            #sx_MainConvRunFeedbackError := FALSE;
	            #sUDT_HMIStatus.InfeedConvSpecific.Conv_ERR := FALSE;                                                      // Reset infeed conveyor feedback error
	            #sUDT_HMIStatus.MainConvSpecific.Conv_ERR := FALSE;                                                        // Reset main conveyor feedback error
	            #sUDT_HMIStatus.OutfeedConvSpecific.Conv_ERR := FALSE;
	            #sUDT_HMIStatus.InfeedConvSpecific.Encoder_ERR := FALSE;                                                      // Reset infeed conveyor feedback error
	            #sUDT_HMIStatus.MainConvSpecific.Encoder_ERR := FALSE;                                                        // Reset main conveyor feedback error
	            #sUDT_HMIStatus.OutfeedConvSpecific.Encoder_ERR := FALSE;     // Reset outfeed conveyor feedback error    
	        END_IF;
	    END_REGION
	    
	    REGION 3.2 - Xray Errors
	        // Xray machine errors / Warnings
	        #sUDT_HMIStatus.XraySpecific.DoorInterlockNotOk := NOT #ix_Interlock;                                 // One of the doors of the in or outfeed tunnel is opend
	        #sUDT_HMIStatus.XraySpecific.RepairSwitch := #ix_RepairSwitch;                                        // X-ray mains are powered off
	        #sUDT_HMIStatus.XraySpecific.ServiceMode := #ix_ServiceMode;                                          // The X-ray is in service mode.
	        #sUDT_HMIStatus.XraySpecific.TempOutOfRange := #ix_TempOutOfRange;                                    // XCT doesn’t work because XCT operating temperature isn’t given
	        #sUDT_HMIStatus.XraySpecific.GantrySpeedNotOk := NOT #ix_ReadyToScan;                                 // Gantry speed is not Ok
	        #sUDT_HMIStatus.XraySpecific.IQTestActive := #ix_IQTestSelection OR #ix_IQTestActive;                                        // IQ test is active on XRAY
	        #sUDT_HMIStatus.XraySpecific.XrayPowerNotOn := NOT #ix_PowerOn;                                       // Power is not switched on
	        #sUDT_HMIStatus.XraySpecific.MachineNotOk := NOT #ix_MachineOk;                                       // Machine is not ok
	        #sUDT_HMIStatus.XraySpecific.XRayNotReady := NOT #ix_XrayReady;                                       // X-Ray is not ready to operate
	        #sUDT_HMIStatus.XraySpecific.TransitActive := #ix_TransitActive;                                      // The transit mode is active
	        #sUDT_HMIStatus.XraySpecific.NoScanActive := #ix_NoScanActive;                                        // The X-ray is in the no-scan mode.
	        
	        // Xray Common "Error"
	        #sUDT_CommonStatus.Error := NOT #ix_24vOk                                                                  // 24v signalling not OK
	        OR NOT #ix_400vOk                                                                                           // 400v signalling not OK
	        OR NOT #ix_ProfinetOk                                                                                       // Profinet signalling not OK
	        OR NOT #ix_SafetyOk
	        OR #sUDT_HMIStatus.XraySpecific.MachineNotOk                                                                                         // Safety signalling NOT OK
	        // changed onsite
	        OR NOT #sUDT_HMIStatus.XraySpecific.RepairSwitch                                                                   // X-ray mains are powered off
	        OR #sUDT_InfeedConvCommonStatus.Error                                                                          // Or error is active on main conveyor            
	        OR #sUDT_MainConvCommonStatus.Error                                                                            // Or error is active on main conveyor            
	        OR #sUDT_OutfeedConvCommonStatus.Error
	        OR (#sUDT_HMIStatus.XraySpecific.ServiceMode AND NOT #ix_IQTestSelection)                                                                    // The X-ray is in service mode.
	        OR #sUDT_HMIStatus.XraySpecific.TempOutOfRange;                                                                // XCT doesn’t work because XCT operating temperature isn’t given
	        //OR #s_StatusUDT.XraySpecific.GantrySpeedNotOk                                                             // Xraay gantry speed is not ok 
	        
	    END_REGION
	    
	    REGION 3.3 - Infeed conveyor errors
	        
	        IF #ix_InfConveyorError OR #iqUDT_InfeedConveyorInterface.InternalErrorTracking THEN                                                                        // If main conveyor feedback error active then
	            #sUDT_HMIStatus.InfeedConvSpecific.Conv_ERR := TRUE;                                                       // Create infeed conveyor feedback error
	        END_IF;
	        
	        #s_EntryEncoderFault(iudi_OnDelayTime := 5000,
	                             ix_SignalToDelay := #sx_InfeedConveyorOn AND #iqUDT_InfeedConveyorInterface.Displacement = 0,                         //If Main conveyor speed not Ok
	                             ix_Enable := TRUE);
	        
	        IF #s_EntryEncoderFault.qx_DelayedSignal THEN
	            #sUDT_HMIStatus.InfeedConvSpecific.Encoder_ERR := TRUE;
	        END_IF;
	        
	        IF NOT #sx_PEC_InfeedEoSFiltered                                                                            // PEC is blocked
	        THEN
	            #si_InfeedAuxJamDisplacement += #iqUDT_InfeedConveyorInterface.Displacement;                          // Increase memory with actual displacement
	        ELSE
	            #si_InfeedAuxJamDisplacement := 0;                                                                     // Reset memory (PEC was free)
	        END_IF;
	        
	        IF #si_InfeedAuxJamDisplacement > #iUDT_EquipmentConfiguration.InfeedPECJamDisplacementLimit THEN         // If memory is bigger than setpoint, set error
	            #sUDT_HMIStatus.InfeedConvSpecific.PEC_EoSJam := TRUE;
	        END_IF;
	        
	        #sUDT_InfeedConvCommonStatus.Error := #sUDT_HMIStatus.InfeedConvSpecific.PEC_EoSJam                               // Infeed conveyor PEC Jammed
	        OR #sUDT_HMIStatus.InfeedConvSpecific.Conv_ERR                                                                 // Infeed conveyor is in error
	        OR #sUDT_HMIStatus.InfeedConvSpecific.Encoder_ERR;                                                             // Infeed conveyor has encoder error
	        
	    END_REGION
	    
	    REGION 3.4 - Main conveyor Errors
	        
	        #s_MainEncoderFault(iudi_OnDelayTime := 5000,
	                            ix_SignalToDelay := #sx_MainConveyorOn AND #ix_MainSpeedOk AND #iqUDT_MainConveyorInterface.Displacement = 0,                         //If Main conveyor speed not Ok
	                            ix_Enable := TRUE);
	        
	        IF #s_MainEncoderFault.qx_DelayedSignal THEN
	            #sUDT_HMIStatus.MainConvSpecific.Encoder_ERR := TRUE;
	        END_IF;                                            // The Main conveyor encoder is faulted
	        
	        #s_MainConvRunFeedback(iudi_OnDelayTime := #iUDT_EquipmentConfiguration.MainConvFeedbackDelayTime,
	                               ix_SignalToDelay := #sx_MainConveyorOn AND NOT #ix_MainSpeedOk,                         //If Main conveyor speed not Ok
	                               ix_Enable := TRUE,                                                                       // Enable timer when run command to main conveyor is ON 
	                               qx_DelayedSignal => #sx_MainConvRunFeedbackError);
	        
	        IF #sx_MainConvRunFeedbackError OR #iqUDT_MainConveyorInterface.InternalErrorTracking THEN                                                                        // If main conveyor feedback error active then
	            #sUDT_HMIStatus.MainConvSpecific.Conv_ERR := TRUE;                                                         // Create main conveyor feedback error
	        END_IF;
	        
	        #sUDT_MainConvCommonStatus.Error :=
	        #sUDT_HMIStatus.MainConvSpecific.Conv_ERR                                                                      // Outfeed conveyor is in error
	        OR #sUDT_HMIStatus.MainConvSpecific.Encoder_ERR;
	        
	    END_REGION
	    
	    REGION 3.5 - Outfeed conveyor errors
	        
	        IF #ix_OutfConveyorError OR #iqUDT_OutfeedConveyorInterface.InternalErrorTracking THEN                                                                        // If main conveyor feedback error active then
	            #sUDT_HMIStatus.OutfeedConvSpecific.Conv_ERR := TRUE;                                                      // Create infeed conveyor feedback error
	        END_IF;
	        
	        #s_ExitEncoderFault(iudi_OnDelayTime := 5000,
	                            ix_SignalToDelay := #sx_OutfeedConveyorOn AND #iqUDT_OutfeedConveyorInterface.Displacement = 0,                         //If Main conveyor speed not Ok
	                            ix_Enable := TRUE);
	        
	        IF #s_ExitEncoderFault.qx_DelayedSignal THEN
	            #sUDT_HMIStatus.OutfeedConvSpecific.Encoder_ERR := TRUE;
	        END_IF;                                       // The Infeed conveyor encoder is faulted
	        
	        IF NOT #sx_PEC_OutfeedEoSFiltered                                                                           // PEC is blocked
	        THEN
	            #si_OutfeedAuxJamDisplacement += #iqUDT_OutfeedConveyorInterface.Displacement;                        // Increase memory with actual displacement
	        ELSE
	            #si_OutfeedAuxJamDisplacement := 0;                                                                    // Reset memory (PEC was free)
	        END_IF;
	        
	        IF #si_OutfeedAuxJamDisplacement > #iUDT_EquipmentConfiguration.OutfeedPECJamDisplacementLimit THEN       // If memory is bigger than setpoint, set error
	            #sUDT_HMIStatus.OutfeedConvSpecific.PEC_EoSJam := TRUE;
	        END_IF;
	        
	        #sUDT_OutfeedConvCommonStatus.Error := #sUDT_HMIStatus.OutfeedConvSpecific.PEC_EoSJam                             // Outfeed conveyor PEC Jammed
	        OR #sUDT_HMIStatus.OutfeedConvSpecific.Conv_ERR                                                                // Outfeed conveyor is in error
	        OR #sUDT_HMIStatus.OutfeedConvSpecific.Encoder_ERR;                                                            // Outfeed conveyor has encoder error
	    END_REGION
	    
	    // Common warning
	    #sUDT_CommonStatus.Warning :=
	    #sUDT_HMIStatus.XraySpecific.TransitActive                                                                         // The transit mode is active
	    OR #sUDT_HMIStatus.XraySpecific.NoScanActive                                                                      // The X-ray is in the no-scan mode.
	    OR #sUDT_HMIStatus.XraySpecific.DoorInterlockNotOk // Interlock open
	    OR #sUDT_HMIStatus.XraySpecific.XRayNotReady;
	    //Conditions to set bit sx_Ready to operate 
	    #sx_MainConvReady := NOT #sUDT_CommonStatus.Error AND NOT #sUDT_MainConvCommonStatus.Error;
	    
	END_REGION
	
	REGION 4 - Stop Equipment
	    (* When a stop command is received the machine will transport the parcels to the end of the machine
	       so clearing the main conveyor. If the main conveyor is stopped (because of a parcel in the last position) 
	       or the main conveyor has run its emptying distance the machine will stop.*)
	    
	    IF NOT #iqUDT_EquipmentControl.Command.AutomaticOn                                                             // if Stop active from system control ( Means Not automatic ON)
	        AND NOT #iqUDT_EquipmentControl.Command.Start                                                              // And no start command from system control
	        AND #sx_MainAutomaticActive                                                                                 // And system is Automatic active
	    THEN                                                                                                            // Then
	        IF NOT #sx_Stopping THEN                                                                                    // If Stopping sequence is not activated
	            #sdi_DistanceStopping := 0; //((#i_UDT_EquipmentConfiguration.InfeedConveyor.Length +
	            // #i_UDT_EquipmentConfiguration.MainConveyor.Length +
	            // #i_UDT_EquipmentConfiguration.OutfeedConveyor.Length + 1000) / 10);                                            // Calculate stopping distance in cm
	        END_IF;
	        #sx_Stopping := TRUE;                                                                                       // Activate stop sequence
	    END_IF;
	    
	    IF #sx_Stopping THEN                                                                                            // If stopping sequence is activated then
	        #sdi_DistanceStopping -= #iqUDT_MainConveyorInterface.Displacement;                                         // Calculate stopping distance 
	        
	        IF #sdi_DistanceStopping < 0                                                                                 // And if stopping distance is done
	            OR NOT #ix_MainSpeedOk                                                                                  // or if main conveyor is not already stopped
	        THEN                                                                                                        // Then
	            #sx_Stopped := TRUE;                                                                                    // make Stopped status TRUE
	            #sx_Stopping := FALSE;                                                                                  // and Reset stopping sequence
	        END_IF;
	    END_IF;
	    
	    //Main and outfeed conveyor
	    IF #sx_Stopped                                                                                                  // If Stop command received and both conveyors are stopped
	        OR #sUDT_CommonStatus.Error                                                                                // Or an error is active on Xray Or error is active on main conveyor       
	        OR (#ix_TransitActive AND NOT #sx_IQTestReady)                                                                                   // AND Xray is not in transit mode
	        //OR (#ix_ServiceMode AND NOT #ix_IQTestSelection)                                                                                          // AND Xray is not in service mode
	        OR NOT #ix_SafetyOk
	        //OR (#i_UDT_HMICommand.NoScanMode AND NOT #ix_ReadyToScan)
	    THEN                                                                                                            // Then 
	        #iqUDT_HandShakeUp.RTR := FALSE;                                                                           // Reset RTR signal
	        #iqUDT_HandShakeUp.CascadeStartUp := FALSE;                                                                // Reset cascade start signal
	        #sx_MainAutomaticActive := FALSE;                                                                           // Switch off automatic active
	        #sx_OutfeedAutomaticActive := FALSE;                                                                        // Switch off automatic active
	        #sx_StartReceived := FALSE;                                                                                 // Reset start command received from system     
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Start Automatic mode
	    // if start (OS) is received from system, this is memorised until started in cascade 
	    IF #iqUDT_EquipmentControl.Command.Start                                                                       // If Start command from from system received 
	        
	    THEN                                                                                                            // Then
	        #sx_StartReceived := TRUE;                                                                                  // Set Start command received from system
	        #sx_Stopping := FALSE;                                                                                      // Stop stopping sequence
	        #sx_Stopped := FALSE;                                                                                       // Reset stopped bit        
	    END_IF;
	    
	    IF #sx_StartReceived                                                                                            // If Start command received from system
	        AND (#iqUDT_Handshake.CascadeStartUp                                                                       // Handshake from downstream conveyor to cascade start
	        OR #iUDT_EquipmentConfiguration.FirstConveyorToStart)                                                      // of if this is the first conveyor to start in the cascade 
	    THEN                                                                                                            // THEN
	        #sx_MainAutomaticActive := TRUE;                                                                            // Set Automatic active
	        #sx_OutfeedAutomaticActive := TRUE;                                                                         // Set Automatic active
	        #sx_StartReceived := FALSE;                                                                                 // and reset start received bit
	    END_IF;
	    
	    // Cascade mode
	    #s_CascadeModeTimer(iudi_OnDelayTime := #iUDT_EquipmentConfiguration.CascadeTimeOnDelay,                       //Timer to cascade mode--Outfeed Conveyor
	                        ix_SignalToDelay := #sx_MainAutomaticActive,
	                        ix_Enable := #sUDT_InfeedConvCommonStatus.Running,
	                        qx_DelayedSignal => #iqUDT_HandShakeUp.CascadeStartUp);
	    
	    #sx_ManualModeActive := FALSE;                                                                                  // No manual mode available for Xray machine hence disabled it.
	END_REGION
	
	REGION 6 - Automatic mode active    
	    REGION 6.1 - Head to End       
	        (*  Function to calculate when the head of the parcel reaches the end of the conveyor
	            When the PEC detects the parcels head, the functionality increments the displacement
	            of the conveyor until it reaches the value of the distance between PEC and the end of the conveyor. 
	            After that, the counter is reset and the bit #sx_AuxHeadToEnd is triggered to inform the system. *)
	        #sdi_PECOutfeedDistanceOffset := #iUDT_EquipmentConfiguration.PEC_OutfeedDistanceOffset;
	        
	        IF #sdi_PECOutfeedDistanceOffset >= #iUDT_EquipmentConfiguration.PEC_OutfeedDistance
	        THEN
	            #sdi_PECOutfeedDistanceOffset := #iUDT_EquipmentConfiguration.PEC_OutfeedDistance - 1;
	        END_IF;
	        
	        IF #F_TRIG_PEC_EosFiltered.Q THEN                                                                           // If the product's head is detected then
	            #si_HeadToEnd := (#iUDT_EquipmentConfiguration.PEC_OutfeedDistance                                     // Move PEC distand minus PEC offset to static variable in cm
	            - #iUDT_EquipmentConfiguration.PEC_OutfeedDistanceOffset) / 10;                                        // (Static variable is virtual distance between PEC and end of the conveyor) 
	            
	            #sx_AuxHeadToEnd := TRUE;                                                                               //And active head to end function
	            #iqUDT_Handshake.RTS := TRUE;                                                                          //And Set Ready TO Send true when a parcel is detected in the PEC 
	        END_IF;
	        
	        IF #sx_AuxHeadToEnd                                                                                         // If the product's head is detected then
	            AND (#si_HeadToEnd > 0)                                                                                 //And Parcel's head did not arrive in the end of the conveyor yet
	        THEN                                                                                                        // Then
	            #si_HeadToEnd -= #iqUDT_OutfeedConveyorInterface.Displacement;                                         // then Count displacement until it arrives at the end of the conveyor
	        ELSE                                                                                                        // Else
	            #sx_AuxHeadToEnd := FALSE;                                                                              // Stop function head to end
	        END_IF;
	        
	        // Falling edge trigger Aux Head to End bit
	        #F_TRIG_AuxHeadToEnd(CLK := #sx_AuxHeadToEnd);
	        IF #F_TRIG_AuxHeadToEnd.Q
	        THEN
	            #sx_AuxHeadAtEnd := TRUE;
	        END_IF;
	    END_REGION
	    
	    REGION 6.2 - Tail to Begin       
	        (*   This function tracks when the parcels tail reaches the begin of the downstream conveyor
	             When the PEC is clear, the function starts to increase the displacement until reaches the distance
	             between PEC and the end of conveyor. *)
	        
	        IF #R_TRIG_PEC_EoSFiltered.Q THEN                                                                           // If product's tail is detected then
	            #si_TailToBegin := (#iUDT_EquipmentConfiguration.PEC_OutfeedDistance / 10);                            // Move distance of the PEC to the end of the conveyor TO auxiliar static variable
	        END_IF;
	        
	        IF #si_TailToBegin > 0 THEN                                                                                 // While the products tail doesn't reach the beginning of next conveyor
	            #si_TailToBegin -= #iqUDT_OutfeedConveyorInterface.Displacement;                                       // count displacement until the product's tail arrives on the next conveyor
	            #sx_TailToBegin := FALSE;                                                                               // Reset Tail to begin bit
	        ELSE
	            #sx_TailToBegin := TRUE;                                                                                // Product's tail arrived at the begin of the next conveyor
	        END_IF;
	        
	        // Rising edge trigger Aux Tail to Begin bit
	        #R_TRIG_TailToBegin(CLK := #sx_TailToBegin);
	        
	    END_REGION
	    
	    REGION 6.3 - Transfer in progress
	        
	        IF #iqUDT_Handshake.RTS                                                                                    // If it is Ready to send
	            AND #iqUDT_Handshake.RTR                                                                               // AND Ready TO receive from downstream is available
	            AND #sx_AuxHeadAtEnd                                                                                    // And Parcel is at end of conveyor
	            AND NOT #sx_Gapping                                                                                     // And Not recovering from a dieback
	        THEN                                                                                                        // Then
	            #iqUDT_Handshake.TIP := TRUE;                                                                          // Set Transfer in progress bit
	            #iqUDT_Handshake.RTS := FALSE;                                                                         // And reset Ready to send bit
	            #sx_AuxHeadAtEnd := FALSE;                                                                              // And reset Parcel is at end of conveyor static bit
	            
	        END_IF;
	        
	        IF #R_TRIG_TailToBegin.Q THEN                                                                               // If the parcel tails transffered to downstream conveyor then 
	            #iqUDT_Handshake.TIP := FALSE;                                                                         // Reset Transfer in progress bit
	            #si_GapTailToHead := #iUDT_EquipmentConfiguration.Gap;                                                 // move required Gap to static variable
	        END_IF;
	        
	    END_REGION
	    
	    REGION 6.4 - Takeout conveyor clear
	        (* Before machine startup downstream (takeout) conveyor must be cleard*)
	        
	        IF NOT #ix_ReadyToScan AND #R_TRIG_TakeoutConveyorRuning.Q
	        THEN
	            
	            #sdi_ClearDistance := #idi_TakeoutConveyorLength / 10;
	            
	            #sx_TakeoutConveyorClear := FALSE;
	            
	        END_IF;
	        
	        IF #sdi_ClearDistance > 0 AND #ix_TakeoutConveyorRunning
	        THEN
	            
	            #sdi_ClearDistance -= #iqUDT_Handshake.DownstreamDisplacement;
	            
	            IF #sdi_ClearDistance <= 0 THEN
	                
	                #sx_TakeoutConveyorClear := TRUE;
	                #sdi_ClearDistance := 0;
	                
	            END_IF;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 6.5 - Startup squence
	        (* If conditions are met, the machine is requested to power on. When started and the machine is powered on the prepare to scan command is given *)
	        // Power on XRay generator
	        #tx_PowerOn := #ix_24vOk                                                                                    // If harware inputs 24V, 400V and Profinet IO device is Ok the Power ON Xray.
	        AND #ix_400vOk
	        AND #ix_ProfinetOk;
	        
	        #sx_MachineHealthy := #tx_PowerOn                                                                           // IF Xray is power ON command is active from PLC
	        AND #ix_PowerOn                                                                                             // AND Xray power on feedback is active 
	        AND #ix_MachineOk;                                                                                          // And Machine is OK.
	        
	        // Prepare to Scan 
	        #tx_PrepareToScan := #sx_MachineHealthy
	        AND #sx_MainAutomaticActive                                                                                 // And Automatic activated
	        AND NOT #sx_EnergySaveActive                                                                                // X-Ray is in energy save
	        AND (#sx_TakeoutConveyorClear OR #ix_ReadyToScan);                                                     // And if downstream is clear or machine is ready to scan then send prepare to scan command to machine
	        
	    END_REGION
	    
	    REGION 6.6 - Run X-RAY belts
	        
	        // Start the outfeed Conveyor 
	        #sx_OutfeedConveyorOn := #tx_PrepareToScan// Gantry start rotation, acceleration time ~90 sec. 
	        AND #ix_Interlock
	        AND NOT #sUDT_CommonStatus.Error                                                                           // Equipment has no errors and is ready to operate
	        AND ((#ix_ReadyToScan                                                                                      // Gantry is ready and have the nominal Speed.
	        AND (#ix_XrayReady                                                                                      // X-ray is ready to receive a bag.
	        OR #sx_calibrating)                                                                                 // outfeed conveyor needs to keep running during calibration since main conveyor is running 
	        ))
	        AND (NOT #sx_Gapping                                                                                        // No Dieback
	        OR #iqUDT_Handshake.TIP)                                                                               // OR transfer in progress
	        AND (#iqUDT_Handshake.RTR                                                                                  // Ready to receive from upsteam 
	        OR (NOT #sx_AuxHeadAtEnd                                                                                // or end position is Empty
	        AND NOT #iqUDT_Handshake.TIP))                                                                         // Transfer is not in progress
	        AND NOT #ix_TransitActive                                                                                   // AND Xray is not in transit mode
	        AND NOT #ix_ServiceMode
	        AND NOT #qx_IQTestInfeedHold;                                                                                    // AND Xray is not in service mode
	        
	        // Start the main conveyor
	        #sx_MainConveyorOn := #tx_PrepareToScan// Gantry start rotation, acceleration time ~90 sec. 
	        AND #ix_Interlock
	        AND #sx_MainConvReady                                                                                       // Equipment has no errors and is ready to operate
	        AND ((#ix_ReadyToScan                                                                                       // Gantry is ready and have the nominal Speed.
	        AND (#ix_XrayReady                                                                                    // X-ray is ready receive a bag.
	        OR #sx_calibrating)                                                                                     // main conveyor needs to keep running during calibration
	        ))
	        AND NOT #sx_ParcelAtEnd                                                                                     // No parcel at end of the conveyor
	        AND ((#iqUDT_Handshake.RTR                                                                                 // Downstream conveyor is ready to receive
	        OR (NOT #iqUDT_Handshake.RTS                                                                           // Position at outfeed is free, not detected yet
	        AND #sx_OutfeedConveyorOn)                                                                          // and outfeed conveyor is on
	        OR NOT #sx_ParcelAtEnd))                                                                                // or parcel is not detected in the window
	        AND NOT #ix_TransitActive                                                                                   // AND Xray is not in transit mode
	        AND NOT #ix_ServiceMode
	        AND NOT #qx_IQTestInfeedHold;                                                                                    // AND Xray is not in service mode
	        
	        // Start the infeed conveyor
	        #sx_InfeedConveyorOn :=
	        #sx_MainConveyorOn
	        AND #ix_MainSpeedOk;
	        
	    END_REGION
	    
	    REGION 6.9 - Dieback recovery
	        IF NOT #iqUDT_Handshake.RTR                                                                                // no RTR
	            AND #sx_MainAutomaticActive                                                                                 // Automatic activated
	            AND NOT #sx_OutfeedConveyorOn                                                                           // outfeed is stopped
	            AND NOT #iqUDT_Handshake.TIP                                                                           // TIP is not active
	            AND #si_GapTailToHead > 0
	        THEN
	            #sx_Gapping := TRUE;
	            
	        END_IF;
	        
	        IF #si_GapTailToHead > 0                                                                                    // Gap is bigger than 0
	            OR #sx_Gapping = TRUE                                                                                   // Bit is still high 
	        THEN
	            
	            #si_GapTailToHead -= #iqUDT_Handshake.DownstreamDisplacement;                                          // decrease distance with actual displacement 
	            
	            IF #si_GapTailToHead <= 0                                                                               // Gap is smaller/equal to 0
	            THEN
	                
	                #si_GapTailToHead := 0;                                                                             // reset Gapcounter
	                #sx_Gapping := FALSE;                                                                               // reset dieback memory
	                
	            END_IF;
	        END_IF;
	    END_REGION
	    
	    REGION 6.10 - Interface with upstream conveyor
	        
	        // Move displacement TO upstream
	        #iqUDT_HandShakeUp.DownstreamDisplacement := #iqUDT_MainConveyorInterface.Displacement;                  // Downstream displacement is moved to upstream conveyor to calculate gap
	        
	        // Scanning mode
	        #iqUDT_HandShakeUp.RTR := (#sx_InfeedConveyorOn
	        AND NOT #sx_RunningEmptyMain                                                                               // If not running conveyor empty
	        AND NOT #sx_RunningEmptyOutfeed                                                                            // If not running conveyor empty
	        AND NOT #ix_TransitActive                                                                                  // The transit mode is active.
	        AND NOT #ix_ServiceMode)
	        OR (#ix_IQTestSelection AND #sx_IQTestReady AND #ix_ReadyToScan AND #ix_MainSpeedOk);
	        
	    END_REGION
	    
	    REGION 6.11 - Check parcel at end function
	        (* When the outfeed of the machine is stopped the main conveyor will continue to
	        run until, if there is a parcel still on this conveyor, the parcel reaches the
	        "ix_GINinMainTrack" position.
	         *)
	        
	        IF NOT #sx_OutfeedConveyorOn AND #ix_GINinMainTrack                                                        // outfeed is not running and a GIN is detected in the tracking configured area
	        THEN
	            #sx_ParcelAtEnd := TRUE;                                                                               // Set parcel at end
	        END_IF;
	        
	        IF #sx_OutfeedConveyorOn                                                                                   // Outfeed conveyor is running
	            AND NOT #sx_RunningEmptyOutfeed                                                                        // Running empty is active
	        THEN
	            #sx_ParcelAtEnd := FALSE;                                                                              // Reset parcel at end
	        END_IF;
	    END_REGION
	    
	    REGION 6.12 - Calibration
	        // Delay before the callibration is forced on. Normally the system waits for a gap in the flow to start. If this is timed out the callibration is forced on. 
	        #s_CallibrationForceDelay(iudi_OnDelayTime := #iUDT_EquipmentConfiguration.CallibrationTimeout,
	                                  iudi_OffDelayTime := 0,
	                                  ix_SignalToDelay := (#ix_CalReq AND NOT #ix_AllowCalibration),
	                                  ix_Enable := (#iUDT_EquipmentConfiguration.CallibrationTimeout > 0),
	                                  qx_DelayedSignal => #sx_CallibrateForceOn);
	        
	        
	        IF #ix_CalReq                                                                                               // IF  External calibration request is ON 
	            AND (#ix_AllowCalibration                                                                               // And External callibration allow (a gap in flow present)
	            OR #sx_CallibrateForceOn)                                                                               // Or There was no allow callibration in time, callibration is forced on
	        THEN
	            #sx_ReqToCal := TRUE;                                                                                   // Set request for calibration
	        END_IF;
	        
	        IF NOT #ix_CalReq THEN                                                                                      // input request calibration will reset when calibraiton is done
	            #sx_ReqToCal := FALSE;                                                                                  // Then reset calibration request
	        END_IF;
	        
	        //set ready for calibration 
	        IF #sx_ReqToCal                                                                                             // IF Request to calibration is active
	            AND NOT #iqUDT_HandShakeUp.RTR                                                                         // And ready to receive to upstream is not active
	            AND NOT #iqUDT_HandShakeUp.RTS                                                                         // And it is not ready to send
	            AND NOT #iqUDT_HandShakeUp.TIP                                                                         // And not in transfer in progress
	        THEN                                                                                                        // Then
	            #sx_ReadyForCal := TRUE;                                                                                // Set ready for calibration 
	        END_IF;
	        
	        //reset reday for calibration     
	        IF NOT #ix_CalReq AND #ix_XrayReady THEN                                                                    // If Calibration request is not active and XRAY is ready then 
	            #sx_ReadyForCal := FALSE;                                                                               // Reset ready for calibration
	        END_IF;
	        
	        #qx_ReadyForCal := #sx_ReadyForCal;
	        
	    END_REGION
	    
	    REGION 6.13 - IQ Test sequence
	        
	        #R_TRIG_IQTest(CLK := #ix_IQTestSelection);
	        
	        IF #R_TRIG_IQTest.Q THEN
	            #si_IQTestEmptyDistance := 1600;
	        END_IF;
	        
	        IF #ix_IQTestSelection THEN
	            
	            IF #si_IQTestEmptyDistance > 0 AND #ix_TakeoutConveyorRunning AND #ix_MainSpeedOk THEN
	                #si_IQTestEmptyDistance -= #iqUDT_MainConveyorInterface.Displacement;
	            ELSE
	                #sx_IQTestReady := TRUE;
	            END_IF;
	            
	            IF #sx_IQTestReady AND #iqUDT_EquipmentControl.Command.AutomaticOn THEN
	                
	                #qx_IQTestInfeedHold := FALSE;
	                #qx_IQTestOutfeedHold := FALSE;
	                
	                #qx_IQTestInfeedHold := NOT (#ix_ReadyToScan AND #ix_MainSpeedOk);
	                
	                #s_IQTestRealese(iudi_OnDelayTime := 0,
	                                 iudi_OffDelayTime := 5000,
	                                 ix_SignalToDelay := NOT #ix_IQTestStopPEC,
	                                 qx_DelayedSignal => #qx_IQTestOutfeedHold);
	                
	            END_IF;
	            
	        ELSE
	            #si_IQTestEmptyDistance := 0;
	            #sx_IQTestReady := FALSE;
	            #qx_IQTestInfeedHold := FALSE;
	            #qx_IQTestOutfeedHold := FALSE;
	        END_IF;
	        
	        #qx_IQTestIndication := (#ix_IQTestSelection AND "DB_Memory".Clock_1Hz) OR #sx_IQTestReady;
	        
	    END_REGION
	    
	    REGION 6.14 - Energy save
	        
	        IF #iUDT_EquipmentConfiguration.Energy THEN                                                                // If Energy save functionality is enable from configuration then
	            
	            IF #si_AuxEnergySave >= #iUDT_EquipmentConfiguration.EnergySaveLenght THEN                              // If energy save counter is greater than configigure energy save lenth then
	                #sx_EnergySaveActive := TRUE; // Set energy save active
	                #sx_ResetRunEmptyESave := TRUE; // Set to daisable run empty in case of energy save
	            END_IF;
	            
	            IF (NOT (#sx_PEC_OutfeedEoSFiltered OR #sx_PEC_InfeedEoSFiltered)                                       // If Photo eye detects a parcel
	                AND NOT #sx_EnergySaveActive)                                                                       // And Energy save is not active
	                OR #ix_ResetEnergySave                                                                              // Or external Reset energy save request occured
	                OR #iqUDT_HandShakeUp.ResetEnergySave                                                              // Or if Reset energy save request occur from upstream conveyor 
	                OR #sx_Stopped                                                                                      // Or it is stopped signal
	                // OR #iq_UDT_HandShakeUp.RTS                                                                          // Or upstream is ready to send
	                OR (#sx_EnergySaveActive                                                                            // OR if Energy save active and Signaling request is done and PEC is covered
	                AND (#sx_PEC_OutfeedEoSFiltered OR #sx_PEC_InfeedEoSFiltered)
	                AND #F_TRIG_SignalingRequest.Q)
	            THEN                                                                                                    // Then
	                #si_AuxEnergySave := 0;                                                                             // Reset energy save counter
	                #sx_EnergySaveActive := FALSE;                                                                      // Set energy save active to false
	            ELSE                                                                                                    // Else
	                #si_AuxEnergySave += #iqUDT_MainConveyorInterface.Displacement;                                    // Increament displacement Counter
	            END_IF;
	            
	            
	            
	            // If energy save is active and a photo eye is triggered, signaling is request before start run again
	            
	            IF #sx_EnergySaveActive                                                                                 // Energy save active
	                AND #F_TRIG_PEC_EosFiltered.Q                                                                       // ANd Photo eye detecting a parcel
	                AND NOT #iqUDT_EquipmentControl.Request.SignalingRequest                                           // And Signaling not request
	            THEN
	                #iqUDT_EquipmentControl.Request.SignalingRequest := TRUE;                                          // Set signaling request true
	            END_IF;
	            
	        ELSE                                                                                                        // If energy save functionality is disabled from configuration
	            #si_AuxEnergySave := 0;                                                                                 // Reset energy save counter
	            #sx_EnergySaveActive := FALSE;                                                                          // Set energy save false
	        END_IF;
	        
	        //move energy save to downstream 
	        #iqUDT_Handshake.ResetEnergySave :=
	        #ix_ResetEnergySave                                                                                         // External reset energy save
	        OR NOT #ix_PECOutfeedPosition                                                                                   // Outfeed conveyor PEC is covered 
	        OR NOT #ix_PECInfeedEoS                                                                                    // Infeed conveyor PEC is covered 
	        OR #iqUDT_HandShakeUp.ResetEnergySave                                                                      // Request from upstream to reset energysave
	        OR #ix_CalReq;                                                                                              // Calibration request is active
	        
	    END_REGION
	    
	    REGION 6.15 - Move to outputs
	        // Move temporary bits to output
	        #qx_PowerOn := #tx_PowerOn;
	        #qx_PrepareToScan := #tx_PrepareToScan;
	        #qx_InfeedConveyorOn := #sx_InfeedConveyorOn;
	        #qx_MainConveyorOn := #sx_MainConveyorOn;
	        #qx_OutfeedConveyorOn := #sx_OutfeedConveyorOn;
	        #qx_ESReset := #ix_SafetyReset;
	        #qx_NoScan := #iUDT_HMICommand.NoScanMode;
	    END_REGION
	    
	    REGION 6.16 - Update Interface
	        
	        //Infeed conveyor 
	        #iqUDT_InfeedConveyorInterface.VFDRunning := #sx_InfeedConveyorOn;
	        #iqUDT_InfeedConveyorInterface.RunFwd := #sx_InfeedConveyorOn;
	        #iqUDT_InfeedConveyorInterface.VFDatSpeed := #sx_InfeedConveyorOn;
	        #iqUDT_InfeedConveyorInterface.ResetStatistics := #iqUDT_EquipmentControl.Command.ResetData;
	        #iqUDT_InfeedConveyorInterface.InternalErrorReset := #iqUDT_EquipmentControl.Command.Reset;
	        
	        // main conveyor
	        #iqUDT_MainConveyorInterface.VFDRunning := #ix_MainSpeedOk;
	        #iqUDT_MainConveyorInterface.RunFwd := #ix_MainSpeedOk;
	        #iqUDT_MainConveyorInterface.VFDatSpeed := #ix_MainSpeedOk;
	        #iqUDT_MainConveyorInterface.ResetStatistics := #iqUDT_EquipmentControl.Command.ResetData;
	        #iqUDT_MainConveyorInterface.InternalErrorReset := #iqUDT_EquipmentControl.Command.Reset;
	        
	        // Outfeed conveyor
	        #iqUDT_OutfeedConveyorInterface.VFDRunning := #sx_OutfeedConveyorOn;
	        #iqUDT_OutfeedConveyorInterface.RunFwd := #sx_OutfeedConveyorOn;
	        #iqUDT_OutfeedConveyorInterface.VFDatSpeed := #sx_OutfeedConveyorOn;
	        #iqUDT_OutfeedConveyorInterface.ResetStatistics := #iqUDT_EquipmentControl.Command.ResetData;
	        #iqUDT_OutfeedConveyorInterface.InternalErrorReset := #iqUDT_EquipmentControl.Command.Reset;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 7 - Statistics
	    // X-Ray mode active
	    IF (NOT #sUDT_CommonStatus.Stopped AND NOT #ix_ServiceMode AND NOT #ix_TransitActive)
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := (NOT #sUDT_CommonStatus.Stopped AND NOT #ix_ServiceMode AND NOT #ix_TransitActive),
	                        ix_RTrigActivate := #R_TRIG_XRayMode.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.XRayMode);
	    END_IF;
	    
	    // Service mode active
	    IF NOT #sUDT_CommonStatus.Stopped AND #ix_ServiceMode
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := NOT #sUDT_CommonStatus.Stopped AND #ix_ServiceMode,
	                        ix_RTrigActivate := #R_TRIG_ServiceMode.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.ServiceMode);
	    END_IF;
	    
	    // Transit mode active   
	    IF NOT #sUDT_CommonStatus.Stopped AND #ix_TransitActive
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := NOT #sUDT_CommonStatus.Stopped AND #ix_TransitActive,
	                        ix_RTrigActivate := #R_TRIG_TransitMode.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.TransitMode);
	    END_IF;
	    
	    // Safety not Ok
	    IF #ix_SafetyOk
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := NOT #ix_SafetyOk,
	                        ix_RTrigActivate := #R_TRIG_Estop.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.EStopActive);
	    END_IF;
	    
	    // Repairswitch
	    IF #ix_RepairSwitch
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := NOT #ix_RepairSwitch,
	                        ix_RTrigActivate := #R_TRIG_RepairSwitch.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.RepairSwitch);
	    END_IF;
	    
	    // Temperature out OF range
	    IF #ix_TempOutOfRange
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #ix_TempOutOfRange,
	                        ix_RTrigActivate := #R_TRIG_TempOutOfRange.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.TempOutOfRange);
	    END_IF;
	    
	    // Stopped
	    IF #sUDT_CommonStatus.Stopped
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_CommonStatus.Stopped,
	                        ix_RTrigActivate := #R_TRIG_Stop.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.Stopped);
	    END_IF;
	    
	    // Calibrating
	    IF #sx_calibrating
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sx_calibrating,
	                        ix_RTrigActivate := #R_TRIG_Calibrating.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.Calibrating);
	    END_IF;
	    
	    // Callibration forced
	    #R_TRIG_CalibrationForce(CLK := #sx_CallibrateForceOn);
	    
	    IF #sx_CallibrateForceOn
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sx_CallibrateForceOn,
	                        ix_RTrigActivate := #R_TRIG_CalibrationForce.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.CallibrationForced);
	    END_IF;
	    
	    // Interlock
	    IF NOT #ix_Interlock
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := NOT #ix_Interlock,
	                        ix_RTrigActivate := #F_TRIG_Interlock.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.Interlock);
	    END_IF;
	    
	    // Infeed conveyor "Error"
	    #R_TRIG_InfConvErr(CLK := #sUDT_HMIStatus.InfeedConvSpecific.Conv_ERR);
	    
	    IF #sUDT_HMIStatus.InfeedConvSpecific.Conv_ERR
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.InfeedConvSpecific.Conv_ERR,
	                        ix_RTrigActivate := #R_TRIG_InfConvErr.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.InfeedConveyorError);
	    END_IF;
	    
	    // Outfeed conveyor "Error"
	    #R_TRIG_OutfConvErr(CLK := #sUDT_HMIStatus.OutfeedConvSpecific.Conv_ERR);
	    
	    IF #sUDT_HMIStatus.OutfeedConvSpecific.Conv_ERR
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.OutfeedConvSpecific.Conv_ERR,
	                        ix_RTrigActivate := #R_TRIG_OutfConvErr.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.OutfeedConveyorError);
	    END_IF;
	    
	    // Encoder "Error"
	    #R_TRIG_EncoderErr(CLK := #sUDT_HMIStatus.InfeedConvSpecific.Encoder_ERR
	                       OR #sUDT_HMIStatus.MainConvSpecific.Encoder_ERR
	                       OR #sUDT_HMIStatus.OutfeedConvSpecific.Encoder_ERR);
	    
	    IF #sUDT_HMIStatus.InfeedConvSpecific.Encoder_ERR
	        OR #sUDT_HMIStatus.MainConvSpecific.Encoder_ERR
	        OR #sUDT_HMIStatus.OutfeedConvSpecific.Encoder_ERR
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.InfeedConvSpecific.Encoder_ERR
	                        OR #sUDT_HMIStatus.MainConvSpecific.Encoder_ERR
	                        OR #sUDT_HMIStatus.OutfeedConvSpecific.Encoder_ERR,
	                        ix_RTrigActivate := #R_TRIG_EncoderErr.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.EncoderError);
	    END_IF;
	    
	    // Move statistics to statistics output
	    
	END_REGION
	
	REGION 8 - Status    
	    REGION 8.1 - Infeed conveyor common status
	        #sUDT_InfeedConvCommonStatus.Stopped := NOT #sx_MainAutomaticActive OR #sUDT_InfeedConvCommonStatus.Error;
	        #sUDT_InfeedConvCommonStatus.Halted := FALSE;
	        #sUDT_InfeedConvCommonStatus.Running := #sx_InfeedConveyorOn;
	        #sUDT_InfeedConvCommonStatus.Dieback := #sx_MainAutomaticActive AND NOT #sx_InfeedConveyorOn AND NOT #sx_EnergySaveActive;
	        #sUDT_InfeedConvCommonStatus.Manual := FALSE;
	        #sUDT_InfeedConvCommonStatus.EnergySave := #sx_EnergySaveActive;
	        #sUDT_InfeedConvCommonStatus.Warning := FALSE;
	        #sUDT_InfeedConvCommonStatus.SafetyStop := NOT #ix_SafetyOk;
	        
	        IF #sUDT_InfeedConvCommonStatus <> #sUDT_InfeedConvCommonStatusOld THEN
	            
	            // Set status to status number
	            #sUDT_HMIStatus.InfeedConvSpecific.Status := 0;                                        // Initialise status number              
	            
	            IF #sUDT_InfeedConvCommonStatus.EnergySave                                                 // Energy save
	            THEN
	                
	                #sUDT_HMIStatus.InfeedConvSpecific.Status := "DB_HMIStatusConfiguration".EnergySave;
	                
	            END_IF;
	            
	            IF #sUDT_InfeedConvCommonStatus.Running                                                    // Running
	            THEN
	                
	                #sUDT_HMIStatus.InfeedConvSpecific.Status := "DB_HMIStatusConfiguration".Running;
	                
	            END_IF;
	            
	            IF #sUDT_InfeedConvCommonStatus.Stopped                                                    // Stopped
	            THEN
	                
	                #sUDT_HMIStatus.InfeedConvSpecific.Status := "DB_HMIStatusConfiguration".Stopped;
	                
	            END_IF;
	            
	            IF #sUDT_InfeedConvCommonStatus.Dieback                                                    // Dieback
	            THEN
	                
	                #sUDT_HMIStatus.InfeedConvSpecific.Status := "DB_HMIStatusConfiguration".Dieback;
	                
	            END_IF;
	            
	            IF #sUDT_HMIStatus.InfeedConvSpecific.Conv_ERR                                         // Conveyor error
	            THEN
	                
	                #sUDT_HMIStatus.InfeedConvSpecific.Status := "DB_HMIStatusConfiguration".Error;
	                
	            END_IF;
	            
	            IF #sUDT_HMIStatus.InfeedConvSpecific.Encoder_ERR                                      // Encoder error
	            THEN
	                
	                #sUDT_HMIStatus.InfeedConvSpecific.Status := "DB_HMIStatusConfiguration".EncoderError;
	                
	            END_IF;
	            
	            IF #sUDT_HMIStatus.InfeedConvSpecific.PEC_EoSJam                                       // EOS PEC jam
	            THEN
	                
	                #sUDT_HMIStatus.InfeedConvSpecific.Status := "DB_HMIStatusConfiguration".PECJam;
	                
	            END_IF;
	            
	            IF #sUDT_InfeedConvCommonStatus.SafetyStop                                                // Safety stop
	            THEN
	                
	                #sUDT_HMIStatus.InfeedConvSpecific.Status := "DB_HMIStatusConfiguration".SafetyStop;
	                
	            END_IF;
	            #qUDT_HMIStatus := #sUDT_HMIStatus;                                                  // Copy status to output
	            #sUDT_InfeedConvCommonStatusOld := #sUDT_InfeedConvCommonStatus;                             // Copy status TO memory
	            
	        END_IF;
	    END_REGION
	    
	    
	    REGION 8.2 - Main conveyor common status
	        
	        #sUDT_MainConvCommonStatus.Stopped := NOT #sx_MainAutomaticActive OR #sUDT_MainConvCommonStatus.Error;
	        #sUDT_MainConvCommonStatus.Halted := FALSE;
	        #sUDT_MainConvCommonStatus.Running := #sx_MainConveyorOn;
	        #sUDT_MainConvCommonStatus.Dieback := #sx_MainAutomaticActive AND NOT #sx_MainConveyorOn AND NOT #sx_EnergySaveActive;
	        #sUDT_MainConvCommonStatus.Manual := FALSE;
	        #sUDT_MainConvCommonStatus.EnergySave := #sx_EnergySaveActive;
	        #sUDT_MainConvCommonStatus.Warning := FALSE;
	        #sUDT_MainConvCommonStatus.SafetyStop := NOT #ix_SafetyOk;
	        
	        IF #sUDT_MainConvCommonStatus <> #sUDT_MainConvCommonStatusOld THEN
	            // Set status to status number
	            #sUDT_HMIStatus.MainConvSpecific.Status := 0;                                        // Initialise status number              
	            
	            IF #sUDT_MainConvCommonStatus.EnergySave                                                 // Energy save
	            THEN
	                
	                #sUDT_HMIStatus.MainConvSpecific.Status := "DB_HMIStatusConfiguration".EnergySave;
	                
	            END_IF;
	            
	            IF #sUDT_MainConvCommonStatus.Running                                                    // Running
	            THEN
	                
	                #sUDT_HMIStatus.MainConvSpecific.Status := "DB_HMIStatusConfiguration".Running;
	                
	            END_IF;
	            
	            IF #sUDT_MainConvCommonStatus.Stopped                                                    // Stopped
	            THEN
	                
	                #sUDT_HMIStatus.MainConvSpecific.Status := "DB_HMIStatusConfiguration".Stopped;
	                
	            END_IF;
	            
	            IF #sUDT_MainConvCommonStatus.Dieback                                                    // Dieback
	            THEN
	                
	                #sUDT_HMIStatus.MainConvSpecific.Status := "DB_HMIStatusConfiguration".Dieback;
	                
	            END_IF;
	            
	            IF #sUDT_HMIStatus.MainConvSpecific.Conv_ERR                                         // Conveyor error
	            THEN
	                
	                #sUDT_HMIStatus.MainConvSpecific.Status := "DB_HMIStatusConfiguration".Error;
	                
	            END_IF;
	            
	            IF #sUDT_HMIStatus.MainConvSpecific.Encoder_ERR                                      // Encoder error
	            THEN
	                
	                #sUDT_HMIStatus.MainConvSpecific.Status := "DB_HMIStatusConfiguration".EncoderError;
	                
	            END_IF;
	            
	            IF #sUDT_MainConvCommonStatus.SafetyStop                                                // Safety stop
	            THEN
	                
	                #sUDT_HMIStatus.MainConvSpecific.Status := "DB_HMIStatusConfiguration".SafetyStop;
	                
	            END_IF;
	            #sUDT_MainConvCommonStatusOld := #sUDT_MainConvCommonStatus;                               // Copy status TO memory
	        END_IF;
	    END_REGION
	    
	    
	    REGION 8.3 - Outfeed conveyor common status
	        
	        #sUDT_OutfeedConvCommonStatus.Stopped := NOT #sx_MainAutomaticActive OR #sUDT_OutfeedConvCommonStatus.Error;
	        #sUDT_OutfeedConvCommonStatus.Halted := FALSE;
	        #sUDT_OutfeedConvCommonStatus.Running := #sx_OutfeedConveyorOn;
	        #sUDT_OutfeedConvCommonStatus.Dieback := #sx_MainAutomaticActive AND NOT #sx_OutfeedConveyorOn AND NOT #sx_EnergySaveActive;
	        #sUDT_OutfeedConvCommonStatus.Manual := FALSE;
	        #sUDT_OutfeedConvCommonStatus.EnergySave := #sx_EnergySaveActive;
	        #sUDT_OutfeedConvCommonStatus.Warning := FALSE;
	        #sUDT_OutfeedConvCommonStatus.SafetyStop := NOT #ix_SafetyOk;
	        
	        IF #sUDT_OutfeedConvCommonStatus <> #sUDT_OutfeedConvCommonStatusOld THEN
	            
	            // Set status to status number
	            #sUDT_HMIStatus.OutfeedConvSpecific.Status := 0;                                     // Initialise status number              
	            
	            IF #sUDT_OutfeedConvCommonStatus.EnergySave                                              // Energy save
	            THEN
	                
	                #sUDT_HMIStatus.OutfeedConvSpecific.Status := "DB_HMIStatusConfiguration".EnergySave;
	                
	            END_IF;
	            
	            IF #sUDT_OutfeedConvCommonStatus.Running                                                 // Running
	            THEN
	                
	                #sUDT_HMIStatus.OutfeedConvSpecific.Status := "DB_HMIStatusConfiguration".Running;
	                
	            END_IF;
	            
	            IF #sUDT_OutfeedConvCommonStatus.Stopped                                                 // Stopped
	            THEN
	                
	                #sUDT_HMIStatus.OutfeedConvSpecific.Status := "DB_HMIStatusConfiguration".Stopped;
	                
	            END_IF;
	            
	            IF #sUDT_OutfeedConvCommonStatus.Dieback                                                 // Dieback
	            THEN
	                
	                #sUDT_HMIStatus.OutfeedConvSpecific.Status := "DB_HMIStatusConfiguration".Dieback;
	                
	            END_IF;
	            
	            IF #sUDT_HMIStatus.OutfeedConvSpecific.Conv_ERR                                      // Conveyor error
	            THEN
	                
	                #sUDT_HMIStatus.OutfeedConvSpecific.Status := "DB_HMIStatusConfiguration".Error;
	                
	            END_IF;
	            
	            IF #sUDT_HMIStatus.OutfeedConvSpecific.Encoder_ERR                                   // Encoder error
	            THEN
	                
	                #sUDT_HMIStatus.OutfeedConvSpecific.Status := "DB_HMIStatusConfiguration".EncoderError;
	                
	            END_IF;
	            
	            IF #sUDT_HMIStatus.OutfeedConvSpecific.PEC_EoSJam                                    // EOS PEC jam
	            THEN
	                
	                #sUDT_HMIStatus.OutfeedConvSpecific.Status := "DB_HMIStatusConfiguration".PECJam;
	                
	            END_IF;
	            
	            IF #sUDT_OutfeedConvCommonStatus.SafetyStop                                              // Safety stop
	            THEN
	                
	                #sUDT_HMIStatus.OutfeedConvSpecific.Status := "DB_HMIStatusConfiguration".SafetyStop;
	                
	            END_IF;
	            #sUDT_OutfeedConvCommonStatusOld := #sUDT_OutfeedConvCommonStatus;                          // Copy status TO memory
	        END_IF;
	    END_REGION
	    
	    
	    REGION 8.4 - Xray Common status
	        
	        #sUDT_CommonStatus.Stopped := NOT #sx_MainAutomaticActive;                                                // stopped
	        #sUDT_CommonStatus.Running := #sx_MainAutomaticActive AND #tx_PrepareToScan AND #iqUDT_HandShakeUp.RTR AND NOT #sx_EnergySaveActive;         // Running
	        #sUDT_CommonStatus.Halted := FALSE;                                                                       // Halted
	        #sUDT_CommonStatus.Dieback := #sx_MainAutomaticActive AND #tx_PrepareToScan AND NOT #iqUDT_HandShakeUp.RTR AND NOT #sx_EnergySaveActive;     // Die back
	        #sUDT_CommonStatus.Manual := #sx_ManualModeActive;                                                        // Manual
	        #sUDT_CommonStatus.EnergySave := #sx_EnergySaveActive;                                                    // Energy save active
	        #sUDT_CommonStatus.SafetyStop := NOT #ix_SafetyOk;                                                        // Safety not ok
	        
	        IF #sUDT_CommonStatusOld <> #sUDT_CommonStatus                                          // update on change
	        THEN
	            
	            // Set status to status number
	            #sUDT_HMIStatus.Status := 0;                                                         // Initialise status number              
	            
	            IF #sUDT_CommonStatus.EnergySave                                                     // Energy save
	            THEN
	                
	                #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".EnergySave;
	                
	            END_IF;
	            
	            IF #sUDT_CommonStatus.Running                                                        // Running
	            THEN
	                
	                #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Running;
	                
	            END_IF;
	            
	            IF #sUDT_CommonStatus.Stopped                                                       // Stopped
	            THEN
	                
	                #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Stopped;
	                
	            END_IF;
	            
	            IF #sUDT_MainConvCommonStatus.Dieback                                                    // Dieback
	            THEN
	                
	                #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Dieback;
	                
	            END_IF;
	            
	            IF #sUDT_CommonStatus.Manual                                                       // Manual
	            THEN
	                
	                #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Manual;
	                
	            END_IF;
	            
	(*            IF #s_UDT_CommonStatus.Warning                                                      // Warning
	            THEN
	                
	                #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Warning;
	                
	            END_IF; *)
	            
	            IF #sUDT_CommonStatus.Error                                                       // Manual
	            THEN
	                
	                #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Error;
	                
	            END_IF;
	            
	            IF #sUDT_CommonStatus.SafetyStop                                                  // Safety stop
	            THEN
	                
	                #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".SafetyStop;
	                
	            END_IF;
	            
	            #sUDT_CommonStatusOld := #sUDT_CommonStatus;                                     // Copy status TO memory
	            
	        END_IF;
	        
	    END_REGION
	    
	    #qUDT_HMIStatus := #sUDT_HMIStatus;
	    
	END_REGION
	
	REGION 9 - Report to control block
	    //Xray
	    "FC_EquipmentReport"(iUDT_Status := #sUDT_CommonStatus,
	                         iqUDT_Control := #iqUDT_EquipmentControl);
	    //Outfeed conveyor
	    "FC_EquipmentReport"(iUDT_Status := #sUDT_OutfeedConvCommonStatus,
	                         iqUDT_Control := #iqUDT_EquipmentControl);
	    //Main conveyor
	    "FC_EquipmentReport"(iUDT_Status := #sUDT_MainConvCommonStatus,
	                         iqUDT_Control := #iqUDT_EquipmentControl);
	    // Infeed conveyor
	    "FC_EquipmentReport"(iUDT_Status := #sUDT_InfeedConvCommonStatus,
	                         iqUDT_Control := #iqUDT_EquipmentControl);
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_Sorter"
TITLE = FB_Sorter
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : Sorter
VERSION : 3.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 227
// END_ATTRIBUTES
//Function block to control shoe sorter conveyor
   VAR_INPUT 
      iUDT_ConveyorConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_SorterConveyorConfiguration";   //  Conveyor configuration structure
      ix_SafetyOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when safety is ok
      ix_SS1Active { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when SS1 is active
      ix_24vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when 24VDC is healthy
      ix_400vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when 400VAC is healthy
      ix_ProfinetOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when the PN node(s) of conveyor are OK
      ix_PECEoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when the end of section photoeye in forward direction is not blocked
      ix_PECBoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when the end of section photoeye in reverse direction is not blocked
      ix_ExternalRequestHold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  External input to request conveyor hold
      ix_ResetEnergySave { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Reset energy save mode timer
      ix_SorterInterlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE sorter mechanical interlock error
      ix_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when  hardware is Ok
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorStatus";   //  HMI status structure
      qUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   //  Common status structure
   END_VAR

   VAR_IN_OUT 
      iqUDT_PendantInerface : "UDT_PendantVT100Interface";   //  Pendant VT100 Interface
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   //  Equipment control structure
      iqUDT_ConveyorCommand : "UDT_ConveyorCommand";   //  Conveyor command stucture
      iqUDT_ConveyorInterface : "UDT_ConveyorInterface";   //  Interface structure
      iqUDT_HandShakeUp : "UDT_ConveyorHandshake";   //  Upstream handshake structure in forward direction
      iqUDT_HandShake : "UDT_ConveyorHandshake";   //  Handshake structure in forward direction
      iqUDT_Statistics : "UDT_ConveyorStatistics";   //  Statistics structure
   END_VAR

   VAR 
      sUDT_CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //  Common status structure
      sUDT_CommonStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //  Auxiliary status structure
      sUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";   //  HMI status structure
      sFB_CascadeModeTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //  Timer to cascade start
      sR_TRIG_ManualMode {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger manual mode
      sR_TRIG_Jog {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger manual jog
      sF_TRIG_ManualMode {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //  Falling edge trigger manual mode
      sF_TRIG_Jog {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //  Falling edge trigger manual mode jog
      sR_TRIG_ConveyorUp {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger conveyor up time
      sR_TRIG_EnergySave {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger energy save
      sR_TRIG_VFDRunning {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger VFD running
      sR_TRIG_ConveyorDownTime {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger conveyor down
      sR_TRIG_RunManual {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge run conveyor in manual mode
      sR_TRIG_StopRunManual {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Falling edge run conveyor in manual mode
      sR_TRIG_ServiceMode {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge service mode is enabled
      sF_TRIG_ServiceMode {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //  Falling edge service mode is enabled
      sR_TRIG_ConveyorStopped {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge of stop
      sR_TRIG_PreStartrManual {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
   END_VAR
   VAR RETAIN
      sdi_AuxEnergySaveFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //  Auxiliary variable to calculate energy save displacement
   END_VAR
   VAR 
      sx_Ready { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Conveyor Ready to operate in Automatic mode
      sx_Safetyok { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Safety is ok
   END_VAR
   VAR RETAIN
      sx_StartReceived { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Save start trigger from the system
      sx_EnergySaveActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Active energy save mode
   END_VAR
   VAR 
      sx_AutomaticActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Automatic active
      sx_ManualModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Manual mode active
      sx_PreStartManual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Pre conditions to run conveyor in manual mode
      sx_CascadeStartUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Cascade startup auxiliary bit
      sx_ManualRunning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Conveyor running in manual mode
      sx_Up { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Conveyor is up
      sx_Down { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Conveyor is down
      sx_Stopped { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Conveyor is stopped
   END_VAR

   VAR_TEMP 
      tx_Up : Bool;
      tx_Down : Bool;
      tx_Stop : Bool;
   END_VAR

   VAR CONSTANT 
      ci_OverflowLimit : Int := 32000;   //  Limit int overflow
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	            | 3.0       | C.Leite       | First release TIA 15.1
	06/04/2020  | 3.1       | S. Theocharis | Modified Conveyor block to sorter block
	07/02/2020  | 3.2       | K. Pokorski   | Modified condition to disable manual mode (safety ok), modified singaling request activation in manual mode
	07/02/2020  | 3.3       | S. Theocharis | Updated the engergy save mode. Test on the primary sorters
	09/07/2020  | 3.4       | S. Theocharis | Write HMI status in every scan
	16/07/2020  | 3.5       | S. Theocharis | Pendant speed hardcoded to 500mm/s
	31/07/2020  | 3.6       | S. Theocharis | Reset HMI commands of manual mode when conveyor no ready
	19/08/2020  | 3.7       | S. Theocharis | Encoder fault added. Manual mode to interface. Fix statistics
	02/03/2021  | 3.8       | K. Pokorski   | Halted status enable only when automatic on
	23/03/2021  | 3.9       | K. Pokorski   | Protect before starting sorter when ramping down.
	22/07/2021  | 3.10      | S. Theocharis | Added Manual speed
	27/07/2021  | 3.11      | S. Theocharis | Energy Save, safety ok logic modifed
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Initial
	    
	    REGION 1.1 - First PLC cycle
	        
	        // Conveyor stops in the first scan of the PLC
	        IF "DB_Memory".FirstScan
	        THEN
	            #iqUDT_EquipmentControl.Command.Start := FALSE;    // Command start
	            #sx_AutomaticActive := FALSE;                       // switch of automatic active
	            #iqUDT_HandShakeUp.RTR := False;                   // Reset RTR signal
	            
	            #iqUDT_HandShakeUp.CascadeStartUp := FALSE;        // Reset cascade start signal
	            
	            #iqUDT_ConveyorInterface.RunFwd := FALSE;          // Order to run forward to VFD
	            #iqUDT_ConveyorInterface.RunRvs := FALSE;          // Order to run reverse to VFD
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 1.2 Conditions Up - Down - Stopped
	        //Used for statistics
	        
	        #sx_Up := (#sx_AutomaticActive                               // Automatic active
	        AND #sx_Ready                                                // Ready active
	        AND NOT #sx_EnergySaveActive);                              // Not in energy save
	        
	        #sx_Down := (NOT #sx_ManualModeActive                                                   // Not in manual mode
	        AND #sUDT_CommonStatus.Error                                                           // in error 
	        AND NOT #sx_Ready                                                                       // Conveyor not ready
	        AND NOT #sx_EnergySaveActive);                                                          // Not in energy save
	        
	        #sx_Stopped := (NOT #sx_AutomaticActive AND #sx_Ready);
	        
	    END_REGION
	    
	    REGION 1.3 - Triggers
	        
	        // Rising edge trigger manual mode
	        #sR_TRIG_ManualMode(CLK := #iqUDT_ConveyorCommand.ManualMode
	                            OR #iqUDT_EquipmentControl.Command.ManualMode);
	        
	        // Falling edge trigger manual mode
	        #sF_TRIG_ManualMode(CLK := #iqUDT_ConveyorCommand.ManualMode
	                            OR #iqUDT_EquipmentControl.Command.ManualMode);
	        
	        // Rising edge trigger manual mode jog
	        #sR_TRIG_Jog(CLK := #iqUDT_ConveyorCommand.ManualJog);
	        
	        // Falling edge trigger manual mode jog
	        #sF_TRIG_Jog(CLK := #iqUDT_ConveyorCommand.ManualJog);
	        
	        // Rising edge trigger to start in manual mode
	        #sR_TRIG_RunManual(CLK := #iqUDT_ConveyorCommand.ManualStartStop);
	        
	        // Rising edge conveyor up
	        #sR_TRIG_ConveyorUp(CLK := #sx_Up);
	        
	        // Rising edge energy save mode
	        #sR_TRIG_EnergySave(CLK := #sx_EnergySaveActive);
	        
	        // Rising edge running
	        #sR_TRIG_VFDRunning(CLK := #iqUDT_ConveyorInterface.VFDRunning);
	        
	        // Rising edge conveyor conveyor down
	        #sR_TRIG_ConveyorDownTime(CLK := #sx_Down);
	        
	        //Rising edge conveyor stopped
	        #sR_TRIG_ConveyorStopped(CLK := #sx_Stopped);
	        
	        //Rising edge Pendant mode
	        #sR_TRIG_ServiceMode(CLK := #iqUDT_PendantInerface.ServiceModeEngaged);
	        
	        //Falling edge Pendant mode
	        #sF_TRIG_ServiceMode(CLK := #iqUDT_PendantInerface.ServiceModeEngaged);
	        
	    END_REGION
	    
	    REGION 1.3 - Move displacement to upstream
	        // Downstream displacement is mode to upstream conveyor to calculate gap
	        #iqUDT_HandShakeUp.DownstreamDisplacement := #iqUDT_ConveyorInterface.Displacement;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 2 - Reset faults
	    
	    REGION 2.1 - Send reset request to interface UDT
	        
	        // Reset signal is sent to the interface UDT (VFD block, Tracking block, PEC update block)
	        #iqUDT_ConveyorInterface.InternalErrorReset := #iqUDT_EquipmentControl.Command.Reset;
	        #iqUDT_ConveyorInterface.ResetStatistics := #iqUDT_EquipmentControl.Command.ResetData;
	        
	    END_REGION
	    
	    REGION 2.2 - Error / warning
	        
	        #sUDT_CommonStatus.Error := #iqUDT_ConveyorInterface.InternalErrorPEC           // Internal PEC error status
	        OR #iqUDT_ConveyorInterface.InternalErrorVFD            // Internal VFD error status
	        OR #iqUDT_ConveyorInterface.InternalErrorTracking       // Not applicable in Shoe sorter
	        OR #iqUDT_ConveyorInterface.Disconnected                // Isolator switch error status 
	        OR #ix_SorterInterlockError                             // Sorter Interlock errors are handled in the sortation code
	        OR #iqUDT_ConveyorInterface.InternalErrorEncoder;       // Encoder error
	        
	        #sUDT_CommonStatus.Warning := #iqUDT_ConveyorInterface.InternalWarningTracking  // v2.3 Internal Warning Tracking  added
	        OR #iqUDT_ConveyorInterface.InternalWarningVFD;                                 // v2.3 Internal Warning VFD added
	        
	    END_REGION
	    
	END_REGION
	
	REGION 3 - Check conditions to set conveyor ready
	    
	    //Set safety OK bit. 
	    //Different logic for service mode in order to mask the STO when SLS is active and drive is standstill
	    #sx_Safetyok := (#ix_SafetyOk AND NOT #iqUDT_PendantInerface.ServiceModeEngaged)
	    OR (#iqUDT_PendantInerface.ServiceModeEngaged AND NOT #ix_SS1Active);
	    
	    
	    //  Conditions to set bit sx_Ready to operate in automatic mode
	    #sx_Ready := NOT #sUDT_CommonStatus.Error                   // Ready bit is set true when common error status its false
	    AND #sx_Safetyok
	    AND #ix_24vOk                                               // 24V error status
	    AND #ix_400vOk                                              // 400V error status
	    AND #ix_ProfinetOk                                          // Profinet error status
	    AND NOT #iqUDT_ConveyorInterface.ConfigurationError         // No configuration error      
	    AND NOT #ix_SorterInterlockError;                           // Sorter interlock error
	    
	END_REGION
	
	REGION 4 - Stop conveyor
	    
	    // Conditions to stop conveyor
	    IF ((#sR_TRIG_StopRunManual.Q                               // Trigger when conveyor stops in manual mode
	        OR #sF_TRIG_Jog.Q)                                      // Trigger when conveyor stops jogging by HMI
	        AND #sx_ManualModeActive)                               // Manual mode is active
	        
	        OR (NOT #iqUDT_EquipmentControl.Command.AutomaticOn     // Conveyor stops if the bit AutomaticOn from control block is false
	        AND NOT #sx_ManualModeActive)                           // Manual mode active bit
	        
	        OR (NOT #sx_Ready                                       // Bit conveyor ready to run in automatic mode
	        AND NOT #sx_ManualModeActive)                           // Manual mode active
	        
	        OR #sR_TRIG_ManualMode.Q                                // Trigger when manual mode is set on
	        OR #sF_TRIG_ManualMode.Q                                // Trigger when manual mode is set off
	        
	        OR #sR_TRIG_ServiceMode.Q                               // Sorter related. Rising edge Service mode is enabled
	        OR #sF_TRIG_ServiceMode.Q                               // Sorter related. Falling edge Service mode is enabled
	    THEN
	        //  Order to stop VFD
	        #iqUDT_ConveyorInterface.RunFwd := FALSE;               // Set false order to VFD run in forward direction
	        #iqUDT_ConveyorInterface.RunRvs := FALSE;               // Set false order to VFD run in reverse direction
	        
	        #iqUDT_HandShakeUp.RTR := FALSE;                        // Set false the bit ready to receive
	        #iqUDT_HandShakeUp.CascadeStartUp := FALSE;             // Set false cascade start up bit
	        
	        
	        #sx_AutomaticActive := FALSE;                           // Automatic mode is disable
	        #sx_StartReceived := FALSE;                             // Clear start receive bit 
	        
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Start
	    
	    REGION 5.1 - Save Start bit request
	        
	        // The conditions to set the bit "startReceived" are: 
	        // - Conveyor not in manual mode.
	        // - Conveyor ready to run.
	        // - Bit AutomaticOn from control block must be on.
	        // - Bit start form control block on.
	        // - Sorter related. Service mode is not engaged
	        
	        IF NOT #sx_ManualModeActive
	            AND #sx_Ready
	            AND #iqUDT_EquipmentControl.Command.Start
	            AND #iqUDT_EquipmentControl.Command.AutomaticOn
	            AND NOT #iqUDT_PendantInerface.ServiceModeEngaged
	            AND (NOT #iqUDT_ConveyorInterface.VFDRunning OR #iqUDT_ConveyorInterface.RunFwd)
	        THEN
	            #sx_StartReceived := TRUE;                          // Start bit from control block received
	        END_IF;
	        
	    END_REGION
	    
	    REGION 5.2 - Cascade mode
	        
	        (* If the bit "StartReceived" is set, automatic mode is activated if the conveyor is set as the first one to run
	         or the bit cascadestartup from downstream is on. *)
	        
	        IF #sx_StartReceived
	            AND (#iUDT_ConveyorConfiguration.Forward_Direction.FirstConveyorToStart
	            OR #iqUDT_HandShake.CascadeStartUp)
	        THEN
	            #sx_AutomaticActive := TRUE;                        // Conveyor active automatic mode
	            #sx_StartReceived := FALSE;                         // Reset start bit received from control block
	        END_IF;
	        
	        //Timer to cascade mode
	        #sFB_CascadeModeTimer(iudi_OnDelayTime := #iUDT_ConveyorConfiguration.CascadeTimeOnDelay,   // Cascade mode timer
	                              ix_SignalToDelay := #sx_AutomaticActive,
	                              ix_Enable := #sx_Ready,                                              // Signal ready to enable cascade mode
	                              qx_DelayedSignal => #sx_CascadeStartUp);                             // Cascade mode signal to upstream
	        
	        #iqUDT_HandShakeUp.CascadeStartUp := #sx_CascadeStartUp;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 6 - Manual mode
	    
	    REGION 6.1 - Manual mode force disable 
	        // Manual mode bits inputs can be reset in case of malfunction
	        // or when the service mode is engaged from the pendant
	        // or safety is not ok
	        IF #iqUDT_EquipmentControl.Command.DisableManualMode
	            OR #iqUDT_PendantInerface.ServiceModeEngaged
	        THEN
	            
	            #iqUDT_ConveyorCommand.ManualMode := False;
	            #iqUDT_EquipmentControl.Command.ManualMode := False;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 6.2 - Manual mode activation 
	        
	        // Manual mode is active if it is active from hmi or by control block  
	        #sx_ManualModeActive := (#iqUDT_ConveyorCommand.ManualMode
	        OR #iqUDT_EquipmentControl.Command.ManualMode)
	        AND NOT #iqUDT_PendantInerface.ServiceModeEngaged;
	        
	        //Send manual mode active to PEC/VFD blocks to supress errors
	        #iqUDT_ConveyorInterface.ManualModeActive := #sx_ManualModeActive;
	        
	    END_REGION
	    
	    REGION 6.3 - Reset manual commands 
	        //When the system is not any more in manual mode or when fatal error occurs the HMI commands should be reset
	        IF NOT #sx_Safetyok
	            OR NOT #ix_24vOk                                    // 24V error status
	            OR NOT #ix_400vOk                                   // 400V error status
	            OR NOT #ix_ProfinetOk                               // Profinet error status
	            OR #iqUDT_ConveyorInterface.ConfigurationError      // No configuration err
	            OR #iqUDT_ConveyorInterface.InternalErrorVFD
	            OR #iqUDT_ConveyorInterface.Disconnected
	            OR NOT #sx_ManualModeActive
	            OR #iqUDT_PendantInerface.ServiceModeEngaged
	        THEN
	            #iqUDT_ConveyorCommand.ManualStartStop := FALSE;
	            #iqUDT_ConveyorCommand.ManualFullSpeed := FALSE;
	            #iqUDT_ConveyorCommand.ManualJog := FALSE;
	            #iqUDT_ConveyorCommand.Reverse := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 6.3 - Start/Stop
	        
	        // Pre start conditions to run in manual mode
	        #sx_PreStartManual := #sx_ManualModeActive              // Manual mode active bit
	        AND #sx_Safetyok                                        // Safety healthy bit
	        AND NOT #iqUDT_ConveyorInterface.Disconnected           // Isolator switch connected
	        AND #ix_ProfinetOk                                      // Profinet comunication 
	        AND NOT #iqUDT_ConveyorInterface.InternalErrorVFD;      // Internal error from VFD
	        
	        #sR_TRIG_PreStartrManual(CLK := #sx_PreStartManual);
	        
	        IF (#sx_PreStartManual                                  // Pre start conditions to run in manual mode
	            AND (#sR_TRIG_RunManual.Q                           // Trigger when conveyor start running in manual mode
	            AND NOT #iqUDT_ConveyorCommand.ManualJog)           // Conveyor is not running in jog
	            OR (#sR_TRIG_Jog.Q                                  // Trigger to start jogging
	            AND NOT #iqUDT_ConveyorCommand.ManualStartStop))    // Conveyor is not running in manual mode
	            OR (#sR_TRIG_PreStartrManual.Q
	            AND #iqUDT_ConveyorCommand.ManualStartStop
	            AND NOT #iqUDT_ConveyorCommand.ManualJog)
	        THEN
	            
	            #iqUDT_EquipmentControl.Request.SignalingRequest := TRUE;  // Request signaling to control block before conveyor run in manual mode
	            
	        END_IF;
	        
	        // Run conveyor forward in manual mode
	        #iqUDT_ConveyorInterface.RunFwd := #sx_PreStartManual   // Pre start conditions to run in manual mode
	        AND NOT #iqUDT_ConveyorCommand.Reverse                  // Not in reverse direction
	        AND
	        (NOT #iqUDT_EquipmentControl.Request.SignalingRequest   // Signaling request done
	        OR #sx_ManualRunning)
	        AND
	        (#iqUDT_ConveyorCommand.ManualStartStop                 // Manual mode start to run
	        OR #iqUDT_ConveyorCommand.ManualJog)                    // Jogging
	        AND NOT #iqUDT_PendantInerface.ServiceModeEngaged;      // Service mode is not enabled
	        
	        
	        // Never run sorter reverse in manual mode
	        #iqUDT_ConveyorInterface.RunRvs := FALSE;
	        
	        #sx_ManualRunning := #iqUDT_ConveyorInterface.RunFwd;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 7 - Automatic mode active
	    
	    IF NOT #sx_ManualModeActive                                 // Manual mode is not active
	        AND NOT #iqUDT_PendantInerface.ServiceModeEngaged       // and service mode is not active
	    THEN
	        
	        REGION 7.1 - Operation modes
	            // Mode slave in automatic
	            IF #sx_AutomaticActive
	                AND #sx_Ready
	            THEN
	                // Slave
	                #iqUDT_ConveyorInterface.RunFwd := #sx_AutomaticActive     // Automatic mode active
	                AND #sx_Ready                                   // Ready active
	                AND NOT #ix_ExternalRequestHold                 // Halt request is not active
	                AND NOT #sx_EnergySaveActive                    // Energy save not active
	                AND #iqUDT_HandShake.RTR;                       // Ready to receive active
	                
	                #iqUDT_HandShakeUp.RTR := #iqUDT_ConveyorInterface.RunFwd
	                AND (#iqUDT_ConveyorInterface.VFDatSpeed OR NOT #iUDT_ConveyorConfiguration.RTR_at_Speed);
	                
	                #iqUDT_HandShake.ResetEnergySave := #iqUDT_HandShakeUp.ResetEnergySave  // Send reset energy save to downstream
	                OR #iqUDT_HandShake.RTS
	                OR NOT #ix_PECEoS;
	                
	            ELSE
	                // If conveyor is not in manual mode and not ready
	                #iqUDT_ConveyorInterface.RunFwd := FALSE;       // Order to VFD stop conveyor
	                #iqUDT_HandShakeUp.RTR := FALSE;                // Set ready to receive false
	            END_IF;
	            
	        END_REGION
	        
	        REGION 7.2 - Energy save
	            
	            IF #iUDT_ConveyorConfiguration.Energy               // Energy save functionality enable from configuration
	            THEN
	                
	                IF ((NOT #ix_PECEoS OR NOT #ix_PECBoS)        // Photo eye detects a parcel
	                    AND NOT #sx_EnergySaveActive)               // Energy save active bit
	                    OR #ix_ResetEnergySave                      // Reset energy save
	                    OR NOT #iqUDT_EquipmentControl.Command.AutomaticOn  // Automatic ON from control block
	                    OR #iqUDT_EquipmentControl.Command.Stop     // Stop command from control block
	                THEN
	                    #sdi_AuxEnergySaveFwd := 0;                 // Reset energy save counter
	                    #sx_EnergySaveActive := FALSE;              // Set energy save active to false
	                ELSE
	                    #sdi_AuxEnergySaveFwd += #iqUDT_ConveyorInterface.Displacement;
	                END_IF;
	                
	                
	                #sx_EnergySaveActive := (#sdi_AuxEnergySaveFwd > #iUDT_ConveyorConfiguration.Forward_Direction.EnergySaveLenght);
	                
	            ELSE
	                // If energy save functionality is disable from configuration
	                #sdi_AuxEnergySaveFwd := 0;                     // Reset energy save counter
	                #sx_EnergySaveActive := FALSE;                  // Set energy save false
	            END_IF;
	            
	        END_REGION
	        
	    END_IF;
	    
	END_REGION
	
	REGION 8 - Service mode
	    
	    //Run when service mode is engaged - speed control in the next region
	    IF #iqUDT_PendantInerface.ServiceModeEngaged THEN
	        
	        //Run command 
	        #iqUDT_ConveyorInterface.RunFwd := #iqUDT_PendantInerface.CmdRun
	        AND #iqUDT_PendantInerface.PendantStopHealthy
	        AND #sx_Safetyok
	        AND #ix_24vOk                                           // 24V error status
	        AND #ix_400vOk                                          // 400V error status
	        AND #ix_ProfinetOk                                      // Profinet error status
	        AND NOT #iqUDT_ConveyorInterface.ConfigurationError     // No configuration error      
	        AND NOT #ix_SorterInterlockError                        // Sorter interlock error
	        AND NOT #iqUDT_ConveyorInterface.InternalErrorVFD
	        ;
	        //Reset VFD                                   
	        #iqUDT_ConveyorInterface.InternalErrorReset := #iqUDT_PendantInerface.PendantReset;
	        
	        
	    END_IF;
	    
	    
	END_REGION
	
	REGION 9 - Speed control
	    
	    (*In manual mode, conveyor runs with low speed by default. If "ManualFullSpeed" is set true, conveyor runs with high speed in manual mode.
	      In automatic mode, conveyor runs with full speed if external is zero. If external speed is bigger than zero, conveyor will run with that speed. *)
	    
	    // Protection against wrong speed 
	    IF #iqUDT_ConveyorCommand.ManualSpeed > 100 THEN
	        #iqUDT_ConveyorCommand.ManualSpeed := 100;
	    END_IF;
	    
	    IF #iqUDT_ConveyorCommand.ManualSpeed < 0 THEN
	        #iqUDT_ConveyorCommand.ManualSpeed := 0;
	    END_IF;
	    
	    
	    IF #sx_ManualModeActive                                     // Manual mode active
	    THEN
	        IF #iqUDT_ConveyorCommand.ManualFullSpeed               // Full speed in manual mode
	            AND #iqUDT_ConveyorCommand.ManualStartStop          // Start/stop conveyor in manual mode
	        THEN
	            #iqUDT_ConveyorInterface.SpeedSetpoint := #iUDT_ConveyorConfiguration.SpeedSetpointNominal;     // Move nominal setpoint to the VFD
	        ELSE
	            #iqUDT_ConveyorInterface.SpeedSetpoint := REAL_TO_INT(INT_TO_REAL(#iqUDT_ConveyorCommand.ManualSpeed) * (INT_TO_REAL(#iUDT_ConveyorConfiguration.SpeedSetpointNominal) / 100));     // Calculate and Move manual speed setpoint to VFD;         // Move low speed setpoint to VFD
	        END_IF;
	        
	    ELSIF #iqUDT_PendantInerface.ServiceModeEngaged THEN        // pendant control
	        
	        IF #iqUDT_PendantInerface.LowSpeedSelected AND #iqUDT_ConveyorInterface.RunFwd THEN                 // low speed
	            #iqUDT_ConveyorInterface.SpeedSetpoint := #iUDT_ConveyorConfiguration.SpeedSetpointPendantLow;
	        ELSIF #iqUDT_PendantInerface.ManualSpeedSelected AND #iqUDT_ConveyorInterface.RunFwd THEN           // manual speed
	            #iqUDT_ConveyorInterface.SpeedSetpoint := 500; //500mm/s
	        ELSE
	            #iqUDT_ConveyorInterface.SpeedSetpoint := 0;        //zero speed 
	        END_IF;
	        
	        
	    ELSE
	        #iqUDT_ConveyorInterface.SpeedSetpoint := #iUDT_ConveyorConfiguration.SpeedSetpointNominal;       // Move nominal setpoint to VFD
	    END_IF;
	    
	    
	END_REGION
	
	REGION 10 - Statistics
	    
	    REGION 10.1 - Conveyor up time
	        
	        IF #sx_Up OR #iqUDT_EquipmentControl.Command.ResetData  // Reset statistics
	        THEN
	            
	            "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,                      // Reset statistics input
	                            ix_Activate := #sx_Up,
	                            ix_RTrigActivate := #sR_TRIG_ConveyorUp.Q,                                  // Statistics active trigger
	                            iqUDT_Statistics := #iqUDT_Statistics.ConveyorUp);                         // Statistics values output
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 10.2 - Energy save
	        
	        // Statistics Energy save mode active
	        IF #sx_EnergySaveActive                                                                         // Energy save active
	            OR #iqUDT_EquipmentControl.Command.ResetData                                                // Reset statistics
	        THEN
	            "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,                      // Reset statistics input
	                            ix_Activate := #sx_EnergySaveActive,                                        // Activate statistics functions input
	                            ix_RTrigActivate := #sR_TRIG_EnergySave.Q,                                  // Statistics active trigger
	                            iqUDT_Statistics := #iqUDT_Statistics.EnergySave);                         // Statistics values output
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 10.3 - Conveyor down time
	        
	        // Conveyor down is when conveyor is not in manual mode and has an error
	        IF #sx_Down OR #iqUDT_EquipmentControl.Command.ResetData                                        // Reset statistics
	        THEN
	            
	            "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,                      // Reset statistics input
	                            ix_Activate := #sx_Down,                                                    // Activate statistics functions input
	                            ix_RTrigActivate := #sR_TRIG_ConveyorDownTime.Q,                            // Statistics active trigger
	                            iqUDT_Statistics := #iqUDT_Statistics.ConveyorDown);                       // Statistics values output
	            
	        END_IF;
	    END_REGION
	    
	    REGION 10.4 - Conveyor stop time
	        
	        IF #sx_Stopped OR #iqUDT_EquipmentControl.Command.ResetData                                     // Reset statistics
	        THEN
	            
	            "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,                      // Reset statistics input
	                            ix_Activate := #sx_Stopped,                                                 // Activate statistics functions input
	                            ix_RTrigActivate := #sR_TRIG_ConveyorStopped.Q,                             // Statistics active trigger
	                            iqUDT_Statistics := #iqUDT_Statistics.ConveyorStop);                       // Statistics values output
	            
	        END_IF;
	    END_REGION
	    
	END_REGION
	
	REGION 11 - Status
	    
	    #sUDT_HMIStatus.Specific.Reverse := FALSE;                                                          // sorter does not run reverse
	    #sUDT_CommonStatus.Stopped := #sx_Ready AND NOT #sx_AutomaticActive;                                // stopped
	    #sUDT_CommonStatus.AutoON := #sx_Ready AND #sx_AutomaticActive;                                     // Auto ON
	    #sUDT_CommonStatus.Running := #iqUDT_ConveyorInterface.RunFwd;                                      // Running
	    #sUDT_CommonStatus.Halted := #ix_ExternalRequestHold AND #sUDT_CommonStatus.AutoON;                 // Halted
	    #sUDT_CommonStatus.EnergySave := #sx_EnergySaveActive;                                              // Energy save active
	    #sUDT_CommonStatus.Dieback := #sUDT_CommonStatus.AutoON
	    AND NOT #sUDT_CommonStatus.EnergySave
	    AND NOT #sUDT_CommonStatus.Running;                                                                 // Die back
	    #sUDT_CommonStatus.Manual := #sx_ManualModeActive                                                   // Manual
	    OR #iqUDT_PendantInerface.ServiceModeEngaged;                                                       // Service mode engaged                        
	    #sUDT_CommonStatus.ManualRun := (#sx_ManualModeActive AND #sUDT_CommonStatus.Running)               // Manual Running
	    OR (#iqUDT_PendantInerface.ServiceModeEngaged AND #iqUDT_ConveyorInterface.VFDRunning);
	    #sUDT_CommonStatus.SafetyStop := NOT #sx_Safetyok;                                                  // Safety not ok
	    
	    // HMI status update
	    IF #sUDT_CommonStatusOld <> #sUDT_CommonStatus                                                      // update on change
	    THEN
	        
	        // HMI status initialization
	        #sUDT_HMIStatus.Status := 0;
	        
	        // HMI status calculation
	        IF #sUDT_CommonStatus.EnergySave                        // Energy save
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".EnergySave;
	        END_IF;
	        
	        IF #sUDT_CommonStatus.Running                           // Running
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Running;
	        END_IF;
	        
	        IF #sUDT_CommonStatus.Stopped                           // Stopped
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Stopped;
	        END_IF;
	        
	        IF #sUDT_CommonStatus.Dieback                           // Dieback
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Dieback;
	        END_IF;
	        
	        IF #sUDT_CommonStatus.Halted                            // Halted
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Halted;
	        END_IF;
	        
	        IF #sUDT_CommonStatus.Manual                            // Manual
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Manual;
	        END_IF;
	        
	        IF #sUDT_CommonStatus.ManualRun                         // Running in manual mode
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".ManualRun;
	        END_IF;
	        
	        IF #iqUDT_ConveyorInterface.InternalWarningTracking     // Internal tracking warning
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Warning;
	        END_IF;
	        
	        IF #iqUDT_ConveyorInterface.InternalErrorTracking       // Internal tracking error
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".TrackingError;
	        END_IF;
	        
	        IF #iqUDT_ConveyorInterface.InternalErrorPEC            // Internal PEC error
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".PECJam;
	        END_IF;
	        
	        // Internal Encoder error
	        IF #iqUDT_ConveyorInterface.InternalErrorEncoder
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".EncoderError;
	        END_IF;
	        
	        IF #ix_SorterInterlockError
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Error;
	        END_IF;
	        
	        IF #iqUDT_ConveyorInterface.InternalErrorVFD            // Internal VFD error
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".VFDError;
	        END_IF;
	        
	        IF #iqUDT_ConveyorInterface.Disconnected                // Disconnect error
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".CBError;
	        END_IF;
	        
	        IF (#sUDT_CommonStatus.SafetyStop)                      // Safety stop
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".SafetyStop;
	        END_IF;
	        
	        
	        #sUDT_CommonStatusOld := #sUDT_CommonStatus;            // Copy status to memory
	        #qUDT_Status := #sUDT_CommonStatus;                     // Copy status to output
	        
	    END_IF;
	    
	    #qUDT_HMIStatus := #sUDT_HMIStatus;                         // Copy HMI status to output
	    
	END_REGION
	
	REGION 12 - Report to control block
	    
	    // Function to manage report between control block and conveyor block
	    
	    "FC_EquipmentReport"(iUDT_Status := #sUDT_CommonStatus,
	                         iqUDT_Control := #iqUDT_EquipmentControl);
	    
	END_REGION
	
	REGION 13 - Internal errors and warnings reset
	    
	    IF #iqUDT_EquipmentControl.Command.Reset
	    THEN
	        #iqUDT_ConveyorInterface.InternalErrorEncoder := FALSE;
	        #iqUDT_ConveyorInterface.InternalErrorPEC := FALSE;
	        #iqUDT_ConveyorInterface.InternalWarningTracking := FALSE;
	        #iqUDT_ConveyorInterface.InternalErrorTracking := FALSE;
	        #iqUDT_ConveyorInterface.InternalWarningVFD := FALSE;
	        #iqUDT_ConveyorInterface.InternalErrorVFD := FALSE;
	        #iqUDT_ConveyorInterface.Disconnected := FALSE;
	        #iqUDT_ConveyorInterface.ConfigurationError := FALSE;
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_XBSInductInterface"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 43
// END_ATTRIBUTES
   VAR_INPUT 
      iudt_ConveyorInterface { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorInterface";   // Conveyor interface
      iudt_XBSInterfaceRcv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_XBSInductInterfaceRcv";   // Induct input structure
      ii_RunningEmptyDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Distance between in and out photocell (cm)
      ix_ConveyorsRunning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conmmon conveyor running status
      ix_PECIn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PEC input to increment parcel count
      ix_PECOut { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PEC input to decrement parcel count
   END_VAR

   VAR_OUTPUT 
      qUDT_XBSInterfaceSend { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_XBSInductInterfaceSend";   // Induct output structure
      qi_SpeedUpstream { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Max speed on which infeed upstream conveyor may run
   END_VAR

   VAR_IN_OUT 
      iqUDT_ConveyorHandshake : "UDT_ConveyorHandshake";   // Conveyor handshake
   END_VAR

   VAR 
      sF_Trig_PECOut {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;
      sR_Trig_PECIn {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger PEC in
      si_NumberOfParcels { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Number of parcels available upstream of Induct
      sx_LoopCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Loop couter
      si_DisplacementCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Array length of the tracking DB
      si_OldGin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Old parcel ID
      si_ParcelID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Parcel ID
      si_WatchDog { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Watch dog
      sx_ParcelAvailable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parcel is available
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	31-03-2022  | 3.0       | S. Deulkar    | First release TIA 16
	24-05-2022  | 3.1       | M. Piela      | Interface update        
	29-06-2022  | 3.2       | M. Piela      | Change detection of ix_PEC_Out on falling edge,
	                                          change condition to dicrement #si_DisplacementCount
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	12/03/2024  | 4.1       | S. Nieswiec   | Small variable name changes according to current standard   
	*)
	
	
	REGION 1 - Initial
	    REGION 1.1 - First PLC cycle
	        
	        IF "DB_Memory".FirstScan
	        THEN
	            #si_NumberOfParcels := 0;                   //#si_ParcelID := 0;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 1.2 - Triggers
	        //Detect rising edge of the PEC's
	        #sR_Trig_PECIn(CLK := #ix_PECIn);
	        
	        #sF_Trig_PECOut(CLK := #ix_PECOut);
	    END_REGION
	    
	END_REGION
	
	REGION 2 - Receive
	    
	    #iqUDT_ConveyorHandshake.RTR := #iudt_XBSInterfaceRcv.RunConsent;
	    #qi_SpeedUpstream := REAL_TO_INT(#iudt_XBSInterfaceRcv.LastConveyorSpeedSP);
	    
	END_REGION
	
	REGION 3 - Calculate and Send
	    
	    //Increment number of parcel
	    IF #sR_Trig_PECIn.Q AND #ix_ConveyorsRunning THEN
	        #si_NumberOfParcels := #si_NumberOfParcels + 1;
	    END_IF;
	    
	    //Decrement number of parcel
	    IF #sF_Trig_PECOut.Q THEN
	        //#si_ParcelID += 1;
	        #si_NumberOfParcels := #si_NumberOfParcels - 1;
	        #si_DisplacementCount := #ii_RunningEmptyDistance;
	    END_IF;
	    
	    // IF #si_ParcelID = 1000
	    // THEN
	    //     #si_ParcelID := 1;
	    // END_IF;
	    
	    // To avoide false count because of false triggering 
	    // Subtract displacement when parcel when new parcel detected by PEC IN
	    IF #si_DisplacementCount > 0 THEN
	        #si_DisplacementCount := #si_DisplacementCount - #iudt_ConveyorInterface.Displacement;
	    END_IF;
	    
	    // If PEC Out does not get triggered for configured distance then intitialize number of parcels to 0.
	    IF #si_DisplacementCount <= 0
	    THEN
	        #si_NumberOfParcels := 0;
	        //#si_ParcelID := 0;
	        #si_DisplacementCount := 0;
	    END_IF;
	    
	    
	    //Watchdog counter to be updated after every 100 msec
	    IF "DB_Memory"."OS_0.1sec"
	    THEN
	        IF #si_WatchDog >= 255 OR #si_WatchDog < 0
	        THEN
	            #si_WatchDog := 0;
	        END_IF;
	        #si_WatchDog := #si_WatchDog + 1;
	    END_IF;
	    
	    #qUDT_XBSInterfaceSend.WatchDog := INT_TO_BYTE(#si_WatchDog);
	    #qUDT_XBSInterfaceSend.IncomingParcel := #si_NumberOfParcels > 0;
	    #qUDT_XBSInterfaceSend.ParcelOnBoard := #si_NumberOfParcels;
	    //#qudt_XBSInterfaceSend.ParcelID := #si_ParcelID;
	    #qUDT_XBSInterfaceSend.LastConveyorSpeed := INT_TO_REAL(#iudt_ConveyorInterface.ActualSpeed);
	    #qUDT_XBSInterfaceSend.Discharge := #iqUDT_ConveyorHandshake.TIP;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_Caljan"
TITLE = FB_Unloader
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : Equimpent
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 252
// END_ATTRIBUTES
//Function block to control unloader.
   VAR_INPUT 
      iUDT_CaljanConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CaljanConfiguration";   // Caljan configuration structure
      iUDT_CaljanReceive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CaljanReceive";   // Caljan receive structure
      ix_SafetyReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Safety reset
      ix_SafetyOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when Safety Circuit of the Conveyor is healthy
      ix_24vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 24VDC is healthy
      ix_400vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 400VAC is healthy
      ix_HardwareOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when the PN node(s) are ok
      ix_ExternalRequestDieBack { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External request die back
      ix_ExternalRequestHold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External request hold
      ix_ResetEnergySave { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset energy save mode timer
      ix_TooLongParcel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when Unloader has detected a too long parcel (stopped)
      ix_SimulationModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when simulation mode is active
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CaljanStatus";   // HMI status structure
      qUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   // Common status structure
      qUDT_CaljanSend { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CaljanSend";   // Caljan send structure
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
      iqUDT_CaljanCommand : "UDT_CaljanCommand";   // Caljan HMI control
      iqUDT_HandShake : "UDT_ConveyorHandshake";   // Handshake structure
      iqUDT_HandShakeUp : "UDT_ConveyorHandshake";   // Upstream handshake structure
      iqUDT_CaljanInterface : "UDT_ConveyorInterface";   // Equipment interface structure
      iqUDT_Statistics : "UDT_CaljanStatistics";   // Statistics structure
   END_VAR

   VAR 
      sUDT_CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Common status structure
      sUDT_CommonStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Auxiliary status structure
      sUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CaljanStatus";   // HMI status structure
      sUDT_PNDevice { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PNDevice";   // PN device info structure
      sa_PNPortsStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..8] of Bool;   // TRUE when specific port has an error
      R_TRIG_EnergySave {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for energy save
      R_TRIG_ConveyorUp {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge of automatic active
      R_TRIG_ConveyorDown {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge of automatic not active
      R_TRIG_NotHealthy {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger if extendable not healthy
      R_TRIG_TooLongParcel {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger for too long parcel
      R_TRIG_SafetyOk {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger safety is ok
      R_TRIG_PEC_UnloaderFiltered {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger end of section photo eye filtered
      F_TRIG_PEC_UnloaderFiltered {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger end of section photo eye filtered
      F_TRIG_AuxHeadToEnd {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger Aux head to end bit
      R_TRIG_TailToBegin {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger tail to begin bit
      sR_TRIG_PNSlaveError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for PN error
      sR_TRIG_PNSlaveNotOnline {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for PN not online
      sFB_PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   // FB PEC block for PEC Jam status
      sFB_ResetPulseTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer on/off delay for reset pulse
      sFB_CascadeModeTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer on/off delay for cascade mode
      sFB_TimerOnOffDelayCheck24V { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer on/off delay to allow startup before fault is generated
      sFB_TimerOnOffDelayCheck400V { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer on/off delay to allow startup before fault is generated
      sFB_Displacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Displacement";   // Function block to calculate displacement
      sdi_GapHeadToHeadConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Preset forward gap head to head with correction [cm]
      sdi_GapTailToHeadConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Preset forward gap tail to head with correction [cm]
   END_VAR
   VAR RETAIN
      sdi_HeadToEnd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Count head to end distance
      sdi_GapHeadToHead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Head to head between two products
      sdi_TailToBegin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Count tail to next conveyor distance
      sdi_AuxGapHeadToHeadCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Auxiliary variable to count the head to head
      sdi_AuxGapTailtoHeadCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Auxiliary variable to count the gap
      sdi_Gap { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Gap between two products
   END_VAR
   VAR 
      si_AuxEnergySave { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Auxiliary energy save
      sx_Disabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Operation is enabled
      sx_Ready { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor Ready to operate in Forward mode
      sx_PEC_EoSFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // End of section photo eye filtered
      sx_EnergySaveActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Active energy save mode
      sx_AutomaticActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Forward active
      sx_CascadeStartUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Cascade startup auxiliary bit
      sx_ReverseActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Unloader is running in reverse directon
   END_VAR
   VAR RETAIN
      sx_AuxHeadToEnd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Aux bit to control head to end positioning in forward direction
      sx_AuxHeadAtEnd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parcel reach the end of the conveyor in forward direction
      sx_Gapping { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Gapping in process in forward direction
      sx_TailToBegin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Tail to begin done in forward direction
      sx_RecoveryGap { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Recovery gap activated in forward direction
   END_VAR
   VAR 
      sx_HoldUnloading { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Hold unloading ofter release Hold Reverse button
      sx_24VOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 24V ok
      sx_400VOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 400V ok
   END_VAR

   VAR CONSTANT 
      ci_OverflowLimit : Int := 32000;   // Limit int overflow
      ci_NumberOfProfinetPorts : Int := 2;   // Number of Profinet ports in device
      ci_PowerSupplyDelayTime : UInt := 4000;   // Power supply delay time
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	26/10/2021  | 0.1       | M. Piela      | first release MHS TIA 16
	11/11/2021  | 0.2       | S. Theocharis | change profinet ok to hardware ok 
	10/01/2022  | 0.3       | K. Pokorski   | Bug fix/PNPN coupler handling added
	21/02/2022  | 0.4       | M. Piela      | Status update
	12/03/2022  | 0.5       | M. Piela      | Add reset energy save via handshake
	09/05/2022  | 0.6       | M. Piela      | Correct contitions to allow loading and unloading
	24/06/2022  | 0.7       | M. Kurpiers   | Loader running and dieback status changed
	27/07/2022  | 0.8       | M. Piela      | Change conditon to energy save for loader
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Get Device Profinet information
	    
	    "FC_GetDevicePN"(is_PNDeviceName := #iUDT_CaljanConfiguration.PNDeviceName,
	                     ix_SimulationModeActive := #ix_SimulationModeActive,
	                     iqUDT_PND := #sUDT_PNDevice);
	    
	    "FC_GetPNPortStatus"(ii_NumberOfPorts := #ci_NumberOfProfinetPorts,
	                         iUDT_DevicePNInfo := #sUDT_PNDevice,
	                         qa_PortFault => #sa_PNPortsStatus);
	    
	END_REGION
	
	REGION 2 - Initial
	    
	    REGION 2.1 - First PLC cycle
	        
	        IF "DB_Memory".FirstScan
	        THEN
	            #sx_AutomaticActive := FALSE;
	            #iqUDT_HandShakeUp.RTR := FALSE;
	            #iqUDT_HandShakeUp.CascadeStartUp := FALSE;
	            #sx_Disabled := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 2.2 - Triggers
	        
	        // Rising edge trigger energy save
	        #R_TRIG_EnergySave(CLK := #sUDT_CommonStatus.EnergySave);
	        
	        // Rising edge extendable up
	        #R_TRIG_ConveyorUp(CLK := #sx_AutomaticActive AND #sx_Ready);
	        
	        // Rising edge extendable down
	        #R_TRIG_ConveyorDown(CLK := #sx_AutomaticActive AND NOT #sx_Ready);
	        
	        // Rising edge extendable not healthy 
	        #R_TRIG_NotHealthy(CLK := #sUDT_HMIStatus.Specific.NotHealthy);
	        
	        // Rising edge for too long parcel 
	        #R_TRIG_TooLongParcel(CLK := #sUDT_HMIStatus.Specific.TooLongParcel);
	        
	        // Rising edge for Profinet error
	        #sR_TRIG_PNSlaveError(CLK := #sUDT_HMIStatus.Specific.PNSlaveError);
	        
	        // Rising edge for Profinet not online
	        #sR_TRIG_PNSlaveNotOnline(CLK := #sUDT_HMIStatus.Specific.PNSlaveNotOnline);
	        
	    END_REGION
	    
	    REGION 2.3 - HMI button Disable operation
	        
	        // Copy HMI command to static memory
	        #sx_Disabled := #iqUDT_CaljanCommand.Disable;
	        
	        // Copy status to HMI
	        #sUDT_HMIStatus.Specific.Disabled := #sx_Disabled;
	        
	    END_REGION
	    
	    REGION 2.4 - Displacement
	        
	        // Calculate displacement only when Caljan is running
	        IF #iUDT_CaljanReceive.BeltDirection_Loading OR #iUDT_CaljanReceive.BeltDirection_Unloading
	        THEN
	            #sFB_Displacement(#iqUDT_CaljanInterface);
	        ELSE
	            #iqUDT_CaljanInterface.Displacement := 0;
	        END_IF;
	        
	        // Map displacement to upstream conveyor
	        IF NOT #sx_ReverseActive
	        THEN
	            #iqUDT_HandShakeUp.DownstreamDisplacement := #iqUDT_CaljanInterface.Displacement;
	        ELSE
	            #iqUDT_HandShake.DownstreamDisplacement := #iqUDT_CaljanInterface.Displacement;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 2.5 - Gaps configuration
	        
	        // Forward head to head
	        #sdi_GapHeadToHeadConfiguration := #iUDT_CaljanConfiguration.Forward_Direction.GapHeadToHead + #iUDT_CaljanConfiguration.Forward_Direction.GapCorrection;
	        // Forward tail to head
	        #sdi_GapTailToHeadConfiguration := #iUDT_CaljanConfiguration.Forward_Direction.GapTailToHead + #iUDT_CaljanConfiguration.Forward_Direction.GapCorrection;
	        
	    END_REGION
	    
	    REGION 2.6 - Timers 
	        
	        // Handle PEC when Calian is configured as unloader 
	        IF #iUDT_CaljanConfiguration.CaljanMode = 2
	        THEN
	            // PEC EoS
	            #sFB_PEC(ix_PEC := #iUDT_CaljanReceive.PECUnloader,
	                     iUDT_PECConfiguration := #iUDT_CaljanConfiguration.PEC_EOS,
	                     qx_PECFiltered => #sx_PEC_EoSFiltered,
	                     qUDT_HMIStatus => #sUDT_HMIStatus.Specific.PEC_EoS,
	                     iqUDT_ConveyorInterface := #iqUDT_CaljanInterface,
	                     iqUDT_PECStatistics := #iqUDT_Statistics.PEC_EOS);
	        END_IF;
	        
	        // Hardware will only be available after the delay, so the device has time for the initialisation
	        #sFB_TimerOnOffDelayCheck24V(iudi_OnDelayTime := #ci_PowerSupplyDelayTime,
	                                     ix_SignalToDelay := #ix_24vOk,
	                                     qx_DelayedSignal => #sx_24VOk);
	        
	        #sFB_TimerOnOffDelayCheck400V(iudi_OnDelayTime := #ci_PowerSupplyDelayTime,
	                                      ix_SignalToDelay := #ix_400vOk,
	                                      qx_DelayedSignal => #sx_400VOk);
	        
	    END_REGION
	    
	END_REGION
	
	REGION 3 - Reset Profinet errors 
	    
	    IF #iqUDT_EquipmentControl.Command.Reset THEN
	        #sUDT_HMIStatus.Specific.PNSlaveNotOnline := FALSE;
	        #sUDT_HMIStatus.Specific.PNSlaveError := FALSE;
	        #sUDT_HMIStatus.Specific.PNSlaveWarning := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Errors
	    
	    // Check if PN device is online
	    IF NOT "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.Exist
	        AND NOT #ix_SimulationModeActive
	        AND #sx_24VOk
	    THEN
	        #sUDT_HMIStatus.Specific.PNSlaveNotOnline := TRUE;
	        
	    END_IF;
	    
	    // Check if PN ports are healthy 
	    IF #sa_PNPortsStatus[1] XOR #sa_PNPortsStatus[2] THEN
	        #sUDT_HMIStatus.Specific.PNSlaveWarning := TRUE;
	    END_IF;
	    
	    // Check if PN device has an error
	    IF "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.Error
	        AND NOT #ix_SimulationModeActive
	        AND #sx_24VOk
	        AND NOT #sUDT_HMIStatus.Specific.PNSlaveWarning
	    THEN
	        #sUDT_HMIStatus.Specific.PNSlaveError := TRUE;
	    END_IF;
	    
	    // Not healthy
	    #sUDT_HMIStatus.Specific.NotHealthy := NOT #iUDT_CaljanReceive.Healthy
	    AND #sx_400VOk
	    AND #sx_24VOk
	    AND #ix_HardwareOK
	    AND #ix_SafetyOk;
	    
	    // Common Error
	    #sUDT_CommonStatus.Error := NOT #sx_24VOk
	    OR NOT #sx_400VOk
	    OR NOT #ix_HardwareOK
	    OR NOT #ix_SafetyOk
	    OR #sUDT_HMIStatus.Specific.PEC_EoS.Jam
	    OR #sUDT_HMIStatus.Specific.NotHealthy;
	    
	    //Parcel too long
	    #sUDT_HMIStatus.Specific.TooLongParcel := #ix_TooLongParcel;
	    
	    // Warning
	    #sUDT_CommonStatus.Warning := #sUDT_HMIStatus.Specific.TooLongParcel;
	    
	END_REGION
	
	REGION 5 - Check conditions to set caljan ready    
	    
	    #sx_Ready := NOT #sUDT_CommonStatus.Error;
	    
	END_REGION
	
	REGION 6 - Stop caljan
	    
	    IF NOT #iqUDT_EquipmentControl.Command.AutomaticOn
	        OR #sUDT_CommonStatus.Error
	    THEN
	        #sx_AutomaticActive := FALSE;
	        #qUDT_CaljanSend.AllowLoading := FALSE;
	        #qUDT_CaljanSend.AllowUnloading := FALSE;
	        #iqUDT_HandShakeUp.RTR := FALSE;
	        #iqUDT_HandShakeUp.CascadeStartUp := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Start automatic mode  
	    
	    // If start (one shot) is received from system, this is memorised until started in cascade. Later the unloader is started
	    IF #iqUDT_EquipmentControl.Command.Start
	        AND #sx_Ready
	    THEN
	        #sx_AutomaticActive := TRUE;
	    END_IF;
	    
	    //Timer to cascade mode
	    #sFB_CascadeModeTimer(iudi_OnDelayTime := #iUDT_CaljanConfiguration.CascadeTimeOnDelay,
	                          ix_SignalToDelay := #sx_AutomaticActive,
	                          ix_Enable := #sx_Ready,
	                          qx_DelayedSignal => #sx_CascadeStartUp);
	    
	    #iqUDT_HandShakeUp.CascadeStartUp := #sx_CascadeStartUp;                                     //TO CHECK ON SITE
	    
	END_REGION
	
	REGION 8 - Automatic mode active
	    
	    REGION 8.1 - Operation
	        
	        (* *******LOADER ******** *)
	        IF #iUDT_CaljanConfiguration.CaljanMode = 1 THEN
	            
	            // Release loading
	            #qUDT_CaljanSend.AllowLoading := #sx_AutomaticActive
	            AND #sx_Ready
	            AND #iUDT_CaljanReceive.ReadyToReceive
	            AND NOT #sx_Disabled
	            AND NOT #ix_ExternalRequestHold
	            AND NOT #sx_EnergySaveActive;
	            
	            #iqUDT_HandShakeUp.RTR := #qUDT_CaljanSend.AllowLoading;
	            
	        END_IF;
	        
	        (* *******UNLOADER ******** *)
	        IF #iUDT_CaljanConfiguration.CaljanMode = 2
	        THEN
	            
	            // Release unloading
	            #qUDT_CaljanSend.AllowUnloading := #sx_AutomaticActive
	            AND #sx_Ready
	            AND NOT #sx_Disabled
	            AND NOT #ix_ExternalRequestHold
	            AND NOT #sx_EnergySaveActive
	            AND NOT #sx_HoldUnloading;
	            
	            #qUDT_CaljanSend.PEC_Override := #iqUDT_HandShake.RTR
	            AND NOT #ix_ExternalRequestDieBack;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 8.2 - Energy save
	        
	        IF #iUDT_CaljanConfiguration.Energy THEN
	            
	            // Set Energy save active
	            IF #si_AuxEnergySave >= #iUDT_CaljanConfiguration.EnergySaveLength
	            THEN
	                #sx_EnergySaveActive := TRUE;
	            END_IF;
	            
	            (* *******LOADER ******** *)
	            // Reset or increment displacement calculation to use for energy save
	            IF #iUDT_CaljanConfiguration.CaljanMode = 1
	                AND NOT #iUDT_CaljanReceive.PECUnloader
	                OR #ix_ResetEnergySave
	                OR #iqUDT_HandShakeUp.RTS
	                OR #iqUDT_HandShakeUp.ResetEnergySave
	                OR NOT #iqUDT_EquipmentControl.Command.AutomaticOn
	            THEN
	                #si_AuxEnergySave := 0;
	                #sx_EnergySaveActive := FALSE;
	                
	                (* *******UNLOADER ******** *)
	            ELSIF #iUDT_CaljanConfiguration.CaljanMode = 2
	                AND NOT #sx_PEC_EoSFiltered
	                OR #ix_ResetEnergySave
	                OR #iUDT_CaljanReceive.HoldReverseSignal
	            THEN
	                #si_AuxEnergySave := 0;
	                #sx_EnergySaveActive := FALSE;
	                
	            ELSE
	                #si_AuxEnergySave += #iqUDT_CaljanInterface.Displacement;
	            END_IF;
	        ELSE
	            #si_AuxEnergySave := 0;
	            #sx_EnergySaveActive := FALSE;
	            
	        END_IF;
	        
	        IF #sx_AutomaticActive AND NOT #sx_ReverseActive
	        THEN
	            #iqUDT_HandShake.ResetEnergySave := NOT #iUDT_CaljanReceive.PECUnloader AND NOT #sx_EnergySaveActive;
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 9 - Gapping configuration
	    
	    REGION 9.1 - Head to End
	        
	        (*  Function to calculate when the head of the parcel reaches the end of the conveyor
	            When PEC detects parcels head, the functionality increments the displacement of the conveyor until reach the value of the distance
	            between PEC and the end of the conveyor. After that, the counter is reset and the bit #sx_AuxHeadToEnd is triggered to inform the system. *)
	        IF NOT #sx_ReverseActive
	        THEN
	            REGION 9.1.1 - Forward
	                
	                #F_TRIG_PEC_UnloaderFiltered(CLK := #sx_PEC_EoSFiltered);
	                
	                IF #F_TRIG_PEC_UnloaderFiltered.Q                                   // Detects the product's head
	                THEN
	                    #sdi_HeadToEnd := #iUDT_CaljanConfiguration.PEC_EOS.Distance;  // move the distance between PEC and the end of the conveyor to auxiliary variable 
	                    #sx_AuxHeadToEnd := TRUE;                                       // Active head to end function
	                    
	                    #sdi_GapHeadToHead := #sdi_AuxGapHeadToHeadCounter;             // Move gap calculated to variable
	                    #sdi_AuxGapHeadToHeadCounter := 0;                              // Reset gap counter
	                    
	                    #sdi_Gap := #sdi_AuxGapTailtoHeadCounter;                       // Move gap calculated to variable
	                    
	                    #sdi_AuxGapTailtoHeadCounter := 0;                              // Reset gap counter
	                    
	                    #iqUDT_HandShake.RTS := TRUE;                                  // Set ready to send true when a parcel is detected in the PEC
	                END_IF;
	                
	                IF #sx_AuxHeadToEnd                                                 // Parcel's head detected in photo cell
	                    AND (#sdi_HeadToEnd > 0)                                        // Psrcel's head do not arrive in the end of the conveyor yet
	                THEN
	                    #sdi_HeadToEnd -= #iqUDT_CaljanInterface.Displacement;         // Count displacement until arrive to the end of the conveyor
	                ELSE
	                    #sx_AuxHeadToEnd := FALSE;                                      // Stop function head to end
	                END_IF;
	                
	                // Falling edge trigger Aux Head to End bit
	                #F_TRIG_AuxHeadToEnd(CLK := #sx_AuxHeadToEnd);
	                
	                IF #F_TRIG_AuxHeadToEnd.Q
	                    
	                THEN
	                    #sx_AuxHeadAtEnd := TRUE;                                       // The head of the parcel is at the front positon of the conveyor
	                END_IF;
	                
	            END_REGION
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 9.2 - Tail to Begin
	        
	        (*   This function tracks when parcels tail reaches the begin of downstream conveyor
	             When the PEC is clear, the function start to increase the displacement until reaches the distance
	             between PEC and the end of conveyor. *)
	        IF NOT #sx_ReverseActive
	        THEN
	            REGION 9.2.1 - Forward
	                
	                #R_TRIG_PEC_UnloaderFiltered(CLK := #sx_PEC_EoSFiltered);
	                
	                IF #R_TRIG_PEC_UnloaderFiltered.Q                                             // Detects product's tail
	                THEN
	                    
	                    #sdi_TailToBegin := (#iUDT_CaljanConfiguration.PEC_EOS.Distance / 10);   // move distance between PE and the end of the conveyor to auxiliar variable
	                    
	                END_IF;
	                
	                IF (#sdi_TailToBegin > 0)                                                     // While tails parcel do not reach the beginning of next conveyor
	                THEN
	                    
	                    #sdi_TailToBegin -= #iqUDT_CaljanInterface.Displacement;                 // count displacement until the product's tail arrive to the next conveyor
	                    #sx_TailToBegin := FALSE;                                                 // Reset tail to begin bit
	                    
	                ELSE
	                    
	                    #sx_TailToBegin := TRUE;                                                  // Product's tail arrived at the begin OF next conveyor
	                    
	                END_IF;
	                
	                // Rising edge trigger Aux tail to Begin bit
	                #R_TRIG_TailToBegin(CLK := #sx_TailToBegin);
	                
	            END_REGION
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 9.3 - Gap
	        
	        (*    Gap tail TO head function calculates the distance (Gap) between two parcels.                                       
	              The function increases the Counter WHILE the photo eye is clear.                                                    
	              Every time a parcel trigger the photo eye, gap value is save AND the counter is reset.  *)
	        IF NOT #sx_ReverseActive
	        THEN
	            REGION 9.3.1 - Forward
	                
	                IF #iUDT_CaljanReceive.PECUnloader                             // Count displacement when the PE do not detects the product
	                THEN
	                    
	                    IF #sdi_AuxGapTailtoHeadCounter < #ci_OverflowLimit        // Prevent integer variable overflow
	                    THEN
	                        IF #iqUDT_HandShake.RTR THEN
	                            #sdi_AuxGapTailtoHeadCounter += #iqUDT_CaljanInterface.Displacement;    // Calculate the gap
	                        END_IF;
	                        
	                    END_IF;
	                    
	                END_IF;
	                
	            END_REGION
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 9.4 - Head to head
	        
	        // The functionality head to head is used to calculate the distance between one head's parcel and the head's parcel behind.
	        // To do it, everytime the PEC is triggered, the function save the distance calculated and reset the counter to start
	        // counting again, over and over again.
	        IF NOT #sx_ReverseActive
	        THEN
	            REGION 9.4.1 - Forward
	                
	                IF #sdi_AuxGapHeadToHeadCounter < #ci_OverflowLimit                         // Prevent integer variable overflow
	                THEN
	                    
	                    #sdi_AuxGapHeadToHeadCounter += #iqUDT_CaljanInterface.Displacement;   // measure the distance between two products
	                    
	                END_IF;
	                
	            END_REGION
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 9.5 - Check gaps between products
	        
	        // Check gaps is a routine that checks all the time if the gap and head to head distance is acording to the configuration.
	        // If not, the bit "sx_Gapping" is set true and the conveyor stops to gap.
	        // Compare gaps calculated with the configured gaps 
	        IF NOT #sx_ReverseActive
	        THEN
	            REGION 9.5.1 - Forward
	                
	                IF ((#sdi_GapHeadToHeadConfiguration > #sdi_GapHeadToHead        // Compare head to head configured with real distance
	                    OR #sdi_GapTailToHeadConfiguration > #sdi_Gap)
	                    AND #F_TRIG_AuxHeadToEnd.Q)                                  // Trigger when parcel arrive in the end of the conveyor
	                THEN
	                    
	                    #sx_Gapping := TRUE;        // Bit to inform the system that conveyor needs to stop to apply gap
	                    
	                END_IF;
	                
	            END_REGION
	            
	        END_IF;
	        //    When conveyor stops to gapping, displacement values from downstream are used to 
	        //    apply new gap.
	        //    When the new gap applied fits with the configured one, the conveyor starts running again.
	        //    If the conveyor stops for die back reason and the gap its been applied, and extra gap value it will be applied.
	        //    This recovery gap it helps to recovery the system after die back.
	        IF NOT #sx_ReverseActive
	        THEN
	            REGION 9.5.2 - Forward recovery
	                
	                IF (#sx_Gapping                                                   // Gapping needs to be applied bit
	                    AND ((#sdi_GapHeadToHeadConfiguration > #sdi_GapHeadToHead    // Configured head to head bigger than the actual one
	                    OR #sdi_GapTailToHeadConfiguration > #sdi_Gap)                // Configured gap bigger than the actual one
	                    AND NOT #sx_RecoveryGap)                                      // Die back recovery gap bit not active
	                    OR ((#sdi_GapHeadToHeadConfiguration > #sdi_GapHeadToHead     // Actual head to head distance
	                    OR #sdi_GapTailToHeadConfiguration > #sdi_Gap)                // Actual gap between parcels
	                    AND #sx_RecoveryGap))                                         // Recovery gap bit activate
	                THEN
	                    
	                    #sdi_GapHeadToHead += #iqUDT_HandShake.DownstreamDisplacement;     // Increase head to head counter with conveyor downstream displacement
	                    #sdi_Gap += #iqUDT_HandShake.DownstreamDisplacement;               // Increase gap counter with conveyor downstream displacement
	                    
	                ELSE
	                    
	                    #sx_Gapping := FALSE;          // Set gapping bit to false
	                    
	                END_IF;
	                
	                IF #sx_Gapping                     // Gapping bit active
	                    AND NOT #iqUDT_HandShake.RTR  // Ready to receive not active
	                THEN
	                    
	                    #sx_RecoveryGap := TRUE;       // Recovery gap activation after die back
	                    
	                END_IF;
	                
	                IF #sx_RecoveryGap                 // Recovery gap active
	                    AND NOT #sx_Gapping            // Gapping bit not active
	                THEN
	                    
	                    #sx_RecoveryGap := FALSE;      // Recovery gap disable
	                    
	                END_IF;
	                
	            END_REGION
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 9.6 - Ready to send and Transfer in progress
	        
	        IF NOT #sx_ReverseActive
	        THEN
	            REGION 9.6.1 - Forward
	                
	                IF #iqUDT_HandShake.RTR                 // Ready to receive bit
	                    AND #iqUDT_HandShakeUp.RTR
	                    AND NOT #sx_Gapping
	                    AND #sx_AuxHeadAtEnd                 // Parcel is at end of conveyor
	                    AND NOT #ix_ExternalRequestDieBack
	                THEN
	                    
	                    #iqUDT_HandShake.TIP := TRUE;      // Transfer in progress bit
	                    #iqUDT_HandShake.RTS := FALSE;     // Ready to send bit
	                    #sx_AuxHeadAtEnd := FALSE;
	                    
	                END_IF;
	                
	                IF #R_TRIG_TailToBegin.Q               // Reset TIP when the parcel leaves interlock
	                THEN
	                    
	                    #iqUDT_HandShake.TIP := FALSE;     // Transfer in progress bit
	                    
	                END_IF;
	                
	            END_REGION
	            
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 10 - Reverse run
	    
	    IF #iUDT_CaljanConfiguration.CaljanMode = 2 THEN
	        
	        //Starting reverse run
	        IF #iUDT_CaljanReceive.HoldReverseSignal
	            AND #sx_AutomaticActive
	        THEN
	            #sx_ReverseActive := TRUE;
	        END_IF;
	        
	        IF #sx_ReverseActive AND NOT #iUDT_CaljanReceive.HoldReverseSignal
	        THEN
	            #sx_ReverseActive := FALSE;
	            #sx_HoldUnloading := TRUE;
	        END_IF;
	        
	        IF NOT #iUDT_CaljanReceive.HoldReverseSignal AND #iUDT_CaljanReceive.ResetReverse
	        THEN
	            #sx_ReverseActive := FALSE;
	            #sx_HoldUnloading := FALSE;
	        END_IF;
	    END_IF;
	    
	END_REGION
	
	REGION 11 - Reset
	    
	    // Safety ok extended pulse
	    #R_TRIG_SafetyOk(CLK := #ix_SafetyReset);
	    
	    #sFB_ResetPulseTimer(iudi_OffDelayTime := #iUDT_CaljanConfiguration.ResetDelay,
	                         ix_SignalToDelay := #R_TRIG_SafetyOk.Q);
	    
	    // Send reset signal to Caljan 
	    #qUDT_CaljanSend.Reset := #ix_SafetyReset OR #iqUDT_EquipmentControl.Command.Reset OR #sFB_ResetPulseTimer.qx_DelayedSignal;
	    
	END_REGION
	
	REGION 12 - Status
	    
	    #sUDT_CommonStatus.Stopped := NOT #sx_AutomaticActive;
	    #sUDT_CommonStatus.Running := (#iUDT_CaljanReceive.BeltDirection_Unloading OR #iUDT_CaljanReceive.BeltDirection_Loading) AND #iUDT_CaljanReceive.ActualSpeed > 0;
	    #sUDT_CommonStatus.AutoON := #sx_Ready AND #sx_AutomaticActive;
	    #sUDT_CommonStatus.Halted := #ix_ExternalRequestHold AND #sUDT_CommonStatus.AutoON AND NOT #sx_EnergySaveActive;
	    #sUDT_CommonStatus.Dieback := (NOT #iqUDT_HandShake.RTR OR #ix_ExternalRequestDieBack) AND #sUDT_CommonStatus.AutoON AND NOT #sx_EnergySaveActive
	    AND NOT #sUDT_CommonStatus.EnergySave AND NOT #sUDT_CommonStatus.Running AND NOT #sx_PEC_EoSFiltered;
	    
	    #sUDT_CommonStatus.EnergySave := #sx_EnergySaveActive;
	    #sUDT_CommonStatus.SafetyStop := NOT #ix_SafetyOk;
	    
	    // HMI status update on change
	    IF #sUDT_CommonStatusOld <> #sUDT_CommonStatus
	    THEN
	        // HMI status initialization
	        #sUDT_HMIStatus.Status := 0;
	        
	        // Running
	        IF #sUDT_CommonStatus.Running
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Running;
	        END_IF;
	        
	        // Stopped
	        IF #sUDT_CommonStatus.Stopped
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Stopped;
	        END_IF;
	        
	        // Energy save
	        IF #sUDT_CommonStatus.EnergySave
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".EnergySave;
	        END_IF;
	        
	        // Dieback
	        IF #sUDT_CommonStatus.Dieback
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Dieback;
	        END_IF;
	        
	        // Halted
	        IF #sUDT_CommonStatus.Halted
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Halted;
	        END_IF;
	        
	        // Dimension error
	        IF #sUDT_HMIStatus.Specific.TooLongParcel
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".DimensionError;
	        END_IF;
	        
	        //  PEC error
	        IF #sUDT_HMIStatus.Specific.PEC_EoS.Jam
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".PECJam;
	        END_IF;
	        
	        // Not healthy
	        IF #sUDT_HMIStatus.Specific.NotHealthy
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".VFDNotHealthy;
	        END_IF;
	        
	        // Safety stop
	        IF #sUDT_CommonStatus.SafetyStop
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".SafetyStop;
	        END_IF;
	        
	        // Copy statuses
	        
	        #sUDT_CommonStatusOld := #sUDT_CommonStatus;
	        #qUDT_Status := #sUDT_CommonStatus;
	    END_IF;
	    
	    #qUDT_HMIStatus := #sUDT_HMIStatus;
	    
	END_REGION
	
	REGION 13 - Statistics
	    
	    // Up time
	    IF #sx_AutomaticActive
	        AND #sx_Ready
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sx_AutomaticActive AND #sx_Ready,
	                        ix_RTrigActivate := #R_TRIG_ConveyorUp.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.ExtendableUpTime);
	    END_IF;
	    
	    // Down time
	    IF NOT #sx_AutomaticActive
	        AND #sx_Ready
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := NOT #sx_AutomaticActive AND #sx_Ready,
	                        ix_RTrigActivate := #R_TRIG_ConveyorDown.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.ExtendableDownTime);
	    END_IF;
	    
	    // Energy save mode active
	    IF #sx_EnergySaveActive
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_CommonStatus.EnergySave,
	                        
	                        ix_RTrigActivate := #R_TRIG_EnergySave.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.EnergySave);
	    END_IF;
	    
	    // Not healthy
	    IF #sUDT_HMIStatus.Specific.NotHealthy
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.NotHealthy,
	                        ix_RTrigActivate := #R_TRIG_NotHealthy.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.NotHealthy);
	    END_IF;
	    
	    // Too long parcel
	    IF #sUDT_HMIStatus.Specific.TooLongParcel
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.TooLongParcel,
	                        ix_RTrigActivate := #R_TRIG_TooLongParcel.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.TooLongParcel);
	    END_IF;
	    
	    // PN Slave not online
	    IF #iqUDT_EquipmentControl.Command.ResetData OR #sUDT_HMIStatus.Specific.PNSlaveNotOnline
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.PNSlaveNotOnline,
	                        ix_RTrigActivate := #sR_TRIG_PNSlaveNotOnline.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.PNNodeNotOnline);
	    END_IF;
	    
	    // PN Slave error
	    IF #iqUDT_EquipmentControl.Command.ResetData OR #sUDT_HMIStatus.Specific.PNSlaveError
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.PNSlaveError,
	                        ix_RTrigActivate := #sR_TRIG_PNSlaveError.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.PNNodeError);
	    END_IF;
	    
	END_REGION
	
	REGION 14 - Report to control block
	    
	    "FC_EquipmentReport"(iUDT_Status := #sUDT_CommonStatus,
	                         iqUDT_Control := #iqUDT_EquipmentControl);
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_PowerDistributionPanel"
TITLE = PDP Block
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 24
// END_ATTRIBUTES
   VAR_INPUT 
      ix_24VOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  24VDC input OK
      ix_ET200Ok { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  ET 200 OK
      ix_CircuitBreakerOkF100 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF201 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF202 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF203 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF204 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF205 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF206 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF207 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF208 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF209 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF210 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF211 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF212 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF213 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF214 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF215 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF216 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF217 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF218 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF219 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF220 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF221 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF222 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF223 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF224 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF225 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF226 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF227 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF228 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF229 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF230 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF231 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF232 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF233 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF234 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF235 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF236 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF237 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF238 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF239 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF240 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF241 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF242 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF243 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF244 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF245 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF246 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF247 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF248 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF249 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF250 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF501 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF502 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF503 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF504 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_CircuitBreakerOkF505 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breaker ok when the signal is true
      ix_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when  hardware is Ok
   END_VAR

   VAR_OUTPUT 
      qUDT_PdpCbState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PowerDistributionPanelCBState";   //  Circuit breakers state
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PowerDistributionPanelStatus";   //  HMI status structure
      qUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   //  Common status structure
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   //  User-defined structure of equipment control commands.
      iq_CircuitBreakersTripped : "UDT_EventStatistic";   //  Circuit breakers event statistics
   END_VAR

   VAR 
      sUDT_CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //  Common status structure
      sUDT_CommonStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //  Auxiliary status structure
   END_VAR
   VAR RETAIN
      sUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PowerDistributionPanelStatus";   //  PDP status UDT
   END_VAR
   VAR 
      sF_Trig_CircuitBreakerTripped {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //  Fall trigger circuit breaker
      sx_CircuitBreakersStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Circuit breakers status
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	19/09/2019  | 2.0       | C.Leite       | first release TIA 15.1
	15/10/2019  | 2.1       | L.Klar        | Updated status structure
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	25/02/2020  | 3.1       | S. Deulkar    | Modified to update ststus output every cycle
	09/07/2020  | 3.2       | S.Theocharis  | Bug fix in status update. Initialize static status instead output status
	25-02-2021  | 3.3       | M.Kocot       | Added extra circuit breaker to cover all PDP's in one block
	31-03-2021  | 3.4       | H.Rutkowski   | Corrected crosschecked and corrected output write
	02-08-2021  | 3.5       | S. Deulkar    | Masked error if we dont have 24V and profinet okay
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	12/03/2024  | 4.1       | S. Nieswiec   | Updated variable names to current standard
	04/10/2024  | 4.2       | F. Solloch    | Adjust for H&M Cheb
	*)
	
	REGION 1 - Trigger
	    
	    // Circuit breaker global status 
	    #sx_CircuitBreakersStatus := #ix_CircuitBreakerOkF100
	    AND #ix_CircuitBreakerOkF201
	    AND #ix_CircuitBreakerOkF202
	    AND #ix_CircuitBreakerOkF203
	    AND #ix_CircuitBreakerOkF204
	    AND #ix_CircuitBreakerOkF205
	    AND #ix_CircuitBreakerOkF206
	    AND #ix_CircuitBreakerOkF207
	    AND #ix_CircuitBreakerOkF208
	    AND #ix_CircuitBreakerOkF209
	    AND #ix_CircuitBreakerOkF210
	    AND #ix_CircuitBreakerOkF211
	    AND #ix_CircuitBreakerOkF212
	    AND #ix_CircuitBreakerOkF213
	    AND #ix_CircuitBreakerOkF214
	    AND #ix_CircuitBreakerOkF215
	    AND #ix_CircuitBreakerOkF216
	    AND #ix_CircuitBreakerOkF217
	    AND #ix_CircuitBreakerOkF218
	    AND #ix_CircuitBreakerOkF219
	    AND #ix_CircuitBreakerOkF220
	    AND #ix_CircuitBreakerOkF221
	    AND #ix_CircuitBreakerOkF222
	    AND #ix_CircuitBreakerOkF223
	    AND #ix_CircuitBreakerOkF224
	    AND #ix_CircuitBreakerOkF225
	    AND #ix_CircuitBreakerOkF226
	    AND #ix_CircuitBreakerOkF227
	    AND #ix_CircuitBreakerOkF228
	    AND #ix_CircuitBreakerOkF229
	    AND #ix_CircuitBreakerOkF230
	    AND #ix_CircuitBreakerOkF231
	    AND #ix_CircuitBreakerOkF232
	    AND #ix_CircuitBreakerOkF233
	    AND #ix_CircuitBreakerOkF234
	    AND #ix_CircuitBreakerOkF235
	    AND #ix_CircuitBreakerOkF236
	    AND #ix_CircuitBreakerOkF237
	    AND #ix_CircuitBreakerOkF238
	    AND #ix_CircuitBreakerOkF239
	    AND #ix_CircuitBreakerOkF240
	    AND #ix_CircuitBreakerOkF241
	    AND #ix_CircuitBreakerOkF242
	    AND #ix_CircuitBreakerOkF243
	    AND #ix_CircuitBreakerOkF244
	    AND #ix_CircuitBreakerOkF245
	    AND #ix_CircuitBreakerOkF246
	    AND #ix_CircuitBreakerOkF247
	    AND #ix_CircuitBreakerOkF248
	    AND #ix_CircuitBreakerOkF249
	    AND #ix_CircuitBreakerOkF250
	    AND #ix_CircuitBreakerOkF501
	    AND #ix_CircuitBreakerOkF502
	    AND #ix_CircuitBreakerOkF503
	    AND #ix_CircuitBreakerOkF504
	    AND #ix_CircuitBreakerOkF505;
	    
	    // Fall trigger circuit breaker tripped
	    #sF_Trig_CircuitBreakerTripped(CLK := #sx_CircuitBreakersStatus);
	    
	END_REGION
	
	REGION 2 - Reset faults
	    
	    // All faults are reset when the reset input is true
	    IF #iqUDT_EquipmentControl.Command.Reset
	        OR NOT #ix_ET200Ok
	        OR NOT #ix_24VOk
	    THEN
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF100 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF201 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF202 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF203 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF204 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF205 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF206 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF207 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF208 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF209 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF210 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF211 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF212 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF213 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF214 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF215 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF216 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF217 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF218 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF219 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF220 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF221 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF222 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF223 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF224 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF225 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF226 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF227 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF228 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF229 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF230 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF231 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF232 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF233 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF234 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF235 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF236 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF237 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF238 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF239 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF240 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF241 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF242 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF243 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF244 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF245 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF246 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF247 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF248 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF249 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF250 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF501 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF502 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF503 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF504 := FALSE;
	        #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF505 := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Faults monitoring 
	    
	    // If a circuit breaker is tripped, the state of that is set in HMI Status
	    IF #ix_ET200Ok
	        AND #ix_24VOk
	    THEN
	        
	        IF NOT #sx_CircuitBreakersStatus
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakersTripped := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF100
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF100 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF201
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF201 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF202
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF202 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF203
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF203 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF204
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF204 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF205
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF205 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF206
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF206 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF207
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF207 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF208
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF208 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF209
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF209 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF210
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF210 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF211
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF211 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF212
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF212 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF213
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF213 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF214
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF214 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF215
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF215 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF216
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF216 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF217
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF217 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF218
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF218 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF219
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF219 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF220
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF220 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF221
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF221 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF222
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF222 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF223
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF223 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF224
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF224 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF225
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF225 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF226
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF226 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF227
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF227 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF228
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF228 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF229
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF229 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF230
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF230 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF231
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF231 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF232
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF232 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF232
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF232 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF233
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF233 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF234
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF234 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF235
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF235 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF236
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF236 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF237
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF237 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF238
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF238 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF239
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF239 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF240
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF240 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF241
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF241 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF242
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF242 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF243
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF243 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF244
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF244 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF245
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF245 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF246
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF246 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF247
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF247 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF248
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF248 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF249
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF249 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF250
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF250 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF501
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF501 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF502
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF502 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF503
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF503 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF504
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF504 := TRUE;
	        END_IF;
	        
	        IF NOT #ix_CircuitBreakerOkF505
	        THEN
	            #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF505 := TRUE;
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Status
	    
	    // Set common error to report 
	    #sUDT_CommonStatus.Error := #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF100
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF201
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF202
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF203
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF204
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF205
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF206
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF207
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF208
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF209
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF210
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF211
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF212
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF213
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF214
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF215
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF216
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF217
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF218
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF219
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF220
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF221
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF222
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF223
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF224
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF225
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF225
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF226
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF227
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF228
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF229
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF230
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF231
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF232
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF233
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF234
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF235
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF236
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF237
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF238
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF239
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF240
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF241
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF242
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF243
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF244
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF245
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF246
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF247
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF248
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF249
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF250
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF501
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF502
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF503
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF504
	    OR #sUDT_HMIStatus.Specific.CircuitBreakerTrippedF505
	    ;
	    
	    // HMI status update
	    IF #sUDT_CommonStatusOld <> #sUDT_CommonStatus                    // update on change
	    THEN
	        
	        // HMI status initialization
	        #sUDT_HMIStatus.Status := 0;
	        
	        // HMI status calculation
	        IF #sUDT_CommonStatus.Error                                    // CB error
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".CBError;
	            
	        END_IF;
	        
	        #sUDT_CommonStatusOld := #sUDT_CommonStatus;                  // Copy status to memory
	        #qUDT_Status := #sUDT_CommonStatus;                           // Copy status to output
	        
	    END_IF;
	    
	    #qUDT_HMIStatus := #sUDT_HMIStatus;                           // Copy HMI status to output
	    
	END_REGION
	
	REGION 5 - Statistics
	    
	    // Statistics is running when at least one circuit breaker is tripped
	    IF #sUDT_HMIStatus.Specific.CircuitBreakersTripped
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.CircuitBreakersTripped,
	                        ix_RTrigActivate := #sF_Trig_CircuitBreakerTripped.Q,
	                        iqUDT_Statistics := #iq_CircuitBreakersTripped);
	        
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Report to control block
	    
	    // Function to manage report between control block and conveyor block
	    "FC_EquipmentReport"(iUDT_Status := #sUDT_CommonStatus,
	                         iqUDT_Control := #iqUDT_EquipmentControl);
	    
	END_REGION
	
	REGION 7 - Circuit Breake State
	    
	    // State mapping from input to output
	    #qUDT_PdpCbState.CircuitBreakerStateF100 := #ix_CircuitBreakerOkF100;
	    #qUDT_PdpCbState.CircuitBreakerStateF201 := #ix_CircuitBreakerOkF201;
	    #qUDT_PdpCbState.CircuitBreakerStateF202 := #ix_CircuitBreakerOkF202;
	    #qUDT_PdpCbState.CircuitBreakerStateF203 := #ix_CircuitBreakerOkF203;
	    #qUDT_PdpCbState.CircuitBreakerStateF204 := #ix_CircuitBreakerOkF204;
	    #qUDT_PdpCbState.CircuitBreakerStateF205 := #ix_CircuitBreakerOkF205;
	    #qUDT_PdpCbState.CircuitBreakerStateF206 := #ix_CircuitBreakerOkF206;
	    #qUDT_PdpCbState.CircuitBreakerStateF207 := #ix_CircuitBreakerOkF207;
	    #qUDT_PdpCbState.CircuitBreakerStateF208 := #ix_CircuitBreakerOkF208;
	    #qUDT_PdpCbState.CircuitBreakerStateF209 := #ix_CircuitBreakerOkF209;
	    #qUDT_PdpCbState.CircuitBreakerStateF210 := #ix_CircuitBreakerOkF210;
	    #qUDT_PdpCbState.CircuitBreakerStateF211 := #ix_CircuitBreakerOkF211;
	    #qUDT_PdpCbState.CircuitBreakerStateF212 := #ix_CircuitBreakerOkF212;
	    #qUDT_PdpCbState.CircuitBreakerStateF213 := #ix_CircuitBreakerOkF213;
	    #qUDT_PdpCbState.CircuitBreakerStateF214 := #ix_CircuitBreakerOkF214;
	    #qUDT_PdpCbState.CircuitBreakerStateF215 := #ix_CircuitBreakerOkF215;
	    #qUDT_PdpCbState.CircuitBreakerStateF216 := #ix_CircuitBreakerOkF216;
	    #qUDT_PdpCbState.CircuitBreakerStateF217 := #ix_CircuitBreakerOkF217;
	    #qUDT_PdpCbState.CircuitBreakerStateF218 := #ix_CircuitBreakerOkF218;
	    #qUDT_PdpCbState.CircuitBreakerStateF219 := #ix_CircuitBreakerOkF219;
	    #qUDT_PdpCbState.CircuitBreakerStateF220 := #ix_CircuitBreakerOkF220;
	    #qUDT_PdpCbState.CircuitBreakerStateF221 := #ix_CircuitBreakerOkF221;
	    #qUDT_PdpCbState.CircuitBreakerStateF222 := #ix_CircuitBreakerOkF222;
	    #qUDT_PdpCbState.CircuitBreakerStateF223 := #ix_CircuitBreakerOkF223;
	    #qUDT_PdpCbState.CircuitBreakerStateF224 := #ix_CircuitBreakerOkF224;
	    #qUDT_PdpCbState.CircuitBreakerStateF225 := #ix_CircuitBreakerOkF225;
	    #qUDT_PdpCbState.CircuitBreakerStateF226 := #ix_CircuitBreakerOkF226;
	    #qUDT_PdpCbState.CircuitBreakerStateF227 := #ix_CircuitBreakerOkF227;
	    #qUDT_PdpCbState.CircuitBreakerStateF228 := #ix_CircuitBreakerOkF228;
	    #qUDT_PdpCbState.CircuitBreakerStateF229 := #ix_CircuitBreakerOkF229;
	    #qUDT_PdpCbState.CircuitBreakerStateF230 := #ix_CircuitBreakerOkF230;
	    #qUDT_PdpCbState.CircuitBreakerStateF231 := #ix_CircuitBreakerOkF231;
	    #qUDT_PdpCbState.CircuitBreakerStateF232 := #ix_CircuitBreakerOkF232;
	    #qUDT_PdpCbState.CircuitBreakerStateF233 := #ix_CircuitBreakerOkF233;
	    #qUDT_PdpCbState.CircuitBreakerStateF234 := #ix_CircuitBreakerOkF234;
	    #qUDT_PdpCbState.CircuitBreakerStateF235 := #ix_CircuitBreakerOkF235;
	    #qUDT_PdpCbState.CircuitBreakerStateF236 := #ix_CircuitBreakerOkF236;
	    #qUDT_PdpCbState.CircuitBreakerStateF237 := #ix_CircuitBreakerOkF237;
	    #qUDT_PdpCbState.CircuitBreakerStateF238 := #ix_CircuitBreakerOkF238;
	    #qUDT_PdpCbState.CircuitBreakerStateF239 := #ix_CircuitBreakerOkF239;
	    #qUDT_PdpCbState.CircuitBreakerStateF240 := #ix_CircuitBreakerOkF240;
	    #qUDT_PdpCbState.CircuitBreakerStateF241 := #ix_CircuitBreakerOkF241;
	    #qUDT_PdpCbState.CircuitBreakerStateF242 := #ix_CircuitBreakerOkF242;
	    #qUDT_PdpCbState.CircuitBreakerStateF243 := #ix_CircuitBreakerOkF243;
	    #qUDT_PdpCbState.CircuitBreakerStateF244 := #ix_CircuitBreakerOkF244;
	    #qUDT_PdpCbState.CircuitBreakerStateF245 := #ix_CircuitBreakerOkF245;
	    #qUDT_PdpCbState.CircuitBreakerStateF246 := #ix_CircuitBreakerOkF246;
	    #qUDT_PdpCbState.CircuitBreakerStateF247 := #ix_CircuitBreakerOkF247;
	    #qUDT_PdpCbState.CircuitBreakerStateF248 := #ix_CircuitBreakerOkF248;
	    #qUDT_PdpCbState.CircuitBreakerStateF249 := #ix_CircuitBreakerOkF249;
	    #qUDT_PdpCbState.CircuitBreakerStateF250 := #ix_CircuitBreakerOkF250;
	    #qUDT_PdpCbState.CircuitBreakerStateF501 := #ix_CircuitBreakerOkF501;
	    #qUDT_PdpCbState.CircuitBreakerStateF502 := #ix_CircuitBreakerOkF502;
	    #qUDT_PdpCbState.CircuitBreakerStateF503 := #ix_CircuitBreakerOkF503;
	    #qUDT_PdpCbState.CircuitBreakerStateF504 := #ix_CircuitBreakerOkF504;
	    #qUDT_PdpCbState.CircuitBreakerStateF505 := #ix_CircuitBreakerOkF505;
	    
	    
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_ProfiDiag"
TITLE = FB_ProfiDiag
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 25
// END_ATTRIBUTES
//Function block to diagnose Profinet network.
   VAR_INPUT 
      iui_LADDR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_IOSYSTEM;   // Hardware identifier of the PROFINET IO
      ix_ExternalScan { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External scan
   END_VAR

   VAR_OUTPUT 
      qx_ProfinetOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet ok
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective error output
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
      iqUDT_PNDiagArray : "UDT_ProfinetNetwork";   // Profinet devices status array
      iqUDT_Statistics : "UDT_ProfiDiagStatistics";   // Statistics structure
   END_VAR

   VAR 
      s_GetProjectName {InstructionName := 'Get_Name'; LibVersion := '1.3'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Get_Name;   // Get name function
      sa_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         ErrorCode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Error code structure
            DeviceState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Siemens "DeviceState" error code
            GEO2LOG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Siemens "GEO2LOG" error code
            LOG2GEO { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Siemens "LOG2GEO" error code
            GetName { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Siemens "GetName" error code
         END_STRUCT;
      END_STRUCT;
      sx_PNOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;   // Profinet OK
      sx_NewEvent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // New event
   END_VAR

   VAR_TEMP 
      tv_ProfinetGeoAdr {InstructionName := 'GEOADDR'; LibVersion := '1.0'} : GEOADDR;   // Profinet network geo structure
      tv_DeviceGeoAdr {InstructionName := 'GEOADDR'; LibVersion := '1.0'} : GEOADDR;   // Profinet device geo structure
      ta_Configured : Array[0..1024] of Bool;   // Configured devices array
      ta_Exist : Array[0..1024] of Bool;   // Existing devices array
      ta_Error : Array[0..1024] of Bool;   // Devices errors array
      ti_DeviceNr : Int;   // Device number
      ti_NrOfDevicesError : Int;   // Number of devices error
      ti_DiagArraySize : Int;   // Diagnostic array size
   END_VAR

   VAR CONSTANT 
      cui_ConfiguredDevicesMode : UInt := 1;   // Scan mode of configured devices
      cui_ExistingDevicesMode : UInt := 4;   // Scan mode of existing devices
      cui_DevicesErrorMode : UInt := 2;   // Scan mode of devices error
      cui_HWType : UInt := 2;   // IO device hardware type
      cui_Area : UInt := 1;   // IO device area
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | K.Pokorski    | first release MHS TIA 15.1
	13/06/2019  | 0.2       | A.Nowak       | Replacement of instruction if for direct write into variable - Region 3
	24/06/2019  | 0.3       | L.Klar        | Status running added
	19/07/2019  | 0.5       | L.Klar        | Status handling changed, output qx_ProfinetOk added
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	14/08/2019  | 2.1       | K.Pokorski    | HW_ID and TIA device project name handling added 
	26/08/2019  | 2.2       | K.Pokorski    | Comments adjusted
	20/09/2019  | 2.3       | K.Pokorski    | "UDT_Status" deleted
	04/11/2019  | 2.4       | L.Klar        | Scan profinet and first scan changed from memory bit to DB variable
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – Scan request
	    
	    IF ("DB_Memory".ScanProfinet    // Scan request from diagnostic OB 
	        OR "DB_Memory".FirstScan    // First PLC cycle
	        OR #ix_ExternalScan)        // External scan available
	    THEN
	        
	        #sx_PNOK := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 – Devices states update 
	    
	    // Scan devices, extract device status: configured, exists, error when profinet network not ok
	    IF (NOT #sx_PNOK)       // Profinet needs a scan
	    THEN
	        
	        #sa_Status.ErrorCode.DeviceState := DeviceStates(LADDR := #iui_LADDR,
	                                                         MODE := #cui_ConfiguredDevicesMode,
	                                                         STATE := #ta_Configured);
	        
	        #sa_Status.ErrorCode.DeviceState := DeviceStates(LADDR := #iui_LADDR,
	                                                         MODE := #cui_ExistingDevicesMode,
	                                                         STATE := #ta_Exist);
	        
	        #sa_Status.ErrorCode.DeviceState := DeviceStates(LADDR := #iui_LADDR,
	                                                         MODE := #cui_DevicesErrorMode,
	                                                         STATE := #ta_Error);
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 – Devices Statuses update
	    
	    // Move device state to diagnostic structure if network required scan and no error occured during scan 
	    IF (NOT #sx_PNOK                                                                                                    // Profinet not ok 
	        AND #sa_Status.ErrorCode.DeviceState = 0)                                                                       // "DeviceStates" error free                                      
	    THEN
	        
	        // Initialise reset device errors counter
	        #ti_NrOfDevicesError := 0;
	        
	        // Maximum number of Profinet devices
	        #ti_DiagArraySize := "FC_GetNrOfArrayEl"(iv_Array := #iqUDT_PNDiagArray.DeviceStatus);
	        
	        // A loop operating on Profinet devices
	        FOR #ti_DeviceNr := 0 TO (#ti_DiagArraySize - 1)
	        DO
	            
	            // The device is configured in TIA Portal 
	            IF (#ta_Configured[#ti_DeviceNr])                                                                           // Devices configured
	            THEN
	                
	                // Set the device configured status bit in diagnostic structure
	                #iqUDT_PNDiagArray.DeviceStatus[#ti_DeviceNr].DeviceState.Configure := TRUE;
	                
	                // Move device profinet number to diagnostic structure
	                #iqUDT_PNDiagArray.DeviceStatus[#ti_DeviceNr].DeviceState.ProfinetNumber := INT_TO_UINT(#ti_DeviceNr);
	                
	                // Get the Profinet network IOSystem address 
	                #sa_Status.ErrorCode.LOG2GEO := LOG2GEO(LADDR := #iui_LADDR, GEOADDR := #tv_ProfinetGeoAdr);
	                
	                // Configuring parameters for extracting the device's HW_ID
	                #tv_DeviceGeoAdr.HWTYPE := #cui_HWType;
	                #tv_DeviceGeoAdr.AREA := #cui_Area;
	                #tv_DeviceGeoAdr.STATION := INT_TO_UINT(#ti_DeviceNr);
	                #tv_DeviceGeoAdr.IOSYSTEM := #tv_ProfinetGeoAdr.IOSYSTEM;
	                
	                // Extracting the device's HW_ID 
	                #sa_Status.ErrorCode.GEO2LOG := GEO2LOG(GEOADDR := #tv_DeviceGeoAdr,
	                                                        LADDR => #iqUDT_PNDiagArray.DeviceStatus[#ti_DeviceNr].DeviceState.HW_ID);
	                
	                // Move device's project name to diagnostic structure
	                #s_GetProjectName(LADDR := #iui_LADDR,
	                                  STATION_NR := INT_TO_UINT(#ti_DeviceNr),
	                                  STATUS => #sa_Status.ErrorCode.GetName,
	                                  DATA := #iqUDT_PNDiagArray.DeviceStatus[#ti_DeviceNr].DeviceState.PNDeviceName);
	                
	                // Move device exist state to the Profinet diagnostic structure 
	                IF (#ta_Exist[#ti_DeviceNr])                                                                                // Device exist
	                THEN
	                    
	                    #iqUDT_PNDiagArray.DeviceStatus[#ti_DeviceNr].DeviceState.Exist := TRUE;
	                    
	                ELSE
	                    
	                    #iqUDT_PNDiagArray.DeviceStatus[#ti_DeviceNr].DeviceState.Exist := FALSE;
	                    
	                    // Increment the number of devices error
	                    #ti_NrOfDevicesError += 1;
	                    
	                END_IF;
	                // Move device error state to the Profinet diagnostic structure 
	                IF (NOT #ta_Error[#ti_DeviceNr])                                                                            // Device is error free
	                THEN
	                    
	                    #iqUDT_PNDiagArray.DeviceStatus[#ti_DeviceNr].DeviceState.Error := FALSE;
	                    
	                ELSE
	                    
	                    // New error detected
	                    #sx_NewEvent := NOT #iqUDT_PNDiagArray.DeviceStatus[#ti_DeviceNr].DeviceState.Error;
	                    
	                    // Statistics handling
	                    IF (#ta_Error[#ti_DeviceNr]                                                                             // Device has error
	                        OR #iqUDT_EquipmentControl.Command.ResetData)                                                      // Reset statistics available
	                    THEN
	                        
	                        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                                        ix_Activate := #ta_Error[#ti_DeviceNr],
	                                        ix_RTrigActivate := #sx_NewEvent,
	                                        iqUDT_Statistics := #iqUDT_Statistics.DeviceError[#ti_DeviceNr]);
	                        
	                    END_IF;
	                    
	                    #iqUDT_PNDiagArray.DeviceStatus[#ti_DeviceNr].DeviceState.Error := TRUE;
	                    
	                    // Increment number of devices error
	                    #ti_NrOfDevicesError += 1;
	                    
	                END_IF;
	                
	                // Reset all diagnostic information if the device is not configured in TIA Portal 
	            ELSE
	                
	                #iqUDT_PNDiagArray.DeviceStatus[#ti_DeviceNr].DeviceState.Configure := FALSE;
	                #iqUDT_PNDiagArray.DeviceStatus[#ti_DeviceNr].DeviceState.Exist := FALSE;
	                #iqUDT_PNDiagArray.DeviceStatus[#ti_DeviceNr].DeviceState.Error := FALSE;
	                #iqUDT_PNDiagArray.DeviceStatus[#ti_DeviceNr].DeviceState.HW_ID := 0;
	                #iqUDT_PNDiagArray.DeviceStatus[#ti_DeviceNr].DeviceState.ProfinetNumber := 0;
	                #iqUDT_PNDiagArray.DeviceStatus[#ti_DeviceNr].DeviceState.PNDeviceName := '';
	                
	            END_IF;
	            
	        END_FOR;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 – Profinet OK
	    
	    // Reset profinet error
	    IF (#ti_NrOfDevicesError = 0                        // Number of devices error equal to zero 
	        AND (#iqUDT_EquipmentControl.Command.Reset     // Error reset required 
	        OR #ix_ExternalScan))                           // External scan active
	    THEN
	        
	        #sx_PNOK := TRUE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 5 – Status
	    
	    // Update Profinet ok output status
	    #qx_ProfinetOk := #sx_PNOK;
	    
	    // Create the collective block error bit
	    #qx_Error := #sa_Status.ErrorCode.DeviceState <> 0       // Profinet network error  
	    OR #sa_Status.ErrorCode.GEO2LOG <> 0                     // "Geo2Log" standard Siemens block error
	    OR #sa_Status.ErrorCode.LOG2GEO <> 0                     // "Log2Geo" standard Siemens block error
	    OR #sa_Status.ErrorCode.GetName > 16#8000;               // "GetName" standard Siemens block error
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_SlipCompensation"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 27
// END_ATTRIBUTES
   VAR_INPUT 
      IUDT_DowstreamConveyorLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorCommonConfiguration";   //  Configured length of the downstream conveyor
      ii_ConfigurationSlipfactor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 0;   //  1-100% slip of the parcel
   END_VAR

   VAR_IN_OUT 
      iqUDT_ConveyorInterfaceUpstream : "UDT_ConveyorInterface";   //  Interface structure
      iqUDT_ConveyorInterfaceDownstream : "UDT_ConveyorInterface";   //  Interface structure
      iqUDT_HandShakeUpstream : "UDT_ConveyorHandshake";   //  Upstream handshake structure in forward direction
      iqUDT_HandShakeDownstreamSlip : "UDT_ConveyorHandshake";   //  Downstream handshake structure in forward direction
      iqs_TrackingDataDownstream : Array[*] of Int;   //  Tracking data
   END_VAR

   VAR 
      sR_TRIG_TIP {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge trigger TIP signal
      si_MemoryGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Latest GIN
      si_MemoryParcel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Latest Parcellength
      si_CalculatedSlipLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Calculated slip based on lenth of the parcel
      si_ProcessedParcelLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  The length of the parcel to be processed
      si_DelayedSlipLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Actual slip counter
      si_LoopCounterWrite { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  LoopCounter write data in tracking array
      sx_ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Error in configuration values
      sx_PositiveSlip { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Speed difference is generating positive slip
      sx_NegativeSlip { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Speed difference is generating negative slip
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	30/01/2020  | 3.0       | F.Baten       | first release MHS TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Configuration error
	    // When slipfactor is less than 1% or bigger than 100% the configuration error is set and passed to both conveyors
	    #sx_ConfigurationError := #ii_ConfigurationSlipfactor > 100 OR #ii_ConfigurationSlipfactor < 1;
	    #iqUDT_ConveyorInterfaceDownstream.ConfigurationError := #sx_ConfigurationError;
	    #iqUDT_ConveyorInterfaceUpstream.ConfigurationError := #sx_ConfigurationError;
	    
	END_REGION
	
	REGION 2 - Get new gin data
	    IF #iqUDT_HandShakeUpstream.GIN <> 0                                                           // Gin on upstream conveyor
	        AND #iqUDT_HandShakeUpstream.GIN <> #si_MemoryGIN                                          // not equal to previous one
	    THEN
	        #si_MemoryGIN := #iqUDT_HandShakeUpstream.GIN;                                             // Memorise
	        #si_MemoryParcel := "DB_GIN".GIN[#si_MemoryGIN].General.Length;                             // Get the length of this parcel 
	        #si_CalculatedSlipLength := REAL_TO_INT((INT_TO_REAL(#si_MemoryParcel) / 100.0) * INT_TO_REAL(#ii_ConfigurationSlipfactor)); // Calculate the distance to generate slip 
	        #si_DelayedSlipLength := 0;                                                                 // reset the slipcouter
	        #si_ProcessedParcelLength := #si_MemoryParcel;                                              // copy the memory to the process value
	    END_IF;
	END_REGION
	
	REGION 3 - Check slip direction
	    // If the speed setpoint of the upstream conveyor is higher than the downstream, the parcel is pushed onto the downstream conveyor
	    // here called "positive slip" the otherway around is then "negative slip".
	    
	    IF #iqUDT_ConveyorInterfaceUpstream.SpeedSetpoint > #iqUDT_ConveyorInterfaceDownstream.SpeedSetpoint
	    THEN
	        #sx_PositiveSlip := TRUE;
	        #sx_NegativeSlip := FALSE;
	    ELSE
	        #sx_PositiveSlip := FALSE;
	        #sx_NegativeSlip := TRUE;
	    END_IF;
	END_REGION
	
	REGION 4 - Clear upstream NRofPosToShift on own displacement
	    // mimic the working of the tracking for it is not copied to downstream, so with displacement the prositions to shift is decreased
	    IF #iqUDT_HandShakeUpstream.NrOfPosToShift > 0 AND
	        #iqUDT_ConveyorInterfaceUpstream.Displacement > 0
	    THEN
	        #iqUDT_HandShakeUpstream.NrOfPosToShift -= #iqUDT_ConveyorInterfaceUpstream.Displacement;
	        IF #iqUDT_HandShakeUpstream.NrOfPosToShift < 0
	        THEN
	            #iqUDT_HandShakeUpstream.NrOfPosToShift := 0;
	        END_IF;
	    END_IF;
	END_REGION
	
	REGION 5 - Negative slip handling
	    //  Delay the writing of the data with the slipdistance and then with the displacement
	    //  of the downstream conveyor so the data will catch up because it faster.
	    IF #sx_NegativeSlip
	    THEN
	        
	        REGION 5.1 - Slip delay
	            IF #iqUDT_HandShakeUpstream.TIP                                                        // Transfer is started
	                AND #si_DelayedSlipLength < #si_CalculatedSlipLength                                // Actual slip is not yet reached
	            THEN
	                #si_DelayedSlipLength += #iqUDT_ConveyorInterfaceDownstream.Displacement;          // Increase the slip distance
	            END_IF;
	        END_REGION
	        
	        REGION 5.2 - Pass GIN to downstream
	            IF #si_DelayedSlipLength >= #si_CalculatedSlipLength                                    // The slipdistance is equal or larger to the calculated value
	                AND #si_ProcessedParcelLength > 0                                                   // the lenth of the parcel is not completely processed yet
	            THEN
	                #si_ProcessedParcelLength -= #iqUDT_HandShakeDownstreamSlip.DownstreamDisplacement;    // Decrease the parcel lenth by conveyor displacement
	                
	                #iqUDT_HandShakeDownstreamSlip.NrOfPosToShift := #iqUDT_ConveyorInterfaceDownstream.Displacement; // copy the numbers of positions to shift back to the downstream conveyor
	                #iqUDT_HandShakeDownstreamSlip.GIN := #si_MemoryGIN;
	                IF #si_ProcessedParcelLength < 0                                                    // parcel length too small
	                THEN
	                    #si_ProcessedParcelLength := 0;                                                 // reset length
	                END_IF;
	            END_IF;
	            
	            IF #si_DelayedSlipLength < #si_CalculatedSlipLength                                     // The slipdistance is smaller than the calculated value
	                OR #si_ProcessedParcelLength = 0                                                    // the length of the parcel is processed
	            THEN
	                #iqUDT_HandShakeDownstreamSlip.NrOfPosToShift := 0;                                // reset the value
	                #iqUDT_HandShakeDownstreamSlip.GIN := 0;                                           // clear the GIN
	            END_IF;
	        END_REGION
	    END_IF;
	END_REGION
	
	REGION 6 - Positive slip handling
	    // Write the data on start of the tip directly in front and then with the displacement of the downstream conveyor
	    // as the parcel is gripped by the conveyor belt.
	    IF #sx_PositiveSlip
	    THEN
	        REGION 6.1 - Parcel entering, write slipped GIN to downstream
	            #sR_TRIG_TIP(CLK := #iqUDT_HandShakeUpstream.TIP
	                         AND (#iqUDT_HandShakeUpstream.GIN <> 0)
	                         AND #iqUDT_HandShakeUpstream.GIN = #si_MemoryGIN);                     // Start of the TIP
	            IF #sR_TRIG_TIP.Q
	            THEN                                                                                // write directly GIN in tracking for the length of the slip
	                FOR #si_LoopCounterWrite := #si_CalculatedSlipLength TO 0 BY -1 DO                      // set the loopcounter
	                    #iqs_TrackingDataDownstream[(#IUDT_DowstreamConveyorLength.Length / 10) - #si_LoopCounterWrite] := #si_MemoryGIN; // Write the GIN from the calculated position to the end 
	                END_FOR;
	                #si_ProcessedParcelLength := "DB_GIN".GIN[#si_MemoryGIN].General.Length - #si_CalculatedSlipLength;
	            END_IF;
	        END_REGION
	        
	        REGION 6.2 - Pass remaining GIN to downstream
	            // Calculate the length of the parcel to write GIN
	            // Write the GIN while the parcellength is not '0', reset the values when the parcel is gone but only when in positive slip
	            IF #si_ProcessedParcelLength > 0                                                    // There is still parcellength to process    
	            THEN
	                #si_ProcessedParcelLength -= #iqUDT_ConveyorInterfaceDownstream.Displacement;  // decrease the lenth of the value by the downstream displacement
	                IF #si_ProcessedParcelLength < 0                                                // If the length is smaller than '0'    
	                THEN
	                    #si_ProcessedParcelLength := 0;                                             // set the value to '0'
	                END_IF;
	                
	                #iqUDT_HandShakeDownstreamSlip.DownstreamDisplacement := #iqUDT_ConveyorInterfaceDownstream.Displacement; // copy the displacement back to the interface
	                #iqUDT_HandShakeDownstreamSlip.GIN := #si_MemoryGIN;                           // copy the gin into the interface
	            END_IF;
	        END_REGION
	        
	        // Parcel was processed, reset values 
	        IF #si_ProcessedParcelLength = 0
	        THEN
	            #iqUDT_HandShakeDownstreamSlip.NrOfPosToShift := 0;
	            #iqUDT_HandShakeDownstreamSlip.GIN := 0;
	        END_IF;
	    END_IF;
	END_REGION
	
	REGION 7 - Handle handshake
	    #iqUDT_HandShakeDownstreamSlip.RTS := #iqUDT_HandShakeUpstream.RTS;
	    #iqUDT_HandShakeUpstream.RTR := #iqUDT_HandShakeDownstreamSlip.RTR;
	    #iqUDT_HandShakeDownstreamSlip.TIP := #iqUDT_HandShakeUpstream.TIP;
	    #iqUDT_HandShakeDownstreamSlip.ResetEnergySave := #iqUDT_HandShakeUpstream.ResetEnergySave;
	    #iqUDT_HandShakeUpstream.CascadeStartUp := #iqUDT_HandShakeDownstreamSlip.CascadeStartUp;
	    #iqUDT_HandShakeDownstreamSlip.ReqStop := #iqUDT_HandShakeUpstream.ReqStop;
	    #iqUDT_HandShakeDownstreamSlip.DownstreamDisplacement := #iqUDT_ConveyorInterfaceDownstream.Displacement;
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_SoftVersion"
TITLE = FB_SoftVersion
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 28
// END_ATTRIBUTES
//Function block to get the program checksums.
   VAR_INPUT 
      is_ActualDateTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Actual date and time
   END_VAR

   VAR_OUTPUT 
      qs_SoftVersion { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[8];   // Software version
      qa_StandardCRC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..7] of Byte;   // Standard program checksum output
      qa_SafetyCRC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..7] of Byte;   // Safety program checksum output
   END_VAR

   VAR 
      sFB_GetChecksum_Safety {InstructionName := 'GetChecksum'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : GetChecksum;   // Safety checksum read block
      sFB_GetChecksum_Standard {InstructionName := 'GetChecksum'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : GetChecksum;   // Standard checksum read block
   END_VAR
   VAR RETAIN
      sa_StandardCRC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..7] of Byte;   // Standard program checksum
      sa_SafetyCRC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..7] of Byte;   // Safety program checksum
   END_VAR
   VAR 
      sa_NewStandardCRC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..7] of Byte;   // New standard program checksum
      sa_NewSafetyCRC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..7] of Byte;   // New safety program checksum
   END_VAR
   VAR RETAIN
      ss_Date { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[8];   // Date charater string
   END_VAR

   VAR_TEMP 
      ta_StandardCRC : Struct   // GetChecksum
         tx_Done : Bool;   // GetChecksum - Done
         tx_Busy : Bool;   // GetChecksum - Busy
         tx_Error : Bool;   // GetChecksum - Error
         tw_Status : Word;   // GetChecksum - Status
      END_STRUCT;
      ta_SafetyCRC : Struct   // GetChecksum
         tx_Done : Bool;   // GetChecksum - Done
         tx_Busy : Bool;   // GetChecksum - Busy
         tx_Error : Bool;   // GetChecksum - Error
         tw_Status : Word;   // GetChecksum - Status
      END_STRUCT;
      tx_CRCValid : Bool;   // Checksums valid
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | K.Pokorski    | first release MHS TIA 15.1
	14/06/2019  | 0.2       | A.Nowak       | Replacement of instruction if for direct write into variable - Region 2  
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	27/08/2019  | 2.2       | K.Pokorski    | Comments adjusted
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Standard and safety program checksums
	    
	    // Scope - 1 - Standard program CRC
	    #sFB_GetChecksum_Standard(Scope := 1,
	                              Done => #ta_StandardCRC.tx_Done,
	                              Busy => #ta_StandardCRC.tx_Busy,
	                              Error => #ta_StandardCRC.tx_Error,
	                              Status => #ta_StandardCRC.tw_Status,
	                              Checksum := #sa_NewStandardCRC);
	    
	    // Scope - 2 - Safety program CRC
	    #sFB_GetChecksum_Safety(Scope := 2,
	                            Done => #ta_SafetyCRC.tx_Done,
	                            Busy => #ta_SafetyCRC.tx_Busy,
	                            Error => #ta_SafetyCRC.tx_Error,
	                            Status => #ta_SafetyCRC.tw_Status,
	                            Checksum := #sa_NewSafetyCRC);
	    
	END_REGION
	
	REGION 2 - Checksums comparison
	    
	    #tx_CRCValid := (#sa_NewStandardCRC = #sa_StandardCRC)
	    AND (#sa_SafetyCRC = #sa_NewSafetyCRC);
	    
	END_REGION
	
	REGION 3 - New software version 
	    
	    // Separate the year, mounth and day from actual date and time and connect it to one string
	    IF (NOT #tx_CRCValid)                                           // Checksums not valid
	    THEN
	        
	        #ss_Date := CONCAT(IN1 := MID(IN := #is_ActualDateTime,
	                                                         L := 4,
	                                                         P := 1),
	                           
	                           IN2 := MID(IN := #is_ActualDateTime,
	                                      L := 2,
	                                      P := 6),
	                           
	                           IN3 := MID(IN := #is_ActualDateTime,
	                                      L := 2,
	                                      P := 9));
	        
	        // Standard progrm checksum update
	        #sa_StandardCRC := #sa_NewStandardCRC;
	        
	        // Safety program checksum update
	        #sa_SafetyCRC := #sa_NewSafetyCRC;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Write outputs 
	    
	    // New program date
	    #qs_SoftVersion := #ss_Date;
	    
	    // Actual standard program checksum
	    #qa_StandardCRC := #sa_StandardCRC;
	    
	    // Actual safety program checksum
	    #qa_SafetyCRC := #sa_SafetyCRC;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_VfdNORDPPO4"
TITLE = Control block for NORD VFD with PPO4
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHS
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 235
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_VFDConfig { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdConfiguration";   // Configuration structure
      iUDT_VFDInputs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdNordPI";   // VFD inputs structure
      iUDT_MotorData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_MotorData";   // Motor data structure
      ix_24vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 24VDC is healthy
      ix_400vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 400VAC is healthy
      ix_QuickStopDisable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;   // TRUE when Motor can turn, False = Quick stop
      ix_SimulationModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when Simulation mode active
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdStatus";   // HMI status structure
      qUDT_VFDOutputs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdNordPO";   // VFD outputs structure
      qUDT_commisioning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommisioningNord";
   END_VAR

   VAR_IN_OUT 
      iqUDT_ConveyorInterface : "UDT_ConveyorInterface";   // Conveyor interface structure
      iqUDT_VFDStatistics : "UDT_VfdStatistics";   // Satistics structure
      iqx_StartCommissioning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when Start auto-commissioning
   END_VAR

   VAR 
      sFB_TimerOnOffDelayCheck24V { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // MHS "TimerOnOffDelay" - to delay time for VFD 24V contactor
      sFB_TimerOnOffDelayCheck400V { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // MHS "TimerOnOffDelay" - to delay time for VFD 400V contactor
      sFB_TimerOnOffDelayVFDReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // MHS "TimerOnOffDelay" - to extend VFD reset
      sFB_TimerOnOffDelayVFDRunningFeedbackError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // MHS "TimerOnOffDelay" - to delay time for VFDRunningFeedback error
      sFB_VfdNORDCommissiong { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_VfdNORDCommissioning";   // FB to commissiong NORD drive
      sUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatus";   // Detailed VFD status overview
      sUDT_PNDevice { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PNDevice";   // PN device info structure
      sa_PNPortsStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..8] of Bool;   // TRUE when specific port has an error
      sp_VFDTelegram { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // Free telegram's HW_ID
      sv_VFDGeoStruct {InstructionName := 'GEOADDR'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : GEOADDR;   //  Geo structure indicate to telegram
      sR_TRIG_PNSlaveNotOnline {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for trigger Profinet slave not online statistics
      sR_TRIG_PNSlaveError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for trigger Profinet slave error statistics
      sR_TRIG_VFDInternalError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for trigger Internal VFD Error statistics
      sR_TRIG_Running {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for starting of the running signal
      sF_TRIG_RunFwd {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge for run forward signal
      sF_TRIG_RunRvs {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge for run reverse signal
      sr_RPMActual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Drive RPM feedback
      sr_RPMSetpoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Actual speed setpoint [rpm]
      sr_ReferenceFrequency { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Frequency of the reference RPM in [Hz]
      sdi_LastRampTimeUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Last cycle ramp down time
      sdi_LastRampTimeDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Last cycle ramp up time
      si_ActualRamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Actual ramp value
      si_ActualRampUpTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Actual ramp up time
      si_ActualRampDownTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Actual ramp down time
      si_HWAdress { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_ActualSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Actual speed in [mm/sec]
      si_Log2GeoReturn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Log2Geo function return
      si_Geo2LogReturn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Geo2Log function return
      sx_ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Commissioning: configuration error
      sx_PNDeviceHealthy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet device is online and error free
      sx_HardwareAvailable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Power and communication to drive are ok
      sx_VfdAvailable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Hardware of VFD is ok and no communication error with movikit
      sx_24vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 24VDC is healthy
      sx_400vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 400VAC is healthy
      sx_ErrorActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block has an error
      sx_EnableOperation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Enable operation signal
      sx_RunVFDReverse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start VFD backward
      sx_RunVFDForward { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start VFD forward
      sx_SpeedSetpointReached { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor is running at requested speed
      sx_VFDStopping { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // VFD Stopping
      sx_VFDNotReadyError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Temporary Error need to be implemented in the status
   END_VAR

   VAR CONSTANT 
      cr_MaximumValueSpeedWord : Real := 16384.0;   // Maximum value of speed actual value
      cr_MaximumValueRampWord : Real := 32767.0;   // Maximum value of ramp setpoint ( corresponds to 20Sec)
      cr_MaximumFrequency : Real := 16384.0;   // Maximum value of frequency setpoint (corresponds to P105 Maximum Frequency)
      cudi_DefaultRampDownTime : UDInt := 20000;   // VFD ramp down default time [ms]
      cudi_DefaultRampUpTime : UDInt := 20000;   // VFD ramp up default time [ms]
      ci_VFDArea : UInt := 1;   // Area ID of IO Profinet devices
      ci_SubmoduleHWType : UInt := 5;   // Submodule HW_type number
      ci_TelegramSlot : UInt := 0;   // PPO4 telegram slot
      ci_TelegramSubslot : UInt := 1;   // PPO4 telegram subslot
      ci_NumberOfProfinetPorts : Int := 2;   // Number of Profinet ports in device
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	25/01/2020  | 0.1       | S.Theocharis  | Initial version TIA 15.1
	28/04/2022  | 0.2       | K. Pokorski   | NORD Commissioning interface change
	09/05/2022  | 0.3       | M. Pluskota   | Reference speed changed to nominal speed for actual speed calculation
	12/05/2022  | 0.4       | M. Pluskota   | Ramp equation adjustet for nord drives
	04/06/2022  | 0.5       | M. Pluskota   | Aded a if statment to not exceed the max value of the ramp value
	                                        | Error decoding changed now the error is shown as ErrorCode.SubErrorCodee
	12/07/2022  | 0.6       | M. Pluskota   | Ramp equation bug fix 
	29/07/2022  | 0.7       | M. Piela      | Add hardware ok to the profinet checking
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	
	REGION 1 - Get Device Profinet information
	    
	    "FC_GetDevicePN"(is_PNDeviceName := #iUDT_VFDConfig.VFDPNDeviceName,
	                     ix_SimulationModeActive := #ix_SimulationModeActive,
	                     iqUDT_PND := #sUDT_PNDevice);
	    
	    
	    "FC_GetPNPortStatus"(ii_NumberOfPorts := #ci_NumberOfProfinetPorts,
	                         iUDT_DevicePNInfo := #sUDT_PNDevice,
	                         qa_PortFault => #sa_PNPortsStatus);
	    
	END_REGION
	
	REGION 2 - Reset errors
	    
	    IF #iqUDT_ConveyorInterface.InternalErrorReset OR (NOT #iqUDT_ConveyorInterface.HardwareOk AND #sUDT_Status.PNSlaveNotonline)   // Reser errors when Reset is given
	    THEN
	        
	        #sUDT_Status.PNSlaveNotonline := FALSE;
	        #sUDT_Status.PNSlaveError := FALSE;
	        #sUDT_Status.InternalError := FALSE;
	        #sUDT_Status.VFDRunningFeedbackError := FALSE;
	        #sUDT_Status.PNSlaveWarning := FALSE;
	        
	    END_IF;
	    
	    
	    // Create  extended pulse for VFD Reset
	    #sFB_TimerOnOffDelayVFDReset(iudi_OnDelayTime := 0,
	                                 iudi_OffDelayTime := 200,
	                                 ix_SignalToDelay := #iqUDT_ConveyorInterface.InternalErrorReset,
	                                 ix_Enable := TRUE);
	    
	END_REGION
	
	REGION 3 - Hardware checks
	    // Hardware will only be available after the delay, so the device has time for the initialisation
	    #sFB_TimerOnOffDelayCheck24V(iudi_OnDelayTime := 2000,
	                                 iudi_OffDelayTime := 0,
	                                 ix_SignalToDelay := #ix_24vOk
	    );
	    
	    #sx_24vOk := #sFB_TimerOnOffDelayCheck24V.qx_DelayedSignal;
	    
	    #sFB_TimerOnOffDelayCheck400V(iudi_OnDelayTime := 2000,
	                                  ix_SignalToDelay := #ix_400vOk);
	    
	    #sx_400vOk := #sFB_TimerOnOffDelayCheck400V.qx_DelayedSignal;
	    
	    // Check if PN device is online
	    IF NOT "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.Exist
	        AND NOT #ix_SimulationModeActive
	        AND #sx_24vOk
	        AND #iqUDT_ConveyorInterface.HardwareOk
	    THEN
	        #sUDT_Status.PNSlaveNotonline := TRUE;
	        
	    END_IF;
	    
	    // Check if PN ports are healthy 
	    IF #sa_PNPortsStatus[1] XOR #sa_PNPortsStatus[2] THEN
	        #sUDT_Status.PNSlaveWarning := TRUE;
	    END_IF;
	    
	    
	    // Check if PN device has an error
	    IF "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.Error
	        AND NOT #ix_SimulationModeActive
	        AND #sx_24vOk
	        AND NOT #sUDT_Status.PNSlaveWarning
	        AND #iqUDT_ConveyorInterface.HardwareOk
	    THEN
	        #sUDT_Status.PNSlaveError := TRUE;
	    END_IF;
	    
	    // Set bit when PN device is healthy (online and no error)
	    #sx_PNDeviceHealthy := NOT #sUDT_Status.PNSlaveNotonline
	    AND NOT #sUDT_Status.PNSlaveError
	    AND #sUDT_PNDevice.PNDeviceFound
	    AND #sx_24vOk;
	    
	    // Set hardware available bit when all conditions are met
	    #sx_HardwareAvailable := (#sx_24vOk
	    AND #sx_PNDeviceHealthy)
	    OR #ix_SimulationModeActive;
	    
	    
	    // VFD is ready for operation if hardware ok 
	    #sx_VfdAvailable := #sx_HardwareAvailable;
	    
	    //VFD not ready error . Temporary 
	    #sx_VFDNotReadyError := #sx_HardwareAvailable
	    AND NOT #iUDT_VFDInputs.ZSW.ReadyToStart
	    AND #iUDT_VFDInputs.ZSW.EmergencyStop
	    OR NOT #iUDT_VFDInputs.ZSW.BusControlActive;
	    
	    
	    
	    
	END_REGION
	
	REGION 4 - Check errors and warnings 
	    
	    // Check if the VFD has a warning
	    #sUDT_Status.InternalWarning := #iUDT_VFDInputs.ZSW.WarningActive;
	    
	    // Copy warning code to status DB when warning active
	    IF #sUDT_Status.InternalWarning
	    THEN
	        
	        #sUDT_Status.ErrorCode := #iUDT_VFDInputs.FaultCode / 10; // AST check the value of warning
	        #sUDT_Status.SubErrorCode := #iUDT_VFDInputs.FaultCode MOD 10;
	        
	    END_IF;
	    
	    // Check if the VFD has an error
	    #sUDT_Status.InternalError := #iUDT_VFDInputs.ZSW.Fault; // AND NOT #sx_StartMeasuring;
	    
	    // Copy error code to status DB when error active
	    IF #sUDT_Status.InternalError
	    THEN
	        
	        #sUDT_Status.ErrorCode := #iUDT_VFDInputs.FaultCode / 10; // AST check the value of warning
	        #sUDT_Status.SubErrorCode := #iUDT_VFDInputs.FaultCode MOD 10;
	        
	    END_IF;
	    
	    // Reset error code if warning and error not available    
	    IF (NOT #sUDT_Status.InternalWarning
	        AND NOT #sUDT_Status.InternalError)
	    THEN
	        
	        #sUDT_Status.ErrorCode := 0;
	        #sUDT_Status.SubErrorCode := 0;
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Check if configuration is ok for commissioning purposes
	    
	    IF #iUDT_VFDConfig.WheelEndPerimeter > 0.0                                         // If perimeter of wheel at the end of gear is greater than 0 
	        AND #iUDT_VFDConfig.GearRatio > 0.0                                            // and gear ratio is greater than 0
	        AND #iUDT_VFDConfig.ReferenceRPM > 0.0                                         // and maximum speed is greater than 0
	        AND #iUDT_VFDConfig.VFDRampUpTime > 0                                          // and ramp up time is greater than 0
	        AND #iUDT_VFDConfig.VFDRampDownTime > 0                                        // and ramp down time is greater than zero
	        AND #iUDT_VFDConfig.VFDStartupTime > 0.0                                       // and startup time is greater then zero
	        //  AND MOTOR NOMINAL SPEED IS >0  the reference speed is invalid for NORD drives    
	        AND #cudi_DefaultRampUpTime > #iUDT_VFDConfig.VFDRampUpTime                     // and ramp up time is not greater than default ramp up time
	        AND #cudi_DefaultRampDownTime > #iUDT_VFDConfig.VFDRampDownTime                 // and ramp down time is not greater than default ramp down time
	        // need to know if the FI receives a percentage of a default ramp or value in ms , depending to that the configuration validation code will change
	        
	        AND (#sUDT_PNDevice.PNDeviceFound                                              // and device not found in PN structure 
	        OR #ix_SimulationModeActive)                                                    // or simulation mode is active
	    THEN
	        #sx_ConfigurationError := FALSE;                                                // Reset configuration error
	    ELSE
	        #sx_ConfigurationError := TRUE;                                                 // Set configuration error
	    END_IF;
	    #qUDT_commisioning.CommissionError := #sx_ConfigurationError;
	    
	END_REGION
	
	REGION 6 - Speed handling  
	    
	    //Calculate actual speed value in rpm 
	    // #sr_RPMActual := ((INT_TO_REAL(#i_UDT_VFDInputs.ActualSpeed) / #cr_MaximumValueSpeedWord) * INT_TO_REAL(#i_UDT_MotorData.NominalSpeed));
	    
	    //#sr_RPMActual := ((INT_TO_REAL(#i_UDT_VFDInputs.ActualSpeed) / #cr_MaximumValueSpeedWord) * (#i_UDT_MotorData.NominalSpeed));
	    #sr_RPMActual := ((INT_TO_REAL(#iUDT_VFDInputs.ActualSpeed) / #cr_MaximumFrequency) * (#iUDT_VFDConfig.ReferenceRPM));
	    // Calculate actual speed in mm/s                                                                                                         
	    #si_ActualSpeed := REAL_TO_INT((#sr_RPMActual / #iUDT_VFDConfig.GearRatio) * ((#iUDT_VFDConfig.WheelEndPerimeter) / 60.0));
	    
	    
	    //change the i_UDT_VFDInput.Actualspeed to RPM
	    
	    // Reversal actual speed
	    IF #iUDT_VFDConfig.DirectionReversal THEN
	        
	        #si_ActualSpeed := #si_ActualSpeed * -1;
	        
	    END_IF;
	    
	    // Calculate actual speed setpoint in rpm
	    #sr_RPMSetpoint := ((DINT_TO_REAL(INT_TO_DINT(#iqUDT_ConveyorInterface.SpeedSetpoint) * 60)) / #iUDT_VFDConfig.WheelEndPerimeter) * #iUDT_VFDConfig.GearRatio;
	    
	    // Check if speed setpoint is reached                                 
	    #sx_SpeedSetpointReached := (ABS(#si_ActualSpeed) >= (#iqUDT_ConveyorInterface.SpeedSetpoint - #iUDT_VFDConfig.SpeedSetpointWindow))
	    AND (ABS(#si_ActualSpeed) <= (#iqUDT_ConveyorInterface.SpeedSetpoint + #iUDT_VFDConfig.SpeedSetpointWindow));
	    
	    
	END_REGION
	
	REGION 7 - Prepare output data VFD
	    
	    REGION 7.1 - Set speed setpoint in forward and reverse directory 
	        
	        // If motor stopped and Run forward is requested and interlock forward is active, the speed setpoint is loaded to run forward.
	        //  IF (#i_UDT_VFDInputs.ActualSpeed = 0) AND #iq_UDT_ConveyorInterface.RunFwd AND #i_UDT_VFDConfig.InterlockFwd
	        IF #iqUDT_ConveyorInterface.RunFwd AND #iUDT_VFDConfig.InterlockFwd
	        THEN
	            #sx_RunVFDForward := TRUE;
	            #sx_RunVFDReverse := FALSE;
	        END_IF;
	        
	        // If motor stopped and Run reverse is requested and interlock reverse is active, the speed setpoint is loaded to run reverse.
	        IF (#iUDT_VFDInputs.ActualSpeed = 0) AND #iqUDT_ConveyorInterface.RunRvs AND #iUDT_VFDConfig.InterlockRvs
	        THEN
	            #sx_RunVFDReverse := TRUE;
	            #sx_RunVFDForward := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 7.2 - Stopping
	        
	        // Create trigger when direction signal falling
	        #sF_TRIG_RunFwd(CLK := #iqUDT_ConveyorInterface.RunFwd);
	        #sF_TRIG_RunRvs(CLK := #iqUDT_ConveyorInterface.RunRvs);
	        
	        // When no run signal is given the VFD should stop
	        IF NOT #iqUDT_ConveyorInterface.RunRvs AND NOT #iqUDT_ConveyorInterface.RunFwd
	            OR (#iqUDT_ConveyorInterface.RunRvs AND #iqUDT_ConveyorInterface.RunFwd)
	            OR #sF_TRIG_RunRvs.Q
	            OR #sF_TRIG_RunFwd.Q
	            
	        THEN
	            #sx_RunVFDReverse := FALSE;
	            #sx_RunVFDForward := FALSE;
	        END_IF;
	        
	        IF NOT #sx_RunVFDReverse AND NOT #sx_RunVFDForward AND (#iUDT_VFDInputs.ActualSpeed <> 0)
	        THEN
	            #sx_VFDStopping := TRUE;
	        ELSE
	            #sx_VFDStopping := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 7.3 - Check for enable operation signal
	        
	        #sx_EnableOperation := #sx_VfdAvailable
	        AND #sx_400vOk
	        AND NOT #sx_ConfigurationError
	        AND (#sx_RunVFDForward OR #sx_RunVFDReverse); // add communication error
	        
	    END_REGION
	    
	    REGION 7.4 - Write acceleration and deceleration value to drive
	        
	        //Detect is VFD is ramping up 
	        IF ABS(#sr_RPMSetpoint) > ABS(#sr_RPMActual)
	            AND NOT #sx_SpeedSetpointReached
	            AND #iUDT_VFDInputs.ZSW.OperationEnabled
	            AND (#sx_RunVFDForward OR #sx_RunVFDReverse)
	        THEN
	            // Calculate the ramp up time if the vfd configuration is changed durning process or the vfd starts from speed 0 
	            IF #sdi_LastRampTimeUp <> #iUDT_VFDConfig.VFDRampUpTime THEN
	                #si_ActualRamp := REAL_TO_UINT(UDINT_TO_REAL(#iUDT_VFDConfig.VFDRampUpTime) / UDINT_TO_REAL(#cudi_DefaultRampUpTime) * #cr_MaximumValueRampWord / (#sr_RPMSetpoint / #iUDT_VFDConfig.ReferenceRPM));
	                #si_ActualRampUpTime := #si_ActualRamp;
	            ELSE
	                #si_ActualRamp := #si_ActualRampUpTime;
	            END_IF;
	            #sdi_LastRampTimeUp := #iUDT_VFDConfig.VFDRampUpTime;
	        ELSE
	            // Calculate the ramp down time if the actual speed is greater than 0 and the configuration has changed durning process
	            // or the VFD perform the first deceleration
	            
	            IF #si_ActualSpeed <> 0 THEN
	                IF #sdi_LastRampTimeDown <> #iUDT_VFDConfig.VFDRampDownTime
	                THEN
	                    #si_ActualRamp := REAL_TO_UINT(UDINT_TO_REAL(#iUDT_VFDConfig.VFDRampDownTime) / UDINT_TO_REAL(#cudi_DefaultRampDownTime) * #cr_MaximumValueRampWord / (#sr_RPMSetpoint / #iUDT_VFDConfig.ReferenceRPM));
	                    #si_ActualRampDownTime := #si_ActualRamp;
	                    
	                ELSE
	                    #si_ActualRamp := #si_ActualRampDownTime;
	                END_IF;
	                #sdi_LastRampTimeDown := #iUDT_VFDConfig.VFDRampDownTime;
	            ELSE
	                #sdi_LastRampTimeDown := 0;
	                #sdi_LastRampTimeUp := 0;
	            END_IF;
	            
	        END_IF;
	        
	        // If the ramp value exceeds the maximum value, then the maximum value is sent to the VFD
	        IF UINT_TO_REAL(#si_ActualRamp) > #cr_MaximumValueRampWord
	        THEN
	            #qUDT_VFDOutputs.RampTimeSetPoint := REAL_TO_INT(#cr_MaximumValueRampWord);
	        ELSE
	            #qUDT_VFDOutputs.RampTimeSetPoint := REAL_TO_INT(UINT_TO_REAL(#si_ActualRamp));
	        END_IF;
	        
	        
	    END_REGION
	END_REGION
	
	REGION 8 - Auto Commmissioning 
	    
	    REGION 8.1 Initialize 
	        IF #iqx_StartCommissioning THEN
	            
	            //Caclulate theoretical reference Hz. Necessary for NORD drives cause the setpoint is given at Hz
	            //Variation of motor slip from 50Hz to reference Hz is not taken into account. That means there will always be a variantion between Setpoint and actual speed
	            #sr_ReferenceFrequency := (#iUDT_VFDConfig.ReferenceRPM / 1500) * 50; //1500 for 4 pole motor 
	            
	            // Get hardware adres of "SK-TU4-PNS~Head" submodule
	            #si_Log2GeoReturn := LOG2GEO(LADDR := "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.HW_ID, GEOADDR := #sv_VFDGeoStruct);       // "LOG2GEO" to get profinet network number
	            #sv_VFDGeoStruct.AREA := #ci_VFDArea;                                                                                                                                                                               // Set IO Profinet devices area ID
	            #sv_VFDGeoStruct.HWTYPE := #ci_SubmoduleHWType;                                                                                                                                                                     // Set submodule HW_type number
	            #sv_VFDGeoStruct.STATION := INT_TO_UINT(#sUDT_PNDevice.PNDeviceNumber);                                                                                                                                            // Set device's profinet number
	            #sv_VFDGeoStruct.SLOT := #ci_TelegramSlot;                                                                                                                                                                          // Set free telegram slot
	            #sv_VFDGeoStruct.SUBSLOT := #ci_TelegramSubslot;                                                                                                                                                                    // Set free telegram subslot
	            
	            #si_Geo2LogReturn := GEO2LOG(GEOADDR := #sv_VFDGeoStruct, LADDR => #sp_VFDTelegram);                                                                                                                              // "GEO2LOG" to get free telegram's HW_ID
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 8.2 Run - auto commissioning 
	        
	        #sFB_VfdNORDCommissiong(ix_VFDReadyToRun := #sx_400vOk AND #iUDT_VFDInputs.ZSW.EmergencyStop AND NOT #iUDT_VFDInputs.ZSW.Fault,
	                                qx_24VCommissioningDone => #sFB_VfdNORDCommissiong.qx_24VCommissioningDone,
	                                iqx_Enable := #iqx_StartCommissioning,
	                                ir_ReferenceFrequency := #sr_ReferenceFrequency,
	                                ihw_HardwareID := #sp_VFDTelegram,
	                                iudt_MotorData := #iUDT_MotorData,
	                                qi_HWAdress => #qUDT_commisioning.HWAdress,
	                                qx_Busy => #sFB_VfdNORDCommissiong.qx_Busy,
	                                qx_Done => #sFB_VfdNORDCommissiong.qx_Done,
	                                qx_Error => #sFB_VfdNORDCommissiong.qx_Error);
	        
	    END_REGION
	    
	END_REGION
	
	REGION 9 - Write outputs to VFD  
	    
	    REGION 9.1 - Write control word 1
	        
	        #qUDT_VFDOutputs.STW.ReadyForOperation := #sx_RunVFDReverse OR #sx_RunVFDForward;
	        #qUDT_VFDOutputs.STW.DisableVoltage := TRUE;
	        #qUDT_VFDOutputs.STW.EmergencyStop := #ix_QuickStopDisable;
	        #qUDT_VFDOutputs.STW.EnableOperation := TRUE;
	        #qUDT_VFDOutputs.STW.EnablePulsles := TRUE;
	        #qUDT_VFDOutputs.STW.EnableRamp := TRUE;
	        #qUDT_VFDOutputs.STW.EnableSetpoint := TRUE;
	        #qUDT_VFDOutputs.STW.Acknowledge := #sFB_TimerOnOffDelayVFDReset.qx_DelayedSignal;
	        #qUDT_VFDOutputs.STW."StartFunction408.11" := FALSE;
	        #qUDT_VFDOutputs.STW."StartFunction408.12" := FALSE;
	        #qUDT_VFDOutputs.STW.ControlDataValid := TRUE;
	        #qUDT_VFDOutputs.STW.RotationRightOn := TRUE; //direction reversal via the speed setpoint
	        #qUDT_VFDOutputs.STW.RotationLeftOn := FALSE;
	        #qUDT_VFDOutputs.STW.Reserved := FALSE;
	        #qUDT_VFDOutputs.STW.ParameterSetBit0 := FALSE; //Parameter set 1
	        #qUDT_VFDOutputs.STW.ParameterSetBit1 := FALSE; //Parameter set 1
	        
	        IF (NOT #sx_VfdAvailable OR NOT #sx_400vOk) //AND NOT #sx_StartMeasuring
	        THEN
	            #qUDT_VFDOutputs.STW.ReadyForOperation := FALSE;
	            #qUDT_VFDOutputs.STW.EmergencyStop := FALSE;
	            #qUDT_VFDOutputs.STW.EnableSetpoint := FALSE;
	            #qUDT_VFDOutputs.STW."StartFunction408.11" := FALSE;
	            #qUDT_VFDOutputs.STW."StartFunction408.12" := FALSE;
	        END_IF;
	    END_REGION
	    
	    REGION 9.2 - Write speed setpoint to drive
	        
	        // Calculate normalized speed setpoint
	        #qUDT_VFDOutputs.FrequencySetPoint := REAL_TO_INT((#sr_RPMSetpoint / #iUDT_VFDConfig.ReferenceRPM) * #cr_MaximumFrequency);
	        
	        IF #qUDT_VFDOutputs.FrequencySetPoint > #cr_MaximumFrequency
	        THEN
	            #qUDT_VFDOutputs.FrequencySetPoint := REAL_TO_INT(#cr_MaximumFrequency);
	        END_IF;
	        
	        // The conveyor stopped and may now run in reverse direction
	        IF (#sx_RunVFDReverse AND NOT #iUDT_VFDConfig.DirectionReversal)
	            OR (#sx_RunVFDForward AND #iUDT_VFDConfig.DirectionReversal)
	        THEN
	            #qUDT_VFDOutputs.FrequencySetPoint := #qUDT_VFDOutputs.FrequencySetPoint * -1;
	        END_IF;
	        
	        // Clear speed setpoint when no run request or above direction request or is configuration error
	        IF (NOT #sx_RunVFDForward AND NOT #sx_RunVFDReverse)
	            OR #sx_ConfigurationError
	        THEN
	            #qUDT_VFDOutputs.FrequencySetPoint := 0;
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 10 - Check if motor is running
	    
	    //The motor should start running after specific time. If not the VFDRunningFeedback error occured
	    #sFB_TimerOnOffDelayVFDRunningFeedbackError(iudi_OnDelayTime := #iUDT_VFDConfig.VFDStartupTime,
	                                                ix_SignalToDelay := #sx_EnableOperation AND NOT (#si_ActualSpeed <> 0));
	    
	    IF #sFB_TimerOnOffDelayVFDRunningFeedbackError.qx_DelayedSignal THEN
	        
	        #sUDT_Status.VFDRunningFeedbackError := TRUE;
	        
	    END_IF;
	    
	    
	    
	END_REGION
	
	REGION 11 - Copy signals to interface DB and to status output UDT
	    
	    // Create internal error status
	    #sx_ErrorActive := #sUDT_Status.PNSlaveNotonline
	    OR #sUDT_Status.VFDRunningFeedbackError
	    OR #sUDT_Status.PNSlaveError //Commented out BY AST TO allow run in ring topology v3.12
	    OR #sUDT_Status.InternalError;
	    
	    // Write interface bits - AST Check thoses statuses
	    #iqUDT_ConveyorInterface.VFDRunning := #sx_VfdAvailable AND (#iqUDT_ConveyorInterface.ActualSpeed <> 0 OR #qUDT_VFDOutputs.STW.ReadyForOperation);   // Write true on output Conveyor interface structure if VFD is in operation and motor is turning 
	    #iqUDT_ConveyorInterface.VFDatSpeed := #sx_SpeedSetpointReached AND #sx_VfdAvailable AND #si_ActualSpeed <> 0;                                                                                                  // Copy setpoint speed reached state from static to the output conveyor interface structure
	    #iqUDT_ConveyorInterface.InternalWarningVFD := #iUDT_VFDInputs.ZSW.WarningActive;                                                                                                      // Set the internal VFD warning bit if any warning is active
	    #iqUDT_ConveyorInterface.InternalErrorVFD := #sx_ErrorActive;                                                                                                                           // Set the internal VFD error bit if any fault is active 
	    #iqUDT_ConveyorInterface.ActualSpeed := #si_ActualSpeed;                                                                                                                                // Copy the calculated value to the output
	    #iqUDT_ConveyorInterface.ConfigurationError := #iqUDT_ConveyorInterface.ConfigurationError OR #sx_ConfigurationError;
	    
	    // Copy error status to output
	    #qUDT_HMIStatus := #sUDT_Status;
	    
	END_REGION
	
	REGION 12 - Statistic
	    // Create trigger on error and create statistics for profinet slave not online
	    #sR_TRIG_PNSlaveNotOnline(CLK := #sUDT_Status.PNSlaveNotonline);                                        // Detect the rising edge of the error
	    
	    IF #iqUDT_ConveyorInterface.ResetStatistics OR #sUDT_Status.PNSlaveNotonline
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #sUDT_Status.PNSlaveNotonline,
	                        ix_RTrigActivate := #sR_TRIG_PNSlaveNotOnline.Q,
	                        iqUDT_Statistics := #iqUDT_VFDStatistics.PNSlaveNotOnline);
	    END_IF;
	    
	    // Create trigger on error and create statistics for profinet slave error
	    #sR_TRIG_PNSlaveError(CLK := #sUDT_Status.PNSlaveError);                                        // Detect the rising edge of the error
	    
	    IF #iqUDT_ConveyorInterface.ResetStatistics OR #sUDT_Status.PNSlaveError
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #sUDT_Status.PNSlaveError,
	                        ix_RTrigActivate := #sR_TRIG_PNSlaveError.Q,
	                        iqUDT_Statistics := #iqUDT_VFDStatistics.PNSlaveError);
	    END_IF;
	    
	    // Create trigger on error and create statistics for internal VFD Error
	    #sR_TRIG_VFDInternalError(CLK := #sUDT_Status.InternalError);                                        // Detect the rising edge of the error
	    
	    IF #iqUDT_ConveyorInterface.ResetStatistics OR #sUDT_Status.InternalError
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #sUDT_Status.InternalError,
	                        ix_RTrigActivate := #sR_TRIG_VFDInternalError.Q,
	                        iqUDT_Statistics := #iqUDT_VFDStatistics.VFDInternalError);
	    END_IF;
	    
	    // Create trigger on running signal and create statistics for running status
	    #sR_TRIG_Running(CLK := #iqUDT_ConveyorInterface.VFDRunning);                                        // Detect the rising edge of the signal
	    
	    IF #iqUDT_ConveyorInterface.ResetStatistics OR #iqUDT_ConveyorInterface.VFDRunning
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #iqUDT_ConveyorInterface.VFDRunning,
	                        ix_RTrigActivate := #sR_TRIG_Running.Q,
	                        iqUDT_Statistics := #iqUDT_VFDStatistics.Running);
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_SystemStatistics"
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHS
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 29
// END_ATTRIBUTES
   VAR_INPUT 
      ix_HMIStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // HMI stop button one shot signal
      ix_FieldStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Field stop button one shot signal
      ix_BuildingEStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE if bulding emergency stop button is active
      ix_MCPEStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE if MCP emergency stop button is active
      ix_RemotePanelEStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE if Remote Panel emergency stop button is active
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
      iqUDT_Statistics : "UDT_SystemStatistics";   // Statistics structure
   END_VAR

   VAR 
      sR_Trig_HMIStop {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rise trigger when a HMI stop is active
      sR_Trig_FieldStop {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rise trigger when a field stop is active
      sR_Trig_BuildingEStop {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rise trigger when a building emergency stop is active
      sR_Trig_MCPEStop {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rise trigger when a MCP emergency stop is active
      sR_Trig_RemotePanelEStop {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rise trigger when a remote panel emergency stop is active
      sR_TRIG_AutomaticOn {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rise trigger when a automatic mode  is active
      sR_TRIG_DataReset {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rise trigger when data reset command is received
      sR_TRIG_Error {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rise trigger when  Error occured
      sF_TRIG_Error {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Fall trigger when  Error is cleared
      sx_HMIStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // HMI stop signal
      sx_FieldStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Field stop signal
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	14/01/2020  | 3.0       | S. Nikodem    | first release MHS TIA 15.1
	22/08/2020  | 3.1       | S. Theocharis | Updated for UPS EMA HMI
	03/08/2021  | 3.2       | M. Roijen     | Bug fix System in error iq_UDT_Statistics
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – Triggers
	    
	    // Rise trigger when a HMI stop is active
	    #sR_Trig_HMIStop(CLK := #sx_HMIStop);
	    
	    // Rise trigger when a field stop is active
	    #sR_Trig_FieldStop(CLK := #sx_FieldStop);
	    
	    // Rise trigger when a building emergency stop is active trigger 
	    #sR_Trig_BuildingEStop(CLK := #ix_BuildingEStop);
	    
	    // Rise trigger when a MCP emergency stop is active
	    #sR_Trig_MCPEStop(CLK := #ix_MCPEStop);
	    
	    // Rise trigger when a remote panel emergency stop is active 
	    #sR_Trig_RemotePanelEStop(CLK := #ix_RemotePanelEStop);
	    
	    // Rise trigger when a Field stop is active 
	    #sR_TRIG_AutomaticOn(CLK := #iqUDT_EquipmentControl.Command.AutomaticOn);
	    
	    // Fall trigger when error is cleared (UPS EMA Addition)
	    #sF_TRIG_Error(CLK := #iqUDT_EquipmentControl.Report.Error);
	    
	    //Rise trigger when data reset command is received (UPS EMA Addition)
	    #sR_TRIG_DataReset(CLK := #iqUDT_EquipmentControl.Command.ResetData);
	    
	    //Rise trigger on error
	    #sR_TRIG_Error(CLK := #iqUDT_EquipmentControl.Report.Error);
	    
	END_REGION
	
	REGION 2 – Sustain input signals
	    
	    // Set HMI stop when input signal and automatic mode are active
	    IF #ix_HMIStop AND #iqUDT_EquipmentControl.Command.AutomaticOn THEN
	        
	        #sx_HMIStop := TRUE;
	        
	    END_IF;
	    
	    // Set Field stop when input signal and automatic mode are active
	    IF #ix_FieldStop AND #iqUDT_EquipmentControl.Command.AutomaticOn THEN
	        
	        #sx_FieldStop := TRUE;
	        
	    END_IF;
	    
	    /// Reset when automatic mode is active 
	    IF #sR_TRIG_AutomaticOn.Q THEN
	        
	        #sx_HMIStop := FALSE;
	        #sx_FieldStop := FALSE;
	        
	    END_IF;
	END_REGION
	
	REGION 3 – Statistics
	    
	    // HMI stop signal statistics
	    IF #sx_HMIStop
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sx_HMIStop,
	                        ix_RTrigActivate := #sR_Trig_HMIStop.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.HMI_Stop);
	    END_IF;
	    
	    // Field stop signal statistics
	    IF #sx_FieldStop
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sx_FieldStop,
	                        ix_RTrigActivate := #sR_Trig_FieldStop.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics."Field_Stop");
	    END_IF;
	    
	    // Building emergency stop statistics
	    IF #ix_BuildingEStop
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #ix_BuildingEStop,
	                        ix_RTrigActivate := #sR_Trig_BuildingEStop.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics."Building_EStop");
	    END_IF;
	    
	    
	    // MCP emergency stop statistics
	    IF #ix_MCPEStop
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #ix_MCPEStop,
	                        ix_RTrigActivate := #sR_Trig_MCPEStop.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics."MCP_EStop");
	        
	    END_IF;
	    
	    // Remote panel emergency stop statistics
	    IF #ix_RemotePanelEStop
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #ix_RemotePanelEStop,
	                        ix_RTrigActivate := #sR_Trig_RemotePanelEStop.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.RemotePanel_EStop);
	        
	    END_IF;
	    
	    
	    //System in error  
	    IF #iqUDT_EquipmentControl.Report.Error
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #iqUDT_EquipmentControl.Report.Error,
	                        ix_RTrigActivate := #sR_TRIG_Error.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.Error);
	        
	    END_IF;
	    
	    
	    
	    //Number of times start (UPS EMA addition)
	    IF #sR_TRIG_AutomaticOn.Q
	    THEN
	        #iqUDT_Statistics.StartNumberOfTimes += 1;
	    ELSIF #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        #iqUDT_Statistics.StartNumberOfTimes := 0;
	    END_IF;
	    
	    //Number of times Reset (UPS EMA addition)
	    IF #sF_TRIG_Error.Q
	    THEN
	        #iqUDT_Statistics.ResetNumberOfTimes += 1;
	    ELSIF #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        #iqUDT_Statistics.ResetNumberOfTimes := 0;
	    END_IF;
	    
	    //Number of times Data Reset (UPS EMA addition)
	    IF #sR_TRIG_DataReset.Q
	    THEN
	        #iqUDT_Statistics.DataResetNumberOfTimes += 1;
	    ELSIF #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        #iqUDT_Statistics.DataResetNumberOfTimes := 0;
	    END_IF;
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_TCPIPReceive"
TITLE = FB_TCPIPReceive
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : Communication
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 30
// END_ATTRIBUTES
//Function block to receive data from TCPIP.
// END_ATTRIBUTES
//Function block to receive data from TCPIP.
   VAR_INPUT 
      iUDT_Connection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_Connection";   // Connection parameters
      ix_EnableReceive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Enable receive
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective error output
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective warning output
   END_VAR

   VAR_IN_OUT 
      iqUDT_FifoHeader : "UDT_FifoHeader";   // Fifo header
      iqUDT_Statistics : "UDT_TCPIPReceiveStatistics";   // Statistic structure
      iqa_FifoData : Array[*] of "UDT_Message";   // Fifo data
   END_VAR

   VAR 
      sFB_TRCV {InstructionName := 'TRCV'; LibVersion := '4.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TRCV;   // Siemens "TRCV" block - to receive the data from TCPIP socket
      sa_TRCV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // TRCV block interface structure
         Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    TRCV - Enable
         NDR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    TRCV - New data available
         Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    TRCV - Busy
         Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    TRCV - Error
         Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   //    TRCV - Status
         RcvLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   //    TRCV - Received length
         Data { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..999] of Char;   //    TRCV - Data
      END_STRUCT;
      sUDT_MsgArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Message";   // Message character array
      sUDT_MsgPartArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Message";   // Part of the message character array
      sa_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         ErrorCode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Error code structure
            TRCV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Siemens TRCV error code - Check documentation
         END_STRUCT;
         FIFORcvStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";   // Receive FIFO status structure
         FIFORcvError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // Receive FIFO error
         FIFORcvWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // Receive  FIFO warning
         ReceiveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRCV block operation error - Check TRCVStatus
      END_STRUCT;
      sdi_RcvMsgCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Total received messages counter
      si_RcvMsgOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Received message offset
      si_RcvMsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Received message length
      si_NrOfRcvMsg { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Number of received messages in one frame
      si_RcvMsgPartLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Length of the part of received message
      si_LoopCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Loop counter
      si_MaxMsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum message length
      sx_RcvMsgPart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Received part of the message
      sx_InvalidTermination { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Termination sign missing
   END_VAR

   VAR CONSTANT 
      cc_CRLF_R : Char := '$R';   // First termination sign
      cc_CRLF_L : Char := '$L';   // Last termination sign
      cc_NULL : Char := '$00';   // NULL sign
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	17/06/2019  | 0.3       | A.Nowak       | Replace 2nd level subregions with comments (5.3)
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	22/08/2019  | 2.1       | K.Pokorski    | Comments adjusted
	12/09/2019  | 2.2       | A.Nowak       | Delete buffer size variable 
	20/09/2019  | 2.3       | J.Krawczuk    | Replacing UDT_HeartbeatStatus structure to internal structure  
	01/10/2019  | 2.4       | A.Nowak       | Implementation of the new FIFO block
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	23/03/2021  | 3.1       | L.Klar        | Static variables data types changed form uint to int
	14/08/2021  | 3.2       | S. Deulkar    | In region 5.3, conveted variable to ULINT because it was giving warning
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – Update FIFO header status bits
	    
	    // Mode 'S' - FIFO register status update
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #sa_Status.FIFORcvStatus,
	              qx_Error => #sa_Status.FIFORcvError,
	              qx_Warning => #sa_Status.FIFORcvWarning,
	              iqv_Data := #sUDT_MsgArray,
	              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	              iqv_DataBuffer := #iqa_FifoData);
	    
	    
	END_REGION
	
	REGION 2 – Maximum number of message arrays elements
	    
	    #si_MaxMsgLen := "FC_GetNrOfArrayEl"(iv_Array := #sUDT_MsgArray.Character);
	    
	END_REGION
	
	REGION 3 – Receive enable
	    
	    // Allow receiving if the connection is established and there are no fifo errors
	    #sa_TRCV.Enable :=
	    #ix_EnableReceive
	    AND NOT #sa_Status.FIFORcvError;
	    
	END_REGION
	
	REGION 4 – Receive data
	    
	    // Data received in an ADHOC mode - data available immediately
	    #sFB_TRCV(EN_R := #sa_TRCV.Enable,
	              ID := #iUDT_Connection.ID,
	              LEN := 0,
	              ADHOC := TRUE,
	              NDR => #sa_TRCV.NDR,
	              BUSY => #sa_TRCV.Busy,
	              ERROR => #sa_TRCV.Error,
	              STATUS => #sa_TRCV.Status,
	              RCVD_LEN => #sa_TRCV.RcvLen,
	              DATA := #sa_TRCV.Data);
	    
	END_REGION
	
	IF #sa_TRCV.RcvLen > 1000 THEN
	    #sa_TRCV.RcvLen := 1000;
	END_IF;
	
	REGION 5 – Received data handling
	    
	    // Receiving data was successful
	    IF (#sa_TRCV.NDR                    // New data received without error
	        AND NOT #sa_TRCV.Busy           // Job not yet started or already completed
	        AND NOT #sa_TRCV.Error          // No errors during receiving messages
	        AND #sa_TRCV.RcvLen > 0)        // Length greater than zero
	    THEN
	        
	        REGION 5.1 – Initialization
	            
	            #si_RcvMsgLen := 0;
	            #si_RcvMsgOffset := 0;
	            #si_NrOfRcvMsg := 0;
	            
	        END_REGION
	        
	        REGION 5.2 – Received part of the message
	            
	            // Move part of the messages to a buffer if available
	            IF (#sx_RcvMsgPart)                             // Message part available
	            THEN
	                
	                #sUDT_MsgArray := #sUDT_MsgPartArray;
	                #sx_RcvMsgPart := FALSE;
	                
	            END_IF;
	            
	        END_REGION
	        
	        REGION 5.3 – Message handling
	            
	            FOR #si_LoopCounter := 0 TO UDINT_TO_INT(#sa_TRCV.RcvLen) - 1 DO
	                
	                // Message length validation
	                IF (#si_RcvMsgLen + #si_RcvMsgPartLen < #si_MaxMsgLen)
	                THEN
	                    
	                    // Termination sign found
	                    IF (#sa_TRCV.Data[#si_LoopCounter] = #cc_CRLF_L)
	                    THEN
	                        
	                        // Move received message to the message array
	                        MOVE_BLK(IN := #sa_TRCV.Data[#si_RcvMsgOffset],
	                                 COUNT := INT_TO_ULINT(#si_RcvMsgLen),
	                                 OUT => #sUDT_MsgArray.Character[#si_RcvMsgPartLen]);
	                        
	                        // Clear NOT used message array characters
	                        FILL_BLK(IN := #cc_NULL,
	                                 COUNT := INT_TO_ULINT(#si_MaxMsgLen - #si_RcvMsgLen + #si_RcvMsgPartLen),
	                                 OUT => #sUDT_MsgArray.Character[#si_RcvMsgLen + #si_RcvMsgPartLen]);
	                        
	                        // Check and clear termination sign                                                       
	                        IF (#si_RcvMsgLen + #si_RcvMsgPartLen - 1) >= 0 AND (#si_RcvMsgLen + #si_RcvMsgPartLen - 1) < #si_MaxMsgLen THEN
	                            IF (#sUDT_MsgArray.Character[#si_RcvMsgLen + #si_RcvMsgPartLen - 1] = #cc_CRLF_R)        // Character is a termination sign
	                            THEN
	                                
	                                #sUDT_MsgArray.Character[#si_RcvMsgLen + #si_RcvMsgPartLen - 1] := #cc_NULL;
	                                
	                                // Termination sign invalid - error generated, statistics increased    
	                            ELSE
	                                
	                                #sx_InvalidTermination := TRUE;
	                                #iqUDT_Statistics.InvalidMsg += 1;
	                                
	                            END_IF;
	                        ELSE
	                            #iqUDT_Statistics.InvalidMsg += 1;
	                        END_IF;
	                        
	                        
	                        // Move message into the FIFO data block
	                        IF (NOT #sx_InvalidTermination)                                         // No termination sign error 
	                        THEN
	                            
	                            // Mode 'W' - Write FIFO record
	                            "FC_Fifo"(ic_Mode := 'W',
	                                      qUDT_Status => #sa_Status.FIFORcvStatus,
	                                      qx_Error => #sa_Status.FIFORcvError,
	                                      qx_Warning => #sa_Status.FIFORcvWarning,
	                                      iqv_Data := #sUDT_MsgArray,
	                                      iqUDT_FifoHeader := #iqUDT_FifoHeader,
	                                      iqv_DataBuffer := #iqa_FifoData);
	                            
	                            
	                        END_IF;
	                        
	                        #sx_InvalidTermination := FALSE;                                    // Reset the invalid termination bit
	                        
	                        // Update lengths and counters
	                        #si_RcvMsgPartLen := 0;
	                        #si_RcvMsgOffset += #si_RcvMsgLen + 1;
	                        #si_RcvMsgLen := 0;
	                        #si_NrOfRcvMsg += 1;
	                        #sdi_RcvMsgCounter += 1;
	                        
	                        // Termination sign not found        
	                    ELSE
	                        
	                        #si_RcvMsgLen := #si_RcvMsgLen + 1;                               // Increment received message length
	                        
	                    END_IF;
	                    
	                    // Message length invalid - reset message length and increase statistics
	                ELSE
	                    
	                    #si_RcvMsgLen := 0;
	                    #iqUDT_Statistics.InvalidMsg += 1;
	                    
	                END_IF;
	                
	            END_FOR;
	            
	        END_REGION
	        
	        REGION 5.4 – Part of the message preparation
	            
	            
	            // Move part of the message to buffer when last received sign is not a termination signs
	            IF (#sa_TRCV.Data[UDINT_TO_INT(#sa_TRCV.RcvLen - 1)] <> #cc_CRLF_L            // Last received sign is not a termination sing
	                AND #si_RcvMsgLen < #si_MaxMsgLen)                         // Message length valid
	            THEN
	                
	                // Fill not used message char array elements with '$00' 
	                FILL_BLK(IN := '$00',
	                         COUNT := INT_TO_ULINT(#si_MaxMsgLen) -
	                         INT_TO_ULINT(#si_RcvMsgLen),
	                         OUT => #sUDT_MsgPartArray.Character[#si_RcvMsgLen]);
	                
	                // Move part of the message to a buffer
	                MOVE_BLK(IN := #sa_TRCV.Data[#si_RcvMsgOffset],
	                         COUNT := INT_TO_ULINT(#si_RcvMsgLen),
	                         OUT => #sUDT_MsgPartArray.Character[0]);
	                
	                // Set the part of the message received bit and move length of the received message into the length of the part of the message variable
	                #sx_RcvMsgPart := TRUE;
	                #si_RcvMsgPartLen := #si_RcvMsgLen;
	                
	            END_IF;
	            
	        END_REGION
	        
	    END_IF;
	    
	END_REGION
	
	REGION 6 – Status
	    
	    REGION 6.1 - Block status
	        
	        // Receive error
	        #sa_Status.ReceiveError := #sa_TRCV.Error;
	        
	        // Parametrization collective error output
	        #qx_Error :=
	        #sa_Status.FIFORcvError                          // FIFO error
	        OR #sa_Status.ReceiveError;                      // Receive error
	        
	        // Parametrization collective warning output
	        #qx_Warning := #sa_Status.FIFORcvWarning;        // FIFO warning
	        
	    END_REGION
	    
	    REGION 6.2 - Error code preparation
	        
	        IF (#sa_TRCV.#Status > 16#8000
	            OR #sa_TRCV.#Status = 16#0)
	        THEN
	            
	            #sa_Status.ErrorCode.TRCV := #sa_TRCV.#Status;
	            
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_TCPIPSend"
TITLE = FB_TCPIPSend
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : Communication
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 31
// END_ATTRIBUTES
//Function block to send data from TCPIP.
   VAR_INPUT 
      iUDT_Connection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_Connection";   // Connection parameters
      ix_EnableSend { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Enable send
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective error output
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective warning output
   END_VAR

   VAR_IN_OUT 
      iqUDT_FifoLowHeader : "UDT_FifoHeader";   // Low priority FIFO header
      iqs_FifoLowData : Array[*] of "UDT_Message";   // Low priority FIFO data
      iqUDT_FifoMedHeader : "UDT_FifoHeader";   // Medium priority FIFO header
      iqs_FifoMedData : Array[*] of "UDT_Message";   // Medium priority FIFO data
      iqUDT_FifoHighHeader : "UDT_FifoHeader";   // High priority FIFO header
      iqs_FifoHighData : Array[*] of "UDT_Message";   // High priority FIFO data
   END_VAR

   VAR 
      sFB_TSEND {InstructionName := 'TSEND'; LibVersion := '4.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TSEND;   // Siemens "TSEND" block - to send the data over TCPIP socket
      sUDT_MsgArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Message";   // Message character array
      sa_TSEND { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // TSEND block structure
         Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // TSEND - Status
         Request { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TSEND - Request
         Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TSEND - Busy
         Done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TSEND - Done
         Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TSEND - Error
      END_STRUCT;
      sa_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOLowPrioStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";
         FIFOMedPrioStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";
         FIFOHighPrioStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";
         FIFOLowPrioError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO low priority error
         FIFOLowPrioWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO low priority warning
         FIFOMedPrioError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO medium priority error
         FIFOMedPrioWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO medium priority warning
         FIFOHighPrioError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO high priority error
         FIFOHighPrioWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO high priority warning
         SendError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send operation error
      END_STRUCT;
      si_MaxMsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum message length
      si_MsgLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Message length
      sx_MsgReady { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message is ready to send
      sx_MsgRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message has been read
      sx_MsgReadReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request to read message
      sx_FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Summary FIFO error
   END_VAR

   VAR CONSTANT 
      cc_NULL : Char := '$00';   // NULL sign
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	13/06/2019  | 0.2       | A.Nowak       | Replacement of instruction if for direct write into variable - Region 7  
	25/06/2019  | 0.5       | L.Klar        | Comments corrected
	18/07/2019  | 0.6       | L.Klar        | Status handling changed
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	22/08/2019  | 2.1       | K.Pokorski    | Comments adjusted
	20/09/2019  | 2.2       | K.Pokorski    | "UDT_Status" deleted
	26/09/2019  | 2.3       | A.Nowak       | Delete NoDataTOSend and TSEND status code from status structure. Delete region 7.
	02/10/2019  | 2.4       | A.Nowak       | Implementation of the new FIFO block
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – Update FIFO header status bits
	    
	    // Mode 'S' - High priority FIFO register status update
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #sa_Status.FIFOHighPrioStatus,
	              qx_Error => #sa_Status.FIFOHighPrioError,
	              qx_Warning => #sa_Status.FIFOHighPrioWarning,
	              iqv_Data := #sUDT_MsgArray,
	              iqUDT_FifoHeader := #iqUDT_FifoHighHeader,
	              iqv_DataBuffer := #iqs_FifoHighData);
	    
	    
	    // Mode 'S' - Medium priority FIFO register status update
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #sa_Status.FIFOMedPrioStatus,
	              qx_Error => #sa_Status.FIFOMedPrioError,
	              qx_Warning => #sa_Status.FIFOMedPrioWarning,
	              iqv_Data := #sUDT_MsgArray,
	              iqUDT_FifoHeader := #iqUDT_FifoMedHeader,
	              iqv_DataBuffer := #iqs_FifoMedData);
	    
	    // Mode 'S' - Low priority FIFO register status update
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #sa_Status.FIFOLowPrioStatus,
	              qx_Error => #sa_Status.FIFOLowPrioError,
	              qx_Warning => #sa_Status.FIFOLowPrioWarning,
	              iqv_Data := #sUDT_MsgArray,
	              iqUDT_FifoHeader := #iqUDT_FifoLowHeader,
	              iqv_DataBuffer := #iqs_FifoLowData);
	    
	END_REGION
	
	REGION 2 – FIFO header summary error 
	    
	    #sx_FIFOError :=
	    #sa_Status.FIFOHighPrioError         // High priority FIFO error 
	    OR #sa_Status.FIFOMedPrioError       // Medium priority FIFO error
	    OR #sa_Status.FIFOLowPrioError;      // Low priority FIFO error
	    
	END_REGION
	
	REGION 3 – FIFO Read request
	    
	    #sx_MsgReadReq :=
	    #ix_EnableSend                      // Connection is established 
	    AND NOT #sx_FIFOError               // No FIFO errors
	    AND NOT #sa_TSEND.Error             // No TSEND errors 
	    AND #sa_TSEND.Status = 16#7000;     // TSEND block status equal to 16#7000 - no job
	    
	END_REGION
	
	REGION 4 – Read the message from high priority FIFO data buffer
	    
	    IF (#sx_MsgReadReq                                                          // Read request
	        AND NOT #iqUDT_FifoHighHeader.Status.Empty                             // High priority FIFO data buffer is not empty
	        AND NOT #sx_MsgRead)                                                    // Message isn't read
	    THEN
	        
	        // Mode 'R' - Read high priority FIFO record
	        "FC_Fifo"(ic_Mode := 'R',
	                  qUDT_Status => #sa_Status.FIFOHighPrioStatus,
	                  qx_Error => #sa_Status.FIFOHighPrioError,
	                  qx_Warning => #sa_Status.FIFOHighPrioWarning,
	                  iqv_Data := #sUDT_MsgArray,
	                  iqUDT_FifoHeader := #iqUDT_FifoHighHeader,
	                  iqv_DataBuffer := #iqs_FifoHighData);
	        
	        #sx_MsgRead := TRUE;                                                        // Message read bit
	        
	    END_IF;
	    
	END_REGION
	
	REGION 5 – Read the message from medium priority FIFO data buffer
	    
	    IF (#sx_MsgReadReq                                                              // Read request, 
	        AND #iqUDT_FifoHighHeader.Status.Empty                                     // High priority FIFO data buffer empty
	        AND NOT #iqUDT_FifoMedHeader.Status.Empty                                  // Medium priority FIFO data buffer not empty
	        AND NOT #sx_MsgRead)                                                        // Message not read
	    THEN
	        
	        // Mode 'R' - Read medium priority FIFO record
	        "FC_Fifo"(ic_Mode := 'R',
	                  qUDT_Status => #sa_Status.FIFOMedPrioStatus,
	                  qx_Error => #sa_Status.FIFOMedPrioError,
	                  qx_Warning => #sa_Status.FIFOMedPrioWarning,
	                  iqv_Data := #sUDT_MsgArray,
	                  iqUDT_FifoHeader := #iqUDT_FifoMedHeader,
	                  iqv_DataBuffer := #iqs_FifoMedData);
	        
	        #sx_MsgRead := TRUE;                                                        // Message read bit
	        
	    END_IF;
	    
	END_REGION
	
	REGION 6 – Read the message from low priority FIFO data buffer
	    
	    IF (#sx_MsgReadReq                                                          // Read request
	        AND #iqUDT_FifoHighHeader.Status.Empty                                 // High priority FIFO data buffer empty
	        AND #iqUDT_FifoMedHeader.Status.Empty                                  // Medium priority FIFO data buffer empty
	        AND NOT #iqUDT_FifoLowHeader.Status.Empty                              // Low priority FIFO data buffer not empty
	        AND NOT #sx_MsgRead)                                                    // Message not read
	    THEN
	        
	        #sx_MsgRead := TRUE;                                                    // Message read bit
	        
	        // Mode 'R' - Read low priority FIFO record
	        "FC_Fifo"(ic_Mode := 'R',
	                  qUDT_Status => #sa_Status.FIFOLowPrioStatus,
	                  qx_Error => #sa_Status.FIFOLowPrioError,
	                  qx_Warning => #sa_Status.FIFOLowPrioWarning,
	                  iqv_Data := #sUDT_MsgArray,
	                  iqUDT_FifoHeader := #iqUDT_FifoLowHeader,
	                  iqv_DataBuffer := #iqs_FifoLowData);
	        
	    END_IF;
	    
	END_REGION
	
	REGION 7 – Maximum number of message array elements
	    
	    #si_MaxMsgLen := "FC_GetNrOfArrayEl"(iv_Array := #sUDT_MsgArray.Character);
	    
	END_REGION
	
	REGION 8 – Message length
	    
	    // Measuring the length of a read message
	    IF (#sx_MsgRead                                                 // The message is read
	        AND NOT #sx_MsgReady)                                       // The message is not ready
	    THEN
	        
	        // Initialize the message length 
	        #si_MsgLen := 0;
	        
	        // Message character counting loop  
	        WHILE #sUDT_MsgArray.Character[#si_MsgLen] <> #cc_NULL     // Message array character is diffrent then NULL sign
	            AND #si_MsgLen < #si_MaxMsgLen - 1                      // Message length is lower then maximum message length minus 1
	        DO
	            
	            #si_MsgLen += 1;
	            
	        END_WHILE;
	        
	        #sx_MsgReady := TRUE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 9 – Send request
	    
	    IF (#sx_MsgRead                     // The message is read
	        AND #sx_MsgReady)               // The message is ready
	        
	    THEN
	        
	        #sa_TSEND.Request := TRUE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 10 – Send data
	    
	    #sFB_TSEND(REQ := #sa_TSEND.Request,
	               ID := #iUDT_Connection.ID,
	               LEN := INT_TO_UDINT(#si_MsgLen),
	               DONE => #sa_TSEND.Done,
	               BUSY => #sa_TSEND.Busy,
	               ERROR => #sa_TSEND.Error,
	               STATUS => #sa_TSEND.Status,
	               DATA := #sUDT_MsgArray);
	    
	    // Reset send request, message read and ready bits
	    IF (#sa_TSEND.Request                                       // Send request
	        AND NOT #sa_TSEND.Busy                                  // TSEND block not busy
	        AND (#sa_TSEND.Done                                     // Send operation done 
	        OR #sa_TSEND.Status = 16#7000))                     // Communication is not established
	    THEN
	        
	        #sa_TSEND.Request := FALSE;
	        #sx_MsgRead := FALSE;
	        #sx_MsgReady := FALSE;
	        
	    END_IF;
	    
	    // Reset send error and TSEND status after correctly sent message
	    IF (#sa_TSEND.Done)                                                 // Send operation done 
	    THEN
	        
	        #sa_Status.SendError := FALSE;
	        
	    END_IF;
	    
	    // Set send error and TSEND status if error occured
	    IF (#sa_TSEND.Error)                                                // TSEND error
	    THEN
	        
	        #sa_Status.SendError := TRUE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 11 – Status
	    
	    // Parametrization collective error output
	    #qx_Error :=
	    #sx_FIFOError                           // FIFO errors and
	    OR #sa_Status.SendError;                // TSEND block operation error
	    
	    // Parametrization collective warning output
	    #qx_Warning :=
	    #sa_Status.FIFOHighPrioWarning          // High priority FIFO warning bit 
	    OR #sa_Status.FIFOMedPrioWarning        // Medium priority FIFO warning bit 
	    OR #sa_Status.FIFOLowPrioWarning;       // Low priority FIFO warning bit 
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_Tracking"
TITLE = FB_Tracking
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 33
// END_ATTRIBUTES
//Function block to shift data in the tracking array.
   VAR_INPUT 
      iUDT_ConveyorCommonConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorCommonConfiguration";   // Conveyor common configuration
   END_VAR

   VAR_IN_OUT 
      iqa_TrackingData : Array[*] of Int;   // Tracking array
      iqUDT_ConveyorInterface : "UDT_ConveyorInterface";   // Conveyor interface
      iqUDT_HandshakeUp : "UDT_ConveyorHandshake";   // Upstream conveyor handshake
      iqUDT_Handshake : "UDT_ConveyorHandshake";   // Conveyor handshake
   END_VAR

   VAR 
      si_TrackingArrayLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Tracking array length
      si_TrackingArrayLowBound { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Tracking array lower bound
      sdi_TotalConvLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Number of tracking entries is equal to the conveyor length in cm
      si_Displacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Displacement
      si_ShiftDestination { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Pointer to the entry to start writing the tracking data
      si_ShiftOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Number of entries to be shifted and its direction
      sdi_GINInsertPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Position where GIN form upstream conveyor will be inserted
      sdi_GINExtractPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Position from which GIN will be moved to the downstream conveyor
      sx_InvalidTrackArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid tracking array size
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2019             MHS                                                     |
	|  All Rights Reserved         Larenweg 90                                             |
	|                              5234 KC 's-Hertogenbosch,                               |
	|                              Netherlands                                             |
	|                                                                                      |     
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L. Klar      | first release MHS TIA 15.1
	14/06/2019  | 0.2       | A.Nowak      | Replacement of instruction if for direct write into variable - Region 3 
	19/07/2019  | 0.5       | L.Klar       | Status handling changed
	24/07/2019  | 2.0       | L.Klar       | 2.0 MHS library release TIA 15.1
	23/08/2019  | 2.1       | L.Klar       | "UDT_ConveyorConfiguration" changed to "UDT_ConveyorCommonConfiguration", internal tracking error set instead of coil assigment. 
	10/09/2019  | 2.2       | L.Klar       | Comments changed, block optimized
	21/10/2019  | 2.3       | L.Klar       | Configuration UDT chanaged to input
	12/11/2019  | 3.0       | P.Majka      | 3.0 MHS library release TIA 15.1
	20/12/2019  | 3.1       | S. Deulkar   | Used configureation error bit to report to conveyor block 
	15/01/2020  | 3.2       | L.Klar       | Block adjusted to allow to transfer negative GIN numbers
	*)
	
	REGION 1 – Get the required number of entries
	    
	    // Number of entries is a conveyor length in cm
	    #sdi_TotalConvLength := (#iUDT_ConveyorCommonConfiguration.Length + #iUDT_ConveyorCommonConfiguration.LengthCorrection) / 10;
	    
	END_REGION
	
	REGION 2 – Number of tracking records validation
	    
	    // Tracking array dimensions
	    #si_TrackingArrayLen := "FC_GetNrOfArrayEl"(#iqa_TrackingData);
	    #si_TrackingArrayLowBound := DINT_TO_INT(LOWER_BOUND(ARR := #iqa_TrackingData, DIM := 1));
	    
	    // Check if the number of entries is exceeding the tracking array size
	    #sx_InvalidTrackArraySize := #si_TrackingArrayLen < #sdi_TotalConvLength + 2
	    OR #si_TrackingArrayLowBound <> 0;
	    
	END_REGION
	
	REGION 3 – Read the displacement
	    
	    #si_Displacement := #iqUDT_ConveyorInterface.Displacement;
	    
	END_REGION
	
	REGION 4 – Prepare tracking array pointers
	    
	    // A conveyor can run in forward and reverse direction
	    // Data will be shifted into tracking entry position 1 for both cases.
	    #si_ShiftDestination := 1;
	    
	    // If the direction is forward (positive displacement), entry 2 is taken as offset (shifts conveyor length from pos 2 in pos 1)
	    IF #si_Displacement > 0
	    THEN
	        
	        #si_ShiftOffset := 2;
	        #sdi_GINInsertPosition := #sdi_TotalConvLength + 1;
	        #sdi_GINExtractPosition := 1;
	        
	        // If the direction is reverse (negative displacement), entry 0 is taken as offset (shifts conveyor length from pos 0 in pos 1)
	    ELSE
	        
	        #si_ShiftOffset := 0;
	        #sdi_GINInsertPosition := 0;
	        #sdi_GINExtractPosition := #sdi_TotalConvLength;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 5 – Shift data
	    
	    // Data is shifted only if the conveyor is running (positive or negtive displacement)
	    WHILE #si_Displacement <> 0 DO
	        
	        // Conveyor running forward
	        IF (#si_Displacement > 0)
	        THEN
	            
	            // GIN is moved into the tracking array on GIN insert position if the number of positions in upstream conveyor handshake is available
	            // The number of positions to be shifted will be decremented
	            IF (#iqUDT_HandshakeUp.GIN <> 0
	                AND #iqUDT_HandshakeUp.NrOfPosToShift > 0)
	            THEN
	                
	                #iqa_TrackingData[#sdi_GINInsertPosition] := #iqUDT_HandshakeUp.GIN;
	                #iqUDT_HandshakeUp.NrOfPosToShift -= 1;
	                
	            ELSIF (#iqUDT_HandshakeUp.GIN <> 0
	                AND #iqUDT_HandshakeUp.NrOfPosToShift = 0)
	            THEN
	                
	                #iqa_TrackingData[#sdi_GINInsertPosition] := #iqUDT_HandshakeUp.GIN;
	                
	            END_IF;
	            
	            // Clear the downsteam handshake GIN if the number of positions to be shifted is 0
	            IF (#iqUDT_Handshake.GIN <> 0 AND #iqUDT_Handshake.NrOfPosToShift = 0)
	            THEN
	                
	                #iqUDT_Handshake.GIN := 0;
	                
	            END_IF;
	            
	            // GIN is moved into the handshake structure if the data is available at GIN extract position
	            // The number of positions will be incremented
	            IF (#iqa_TrackingData[#sdi_GINExtractPosition] <> 0)
	            THEN
	                
	                IF (#iqUDT_Handshake.GIN = 0)
	                THEN
	                    
	                    #iqUDT_Handshake.GIN := #iqa_TrackingData[#sdi_GINExtractPosition];
	                    #iqUDT_Handshake.NrOfPosToShift += 1;
	                    
	                ELSIF (#iqUDT_Handshake.GIN = #iqa_TrackingData[#sdi_GINExtractPosition])
	                THEN
	                    
	                    #iqUDT_Handshake.NrOfPosToShift += 1;
	                    
	                END_IF;
	                
	            END_IF;
	            
	            // Update displacement
	            #si_Displacement -= 1;
	            
	            // Conveyor running backward
	        ELSIF (#si_Displacement < 0)
	        THEN
	            
	            // GIN is moved into the tracking array on GIN insert position if the number of positions in downstream conveyor handshake is available
	            // The number of positions to be shifted will be decremented
	            IF (#iqUDT_Handshake.GIN <> 0
	                AND #iqUDT_Handshake.NrOfPosToShift > 0)
	            THEN
	                
	                #iqa_TrackingData[#sdi_GINInsertPosition] := #iqUDT_Handshake.GIN;
	                #iqUDT_Handshake.NrOfPosToShift -= 1;
	                
	                // In case of displacement greater than 1 and no positions to be shifted the GIN will be written to avoid gaps in data
	                // Writing will be stopped when GIN 0 is detected
	            ELSIF (#iqUDT_Handshake.GIN <> 0
	                AND #iqUDT_Handshake.NrOfPosToShift = 0)
	            THEN
	                
	                #iqa_TrackingData[#sdi_GINInsertPosition] := #iqUDT_Handshake.GIN;
	                
	            END_IF;
	            
	            // Clear the upstream handshake GIN if the number of positions to be shifted is 0
	            IF (#iqUDT_HandshakeUp.GIN <> 0 AND #iqUDT_HandshakeUp.NrOfPosToShift = 0)
	            THEN
	                
	                #iqUDT_HandshakeUp.GIN := 0;
	                
	            END_IF;
	            
	            // GIN is moved into the handshake structure if the data is available at GIN extract position
	            // The number of positions will be incremented
	            IF (#iqa_TrackingData[#sdi_GINExtractPosition] <> 0)
	            THEN
	                
	                IF (#iqUDT_HandshakeUp.GIN = 0)
	                THEN
	                    
	                    #iqUDT_HandshakeUp.GIN := #iqa_TrackingData[#sdi_GINExtractPosition];
	                    #iqUDT_HandshakeUp.NrOfPosToShift += 1;
	                    
	                    // In case of displacement greater than 1 and no positions to be shifted the GIN will be written to avoid gaps in data
	                    // Writing will be stopped when GIN 0 is detected    
	                ELSIF (#iqUDT_HandshakeUp.GIN = #iqa_TrackingData[#sdi_GINExtractPosition])
	                THEN
	                    
	                    #iqUDT_HandshakeUp.NrOfPosToShift += 1;
	                    
	                END_IF;
	                
	            END_IF;
	            
	            // Update displacement
	            #si_Displacement += 1;
	            
	        END_IF;
	        
	        // Shift the total conveyor length (number of tracking array entries) one cm up or down
	        MOVE_BLK(IN := #iqa_TrackingData[#si_ShiftOffset],
	                 COUNT := DINT_TO_ULINT(#sdi_TotalConvLength),
	                 OUT => #iqa_TrackingData[#si_ShiftDestination]);
	        
	        // Clear the GIN insert position
	        #iqa_TrackingData[#sdi_GINInsertPosition] := 0;
	        
	    END_WHILE;
	    
	END_REGION
	
	REGION 6 – Internal tracking error
	    
	    // The internal tracking error is set to stop the conveyor
	    // It is reset in the conveyor block
	    IF (#sx_InvalidTrackArraySize)
	    THEN
	        
	        #iqUDT_ConveyorInterface.ConfigurationError := TRUE;
	        
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_PECBulkD"
TITLE = FB_PEC
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : Conveyor
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 21
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_PECConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECDConfiguration";   //   PEC configuration structure
      ix_PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Signal of the PEC
      ix_PECDownstream { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Downstream PEC signal
      ix_DownstreamRunning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Downstream conveyor is running
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";   //   Status structure
      qx_PECFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   PEC Filtered
   END_VAR

   VAR_IN_OUT 
      iqUDT_ConveyorInterface : "UDT_ConveyorInterface";   //   Interface structure
      iqUDT_PECStatistics : "UDT_PECStatistics";   //   Statistics structure
   END_VAR

   VAR 
      s_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatus";   //   Status structure
      s_StatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatus";   //   Auxiliary status structure
      PEC_OnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_OnOffDelayDistance";   //   Filtering end of section photo eye signal
      R_TRIG_PECJam {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge trigger PEC jam
   END_VAR
   VAR RETAIN
      si_AuxJamDisplacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Auxiliary variable to calculate displacement when PEC is blocked
   END_VAR
   VAR 
      sx_Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Enable
      sx_PECFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Photo eye filtered
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	 16/03/2020 | 3.0       | K.Pokorski    | 3.0 MHS library release TIA 15.1
	 20/03/2020 | 3.1       | S.Theocharis  | Changed check to upsteam and jam condition
	 24/03/2020 | 3.2       | S.Theocharis  | Add input ix Changed ix_UpstreamRunning
	 30/03/2020 | 3.3       | K.Pokorski    | Changed error reset condition
	 02/04/2020 | 3.4       | S.Theocharis  | Changed check to downsteam
	 03/05/2023 | 4.0       | F.Baten       | PEC delay changed to distance 4.0 Release TIA 17.5
	 12/03/2024  | 4.1      | S. Nieswiec   | Small variable name changes according to current standard                                         
	*)
	
	REGION 1 - Triggers
	    
	    // Rising edge PEC Jam.
	    #R_TRIG_PECJam(CLK := #s_Status.Jam);
	    
	END_REGION
	
	REGION 2 - Active function  
	    
	    // To activate the Jam monitoring, the jam displacement limit must be greater than zero. 
	    #sx_Enable := #iUDT_PECConfiguration.JamDisplacementLimit > 0;
	    
	END_REGION
	
	REGION 3 - Reset errors
	    
	    // Reset Jam error and initialize Jam displacement counter, when reset signal occurs.
	    IF #iqUDT_ConveyorInterface.InternalErrorReset
	        AND (#iUDT_PECConfiguration.ResetWithPECBlocked
	        OR (NOT #iUDT_PECConfiguration.ResetWithPECBlocked
	        AND #sx_PECFiltered AND #ix_PECDownstream))
	        AND #s_Status.Jam
	    THEN
	        #si_AuxJamDisplacement := 0;
	        #s_Status.Jam := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Photo eye filters
	    
	    // End OF section photo eye signal filter measurement
	    #PEC_OnOffDelay(ii_Displacement := #iqUDT_ConveyorInterface.Displacement,
	                    idi_OnDelayDistance := #iUDT_PECConfiguration.OnDelayDistance,
	                    idi_OffDelayDistance := #iUDT_PECConfiguration.OffDelayDistance,
	                    ix_SignalToDelay := #ix_PEC,
	                    ix_Enable := TRUE,
	                    qx_DelayedSignal => #sx_PECFiltered);
	    
	    // Write the current status of the photo eye.
	    #s_Status.PEC := #sx_PECFiltered;
	    #qx_PECFiltered := #sx_PECFiltered;
	    
	END_REGION
	
	REGION 5 - Jam detection   
	    
	    // Increasing Jam displacement counter by conveyor displacement, when photo eyes on conveyor and downstream conveyor are blocked and jam functionality is enable.
	    IF #ix_PECDownstream AND (NOT #sx_PECFiltered) AND #sx_Enable AND #ix_DownstreamRunning
	        
	    THEN
	        #si_AuxJamDisplacement += #iqUDT_ConveyorInterface.Displacement;
	    ELSE
	        #si_AuxJamDisplacement := 0;
	    END_IF;
	    
	    // Set jam error when total jam displacement exceeded limit.
	    IF (#si_AuxJamDisplacement > #iUDT_PECConfiguration.JamDisplacementLimit)
	        OR (#si_AuxJamDisplacement < (#iUDT_PECConfiguration.JamDisplacementLimit * -1))
	    THEN
	        #s_Status.Jam := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Statistics
	    
	    // Jam Photo eye blocked statistics.
	    IF #s_Status.Jam
	        OR #iqUDT_ConveyorInterface.ResetStatistics
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #s_Status.Jam,
	                        ix_RTrigActivate := #R_TRIG_PECJam.Q,
	                        iqUDT_Statistics := #iqUDT_PECStatistics.Jam);
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Internal PEC error
	    
	    // Set Internal photo eye error .
	    IF #s_Status.Jam
	    THEN
	        #iqUDT_ConveyorInterface.InternalErrorPEC := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 8 - Status
	    
	    // Status update on change.
	    IF #s_StatusOld <> #s_Status
	    THEN
	        #qUDT_HMIStatus := #s_Status;
	        #s_StatusOld := #s_Status;
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_VfdSEWMOVI-CPositioning"
TITLE = FB_VFD_SEW_MOVI-C_Positioning
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 36
// END_ATTRIBUTES
//Control SEW Servo VFD with multiple positions
   VAR_INPUT 
      iUDT_VfdConfig { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdPositioningConfiguration";   //  Configuration structure
      iUDT_VfdInputs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdSEWPositioningPI";   //  VFD inputs structure
      ix_MainPowerOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  True = Main power is ok
      ix_BackupPowerOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  True = back-up power is ok
      ix_SimulationModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Simulation On
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdPositioningStatus";   //  HMI status structure
      qUDT_VfdOutputs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdSEWPositioningPO";   //  VFD outputs structure
   END_VAR

   VAR_IN_OUT 
      iqUDT_VSUInterface : "UDT_VSUInterface";   //  VSU interface structure
      iqUDT_VFDStatistics : "UDT_VfdStatistics";   //  VFD statistics
   END_VAR

   VAR 
      sUDT_PNDevice { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PNDevice";   //  PN device info structure
      sUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdPositioningStatus";   //  Status struture
      sFB_TimerOnOffDelayCheckSupply { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //  MHS "TimerOnOffDelay" - to delay time for VFD supply contactor
      sFB_TimerOnOffDelayMoviKit { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //  MHS "TimerOnOffDelay" - to delay time for MoviKit response delay error
      sFB_TimerOnOffDelayPositioning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //  MHS "TimerOnOffDelay" - to delay time for Porisioning delay error
      sFB_TimerOnOffDelayFasterManualSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sFB_TimerOnOffDelayActivateInhibit { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sF_TRIG_LST {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //  Falling edge positioning feedback
      sR_TRIG_ManInPos {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge manual travel into position
      sR_TRIG_PNSlaveNotOnline {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge for trigger Profinet slave not online statistics
      sR_TRIG_PNSlaveError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge for trigger Profinet slave error statistics
      sR_TRIG_InternalError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge for trigger Internal VFD Error statistics
      sR_TRIG_CommunicationErrorMovikit {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge for trigger communication error Movikit statistics
      sR_TRIG_Running {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge for starting of the running signal
      sa_PNPortsStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..8] of Bool;   // TRUE when specific port has an error
      sr_ActualTorque { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   //  Actual torque of drive
      sdi_ActualPositionValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //  Actual position in mm
      si_ManualSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Actual manual speed
      si_ActualSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  Actual speed in mm/s
      si_LastSwitchtime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //  The actual time it took the last switch-over
      sx_ErrorActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  An error is active
      sx_WarningActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  A warning is active
      sx_PNDeviceHealthy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  PN Device is healthy, no errors
      sx_MovikitHandshakeIn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Handshake to movikit
      sx_MoviKitFeedback { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Movikit feedback delay
      sx_HardwareAvailable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  All hardware is on line and available
      sx_PowerOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  All Power (in and external) is ok
      sx_PositioningFeedback { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Positioning feedback delay
      sx_VFDReady { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  The VFD control is ready to operate
      sx_StartVFD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Start VFD
      sx_MotorRunning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  The servo motor is running
      sx_ManualPositionStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  A configured position is reached in manual mode
      sx_ManualPosHold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Hold in position
      sx_RestartMan { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Manual restart requested
      sx_ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Commissioning: configuration of parameters is wrong
      si_LoopCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      sx_Check { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_TEMP 
      tdi_EncoderPositionSetpoint : DInt;   //  Value of position setpoint
   END_VAR

   VAR CONSTANT 
      ci_NumberOfProfinetPorts : Int := 2;   // Number of Profinet ports in device
      ci_SpeedManualMode : Int := 100;   // Speed in manual mode for jogging
      ci_SpeedManualModeAfter5s : Int := 200;
   END_VAR


BEGIN
	(* 
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | P. Majka      | first release MHS TIA 15.1
	29/07/2019  | 0.2       | P. Majka      | Adding new functionality - comments to change
	30/07/2019  | 2.0       | P. Majka      | Moved to project with library 2.0
	31/07/2019  | 2.1       | M. Kurpiers   | Updating comments
	08/08/2019  | 2.2       | J.Krawczuk    | Updating referencing
	14/08/2019  | 2.3       | J.Krawczuk    | Added new functionality
	24/08/2019  | 2.4       | F. Baten      | Changed regions / combined errors / modified comments and working 
	05/11/2019  | 2.5       | S.Theocharis  | Change the VFDDeviceName to VFDPNDeviceName for consistency with rest VFD blocks
	20/11/2019  | 2.10      | S. Nikodem    | Configuration error
	20/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	28/02/2020  | 3.1       | F.Baten       | Reinstated positioning warning (Servo takes too long to get to position) and
	                                        | separated it again from OutOfPosition error (over running the set positions)
	01/02/2020  | 3.2       | F.Baten       | Changed "UDT_VFD_Status" to "UDT_VFD_PositioningStatus"
	04/02/2020  | 3.3       | F.Baten       | Changed VSU Rio interface - Error and ready modified.
	06/08/2020  | 3.4       | L.Klar        | Manual speed changed
	03/11/2020  | 3.5       | K.Pokorski    | Profinet ports diagnostics added 
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	06/10/2023  | 4.1       | F.Baten       | All positions converted to DINT as need of higher values for lift funtion
	14/06/2024  | 4.1       | R.Pieczonka   | Changed conditions for "EnableApplicationStop". Fixed setting output speed
	*)
	
	REGION 1 - Get Device Profinet information
	    
	    "FC_GetDevicePN"(is_PNDeviceName := #iUDT_VfdConfig.VFDPNDeviceName,
	                     ix_SimulationModeActive := #ix_SimulationModeActive,
	                     iqUDT_PND := #sUDT_PNDevice);
	    
	    
	    "FC_GetPNPortStatus"(ii_NumberOfPorts := #ci_NumberOfProfinetPorts,
	                         iUDT_DevicePNInfo := #sUDT_PNDevice,
	                         qa_PortFault => #sa_PNPortsStatus);
	    
	END_REGION
	
	REGION 2 - Reset errors
	    
	    IF #iqUDT_VSUInterface.InternalErrorReset
	        
	    THEN
	        #sUDT_HMIStatus.CommunicationErrorMovikit := FALSE;                    // The Movikit application is not reacting 
	        #sUDT_HMIStatus.PNSlaveNotOnline := FALSE;                             // Profinet slave is not on line
	        #sUDT_HMIStatus.PNSlaveError := FALSE;                                 // Profinet slave has an error
	        #sUDT_HMIStatus.PositioningTimeOutError := FALSE;                      // Reset positioning error 
	        #sUDT_HMIStatus.InternalError := FALSE;                                // Reset internal error
	        #sUDT_HMIStatus.PNSlaveWarning := FALSE;
	        
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Check Hardware
	    
	    REGION 3.1 - Power OK
	        // Hardware will be available after delay so the device has time for initialisation
	        #sFB_TimerOnOffDelayCheckSupply(iudi_OnDelayTime := 2000,              // Set time for on delay 
	                                        ix_SignalToDelay := #ix_MainPowerOk);  // Mains are ok
	        
	        #sx_PowerOK := #sFB_TimerOnOffDelayCheckSupply.qx_DelayedSignal;       // And All Power (in and external) is ok
	    END_REGION
	    
	    REGION 3.2 - PN Healthy Check
	        
	        IF NOT "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.Exist     // Or the connected device doesn't exist 
	            AND NOT #ix_SimulationModeActive                                    // And not in simulation   
	            AND (#sx_PowerOK                                                    // Main Power is ok
	            OR #ix_BackupPowerOk)                                               // Or backup power is ok
	        THEN
	            #sUDT_HMIStatus.PNSlaveNotOnline := TRUE;
	        END_IF;
	        
	        // Check if PN ports are healthy 
	        IF #sa_PNPortsStatus[1] XOR #sa_PNPortsStatus[2] THEN
	            #sUDT_HMIStatus.PNSlaveWarning := TRUE;
	        END_IF;
	        
	        IF "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.Error       // Or the device has an error 
	            AND NOT #ix_SimulationModeActive                                    // And not in simulation 
	            AND (#sx_PowerOK                                                    // Main Power is ok
	            OR #ix_BackupPowerOk)                                               // Or backup power is ok
	            AND NOT #sUDT_HMIStatus.PNSlaveWarning                             // and PN ports are healthy
	            
	        THEN
	            #sUDT_HMIStatus.PNSlaveError := TRUE;                              // Profinet slave has an error
	        END_IF;
	        
	        #sx_PNDeviceHealthy := NOT #sUDT_HMIStatus.PNSlaveNotOnline            // Or the device an error 
	        AND NOT #sUDT_HMIStatus.PNSlaveError                                   // Profinet slave has an error
	        AND (#sx_PowerOK                                                        // Main Power is ok
	        OR #ix_BackupPowerOk)                                                   // Or backup power is ok
	        AND #sUDT_PNDevice.PNDeviceFound;                                      // Device is found in network configuration
	        
	    END_REGION
	    
	    // Hardware is available 
	    #sx_HardwareAvailable := #iUDT_VfdInputs.Status_Word_1.STO_Inactive        // Safety is ok
	    AND #sx_PowerOK                                                             // All mains are ok
	    AND #sx_PNDeviceHealthy                                                     // No PN errors
	    OR #ix_SimulationModeActive;                                                // Or simulation active 
	    
	    REGION 3.3 - Check communication MoviKit
	        #sx_MoviKitFeedback :=                                                  // Set MoviKit feedback delay
	        ((#sx_MovikitHandshakeIn                                                // IF MoviKit handshake input is active 
	        AND NOT #iUDT_VfdInputs.Status_Word_1.MovikitHandshakeOut)             // And MoviKit handshake output active 
	        OR (NOT #sx_MovikitHandshakeIn                                          // Or MoviKit handshake input isn't active 
	        AND #iUDT_VfdInputs.Status_Word_1.MovikitHandshakeOut));               // And MoviKit handshake output isn't active 
	        
	        #sFB_TimerOnOffDelayMoviKit(iudi_OnDelayTime := 1000,                  // Set on delay time to 1000
	                                    ix_SignalToDelay := NOT #sx_MoviKitFeedback);          // Start timer  
	        
	        IF (#sFB_TimerOnOffDelayMoviKit.qx_DelayedSignal)                      // If the timer elapsed 
	            AND #sx_HardwareAvailable
	        THEN
	            #sUDT_HMIStatus.CommunicationErrorMovikit := TRUE;                 // Set MoviKit error 
	        END_IF;
	        
	        #sx_MovikitHandshakeIn := NOT #iUDT_VfdInputs.Status_Word_1.MovikitHandshakeOut;   // Set the Handshake signal
	    END_REGION
	    
	    
	END_REGION
	
	REGION 4 - Handle input data
	    
	    REGION 4.1 - Move to status
	        
	        #sr_ActualTorque := INT_TO_REAL(#iUDT_VfdInputs.ActualTorque) / 1000.0 * #iUDT_VfdConfig.TorqueMax;   // Writing actual real calculated torque
	        #si_ActualSpeed := #iUDT_VfdInputs.ActualSpeed;                                                        // Actual speed in mm/s 
	        #sx_MotorRunning := #iUDT_VfdInputs.Status_Word_1.DriveActive;                                         // Set status motor running if motor shaft is turning 
	        
	    END_REGION
	    
	    REGION 4.2 - Actual positon value
	        
	        #sdi_ActualPositionValue := SHL(IN := (WORD_TO_DINT(IN := #iUDT_VfdInputs.ActualPosition_hW)), N := 16) + WORD_TO_DINT(IN := #iUDT_VfdInputs.ActualPosition_lW);   // Calculate actual encoder position from two words  
	        
	        IF #sdi_ActualPositionValue <= (#iUDT_VfdConfig.Position[#iqUDT_VSUInterface.PositionSetpoint] + #iUDT_VfdConfig.PositionWindow)         // If actual encoder position in mm is lower or equal to position setpoint plus position window 
	            AND #sdi_ActualPositionValue >= (#iUDT_VfdConfig.Position[#iqUDT_VSUInterface.PositionSetpoint] - #iUDT_VfdConfig.PositionWindow)    // And actual encoder position in mm is greater or equal to position setpoint minus position window 
	            
	        THEN
	            #iqUDT_VSUInterface.PositionActual := #iqUDT_VSUInterface.PositionSetpoint;                                              // Write position setpoint TO actual position number when position setpoint reached 
	        ELSIF #iqUDT_VSUInterface.Manual
	        THEN
	            #sx_Check := FALSE;
	            FOR #si_LoopCounter := 0 TO "FC_GetNrOfArrayEl"(iv_Array := #iUDT_VfdConfig.Position) DO
	                IF #sdi_ActualPositionValue <= (#iUDT_VfdConfig.Position[#si_LoopCounter] + #iUDT_VfdConfig.PositionWindow)
	                    AND #sdi_ActualPositionValue >= (#iUDT_VfdConfig.Position[#si_LoopCounter] - #iUDT_VfdConfig.PositionWindow)
	                THEN
	                    #iqUDT_VSUInterface.PositionActual := #si_LoopCounter;
	                    #sx_Check := TRUE;
	                END_IF;
	            END_FOR;
	            IF #sx_Check = 0 THEN
	                #iqUDT_VSUInterface.PositionActual := 0;
	            END_IF;
	        ELSE
	            #iqUDT_VSUInterface.PositionActual := 0;
	        END_IF;
	        
	        
	        
	        
	    END_REGION
	    
	    REGION 4.3 - Manual position
	        // to stop at a predefined position when jogging, after the stop the movement can continue by pressing the jogbutton again
	        IF #iUDT_VfdInputs.Mode = 100                                                                          // The actual application mode is equal to 100
	        THEN
	            #sx_ManualPositionStop :=
	            (#sdi_ActualPositionValue <= (#iUDT_VfdConfig.Position[1] + #iUDT_VfdConfig.PositionWindow)       // IF actual encoder position in mm is lower OR equal TO position setpoint plus position window 
	            AND #sdi_ActualPositionValue >= (#iUDT_VfdConfig.Position[1] - #iUDT_VfdConfig.PositionWindow))   // And actual encoder position in mm is greater or equal to position setpoint minus position window
	            OR (#sdi_ActualPositionValue <= (#iUDT_VfdConfig.Position[2] + #iUDT_VfdConfig.PositionWindow)    // IF actual encoder position in mm is lower OR equal TO position setpoint plus position window 
	            AND #sdi_ActualPositionValue >= (#iUDT_VfdConfig.Position[2] - #iUDT_VfdConfig.PositionWindow))   // And actual encoder position in mm is greater or equal to position setpoint minus position window
	            OR (#sdi_ActualPositionValue <= (#iUDT_VfdConfig.Position[3] + #iUDT_VfdConfig.PositionWindow)    // IF actual encoder position in mm is lower OR equal TO position setpoint plus position window 
	            AND #sdi_ActualPositionValue >= (#iUDT_VfdConfig.Position[3] - #iUDT_VfdConfig.PositionWindow))   // And actual encoder position in mm is greater or equal to position setpoint minus position window
	            OR (#sdi_ActualPositionValue <= (#iUDT_VfdConfig.Position[4] + #iUDT_VfdConfig.PositionWindow)    // IF actual encoder position in mm is lower OR equal TO position setpoint plus position window 
	            AND #sdi_ActualPositionValue >= (#iUDT_VfdConfig.Position[4] - #iUDT_VfdConfig.PositionWindow))   // And actual encoder position in mm is greater or equal to position setpoint minus position window
	            OR (#sdi_ActualPositionValue <= (#iUDT_VfdConfig.Position[5] + #iUDT_VfdConfig.PositionWindow)    // IF actual encoder position in mm is lower OR equal TO position setpoint plus position window 
	            AND #sdi_ActualPositionValue >= (#iUDT_VfdConfig.Position[5] - #iUDT_VfdConfig.PositionWindow))   // And actual encoder position in mm is greater or equal to position setpoint minus position window
	            OR (#sdi_ActualPositionValue <= (#iUDT_VfdConfig.Position[6] + #iUDT_VfdConfig.PositionWindow)    // IF actual encoder position in mm is lower OR equal TO position setpoint plus position window 
	            AND #sdi_ActualPositionValue >= (#iUDT_VfdConfig.Position[6] - #iUDT_VfdConfig.PositionWindow))   // And actual encoder position in mm is greater or equal to position setpoint minus position window
	            OR (#sdi_ActualPositionValue <= (#iUDT_VfdConfig.Position[7] + #iUDT_VfdConfig.PositionWindow)    // IF actual encoder position in mm is lower OR equal TO position setpoint plus position window 
	            AND #sdi_ActualPositionValue >= (#iUDT_VfdConfig.Position[7] - #iUDT_VfdConfig.PositionWindow))   // And actual encoder position in mm is greater or equal to position setpoint minus position window
	            OR (#sdi_ActualPositionValue <= (#iUDT_VfdConfig.Position[8] + #iUDT_VfdConfig.PositionWindow)    // IF actual encoder position in mm is lower OR equal TO position setpoint plus position window 
	            AND #sdi_ActualPositionValue >= (#iUDT_VfdConfig.Position[8] - #iUDT_VfdConfig.PositionWindow))   // And actual encoder position in mm is greater or equal to position setpoint minus position window
	            OR (#sdi_ActualPositionValue <= (#iUDT_VfdConfig.Position[9] + #iUDT_VfdConfig.PositionWindow)    // IF actual encoder position in mm is lower OR equal TO position setpoint plus position window 
	            AND #sdi_ActualPositionValue >= (#iUDT_VfdConfig.Position[9] - #iUDT_VfdConfig.PositionWindow))   // And actual encoder position in mm is greater or equal to position setpoint minus position window
	            OR (#sdi_ActualPositionValue <= (#iUDT_VfdConfig.Position[10] + #iUDT_VfdConfig.PositionWindow)   // IF actual encoder position in mm is lower OR equal TO position setpoint plus position window 
	            AND #sdi_ActualPositionValue >= (#iUDT_VfdConfig.Position[10] - #iUDT_VfdConfig.PositionWindow)); // And actual encoder position in mm is greater or equal to position setpoint minus position window
	        END_IF;
	    END_REGION
	END_REGION
	
	REGION 5 - Errors and warnings
	    
	    REGION 5.1 - VFD internal error 
	        
	        #sUDT_HMIStatus.InternalError := #iUDT_VfdInputs.Status_Word_1.Error; // An internal VFD error is active
	        #sUDT_HMIStatus.ErrorCode := #iUDT_VfdInputs.StatusErrorNo.%B1;       // Copy VFD error code from static status structure to HMI status structure 
	        #sUDT_HMIStatus.SubErrorCode := #iUDT_VfdInputs.StatusErrorNo.%B0;    // Copy VFD sub-error code from static status structure to HMI status structure 
	        
	        IF NOT #iUDT_VfdInputs.Status_Word_1.Error
	            AND NOT #iUDT_VfdInputs.Status_Word_1.Warning
	        THEN
	            #sUDT_HMIStatus.ErrorCode := 0;                                    // Copy VFD error code from static status structure TO HMI status structure 
	            #sUDT_HMIStatus.SubErrorCode := 0;                                 // Copy VFD sub-error code from static status structure to HMI status structure 
	        END_IF;
	    END_REGION
	    
	    REGION 5.2 - Positioning error
	        // This timer checks if the speed of the VFD is ok.
	        // The VFD should reach is next destination in the given time
	        // 
	        
	        #sx_PositioningFeedback := #iqUDT_VSUInterface.PositionActual <> #iqUDT_VSUInterface.PositionSetpoint // If actual position is different than setpoint position 
	        AND #iqUDT_VSUInterface.Automatic;                                                                     // And in automatic mode 
	        
	        #sF_TRIG_LST(CLK := #sx_PositioningFeedback);
	        
	        IF #sF_TRIG_LST.Q
	        THEN
	            #si_LastSwitchtime := LREAL_TO_INT(#sFB_TimerOnOffDelayPositioning.qlr_ActualTime);
	        END_IF;
	        
	        
	        
	        #sFB_TimerOnOffDelayPositioning(iudi_OnDelayTime := (#iqUDT_VSUInterface.SwitchingTime),  // Set on delay time 
	                                        ix_SignalToDelay := #sx_PositioningFeedback);              // Start timer when positioning feedback delay 
	        
	        
	        
	        IF #sFB_TimerOnOffDelayPositioning.qx_DelayedSignal                    // If the time elapsed
	        THEN
	            
	            #sUDT_HMIStatus.PositioningTimeOutError := TRUE;                   // Set positioning warning
	            
	        END_IF;
	    END_REGION
	    
	    REGION 5.3 - Common Error
	        // Set VFD error active
	        #sx_ErrorActive := #sUDT_HMIStatus.InternalError                       // The VFD indicates an active error
	        OR #sUDT_HMIStatus.CommunicationErrorMovikit;                          // The block generated an communication error
	        
	    END_REGION
	    
	    REGION 5.4 - Configuration Warning
	        //  Check if no faulty setup is active
	        //  This is the responcebility of the commisioning engineer 
	        
	        IF #iUDT_VfdConfig.PositionMax > #iUDT_VfdConfig.PositionMin          // Max position is bigger than min position
	            AND #iUDT_VfdConfig.PositionMax > 0                                // and not 0
	            AND #iUDT_VfdConfig.VFDSpeed > 0                                   // Max speed is not 0
	            AND #iUDT_VfdConfig.VFDAccDecel > 0                                // Maximum acceleration an deceleration time is not 0
	            AND "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.Configure
	        THEN
	            #sx_ConfigurationError := FALSE;                                    // Reset the configuration warning   
	        ELSE
	            #sx_ConfigurationError := TRUE;                                     // Set configuration warning
	        END_IF;
	    END_REGION
	    
	    REGION 5.5 - Common warning
	        // Set VFD warning active
	        #sx_WarningActive := #iUDT_VfdInputs.Status_Word_1.Warning             // The VFD indicates an active warning
	        OR #sUDT_HMIStatus.PositioningTimeOutError;                                 // The VFD did not reach the position in time.
	        
	    END_REGION
	    
	END_REGION
	
	REGION 6 - Check conditions to set VFD Ready signals
	    
	    REGION 6.1 - Internal VFD ready
	        
	        #sx_VFDReady := #sx_HardwareAvailable                                   // The hardware is powered up and detected
	        AND (#iUDT_VfdInputs.Status_Word_1.InverterReady                       // And VFD is ready to start
	        OR #sx_MotorRunning)                                                    // Or motor running 
	        AND NOT #sx_ErrorActive                                                 // And no VFD error active      
	        AND NOT #sx_ConfigurationError;
	        // AND NOT (#iqUDT_VSUInterface.PositionActual = #iqUDT_VSUInterface.RequestedPosition);    /// Commented out because  it was causing issues for the refernce drive                                // And no configuration error
	        
	    END_REGION
	    
	    REGION 6.2 - External VFD ready (to control)
	        
	        #iqUDT_VSUInterface.Ready :=                                           // Signal ready is active if:
	        (#iqUDT_VSUInterface.Automatic                                         // And automatic mode request
	        AND NOT #iqUDT_VSUInterface.Manual                                     // And no manual mode request
	        AND #iUDT_VfdInputs.Status_Word_1.Referenced                           // And the drive is referenced
	        AND #iUDT_VfdInputs.Mode = 400)                                        // Actual application mode is equal to 400
	        OR
	        (NOT #iqUDT_VSUInterface.Automatic                                     // No automatic mode request 
	        AND #iqUDT_VSUInterface.Manual                                         // AND manual mode request 
	        AND #iUDT_VfdInputs.Mode = 100)                                        // And the actual application mode is equal to 100
	        OR
	        (#iqUDT_VSUInterface.Reference_command                                 // And the "refference" command is active
	        AND #iUDT_VfdInputs.Mode = 301)                                        // The actual application mode is equal TO 301
	        AND
	        (#sx_VFDReady                                                           // Status ready is active
	        AND #iqUDT_VSUInterface.RunEnabled);                                   // And running of the lifting device is enabled by VSU
	        
	    END_REGION
	END_REGION
	
	REGION 7 - Set VFD control data 
	    
	    REGION 7.1 - Stop VFD
	        
	        IF NOT #iqUDT_VSUInterface.Ready                                       // If VFD isn't ready to operate
	        THEN
	            
	            #sx_StartVFD := FALSE;                                              // Reset start VFD 
	            #qUDT_VfdOutputs.SetpointMode := 0;                                // Set the application mode to 0
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 7.3 - Reference VFD
	        
	        IF #sx_VFDReady                                                         // If status VFD ready to operate is active 
	            AND #iqUDT_VSUInterface.Reference_command                          // And the "refference" command is active 
	        THEN
	            
	            #qUDT_VfdOutputs.SetpointMode := 301;                              // Selecting FCB for reference travel FCB = 12 
	            
	            #tdi_EncoderPositionSetpoint := #iUDT_VfdConfig.Position[0];                                  // Set the position value as refference
	            #qUDT_VfdOutputs.SetpointPosition_hW := DINT_TO_WORD(SHR(IN := (#tdi_EncoderPositionSetpoint), N := 16));  // Send new position to encoder - high word 
	            #qUDT_VfdOutputs.SetpointPosition_lW := DINT_TO_WORD(IN := #tdi_EncoderPositionSetpoint);                  // Send new position TO encoder - low word 
	        END_IF;
	        
	        
	        IF #iqUDT_VSUInterface.Ready AND                                       // If VFD system is ready to operation
	            #iUDT_VfdInputs.Mode = 301                                         // And actual application mode  is equal to 301
	        THEN
	            
	            #sx_StartVFD := TRUE;                                               // Set start VFD 
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 7.4 - Manual mode - jogging
	        
	        IF #sx_VFDReady                                                         // If status VFD ready to operation is active
	            AND #iqUDT_VSUInterface.Manual                                     // And manual mode request is active 
	            AND NOT #iqUDT_VSUInterface.Automatic                              // And automatic mode request isn't active 
	            AND #iqUDT_VSUInterface.RunEnabled                                 // And running of the lifting device is enabled by VSU
	            AND NOT #iqUDT_VSUInterface.Reference_command                      // And the "refference" command isn't active 
	            
	        THEN
	            
	            #qUDT_VfdOutputs.SetpointMode := 100;                              // Selecting FCB for position-controlled jogging FCB = 20 
	            
	        END_IF;
	        
	        // On position while jogging: stop, when button is released and pressed again continue to travel
	        // 
	        #sR_TRIG_ManInPos(CLK := #sx_ManualPositionStop);
	        
	        #sx_ManualPosHold := (#sx_ManualPosHold                                 // Hold movement as long as buttons are pressed  
	        OR #sR_TRIG_ManInPos.Q)                                                // trigger position reached
	        AND (#iqUDT_VSUInterface.JogUp                                         // jogging up active
	        OR #iqUDT_VSUInterface.JogDown)                                        // jogging down active
	        AND #iqUDT_VSUInterface.Ready;                                         // ready to operate
	        
	        // Jog commands
	        
	        IF #iqUDT_VSUInterface.Ready                                           // If the VFD system is ready to operate 
	            AND (#iUDT_VfdInputs.Mode = 100)                                   // And the actual application mode is equal to 100
	            AND #iqUDT_VSUInterface.JogUp                                      // And selected jog in positive direction 
	            AND NOT #iqUDT_VSUInterface.JogDown                                // And not selected jog in negative direction  
	            AND NOT #sx_ManualPosHold
	        THEN
	            
	            #qUDT_VfdOutputs.Control_Word_1.JogPos := TRUE;                                                // Set jog positive VFD control bit 
	            #qUDT_VfdOutputs.Control_Word_1.JogNeg := FALSE;                                               // Reset jog negative VFD control bit 
	            
	        ELSIF
	            #iqUDT_VSUInterface.Ready                                          // If the VFD system is ready to operate 
	            AND (#iUDT_VfdInputs.Mode = 100)                                   // And the actual application mode is equal to 100
	            AND NOT #iqUDT_VSUInterface.JogUp                                  // And not selected jog in positive direction 
	            AND #iqUDT_VSUInterface.JogDown                                    // And selected jog in negative direction  
	            AND NOT #sx_ManualPosHold
	        THEN
	            
	            #qUDT_VfdOutputs.Control_Word_1.JogPos := FALSE;                   // Reset jog positive VFD control bit 
	            #qUDT_VfdOutputs.Control_Word_1.JogNeg := TRUE;                    // Set jog negative VFD control bit 
	            
	        ELSE
	            
	            #qUDT_VfdOutputs.Control_Word_1.JogPos := FALSE;                   // Reset jog positive VFD control bit 
	            #qUDT_VfdOutputs.Control_Word_1.JogNeg := FALSE;                   // Reset jog negative VFD control bit 
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 7.5 - Automatic mode - for positioning
	        
	        IF #sx_VFDReady                                                         // If status VFD ready to operation is active 
	            AND #iqUDT_VSUInterface.Automatic                                  // And automatic mode request is active 
	            AND NOT #iqUDT_VSUInterface.Manual                                 // And manual mode request isn't active
	            AND #iqUDT_VSUInterface.RunEnabled                                 // And running of the lifting device is enabled by VSU 
	            AND #iUDT_VfdInputs.Status_Word_1.Referenced                       // And the drive is referenced 
	            AND NOT #iqUDT_VSUInterface.Reference_command                      // And the "refference" command isn't active
	            
	        THEN
	            
	            #qUDT_VfdOutputs.SetpointMode := 400;                              // Select FCB for absolute positioning control FCB = 09 
	            
	        END_IF;
	        
	        IF #iqUDT_VSUInterface.Ready AND                                       // IF VFD system is ready TO operation 
	            #iUDT_VfdInputs.Mode = 400                                         // And actual application mode is equal to 400
	        THEN
	            
	            #tdi_EncoderPositionSetpoint := #iUDT_VfdConfig.Position[#iqUDT_VSUInterface.PositionSetpoint];    // Move position request to setpoint postion 
	            #qUDT_VfdOutputs.SetpointPosition_hW := DINT_TO_WORD(SHR(IN := (#tdi_EncoderPositionSetpoint), N := 16));         // Send new position to encoder - high word 
	            #qUDT_VfdOutputs.SetpointPosition_lW := DINT_TO_WORD(IN := #tdi_EncoderPositionSetpoint);                         // Send new position to encoder - low word 
	            #sx_StartVFD := TRUE;
	            
	        END_IF;
	        
	    END_REGION
	    
	    
	    REGION 7.6 - Set output speed
	        
	        // When the drive was manual operated, first start in manual speed to go to position
	        
	        #si_ManualSpeed := #ci_SpeedManualMode;                                 // Manual speed setpoint
	        
	        IF (#iqUDT_VSUInterface.Manual                                          // Manual command is activated
	            OR #iqUDT_VSUInterface.GoReference)
	            AND NOT #iqUDT_VSUInterface.Automatic
	        THEN
	            #sx_RestartMan := TRUE;                                             // Set memory Manual was activated
	        END_IF;
	        
	        IF #iqUDT_VSUInterface.PositionActual = #iqUDT_VSUInterface.PositionSetpoint     // Signal from VFD, indicating being in position
	            OR #iqUDT_VSUInterface.Automatic
	        THEN
	            #sx_RestartMan := FALSE;                                            // Reset memory Manual was activated
	        END_IF;
	        
	        
	        IF #iUDT_VfdInputs.Mode = 400                                          // If actual application mode is Auto ( 400 )
	        THEN
	            IF NOT #sx_RestartMan                                               // Manual was not activated
	                
	            THEN
	                #qUDT_VfdOutputs.SetpointSpeed := #iUDT_VfdConfig.VFDSpeed;   // Move speedsetpoint to output
	            ELSE                                                                // If manual was activated then
	                #qUDT_VfdOutputs.SetpointSpeed := #si_ManualSpeed;             // Move manual speedsetpoint to output
	            END_IF;
	            
	        ELSIF #iUDT_VfdInputs.Mode = 100                                       // If actual application mode is manual ( 100 )
	        THEN
	            
	            #qUDT_VfdOutputs.SetpointSpeed := #si_ManualSpeed;                 // Move manual speedsetpoint TO output
	            
	        END_IF;
	        
	    END_REGION
	    
	    
	    REGION 7.8 - Other control signals to VFD
	        
	        #qUDT_VfdOutputs.Control_Word_1.EnableRapidStop := (#sx_HardwareAvailable AND #iqUDT_VSUInterface.RunEnabled); // Writing states of VFD power is ready or simulation to enable VFD to run   
	        #qUDT_VfdOutputs.Control_Word_1.EnableApplicationStop := #sx_VFDReady AND ((NOT (#sdi_ActualPositionValue = #tdi_EncoderPositionSetpoint) AND #iqUDT_VSUInterface.Automatic) OR (#iqUDT_VSUInterface.Manual AND ((#iqUDT_VSUInterface.JogDown OR #iqUDT_VSUInterface.JogUp) OR #iqUDT_VSUInterface.Reference_command)));                             // Writing state to enable VFD operation  
	        #qUDT_VfdOutputs.Control_Word_1.ReleaseBrake := FALSE;                                             // Not used
	        #qUDT_VfdOutputs.Control_Word_1.ApplyRelativePositioning := FALSE;                                 // Not used for speed control 
	        #qUDT_VfdOutputs.Control_Word_1.StartStop := #sx_StartVFD;                                         // Writing state to start or stop VFD 
	        #qUDT_VfdOutputs.Control_Word_1.ResetError := #iqUDT_VSUInterface.InternalErrorReset;             // Reseting VFD errors with error reset bit 
	        #qUDT_VfdOutputs.Control_Word_1.ActivateDriveTrain2 := FALSE;                                      // Not used for MoviGear with on Drive Train 
	        #qUDT_VfdOutputs.Control_Word_1.DeactivateSW_LimitSwitch := FALSE;                                 // Not used 
	        #qUDT_VfdOutputs.Control_Word_1.ActivateInhibit := NOT #sx_VFDReady;                                // Controller Inhibit has to be "false" before start/stop
	        #qUDT_VfdOutputs.Control_Word_1.ActivateStandby := FALSE;                                          // Not used 
	        #qUDT_VfdOutputs.Control_Word_1.MovikitHandshakeIn := #sx_MovikitHandshakeIn;                      // Set "MoviKit" handshake input to 1 by 0.5 sec.
	        
	    END_REGION
	    
	    REGION 7.9 - Acceleration and deceleration ramps 
	        
	        #qUDT_VfdOutputs.SetpointAcceleration := #iUDT_VfdConfig.VFDAccDecel;
	        #qUDT_VfdOutputs.SetpointDeceleration := #iUDT_VfdConfig.VFDAccDecel;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 8 - In case of communication error reset VFD outputs
	    
	    IF NOT #sx_HardwareAvailable                                                                            // If hardware is not available
	        
	    THEN
	        
	        #qUDT_VfdOutputs.Control_Word_1.ResetError := FALSE;                                               // Reset reset VFD error 
	        #qUDT_VfdOutputs.Control_Word_1.ActivateDriveTrain2 := FALSE;                                      // Reset activate drive train 
	        #qUDT_VfdOutputs.Control_Word_1.DeactivateSW_LimitSwitch := FALSE;                                 // Reset deactivate software limit switch 
	        #qUDT_VfdOutputs.Control_Word_1.ActivateInhibit := FALSE;                                          // Reset activate inhibit
	        #qUDT_VfdOutputs.Control_Word_1.ActivateStandby := FALSE;                                          // Reset activate standby 
	        #qUDT_VfdOutputs.Control_Word_1.MovikitHandshakeIn := FALSE;                                       // Reset movikit hanshake input 
	        #qUDT_VfdOutputs.Control_Word_1.EnableRapidStop := FALSE;                                          // Reset enable rapid stop
	        #qUDT_VfdOutputs.Control_Word_1.EnableApplicationStop := FALSE;                                    // Reset enable application stop
	        #qUDT_VfdOutputs.Control_Word_1.ReleaseBrake := FALSE;                                             // Reset release brake
	        #qUDT_VfdOutputs.Control_Word_1.JogPos := FALSE;                                                   // Reset jog in positive direction 
	        #qUDT_VfdOutputs.Control_Word_1.JogNeg := FALSE;                                                   // Reset jog in negative direction
	        #qUDT_VfdOutputs.Control_Word_1.ApplyRelativePositioning := FALSE;                                 // Reset applying relatice positioning 
	        #qUDT_VfdOutputs.Control_Word_1.StartStop := FALSE;                                                // Reset Start/Stop VFD
	    END_IF;
	END_REGION
	
	REGION 9 - Statistics
	    
	    // Number OF times the VFD had an internal error
	    
	    #sR_TRIG_PNSlaveNotOnline(CLK := #sUDT_HMIStatus.PNSlaveNotOnline);       // Detect the rising edge of the error
	    
	    IF #iqUDT_VSUInterface.ResetStatistics OR                                  // If there is signal to reset statistics from VSU interface  
	        #sUDT_HMIStatus.PNSlaveNotOnline                                       // Or the error occured
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics,       // Reset statistics
	                        ix_Activate := #sUDT_HMIStatus.PNSlaveNotOnline,       // Actual error
	                        ix_RTrigActivate := #sR_TRIG_PNSlaveNotOnline.Q,       // Trigger rising edge error
	                        iqUDT_Statistics := #iqUDT_VFDStatistics.PNSlaveNotOnline);   // Statistics structure
	    END_IF;
	    
	    // Number of ethernet communication faults to VFD drive
	    
	    #sR_TRIG_PNSlaveError(CLK := #sUDT_HMIStatus.PNSlaveError);               // Detect the rising edge of the error
	    IF #iqUDT_VSUInterface.ResetStatistics OR                                  // If there is signal to reset statistics from VSU interface  
	        #sUDT_HMIStatus.PNSlaveError                                           // Or the error occured
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics,       // Reset statistics
	                        ix_Activate := #sUDT_HMIStatus.PNSlaveError,           // Actual error
	                        ix_RTrigActivate := #sR_TRIG_PNSlaveError.Q,           // Trigger rising edge error 
	                        iqUDT_Statistics := #iqUDT_VFDStatistics.PNSlaveError);       // Statistics structure
	        
	    END_IF;
	    
	    
	    // Number of times the VFD had an internal error
	    
	    #sR_TRIG_InternalError(CLK := #sUDT_HMIStatus.InternalError);             // Detect the rising edge of the error
	    
	    IF #iqUDT_VSUInterface.ResetStatistics OR                                  // IF there is signal TO reset statistics from VSU interface   
	        #sUDT_HMIStatus.InternalError                                          // Or the error occured
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics,       // Reset statistics
	                        ix_Activate := #sUDT_HMIStatus.InternalError,          // Actual error
	                        ix_RTrigActivate := #sR_TRIG_InternalError.Q,          // Trigger rising edge error
	                        iqUDT_Statistics := #iqUDT_VFDStatistics.VFDInternalError);       // Statistics structure
	        
	    END_IF;
	    
	    // Number OF times the VFD had a safety error
	    
	    #sR_TRIG_CommunicationErrorMovikit(CLK := #sUDT_HMIStatus.CommunicationErrorMovikit); // Detect the rising edge of the error
	    
	    IF #iqUDT_VSUInterface.ResetStatistics OR                                  // If there is signal to reset statistics from VSU interface  
	        #sUDT_HMIStatus.CommunicationErrorMovikit                              // Or the error occured
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics,       // Reset statistics
	                        ix_Activate := #sUDT_HMIStatus.CommunicationErrorMovikit,              // Actual error
	                        ix_RTrigActivate := #sR_TRIG_CommunicationErrorMovikit.Q,              // Trigger rising edge error
	                        iqUDT_Statistics := #iqUDT_VFDStatistics.CommunicationErrorMovikit);  // Statistics structure
	        
	    END_IF;
	    
	    // Number of times the VFD has been running
	    
	    #sR_TRIG_Running(CLK := #iUDT_VfdInputs.Status_Word_1.DriveActive);       // Detect the rising edge of the signal
	    
	    IF #iqUDT_VSUInterface.ResetStatistics OR                                  // If there is signal to reset statistics from VSU interface  
	        #iUDT_VfdInputs.Status_Word_1.STO_Inactive                             // Or the status occured
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics,       // Reset statistics
	                        ix_Activate := #iUDT_VfdInputs.Status_Word_1.DriveActive,  // Actual status
	                        ix_RTrigActivate := #sR_TRIG_Running.Q,                // Trigger rising edge 
	                        iqUDT_Statistics := #iqUDT_VFDStatistics.Running);    // Statistics structure
	        
	    END_IF;
	END_REGION
	
	REGION 10 - Write interface outputs
	    
	    //Internal Error
	    #iqUDT_VSUInterface.InternalErrorVFD := #sx_ErrorActive;                   // Set the internal VFD error bit in VSU interface IF Any fault is active 
	    
	    //Internal Warning
	    #iqUDT_VSUInterface.InternalWarningVFD := #sx_WarningActive;               // Set the internal VFD warning bit if any warning is active 
	    
	    //Motor running
	    #iqUDT_VSUInterface.MotorRunning := #iUDT_VfdInputs.Status_Word_1.DriveActive;    // Set motor is running in VSU interface IF status control Word "motor running" is active 
	    
	    //Send signal VFD is referenced
	    #iqUDT_VSUInterface.Referenced := #iUDT_VfdInputs.Status_Word_1.Referenced;       // Write state of drive is referenced from VFD to VSU interface 
	    
	    
	    #iqUDT_VSUInterface.Positioning := #iqUDT_VSUInterface.PositionSetpoint <> #iqUDT_VSUInterface.PositionActual  // Set the lifting device is positioning if position setpoint is different than actual position 
	    AND #iqUDT_VSUInterface.Automatic                                      // AND automatic mode enabled 
	    AND NOT #iqUDT_VSUInterface.InternalErrorVFD;                          // And internal error VFD no occurred  
	    
	    #iqUDT_VSUInterface.StartLowSpeed := #sx_RestartMan;                       // Indicating to VSU the VSD is starting in low speed
	    
	    #qUDT_HMIStatus := #sUDT_HMIStatus;                                       // Copy status to output
	END_REGION
	
	REGION 11 - error codes
	    (*
	    FCB number |                       | Meaning
	    ______________________________________________________________________________________________________________
	        1                               Output stage inhibit 
	        2                               Default stop
	        4                               Manual Mode
	        5                               Speed control
	                101                     Speed-controlled jogging. Encoder feedback NOT required.
	                200                     Speed control. Encoder feedback NOT required.
	        6                               Interpolated speed control
	        7                               Torque control
	        8                               Interpolated torque control
	        9                               Positioning mode
	                400                     Absolute position control
	                401                     Relative position control
	                402                     Modulo position control - positive
	                403                     Modulo position control - negative
	                404                     Modulo position control - shortest distance
	        10                              Interpolated position control
	        12                              Referencing mode
	                300                     Reference travel - offset via parameter
	                301                     Reference travel - offset via fieldbus
	        13                              Stop at application limits
	        14                              Emergency stop
	        18                              Rotor position identification
	        19                              Position hold control
	        20                              Jog mode
	                100                     Position-controlled jogging. Encoder feedback required
	        21                              Brake test
	        25                              Motor parameter measurement
	        26                              Stop at user limits
	              
	    
	    Error code | Suberror code        | Meaning                                | Measure  
	    ______________________________________________________________________________________________________________
	        3       1                       Ground fault                            Consult "Fault table" in  
	        4       1                       Brake chopper fault                     document 'SEW Movigear-C 25887130.PDF'
	        6       1                       Line fault                              Chapter 8.7
	        7       1                       DC link fault
	        8       1,2,3                   Speed monitoring fault
	        9       1,2,5,6,9,10            Control mode fault
	        10      1,3-11                  Data flexibility fault
	        11      1-6                     Temperature monitoring fault
	        12      1,2                     Fault brake
	        13      5,24                    Encoder 1 fault
	        16      5-8,10,20-27            Startup fault
	        19      1-9                     Process data fault
	        20      2,11                    Fault device monitoring
	        23      4                       Power section fault
	        25      2-7,20,21,30,31,61,70   Parameter memory monitoring
	        26      1,3                     External fault
	        28      1-12,14                 FCB drive function fault
	        29      1-4                     Hardware limit switch fault
	        30      1-3                     Software limit switch fault
	        31      1-4,7,9                 Thermal protection fault
	        32      2-6,12                  Communication fault
	        33      11,12,13                system initialisation fault
	        34      1                       Process data configuration fault
	        35      1-5                     Function activation fault
	        42      1-3                     Lag fault
	        46      2,3,50,51,52            Safety card fault
	        51      1                       Analog processing fault
	    
	    Error code | Suberror code        | Meaning                                | Measure  
	    ______________________________________________________________________________________________________________
	        1       1,2                     Output stage monitoring fault           Contact SEW-Eurodrive Service       
	        4       2                       Brake chopper fault
	        7       2                       DC link fault
	        9       3,4,8                   Control mode fault
	        10      2,99                    Data flexibility fault
	        11      7,8                     Temperature monitoring fault
	        13      1,3,6,7.8,9,11,13,      Encoder 1 fault
	                15,22,23                
	        16      2,11,12,30              Startup fault
	        17      7                       Internal processor fault
	        18      1,3,4,7,8,9,10,12,13    Software fault
	        20      1,7                     Fault device monitoring
	        21      1                       S-Drive 1 fault
	        23      5,6,7,8                 Power section fault
	        25      10,12-19,50,51,81       Parameter memory monitoring
	        28      13                      FCB drive funcyio fault
	        33      1,2,6,7,8,10            System initialisation fault
	        46      1                       Safety card fault
	        
	    Function Control Block (FCB) codes
	    FBC = 01 Output stage inhibit 
	    FBC = 02 Default stop
	    FBC = 04 Manual Mode
	    FBC = 05 Speed control
	     101 - Speed-controlled jogging. Encoder feedback NOT required.
	     200 - Speed control. Encoder feedback NOT required.
	    FBC = 06 Interpolated speed control
	    FBC = 07 Torque control
	    FBC = 08 Interpolated torque control
	    FBC = 09 Positioning mode
	    400 - Absolute position control
	    401 - Relative position control
	    402 - Modulo position control - positive
	    403 - Modulo position control - negative
	    404 - Modulo position control - shortest distance
	    FBC = 10 Interpolated position control
	    FBC = 12 Referencing mode
	    300 - Reference travel - offset via parameter
	    301 - Reference travel - offset via fieldbus
	    FBC = 13 Stop at application limits
	    FBC = 14 Emergency stop
	    FBC = 18 Rotor position identification
	    FBC = 19 Position hold control
	    FBC = 20 Jog mode
	     100 - Position-controlled jogging. Encoder feedback required
	    FBC = 21 Brake test
	    FBC = 25 Motor parameter measurement
	    FBC = 26 Stop at user limits
	    
	    *)
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_VfdSEWMOVI-CSpeed"
TITLE = FB_VFD_SEW_MOVI-C_Speed
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 37
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_VfdConfig { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdConfiguration";   //    Configuration structure
      iUDT_VfdInputs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdSEWSpeedPI";   //    VFD inputs structure
      ix_PowerOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    True = External Power OK
      ix_SimulationModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    True = Simulation mode active
      ix_QuickStopDisable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;   //    True = Quick Stop not enabled
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdStatus";   //    HMI status structure
      qUDT_VfdOutputs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdSEWSpeedPO";   //    VFD outputs structure
   END_VAR

   VAR_IN_OUT 
      iqUDT_ConveyorInterface : "UDT_ConveyorInterface";   //    Conveyor interface structure
      iqUDT_VfdStatistics : "UDT_VfdStatistics";   //    Statistics structure
   END_VAR

   VAR 
      sUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatus";   //    HMI status structure
      sUDT_PNDevice { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PNDevice";   //    PN device info structure
      sFB_TimerOnOffDelayCheckSupply { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //    MHS "TimerOnOffDelay" - to delay time for VFD supply contactor
      sFB_TimerOnOffDelayMoviKit { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //    MHS "TimerOnOffDelay" - to delay time for MoviKit response delay error
      sFB_TimerOnOffDelayVFDRunningFeedbackError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //    MHS "TimerOnOffDelay" - to delay time for VFDRunningFeedback error
      sR_TRIG_RunFWD {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //    Rising edge of Run forward signal
      sR_TRIG_RunRVS {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //    Rising edge of Run reverse
      sR_TRIG_PNSlaveNotOnline {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //    Rising edge for trigger Profinet slave not online statistics
      sR_TRIG_PNSlaveError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //    Rising edge for trigger Profinet slave error statistics
      sR_TRIG_InternalError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //    Rising edge for trigger Internal VFD Error statistics
      sR_TRIG_CommunicationErrorMovikit {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //    Rising edge for trigger communication error Movikit statistics
      sR_TRIG_Running {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //    Rising edge for starting of the running signal
      sF_TRIG_RunFwd {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //    Falling edge for run forward signal
      sF_TRIG_RunRvs {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //    Falling edge for run reverse signal
      sa_PNPortsStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..8] of Bool;   // TRUE when specific port has an error
      sr_ActualSpeedSetpoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   //    Actual speed setpoint [RPM]
      si_ActualSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //    Actual speed in [mm/s]
      sx_ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Commissioning: configuration error
      sx_PNDeviceHealthy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Profinet device is online and error free
      sx_MoviKitFeedback { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Movikit feedback delay
      sx_HardwareAvailable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Power and communication to drive are ok
      sx_PowerOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Communication, safety and power are available
      sx_VfdAvailable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Hardware of VFD is ok and no communication error with movikit
      sx_ErrorActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Block has an error
      sx_EnableOperation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Enable operation signal
      sx_RunVfdForward { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Start VFD forward
      sx_RunVfdReverse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Start VFD backward
      sx_SpeedSetpointReached { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Motor is running at requested speed
      sx_VfdStopping { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    VFD Stopping
      sx_MovikitHandshakeIn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Handshake to movikit
   END_VAR

   VAR CONSTANT 
      ci_NumberOfProfinetPorts : Int := 2;   // Number of Profinet ports in device
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | P. Majka      | First release MHS TIA 15.1
	24/07/2019  | 0.2       | K. Pokorski   | Autofind device is Profinet structure (Region 2)
	30/07/2019  | 0.3       | M. Kurc       | Add MoviKit error
	30/07/2019  | 2.0       | P. Majka      | Moved to project with library 2.0
	16/08/2019  | 2.1       | T.v.Beukering | Updated complete block
	03/10/2019  | 2.2       | F.Baten       | Applied FC_GetDevicePN, added running statistics, changed speed window from UInt to Int, added actual speed in conveyor interface. 
	11/10/2019  | 2.3       | M. Kurc       | Added VFD stop signal when occurs both run request (FWD, RVS), added logic for QuickSTOP, added interclok FDW/RVS 
	20/11/2019  | 2.10      | S. Nikodem    | Configuration error
	20/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	03/12/2019  | 3.1       | S. Nikodem    | Change of direction 
	20/12/2019  | 3.2       | S. Deulkar    | Used configureation error bit to report to conveyor block 
	06/02/2020  | 3.3       | S. Nikodem    | Configuration error - Simulation mode bypass PNDeviceFound
	01/03/2020  | 3.4       | F.Baten       | Changed "UDT_VFD_Status" to be without positioning status
	04/03/2020  | 3.5       | F.Baten       | Output speed scaling based on measured speed at fixed output value, removal of gearratio and wheelendperrimeter
	01/05/2020  | 3.7       | F.Baten       | Reverted 3.6 modification measured speed
	14/09/2020  | 3.8       | S.Nikodem     | VFDRunningFeedback error 
	03/11/2020  | 3.9       | K.Pokorski    | Profinet ports diagnostics added 
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Get Device Profinet information
	    
	    "FC_GetDevicePN"(is_PNDeviceName := #iUDT_VfdConfig.VFDPNDeviceName,
	                     ix_SimulationModeActive := #ix_SimulationModeActive,
	                     iqUDT_PND := #sUDT_PNDevice);
	    
	    
	    "FC_GetPNPortStatus"(ii_NumberOfPorts := #ci_NumberOfProfinetPorts,
	                         iUDT_DevicePNInfo := #sUDT_PNDevice,
	                         qa_PortFault => #sa_PNPortsStatus);
	    
	END_REGION
	
	REGION 2 - Reset errors
	    
	    IF #iqUDT_ConveyorInterface.InternalErrorReset                           // Reset errors when reset signal is given
	    THEN
	        #sUDT_HMIStatus.CommunicationErrorMovikit := FALSE;
	        #sUDT_HMIStatus.PNSlaveNotonline := FALSE;
	        #sUDT_HMIStatus.PNSlaveError := FALSE;
	        #sUDT_HMIStatus.InternalError := FALSE;
	        #sUDT_HMIStatus.VFDRunningFeedbackError := FALSE;
	        #sUDT_HMIStatus.PNSlaveWarning := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Hardware checks
	    // Hardware will only be available after the delay, so the device has time for the initialisation
	    #sFB_TimerOnOffDelayCheckSupply(iudi_OnDelayTime := 2000,
	                                    ix_SignalToDelay := #ix_PowerOK);
	    
	    #sx_PowerOk := #sFB_TimerOnOffDelayCheckSupply.qx_DelayedSignal;
	    
	    // Check if PN device is online
	    IF NOT "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.Exist
	        AND NOT #ix_SimulationModeActive
	        AND #sx_PowerOk
	    THEN
	        #sUDT_HMIStatus.PNSlaveNotonline := TRUE;
	    END_IF;
	    
	    
	    // Check if PN ports are healthy 
	    IF #sa_PNPortsStatus[1] XOR #sa_PNPortsStatus[2] THEN
	        #sUDT_HMIStatus.PNSlaveWarning := TRUE;
	    END_IF;
	    
	    // Check if PN device has an error
	    IF "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.Error
	        AND NOT #ix_SimulationModeActive
	        AND #sx_PowerOk
	        AND NOT #sUDT_HMIStatus.PNSlaveWarning
	    THEN
	        #sUDT_HMIStatus.PNSlaveError := TRUE;
	    END_IF;
	    
	    // Set bit when PN device is healthy (online and no error)
	    #sx_PNDeviceHealthy := NOT #sUDT_HMIStatus.PNSlaveNotonline
	    AND NOT #sUDT_HMIStatus.PNSlaveError
	    AND #sUDT_PNDevice.PNDeviceFound
	    AND #sx_PowerOk;
	    
	    // Set hardware available bit when all conditions are met
	    #sx_HardwareAvailable := (#iUDT_VfdInputs.Status_Word_1.STO_Inactive
	    AND #sx_PowerOk
	    AND #sx_PNDeviceHealthy)
	    OR #ix_SimulationModeActive;
	    
	    // Check MoviKit communication (heartbeat)
	    #sx_MoviKitFeedback := ((#sx_MovikitHandshakeIn
	    AND NOT #iUDT_VfdInputs.Status_Word_1.MovikitHandshakeOut)
	    OR (NOT #sx_MovikitHandshakeIn
	    AND #iUDT_VfdInputs.Status_Word_1.MovikitHandshakeOut));
	    
	    #sFB_TimerOnOffDelayMoviKit(iudi_OnDelayTime := 1000,
	                                ix_SignalToDelay := NOT #sx_MoviKitFeedback);
	    
	    // Set error when MoviKit communication is not available
	    IF #sFB_TimerOnOffDelayMoviKit.qx_DelayedSignal AND #sx_HardwareAvailable
	    THEN
	        
	        #sUDT_HMIStatus.CommunicationErrorMovikit := TRUE;
	        
	    END_IF;
	    
	    // Invert output when input is equal 
	    #sx_MovikitHandshakeIn := NOT #iUDT_VfdInputs.Status_Word_1.MovikitHandshakeOut;
	    
	    // VFD is ready for operation if hardware ok and no communication error with Movikit
	    #sx_VfdAvailable := #sx_HardwareAvailable AND NOT #sUDT_HMIStatus.CommunicationErrorMovikit;
	    
	END_REGION
	
	REGION 4 - Check errors and warnings 
	    // Check if the VFD has an error
	    #sUDT_HMIStatus.InternalError := #iUDT_VfdInputs.Status_Word_1.Error;
	    
	    // Check if the VFD has a warning
	    #sUDT_HMIStatus.InternalWarning := #iUDT_VfdInputs.Status_Word_1.Warning;
	    
	    // Copy error/warning code to status DB when error/warning active
	    IF NOT #iUDT_VfdInputs.Status_Word_1.Error
	        AND NOT #iUDT_VfdInputs.Status_Word_1.Warning
	    THEN
	        #sUDT_HMIStatus.ErrorCode := 0;
	        #sUDT_HMIStatus.SubErrorCode := 0;
	    ELSE
	        #sUDT_HMIStatus.ErrorCode := #iUDT_VfdInputs.StatusErrorNo.%B1;
	        #sUDT_HMIStatus.SubErrorCode := #iUDT_VfdInputs.StatusErrorNo.%B0;
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Check if configuration is ok for commissioning purposes
	    // Set configuration error when one or all VFD configuration parameters aren't set
	    IF #iUDT_VfdConfig.WheelEndPerimeter > 0.0
	        AND #iUDT_VfdConfig.GearRatio > 0.0
	        AND #iUDT_VfdConfig.ReferenceRPM > 0.0
	        AND #iUDT_VfdConfig.VFDStartupTime > 0.0
	        AND (#sUDT_PNDevice.PNDeviceFound
	        OR #ix_SimulationModeActive)
	    THEN
	        #sx_ConfigurationError := FALSE;
	    ELSE
	        #sx_ConfigurationError := TRUE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Handle speed  
	    // Calculate speed in mm/s                                                                                                         
	    #si_ActualSpeed := REAL_TO_INT(((#iUDT_VfdInputs.ActualSpeed / #iUDT_VfdConfig.GearRatio) * #iUDT_VfdConfig.WheelEndPerimeter) / 60.0);
	    
	    // Reversal direction speed
	    IF #iUDT_VfdConfig.DirectionReversal
	    THEN
	        #si_ActualSpeed := #si_ActualSpeed * -1;
	        
	    END_IF;
	    
	    // Actual speed setpoint
	    #sr_ActualSpeedSetpoint := ((DINT_TO_REAL(INT_TO_DINT(#iqUDT_ConveyorInterface.SpeedSetpoint) * 60) / #iUDT_VfdConfig.WheelEndPerimeter) * #iUDT_VfdConfig.GearRatio);
	    
	    // Check maximum output
	    IF
	        #sr_ActualSpeedSetpoint > #iUDT_VfdConfig.ReferenceRPM
	    THEN
	        #sr_ActualSpeedSetpoint := #iUDT_VfdConfig.ReferenceRPM;
	    END_IF;
	    
	    
	    //Check if speed setpoint is reached                                 
	    #sx_SpeedSetpointReached := (ABS(#si_ActualSpeed) >= (#iqUDT_ConveyorInterface.SpeedSetpoint - #iUDT_VfdConfig.SpeedSetpointWindow))
	    AND (ABS(#si_ActualSpeed) <= (#iqUDT_ConveyorInterface.SpeedSetpoint + #iUDT_VfdConfig.SpeedSetpointWindow));
	    
	    
	END_REGION
	
	REGION 7 - Prepare output data VFD
	    
	    REGION 7.1 - Set speed setpoint in forward and reverse direction 
	        
	        #sR_TRIG_RunFWD(CLK := #iqUDT_ConveyorInterface.RunFwd);     // Get rising edge of Run forward signal
	        #sR_TRIG_RunRVS(CLK := #iqUDT_ConveyorInterface.RunRvs);     // Get rising edge of Run reverse signal
	        
	        // When rising edge of the forward of reverse signal is received, the drive has to stop to be able to make the switch
	        IF #sR_TRIG_RunFWD.Q OR #sR_TRIG_RunRVS.Q
	        THEN
	            #qUDT_VfdOutputs.SetpointSpeed := 0;
	            
	        END_IF;
	        
	        // If motor stopped and Run forward is requested and forward direction is interlock, the speed setpoint is loaded to run forward.
	        IF (#iqUDT_ConveyorInterface.RunFwd) AND #iUDT_VfdConfig.InterlockFwd //(#i_UDT_VFDInputs.ActualSpeed = 0) AND 
	        THEN
	            #sx_RunVfdForward := TRUE;
	            #sx_RunVfdReverse := FALSE;
	        END_IF;
	        
	        // If motor stopped and Run reverse is requested and reverse direction is interlock, the speed setpoint is loaded to run forward.
	        IF (#iUDT_VfdInputs.ActualSpeed = 0) AND #iqUDT_ConveyorInterface.RunRvs AND #iUDT_VfdConfig.InterlockRvs
	        THEN
	            #sx_RunVfdReverse := TRUE;
	            #sx_RunVfdForward := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 7.2 - Stopping
	        
	        // Create trigger when direction signal falling
	        #sF_TRIG_RunFwd(CLK := #iqUDT_ConveyorInterface.RunFwd);
	        #sF_TRIG_RunRvs(CLK := #iqUDT_ConveyorInterface.RunRvs);
	        
	        // When no run signal or above run signal are given or drive is running and no occurs interlock (in specific direction) the VFD should stop
	        IF (NOT #iqUDT_ConveyorInterface.RunRvs AND NOT #iqUDT_ConveyorInterface.RunFwd)
	            OR (#iqUDT_ConveyorInterface.RunRvs AND #iqUDT_ConveyorInterface.RunFwd)
	            OR (#sx_RunVfdReverse AND NOT #iUDT_VfdConfig.InterlockRvs)
	            OR (#sx_RunVfdForward AND NOT #iUDT_VfdConfig.InterlockFwd)
	            OR #sF_TRIG_RunRvs.Q
	            OR #sF_TRIG_RunFwd.Q
	            
	        THEN
	            #sx_RunVfdReverse := FALSE;
	            #sx_RunVfdForward := FALSE;
	        END_IF;
	        
	        IF NOT #sx_RunVfdReverse AND NOT #sx_RunVfdForward AND (#iUDT_VfdInputs.ActualSpeed <> 0)
	        THEN
	            #sx_VfdStopping := TRUE;
	        ELSE
	            #sx_VfdStopping := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 7.3 - Check for enable operation signal
	        
	        #sx_EnableOperation := #sx_VfdAvailable AND NOT #sx_ConfigurationError AND (#sx_RunVfdForward OR #sx_RunVfdReverse) OR #iqUDT_ConveyorInterface.VFDRunning;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 8 - Write outputs to VFD  
	    
	    REGION 8.1 - Write control word 1
	        
	        #qUDT_VfdOutputs.Control_Word_1.EnableRapidStop := #ix_QuickStopDisable;                       // Writing state to enable VFD to run
	        #qUDT_VfdOutputs.Control_Word_1.EnableApplicationStop := #sx_EnableOperation;                  // Writing state to Enable VFD operation   
	        #qUDT_VfdOutputs.Control_Word_1.ReleaseBrake := FALSE;                                         // Not used 
	        #qUDT_VfdOutputs.Control_Word_1.JogPos := FALSE;                                               // Not used
	        #qUDT_VfdOutputs.Control_Word_1.JogNeg := FALSE;                                               // Not used
	        #qUDT_VfdOutputs.Control_Word_1.ApplyRelativePositioning := FALSE;                             // Not used for speed control
	        #qUDT_VfdOutputs.Control_Word_1.StartStop := #sx_EnableOperation;                              // Writing state to start or stop VFD 
	        #qUDT_VfdOutputs.Control_Word_1.ResetError := #iqUDT_ConveyorInterface.InternalErrorReset;    // Reseting VFD errors with error reset bit 
	        #qUDT_VfdOutputs.Control_Word_1.ActivateDriveTrain2 := FALSE;                                  // Not used for MoviGear with one Drive Train   
	        #qUDT_VfdOutputs.Control_Word_1.DeactivateSW_LimitSwitch := FALSE;                             // Not used
	        #qUDT_VfdOutputs.Control_Word_1.ActivateInhibit := NOT #sx_EnableOperation;                    // Controller Inhibit has TO be "false" before start/stop
	        #qUDT_VfdOutputs.Control_Word_1.ActivateStandby := FALSE;                                      // Not used
	        #qUDT_VfdOutputs.Control_Word_1.MovikitHandshakeIn := #sx_MovikitHandshakeIn;                  // MoviKit handshake controlled BY 0.5 Hz 
	        
	        // If hardware is unavailable clear the control word
	        IF NOT #sx_VfdAvailable
	        THEN
	            #qUDT_VfdOutputs.Control_Word_1.EnableRapidStop := FALSE;                                  // Writing state to enable VFD to run
	            #qUDT_VfdOutputs.Control_Word_1.EnableApplicationStop := FALSE;                            // Writing state to Enable VFD operation   
	            #qUDT_VfdOutputs.Control_Word_1.ReleaseBrake := FALSE;                                     // Not used 
	            #qUDT_VfdOutputs.Control_Word_1.JogPos := FALSE;                                           // Not used
	            #qUDT_VfdOutputs.Control_Word_1.JogNeg := FALSE;                                           // Not used
	            #qUDT_VfdOutputs.Control_Word_1.ApplyRelativePositioning := FALSE;                         // NOT used FOR speed control
	            #qUDT_VfdOutputs.Control_Word_1.StartStop := FALSE;                                        // Writing state to start or stop VFD 
	            #qUDT_VfdOutputs.Control_Word_1.ResetError := FALSE;                                       // Reseting VFD errors with error reset bit 
	            #qUDT_VfdOutputs.Control_Word_1.ActivateDriveTrain2 := FALSE;                              // Not used for MoviGear with one Drive Train   
	            #qUDT_VfdOutputs.Control_Word_1.DeactivateSW_LimitSwitch := FALSE;                         // Not used
	            #qUDT_VfdOutputs.Control_Word_1.ActivateInhibit := FALSE;                                  // Controller Inhibit has TO be "false" before start/stop
	            #qUDT_VfdOutputs.Control_Word_1.ActivateStandby := FALSE;                                  // Not used
	            #qUDT_VfdOutputs.Control_Word_1.MovikitHandshakeIn := FALSE;                               // MoviKit handshake controlled BY 0.5 Hz 
	            #qUDT_VfdOutputs.Control_Word_1.BIT_02_Reserved := FALSE;
	            #qUDT_VfdOutputs.Control_Word_1.BIT_09_Reserved := FALSE;
	            #qUDT_VfdOutputs.Control_Word_1.BIT_11_Reserved := FALSE;
	            
	        END_IF;
	    END_REGION
	    
	    REGION 8.2 - Write speed setpoint to drive
	        // The conveyor stopped and may now run in forward direction
	        IF (#sx_RunVfdForward AND NOT #iUDT_VfdConfig.DirectionReversal)
	            OR (#sx_RunVfdReverse AND #iUDT_VfdConfig.DirectionReversal)
	        THEN
	            #qUDT_VfdOutputs.SetpointSpeed := REAL_TO_INT(#sr_ActualSpeedSetpoint);
	        END_IF;
	        
	        // The conveyor stopped and may now run in reverse direction
	        IF (#sx_RunVfdReverse AND NOT #iUDT_VfdConfig.DirectionReversal)
	            OR (#sx_RunVfdForward AND #iUDT_VfdConfig.DirectionReversal)
	            
	        THEN
	            #qUDT_VfdOutputs.SetpointSpeed := REAL_TO_INT(#sr_ActualSpeedSetpoint * -1);
	        END_IF;
	        
	        // Clear speed setpoint when no run request
	        IF NOT #sx_RunVfdForward AND NOT #sx_RunVfdReverse
	        THEN
	            #qUDT_VfdOutputs.SetpointSpeed := 0;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 8.3 - Write acceleration and deceleration value to drive
	        // Write deceleration value to VFD
	        #qUDT_VfdOutputs.SetpointAcceleration := REAL_TO_INT(#iUDT_VfdConfig.ReferenceRPM / (UDINT_TO_REAL(#iUDT_VfdConfig.VFDRampUpTime) / 1000.0));        //Recalculating Acceleration ramp - deviding maximum configured speed by Ramp up time and devide it by 1000
	        
	        // Write deceleration value to VFD
	        #qUDT_VfdOutputs.SetpointDeceleration := REAL_TO_INT(#iUDT_VfdConfig.ReferenceRPM / (UDINT_TO_REAL(#iUDT_VfdConfig.VFDRampDownTime) / 1000.0));      //Recalculating Deceleration ramp - deviding maximum configured speed by Ramp down time and devide it by 1000
	        
	    END_REGION
	    
	END_REGION
	
	REGION 9 - Check if motor is running
	    
	    //The moto should start running after specific time. If nit the VFDRunningFeedback error occured
	    #sFB_TimerOnOffDelayVFDRunningFeedbackError(iudi_OnDelayTime := #iUDT_VfdConfig.VFDStartupTime,
	                                                ix_SignalToDelay := #sx_EnableOperation AND NOT (#si_ActualSpeed <> 0));
	    
	    IF #sFB_TimerOnOffDelayVFDRunningFeedbackError.qx_DelayedSignal THEN
	        
	        #sUDT_HMIStatus.VFDRunningFeedbackError := TRUE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 10 - Copy signals to interface DB and to status output UDT
	    // Create internal error status
	    #sx_ErrorActive := #sUDT_HMIStatus.PNSlaveNotonline
	    OR #sUDT_HMIStatus.PNSlaveError
	    OR #sUDT_HMIStatus.InternalError
	    OR #sUDT_HMIStatus.CommunicationErrorMovikit
	    OR #sUDT_HMIStatus.VFDRunningFeedbackError;
	    
	    // Write interface bits
	    #iqUDT_ConveyorInterface.VFDRunning := #iUDT_VfdInputs.Status_Word_1.DriveActive AND #sx_VfdAvailable AND #iqUDT_ConveyorInterface.ActualSpeed <> 0;        // Write true on output Conveyor interface structure if VFD is in operation and motor is turning 
	    #iqUDT_ConveyorInterface.VFDatSpeed := #sx_SpeedSetpointReached AND #sx_VfdAvailable;                                                                         // Copy setpoint speed reached state from static  to the output conveyor interface structure 
	    #iqUDT_ConveyorInterface.InternalWarningVFD := #iUDT_VfdInputs.Status_Word_1.Warning;                                                                         // Set the internal VFD warning bit if any warning is active 
	    #iqUDT_ConveyorInterface.InternalErrorVFD := #sx_ErrorActive;                                                                                                  // Set the internal VFD error bit if any fault is active 
	    #iqUDT_ConveyorInterface.ActualSpeed := #si_ActualSpeed;                                                                                                       // Copy the calculated value to the output
	    #iqUDT_ConveyorInterface.ConfigurationError := #iqUDT_ConveyorInterface.ConfigurationError OR #sx_ConfigurationError;
	    
	    // Copy error status to output
	    #qUDT_HMIStatus := #sUDT_HMIStatus;
	END_REGION
	
	REGION 11 - Statistics
	    // Create trigger on error and create statistics for profinet slave not online
	    #sR_TRIG_PNSlaveNotOnline(CLK := #sUDT_HMIStatus.PNSlaveNotonline);                              // Detect the rising edge of the error
	    
	    IF #iqUDT_ConveyorInterface.ResetStatistics OR #sUDT_HMIStatus.PNSlaveNotonline
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #sUDT_HMIStatus.PNSlaveNotonline,
	                        ix_RTrigActivate := #sR_TRIG_PNSlaveNotOnline.Q,
	                        iqUDT_Statistics := #iqUDT_VfdStatistics.PNSlaveNotOnline);
	    END_IF;
	    
	    // Create trigger on error and create statistics for profinet slave error
	    #sR_TRIG_PNSlaveError(CLK := #sUDT_HMIStatus.PNSlaveError);                                      // Detect the rising edge of the error
	    
	    IF #iqUDT_ConveyorInterface.ResetStatistics OR #sUDT_HMIStatus.PNSlaveError
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #sUDT_HMIStatus.PNSlaveError,
	                        ix_RTrigActivate := #sR_TRIG_PNSlaveError.Q,
	                        iqUDT_Statistics := #iqUDT_VfdStatistics.PNSlaveError);
	    END_IF;
	    
	    // Create trigger on error and create statistics for internal VFD Error
	    #sR_TRIG_InternalError(CLK := #sUDT_HMIStatus.InternalError);                                    // Detect the rising edge of the error
	    
	    IF #iqUDT_ConveyorInterface.ResetStatistics OR #sUDT_HMIStatus.InternalError
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #sUDT_HMIStatus.InternalError,
	                        ix_RTrigActivate := #sR_TRIG_InternalError.Q,
	                        iqUDT_Statistics := #iqUDT_VfdStatistics.VFDInternalError);
	    END_IF;
	    
	    // Create trigger on error and create statistics for Movikit communication error
	    #sR_TRIG_CommunicationErrorMovikit(CLK := #sUDT_HMIStatus.CommunicationErrorMovikit);            // Detect the rising edge of the error
	    
	    IF #iqUDT_ConveyorInterface.ResetStatistics OR #sUDT_HMIStatus.CommunicationErrorMovikit
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #sUDT_HMIStatus.CommunicationErrorMovikit,
	                        ix_RTrigActivate := #sR_TRIG_CommunicationErrorMovikit.Q,
	                        iqUDT_Statistics := #iqUDT_VfdStatistics.CommunicationErrorMovikit);
	    END_IF;
	    
	    // Create trigger on running signal and create statistics for running status
	    #sR_TRIG_Running(CLK := #iqUDT_ConveyorInterface.VFDRunning);                                 // Detect the rising edge of the signal
	    
	    IF #iqUDT_ConveyorInterface.ResetStatistics OR #iqUDT_ConveyorInterface.VFDRunning
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #iqUDT_ConveyorInterface.VFDRunning,
	                        ix_RTrigActivate := #sR_TRIG_Running.Q,
	                        iqUDT_Statistics := #iqUDT_VfdStatistics.Running);
	    END_IF;
	END_REGION
	
	REGION 12 - VFD codes
	    (*
	    FCB number |                       | Meaning
	    ______________________________________________________________________________________________________________
	        1                               Output stage inhibit 
	        2                               Default stop
	        4                               Manual Mode
	        5                               Speed control
	                101                     Speed-controlled jogging. Encoder feedback NOT required.
	                200                     Speed control. Encoder feedback NOT required.
	        6                               Interpolated speed control
	        7                               Torque control
	        8                               Interpolated torque control
	        9                               Positioning mode
	                400                     Absolute position control
	                401                     Relative position control
	                402                     Modulo position control - positive
	                403                     Modulo position control - negative
	                404                     Modulo position control - shortest distance
	        10                              Interpolated position control
	        12                              Referencing mode
	                300                     Reference travel - offset via parameter
	                301                     Reference travel - offset via fieldbus
	        13                              Stop at application limits
	        14                              Emergency stop
	        18                              Rotor position identification
	        19                              Position hold control
	        20                              Jog mode
	                100                     Position-controlled jogging. Encoder feedback required
	        21                              Brake test
	        25                              Motor parameter measurement
	        26                              Stop at user limits
	                    
	    Error code | Suberror code        | Meaning                                | Measure  
	    ______________________________________________________________________________________________________________
	        3       1                       Ground fault                            Consult "Fault table" in  
	        4       1                       Brake chopper fault                     document 'SEW Movigear-C 25887130.PDF'
	        6       1                       Line fault                              Chapter 8.7
	        7       1                       DC link fault
	        8       1,2,3                   Speed monitoring fault
	        9       1,2,5,6,9,10            Control mode fault
	        10      1,3-11                  Data flexibility fault
	        11      1-6                     Temperature monitoring fault
	        12      1,2                     Fault brake
	        13      5,24                    Encoder 1 fault
	        16      5-8,10,20-27            Startup fault
	        19      1-9                     Process data fault
	        20      2,11                    Fault device monitoring
	        23      4                       Power section fault
	        25      2-7,20,21,30,31,61,70   Parameter memory monitoring
	        26      1,3                     External fault
	        28      1-12,14                 FCB drive function fault
	        29      1-4                     Hardware limit switch fault
	        30      1-3                     Software limit switch fault
	        31      1-4,7,9                 Thermal protection fault
	        32      2-6,12                  Communication fault
	        33      11,12,13                system initialisation fault
	        34      1                       Process data configuration fault
	        35      1-5                     Function activation fault
	        42      1-3                     Lag fault
	        46      2,3,50,51,52            Safety card fault
	        51      1                       Analog processing fault
	    
	    Error code | Suberror code        | Meaning                                | Measure  
	    ______________________________________________________________________________________________________________
	        1       1,2                     Output stage monitoring fault           Contact SEW-Eurodrive Service       
	        4       2                       Brake chopper fault
	        7       2                       DC link fault
	        9       3,4,8                   Control mode fault
	        10      2,99                    Data flexibility fault
	        11      7,8                     Temperature monitoring fault
	        13      1,3,6,7.8,9,11,13,      Encoder 1 fault
	                15,22,23                
	        16      2,11,12,30              Startup fault
	        17      7                       Internal processor fault
	        18      1,3,4,7,8,9,10,12,13    Software fault
	        20      1,7                     Fault device monitoring
	        21      1                       S-Drive 1 fault
	        23      5,6,7,8                 Power section fault
	        25      10,12-19,50,51,81       Parameter memory monitoring
	        28      13                      FCB drive funcyio fault
	        33      1,2,6,7,8,10            System initialisation fault
	        46      1                       Safety card fault
	        
	    Function Control Block (FCB) codes
	    FBC = 01 Output stage inhibit 
	    FBC = 02 Default stop
	    FBC = 04 Manual Mode
	    FBC = 05 Speed control
	     101 - Speed-controlled jogging. Encoder feedback NOT required.
	     200 - Speed control. Encoder feedback NOT required.
	    FBC = 06 Interpolated speed control
	    FBC = 07 Torque control
	    FBC = 08 Interpolated torque control
	    FBC = 09 Positioning mode
	    400 - Absolute position control
	    401 - Relative position control
	    402 - Modulo position control - positive
	    403 - Modulo position control - negative
	    404 - Modulo position control - shortest distance
	    FBC = 10 Interpolated position control
	    FBC = 12 Referencing mode
	    300 - Reference travel - offset via parameter
	    301 - Reference travel - offset via fieldbus
	    FBC = 13 Stop at application limits
	    FBC = 14 Emergency stop
	    FBC = 18 Rotor position identification
	    FBC = 19 Position hold control
	    FBC = 20 Jog mode
	     100 - Position-controlled jogging. Encoder feedback required
	    FBC = 21 Brake test
	    FBC = 25 Motor parameter measurement
	    FBC = 26 Stop at user limits
	    
	    *)
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_VfdSiemensG120X"
TITLE = FB_VFD_Siemens_G120X
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 39
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_VfdConfig { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdConfiguration";   //   Configuration structure
      iUDT_VfdInputs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdSiemensPI";   //   VFD inputs structure
      iUDT_MotorData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_MotorData";
      ix_24vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when 24VDC is healthy
      ix_400vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when 400VAC is healthy
      ix_QuickStopDisable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;   //   TRUE when Motor can turn, False = Quick stop
      ix_SimulationModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when Simulation mode active
      ix_StartCommissioning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when Start auto-commissioning
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdStatus";   //    HMI status structure
      qUDT_VfdOutputs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdSiemensPO";   //    VFD outputs structure
   END_VAR

   VAR_IN_OUT 
      iqUDT_ConveyorInterface : "UDT_ConveyorInterface";   //    Conveyor interface structure
      iqUDT_VfdStatistics : "UDT_VfdStatistics";   //    Satistics structure
      iqx_GoToNextStepCommissioning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Go to next step with the sequences auto commissioning
   END_VAR

   VAR 
      sFB_Commissioning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_VfdSiemensCommissioning";   //    MHS "FB_Commissioning"- to execute drive auto-commissioning
      sFB_TimerOnOffDelayCheck24V { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //    MHS "TimerOnOffDelay" - to delay time for VFD 24V contactor
      sFB_TimerOnOffDelayCheck400V { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //    MHS "TimerOnOffDelay" - to delay time for VFD 400V contactor
      sFB_TimerOnOffDelayVFDReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //    MHS "TimerOnOffDelay" - to extend VFD reset
      sFB_TimerOnOffDelayVFDRunningFeedbackError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //    MHS "TimerOnOffDelay" - to delay time for VFDRunningFeedback error
      sUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatus";   //    Detailed VFD status overview
      sUDT_PNDevice { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PNDevice";   //    PN device info structure
      sv_VFDGeoStruct {InstructionName := 'GEOADDR'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : GEOADDR;   //    Geo structure indicate to telegram
      sR_TRIG_PNSlaveNotOnline {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //    Rising edge for trigger Profinet slave not online statistics
      sR_TRIG_PNSlaveError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //    Rising edge for trigger Profinet slave error statistics
      sR_TRIG_VFDInternalError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //    Rising edge for trigger Internal VFD Error statistics
      sR_TRIG_Running {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //    Rising edge for starting of the running signal
      sF_TRIG_RunFwd {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //    Falling edge for run forward signal
      sF_TRIG_RunRvs {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //    Falling edge for run reverse signal
      sa_PNPortsStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..8] of Bool;   //  TRUE when specific port has an error
      shw_VFD_Telegram { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   //    Free telegram's HW_ID
      sr_ActualSpeedSetpoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   //    Actual speed setpoint [mm/s]
      si_ActualSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //    Actual speed in [mm/s]
      si_Log2GeoReturn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //    Log2Geo function return
      si_Geo2LogReturn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //    Geo2Log function return
      sx_ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Commissioning: configuration error
      sx_PNDeviceHealthy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Profinet device is online and error free
      sx_HardwareAvailable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Power and communication to drive are ok
      sx_VFD_Available { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Hardware of VFD is ok and no communication error with movikit
      sx_24vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   24VDC is healthy
      sx_400vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   400VAC is healthy
      sx_ErrorActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Block has an error
      sx_EnableOperation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Enable operation signal
      sx_RunVFDForward { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Start VFD forward
      sx_RunVFDReverse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Start VFD backward
      sx_SpeedSetpointReached { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Motor is running at requested speed
      sx_VFDStopping { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    VFD Stopping
      sx_StartMeasuring { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    VFD commissioning measuring status
   END_VAR

   VAR CONSTANT 
      cr_MaximumOutput : Real := 16384.0;
      cudi_DefaultRampUpTime : UDInt := 20000;   //    VFD ramp up default time [ms]
      cudi_DefaultRampDownTime : UDInt := 20000;   //    VFD ramp down default time [ms]
      ci_VFDArea : UInt := 1;   //    Area ID of IO Profinet devices
      ci_SubmoduleHWType : UInt := 5;   //    Submodule HW_type number
      ci_TelegramSlot : UInt := 1;   //    Free Siemens telegram slot
      ci_TelegramSubslot : UInt := 3;   //    Free Siemens telegram subslot
      ci_NumberOfProfinetPorts : Int := 2;   //  Number of Profinet ports in device
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | S. Nikodem    | First release MHS TIA 15.1
	14/06/2019  | 0.2       | M. Kurc       | Replacement of instruction if for direct write into variable, temporary variables review 
	14/06/2019  | 0.3       | M. Kurc       | Communication error corrected
	19/06/2019  | 0.4       | M. Kurc       | Deleting error word
	25/06/2019  | 0.6       | M. Kurc       | Change interface q_UDT_VFDStatistic to iq_UDT_VFDStatistic
	04/07/2019  | 0.7       | S. Nikodem    | Add auto-parametrization fuction 
	18/07/2019  | 0.8       | M. Kurc       | Deleting functions (denormaliztion, normalization, rpm-mm/s, mm/s-rpm)  
	24/07/2019  | 2.0       | L. Klar       | 2.0 MHS library release TIA 15.1
	14/08.2019  | 2.1       | K. Pokorski   | Profinet number and HWID reading logic added
	09/09/2019  | 2.2       | S. Nikodem    | Complete rebuild block
	17/09/2019  | 2.3       | S. Nikodem    | Add ramp start/stop
	30/09/2019  | 2.4       | K. Pokorski   | Changed region 1 contents to FC
	30/09/2019  | 2.5       | K. Pokorski   | Implemented new VFD status
	30/09/2019  | 2.6       | L. Klar       | Actual speed connected to a new interface UDT, UDT interface changed
	11/10/2019  | 2.7       | S. Nikodem    | Added Interlock, quick stop, default ramp start/stop time = 20s, running statistic 
	30/10/2019  | 2.8       | K. Pokorski   | Acceleration and deceleration calculating fixed
	30/10/2019  | 2.9       | K. Pokorski   | Internal warning and error handling changed
	20/11/2019  | 2.10      | S. Nikodem    | Configuration error
	20/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	03/12/2019  | 3.1       | S. Nikodem    | Change of direction 
	20/12/2019  | 3.2       | S. Deulkar    | Used configureation error bit to report to conveyor block 
	28/01/2020  | 3.3       | S. Nikodem    | Configuration error if speed setpoint is too high 
	06/02/2020  | 3.4       | S. Nikodem    | Configuration error - Simulation mode bypass PNDeviceFound
	02/01/2020  | 3.5       | F.Baten       | Changed "UDT_VFD_Status" to be without positioning status
	04/03/2020  | 3.6       | F.Baten       | Output speed scaling based on measured speed at fixed output value, removal of gearratio and wheelendperrimeter
	01/05/2020  | 3.7       | F.Baten       | Reverted 3.6 modification measured speed
	18/06/2020  | 3.8       | L.Klar        | ix_PowerOK splitted to 24vOK and 400vOK
	23/06/2020  | 3.9       | L.Klar        | VFD running change to cover deceleration ramp, at speed condition changed to have False in standstill
	08/07/2020  | 3.10      | S.Theocharis  | Change VFD acknowledge to extended pulse & send acknowledge even with PN Slave error
	09/07/2020  | 3.11      | S.Theocharis  | Updated PO UDT 
	10/07/2020  | 3.12      | S.Theocharis  | Comment out the PNSlave error from the VfdAvailable and ErrorActive variables to allo run in a ring topology  
	22/07/2020  | 3.13      | K.Pokorski    | Protection against negative actual speed (int overflow) 
	14/09/2020  | 3.14      | S.Nikodem     | VFDRunningFeedback error 
	03/11/2020  | 3.15      | K.Pokorski    | Profinet ports diagnostics added 
	06/01/2022  | 3.16      | M.Roijen      | Update new FB_Commissioning block
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	    *)
	
	REGION 1 - Get Device Profinet information
	    
	    "FC_GetDevicePN"(is_PNDeviceName := #iUDT_VfdConfig.VFDPNDeviceName,
	                     ix_SimulationModeActive := #ix_SimulationModeActive,
	                     iqUDT_PND := #sUDT_PNDevice);
	    
	    
	    "FC_GetPNPortStatus"(ii_NumberOfPorts := #ci_NumberOfProfinetPorts,
	                         iUDT_DevicePNInfo := #sUDT_PNDevice,
	                         qa_PortFault => #sa_PNPortsStatus);
	    
	END_REGION
	
	REGION 2 - Reset errors
	    
	    IF #iqUDT_ConveyorInterface.InternalErrorReset                           // Reser errors when Reset is given
	    THEN
	        
	        #sUDT_Status.PNSlaveNotonline := FALSE;
	        #sUDT_Status.PNSlaveError := FALSE;
	        #sUDT_Status.InternalError := FALSE;
	        #sUDT_Status.VFDRunningFeedbackError := FALSE;
	        #sUDT_Status.PNSlaveWarning := FALSE;
	        
	    END_IF;
	    
	    
	    // Create  extended pulse for VFD Reset
	    #sFB_TimerOnOffDelayVFDReset(iudi_OnDelayTime := 0,
	                                 iudi_OffDelayTime := 200,
	                                 ix_SignalToDelay := #iqUDT_ConveyorInterface.InternalErrorReset,
	                                 ix_Enable := TRUE);
	    
	END_REGION
	
	REGION 3 - Hardware checks
	    // Hardware will only be available after the delay, so the device has time for the initialisation
	    #sFB_TimerOnOffDelayCheck24V(iudi_OnDelayTime := 2000,
	                                 ix_SignalToDelay := #ix_24vOk);
	    
	    #sx_24vOk := #sFB_TimerOnOffDelayCheck24V.qx_DelayedSignal;
	    
	    #sFB_TimerOnOffDelayCheck400V(iudi_OnDelayTime := 2000,
	                                  ix_SignalToDelay := #ix_400vOk);
	    
	    #sx_400vOk := #sFB_TimerOnOffDelayCheck400V.qx_DelayedSignal;
	    
	    // Check if PN device is online
	    IF NOT "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.Exist
	        AND NOT #ix_SimulationModeActive
	        AND #sx_24vOk
	    THEN
	        #sUDT_Status.PNSlaveNotonline := TRUE;
	        
	    END_IF;
	    
	    // Check if PN ports are healthy 
	    IF #sa_PNPortsStatus[1] XOR #sa_PNPortsStatus[2] THEN
	        #sUDT_Status.PNSlaveWarning := TRUE;
	    END_IF;
	    
	    
	    // Check if PN device has an error
	    IF "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.Error
	        AND NOT #ix_SimulationModeActive
	        AND #sx_24vOk
	        AND NOT #sUDT_Status.PNSlaveWarning
	    THEN
	        #sUDT_Status.PNSlaveError := TRUE;
	    END_IF;
	    
	    // Set bit when PN device is healthy (online and no error)
	    #sx_PNDeviceHealthy := NOT #sUDT_Status.PNSlaveNotonline
	    AND NOT #sUDT_Status.PNSlaveError
	    AND #sUDT_PNDevice.PNDeviceFound
	    AND #sx_24vOk;
	    
	    // Set hardware available bit when all conditions are met
	    #sx_HardwareAvailable := (#sx_24vOk
	    AND #sx_PNDeviceHealthy)
	    OR #ix_SimulationModeActive;
	    
	    
	    // VFD is ready for operation if hardware ok 
	    #sx_VFD_Available := #sx_HardwareAvailable;
	    
	END_REGION
	
	REGION 4 - Check errors and warnings 
	    
	    // Check if the VFD has a warning
	    #sUDT_Status.InternalWarning := #iUDT_VfdInputs.ZSW_1.AlarmActive;
	    
	    // Copy warning code to status DB when warning active
	    IF #iUDT_VfdInputs.ZSW_1.AlarmActive
	    THEN
	        
	        #sUDT_Status.ErrorCode := UINT_TO_INT(#iUDT_VfdInputs.AlarmCode);
	        
	    END_IF;
	    
	    // Check if the VFD has an error
	    #sUDT_Status.InternalError := #iUDT_VfdInputs.ZSW_1.FaultActive AND NOT #sx_StartMeasuring;
	    
	    // Copy error code to status DB when error active
	    IF #iUDT_VfdInputs.ZSW_1.FaultActive
	    THEN
	        
	        #sUDT_Status.ErrorCode := UINT_TO_INT(#iUDT_VfdInputs.FaultCode);
	        
	    END_IF;
	    
	    // Reset error code if warning and error not available    
	    IF (NOT #iUDT_VfdInputs.ZSW_1.AlarmActive
	        AND NOT #iUDT_VfdInputs.ZSW_1.FaultActive)
	    THEN
	        
	        #sUDT_Status.ErrorCode := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Check if configuration is ok for commissioning purposes
	    
	    IF #iUDT_VfdConfig.WheelEndPerimeter > 0.0                                         // If perimeter of wheel at the end of gear is greater than 0 
	        AND #iUDT_VfdConfig.GearRatio > 0.0                                            // and gear ratio is greater than 0
	        AND #iUDT_VfdConfig.ReferenceRPM > 0.0                                             // and maximum speed is greater than 0
	        AND #iUDT_VfdConfig.VFDRampUpTime > 0                                          // and ramp up time is greater than 0
	        AND #iUDT_VfdConfig.VFDRampDownTime > 0                                        // and ramp down time is greater than zero
	        AND #iUDT_VfdConfig.VFDStartupTime > 0.0                                       // and startup time is greater then zero
	        AND 2 * #cudi_DefaultRampUpTime > #iUDT_VfdConfig.VFDRampUpTime                // and ramp up time is not greater two time than default ramp up time
	        AND 2 * #cudi_DefaultRampDownTime > #iUDT_VfdConfig.VFDRampDownTime            // and ramp down time is not greater two time than default ramp down time
	        
	        AND (#sUDT_PNDevice.PNDeviceFound                                              // and device not found in PN structure 
	        OR #ix_SimulationModeActive)                                                    // or simulation mode is active
	    THEN
	        #sx_ConfigurationError := FALSE;                                                // Reset configuration error
	    ELSE
	        #sx_ConfigurationError := TRUE;                                                 // Set configuration error
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Speed handling  
	    
	    // Calculate actual speed in mm/s                                                                                                         
	    #si_ActualSpeed := REAL_TO_INT((((INT_TO_REAL(#iUDT_VfdInputs.ActualSpeed) / #cr_MaximumOutput) * #iUDT_VfdConfig.ReferenceRPM) / #iUDT_VfdConfig.GearRatio) * #iUDT_VfdConfig.WheelEndPerimeter / 60.0);
	    
	    // Reversal actual speed
	    IF #iUDT_VfdConfig.DirectionReversal THEN
	        
	        #si_ActualSpeed := #si_ActualSpeed * -1;
	        
	    END_IF;
	    
	    // Calculate actual speed setpoint 
	    #sr_ActualSpeedSetpoint := ((DINT_TO_REAL(INT_TO_DINT(#iqUDT_ConveyorInterface.SpeedSetpoint) * 60) / #iUDT_VfdConfig.WheelEndPerimeter) * #iUDT_VfdConfig.GearRatio);
	    
	    // Check if speed setpoint is reached                                 
	    #sx_SpeedSetpointReached := (ABS(#si_ActualSpeed) >= (#iqUDT_ConveyorInterface.SpeedSetpoint - #iUDT_VfdConfig.SpeedSetpointWindow))
	    AND (ABS(#si_ActualSpeed) <= (#iqUDT_ConveyorInterface.SpeedSetpoint + #iUDT_VfdConfig.SpeedSetpointWindow));
	END_REGION
	
	REGION 7 - Prepare output data VFD
	    REGION 7.1 - Set speed setpoint in forward and reverse directory 
	        
	        // If motor stopped and Run forward is requested and interlock forward is active, the speed setpoint is loaded to run forward.
	        IF (#iUDT_VfdInputs.ActualSpeed = 0) AND #iqUDT_ConveyorInterface.RunFwd AND #iUDT_VfdConfig.InterlockFwd
	        THEN
	            #sx_RunVFDForward := TRUE;
	            #sx_RunVFDReverse := FALSE;
	        END_IF;
	        
	        // If motor stopped and Run reverse is requested and interlock reverse is active, the speed setpoint is loaded to run reverse.
	        IF (#iUDT_VfdInputs.ActualSpeed = 0) AND #iqUDT_ConveyorInterface.RunRvs AND #iUDT_VfdConfig.InterlockRvs
	        THEN
	            #sx_RunVFDReverse := TRUE;
	            #sx_RunVFDForward := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 7.2 - Stopping
	        
	        // Create trigger when direction signal falling
	        #sF_TRIG_RunFwd(CLK := #iqUDT_ConveyorInterface.RunFwd);
	        #sF_TRIG_RunRvs(CLK := #iqUDT_ConveyorInterface.RunRvs);
	        
	        // When no run signal is given the VFD should stop
	        IF NOT #iqUDT_ConveyorInterface.RunRvs AND NOT #iqUDT_ConveyorInterface.RunFwd
	            OR (#iqUDT_ConveyorInterface.RunRvs AND #iqUDT_ConveyorInterface.RunFwd)
	            OR #sF_TRIG_RunRvs.Q
	            OR #sF_TRIG_RunFwd.Q
	            
	        THEN
	            #sx_RunVFDReverse := FALSE;
	            #sx_RunVFDForward := FALSE;
	        END_IF;
	        
	        IF NOT #sx_RunVFDReverse AND NOT #sx_RunVFDForward AND (#iUDT_VfdInputs.ActualSpeed <> 0)
	        THEN
	            #sx_VFDStopping := TRUE;
	        ELSE
	            #sx_VFDStopping := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 7.3 - Check for enable operation signal
	        
	        #sx_EnableOperation := #sx_VFD_Available AND #sx_400vOk AND NOT #sx_ConfigurationError AND (#sx_RunVFDForward OR #sx_RunVFDReverse); // add communication error
	        
	    END_REGION
	    
	    REGION 7.4 - Write acceleration and deceleration value to drive
	        // Write accceleration value to VFD
	        #qUDT_VfdOutputs.SetpointAcceleration := REAL_TO_INT(#cr_MaximumOutput / UDINT_TO_REAL(#cudi_DefaultRampUpTime) * UDINT_TO_REAL(#iUDT_VfdConfig.VFDRampUpTime));        //Recalculating Acceleration ramp 
	        
	        // Write deceleration value to VFD
	        #qUDT_VfdOutputs.SetpointDeceleration := REAL_TO_INT(#cr_MaximumOutput / UDINT_TO_REAL(#cudi_DefaultRampDownTime) * UDINT_TO_REAL(#iUDT_VfdConfig.VFDRampDownTime));      //Recalculating Deceleration ramp 
	        
	    END_REGION
	    
	END_REGION
	
	REGION 8 - Auto Commisioning 
	    
	    REGION 8.1 Extract telegram's HW_ID 
	        
	        IF (#ix_StartCommissioning)
	        THEN
	            
	            #si_Log2GeoReturn := LOG2GEO(LADDR := "DB_ProfinetDiagnostic".ProfinetNetworks[#sUDT_PNDevice.PNNetworknumber].DeviceStatus[#sUDT_PNDevice.PNDeviceNumber].DeviceState.HW_ID, GEOADDR := #sv_VFDGeoStruct);       // "LOG2GEO" to get profinet network number
	            #sv_VFDGeoStruct.AREA := #ci_VFDArea;                                                                                                                                                                               // Set IO Profinet devices area ID
	            #sv_VFDGeoStruct.HWTYPE := #ci_SubmoduleHWType;                                                                                                                                                                     // Set submodule HW_type number
	            #sv_VFDGeoStruct.STATION := INT_TO_UINT(#sUDT_PNDevice.PNDeviceNumber);                                                                                                                                            // Set device's profinet number
	            #sv_VFDGeoStruct.SLOT := #ci_TelegramSlot;                                                                                                                                                                          // Set free telegram slot
	            #sv_VFDGeoStruct.SUBSLOT := #ci_TelegramSubslot;                                                                                                                                                                    // Set free telegram subslot
	            
	            #si_Geo2LogReturn := GEO2LOG(GEOADDR := #sv_VFDGeoStruct, LADDR => #shw_VFD_Telegram);                                                                                                                              // "GEO2LOG" to get free telegram's HW_ID
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 8.2 Run auto - commissioning
	        
	        // Using commissioning block to write/read parameter. Start parametrization if rise edge trigger from start commissionig signal
	        #sFB_Commissioning(ix_Enable := #ix_StartCommissioning,
	                           ihw_SinaParamHardwareId := #shw_VFD_Telegram,                    // Set hardware id ,
	                           iUDT_MotorConfig := #iUDT_MotorData,
	                           qx_StartMeasuring => #sx_StartMeasuring,                         // Set start measuring signal 
	                           iqx_GoToNextStep := #iqx_GoToNextStepCommissioning);             // Set/Reset signal go to next step
	        
	        
	    END_REGION ;
	    
	END_REGION
	
	REGION 9 - Write outputs to VFD  
	    
	    REGION 9.1 - Write control word 1
	        
	        
	        #qUDT_VfdOutputs.STW_1.ControlViaPLC := TRUE;
	        #qUDT_VfdOutputs.STW_1.DirectionReversal := FALSE;
	        #qUDT_VfdOutputs.STW_1.ONOFF1 := #sx_EnableOperation OR #sx_StartMeasuring;
	        #qUDT_VfdOutputs.STW_1.OFF2 := TRUE;
	        #qUDT_VfdOutputs.STW_1.OFF3 := #ix_QuickStopDisable;
	        #qUDT_VfdOutputs.STW_1.EnableOperation := #sx_RunVFDReverse OR #sx_RunVFDForward OR #iUDT_VfdInputs.ActualSpeed <> 0 OR #sx_StartMeasuring;
	        #qUDT_VfdOutputs.STW_1.DoNotDisableRFG := TRUE;
	        #qUDT_VfdOutputs.STW_1.EnableRFG := TRUE;
	        #qUDT_VfdOutputs.STW_1.EnableSetpoint := TRUE;
	        #qUDT_VfdOutputs.STW_1.Acknowledge := #sFB_TimerOnOffDelayVFDReset.qx_DelayedSignal;
	        
	        
	        IF (NOT #sx_VFD_Available OR NOT #sx_400vOk) AND NOT #sx_StartMeasuring
	        THEN
	            
	            #qUDT_VfdOutputs.STW_1.ForceDormantErrorTest := FALSE;
	            #qUDT_VfdOutputs.STW_1.SpareBit9 := FALSE;
	            #qUDT_VfdOutputs.STW_1.DirectionReversal := FALSE;
	            #qUDT_VfdOutputs.STW_1.SpareBit12 := FALSE;
	            #qUDT_VfdOutputs.STW_1.SpareBit13 := FALSE;
	            #qUDT_VfdOutputs.STW_1.SpareBit14 := FALSE;
	            #qUDT_VfdOutputs.STW_1.SpareBit15 := FALSE;
	            #qUDT_VfdOutputs.STW_1.ONOFF1 := FALSE;
	            #qUDT_VfdOutputs.STW_1.OFF2 := FALSE;
	            #qUDT_VfdOutputs.STW_1.OFF3 := FALSE;
	            #qUDT_VfdOutputs.STW_1.EnableOperation := FALSE;
	            #qUDT_VfdOutputs.STW_1.DoNotDisableRFG := FALSE;
	            #qUDT_VfdOutputs.STW_1.EnableRFG := FALSE;
	            #qUDT_VfdOutputs.STW_1.EnableSetpoint := FALSE;
	            #qUDT_VfdOutputs.SpeedSetpoint := 0;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 9.2 - Write speed setpoint to drive
	        
	        // Calculate normalized speed setpoint
	        #qUDT_VfdOutputs.SpeedSetpoint := REAL_TO_INT((#sr_ActualSpeedSetpoint / #iUDT_VfdConfig.ReferenceRPM) * #cr_MaximumOutput);
	        IF #qUDT_VfdOutputs.SpeedSetpoint > #cr_MaximumOutput
	        THEN
	            #qUDT_VfdOutputs.SpeedSetpoint := REAL_TO_INT(#cr_MaximumOutput);
	        END_IF;
	        
	        // The conveyor stopped and may now run in reverse direction
	        IF (#sx_RunVFDReverse AND NOT #iUDT_VfdConfig.DirectionReversal)
	            OR (#sx_RunVFDForward AND #iUDT_VfdConfig.DirectionReversal)
	        THEN
	            #qUDT_VfdOutputs.SpeedSetpoint := #qUDT_VfdOutputs.SpeedSetpoint * -1;
	        END_IF;
	        
	        // Clear speed setpoint when no run request or above direction request or is configuration error
	        IF (NOT #sx_RunVFDForward AND NOT #sx_RunVFDReverse)
	            OR #sx_ConfigurationError
	        THEN
	            #qUDT_VfdOutputs.SpeedSetpoint := 0;
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 10 - Check if motor is running
	    
	    //The moto should start running after specific time. If not the VFDRunningFeedback error occured
	    #sFB_TimerOnOffDelayVFDRunningFeedbackError(iudi_OnDelayTime := #iUDT_VfdConfig.VFDStartupTime,
	                                                ix_SignalToDelay := #sx_EnableOperation AND NOT (#si_ActualSpeed <> 0));
	    
	    IF #sFB_TimerOnOffDelayVFDRunningFeedbackError.qx_DelayedSignal THEN
	        
	        #sUDT_Status.VFDRunningFeedbackError := TRUE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 11 - Copy signals to interface DB and to status output UDT
	    // Create internal error status
	    #sx_ErrorActive := #sUDT_Status.PNSlaveNotonline
	    OR #sUDT_Status.VFDRunningFeedbackError
	    //  OR #s_UDT_Status.PNSlaveError Commented out by AST to allow run in ring topology v3.12
	    OR #sUDT_Status.InternalError;
	    
	    // Write interface bits
	    #iqUDT_ConveyorInterface.VFDRunning := #iUDT_VfdInputs.ZSW_1.Ready AND #sx_VFD_Available AND (#iqUDT_ConveyorInterface.ActualSpeed <> 0 OR #iUDT_VfdInputs.ZSW_1.OperationEnabled);   // Write true on output Conveyor interface structure if VFD is in operation and motor is turning 
	    #iqUDT_ConveyorInterface.VFDatSpeed := #sx_SpeedSetpointReached AND #sx_VFD_Available AND #si_ActualSpeed <> 0;                                                                                                  // Copy setpoint speed reached state from static to the output conveyor interface structure
	    #iqUDT_ConveyorInterface.InternalWarningVFD := #iUDT_VfdInputs.ZSW_1.AlarmActive;                                                                                                      // Set the internal VFD warning bit if any warning is active
	    #iqUDT_ConveyorInterface.InternalErrorVFD := #sx_ErrorActive;                                                                                                                           // Set the internal VFD error bit if any fault is active 
	    #iqUDT_ConveyorInterface.ActualSpeed := #si_ActualSpeed;                                                                                                                                // Copy the calculated value to the output
	    #iqUDT_ConveyorInterface.ConfigurationError := #iqUDT_ConveyorInterface.ConfigurationError OR #sx_ConfigurationError;
	    
	    // Copy error status to output
	    #qUDT_HMIStatus := #sUDT_Status;
	    
	END_REGION
	
	REGION 12 - Statistic
	    // Create trigger on error and create statistics for profinet slave not online
	    #sR_TRIG_PNSlaveNotOnline(CLK := #sUDT_Status.PNSlaveNotonline);                                        // Detect the rising edge of the error
	    
	    IF #iqUDT_ConveyorInterface.ResetStatistics OR #sUDT_Status.PNSlaveNotonline
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #sUDT_Status.PNSlaveNotonline,
	                        ix_RTrigActivate := #sR_TRIG_PNSlaveNotOnline.Q,
	                        iqUDT_Statistics := #iqUDT_VfdStatistics.PNSlaveNotOnline);
	    END_IF;
	    
	    // Create trigger on error and create statistics for profinet slave error
	    #sR_TRIG_PNSlaveError(CLK := #sUDT_Status.PNSlaveError);                                        // Detect the rising edge of the error
	    
	    IF #iqUDT_ConveyorInterface.ResetStatistics OR #sUDT_Status.PNSlaveError
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #sUDT_Status.PNSlaveError,
	                        ix_RTrigActivate := #sR_TRIG_PNSlaveError.Q,
	                        iqUDT_Statistics := #iqUDT_VfdStatistics.PNSlaveError);
	    END_IF;
	    
	    // Create trigger on error and create statistics for internal VFD Error
	    #sR_TRIG_VFDInternalError(CLK := #sUDT_Status.InternalError);                                        // Detect the rising edge of the error
	    
	    IF #iqUDT_ConveyorInterface.ResetStatistics OR #sUDT_Status.InternalError
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #sUDT_Status.InternalError,
	                        ix_RTrigActivate := #sR_TRIG_VFDInternalError.Q,
	                        iqUDT_Statistics := #iqUDT_VfdStatistics.VFDInternalError);
	    END_IF;
	    
	    // Create trigger on running signal and create statistics for running status
	    #sR_TRIG_Running(CLK := #iqUDT_ConveyorInterface.VFDRunning);                                        // Detect the rising edge of the signal
	    
	    IF #iqUDT_ConveyorInterface.ResetStatistics OR #iqUDT_ConveyorInterface.VFDRunning
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #iqUDT_ConveyorInterface.VFDRunning,
	                        ix_RTrigActivate := #sR_TRIG_Running.Q,
	                        iqUDT_Statistics := #iqUDT_VfdStatistics.Running);
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_Unloader"
TITLE = FB_Unloader
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : Equimpent
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 232
// END_ATTRIBUTES
//Function block to control unloader.
   VAR_INPUT 
      iUDT_UnloaderConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_UnloaderConfiguration";   //   Unloader configuration structure
      ix_SafetyReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Safety reset
      ix_SafetyOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when Safety Circuit of the Conveyor is healthy
      ix_24vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when 24VDC is healthy
      ix_400vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when 400VAC is healthy
      ix_ProfinetOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when the PN node(s) of VSU are OK
      ix_ReadyUnload { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when Unloader is ready to unload
      ix_Running { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when Unloader is running
      ix_TooLongParcel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when Unloader has detected a too long parcel (stopped)
      ix_VFDError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when Unloader has an VFD error
      ix_Healthy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when Unloader has no Errors
      ix_PECEoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when the end of section photoeye is not blocked
      ix_ManualControlled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Unloader is controlled by
      ix_ExternalRequestDieBack { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   External request die back
      ix_ExternalRequestHold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   External request hold
      ix_ResetEnergySave { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Reset energy save mode timer
      ix_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when  hardware is Ok
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_UnloaderStatus";   //   HMI status structure
      qUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   //   Common status structure
      qi_SpeedSelect { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Speed select (slow, normal or fast)
      qx_ReleaseUnload { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Release Unloader
      qx_EStopReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      qx_FaultReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   //   Equipment control structure
      iqUDT_UnloaderCommand : "UDT_UnloaderCommand";   //   Unloader HMI control
      iqUDT_HandShake : "UDT_ConveyorHandshake";   //   Handshake structure
      iqUDT_EquipmentInterface : "UDT_ConveyorInterface";   //   Equipment interface structure
      iqUDT_Statistics : "UDT_UnloaderStatistics";   //   Statistics structure
   END_VAR

   VAR 
      sUDT_CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //   Common status structure
      sUDT_CommonStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //   Auxiliary status structure
      sUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_UnloaderStatus";   //   HMI status structure
      s_FB_TimerOnOffDelaySafetyOKPulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sFB_PECEoSFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //   Filtering end of section photo eye signal
      sFB_PECEoSJamTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //   Timer to detect photo eye jam
      sFB_EnergySaveTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //   Timer to start energy save mode
      sFB_PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_PEC";   //   FB PEC block for PEC Jam status
      sR_TRIG_PEC_EoSFiltered {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge trigger end of section photo eye filtered
      sF_TRIG_PEC_EoSFiltered {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //   Falling edge trigger end of section photo eye filtered
      sR_TRIG_EnergySave {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge for energy save
      sR_TRIG_ConveyorUp {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge of automatic active
      sR_TRIG_ConveyorDown {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge of automatic not active
      sR_TRIG_VFDError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge of VFD error
      sR_TRIG_NotHealthy {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge trigger if extendable not healthy
      sR_TRIG_TooLongParcel {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge trigger for too long parcel
      s_R_TRIG_SafetyOK {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      si_AuxEnergySave { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Auxiliery energy save
      sx_Disabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Operation is enabled
      sx_Ready { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Conveyor Ready to operate in Automatic mode
      sx_StartReceived { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Start command received from system
      sx_PEC_EoSFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   End of section photo eye filtered
      sx_EnergySaveActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Active energy save mode
      sx_AutomaticActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Automatic active
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | F.Baten       | first release MHS TIA 15.1
	17/06/2019  | 0.3       | L.Klar        | Manual mode added to "UDT_EquipmentControl"
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	14/10/2019  | 2.1       | L.Klar        | Updated status structure
	15/10/2019  | 2.2       | S.Deulkar     | Deleted unused symbol, added statistcs, rearrange structure
	04/11/2019  | 2.3       | L.Klar        | First scan bit changed from memory bit to DB variable
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	04/03/2020  | 3.1       | P.Majka       | Adapting reviews, repair statistics for too long parcels
	31/03/2020  | 3.2       | F.Baten       | UDT_UnloaderCommand added
	                                        | Disable by HMI added
	22/09/2020  | 3.3       | L.Klar        | Reset added   
	11/01/2021  | 3.4       | L.Klar        | Input safety ok added to stop conveyor condition
	27/02/2021  | 3.5       | M. Kurpiers   | Button disable/enable operation and status fixed
	02/03/2021  | 3.6       | K. Pokorski   | Halted and dieback status enable only when automatic on
	13/03/2021  | 3.7       | L.Klar        | HMI status updated- warning commented, energy save added
	13/03/2021  | 3.8       | L.Klar        | Energy save corrected
	08/04/2021  | 3.9       | K.Pokorski    | VFD error masked when safety is not ok
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Initial
	    
	    REGION 1.1 - First PLC cycle
	        
	        // Bits initialization.
	        IF "DB_Memory".FirstScan
	        THEN
	            #qx_ReleaseUnload := FALSE;
	            #sx_AutomaticActive := FALSE;
	            #sx_StartReceived := FALSE;
	            #sx_Disabled := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 1.2 Triggers
	        
	        // Rising edge trigger end of section photo eye filtered.
	        #sR_TRIG_PEC_EoSFiltered(CLK := #sx_PEC_EoSFiltered);
	        
	        // Falling edge trigger end of section photo eye filtered.
	        #sF_TRIG_PEC_EoSFiltered(CLK := #sx_PEC_EoSFiltered);
	        
	        // Rising edge trigger energy save.
	        #sR_TRIG_EnergySave(CLK := #sUDT_CommonStatus.EnergySave);
	        
	        // Rising edge extendable up.
	        #sR_TRIG_ConveyorUp(CLK := #sx_AutomaticActive AND #sx_Ready);
	        
	        // Rising edge extendable down.
	        #sR_TRIG_ConveyorDown(CLK := #sx_AutomaticActive AND NOT #sx_Ready);
	        
	        // Rising edge extendable VFD error.
	        #sR_TRIG_VFDError(CLK := #sUDT_HMIStatus.Specific.VFDError);
	        
	        // Rising edge extendable not healthy. 
	        #sR_TRIG_NotHealthy(CLK := #sUDT_HMIStatus.Specific.NotHealthy);
	        
	        // Rising edge for too long parcel. 
	        #sR_TRIG_TooLongParcel(CLK := #sUDT_HMIStatus.Specific.TooLongParcel);
	        
	    END_REGION
	    
	    REGION HMI button Disable/Enable operation
	        IF #iqUDT_UnloaderCommand.Disable
	        THEN
	            #sx_Disabled := TRUE;
	        ELSE
	            #sx_Disabled := FALSE;
	        END_IF;
	        
	        #iqUDT_UnloaderCommand.Disable := FALSE;
	        
	        
	        // Copy status to HMI
	        #sUDT_HMIStatus.Specific.Disabled := #sx_Disabled;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 2 - Errors
	    
	    // PEC EoS.
	    #sFB_PEC(ix_PEC := #ix_PECEoS,
	             iUDT_PECConfiguration := #iUDT_UnloaderConfiguration.PEC_EOS,
	             qx_PECFiltered => #sx_PEC_EoSFiltered,
	             qUDT_HMIStatus => #sUDT_HMIStatus.Specific.PEC_EoS,
	             iqUDT_ConveyorInterface := #iqUDT_EquipmentInterface,
	             iqUDT_PECStatistics := #iqUDT_Statistics.PEC_EOS);
	    
	    // Parcel too long.
	    #sUDT_HMIStatus.Specific.TooLongParcel := #ix_TooLongParcel;
	    
	    // VFD Error.
	    #sUDT_HMIStatus.Specific.VFDError := (#ix_VFDError AND #ix_400vOk AND #ix_ProfinetOk AND #ix_SafetyOk);
	    
	    // Not healthy.
	    #sUDT_HMIStatus.Specific.NotHealthy := (NOT #ix_Healthy AND #ix_400vOk AND #ix_24vOk AND #ix_ProfinetOk);
	    
	    // Common Error.
	    #sUDT_CommonStatus.Error := NOT #ix_24vOk
	    OR NOT #ix_400vOk
	    OR NOT #ix_ProfinetOk
	    OR NOT #ix_SafetyOk
	    OR #sUDT_HMIStatus.Specific.PEC_EoS.Jam
	    OR #sUDT_HMIStatus.Specific.VFDError
	    OR #sUDT_HMIStatus.Specific.NotHealthy;
	    
	    // Warning.
	    #sUDT_CommonStatus.Warning := #sUDT_HMIStatus.Specific.TooLongParcel;
	    
	END_REGION
	
	REGION 3 - Check conditions to set unloader ready    
	    
	    // Ready to operate.
	    #sx_Ready := NOT #sUDT_CommonStatus.Error
	    AND #ix_Healthy
	    AND NOT #ix_ManualControlled;
	    
	END_REGION
	
	REGION 4 - Stop unloader
	    
	    // Reset bits to stop unloader.
	    IF NOT #iqUDT_EquipmentControl.Command.AutomaticOn
	        OR #sUDT_CommonStatus.Error
	        OR NOT #ix_Healthy
	        OR #ix_ManualControlled
	        OR NOT #ix_SafetyOk
	    THEN
	        #qx_ReleaseUnload := FALSE;
	        #sx_AutomaticActive := FALSE;
	        #sx_StartReceived := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Start Automatic mode
	    
	    // If start (one shot) is received from system, this is memorised until started in cascade. 
	    IF #iqUDT_EquipmentControl.Command.Start
	        AND #sx_Ready
	    THEN
	        #sx_StartReceived := TRUE;
	    END_IF;
	    
	    // Activating automatic mode.
	    IF #sx_StartReceived
	        AND (#iqUDT_HandShake.CascadeStartUp
	        OR #iUDT_UnloaderConfiguration.FirstConveyorToStart)
	    THEN
	        #sx_AutomaticActive := TRUE;
	        #sx_StartReceived := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Automatic mode active
	    
	    REGION 6.1 - Ready To Send (RTS)
	        
	        // Set Ready to send signal.
	        IF #sF_TRIG_PEC_EoSFiltered.Q
	            AND #sx_AutomaticActive
	            AND #sx_Ready
	            AND #ix_ReadyUnload
	        THEN
	            #iqUDT_HandShake.RTS := TRUE;
	        END_IF;
	        
	        // Reset Ready to send signal.
	        IF #sR_TRIG_PEC_EoSFiltered.Q
	        THEN
	            #iqUDT_HandShake.RTS := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 6.2 - Operation
	        
	        // Run Unloader.
	        #qx_ReleaseUnload := #sx_AutomaticActive
	        AND #sx_Ready
	        AND #ix_ReadyUnload
	        AND ((#iqUDT_HandShake.RTR
	        AND NOT #ix_ExternalRequestDieBack)
	        OR #sx_PEC_EoSFiltered)
	        AND NOT #sx_Disabled
	        AND NOT #ix_ExternalRequestHold
	        AND NOT #sx_EnergySaveActive;
	        
	    END_REGION
	    
	    REGION 6.3 - Energy save
	        
	        IF #iUDT_UnloaderConfiguration.Energy THEN
	            
	            // Set Energy save active.
	            IF #si_AuxEnergySave >= #iUDT_UnloaderConfiguration.EnergySaveLength
	            THEN
	                #sx_EnergySaveActive := TRUE;
	            END_IF;
	            
	            // Reset or increment displacement calculation to use for energy save.
	            IF NOT #sx_PEC_EoSFiltered
	                OR #ix_ResetEnergySave
	                OR #ix_ManualControlled
	                //OR NOT #ix_ReadyUnload
	            THEN
	                #si_AuxEnergySave := 0;
	                #sx_EnergySaveActive := FALSE;
	            ELSE
	                #si_AuxEnergySave += #iqUDT_EquipmentInterface.Displacement;
	            END_IF;
	            
	        ELSE
	            
	            #si_AuxEnergySave := 0;
	            #sx_EnergySaveActive := FALSE;
	            
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 7 - Speed control
	    
	    // Copy speed setpoint from configuration.
	    #qi_SpeedSelect := #iUDT_UnloaderConfiguration.Speedsetpoint;
	    
	    // Clear speed setpoint depending on wrong configuration.
	    IF #iUDT_UnloaderConfiguration.Speedsetpoint < 0
	        OR #iUDT_UnloaderConfiguration.Speedsetpoint > 2
	    THEN
	        #qi_SpeedSelect := 0;
	    END_IF;
	    
	END_REGION
	
	REGION 8 - Reset
	    
	    // Safety ok extended pulse
	    #s_R_TRIG_SafetyOK(CLK := #ix_SafetyReset);
	    
	    #s_FB_TimerOnOffDelaySafetyOKPulse(iudi_OffDelayTime := 1000,
	                                       ix_SignalToDelay := #s_R_TRIG_SafetyOK.Q);
	    
	    // Fault and Estop reset outputs
	    #qx_FaultReset := #ix_SafetyReset OR #iqUDT_EquipmentControl.Command.Reset OR #s_FB_TimerOnOffDelaySafetyOKPulse.qx_DelayedSignal;
	    #qx_EStopReset := #ix_SafetyReset OR #s_FB_TimerOnOffDelaySafetyOKPulse.qx_DelayedSignal;
	    
	END_REGION
	
	REGION 9 - Statistics
	    
	    // Up time.
	    IF #sx_AutomaticActive
	        AND #sx_Ready
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sx_AutomaticActive AND #sx_Ready,
	                        ix_RTrigActivate := #sR_TRIG_ConveyorUp.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.ExtendableUpTime);
	    END_IF;
	    
	    // Down time.
	    IF #sx_AutomaticActive
	        AND #sx_Ready
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sx_AutomaticActive AND NOT #sx_Ready,
	                        ix_RTrigActivate := #sR_TRIG_ConveyorDown.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.ExtendableDownTime);
	    END_IF;
	    
	    // Energy save mode active.
	    IF #sx_EnergySaveActive
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_CommonStatus.EnergySave,
	                        
	                        ix_RTrigActivate := #sR_TRIG_EnergySave.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.EnergySave);
	    END_IF;
	    
	    // VFD Error.
	    IF #sUDT_HMIStatus.Specific.VFDError
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.VFDError,
	                        ix_RTrigActivate := #sR_TRIG_VFDError.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.VFDError);
	    END_IF;
	    
	    // Not healthy .
	    IF #sUDT_HMIStatus.Specific.NotHealthy
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.NotHealthy,
	                        ix_RTrigActivate := #sR_TRIG_NotHealthy.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.NotHealthy);
	    END_IF;
	    
	    // Too long parcel.
	    IF #sUDT_HMIStatus.Specific.TooLongParcel
	        OR #iqUDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #sUDT_HMIStatus.Specific.TooLongParcel,
	                        ix_RTrigActivate := #sR_TRIG_TooLongParcel.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.TooLongParcel);
	    END_IF;
	    
	END_REGION
	
	REGION 10 - Status
	    
	    // Set statuses.
	    #sUDT_CommonStatus.Stopped := NOT #sx_AutomaticActive;
	    #sUDT_CommonStatus.Running := #ix_Running;
	    #sUDT_CommonStatus.AutoON := #sx_Ready AND #sx_AutomaticActive;
	    #sUDT_CommonStatus.Halted := #ix_ExternalRequestHold AND #sUDT_CommonStatus.AutoON AND NOT #sx_EnergySaveActive;
	    #sUDT_CommonStatus.Dieback := (NOT #iqUDT_HandShake.RTR OR #ix_ExternalRequestDieBack) AND #sUDT_CommonStatus.AutoON AND NOT #sx_EnergySaveActive
	    AND NOT #sUDT_CommonStatus.EnergySave AND NOT #sUDT_CommonStatus.Running;
	    #sUDT_CommonStatus.Manual := #ix_ManualControlled;
	    #sUDT_CommonStatus.ManualRun := #sUDT_CommonStatus.Manual AND #sUDT_CommonStatus.Running;
	    #sUDT_CommonStatus.EnergySave := #sx_EnergySaveActive;
	    #sUDT_CommonStatus.SafetyStop := NOT #ix_SafetyOk;
	    
	    
	    // HMI status update on change.
	    IF #sUDT_CommonStatusOld <> #sUDT_CommonStatus
	    THEN
	        // HMI status initialization.
	        #sUDT_HMIStatus.Status := 0;
	        
	        // Energy save.
	        IF #sUDT_CommonStatus.EnergySave
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".EnergySave;
	        END_IF;
	        
	        // Running.
	        IF #sUDT_CommonStatus.Running
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Running;
	        END_IF;
	        
	        // Stopped.
	        IF #sUDT_CommonStatus.Stopped
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Stopped;
	        END_IF;
	        
	        // Dieback.
	        IF #sUDT_CommonStatus.Dieback
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Dieback;
	        END_IF;
	        
	        // Halted.
	        IF #sUDT_CommonStatus.Halted
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Halted;
	        END_IF;
	        
	        // Dimension error.
	        IF #sUDT_HMIStatus.Specific.TooLongParcel
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".DimensionError;
	        END_IF;
	        
	        // Manual.
	        IF #sUDT_CommonStatus.Manual
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Manual;
	        END_IF;
	        
	        // Running in manual mode.
	        IF #sUDT_CommonStatus.ManualRun
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".ManualRun;
	        END_IF;
	        
	        //  PEC error.
	        IF #sUDT_HMIStatus.Specific.PEC_EoS.Jam
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".PECJam;
	        END_IF;
	        
	        // Not healthy.
	        IF #sUDT_HMIStatus.Specific.NotHealthy
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".VFDNotHealthy;
	        END_IF;
	        
	        // VFD error.
	        IF #sUDT_HMIStatus.Specific.VFDError
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".VFDError;
	        END_IF;
	        
	        // Safety stop.
	        IF #sUDT_CommonStatus.SafetyStop
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".SafetyStop;
	        END_IF;
	        
	        // Copy statuses.
	        
	        #sUDT_CommonStatusOld := #sUDT_CommonStatus;
	        
	        
	    END_IF;
	    
	    #qUDT_HMIStatus := #sUDT_HMIStatus;
	    #qUDT_Status := #sUDT_CommonStatus;
	    
	END_REGION
	
	REGION 11 - Report to control block
	    
	    "FC_EquipmentReport"(iUDT_Status := #sUDT_CommonStatus,
	                         iqUDT_Control := #iqUDT_EquipmentControl);
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_TCPIPConnect"
TITLE = FB_TCPIPConnect
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : Communication
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 231
// END_ATTRIBUTES
//Function block to establish and terminateTCPIP connection.
   VAR_INPUT 
      iUDT_Connection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_Connection";   // Connection parameters
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_TCPIPConnectStatus";   // HMI status structure
      qUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   // Common status structure
      qx_Connected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Connected status
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
      iqUDT_Statistics : "UDT_TCPIPConnectStatistics";   // Statistic structure
      iqx_Reconnect { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reconnect command
   END_VAR

   VAR 
      sUDT_CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Common status structure
      sFB_TCON {InstructionName := 'TCON'; LibVersion := '4.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TCON;   // Siemens "TCON" block - to establish the connection
      sFB_TDISCON {InstructionName := 'TDISCON'; LibVersion := '2.1'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TDISCON;   // Siemens "TDISCON" block - to terminate the connection
      sFB_DIAG {InstructionName := 'T_DIAG'; LibVersion := '1.2'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : T_DIAG;   // Siemens "T_DIAG" block - to diagnose the connection
      sFB_TimerConTimeout { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // MHS "FB_TimerOnOffDelay" block - to measure the connection timeout
      sFB_TimerFilter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // MHS "FB_TimerOnOffDelay" block - to filter the connection established signal
      sv_InterfaceData {InstructionName := 'TCON_IP_v4'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TCON_IP_v4;   // TCON Interface configuration data
      sR_TRIG_ConnectionLost {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Siemens "R_TRIG" - to prepare rising edge signal on Connection lost signal
      sR_TRIG_Reset {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Siemens "R_TRIG" - to prepare rising edge signal on reset data signal
      sa_Connect { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // TCON interface structure
         Request { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TCON - Request
         Done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TCON - Done
         Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TCON - Busy
         Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TCON - Error
         Active { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TCON - Active
         Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   //  TCON - Status
      END_STRUCT;
      sa_Disconnect { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // TDISCON interface structure
         Request { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TDISCON - Request
         Done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TDISCON - Done
         Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TDISCON - Busy
         Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TDISCON - Error
         Active { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TDISCON - Active
         Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   //  TDISCON - Status
      END_STRUCT;
      sa_Diag { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // T_DIAG block diagnostic variables
         Request { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TDIAG - Request
         Done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TDIAG - Done
         Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TDIAG - Busy
         Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TDIAG - Error
         Active { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TDIAG - Active
         Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   //  TDIAG - Status
         Result {InstructionName := 'TDiag_Status'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TDiag_Status;   //  TDIAG - Result
      END_STRUCT;
      sx_Connected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Connection established memory
      sx_ConnectedFiltred { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Connection established memory (filtred)
      sx_CommunicationFault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Communication fault
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	13/06/2019  | 0.2       | A.Nowak       | Delete writing to variable - S_FB_Timer_ConTimeout
	24/06/2019  | 0.3       | L.Klar        | Status running added
	25/06/2019  | 0.5       | L.Klar        | Statistics changed to InOut
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	21/08/2019  | 2.1       | K.Pokorski    | Comments adjusted
	26/09/2019  | 2.2       | A.Nowak       | Delete static status structure and change region 9. Create new static sx_CommunicationFault.
	09/10/2019  | 2.3       | M.Kurc        | System equipment control added
	04/11/2019  | 2.4       | L.Klar        | 10 Hz clock and first scan changed from memory bit to DB variable
	19/11/2019  | 2.5       | L.Klar        | Status outputs corrected
	20/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – Initialization
	    
	    // Reset connected status bit and reconnect command bit during first PLC scan
	    IF ("DB_Memory".FirstScan)             // First PLC scan occured
	    THEN
	        
	        #sx_Connected := FALSE;
	        #iqx_Reconnect := TRUE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 – Connection error reset
	    
	    // Reset errors and blocks statuses when no connection state available and communication fault reset received 
	    #sR_TRIG_Reset(CLK := #iqUDT_EquipmentControl.Command.Reset);
	    
	    IF (#sx_CommunicationFault                                      // Communication fault 
	        AND #sR_TRIG_Reset.Q)                                      // Reset signal trigger
	    THEN
	        
	        #sa_Connect.Status := 16#0;
	        #sa_Disconnect.Status := 16#0;
	        #sa_Diag.Status := 16#0;
	        #sx_CommunicationFault := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 – Communication Interface preparation
	    
	    #sv_InterfaceData.InterfaceId := #iUDT_Connection.Interface_ID;                       // HW-identifier of IE-interface submodule 
	    #sv_InterfaceData.ID := #iUDT_Connection.ID;                                          // Connection reference / identifier
	    #sv_InterfaceData.ConnectionType := 16#0B;                                             // Type OF connection: 11=TCP/IP, 19=UDP 17=TCP/IP
	    #sv_InterfaceData.ActiveEstablished := #iUDT_Connection.ActiveEstablished;            // Active/passive connection establishment
	    #sv_InterfaceData.RemoteAddress.ADDR[1] := INT_TO_BYTE(#iUDT_Connection.IP[1]);       // Remote IP address (IPv4) - x.0.0.0
	    #sv_InterfaceData.RemoteAddress.ADDR[2] := INT_TO_BYTE(#iUDT_Connection.IP[2]);       // Remote IP address (IPv4) - 0.x.0.0
	    #sv_InterfaceData.RemoteAddress.ADDR[3] := INT_TO_BYTE(#iUDT_Connection.IP[3]);       // Remote IP address (IPv4) - 0.0.x.0
	    #sv_InterfaceData.RemoteAddress.ADDR[4] := INT_TO_BYTE(#iUDT_Connection.IP[4]);       // Remote IP address (IPv4) - 0.0.0.x 
	    
	    // Set local or remote port depending on whether the PLC is active or passive device in connection 
	    IF (#sv_InterfaceData.ActiveEstablished)                                               // Active connection
	    THEN
	        
	        #sv_InterfaceData.LocalPort := 0;
	        #sv_InterfaceData.RemotePort := #iUDT_Connection."Port";
	        
	        // Passive connection
	    ELSE
	        
	        #sv_InterfaceData.LocalPort := #iUDT_Connection."Port";
	        #sv_InterfaceData.RemotePort := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 – Connection establishment and termination
	    
	    IF (#iqx_Reconnect)                                                     // Reconnect request          
	    THEN
	        
	        // Terminate a TCPIP connection if reconnect command available and connection established
	        IF (#sx_Connected)                                                  // Connection established
	        THEN
	            
	            // Disconnect request 
	            #sa_Disconnect.Request :=
	            #iqx_Reconnect                                                  // Reconnect command
	            AND #sa_Disconnect.Status = 16#7000;                            // TDISCON block status is equal to 16#7000 (No job processing active)
	            
	            // Terminate a TCPIP connection when request available
	            #sFB_TDISCON(REQ := #sa_Disconnect.Request,
	                         ID := #sv_InterfaceData.ID,
	                         DONE => #sa_Disconnect.Done,
	                         BUSY => #sa_Disconnect.Busy,
	                         ERROR => #sa_Disconnect.Error,
	                         STATUS => #sa_Disconnect.Status);
	            
	            // In case of connection broken, connected bit and disconnect block active bit are reset
	            IF (#sa_Disconnect.Done)                                        // Disconnect was successful
	            THEN
	                
	                #sx_Connected := FALSE;
	                #sa_Disconnect.Active := FALSE;
	                
	                // Connection termination in progress
	            ELSE
	                
	                #sa_Disconnect.Active := TRUE;                              // Set the disconnecting active status bit 
	                
	            END_IF;
	            
	            // Try to establish connection if reconnect command active and there is no connection
	        ELSE                                                                // Connection is terminated 
	            
	            // Connect request
	            #sa_Connect.Request := #iqx_Reconnect AND                       // Reconnect command 
	            #sa_Connect.Status = 16#7000;            // TCON block status is equal to 16#7000 (No job processing active)
	            
	            // Establishing a TCPIP connection when request available
	            #sFB_TCON(REQ := #sa_Connect.Request,
	                      ID := #sv_InterfaceData.ID,
	                      DONE => #sa_Connect.Done,
	                      BUSY => #sa_Connect.Busy,
	                      ERROR => #sa_Connect.Error,
	                      STATUS => #sa_Connect.Status,
	                      CONNECT := #sv_InterfaceData);
	            
	            // In case of connection established, connected bit is set, connect block active bit and reconnect command are reset
	            IF (#sa_Connect.Done)                                           // Connect successful 
	            THEN
	                
	                #sx_Connected := TRUE;
	                #sa_Connect.Active := FALSE;
	                #iqx_Reconnect := FALSE;
	                
	                // Connection establishing in progress
	            ELSE
	                
	                #sa_Connect.Active := TRUE;                                 // Set the connecting active status
	                
	            END_IF;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 5 – Connection establishment and termination error handling
	    
	    // Measure the maximum connect or disconnect time
	    #sFB_TimerConTimeout(ix_SignalToDelay := #sa_Connect.Active
	                         OR #sa_Disconnect.Active,
	                         iudi_OnDelayTime := DINT_TO_UDINT(#iUDT_Connection.ConTimeout),
	                         iudi_OffDelayTime := 0);
	    
	    IF (#sFB_TimerConTimeout.qx_DelayedSignal)                                                 // Connecting / disconnecting time error from connection timeout timer
	    THEN
	        
	        IF (#sa_Connect.Active)                                                                  // Connecting is active
	        THEN
	            
	            // If connection already exist and block try establish connection, connected bit is set, connect block active bit and reconnect command are reset
	            IF (#sa_Connect.Status = 16#80A3)                                                    // Connecting status equal to 16#80A3 - The connection already exist
	            THEN
	                
	                #sx_Connected := TRUE;
	                #sa_Connect.Active := FALSE;
	                #iqx_Reconnect := FALSE;
	                
	                // Connection time has expired - error generated
	            ELSE
	                
	                #sx_CommunicationFault := TRUE;
	                
	            END_IF;
	            
	            // Disconnect operation failed - error generated 
	        ELSIF (#sa_Disconnect.Active)
	        THEN
	            
	            #sx_CommunicationFault := TRUE;
	            
	        END_IF;
	        
	    END_IF;
	    
	    // The connection terminated by partner - error generated, connected bit reset and reconnect command request set
	    IF (#sa_Diag.Result.State <> 16#04)                         // The connection terminated by partner                                                    
	    THEN
	        
	        #sx_CommunicationFault := TRUE;
	        #sx_Connected := FALSE;
	        #iqx_Reconnect := TRUE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 6 – Connection diagnostic
	    
	    // Check connection condition ten times per second
	    IF (NOT #sa_Connect.Active AND NOT #sa_Disconnect.Active)        // Connecting and disconnecting procedure are not active
	    THEN
	        
	        #sFB_DIAG(REQ := "DB_Memory".Clock_10Hz,
	                  ID := #sv_InterfaceData.ID,
	                  DONE => #sa_Diag.Done,
	                  BUSY => #sa_Diag.Busy,
	                  ERROR => #sa_Diag.Error,
	                  STATUS => #sa_Diag.Status,
	                  RESULT := #sa_Diag.Result);
	        
	    END_IF;
	    
	END_REGION
	
	REGION 7 – Connection established filter
	    
	    // Connected status bit filtering
	    #sFB_TimerFilter(ix_SignalToDelay := #sx_Connected,
	                     iudi_OnDelayTime := 50,
	                     qx_DelayedSignal => #sx_ConnectedFiltred);
	    
	END_REGION
	
	REGION 8 – Statistics
	    
	    // Prepare rising edge of connected status signal 
	    #sR_TRIG_ConnectionLost(CLK := NOT #sx_ConnectedFiltred);
	    
	    // Conditions to call "FC_Statistics" 
	    IF (NOT #sx_ConnectedFiltred                                                        // No connection 
	        OR #iqUDT_EquipmentControl.Command.ResetData)                                  // Reset data
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := NOT #sx_ConnectedFiltred,
	                        ix_RTrigActivate := #sR_TRIG_ConnectionLost.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.ConnectionLost);
	        
	    END_IF;
	    
	END_REGION
	
	REGION 9 – Status
	    
	    #sUDT_CommonStatus.Error := #sx_CommunicationFault;                        // Error
	    
	    #sUDT_CommonStatus.AutoON := #sx_ConnectedFiltred;                         // Auto ON
	    
	    #qUDT_HMIStatus.Specific.CommunicationFault := #sx_CommunicationFault;     // Communication faults
	    
	    #qUDT_HMIStatus.Specific.Connected := #sx_ConnectedFiltred;                // Connected
	    
	    IF #sUDT_CommonStatus.AutoON                                               // Auto ON
	    THEN
	        
	        #qUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".AutoON;
	        
	    END_IF;
	    
	    IF #sUDT_CommonStatus.Error                                                // Error
	    THEN
	        
	        #qUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Error;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 10 Report to control block
	    
	    // Function to manage report between control block and conveyor block
	    
	    "FC_EquipmentReport"(iUDT_Status := #sUDT_CommonStatus,
	                         iqUDT_Control := #iqUDT_EquipmentControl);
	    
	END_REGION
	
	REGION 11 – Write outputs
	    
	    #qx_Connected := #sx_Connected;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_SystemControl"
TITLE = FB_SystemControl
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 230
// END_ATTRIBUTES
//Function block to control the system.
   VAR_INPUT 
      iudi_SignalingTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Signaling time [ms]
      ix_SignalingIOModuleOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Beeper and lamp IO module ok
      ix_HMIConnectionOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE = HMI connection is active
      ix_ExternalError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE - External error occurred
      ix_SafetyOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE - Safety OK
      ix_Start { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start command from control panel
      ix_Stop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stop command from control panel
      ix_Reset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset command from control panel
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_SystemControlStatus";   // HMI status structure
      qUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   // Status structure
      qx_StartingFlashLamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Flash lamp
      qx_StartingBeeper { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Beeper starting
      qx_ErrorLamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Equipment error lamp
      qx_SafetyStopLamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Safety stop lamp
      qx_StoppedLamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Equipment stopped lamp
      qx_StartedLamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Equipment started lamp
      qx_WarningLamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Equipment warning lamp
   END_VAR

   VAR_IN_OUT 
      iqUDT_SystemControlCommand : "UDT_SystemControlCommand";   // HMI system control structure
      iqUDT_Equipment : "UDT_EquipmentControl";   // Equipment control structure
      iqUDT_Statistics : "UDT_SystemControlStatistics";   // Statistics structure
   END_VAR

   VAR 
      sUDT_CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Status structure
      sUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_SystemControlStatus";   // Status structure
      sUDT_CommonStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Old status structure
      sUDT_SystemControlCommand { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_SystemControlCommand";   // HMI system control structure
      sFB_TimerOnOffDelaySignaling { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer to calculate the signaling time
      sR_TRIG_PB_Start {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for start push button
      sR_TRIG_PB_Stop {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for stop push button
      sR_TRIG_PB_Reset {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for reset push button
      sR_TRIG_SystemStarted {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for system started statistics
      sR_TRIG_SystemError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for system error statistics
      sR_TRIG_EnergySave {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge for system in energy save mode statistics
      sx_SignalingDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Signaling finished
      sx_StartSignalingRequired { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start signaling required
      sx_SystemStartup { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // System startup procedure in progress
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | K.Pokorski    | first release MHS TIA 15.1
	17/06/2019  | 0.2       | K.Pokorski    | implementation a new concept
	18/06/2019  | 0.3       | K.Pokorski    | remove reset safety handling
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	28/08/2019  | 2.1       | K.Pokorski    | Correction of block logic and adjusting comments
	13/09/2019  | 2.2       | K.Pokorski    | Lamp outputs added
	14/10/2019  | 2.3       | L.Klar        | Updated status structure
	28/10/2019  | 2.4       | K. Pokorski   | Updated region 1, 6 & 9 - compliance with the new status
	04/11/2019  | 2.5       | L.Klar        | 1 Hz clock and first scan changed from memory bit to DB variable
	20/11/2019  | 2.6       | S. Deulkar    | Always Reseting commads to equipment at the beginning of the block 
	21/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	22/05/2020  | 3.1       | M.Roijen      | Disable Start in Signaling handling when in System-Manualmode.
	09/07/2020  | 3.2       | S.Theocharis  | Bug fix in status update. Initialize static status instead output status
	31/07/2020  | 3.3       | S.Theocharis  | Add one shot detection of the push buttons
	11/01/2021  | 3.4       | L.Klar        | iq_UDT_Equipment.Report.SafetyStop removed from automatic on/off
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	12/03/2024  | 4.1       | S. Nieswiec   | Variable name changes according to standard
	*)
	
	REGION 1 - Push button triggers
	    
	    #sR_TRIG_PB_Start(CLK := #ix_Start);                                            //Start button
	    
	    
	    #sR_TRIG_PB_Stop(CLK := #ix_Stop);                                              //Stop button 
	    
	    
	    #sR_TRIG_PB_Reset(CLK := #ix_Reset);                                            //Reset button 
	    
	END_REGION
	
	
	REGION 2 – HMI and control panel commands handling
	    
	    // Reset all HMI commands during first PLC cycle
	    IF "DB_Memory".FirstScan                                                        // First PLC cycle occurred
	    THEN
	        #iqUDT_SystemControlCommand.Start := FALSE;
	        #iqUDT_SystemControlCommand.Stop := FALSE;
	        #iqUDT_SystemControlCommand.Reset := FALSE;
	        #iqUDT_SystemControlCommand.ResetSafety := FALSE;
	        #iqUDT_SystemControlCommand.ResetData := FALSE;
	        #iqUDT_SystemControlCommand.ManualMode := FALSE;
	        #iqUDT_Equipment.Command.AutomaticOn := FALSE;
	        #iqUDT_Equipment.Command.ManualMode := FALSE;
	        #iqUDT_Equipment.Command.DisableManualMode := FALSE;
	        #iqUDT_Equipment.Request.RestartRequired := FALSE;
	        #iqUDT_Equipment.Request.SignalingRequest := FALSE;
	    END_IF;
	    
	    // Clear commands to equipments
	    #iqUDT_Equipment.Command.Start := FALSE;
	    #iqUDT_Equipment.Command.Stop := FALSE;
	    #iqUDT_Equipment.Command.Reset := FALSE;
	    #iqUDT_Equipment.Command.ResetData := FALSE;
	    
	    // Move HMI control structure to static buffer
	    #sUDT_SystemControlCommand := #iqUDT_SystemControlCommand;
	    
	    // Extension of HMI commands with a commands from control panel 
	    #sUDT_SystemControlCommand.Start := #sUDT_SystemControlCommand.Start OR #sR_TRIG_PB_Start.Q;        // Extension of HMI start command with a start command from control panel 
	    #sUDT_SystemControlCommand.Stop := #sUDT_SystemControlCommand.Stop OR #sR_TRIG_PB_Stop.Q;           // Extension of HMI stop command with a stop command from control panel
	    #sUDT_SystemControlCommand.Reset := #sUDT_SystemControlCommand.Reset OR #sR_TRIG_PB_Reset.Q;        // Extension of HMI reset command with a reset command from control panel 
	    
	END_REGION
	
	REGION 3 – Signaling handling
	    
	    // Starting signaling time
	    IF ((NOT #ix_ExternalError                                                      // External error not occurred 
	        AND (#sUDT_SystemControlCommand.Start                                       // Start command received
	        AND NOT #sUDT_SystemControlCommand.ManualMode                               // Not in manual Mode
	        )
	        AND NOT #sUDT_SystemControlCommand.Stop                                     // Stop command not received
	        AND (#iqUDT_Equipment.Report.Stopped                                        // System stopped 
	        OR #iqUDT_Equipment.Request.RestartRequired                                 // Restart Required
	        ))
	        OR #iqUDT_Equipment.Request.SignalingRequest
	        )                                                                           // Equipment request signaling 
	        AND #ix_SignalingIOModuleOK                                                 // Signaling module OK
	        
	    THEN
	        
	        #sx_StartSignalingRequired := TRUE;
	        
	        IF (#sUDT_SystemControlCommand.Start)
	        THEN
	            #sx_SystemStartup := TRUE;                                              // Set the system startup flag
	        END_IF;
	        
	        // Stopping signaling time
	    ELSIF (#sUDT_SystemControlCommand.Stop                                          // Stop command from HMI available
	        OR #ix_ExternalError                                                        // Exernal error occured
	        OR NOT #ix_SignalingIOModuleOK)                                             // Signaling module ok 
	    THEN
	        #sx_StartSignalingRequired := FALSE;
	        #sx_SystemStartup := FALSE;
	    END_IF;
	    
	    // Measure the signaling time
	    #sFB_TimerOnOffDelaySignaling(iudi_OnDelayTime := #iudi_SignalingTime,
	                                  iudi_OffDelayTime := 0,
	                                  ix_SignalToDelay := #sx_StartSignalingRequired,
	                                  ix_Enable := TRUE,
	                                  qx_DelayedSignal => #sx_SignalingDone);
	    
	END_REGION
	
	REGION 4 – Automatic ON / OFF
	    
	    // Signaling time elapsed
	    IF (#sx_SignalingDone) THEN
	        
	        #iqUDT_Equipment.Request.SignalingRequest := FALSE;                         // Reset signaling request
	        
	        IF #sx_SystemStartup
	            AND #ix_SafetyOK
	        THEN
	            #iqUDT_Equipment.Command.Start := TRUE;                                 // Start system 
	            #iqUDT_Equipment.Command.AutomaticOn := TRUE;                           // And turn on automatic mode
	            #sx_SystemStartup := FALSE;
	        END_IF;
	        
	        IF #sx_SystemStartup
	            OR #ix_SafetyOK
	        THEN
	            #sx_SystemStartup := FALSE;
	        END_IF;
	        
	        #sx_StartSignalingRequired := FALSE;                                        // Reset signaling timer
	        #sx_SignalingDone := FALSE;
	    END_IF;
	    
	    // Stopping system and reset automatic mode command 
	    IF #ix_ExternalError                                                            // External error occured
	        OR #sUDT_SystemControlCommand.Stop                                          // Stop command received from HMI
	        OR #sUDT_SystemControlCommand.ManualMode                                    // Manual mode active
	        OR NOT #ix_SafetyOK
	        
	    THEN
	        #iqUDT_Equipment.Command.Stop := TRUE;
	        #iqUDT_Equipment.Command.AutomaticOn := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 5 – Commands to equipment
	    
	    #iqUDT_Equipment.Command.Reset := #sUDT_SystemControlCommand.Reset;             // Move reset HMI command to reset equipment command
	    #iqUDT_Equipment.Command.ResetData := #sUDT_SystemControlCommand.ResetData;     // Move reset data HMI command to reset data equipment command
	    #iqUDT_Equipment.Command.ManualMode := #sUDT_SystemControlCommand.ManualMode;   // Move manual mode HMI command to manual mode equipment command
	    #iqUDT_Equipment.Command.DisableManualMode := NOT #ix_HMIConnectionOK;          // Disable manual mode if HMI connection is broken  
	    
	END_REGION
	
	REGION 6 – Lamp state updating
	    
	    // Light warning before equipment starting. Flashes with a frequency of one period per second.
	    #qx_StartingFlashLamp :=
	    #sx_StartSignalingRequired
	    AND NOT #sx_SignalingDone
	    AND "DB_Memory".Clock_1Hz;
	    
	    // Audiable warning before equipment starting. Intermittent signaling with a frequency of one period per second.
	    #qx_StartingBeeper :=
	    #sx_StartSignalingRequired
	    AND NOT #sx_SignalingDone
	    AND "DB_Memory".Clock_1Hz;
	    
	    // Lamp lighting when an external error or equipment's error occurred
	    #qx_ErrorLamp :=
	    #iqUDT_Equipment.Report.Error
	    OR #ix_ExternalError;
	    
	    // Lamp lighting when the safety error occurred or equipment report the safety stop
	    #qx_SafetyStopLamp :=
	    #iqUDT_Equipment.Report.SafetyStop
	    OR NOT #ix_SafetyOK;
	    
	    // Lamp lighting when the system is stopped
	    #qx_StoppedLamp := NOT #iqUDT_Equipment.Command.AutomaticOn;
	    
	    // Lamp lighting when the system is started
	    #qx_StartedLamp := #iqUDT_Equipment.Report.Running;
	    
	    // Lamp lighting when the equipment report a warning
	    #qx_WarningLamp := #iqUDT_Equipment.Report.Warning;
	    
	END_REGION
	
	REGION 7 – Equipment state update
	    
	    #sUDT_CommonStatus.EnergySave := #iqUDT_Equipment.Report.EnergySave;                         // Move equipment state "EnergySave" from the equipment structure to status structure
	    #sUDT_CommonStatus.Error := #iqUDT_Equipment.Report.Error;                                   // Move equipment state "Error" from the equipment structure to status structure 
	    #sUDT_CommonStatus.Running := #iqUDT_Equipment.Report.Running;                               // Move equipment state "Started" from the equipment structure  to status structure 
	    #sUDT_CommonStatus.SafetyStop := #iqUDT_Equipment.Report.SafetyStop OR NOT #ix_SafetyOK;     // Move equipment state "Safety" from the input and the equipment structure to status structure
	    #sUDT_CommonStatus.Stopped := #iqUDT_Equipment.Report.Stopped;                               // Move equipment state "Stopped" from the equipment structure to status structure 
	    #sUDT_CommonStatus.Warning := #iqUDT_Equipment.Report.Warning;                               // Move equipment state "Warning" from the equipment structure to status structure 
	    #sUDT_CommonStatus.Manual := #iqUDT_Equipment.Report.Manual;                                 // Move equipment state "ManualMode" from the equipment structure to status structure
	    
	END_REGION
	
	REGION 8 – Status update
	    
	    IF #sUDT_CommonStatus <> #sUDT_CommonStatusOld                                  // Actual status is different than the old one
	    THEN
	        
	        // HMI status initialization
	        #sUDT_HMIStatus.Status := 0;
	        
	        // HMI status calculation
	        IF #sUDT_CommonStatus.EnergySave                                            // Energy save
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".EnergySave;
	        END_IF;
	        
	        IF #sUDT_CommonStatus.Running                                               // Running
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Running;
	        END_IF;
	        
	        IF #sUDT_CommonStatus.Stopped                                               // Stopped
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Stopped;
	        END_IF;
	        
	        IF #sUDT_CommonStatus.Dieback                                               // Dieback
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Dieback;
	        END_IF;
	        
	        IF #sUDT_CommonStatus.Halted                                                // Halted
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Halted;
	        END_IF;
	        
	        IF #sUDT_CommonStatus.Manual                                                // Manual
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Manual;
	        END_IF;
	        
	        IF #sUDT_CommonStatus.ManualRun                                             // Running in manual mode
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".ManualRun;
	        END_IF;
	        
	        IF #sUDT_CommonStatus.Warning                                               // Warning
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Warning;
	        END_IF;
	        
	        IF #sUDT_CommonStatus.Error                                                 // Error
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Error;
	        END_IF;
	        
	        
	        IF (#sUDT_CommonStatus.SafetyStop)                                          // Safety stop
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".SafetyStop;
	        END_IF;
	        
	        
	        #sUDT_CommonStatusOld := #sUDT_CommonStatus;                                // Copy status to memory
	        #qUDT_Status := #sUDT_CommonStatus;
	        
	    END_IF;
	    
	    #qUDT_HMIStatus := #sUDT_HMIStatus;                                            // Copy status to output
	    
	END_REGION
	
	REGION 9 – Statistics   
	    
	    // System started
	    #sR_TRIG_SystemStarted(CLK := #iqUDT_Equipment.Report.Running);                 // The system has started
	    
	    IF #iqUDT_Equipment.Report.Running OR #iqUDT_SystemControlCommand.ResetData     // System running statistics handling
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_SystemControlCommand.ResetData,
	                        ix_Activate := #iqUDT_Equipment.Report.Running,
	                        ix_RTrigActivate := #sR_TRIG_SystemStarted.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.Run);
	    END_IF;
	    
	    // System error
	    #sR_TRIG_SystemError(CLK := #iqUDT_Equipment.Report.Error);                     // System error occured
	    
	    IF #iqUDT_Equipment.Report.Error OR #iqUDT_SystemControlCommand.ResetData       // Error statistics
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_SystemControlCommand.ResetData,
	                        ix_Activate := #iqUDT_Equipment.Report.Error,
	                        ix_RTrigActivate := #sR_TRIG_SystemError.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.Error);
	    END_IF;
	    
	    // Energy save
	    #sR_TRIG_EnergySave(CLK := #iqUDT_Equipment.Report.EnergySave);                 // Energy save
	    
	    IF #iqUDT_Equipment.Report.EnergySave OR #iqUDT_SystemControlCommand.ResetData  // Energy save 
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_SystemControlCommand.ResetData,
	                        ix_Activate := #iqUDT_Equipment.Report.EnergySave,
	                        ix_RTrigActivate := #sR_TRIG_EnergySave.Q,
	                        iqUDT_Statistics := #iqUDT_Statistics.EnergySave);
	    END_IF;
	    
	END_REGION
	
	REGION 11 – Reset the equipment states
	    
	    #iqUDT_Equipment.Report.EnergySave := FALSE;           // Reset equipment report - energy save
	    #iqUDT_Equipment.Report.Error := FALSE;                // Reset equipment report - error
	    #iqUDT_Equipment.Report.Manual := FALSE;               // Reset equipment report - manual mode
	    #iqUDT_Equipment.Report.ManualRun := FALSE;            // Reset equipment report - run in manual mode
	    #iqUDT_Equipment.Report.AutoON := FALSE;               // Reset equipment report - automatic mode on
	    #iqUDT_Equipment.Report.Dieback := FALSE;              // Reset equipment report - dieback
	    #iqUDT_Equipment.Report.Halted := FALSE;               // Reset equipment report - halted
	    #iqUDT_Equipment.Report.SafetyStop := FALSE;           // Reset equipment report - safety stop
	    #iqUDT_Equipment.Report.Running := FALSE;              // Reset equipment report - started
	    #iqUDT_Equipment.Report.Stopped := FALSE;              // Reset equipment report - stopped
	    #iqUDT_Equipment.Report.Warning := FALSE;              // Reset equipment report - warning
	    #iqUDT_Equipment.Request.RestartRequired := FALSE;     // Reset equipment report - restart required
	    
	END_REGION
	
	REGION 12 – Reset the HMI commands
	    
	    #iqUDT_SystemControlCommand.Start := FALSE;             // Reset the HMI start command bit 
	    #iqUDT_SystemControlCommand.Stop := FALSE;              // Reset the HMI stop command bit 
	    #iqUDT_SystemControlCommand.ResetData := FALSE;         // Reset the HMI statistic reset bit
	    #iqUDT_SystemControlCommand.Reset := FALSE;             // Reset the HMI faults reset bit
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_VRCapacity"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 40
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_CapacityConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CapacityConfiguration";   // Capacity configuration structure
      ix_PECFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when the end of section photoeye is not blocked
      ix_ResetData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset data
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block error occurred
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block warning occurred
      qi_Capacity { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Capacity value
      qa_CapacityBuffer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..#Samples] of Int;   // Capacity buffer
      qa_PPHBuffer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..#Samples] of Int;   // Parcel per hour buffer
   END_VAR

   VAR_IN_OUT 
      iqUDT_ConveyorInterface : "UDT_ConveyorInterface";   // Conveyor interface
   END_VAR

   VAR 
      sFB_Pulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Pulse";   // Function block to generate custom pulse signal.
      sR_TRIG_ParcelDetect {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Parcel detect
      sa_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FifoError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    FIFO block error
         FifoWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    FIFO block warning
         ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    Collective configuration error
      END_STRUCT;
      sr_CollectiveParcelLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Colletive parcel length [mm]
      sr_ParcelCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Parcel count
      sr_RecalculatedWindow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Window recalculated based on configured avg parcel length
      sr_ParcelPerHour { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Parcel(s) per hour
      sr_AveragePackageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Average parcel length [mm]
      sr_AverageGap { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Average gap size [mm]
      sr_AverageWindow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Average window size [mm]
      sudi_Interval { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Interval [ms]
      si_Capacity { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Capacity value for the configured package length
      si_ConveyorDistanceTraveled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Distance the conveyour travelled this interval
      sx_ParcelDetected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;   // Parcel detected
      sx_SendData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send data signal
   END_VAR

   VAR CONSTANT 
      Samples : ULInt := 120;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	21/01/2020  | 3.0       | A.Nowak       | Initial version
	14/02/2020  | 3.1       | A.Nowak       | Add sample amount and treshold to the configuration and reset data functionality
	13/03/2020  | 3.2       | M.Kurpiers    | Adapting reviews
	23/03/2020  | 3.3       | A. Nowak      | Change the values to the mm
	20/04/2022  | 3.4       | M.Roijen      | Remove MFC logging and added the shift of data
	06/08/2022  | 3.5       | M.Singh       | add Reset PPH Buffer and used avg Length from Config. 
	15/05/2023  | 4.0       | F.Baten       | Lib 4.0
	                                          Removed Displacement memory, SampleAmount, fixed #sr_AveragePackageLength calculation.
	12/03/2024  | 4.1       | S. Nieswiec   | Small variable name changes according to current standard                                           
	*)
	
	REGION 1 - Configuration check
	    
	    // If the block is configured properly, convert interval to the ms and reset the error. Otherwise, set configuration error.
	    IF #iUDT_CapacityConfiguration.Interval > 0
	        AND #iUDT_CapacityConfiguration.AveragePackageLengthConfiguration > 0
	        AND #iUDT_CapacityConfiguration.Treshold >= 0
	    THEN
	        #sudi_Interval := #iUDT_CapacityConfiguration.Interval * 1000;
	        #sa_Status.ConfigurationError := FALSE;
	    ELSE
	        #sa_Status.ConfigurationError := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Reset data
	    
	    // If there is reset data request, initialize sample amount and data buffer.
	    IF #ix_ResetData
	    THEN
	        FILL_BLK(IN := 0,
	                 COUNT := #Samples,
	                 OUT => #qa_CapacityBuffer[0]);
	        FILL_BLK(IN := 0,
	                 COUNT := #Samples,
	                 OUT => #qa_PPHBuffer[0]);
	    END_IF;
	    
	END_REGION
	
	REGION 4 - PEC
	    
	    #sx_ParcelDetected := NOT #ix_PECFiltered;
	    
	END_REGION
	
	REGION 5 - Interval check
	    
	    // Generate puls signal every interval. 
	    #sFB_Pulse(iudi_PulseTime := #sudi_Interval,
	               qx_Pulse => #sx_SendData);
	    
	END_REGION
	
	REGION 6 - Package length measurement and parcel count
	    
	    // Parcel is detected.
	    IF #sx_ParcelDetected
	    THEN
	        // Add displacement to the collective parcel length.
	        #sr_CollectiveParcelLength += (ABS(#iqUDT_ConveyorInterface.Displacement)) * 10;
	    END_IF;
	    
	    #sR_TRIG_ParcelDetect(CLK := #sx_ParcelDetected);
	    // Increment parcel count when package is detected.
	    IF #sR_TRIG_ParcelDetect.Q
	    THEN
	        #sr_ParcelCount += 1;
	    END_IF;
	    
	    // Measure the distance traveled by conveyor
	    #si_ConveyorDistanceTraveled += (ABS(#iqUDT_ConveyorInterface.Displacement)) * 10;
	    
	END_REGION
	
	REGION 7 - Capacity calculation and data send
	    
	    // There is no configuration error and there are send data and enable signals.
	    IF NOT #sa_Status.ConfigurationError
	        AND #sx_SendData
	    THEN
	        // Parcel was detected.
	        IF #sr_ParcelCount <> 0
	            AND #sr_CollectiveParcelLength <> 0
	        THEN
	            // Calculate average values.
	            #sr_AveragePackageLength := #sr_CollectiveParcelLength / #sr_ParcelCount;
	            #sr_AverageWindow := #si_ConveyorDistanceTraveled / #sr_ParcelCount;
	            #sr_AverageGap := #sr_AverageWindow - #sr_AveragePackageLength;
	            
	            // Windowsize calculated based on configured average parcel length
	            #sr_RecalculatedWindow := #sr_AverageGap + #iUDT_CapacityConfiguration.AveragePackageLengthConfiguration;
	            
	            // Calculate parcel per hour value for the configured average parcel length.
	            #si_Capacity := DINT_TO_INT(TRUNC((#sr_ParcelPerHour * #sr_AverageWindow) / #sr_RecalculatedWindow));
	            
	            // Calculate parcel per hour value using data from the interval.
	            #sr_ParcelPerHour := (#sr_ParcelCount / UDINT_TO_REAL(#iUDT_CapacityConfiguration.Interval)) * 3600;
	            
	        ELSE
	            #si_Capacity := 0;
	        END_IF;
	        
	        #qi_Capacity := #si_Capacity;
	        
	        // Capacity value is greater than configured treshold.
	        IF #si_Capacity >= #iUDT_CapacityConfiguration.Treshold
	        THEN
	            
	            MOVE_BLK(IN := #qa_CapacityBuffer[0],
	                     COUNT := #Samples,
	                     OUT => #qa_CapacityBuffer[1]);
	            #qa_CapacityBuffer[0] := #si_Capacity;
	            
	            MOVE_BLK(IN := #qa_PPHBuffer[0],
	                     COUNT := #Samples,
	                     OUT => #qa_PPHBuffer[1]);
	            #qa_PPHBuffer[0] := REAL_TO_INT(#sr_ParcelPerHour);
	        END_IF;
	        
	        // Initialize parcel count and collective parcel length.
	        #sr_ParcelCount := 0;
	        #sr_CollectiveParcelLength := 0;
	        #si_ConveyorDistanceTraveled := 0;
	    END_IF;
	    
	END_REGION
	
	REGION 8 - Status 
	    
	    // Collective error.
	    #qx_Error :=
	    #sa_Status.ConfigurationError
	    OR #sa_Status.FifoError;
	    
	    // Collective warning.
	    #qx_Warning := #sa_Status.FifoWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_VSUDivert"
TITLE = FB_VerticalSwitch
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : Equipment
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 41
// END_ATTRIBUTES
//Function block to control vertical switch unit.
   VAR_INPUT 
      iUDT_VSUConfig { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VSUConfiguration";   //   VSU Configuration structure
      iUDT_ConveyorConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorConfiguration";   //  VSB Conveyor cofiguration structure
      idi_ConveyorLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   Length of VSU conveyor [mm]
      ix_SafetyOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when Safety Circuit of the Conveyor is healthy
      ix_PosUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when position sensor is covered
      ix_PosDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when position sensor is covered
      ix_PECEos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when PEC EOS is not blocked
      ix_PECUpperOut { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when PEC Upper outfeed is not blocked
      ix_PECLowerOut { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when PEC Lower outfeed is not blocked
      ix_PECJamUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when PEC Jamdetection going up is not blocked
      ix_PECJamDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when PEC Jamdetection going down is not blocked
      ix_LCPAutoMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when LocalControlPanel switch Automatic is on
      ix_LCPManualMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when LocalControlPanel switch Manual is on
      ix_LCPDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when LocalControlPanel switch Down is on
      ix_LCPUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when LocalControlPanel switch Up is on
      ix_LCPRef { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when LocalControlPanel switch Refference is on
      ix_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  TRUE when  hardware is Ok
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VSUStatus";   //   HMI status structure
      qUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   //   Common status structure
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   //   Equipment control structure
      iqUDT_VSUCommand : "UDT_VSUCommand";   //   VSU HMI Command structure
      iqUDT_VSUInterface : "UDT_VSUInterface";   //   Interface between VSU and VFD
      iqUDT_ConveyorInterface : "UDT_ConveyorInterface";   //   Interface between VSU and VSU conveyor
      iqUDT_HandShakeVSUConveyor : "UDT_ConveyorHandshake";   //   VSU handshaking interface to VSU conveyor
      iqUDT_HandShakeUpperPosition : "UDT_ConveyorHandshake";   //   VSU handshaking interface to upper outfeed conveyor
      iqUDT_HandShakeLowerPosition : "UDT_ConveyorHandshake";   //   VSU handshaking interface to lower outfeed conveyor
      iqUDT_Statistics : "UDT_VSUStatistics";   //   Statistics structure
   END_VAR

   VAR 
      sUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VSUStatus";   //   HMI status structure
      sUDT_StatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //   Common status structure
      sUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //   Common status structure
      sFB_PECEoSFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //   Filtering end of section photo eye signal
      sFB_PECUpOutFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //   Filtering upper outfeed photo eye signal
      sFB_PECLowOutFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //   Filtering lower outfeed photo eye signal
      sFB_PEC_UpJamFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //   Filtering upper jam photo eye signal
      sFB_PEC_LowJamFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //   Filtering lower jam photo eye signal
      sFB_JogEnable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //   Filtering lower jam photo eye signal
      sFB_MaxStopTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //   Timer for maximum stopping time
      sR_TRIG_ManualMode {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge trigger manual mode
      sR_TRIG_ManualJogUp {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge trigger manual jog mode command
      sR_TRIG_ManualJogDown {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge trigger manual jog mode command
      sR_TRIG_DownTime {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge trigger VSU is stopped
      sR_TRIG_Error {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge trigger for Error
      sR_TRIG_UPSwA_Error {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge trigger for Upper switch area error
      sR_TRIG_LowSwA_Error {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge trigger for Lower switch area error
      sR_TRIG_UPEntr_Jam {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge trigger for Upper Entrance Jam
      sR_TRIG_LowEntr_Jam {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge trigger for Lower Entrance Jam
      sR_TRIG_Direction_Error {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge trigger for Direction error
      sR_TRIG_UpTime {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge trigger VSU is running automatic
      sR_TRIG_GOReference {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge trigger for VFD to do reference run
      sR_TRIG_Referenced {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge trigger VFD refferenced
      sR_TRIG_TIPLeavingVSU {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge trigger TIP VSU Conveyor
      sF_TRIG_TIPLeavingVSU {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //   Falling edge trigger TIP VSU Conveyor
      sR_TRIG_RestartFromError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge trigger Restart from error
   END_VAR
   VAR RETAIN
      sdi_RunEmpty { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   Calculation run empty distance
   END_VAR
   VAR 
      si_Position { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Position from Decisionpoint
      si_RequiredGap { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Required gap in front of VSU
   END_VAR
   VAR RETAIN
      si_UpperHeadToHead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Gap calculation Head To Head upper conveyor
      si_UpperGap { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Gap calculation upper outfeed conveyor
      si_LowerHeadToHead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Gap calculation Head To Head lower conveyor
      si_LowerGap { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Gap calculation lower outfeed conveyor
      si_UpJamDisplacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Auxiliary variable to calculate displacement when PEC is blocked
      si_LowJamDisplacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Auxiliary variable to calculate displacement when PEC is blocked
   END_VAR
   VAR 
      si_DefaultPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Auxiliary variable to set default position
      sx_StartReceived { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Start command received from system
      sx_PEC_EoSFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   End of section photo eye filtered
      sx_PEC_UpOutFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Upper outfeed photo eye filtered
      sx_PEC_LowOutFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Lower outfeed photo eye filtered
      sx_PEC_UpJamFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Upper jam photo eye filtered
      sx_PEC_LowJamFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Lower jam photo eye filtered
      sx_Ready { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Conveyor Ready to operate in Automatic mode
      sx_AutomaticActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Running in automatic
      sx_SemiAutomatic { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Running in semi automatic
      sx_PositionAfterRef { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   After reffer
      sx_PreStartManual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Pre conditions to run conveyor in manual mode
      sx_ManualModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Manual mode active
      sx_Stopping { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Stopping is active, first reach position
      sx_SwitchEnable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Switching conditions
      sx_UpRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Request upper outfeed position for actual parcel
      sx_DownRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Request lower outfeed position for actual parcel
      sx_ActualPositionUP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Actual position is up
      sx_ActualPositionDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Actual position is down
      sx_GappingUpper { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Gapping upper outfeed is active
      sx_GappingLower { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Gapping lower outfeed is active
      sx_CombinedJogUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Combined signal of jogging buttons
      sx_CombinedJogDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Combined signal of jogging buttons
      sx_RestartFromError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   After an error has occurred the action to be done before resuming normal operation
      sx_StopInfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Stop infeed conveyor
      sx_Jog { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Off delayed signal Jogging was activated
      sx_ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Commissioning: configuration of parameters is wrong
   END_VAR

   VAR_TEMP 
      tr_req : Real;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	03-07-2019  | 2.1       | F.Baten       | first release TIA 15
	11-10-2019  | 2.2       | S. Deulkar    | Updated status structure
	30/10/2019  | 2.3       | F.Baten       | Pec timer on/off delaytimes interchanged
	04/11/2019  | 2.4       | L.Klar        | First scan bit changed from memory bit to DB variable
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	04/11/2019  | 3.1       | F.Baten       | Updated interface to VSU_RIO
	07/01/2020  | 3.2       | F.Baten       | Improved upstream gapping and decisionposition calculation, removed additional position reset
	13/01/2020  | 3.3       | F.Baten       | Changed length related tags from Int to Dint  
	12/02/2020  | 3.4       | C.Leite       | Correction of manual mode jogging
	26/08/2020  | 3.5       | L.Klar        | Switch enable changed to use out sensors, depending on movement direction
	                                        | Reduced required gap by additional (safety) distance -  5 cm
	18/10/2020  | 3.6       | L.Klar        | Requested position reset if equal to the actual one or default
	11/01/2021  | 3.7       | L.Klar        | Sinput safety ok added to stop conveyor condition
	17/01/2021  | 3.8       | L.Klar        | Switch enable changed - brackets added
	23/03/2021  | 3.9       | L.Klar        | Jam displacement calculated, when both conveyors moving. Upper switch area error can be reset if VSU is in defined position
	14/04/2021  | 3.10      | L.Klar        | VSB configuration structure input added, switch enable changed
	15/07/2021  | 3.11      | H. Rutkowski  | Upper and lower position added to the HMIStatus
	14/08/2021  | 3.12      | M. Kurpiers   | Enabling switch enable in semi automatic mode even if TIP is active
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Initial
	    
	    REGION 1.1 - First PLC cycle
	        
	        IF "DB_Memory".FirstScan
	        THEN
	            #sx_AutomaticActive := FALSE;                                               // switch of automatic activ
	            #iqUDT_HandShakeVSUConveyor.RTR := FALSE;                                  // Reset RTR signal
	            #iqUDT_HandShakeVSUConveyor.CascadeStartUp := FALSE;                       // Reset cascade start signal
	        END_IF;
	        
	    END_REGION
	    
	    REGION 1.3 - Triggers
	        
	        // Detecting rising edge on manual mode Or from Equipment Control
	        #sR_TRIG_ManualMode(CLK := #sUDT_Status.Manual);
	        
	        // Rising edge trigger running        
	        #sR_TRIG_UpTime(CLK := #sx_AutomaticActive AND #sx_Ready);
	        
	        // Detecting rising edge VSU stopped        
	        #sR_TRIG_DownTime(CLK := #sx_AutomaticActive AND NOT #sx_Ready);
	        
	        // Detecting rising edge on VSU error
	        #sR_TRIG_Error(CLK := #sUDT_Status.Error);
	        
	        // Detecting rising edge on VSU conveyor TIP signal         
	        #sR_TRIG_TIPLeavingVSU(CLK := #iqUDT_HandShakeVSUConveyor.TIP);
	        
	        // Detecting rising edge on VSU conveyor TIP signal         
	        #sF_TRIG_TIPLeavingVSU(CLK := #iqUDT_HandShakeVSUConveyor.TIP);
	        
	        // Detecting rising edge on start of the restart from error sequence
	        #sR_TRIG_RestartFromError(CLK := #sx_RestartFromError);
	        
	    END_REGION
	    
	    REGION 1.4 - Filters
	        
	        //End of section photo eye signal filtering
	        #sFB_PECEoSFiltered(iudi_OnDelayTime := #iUDT_VSUConfig.PEC_EoSTimeOnDelay,
	                            iudi_OffDelayTime := #iUDT_VSUConfig.PEC_EoSTimeOffDelay,
	                            ix_SignalToDelay := #ix_PECEos,
	                            ix_Enable := TRUE,
	                            qx_DelayedSignal => #sx_PEC_EoSFiltered);
	        
	        //Upper outfeed photo eye signal filtering
	        #sFB_PECUpOutFiltered(iudi_OnDelayTime := #iUDT_VSUConfig.PEC_OutTimeOnDelay,
	                              iudi_OffDelayTime := #iUDT_VSUConfig.PEC_OutTimeOffDelay,
	                              ix_SignalToDelay := #ix_PECUpperOut,
	                              ix_Enable := TRUE,
	                              qx_DelayedSignal => #sx_PEC_UpOutFiltered);
	        
	        //Lower outfeed photo eye signal filtering
	        #sFB_PECLowOutFiltered(iudi_OnDelayTime := #iUDT_VSUConfig.PEC_OutTimeOnDelay,
	                               iudi_OffDelayTime := #iUDT_VSUConfig.PEC_OutTimeOffDelay,
	                               ix_SignalToDelay := #ix_PECLowerOut,
	                               ix_Enable := TRUE,
	                               qx_DelayedSignal => #sx_PEC_LowOutFiltered);
	        
	        //Upper jam detection photo eye signal filtering
	        #sFB_PEC_UpJamFiltered(iudi_OnDelayTime := #iUDT_VSUConfig.PEC_JamTimeOnDelay,
	                               iudi_OffDelayTime := #iUDT_VSUConfig.PEC_JamTimeOffDelay,
	                               ix_SignalToDelay := #ix_PECJamUp,
	                               ix_Enable := TRUE,
	                               qx_DelayedSignal => #sx_PEC_UpJamFiltered);
	        
	        //Lower jam detection photo eye signal filtering
	        #sFB_PEC_LowJamFiltered(iudi_OnDelayTime := #iUDT_VSUConfig.PEC_JamTimeOnDelay,
	                                iudi_OffDelayTime := #iUDT_VSUConfig.PEC_JamTimeOffDelay,
	                                ix_SignalToDelay := #ix_PECJamDown,
	                                ix_Enable := TRUE,
	                                qx_DelayedSignal => #sx_PEC_LowJamFiltered);
	        
	        // Time to start without start warning while jogging
	        #sFB_JogEnable(iudi_OffDelayTime := #iUDT_VSUConfig.JogNoHornTime,
	                       ix_SignalToDelay := #sx_Jog);
	        
	        // Maximum stopping time
	        #sFB_MaxStopTime(iudi_OnDelayTime := (#iUDT_VSUConfig.SwitchingTime + #iUDT_VSUConfig.SwitchingTime),
	                         ix_SignalToDelay := #sx_Stopping);
	    END_REGION
	    
	    REGION 1.5 - Switching conditions             
	        
	        #sx_SwitchEnable := (#iqUDT_VSUCommand.SemiAutomaticMode                                                            // Switching of the VSU is enabled when
	        OR NOT #iqUDT_HandShakeVSUConveyor.TIP)                                            // No transfer in progress
	        AND #sx_PEC_LowJamFiltered                                                      // Lower jam sensor free
	        AND #sx_PEC_UpJamFiltered                                                        // Upper jam sensor free
	        AND ((#sx_UpRequest
	        AND #sx_PEC_UpOutFiltered)
	        OR (#sx_DownRequest
	        AND #sx_PEC_LowOutFiltered));                                                      // Upper outfeed PEC is free
	        
	    END_REGION
	    
	    REGION 1.6 - Position
	        
	        #sx_ActualPositionUP :=                                                         // Set status bit lifter in upper position 
	        (#iqUDT_VSUInterface.PositionActual = 1)                                       // If actual position is equal to 1 
	        AND NOT #iqUDT_VSUInterface.Positioning                                        // And the positioning is not active 
	        AND #ix_PosUp;                                                                  // And the position sensor signals
	        
	        #sx_ActualPositionDown :=                                                       // Set bit lifter in lower position 
	        (#iqUDT_VSUInterface.PositionActual = 2)                                       // If actual position is equal to 2 
	        AND NOT #iqUDT_VSUInterface.Positioning                                        // And the positioning is not active 
	        AND #ix_PosDown;                                                                // And the position sensor signals
	    END_REGION
	    
	    REGION 1.7 - Check configuration 
	        #si_DefaultPosition := #iUDT_VSUConfig.DefaultPosition;
	        
	        IF #si_DefaultPosition <= 0
	        THEN
	            #si_DefaultPosition := 1;
	            
	        END_IF;
	    END_REGION
	END_REGION
	
	REGION 2 - Errors
	    
	    REGION 2.1 - Reset errors
	        
	        IF #iqUDT_EquipmentControl.Command.Reset                                       // Reset
	        THEN
	            // Switch area
	            IF #sUDT_HMIStatus.Specific.UpperSwitchArea_Err                            // Upper jam error is active 
	                AND (#ix_PECJamUp OR #iqUDT_VSUInterface.PositionActual = #iqUDT_VSUInterface.PositionSetpoint)                                                      // Upper jam sensor is free
	            THEN
	                
	                #sUDT_HMIStatus.Specific.UpperSwitchArea_Err := FALSE;                 // reset error
	                
	            END_IF;
	            
	            IF #sUDT_HMIStatus.Specific.LowerSwitchArea_Err                            // lower jam error is active 
	                AND #ix_PECJamDown                                                      // Lower jam sensor is free
	            THEN
	                
	                #sUDT_HMIStatus.Specific.LowerSwitchArea_Err := FALSE;                 // reset error
	                
	            END_IF;
	            
	            // Outfeed entrance
	            IF #sUDT_HMIStatus.Specific.UpperEntranceJam_Err                           // Upper outfeed conveyor entrance PEC was blocked too long
	                // AND #sx_PEC_UpOutFiltered                                               // Upper outfeed conveyor entrance PEC is free
	            THEN
	                
	                #sUDT_HMIStatus.Specific.UpperEntranceJam_Err := FALSE;                // reset error
	                
	            END_IF;
	            
	            IF #sUDT_HMIStatus.Specific.LowerEntranceJam_Err                           // Lower outfeed conveyor entrance PEC was blocked too long
	                //  AND #sx_PEC_LowOutFiltered                                              // Lower outfeed conveyor entrance PEC is free
	            THEN
	                
	                #sUDT_HMIStatus.Specific.LowerEntranceJam_Err := FALSE;                // reset error
	                
	            END_IF;
	            
	            // Direction error
	            IF #sUDT_HMIStatus.Specific.Direction_Err                                  // Direction verification found the direction fault, stop VSU action and move in opposite direction
	                AND NOT #iqUDT_VSUInterface.MotorRunning                               // The VFD is stopped
	                AND #sx_PEC_EoSFiltered                                                 // The photoeye on the VSU conveyor is empty
	            THEN
	                
	                #sUDT_HMIStatus.Specific.Direction_Err := FALSE;                       // Direction verification found the direction fault, stop VSU action and move in opposite direction
	                
	            END_IF;
	            
	        END_IF;
	    END_REGION
	    
	    REGION 2.2 - Set errors
	        
	        // Upper Jam sensor blocked in movement
	        IF NOT #sx_PEC_UpJamFiltered                                                             // Upper jam sensor occupied
	            AND #iqUDT_VSUInterface.Positioning                                        // The positioning motor is running
	            AND #sx_UpRequest                                                           // an uprequest is active (going up)
	        THEN
	            
	            #sUDT_HMIStatus.Specific.UpperSwitchArea_Err := TRUE;                      // Set error upper jam sensor
	        END_IF;
	        
	        // Lower Jam sensor blocked in movement
	        IF NOT #sx_PEC_LowJamFiltered                                                           // Lower jam sensor occupied               
	            AND #iqUDT_VSUInterface.Positioning                                        // The positioning motor is running
	            AND #sx_DownRequest                                                         // an downrequest is active (going down)
	        THEN
	            
	            #sUDT_HMIStatus.Specific.LowerSwitchArea_Err := TRUE;                      // Set error lower jam sensor
	        END_IF;
	        
	        // Direction fault in semiautomatic mode
	        IF #sx_SemiAutomatic                                                            // Running Semi-Automatic 
	            AND #iUDT_VSUConfig.SecurityChecked                                        // the VSU is configured in an security area 
	            AND (((#si_Position = 1                                                     // the requested position is "up"
	            AND #si_DefaultPosition = 1)                                                // and the configured "default" is equal to "up"                                     
	            OR (#si_Position = 99                                                       // or the request is "default"
	            AND #si_DefaultPosition = 1)                                                // and the configured "default" is equal to "up"      
	            AND #sx_DownRequest)                                                        // but the position is "down"
	            
	            OR ((#si_Position = 2                                                       // or the requested position is "down"
	            AND #si_DefaultPosition = 2)                                                // and the configured "default" is equal to "down"
	            OR (#si_Position = 99                                                       // or the request is "default"
	            AND #si_DefaultPosition = 2)                                                // and the configured "default" is equal to "down"
	            AND #sx_UpRequest))                                                         // but the position is "up"
	        THEN
	            
	            #sUDT_HMIStatus.Specific.Direction_Err := TRUE;                               // Direction verification found the Direction fault, stop the parcel
	        END_IF;
	        
	        // Activating restart after error 
	        IF #iqUDT_ConveyorInterface.InternalErrorTracking // An error on traking occured on the VSU conveyor
	        THEN
	            
	            #sx_RestartFromError := TRUE;                                               // Activate the sequence to run the VSU conveyor empty
	        END_IF;
	        
	        #sx_ConfigurationError := (#iUDT_VSUConfig.DefaultPosition <= 0);             // Set the configuration error bit (No status!!)
	        
	    END_REGION
	    
	    REGION 2.3 - Common Error
	        
	        #sUDT_Status.Error :=
	        #iqUDT_ConveyorInterface.InternalErrorTracking                              // or the VSU conveyor detected an error in tracking 
	        OR #iqUDT_VSUInterface.InternalErrorVFD                                        // or there are errors in the VFD
	        OR #iqUDT_VSUInterface.InternalErrorRIOPanel                                   // or an internal error in the RIO panel occured
	        OR #sUDT_HMIStatus.Specific.Direction_Err                                      // Direction verification found the Direction fault, stop the parcel
	        OR #sUDT_HMIStatus.Specific.UpperSwitchArea_Err                                // Upper jam PEC detected WHILE going Up
	        OR #sUDT_HMIStatus.Specific.LowerSwitchArea_Err                                // Lower jam PEC detected while going Down
	        OR #sUDT_HMIStatus.Specific.UpperEntranceJam_Err                               // Upper outfeed conveyor entrance PEC was blocked too long
	        OR #sUDT_HMIStatus.Specific.LowerEntranceJam_Err;                              // Lower outfeed conveyor entrance PEC was blocked too long
	        
	    END_REGION
	    
	    REGION 2.4 - Common Warning
	        
	        // Keyswitch NOT in a position
	        #sUDT_HMIStatus.Specific.Keyswitch_WRN := NOT #ix_LCPAutoMode AND NOT #ix_LCPManualMode;
	        #sUDT_Status.Warning := #sUDT_HMIStatus.Specific.Keyswitch_WRN;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 3 - Check conditions to set Equipment ready
	    
	    //Conditions to set bit sx_Ready to operate 
	    
	    #sx_Ready := NOT #sUDT_Status.Error                                                // Error present
	    AND #ix_SafetyOk                                                                    // Safety signalling NOT OK
	    AND #iqUDT_VSUInterface.VSUMainPowerOk;                                            // 400v signalling not OK
	END_REGION
	
	REGION 4 - Stop Equipment
	    
	    IF #sx_ManualModeActive                                                             // Manual mode is active
	        AND #sx_AutomaticActive
	        
	        OR (NOT #iqUDT_EquipmentControl.Command.AutomaticOn                            // VSU stops if the bit AutomaticOn from control block is false
	        AND NOT #sx_ManualModeActive)                                                   // Manual mode active bit
	        
	        OR (NOT #sx_Ready                                                               // Bit VSU ready to run in automatic mode
	        AND NOT #sx_ManualModeActive)                                                   // Manual mode active
	        
	        OR NOT #ix_LCPAutoMode                                                          // LCP is not set to automatic
	        OR NOT #ix_SafetyOk                                                             // 
	        
	    THEN                                                                                // Order to stop 
	        #sx_Stopping := TRUE;                                                           // stopping is activated
	        #sx_AutomaticActive := FALSE;                                                   // switch of automatic activ
	        #sx_StartReceived := FALSE;                                                     // Start command received from system 
	        
	    END_IF;
	    
	    IF (#sx_Stopping                                                                     // stopping is activated
	        AND NOT #iqUDT_VSUInterface.Positioning)                                        // The positioning device is not active positioning 
	        OR #sFB_MaxStopTime.qx_DelayedSignal
	        OR NOT #sx_Ready
	        
	    THEN
	        #sx_Stopping := FALSE;                                                          // stopping is activated
	        #iqUDT_VSUCommand.CommandUp := FALSE;
	        #iqUDT_VSUCommand.CommandDown := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Start Automatic mode
	    
	    REGION 5.1 - Start 
	        // if start (OS) is received from system, this is memorised until started in cascade 
	        IF #iqUDT_EquipmentControl.Command.Start                                       // Start from system
	            AND #sx_Ready                                                               // Equipment has no errors
	        THEN
	            
	            #sx_StartReceived := TRUE;                                                  // Start command received from system 
	            
	        END_IF;
	        
	        IF #sx_StartReceived                                                            // Start command received from system
	            AND #iqUDT_VSUInterface.Referenced                                         // and VSU is referenced
	            AND #ix_LCPAutoMode                                                         // and the LCP is set to auto
	        THEN
	            
	            #sx_AutomaticActive := TRUE;                                                // Automatic activated
	            #sx_StartReceived := FALSE;                                                 // Start command received from system
	        END_IF;
	    END_REGION
	    
	    REGION 5.2 - Semi automatic mode
	        
	        #sx_SemiAutomatic := #sx_AutomaticActive                                        // Automatic activated
	        AND #iqUDT_VSUCommand.SemiAutomaticMode;                                       // and Semi-automatic is selected
	        
	    END_REGION
	    
	END_REGION
	
	REGION 6 - Manual mode
	    
	    REGION 6.1 - Manual mode: activation 
	        
	        // Manual mode is active if it is active from hmi or by control block  
	        #sx_ManualModeActive := #iqUDT_VSUCommand.ManualMode
	        OR #iqUDT_EquipmentControl.Command.ManualMode
	        OR #ix_LCPManualMode;
	        
	    END_REGION
	    
	    REGION 6.2 - Jog signals
	        
	        #sx_CombinedJogUp :=
	        (((#iqUDT_VSUCommand.ManualMode                                                // HMI in manual
	        OR #iqUDT_EquipmentControl.Command.ManualMode)                                 // Or a system control command to go to manual
	        AND #iqUDT_VSUCommand.JogUp)                                                   // If selected jog in positive direction 
	        OR (#ix_LCPManualMode                                                           // box in manual
	        AND #ix_LCPUp));                                                                // If selected jog in positive direction 
	        
	        #sx_CombinedJogDown :=
	        (((#iqUDT_VSUCommand.ManualMode                                                 // HMI in manual
	        OR #iqUDT_EquipmentControl.Command.ManualMode)                                  // Or a system control command to go to manual
	        AND #iqUDT_VSUCommand.JogDown)                                                 // If selected jog in negative direction 
	        OR (#ix_LCPManualMode                                                           // box in manual
	        AND #ix_LCPDown));                                                              // If selected jog in negative direction 
	        
	        // Detecting rising edge on manual jog Up           
	        #sR_TRIG_ManualJogUp(CLK := #sx_CombinedJogUp);
	        
	        // Detecting rising edge on manual jog Down          
	        #sR_TRIG_ManualJogDown(CLK := #sx_CombinedJogDown);
	        
	    END_REGION
	    
	    REGION 6.3 - Manual mode: disabled
	        
	        // Manual mode bits inputs can be reset in case of malfunction
	        IF #iqUDT_EquipmentControl.Command.DisableManualMode
	        THEN
	            
	            #iqUDT_VSUCommand.ManualMode := FALSE;                                     // reset manual mode 
	            #iqUDT_EquipmentControl.Command.ManualMode := FALSE;                       // reset manual mode command 
	            #iqUDT_VSUCommand.JogUp := FALSE;                                          // reset manual command Jog Up
	            #iqUDT_VSUCommand.JogDown := FALSE;                                        // reset manual command Jog Down
	            #sx_Jog := FALSE;
	        END_IF;
	    END_REGION
	    
	    REGION 6.4 - Manual PreStart up or down
	        
	        // Pre start conditions to run in manual mode
	        #sx_PreStartManual := #sx_ManualModeActive                                      // Manual mode active bit
	        AND #ix_SafetyOk                                                                // Safety healthy bit
	        //AND #iq_UDT_VSUInterface.PNDeviceOk                                                              // Profinet comunication 
	        AND NOT #iqUDT_VSUInterface.InternalErrorVFD;                                  // Internal error from VFD
	        
	        IF #sx_PreStartManual                                                           // Pre start conditions to run in manual mode
	            AND (#sR_TRIG_ManualJogUp.Q                                                  // Trigger to start VSU run in manual jog mode UP
	            OR #sR_TRIG_ManualJogDown.Q)                                                 // Trigger to start VSU run in manual jog mode Down
	            AND NOT #sFB_JogEnable.qx_DelayedSignal
	        THEN
	            
	            #iqUDT_EquipmentControl.Request.SignalingRequest := TRUE;                  // Request signaling TO control block before VSU runs in manual mode
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 6.5 - Jog mode Up / Down
	        
	        IF #sx_PreStartManual                                                           // IF in manual jog mode 
	            AND (NOT #iqUDT_EquipmentControl.Request.SignalingRequest                  // Signaling request done
	            OR #sFB_JogEnable.qx_DelayedSignal)
	            AND #sx_CombinedJogUp                                                       // If selected jog in positive direction 
	            AND NOT #sx_CombinedJogDown                                                 // And not selected jog in negative direction
	        THEN
	            
	            #iqUDT_VSUInterface.JogUp := TRUE;                                         // set jog positive 
	            #iqUDT_VSUInterface.JogDown := FALSE;                                      // reset jog negative 
	            #sx_Jog := true;
	            
	        ELSIF
	            #sx_PreStartManual                                                          // IF in manual jog mode 
	            AND (NOT #iqUDT_EquipmentControl.Request.SignalingRequest                  // Signaling request done
	            OR #sFB_JogEnable.qx_DelayedSignal)
	            AND NOT #sx_CombinedJogUp                                                   // If selected jog in positive direction 
	            AND #sx_CombinedJogDown                                                     // and there is command to jog in negative direction 
	        THEN
	            
	            #iqUDT_VSUInterface.JogUp := FALSE;                                        // reset jog positive 
	            #iqUDT_VSUInterface.JogDown := TRUE;                                       // set jog negative 
	            #sx_Jog := true;
	            
	        ELSIF
	            NOT #sx_PreStartManual                                                      // If not in manual mode 
	            OR (#sx_PreStartManual                                                      // or in manual mode
	            AND (#sx_CombinedJogUp                                                      // and jog positive is off 
	            AND #sx_CombinedJogDown)                                                    // AND jog negative is off 
	            OR (NOT #sx_CombinedJogUp                                                   // or jog positive is on 
	            AND NOT #sx_CombinedJogDown))                                               // and jog negative is on 
	        THEN
	            
	            #iqUDT_VSUInterface.JogUp := FALSE;                                        // reset jog positive 
	            #iqUDT_VSUInterface.JogDown := FALSE;                                      // reset jog negative 
	            #sx_Jog := False;
	        END_IF;
	    END_REGION
	END_REGION
	
	REGION 7 - Automatic mode
	    
	    REGION 7.1 - Direction from decision point
	        IF #iqUDT_VSUInterface.RequestedPosition <> 0                                  // Position is received from decision block
	        THEN
	            #si_Position := #iqUDT_VSUInterface.RequestedPosition;                     // Copy the input to the memory
	            
	        END_IF;
	        
	        // Requested position reset
	        IF (#iqUDT_VSUInterface.RequestedPosition = #iqUDT_VSUInterface.PositionActual OR
	            (#iqUDT_VSUInterface.RequestedPosition = 99 AND #iqUDT_VSUInterface.PositionActual = #si_DefaultPosition))
	        THEN
	            
	            #iqUDT_VSUInterface.RequestedPosition := 0;
	            
	        END_IF;
	        
	        
	    END_REGION
	    
	    REGION 7.2 - Position Up / Down             
	        // 1 = Up, 2 = Down and 99 = Default 
	        // 
	        IF (#si_Position = 1                                                            // If the position "up" is equal to the request 
	            OR (#si_Position = 99                                                       // Or the request is "default"
	            AND #si_DefaultPosition = 1))                                               // and the configured "default" is equal to "up"
	            AND #sx_Ready                                                               // Ready to operate, No errors active
	            AND #sx_AutomaticActive                                                     // Automaticly started
	            AND NOT #sx_SemiAutomatic                                                   // Not running Semi-Automatic
	        THEN
	            
	            #sx_DownRequest := FALSE;                                                   // Reset down command
	            #sx_UpRequest := TRUE;                                                      // Set up command
	            #si_Position := 0;                                                          // Reset the memory
	        END_IF;
	        
	        IF (#si_Position = 2                                                            // If the position "down" is equal to the request 
	            OR (#si_Position = 99                                                       // Or the request is "default"
	            AND #si_DefaultPosition = 2))                                               // and the configured "default" is equal to "down"
	            AND #sx_Ready                                                               // Ready to operate, No errors active
	            AND #sx_AutomaticActive                                                     // Automaticly started
	            AND NOT #sx_SemiAutomatic                                                   // Not running Semi-Automatic
	        THEN
	            
	            #sx_DownRequest := TRUE;                                                    // Set down command
	            #sx_UpRequest := FALSE;                                                     // Reset up command
	            #si_Position := 0;                                                          // Reset the memory
	        END_IF;
	        
	        // if the VSU is not referenced set the default position, this ensures the VSU to go to the default
	        // after refferecing.
	        
	        IF NOT #iqUDT_VSUInterface.Referenced
	        THEN
	            IF #si_DefaultPosition = 1
	            THEN
	                #sx_DownRequest := FALSE;                                               // Reset down command
	                #sx_UpRequest := TRUE;                                                  // Set up command
	                #iqUDT_VSUInterface.PositionSetpoint := 1;                             // Set position to be 1 = Up    
	            END_IF;
	            
	            IF #si_DefaultPosition = 2
	            THEN
	                #sx_DownRequest := TRUE;                                                // Reset down command
	                #sx_UpRequest := FALSE;                                                 // Set up command
	                #iqUDT_VSUInterface.PositionSetpoint := 2;                             // Set position to be 1 = Down    
	            END_IF;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 7.3 - Semi automatic
	        
	        IF #sx_SemiAutomatic                                                            // Not running Semi-Automatic
	            AND #iqUDT_VSUCommand.CommandUp
	            
	        THEN
	            #sx_DownRequest := FALSE;                                                   // Reset down command
	            #sx_UpRequest := TRUE;                                                      // Set up command
	            #iqUDT_VSUCommand.CommandUp := FALSE;
	        END_IF;
	        
	        IF #sx_SemiAutomatic                                                            // Not running Semi-Automatic
	            AND #iqUDT_VSUCommand.CommandDown
	            
	        THEN
	            #sx_DownRequest := TRUE;                                                    // Reset down command
	            #sx_UpRequest := FALSE;                                                     // Set up command
	            #iqUDT_VSUCommand.CommandDown := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 7.4 - Restart from error / external dieback
	        // There was an error active requiring the VSU conveyor to be emptied to the default direction
	        // 
	        
	        IF #sR_TRIG_RestartFromError.Q                                                   // The sequence has started
	        THEN
	            #sdi_RunEmpty := (#idi_ConveyorLength / 10);                                  // Set the distance to run empty
	        END_IF;
	        
	        IF #sdi_RunEmpty > 0                                                             // As long as the distance is bigger than '0'
	            OR #sx_StopInfeed
	            
	        THEN
	            #sdi_RunEmpty -= #iqUDT_ConveyorInterface.Displacement;                     // decrease the run empty distance by the actual displacement
	            IF #sdi_RunEmpty < 0                                                         // the distance is ok
	            THEN
	                #sdi_RunEmpty := 0;                                                      // Set distance to '0'
	                #sx_RestartFromError := FALSE;                                          // Reset the running empty sequence
	                #sx_StopInfeed := FALSE;                                                // Reset the dieback signal 
	            END_IF;
	        END_IF;
	        
	        IF #sx_RestartFromError                                                         // There was an error active requiring the VSU conveyor to be emptied to the default direction
	            
	        THEN
	            IF #si_DefaultPosition = 1
	            THEN
	                #sx_DownRequest := FALSE;                                               // Reset down command
	                #sx_UpRequest := TRUE;                                                  // Set up command
	            END_IF;
	            
	            IF #si_DefaultPosition = 2
	            THEN
	                #sx_DownRequest := TRUE;                                                // Reset down command
	                #sx_UpRequest := FALSE;                                                 // Set up command
	            END_IF;
	            #sx_StopInfeed := TRUE;                                                     // Set dieback signal stopping parcels from entering the VSU conveyor
	            
	        END_IF;
	        
	        #iqUDT_VSUInterface.RequestDieBackUpstream := #sx_StopInfeed                   // Stop infeed after error
	        OR #iqUDT_VSUInterface.StartLowSpeed;                                          // Command from VFD
	        
	    END_REGION
	    
	    REGION 7.5 - Controls to to go UP or Down
	        IF #sx_AutomaticActive                                                          // The VSU is automaticly started
	            AND #sx_Ready                                                               // Ready to run / no errors
	        THEN
	            
	            IF #sx_UpRequest                                                            // If there is request to move to the upper position 
	                AND #sx_SwitchEnable                                                    // The VSU is enabled to move 
	                AND NOT #iqUDT_VSUInterface.Positioning                                // Positioning device is positioning, moving to next position
	                AND #iqUDT_VSUInterface.Ready                                          // the positioning device is errorfree
	                AND NOT #sx_ActualPositionUP                                            // And not in upper position
	                
	            THEN
	                
	                #iqUDT_VSUInterface.PositionSetpoint := 1;                             // Set position to be 1 = Up
	                
	            END_IF;
	            
	            IF #sx_DownRequest                                                          // If there is request to move to the lower position 
	                AND #sx_SwitchEnable                                                    // The VSU is enabled to move 
	                AND NOT #iqUDT_VSUInterface.Positioning                                // Positioning device is positioning, moving to next position
	                AND #iqUDT_VSUInterface.Ready                                          // the positioning device is errorfree
	                AND NOT #sx_ActualPositionDown                                          // And not in lower position
	                
	            THEN
	                
	                #iqUDT_VSUInterface.PositionSetpoint := 2;                             // Set position to be 2 = Down
	                
	            END_IF;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 7.6 - Jam detection
	        
	        (* Jam detection functionality is used to stop conveyor when photo eye is blocked
	         for more than a displacement configured to prevent disaster event.
	           While the photo eye is detecting a parcel, the functionality counts the displacement. *)
	        
	        IF NOT #sx_PEC_UpOutFiltered AND #iqUDT_ConveyorInterface.VFDRunning// Photo eye blocked
	        THEN
	            
	            #si_UpJamDisplacement += #iqUDT_HandShakeUpperPosition.DownstreamDisplacement;    // Increases displacement values in auxiliary variable
	        ELSE
	            
	            #si_UpJamDisplacement := 0;                                                 // Reset jam auxiliary counter variable
	        END_IF;
	        
	        IF #si_UpJamDisplacement > #iUDT_VSUConfig.JamDisplacementLimit                // Compare jam auxiliary counter with displacement jam configured
	        THEN
	            
	            #sUDT_HMIStatus.Specific.UpperEntranceJam_Err := TRUE;                        // PEC jam status set true
	        END_IF;
	        
	        IF NOT #sx_PEC_LowOutFiltered AND #iqUDT_ConveyorInterface.VFDRunning                                                   // Photo eye blocked
	        THEN
	            
	            #si_LowJamDisplacement += #iqUDT_HandShakeLowerPosition.DownstreamDisplacement;   // Increases displacement values in auxiliary variable
	        ELSE
	            
	            #si_LowJamDisplacement := 0;                                                // Reset jam auxiliary counter variable
	        END_IF;
	        
	        IF #si_LowJamDisplacement > #iUDT_VSUConfig.JamDisplacementLimit               // Compare jam auxiliary counter with displacement jam configured
	        THEN
	            
	            #sUDT_HMIStatus.Specific.LowerEntranceJam_Err := TRUE;                        // PEC jam status set true
	        END_IF;
	    END_REGION
	    
	    REGION 7.7 - Head to head and gap upper conveyor
	        IF #si_UpperHeadToHead > 0                                                      // as long as value is bigger than '0'
	        THEN
	            
	            #si_UpperHeadToHead -= #iqUDT_HandShakeUpperPosition.DownstreamDisplacement;  // Downstream displacement head to head counter 
	            IF #si_UpperHeadToHead < 0                                                  // Value is smaller than '0'
	            THEN
	                #si_UpperHeadToHead := 0;                                               // Set value to '0'
	            END_IF;
	        END_IF;
	        
	        IF #si_UpperGap > 0                                                             // as long as value is bigger than '0'
	        THEN
	            
	            #si_UpperGap -= #iqUDT_HandShakeUpperPosition.DownstreamDisplacement;     // Downstream displacement gap counter 
	            IF #si_UpperGap < 0                                                         // Value is smaller than '0'
	            THEN
	                #si_UpperGap := 0;                                                      // Set value to '0'
	            END_IF;
	        END_IF;
	        
	        #sx_GappingUpper :=                                                             // Gapping is active 
	        (#si_UpperHeadToHead > 0                                                        // If Head to head counter is bigger than '0'
	        OR #si_UpperGap > 0);                                                          // If the gap counter is bigger than '0'
	    END_REGION
	    
	    REGION 7.8 - Head to head and gap lower conveyor
	        IF #si_LowerHeadToHead > 0                                                      // as long as value is bigger than '0'
	        THEN
	            
	            #si_LowerHeadToHead -= #iqUDT_HandShakeLowerPosition.DownstreamDisplacement;  // Downstream displacement head to head counter 
	            IF #si_LowerHeadToHead < 0                                                  // Value is smaller than '0'
	            THEN
	                #si_LowerHeadToHead := 0;                                               // Set value to '0'
	            END_IF;
	        END_IF;
	        
	        IF #si_LowerGap > 0                                                             // as long as value is bigger than '0'
	        THEN
	            
	            #si_LowerGap -= #iqUDT_HandShakeLowerPosition.DownstreamDisplacement;     // Downstream displacement gap counter 
	            IF #si_LowerGap < 0                                                         // Value is smaller than '0'
	            THEN
	                #si_LowerGap := 0;                                                      // Set value to '0'
	            END_IF;
	        END_IF;
	        
	        #sx_GappingLower :=                                                             // Gapping is active 
	        (#si_LowerHeadToHead > 0                                                        // If Head to head counter is bigger than '0'
	        OR #si_LowerGap > 0);                                                          // If the gap counter is bigger than '0'
	    END_REGION
	    
	    REGION 7.9 - Upper position handshake
	        
	        IF #sx_ActualPositionUP                                                         // IF VSU is in upper position 
	            
	        THEN
	            // Copy handshakes
	            // Upstream to downstream
	            #iqUDT_HandShakeUpperPosition.GIN := #iqUDT_HandShakeVSUConveyor.GIN;    // GIN number which is transported from up to downstream
	            #iqUDT_HandShakeUpperPosition.NrOfPosToShift := #iqUDT_HandShakeVSUConveyor.NrOfPosToShift;                  // Number of positions to shift the tracking
	            
	            #iqUDT_HandShakeUpperPosition.RTS := #iqUDT_HandShakeVSUConveyor.RTS;                                        // Conveyor is Ready To Send  
	            #iqUDT_HandShakeUpperPosition.TIP := #iqUDT_HandShakeVSUConveyor.TIP;                                        // Transfer is in progress
	            #iqUDT_HandShakeUpperPosition.ResetEnergySave := #iqUDT_HandShakeVSUConveyor.ResetEnergySave;                // Wake-up from energy save
	            // Downstream to upstream
	            #iqUDT_HandShakeVSUConveyor.DownstreamDisplacement := #iqUDT_HandShakeUpperPosition.DownstreamDisplacement;  // Actual displacement
	            #iqUDT_HandShakeVSUConveyor.RTR := (#iqUDT_HandShakeUpperPosition.RTR                                        // Ready to receive from upper position
	            AND NOT #sx_GappingUpper);                                                                                       // Gapping is not active
	            
	            #iqUDT_HandShakeVSUConveyor.CascadeStartUp := #iqUDT_HandShakeUpperPosition.CascadeStartUp;                  // Cascade start-up
	            
	            IF #sR_TRIG_TIPLeavingVSU.Q                                                                                      // Transfering aux bit rising trigger
	            THEN
	                #si_UpperHeadToHead := #iUDT_VSUConfig.HeadToHead;                                                         // Set gapsize head to head
	            END_IF;
	            
	            IF #sF_TRIG_TIPLeavingVSU.Q                                                                                      // Transfering aux bit rising trigger
	            THEN
	                #si_UpperGap := #iUDT_VSUConfig.Gap;                                                                       // Set gapsize trail to head
	            END_IF;
	            
	            // Clear GIN iff there is no RTR 
	            IF NOT #iqUDT_HandShakeUpperPosition.RTR THEN
	                #iqUDT_HandShakeUpperPosition.GIN := 0;    // GIN number which is transported from up to downstream
	                #iqUDT_HandShakeUpperPosition.NrOfPosToShift := 0;                  // Number of positions to shift the tracking
	            END_IF;
	            
	        END_IF;
	    END_REGION
	    
	    REGION 7.10 - Lower position handshake
	        
	        IF #sx_ActualPositionDown                                                                                           // If VSU is in lower position 
	            
	        THEN
	            // Copy handshakes
	            // Upstream to downstream
	            #iqUDT_HandShakeLowerPosition.GIN := #iqUDT_HandShakeVSUConveyor.GIN;                                        // GIN number which is transported from up to downstream
	            #iqUDT_HandShakeLowerPosition.NrOfPosToShift := #iqUDT_HandShakeVSUConveyor.NrOfPosToShift;                  // Number of positions to shift the tracking
	            
	            #iqUDT_HandShakeLowerPosition.RTS := #iqUDT_HandShakeVSUConveyor.RTS;                                        // Conveyor is Ready To Send 
	            #iqUDT_HandShakeLowerPosition.TIP := #iqUDT_HandShakeVSUConveyor.TIP;                                        // Transfer is in progress
	            #iqUDT_HandShakeLowerPosition.ResetEnergySave := #iqUDT_HandShakeVSUConveyor.ResetEnergySave;                // Wake-up from energy save
	            // Downstream to upstream
	            #iqUDT_HandShakeVSUConveyor.DownstreamDisplacement := #iqUDT_HandShakeLowerPosition.DownstreamDisplacement;  // Actual displacement
	            #iqUDT_HandShakeVSUConveyor.RTR := (#iqUDT_HandShakeLowerPosition.RTR                                        // Ready to receive from lower position
	            AND NOT #sx_GappingLower);                                                                                        // Gapping is active
	            
	            #iqUDT_HandShakeVSUConveyor.CascadeStartUp := #iqUDT_HandShakeLowerPosition.CascadeStartUp;                  // Cascade start-up
	            
	            IF #sR_TRIG_TIPLeavingVSU.Q                                                                                      // Transfering aux bit rising trigger
	            THEN
	                #si_LowerHeadToHead := #iUDT_VSUConfig.HeadToHead;                                                         // Set gapsize head to head
	            END_IF;
	            
	            IF #sF_TRIG_TIPLeavingVSU.Q                                                                                      // Transfering aux bit rising trigger
	            THEN
	                #si_LowerGap := #iUDT_VSUConfig.Gap;                                                                       // Set gapsize trail to head
	            END_IF;
	            
	            IF NOT #iqUDT_HandShakeLowerPosition.RTR THEN
	                #iqUDT_HandShakeLowerPosition.GIN := 0;    // GIN number which is transported from up to downstream
	                #iqUDT_HandShakeLowerPosition.NrOfPosToShift := 0;                  // Number of positions to shift the tracking
	            END_IF;
	            
	        END_IF;
	    END_REGION
	    
	    REGION 7.11 - No position, Clear Handshake
	        IF NOT #sx_ActualPositionUP AND                                                 // IF VSU is not in upper position 
	            NOT #sx_ActualPositionDown                                                  // AND VSU is not in lower position 
	        THEN
	            
	            // Reset Handshake upstream
	            #iqUDT_HandShakeVSUConveyor.RTR := FALSE;                                  // Reset Ready to Receive
	            #iqUDT_HandShakeVSUConveyor.CascadeStartUp := FALSE;                       // Reset Cascade Startup
	            
	            // Reset Handshake Upper position downstream
	            #iqUDT_HandShakeUpperPosition.GIN := 0;                                   // Reset GIN
	            #iqUDT_HandShakeUpperPosition.NrOfPosToShift := 0;                        // Reset Numbers of positions to shift data
	            #iqUDT_HandShakeUpperPosition.RTS := FALSE;                               // Reset Ready TO Send
	            #iqUDT_HandShakeUpperPosition.TIP := FALSE;                               // Reset Transfer in Progress
	            #iqUDT_HandShakeUpperPosition.DownstreamDisplacement := 0;                // Reset Actual downstream displacement
	            #iqUDT_HandShakeUpperPosition.ResetEnergySave := FALSE;
	            
	            // Reset Handshake lower position downstream
	            #iqUDT_HandShakeLowerPosition.GIN := 0;                                   // Reset GIN
	            #iqUDT_HandShakeLowerPosition.NrOfPosToShift := 0;                        // Reset Numbers of positions to shift data
	            #iqUDT_HandShakeLowerPosition.RTS := FALSE;                               // Reset Ready to Send
	            #iqUDT_HandShakeLowerPosition.TIP := FALSE;                               // Reset Transfer in Progress
	            #iqUDT_HandShakeLowerPosition.DownstreamDisplacement := 0;                // Reset Actual downstream displacement
	            #iqUDT_HandShakeLowerPosition.ResetEnergySave := FALSE;
	            
	        END_IF;
	    END_REGION
	    
	    REGION 7.12 - Secure gaps between entering parcels  
	        // Calculate the minimum gap out of the speed of the conveyor and the time it takes to move between positions 
	        //
	        
	        #si_RequiredGap := LREAL_TO_INT((INT_TO_LREAL(#iUDT_ConveyorConfiguration.SpeedSetpointNominal) / 10.0) * (UINT_TO_LREAL(#iUDT_VSUConfig.SwitchingTime) / 1000.0) * 1.15);
	        #iqUDT_VSUInterface.Decisionpoint := #si_RequiredGap;                      // Required gap + 5cm for outfeed fotocells is decision point (the new direction is already there while handling the parcel)
	        
	    END_REGION
	    
	    REGION 7.13 - Start/Stop VSU conveyor directly
	        // Start
	        IF #iqUDT_EquipmentControl.Command.Start                                       // Start from system
	            AND #sx_Ready                                                               // Equipment has no errors
	        THEN
	            #iqUDT_VSUInterface.ExternalHold := FALSE;                                 // External stop signal
	        END_IF;
	        
	        // Stop 
	        IF #sUDT_HMIStatus.Specific.UpperSwitchArea_Err                                   // Blockage of switching area
	            OR #sUDT_HMIStatus.Specific.LowerSwitchArea_Err
	            OR #sUDT_HMIStatus.Specific.UpperEntranceJam_Err                              // Jam of entrance of outfeed conveyors
	            OR #sUDT_HMIStatus.Specific.LowerEntranceJam_Err
	            OR #sUDT_HMIStatus.Specific.Direction_Err                                     // in semi-automatic mode and configured as security area: a parcel should go to reject area but direction is not. 
	            OR NOT #sx_AutomaticActive                                                  // The VSU is not (semi-)automatic active
	        THEN
	            #iqUDT_VSUInterface.ExternalHold := TRUE;                                  // External stop signal
	        END_IF;
	    END_REGION
	    
	END_REGION
	
	REGION 8 - Write interface DB signals
	    
	    REGION 8.1 - Signal interface
	        
	        #iqUDT_VSUInterface.InternalErrorReset := #iqUDT_EquipmentControl.Command.Reset;      // Write Reset signal to the VFD interface
	        #iqUDT_VSUInterface.ResetStatistics := #iqUDT_EquipmentControl.Command.ResetData;     // Write Reset data signal to the VFD interface
	        #iqUDT_VSUInterface.SwitchingTime := #iUDT_VSUConfig.SwitchingTime;           // Write switching time from configuration to VFD interface
	        
	    END_REGION
	    
	    REGION 8.1 - Mode selection 
	        
	        #iqUDT_VSUInterface.Automatic :=
	        (#sx_AutomaticActive                                                            // Automatic started
	        OR #sx_Stopping                                                                 // stopping is activated
	        OR #sx_PositionAfterRef)                                                        // Go to default position
	        AND #iqUDT_VSUInterface.Referenced;                                            // and the drive is referenced
	        
	        #iqUDT_VSUInterface.Manual :=
	        #sx_ManualModeActive                                                            // Manual mode is started
	        AND (#sx_CombinedJogUp                                                          // IF selected jog in positive direction 
	        OR #sx_CombinedJogDown)
	        AND #iqUDT_VSUInterface.Referenced;                                            // and the drive is referenced
	    END_REGION
	    
	    REGION 8.2 - Run enable
	        
	        #iqUDT_VSUInterface.RunEnabled :=                                              // Enable the positioning device to run
	        NOT #iqUDT_ConveyorInterface.InternalErrorTracking                            // or the VSU conveyor detected an error in tracking 
	        AND NOT #iqUDT_VSUInterface.InternalErrorVFD                                  // or there are errors in the VFD
	        AND NOT #iqUDT_VSUInterface.InternalErrorRIOPanel                              // or an internal error in the RIO panel occured                             
	        AND (#iqUDT_VSUInterface.Automatic
	        OR (#iqUDT_VSUInterface.Manual
	        AND (#sx_CombinedJogUp                                                          // If selected jog in positive direction 
	        OR #sx_CombinedJogDown))
	        OR #iqUDT_VSUInterface.GoReference);
	    END_REGION
	    
	    REGION 8.3 - Referencing VFD
	        
	        #sR_TRIG_GOReference(CLK := (#sx_AutomaticActive                                 // Refferencing in auto when 
	                             AND #sx_StartReceived)                                      // Start command received from system
	                             OR (#sx_ManualModeActive                                    // Manual Refferencing not in auto
	                             AND #iqUDT_VSUCommand.ReferenceRun)                        // Command form HMI to start referecing
	                             OR (#sx_ManualModeActive                                    // Manual Refferencing not in auto
	                             AND #ix_LCPRef));                                           // Command form LCP to start referecing
	        
	        #sR_TRIG_Referenced(CLK := #iqUDT_VSUInterface.Referenced);
	        
	        // Select reference travel and set signalling request prior to VSU movement 
	        IF #sR_TRIG_GOReference.Q                                                        // there is rising edge on referencing request bit 
	            
	        THEN
	            #iqUDT_VSUInterface.GoReference := TRUE;                                   // Activate the reference travel memory 
	            #iqUDT_EquipmentControl.Request.SignalingRequest := TRUE;                  // Request signaling TO control block before running to reference
	        END_IF;
	        
	        // Reference travel mode is active
	        // If signalling request is off set the reference command
	        // if the drive signals to be referenced, reset the command and HMI interface
	        
	        IF #iqUDT_VSUInterface.GoReference = TRUE                                      // The reference travel is activated  
	        THEN
	            // 1: Wait for end of signal request to start drive to do its refference run
	            IF NOT #iqUDT_EquipmentControl.Request.SignalingRequest                    // Request signaling TO control block before running to reference
	                AND NOT #sx_PositionAfterRef                                            // last step is active, prohibit starting again.
	            THEN
	                #iqUDT_VSUInterface.Reference_command := TRUE;                         // Reference command, VSU request to do reference run to positioning device
	                
	            END_IF;
	            
	            // 2: Drive did its refference run and is now at refference position
	            IF #sR_TRIG_Referenced.Q                                                     // If the drive is referenced 
	            THEN
	                #iqUDT_VSUInterface.Reference_command := FALSE;                        // Reset Reference command, VSU request to do reference run to positioning device 
	                #sx_PositionAfterRef := TRUE;                                           // Go to the default position 
	                #iqUDT_VSUInterface.PositionActual := 0;
	            END_IF;
	            
	            // 3: go to requested position after which the system can continue
	            IF #iqUDT_VSUInterface.PositionSetpoint = #iqUDT_VSUInterface.PositionActual   // The position is as requested
	                AND #sx_PositionAfterRef
	                
	            THEN
	                #sx_PositionAfterRef := FALSE;                                          // reset to go to the default position
	                #iqUDT_VSUInterface.GoReference := FALSE;                              // Reset the reference travel memory
	                
	            END_IF;
	        END_IF;
	    END_REGION
	END_REGION
	
	REGION 9 - Statistics
	    
	    // Down Time
	    
	    IF #sx_AutomaticActive                                                              // Automatic active
	        AND NOT #sx_Ready                                                                // Conveyor not ready
	        OR #iqUDT_EquipmentControl.Command.ResetData                                    // Reset statistics
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,              // Or reset statistics from control
	                        ix_Activate := #sx_AutomaticActive AND NOT #sx_Ready,                // VSU is stopped 
	                        ix_RTrigActivate := #sR_TRIG_DownTime.Q,                              // VSU is stopped triger 
	                        iqUDT_Statistics := #iqUDT_Statistics.DownTime);                // VSU is stopped statistics 
	    END_IF;
	    
	    // Up time
	    
	    IF #sx_AutomaticActive                              // Automatic active
	        AND #sx_Ready                                   // Ready active
	        OR #iqUDT_EquipmentControl.Command.ResetData    // Reset statistics
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,        // OR reset statistics from control
	                        ix_Activate := #sx_AutomaticActive AND #sx_Ready,                        // VSU is running 
	                        ix_RTrigActivate := #sR_TRIG_UpTime.Q,                              // VSU running trigger 
	                        iqUDT_Statistics := #iqUDT_Statistics.UpTime);                        // VSU running statistics
	        
	    END_IF;
	    
	    // Upper switch area error
	    
	    #sR_TRIG_UPSwA_Error(CLK := #sUDT_HMIStatus.Specific.UpperSwitchArea_Err);               // Oneshot trigger error occurred
	    
	    IF #iqUDT_VSUInterface.ResetStatistics OR                                              // IF there is signal TO reset statistics from VSU interface 
	        #iqUDT_EquipmentControl.Command.ResetData OR                                       // Or there is signal to reset statistics from equipment control structure 
	        #sUDT_HMIStatus.Specific.UpperSwitchArea_Err                                        // Or an upper switch area error occurred 
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics OR                 // Reset statistics from HMI
	                        #iqUDT_EquipmentControl.Command.ResetData,                         // Or reset statistics from control
	                        ix_Activate := #sUDT_HMIStatus.Specific.UpperSwitchArea_Err,        // Upper switch area error occurred
	                        ix_RTrigActivate := #sR_TRIG_UPSwA_Error.Q,                          // Error trigger 
	                        iqUDT_Statistics := #iqUDT_Statistics.UpperSwitchArea_Error);          // Statistics of VSU errors 
	        
	    END_IF;
	    
	    // Lower switch area error
	    
	    #sR_TRIG_LowSwA_Error(CLK := #sUDT_HMIStatus.Specific.LowerSwitchArea_Err);              // Oneshot trigger error occurred
	    
	    IF #iqUDT_VSUInterface.ResetStatistics OR                                              // IF there is signal TO reset statistics from VSU interface 
	        #iqUDT_EquipmentControl.Command.ResetData OR                                       // Or there is signal to reset statistics from equipment control structure 
	        #sUDT_HMIStatus.Specific.LowerSwitchArea_Err                                        // Or an upper switch area error occurred 
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics OR                 // Reset statistics from HMI
	                        #iqUDT_EquipmentControl.Command.ResetData,                         // Or reset statistics from control
	                        ix_Activate := #sUDT_HMIStatus.Specific.LowerSwitchArea_Err,        // Upper switch area error occurred
	                        ix_RTrigActivate := #sR_TRIG_LowSwA_Error.Q,                         // Error trigger 
	                        iqUDT_Statistics := #iqUDT_Statistics.LowerSwitchArea_Error);          // Statistics of VSU errors 
	        
	    END_IF;
	    
	    // Upper entrance Jam
	    
	    #sR_TRIG_UPEntr_Jam(CLK := #sUDT_HMIStatus.Specific.UpperEntranceJam_Err);               // Oneshot trigger error occurred
	    
	    IF #iqUDT_VSUInterface.ResetStatistics OR                                              // IF there is signal TO reset statistics from VSU interface 
	        #iqUDT_EquipmentControl.Command.ResetData OR                                       // Or there is signal to reset statistics from equipment control structure 
	        #sUDT_HMIStatus.Specific.UpperEntranceJam_Err                                       // Or an upper switch area error occurred 
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics OR                 // Reset statistics from HMI
	                        #iqUDT_EquipmentControl.Command.ResetData,                         // Or reset statistics from control
	                        ix_Activate := #sUDT_HMIStatus.Specific.UpperEntranceJam_Err,       // Upper switch area error occurred
	                        ix_RTrigActivate := #sR_TRIG_UPEntr_Jam.Q,                           // Error trigger 
	                        iqUDT_Statistics := #iqUDT_Statistics.UpperEntranceJam_Error);         // Statistics of VSU errors 
	        
	    END_IF;
	    
	    //- Lower entrance Jam
	    
	    #sR_TRIG_LowEntr_Jam(CLK := #sUDT_HMIStatus.Specific.LowerEntranceJam_Err);              // Oneshot trigger error occurred
	    
	    IF #iqUDT_VSUInterface.ResetStatistics OR                                              // IF there is signal TO reset statistics from VSU interface 
	        #iqUDT_EquipmentControl.Command.ResetData OR                                       // Or there is signal to reset statistics from equipment control structure 
	        #sUDT_HMIStatus.Specific.LowerEntranceJam_Err                                       // Or an upper switch area error occurred 
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics OR                 // Reset statistics from HMI
	                        #iqUDT_EquipmentControl.Command.ResetData,                         // Or reset statistics from control
	                        ix_Activate := #sUDT_HMIStatus.Specific.LowerEntranceJam_Err,       // Upper switch area error occurred
	                        ix_RTrigActivate := #sR_TRIG_LowEntr_Jam.Q,                          // Error trigger 
	                        iqUDT_Statistics := #iqUDT_Statistics.LowerEntranceJam_Error);         // Statistics of VSU errors 
	        
	    END_IF;
	    
	    // Direction error
	    
	    #sR_TRIG_Direction_Error(CLK := #sUDT_HMIStatus.Specific.Direction_Err);                 // Oneshot trigger error occurred
	    
	    IF #iqUDT_VSUInterface.ResetStatistics OR                                              // IF there is signal TO reset statistics from VSU interface 
	        #iqUDT_EquipmentControl.Command.ResetData OR                                       // Or there is signal to reset statistics from equipment control structure 
	        #sUDT_HMIStatus.Specific.Direction_Err                                              // Or an upper switch area error occurred 
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_VSUInterface.ResetStatistics OR                 // Reset statistics from HMI
	                        #iqUDT_EquipmentControl.Command.ResetData,                         // Or reset statistics from control
	                        ix_Activate := #sUDT_HMIStatus.Specific.Direction_Err,              // Upper switch area error occurred
	                        ix_RTrigActivate := #sR_TRIG_Direction_Error.Q,                      // Error trigger 
	                        iqUDT_Statistics := #iqUDT_Statistics.Direction_Error);                // Statistics of VSU errors 
	        
	    END_IF;
	    
	END_REGION
	
	REGION 10 - Status
	    
	    #sUDT_Status.Stopped := #sx_Ready AND NOT #sx_AutomaticActive AND NOT #sx_Stopping;    // stopped
	    #sUDT_Status.AutoON := #sx_AutomaticActive OR #sx_Stopping;                            // Auto On
	    #sUDT_Status.Halted := FALSE;                                                          // Halted
	    #sUDT_Status.Dieback := FALSE;                                                         // Die back
	    #sUDT_Status.Running := (#sx_UpRequest OR #sx_DownRequest) AND #sx_AutomaticActive;                              // Running
	    #sUDT_Status.ManualRun := #sx_ManualModeActive AND #sUDT_Status.Running;             // Manual run
	    #sUDT_Status.Manual := #sx_ManualModeActive;                                           // Manual
	    #sUDT_Status.EnergySave := FALSE;                                                      // Energy save active
	    #sUDT_Status.SafetyStop := NOT #ix_SafetyOk;                                           // Safety not ok
	    
	    //   Specific status
	    #sUDT_HMIStatus.Specific.ReferencedError := NOT #iqUDT_VSUInterface.Referenced;
	    
	    IF #sUDT_StatusOld <> #sUDT_Status                                            // update on change
	    THEN
	        
	        // Set status to status number
	        #sUDT_HMIStatus.Status := 0;                                               // Initialise status number              
	        
	        IF #sUDT_Status.Running                                                    // Running
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Running;
	            
	        END_IF;
	        
	        IF #sUDT_Status.Stopped                                                    // Stopped
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Stopped;
	            
	        END_IF;
	        
	        IF #sUDT_Status.Dieback                                                    // Dieback
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Dieback;
	            
	        END_IF;
	        
	        IF #sUDT_Status.ManualRun                                                  // Manual run
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".ManualRun;
	            
	        END_IF;
	        
	        IF #sUDT_Status.Manual                                                     // Manual
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Manual;
	            
	        END_IF;
	        
	        IF #iqUDT_VSUInterface.InternalWarningVFD                                  // The VFD has an internal warning
	            OR #iqUDT_VSUInterface.InternalWarningRIOPanel                         // The RIO panel has an internal warning    
	            
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Warning;
	            
	        END_IF;
	        
	        IF #sUDT_HMIStatus.Specific.UpperEntranceJam_Err                           // Upper entrance PEC Jam error
	            OR #sUDT_HMIStatus.Specific.LowerEntranceJam_Err                       // Lower entrance PEC Jam error
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".PECJam;
	            
	        END_IF;
	        
	        IF #sUDT_HMIStatus.Specific.ReferencedError                                // Refference error
	            OR #sUDT_HMIStatus.Specific.UpperSwitchArea_Err                        // Upper limit switch error
	            OR #sUDT_HMIStatus.Specific.LowerSwitchArea_Err                        // Lower limit switch error
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".VFDError;
	            
	        END_IF;
	        
	        IF #sUDT_HMIStatus.Specific.Direction_Err                                   // Direction error
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".OperationalError;
	            
	        END_IF;
	        
	        
	        IF #sUDT_HMIStatus.Specific.Keyswitch_WRN                                  // Key switch error
	            OR #iqUDT_VSUInterface.InternalErrorVFD                                // The VFD has an internal error
	            OR #iqUDT_VSUInterface.InternalErrorRIOPanel                           // The RIO panel has an internal error
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Error;
	            
	        END_IF;
	        
	        
	        IF #sUDT_Status.SafetyStop                                                 // Safety stop
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".SafetyStop;
	            
	        END_IF;
	        
	        #qUDT_HMIStatus := #sUDT_HMIStatus;                                       // Copy status to output
	        #sUDT_StatusOld := #sUDT_Status;                                          // Copy status TO memory
	        #qUDT_Status := #sUDT_Status;                                             // Copy status to output
	    END_IF;
	    
	    #qUDT_HMIStatus.Specific.UpperPosition := #sx_ActualPositionUP;
	    #qUDT_HMIStatus.Specific.LowerPosition := #sx_ActualPositionDown;
	    
	END_REGION
	
	REGION 11 - Report to control block
	    
	    "FC_EquipmentReport"(iUDT_Status := #sUDT_Status,
	                         iqUDT_Control := #iqUDT_EquipmentControl);
	    
	END_REGION
	
	REGION 12 - Internal errors and warnings reset
	    
	    #iqUDT_ConveyorInterface.InternalErrorPEC := FALSE;
	    #iqUDT_ConveyorInterface.InternalWarningTracking := FALSE;
	    #iqUDT_ConveyorInterface.InternalErrorTracking := FALSE;
	    #iqUDT_ConveyorInterface.InternalWarningVFD := FALSE;
	    #iqUDT_ConveyorInterface.InternalErrorVFD := FALSE;
	    #iqUDT_ConveyorInterface.Disconnected := FALSE;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_StopRoller"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 229
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_StopRollerConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_StopRollerConfiguration";   // Stop roller configuration structure
      ix_Pressure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when pressure buildup starts
      ix_PECBrake { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when the brake photoye is not blocked
      ix_PECStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when the stop photoye is not blocked
      ix_DownstreamStopActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when the downstream stop is active
      ix_SafetyOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when safety is ok
      ix_BrakePauseLong { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when receiving a delayed signal to increase brake pause
   END_VAR

   VAR_OUTPUT 
      qx_Valve { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when valve is activated
      qx_StopActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when stop is activated to upstream
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
   END_VAR

   VAR 
      s_PECBreakTimerOnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Function block to generate on/off signal delay on the brake PEC
      s_PECStopTimerOnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Function block to generate on/off signal delay on the Stop PEC
      s_PECPressureTimerOnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Function block to generate on/off signal delay on the pressure PEC
      s_StopFunctionTimerOnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Function block to generate on/off signal delay on the downstream stop active
      slr_StepTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Step timer
      si_BrakeFunction { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Brake function step
      sx_PECBrakeFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PEC filtered signal
      sx_PECStopFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PEC filtered signal
      sx_PECPressureFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PEC filtered signal
      sx_DownstreamStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Downstream is stopped
      sx_StopFunctionActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stop function is activated
      sx_StopRoller { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Roller is stop
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	23/06/2021  | 0.0       | F. Baten      | first release TIA 15.1
	20/10/2021  | 0.1       | M. Piela      | Activate valve when system is stoped. Stylistic correction
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	 *)
	
	REGION 1 - Timers
	    
	    // Filtering brake photo eye signal
	    #s_PECBreakTimerOnOffDelay(iudi_OnDelayTime := #iUDT_StopRollerConfiguration.PECBrakeOnDelay,
	                               iudi_OffDelayTime := #iUDT_StopRollerConfiguration.PECBrakeOffDelay,
	                               ix_SignalToDelay := #ix_PECBrake,
	                               ix_Enable := TRUE,
	                               qx_DelayedSignal => #sx_PECBrakeFiltered);
	    
	    // Filtering stop photo eye signal
	    #s_PECStopTimerOnOffDelay(iudi_OnDelayTime := #iUDT_StopRollerConfiguration.PECStopOnDelay,
	                              iudi_OffDelayTime := #iUDT_StopRollerConfiguration.PECStopOffDelay,
	                              ix_SignalToDelay := #ix_PECStop,
	                              ix_Enable := TRUE,
	                              qx_DelayedSignal => #sx_PECStopFiltered);
	    
	    // Filtering downstream stop photo eye signal
	    #s_StopFunctionTimerOnOffDelay(iudi_OnDelayTime := #iUDT_StopRollerConfiguration.StopFunctionOnDelay,
	                                   iudi_OffDelayTime := #iUDT_StopRollerConfiguration.StopFunctionOffDelay,
	                                   ix_SignalToDelay := #ix_DownstreamStopActive,
	                                   ix_Enable := TRUE,
	                                   qx_DelayedSignal => #sx_DownstreamStop);
	    // Sequence Timer
	    IF #slr_StepTimer > 0
	    THEN
	        #slr_StepTimer -= "DB_Memory".PrevCycleTime;
	        IF #slr_StepTimer < 0
	        THEN
	            #slr_StepTimer := 0;
	        END_IF;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Stop roller
	    
	    // Stop roller comes up when outfeed is not active and will fill up until last PEC is occupied.
	    // Sequence
	    // UP
	    IF (#si_BrakeFunction = 0) AND (#slr_StepTimer = 0)
	    THEN
	        #sx_StopRoller := True;
	        #slr_StepTimer := #iUDT_StopRollerConfiguration.BrakePuls;
	        #si_BrakeFunction := 1;
	    END_IF;
	    
	    // Down
	    IF (#si_BrakeFunction = 1) AND (#slr_StepTimer = 0) AND #ix_SafetyOk
	        AND ((#ix_DownstreamStopActive AND #sx_PECStopFiltered AND NOT #sx_PECBrakeFiltered)
	        OR (NOT #ix_DownstreamStopActive AND NOT #sx_PECBrakeFiltered))
	        
	    THEN
	        #sx_StopRoller := False;
	        
	        IF #ix_BrakePauseLong
	        THEN
	            #slr_StepTimer := #iUDT_StopRollerConfiguration.BrakePauseLong;
	        ELSE
	            #slr_StepTimer := #iUDT_StopRollerConfiguration.BrakePause;
	        END_IF;
	        
	        #si_BrakeFunction := 0;
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Stop roller valve
	    
	    IF #sx_StopFunctionActive AND #sx_PECStopFiltered
	    THEN
	        #sx_StopFunctionActive := FALSE;
	    END_IF;
	    
	    IF #ix_DownstreamStopActive //#sx_PECBrakeFiltered
	    THEN
	        #sx_StopFunctionActive := TRUE;
	    END_IF;
	    
	    IF #iUDT_StopRollerConfiguration.FailSafe
	    THEN
	        #qx_Valve := NOT (#sx_StopRoller OR NOT #ix_SafetyOk) OR #iqUDT_EquipmentControl.Command.Stop;
	    ELSE
	        #qx_Valve := #sx_StopRoller AND #ix_SafetyOk OR #iqUDT_EquipmentControl.Command.Stop;
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Stop active
	    
	    #qx_StopActive := #sx_StopFunctionActive AND NOT #sx_PECStopFiltered AND NOT #sx_PECBrakeFiltered;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_SpeedControl"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 228
// END_ATTRIBUTES
   VAR_INPUT 
      ir_FactorHighRange { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Factor when downstream speed is 500-800
      ir_FactorMediumRange { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Factor when downstream speed is 200-500
      ir_FactorLowRange { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Factor when downstream speed is 000-200
      iudi_DelayOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Delay time to go to downstream speed [ms]
      iudi_DelayOff { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Delay time to go to nominal speed [ms]
      ii_DownstreamSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Speed of the downstream conveyor [mm/s]
      ii_NominalSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Nominal speed of the conveyor [mm/s]
      ii_MinimalSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Reference speed to limit the belt to run on low frequency [mm/s]
      ix_PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when the end of section photoeye is not blocked
   END_VAR

   VAR_OUTPUT 
      qi_Speed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Speed for the conveyor [mm/s]
      qx_ReqDieback { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when request to put conveyor into dieback
   END_VAR

   VAR 
      sFB_SpeedSwitchTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Function block to generate on/off signal delay.
      sr_factor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Calculation factor
      sx_SpeedSwitch { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Speed switch (TRUE = downstream speed, FALSE = Nominal speed)
   END_VAR

   VAR CONSTANT 
      ci_SpeedHigh : Int := 500;   // Speed over this value is considered high
      ci_SpeedLow : Int := 200;   // Speed over this value is considered low
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	05/12/2019  | 3.0       | M. Kurpiers   | first release MHSE TIA 15.1
	15/01/2020  | 3.1       | F.Baten       | Renamed qx_ReqHalt to qx_ReqDieback 
	10/03/2021  | 3.2       | S.Theocharis  | Add factors of following speed 
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – First PLC cycle
	    
	    //Set nominal speed in the first scan of the PLC
	    IF ("DB_Memory".FirstScan)
	    THEN
	        
	        #qi_Speed := #ii_NominalSpeed;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 – Timer to speed switch
	    
	    // Delay of switching between speeds depending on the PEC signal 
	    #sFB_SpeedSwitchTimer(iudi_OnDelayTime := #iudi_DelayOn,
	                          iudi_OffDelayTime := #iudi_DelayOff,
	                          ix_SignalToDelay := NOT #ix_PEC,
	                          qx_DelayedSignal => #sx_SpeedSwitch);
	    
	END_REGION
	
	REGION 3 - Determine factor
	    
	    IF #ii_DownstreamSpeed >= #ci_SpeedHigh THEN
	        
	        #sr_factor := #ir_FactorHighRange;
	        
	    ELSIF #ci_SpeedLow < #ii_DownstreamSpeed AND #ii_DownstreamSpeed < #ci_SpeedHigh THEN
	        
	        #sr_factor := #ir_FactorMediumRange;
	        
	    ELSIF #ii_DownstreamSpeed <= #ci_SpeedLow THEN
	        #sr_factor := #ir_FactorLowRange;
	    END_IF;
	    
	    
	END_REGION
	
	REGION 4 – Conveyor speed selection
	    
	    IF (#sx_SpeedSwitch)
	    THEN
	        
	        // Set speed of downstream conveyor
	        #qi_Speed := REAL_TO_INT(#sr_factor * INT_TO_REAL(#ii_DownstreamSpeed));
	        
	        IF #qi_Speed > #ii_NominalSpeed THEN
	            #qi_Speed := #ii_NominalSpeed;
	        END_IF;
	        
	    ELSE
	        
	        // Set nominal speed
	        #qi_Speed := #ii_NominalSpeed;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 5 – Stop conveyor
	    
	    // Halt the conveyor when the downstream speed is lower than minimal speed
	    #qx_ReqDieback := (#ii_DownstreamSpeed < #ii_MinimalSpeed);
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_WeighingScale"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 42
// END_ATTRIBUTES
   VAR_INPUT 
      ix_ScaleInFault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Weighing Scale unit is in fault
   END_VAR

   VAR_OUTPUT 
      qUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   //  Common status structure
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_WE01Status";   //  HMI status structure
      qx_Automatic { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   //  Equipment control structure
   END_VAR

   VAR 
      sUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_WE01Status";   // UDT Weigghing Scale status
      sUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //  Common status structure
      sUDT_CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //  Common status structure
      sUDT_CommonStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //  Auxiliary status structure
      sFB_TimerOnOffDelayAutoOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sx_AutoOnDelayed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR CONSTANT 
      cdi_DelayOffAutomaticOn : UDInt := 600000;   // Delay before turning off the AutoOn signal
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	17/09/2019  | 2.0       | M.Singh       | first release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	12/03/2024  | 4.1       | S. Nieswie    | Variable name changes accroding to current standard
	
	 *)
	
	REGION 1 - Reset Error 
	    // If reset Provided from outside; reset the Error
	    
	    IF #iqUDT_EquipmentControl.Command.Reset THEN
	        #sUDT_HMIStatus.Specific.WeighingScaleFault := FALSE;
	    END_IF;
	END_REGION
	
	REGION 2 - Fault monitoring
	    // Make Camera Error Status
	    
	    IF #ix_ScaleInFault THEN
	        #sUDT_HMIStatus.Specific.WeighingScaleFault := True;
	    END_IF;
	END_REGION
	
	REGION 3 - Send Automatic Signal to Weighing Scale
	    //  Delay the Turning off of "Automatic on" Signal to Weighing Scale 
	    #sFB_TimerOnOffDelayAutoOn(iudi_OffDelayTime := #cdi_DelayOffAutomaticOn,
	                               ix_SignalToDelay := #iqUDT_EquipmentControl.Command.AutomaticOn,
	                               qx_DelayedSignal => #sx_AutoOnDelayed);
	    
	    #qx_Automatic := #sx_AutoOnDelayed;
	END_REGION
	
	REGION 10 - Make Status
	    // Set Common Status Report
	    
	    // Error active
	    #sUDT_CommonStatus.Error := #sUDT_HMIStatus.Specific.WeighingScaleFault;
	    
	    // Running
	    #sUDT_CommonStatus.Running := #iqUDT_EquipmentControl.Command.AutomaticOn AND NOT #sUDT_CommonStatus.Error;
	    
	    // Stopped 
	    #sUDT_CommonStatus.Stopped := NOT #qx_Automatic;
	    
	    IF #sUDT_CommonStatusOld <> #sUDT_CommonStatus                   // update on change
	    THEN
	        
	        // HMI status initialization
	        #sUDT_HMIStatus.Status := 0;
	        
	        // Running in Automatic mode
	        IF #sUDT_CommonStatus.Running
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Running;
	        END_IF;
	        
	        // Stopped
	        IF #sUDT_CommonStatus.Stopped THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Stopped;
	        END_IF;
	        
	        // Error
	        IF #sUDT_HMIStatus.Specific.WeighingScaleFault
	        THEN
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Error;
	        END_IF;
	        
	        #sUDT_CommonStatusOld := #sUDT_CommonStatus;                  // Copy status to memory
	        #sUDT_Status := #sUDT_CommonStatus;                           // Copy status to output
	    END_IF;
	    
	    #qUDT_HMIStatus := #sUDT_HMIStatus;                               // Copy HMI status to output
	    #qUDT_Status := #sUDT_Status;                                     // Copy common status to output
	    
	    
	END_REGION
	
	REGION 11 - Report to control block
	    
	    // Function to manage report between control block and conveyor block
	    
	    "FC_EquipmentReport"(iUDT_Status := #sUDT_CommonStatus,
	                         iqUDT_Control := #iqUDT_EquipmentControl);
	    
	END_REGION
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MCOConveyLinxAixFullZPA"
TITLE = ConveyLinx reduced ZPA segment
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'Ihab Ajram'
FAMILY : ConveyLinx
NAME : ConveyLinx_Reduced_ZPA
VERSION : 0.6
//Version
//history:
//Date        | Version   | Author        | Remark
//----------------------------------------------------------------------------------------
//28/03/2024  | 0.1       | I.Ajram       | Initial
//17/04/2024  | 0.2       | S. Nieswiec   | Changed first scan bit to be taken from DB_Memory;
//                                        | If no initial direction, then set In Forward (region 0.0.2.3)
//                                        
//11/05/2024  | 0.3       | S. Nieswiec   | Changed first scan bit to be taken from DB_Memory;                                        
//                                        | For ConveyStart a transition from 0 to 2 is needed (region 0.3) i did it with your procedure structur check it please
//                                        | To controle whole segment only the GlobalDirAccModeUpstr variable in the first module of the segment is needed
//                                        | If i'm not mistaken direction is set at autoconfiguration and can't be changed by commands. The commands for changing direction
//                                        | only swap the manual mode direction so writing a 5 runs the whole section in reverse and 6 in forward
//                                        
//16/05/2024  | 0.4       | I.Ajram       | Region 0.3 add a check on #qUDT_AixOutputsModuleUpstream.ConveyStopControl/ #qUDT_AixOutputsModuleDownstream.ConveyStopControl
//                                        | if not #cw_ConeyStopDisable, then set it to #cw_ConeyStopDisable and reset to #cw_NormalFunction after 100ms
//
   VAR_INPUT 
      iUDT_AixInputsModuleUpstream { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixZpaFullIN";   // Input structure of conveylinx in ZPA full for the upstream
      iUDT_AixInputsModuleDownstream { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixZpaFullIN";   // Input structure of conveylinx in ZPA full for the downstream
      ix_SafetyOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when safety is ok
      ix_24vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 24VDC is healthy
      ix_ReverseDirection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FALSE when to run in forward direction and True to run in Reverse direction
   END_VAR

   VAR_OUTPUT 
      qUDT_AixOutputsModuleUpstream { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixZpaFullOUT";   // Output structure of conveylinx in ZPA full for the upstream
      qUDT_AixOutputsModuleDownstream { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_AixZpaFullOUT";   // Output structure of conveylinx in ZPA full for the upstream
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorStatus";   // HMI status structure
      qUDT_CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   // Common status structure
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
      iqUDT_ConveyorCommand : "UDT_ConveyorCommand";   // Conveyor command stucture
      iqUDT_ConveyorInterface : "UDT_ConveyorInterface";   //           Interface structure
      iqUDT_ZPAinterface : "UDT_ZPAinterface";   // Handshake structure in forward direction
      iqUDT_HandShakeUp : "UDT_ConveyorHandshake";   // Upstream handshake structure in forward direction
   END_VAR

   VAR 
      sFB_TimerOnOffDelay_GeneralJam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sR_Trig_ix_ReverseDirection {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sF_Trig_ix_ReverseDirection {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;
      sR_Trig_ConvCMD_Reverse {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sF_Trig_ConvCMD_Reverse {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;
      sR_Trig_ix_PECUpstreamEoS {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sF_Trig_ix_PECUpstreamEoS {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;
      sR_Trig_ix_PECUpstreamBoS {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sF_Trig_ix_PECUpstreamBoS {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;
      sR_Trig_ix_PECDownStreamEoS {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sF_Trig_ix_PECDownStreamEoS {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;
      sR_Trig_ix_PECDownStreamBoS {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sF_Trig_ix_PECDownStreamBoS {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;
      sR_TRIG_UpstreamHandshakeRTS {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sF_TRIG_DownstreamPlcPEC {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;
      sF_TRIG_UpstreamHandshakeTIP {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;
      si_previousDownStreamCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      sx_DownstreamZoneOccupied { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_DownstreamZoneOccupied1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR
   VAR RETAIN
      sa_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // To SCADA and Logic
         UpStream_Module { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Loading Side Local Status
            UpstreamZone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
               PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               MotorRunning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               JamDetected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
            END_STRUCT;
            DownstreamZone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
               PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               MotorRunning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               JamDetected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
            END_STRUCT;
            ArrivalCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Int;
            DepartureCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         END_STRUCT;
         DownStream_Module { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Loading Side Local Status
            UpstreamZone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
               PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               MotorRunning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               JamDetected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
            END_STRUCT;
            DownstreamZone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
               PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               MotorRunning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               JamDetected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
            END_STRUCT;
            ArrivalCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Int;
            DepartureCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         END_STRUCT;
         ZPA_Section { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
            InForward { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
            InReverse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
            NumberOfBoxes { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         END_STRUCT;
      END_STRUCT;
   END_VAR
   VAR 
      sa_Procedure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // From block interface
         Start { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Interface_Signal";
         Stop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_Interface_Signal";
         ReverseDirection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Interface_Signal";
         ForwardDirection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Interface_Signal";
         Reset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_Interface_Signal";
         ClearJamUpstream { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_Interface_Signal";
         ClearJamDownstream { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_Interface_Signal";
      END_STRUCT;
   END_VAR
   VAR RETAIN
      FLT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         FaultsPresent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         UpStream_Module { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
            Module { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
               ModuleResetFlag { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               ConnectionsNotOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
            END_STRUCT;
            LeftMotor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
               Overheat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               MaxTorque { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               Short { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               NotConn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               Overload { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               Stalled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               BadHall { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               AnyErr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               OverVoltage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               LowVoltage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
            END_STRUCT;
            RightMotor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
               Overheat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               MaxTorque { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               Short { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               NotConn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               Overload { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               Stalled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               BadHall { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               NotUsed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               AnyErr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               OverVoltage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               LowVoltage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
            END_STRUCT;
            LeftSensor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
               LowGain { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               Jam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
            END_STRUCT;
            RightSensor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
               LowGain { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               Jam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
            END_STRUCT;
         END_STRUCT;
         DownStream_Module { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
            Module { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
               ModuleResetFlag { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               ConnectionsNotOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
            END_STRUCT;
            LeftMotor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
               Overheat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               MaxTorque { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               Short { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               NotConn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               Overload { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               Stalled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               BadHall { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               NotUsed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               AnyErr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               OverVoltage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               LowVoltage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
            END_STRUCT;
            RightMotor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
               Overheat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               MaxTorque { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               Short { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               NotConn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               Overload { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               Stalled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               BadHall { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               NotUsed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               AnyErr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               OverVoltage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               LowVoltage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
            END_STRUCT;
            LeftSensor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
               LowGain { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               Jam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
            END_STRUCT;
            RightSensor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
               LowGain { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
               Jam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
            END_STRUCT;
         END_STRUCT;
         GeneralFaults { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
            GeneralMotorError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stopping motor error somewhere in segment (stalled and max torque not included).
            GeneralNetworkError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Network error somewhere in segment
            GeneralJamError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // JAM error somewhere in segment
            GeneralSensorError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Missing sensor somewhere in segment
         END_STRUCT;
      END_STRUCT;
   END_VAR
   VAR 
      UpstreamClearJamWDT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      DownstreamClearJamWDT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      ResetConveyStopControlPulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      si_GinBuffer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      sx_ResetConveyStopControls { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sx_GinWrote { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      sFB_TimerOnOffDelay_ConveyStopTo0 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sTOF_DownstreamZoneOccupied {InstructionName := 'TOF_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TOF_TIME;
   END_VAR

   VAR CONSTANT 
      cw_NormalFunction : Word := 0;
      cw_AccumulateZones : Word := 1;
      cw_ChangeAccumulationReleaseMode : Word := 3;
      cw_ReturnReleaseModeToConfiguredDefault : Word := 4;
      cw_RunAllFWDDirection : Word := 5;
      cw_RunAllREVDirection : Word := 6;
      cw_PlaceAllInMaintenanceMode : Word := 7;
      cw_SetDirectionToConfiguredDefaultForward : Word := 10;
      cw_SetDirectionToOppositeOfConfiguredDefaultReverse : Word := 11;
      cw_SelectAllModulesMask : Word := 16#00FF;
      cw_ZoneToWakeUpToAccept : Word := 4;
      cw_ZoneToStopWakeUp : Word := 1;
      cw_ConveyRun : Word := 2;
      cw_ConveyStop : Word := 1;
      cw_ConveyStopDisable : Word := 16#0000;
      cw_ClearJam : Word := 1;   // reset to 0 after jam cleared
      cw_AllowRelease : Word := 1;
      cw_LaneFull : Word := 5;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	
	Version
	history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	28/03/2024  | 0.1       | I.Ajram       | Initial
	17/04/2024  | 0.2       | S. Nieswiec   | Changed first scan bit to be taken from DB_Memory;
	                                        | If no initial direction, then set In Forward (region 0.0.2.3)
	                                        
	11/05/2024  | 0.3       | S. Nieswiec   | Changed first scan bit to be taken from DB_Memory;                                        
	                                        | For ConveyStart a transition from 0 to 2 is needed (region 0.3) i did it with your procedure structur check it please
	                                        | To controle whole segment only the GlobalDirAccModeUpstr variable in the first module of the segment is needed
	                                        | If i'm not mistaken direction is set at autoconfiguration and can't be changed by commands. The commands for changing direction
	                                        | only swap the manual mode direction so writing a 5 runs the whole section in reverse and 6 in forward
	                                        
	16/05/2024  | 0.4       | I.Ajram       | Region 0.3 add a check on #qUDT_AixOutputsModuleUpstream.ConveyStopControl/ #qUDT_AixOutputsModuleDownstream.ConveyStopControl
	                                        | if not #cw_ConeyStopDisable, then set it to #cw_ConeyStopDisable and reset to #cw_NormalFunction after 100ms
	                                        | activated IEC check on FB 
	22/05/2024  | 0.5       | S. Nieswiec   | Added PECs from plc conveyors upstream and downstream to block interface
	                                        | Rewrote handshake logic (region 5)
	                                        | Added general errors (region 3.3)
	                                        
	05/06/2024  | 0.6       | S. Nieswiec   | Changes regarding conveystop
	02/10/2024  | 0.7       | R. Willems    | Moved downstream signals to new function block in downstream zone sequence, and handle signals between both blocks
	                                          Added PEC interface handling upstream zone and downstream zone
	                                          
	                                        
	
	*)
	REGION 0 Block interface
	    REGION 0.0.1 edge detection
	        #sR_Trig_ix_ReverseDirection(CLK := #ix_ReverseDirection);
	        #sR_Trig_ConvCMD_Reverse(CLK := #iqUDT_ConveyorCommand.Reverse);
	        #sF_Trig_ix_ReverseDirection(CLK := #ix_ReverseDirection);
	        #sF_Trig_ConvCMD_Reverse(CLK := #iqUDT_ConveyorCommand.Reverse);
	        #sR_Trig_ix_PECUpstreamEoS(CLK := #iUDT_AixInputsModuleUpstream.AllSensorPortInputs.RightSensor);
	        #sF_Trig_ix_PECUpstreamEoS(CLK := #iUDT_AixInputsModuleUpstream.AllSensorPortInputs.RightSensor);
	        #sR_Trig_ix_PECUpstreamBoS(CLK := #iUDT_AixInputsModuleUpstream.AllSensorPortInputs.LeftSensor);
	        #sF_Trig_ix_PECUpstreamBoS(CLK := #iUDT_AixInputsModuleUpstream.AllSensorPortInputs.LeftSensor);
	        #sR_Trig_ix_PECDownStreamEoS(CLK := #iUDT_AixInputsModuleDownstream.AllSensorPortInputs.RightSensor);
	        #sF_Trig_ix_PECDownStreamEoS(CLK := #iUDT_AixInputsModuleDownstream.AllSensorPortInputs.RightSensor);
	        #sR_Trig_ix_PECDownStreamBoS(CLK := #iUDT_AixInputsModuleDownstream.AllSensorPortInputs.LeftSensor);
	        #sF_Trig_ix_PECDownStreamBoS(CLK := #iUDT_AixInputsModuleDownstream.AllSensorPortInputs.LeftSensor);
	        #sR_TRIG_UpstreamHandshakeRTS(CLK := #iqUDT_HandShakeUp.RTS);
	        IF (#iUDT_AixInputsModuleDownstream.DepartureCountDownstreamZone <> #iUDT_AixInputsModuleDownstream.ArrivalCountDownstreamZone) THEN
	            #sx_DownstreamZoneOccupied1 := TRUE;
	        ELSE
	            #sx_DownstreamZoneOccupied1 := FALSE;
	        END_IF;
	        #sTOF_DownstreamZoneOccupied(IN := #sx_DownstreamZoneOccupied1,
	                                     PT := T#500ms,
	                                     Q => #sx_DownstreamZoneOccupied);
	        
	        #sF_TRIG_DownstreamPlcPEC(CLK := #sx_DownstreamZoneOccupied);
	        #sF_TRIG_UpstreamHandshakeTIP(CLK := #iqUDT_HandShakeUp.TIP);
	        
	        
	        
	    END_REGION
	    REGION 0.0.2 Initial Conditions
	        REGION 0.0.2.1 in Forward
	            IF #sa_Status.ZPA_Section.InForward THEN
	                IF "DB_Memory".FirstScan THEN
	                    #qUDT_AixOutputsModuleDownstream.SetDishargeStatus := #cw_LaneFull;
	                    // ToDo add additional initial conditions here
	                END_IF;
	            END_IF;
	        END_REGION
	        REGION 0.0.2.2 in Reverse
	            IF #sa_Status.ZPA_Section.InReverse THEN
	                IF "DB_Memory".FirstScan THEN
	                    #qUDT_AixOutputsModuleUpstream.SetDishargeStatus := #cw_LaneFull;
	                    // ToDo add additional initial conditions here
	                END_IF;
	            END_IF;
	        END_REGION
	        REGION 0.0.2.3 no initial direction - set into Forward
	            IF NOT #sa_Status.ZPA_Section.InReverse AND NOT #sa_Status.ZPA_Section.InForward THEN
	                
	                #sa_Status.ZPA_Section.InForward := TRUE;
	                
	            END_IF;
	            
	        END_REGION
	        
	    END_REGION
	    REGION 0.1 Forward
	        REGION 0.1.2  Request
	            IF (NOT #sa_Status.ZPA_Section.InForward AND
	                (#sF_Trig_ix_ReverseDirection.Q OR #sF_Trig_ConvCMD_Reverse.Q)
	                ) OR
	                ("DB_Memory".FirstScan AND #sa_Status.ZPA_Section.InForward)
	            THEN
	                #sa_Procedure.ForwardDirection.RQST := TRUE;
	            END_IF;
	        END_REGION
	        REGION 0.1.3 Command
	            IF #sa_Procedure.ForwardDirection.RQST AND
	                #iqUDT_EquipmentControl.Report.Stopped
	            THEN
	                #sa_Procedure.ForwardDirection.CMD := TRUE;
	                #sa_Procedure.ForwardDirection.RQST := FALSE;
	            END_IF;
	        END_REGION
	        REGION 0.1.4 Set direction Forward       
	            IF #sa_Procedure.ForwardDirection.CMD THEN
	                #qUDT_AixOutputsModuleUpstream.GlobalDirAccModeUpstr :=
	                #cw_SetDirectionToConfiguredDefaultForward AND 16#00FF;
	                #sa_Procedure.ForwardDirection.CMD := FALSE;
	                #sa_Status.ZPA_Section.InForward := TRUE;
	                #sa_Status.ZPA_Section.InReverse := FALSE;
	            END_IF;
	        END_REGION
	    END_REGION
	    REGION 0.2 Reverse
	        
	        REGION 0.2.2  Request
	            IF (NOT #sa_Status.ZPA_Section.InReverse AND
	                (#sR_Trig_ix_ReverseDirection.Q OR #sR_Trig_ConvCMD_Reverse.Q)
	                ) OR
	                ("DB_Memory".FirstScan AND #sa_Status.ZPA_Section.InReverse)
	            THEN
	                #sa_Procedure.ReverseDirection.RQST := TRUE;
	            END_IF;
	        END_REGION
	        REGION 0.2.3 Command
	            IF #sa_Procedure.ReverseDirection.RQST AND
	                #iqUDT_EquipmentControl.Report.Stopped
	            THEN
	                #sa_Procedure.ReverseDirection.CMD := TRUE;
	                #sa_Procedure.ReverseDirection.RQST := FALSE;
	            END_IF;
	        END_REGION
	        REGION 0.2.4 set direction Reverse
	            IF #sa_Procedure.ReverseDirection.CMD THEN
	                #qUDT_AixOutputsModuleUpstream.GlobalDirAccModeUpstr :=
	                #cw_SetDirectionToOppositeOfConfiguredDefaultReverse AND 16#00FF;
	                #sa_Procedure.ReverseDirection.CMD := FALSE;
	                #sa_Status.ZPA_Section.InForward := FALSE;
	                #sa_Status.ZPA_Section.InReverse := TRUE;
	            END_IF;
	        END_REGION
	    END_REGION
	    REGION 0.3 Start
	        
	        IF #iqUDT_EquipmentControl.Command.Start THEN
	            #sa_Procedure.Start.RQST := TRUE;
	        END_IF;
	        
	        IF #sa_Procedure.Start.RQST THEN
	            IF #qUDT_AixOutputsModuleUpstream.ConveyStopControl <> #cw_ConveyStopDisable OR
	                #qUDT_AixOutputsModuleDownstream.ConveyStopControl <> #cw_ConveyStopDisable
	            THEN
	                #qUDT_AixOutputsModuleUpstream.ConveyStopControl := #cw_ConveyStopDisable;
	                #qUDT_AixOutputsModuleDownstream.ConveyStopControl := #cw_ConveyStopDisable;
	                #sx_ResetConveyStopControls := TRUE;
	            END_IF;
	            IF #ResetConveyStopControlPulse.qx_DelayedSignal OR
	                NOT #sx_ResetConveyStopControls
	            THEN
	                #sx_ResetConveyStopControls := FALSE;
	                #sa_Procedure.Start.CMD := TRUE;
	                #sa_Procedure.Start.RQST := FALSE;
	            END_IF;
	        END_IF;
	        
	        #ResetConveyStopControlPulse(ix_Enable := TRUE,
	                                     ix_SignalToDelay := #sx_ResetConveyStopControls,
	                                     iudi_OffDelayTime := 0,
	                                     iudi_OnDelayTime := 100);
	        
	        
	        IF #sa_Procedure.Start.CMD THEN
	            #qUDT_AixOutputsModuleUpstream.GlobalDirAccModeUpstr := #cw_NormalFunction;
	            
	            #qUDT_AixOutputsModuleUpstream.ConveyStopControl := #cw_ConveyRun;
	            #qUDT_AixOutputsModuleDownstream.ConveyStopControl := #cw_ConveyRun;
	            #sa_Procedure.Start.CMD := FALSE;
	        END_IF;
	    END_REGION
	    REGION 0.4 Stop
	        REGION 0.4.1 Stop request
	            IF (#iqUDT_EquipmentControl.Command.Stop
	                OR #sa_Procedure.ForwardDirection.RQST
	                OR #sa_Procedure.ReverseDirection.RQST
	                OR #FLT.FaultsPresent)
	                AND NOT (#qUDT_AixOutputsModuleUpstream.ConveyStopControl = #cw_ConveyStop)
	                
	            THEN
	                #sa_Procedure.Stop.RQST := TRUE;
	            END_IF;
	        END_REGION
	        REGION 0.4.2 Stop command
	            IF #sa_Procedure.Stop.RQST
	                AND NOT #iqUDT_HandShakeUp.TIP
	                AND NOT #iqUDT_ZPAinterface.Handshake.TIP
	            THEN
	                #qUDT_AixOutputsModuleUpstream.ConveyStopControl := #cw_ConveyStop;
	                #qUDT_AixOutputsModuleDownstream.ConveyStopControl := #cw_ConveyStop;
	                #sa_Procedure.Stop.RQST := FALSE;
	            END_IF;
	        END_REGION
	        
	        #sFB_TimerOnOffDelay_ConveyStopTo0(iudi_OnDelayTime := 1000,
	                                           ix_SignalToDelay := #qUDT_AixOutputsModuleDownstream.ConveyStopControl = #cw_ConveyStop,
	                                           ix_Enable := TRUE);
	        
	        IF #sFB_TimerOnOffDelay_ConveyStopTo0.qx_DelayedSignal THEN
	            #qUDT_AixOutputsModuleDownstream.ConveyStopControl := 0;
	            #qUDT_AixOutputsModuleUpstream.ConveyStopControl := 0;
	        END_IF;
	        
	    END_REGION
	END_REGION
	
	REGION 1 Reset faults
	    
	    REGION 1.1 - Send reset request to interface UDT
	        
	        // Reset signal is sent to the interface UDT (VFD block, Tracking block, PEC update block)
	        #iqUDT_ConveyorInterface.InternalErrorReset := #iqUDT_EquipmentControl.Command.Reset;
	        #iqUDT_ZPAinterface.ConveyorInterface.InternalErrorReset := #iqUDT_EquipmentControl.Command.Reset;
	        #iqUDT_ConveyorInterface.ResetStatistics := #iqUDT_EquipmentControl.Command.ResetData;
	        #iqUDT_ZPAinterface.ConveyorInterface.ResetStatistics := #iqUDT_EquipmentControl.Command.ResetData;
	        
	    END_REGION
	    
	END_REGION
	REGION 2 Local Status   
	    IF #sa_Status.ZPA_Section.InForward THEN
	        REGION 2.2 Status specific for Forward Direction
	            REGION 2.2.1 Up stream Module
	                REGION 2.2.1.1 Up Stream Zone
	                    #sa_Status.UpStream_Module.UpstreamZone.PEC :=
	                    #iUDT_AixInputsModuleUpstream.LocalUpstreamZoneStatus_Fwd = 16#04 OR
	                    #iUDT_AixInputsModuleUpstream.LocalUpstreamZoneStatus_Fwd = 16#05;
	                    
	                    #sa_Status.UpStream_Module.UpstreamZone.MotorRunning :=
	                    #iUDT_AixInputsModuleUpstream.LocalUpstreamZoneStatus_Fwd = 16#02 OR
	                    #iUDT_AixInputsModuleUpstream.LocalUpstreamZoneStatus_Fwd = 16#04;
	                    
	                    #sa_Status.UpStream_Module.UpstreamZone.Busy :=
	                    #iUDT_AixInputsModuleUpstream.LocalUpstreamZoneStatus_Fwd = 16#06;
	                    
	                END_REGION
	                REGION 2.2.1.2 Down Stream Zone
	                    #sa_Status.UpStream_Module.DownstreamZone.PEC :=
	                    #iUDT_AixInputsModuleUpstream.LocalDownstreamZoneStatus_Fwd = 16#04 OR
	                    #iUDT_AixInputsModuleUpstream.LocalDownstreamZoneStatus_Fwd = 16#05;
	                    
	                    #sa_Status.UpStream_Module.DownstreamZone.MotorRunning :=
	                    #iUDT_AixInputsModuleUpstream.LocalDownstreamZoneStatus_Fwd = 16#02 OR
	                    #iUDT_AixInputsModuleUpstream.LocalDownstreamZoneStatus_Fwd = 16#04;
	                    
	                    #sa_Status.UpStream_Module.DownstreamZone.Busy :=
	                    #iUDT_AixInputsModuleUpstream.LocalDownstreamZoneStatus_Fwd = 16#06;
	                END_REGION
	                REGION 2.2.1.3 Arrival / Departure count  
	                    #sa_Status.UpStream_Module.ArrivalCount := #iUDT_AixInputsModuleUpstream.ArrivalCountUpstreamZone;
	                    #sa_Status.UpStream_Module.DepartureCount := #iUDT_AixInputsModuleUpstream.DepartureCountDownstreamZone;
	                END_REGION
	            END_REGION
	            REGION 2.2.2 Down stream Module
	                REGION 2.2.2.1 Up Stream Zone
	                    #sa_Status.DownStream_Module.UpstreamZone.PEC :=
	                    #iUDT_AixInputsModuleDownstream.LocalUpstreamZoneStatus_Fwd = 16#04 OR
	                    #iUDT_AixInputsModuleDownstream.LocalUpstreamZoneStatus_Fwd = 16#05;
	                    
	                    #sa_Status.DownStream_Module.UpstreamZone.MotorRunning :=
	                    #iUDT_AixInputsModuleDownstream.LocalUpstreamZoneStatus_Fwd = 16#02 OR
	                    #iUDT_AixInputsModuleDownstream.LocalUpstreamZoneStatus_Fwd = 16#04;
	                    
	                    #sa_Status.DownStream_Module.UpstreamZone.Busy :=
	                    #iUDT_AixInputsModuleDownstream.LocalUpstreamZoneStatus_Fwd = 16#06;
	                END_REGION
	                REGION 2.2.2.2 Down Stream Zone
	                    #sa_Status.DownStream_Module.DownstreamZone.PEC :=
	                    #iUDT_AixInputsModuleDownstream.LocalDownstreamZoneStatus_Fwd = 16#04 OR
	                    #iUDT_AixInputsModuleDownstream.LocalDownstreamZoneStatus_Fwd = 16#05;
	                    
	                    #sa_Status.DownStream_Module.DownstreamZone.MotorRunning :=
	                    #iUDT_AixInputsModuleDownstream.LocalDownstreamZoneStatus_Fwd = 16#02 OR
	                    #iUDT_AixInputsModuleDownstream.LocalDownstreamZoneStatus_Fwd = 16#04;
	                    
	                    #sa_Status.DownStream_Module.DownstreamZone.Busy :=
	                    #iUDT_AixInputsModuleDownstream.LocalDownstreamZoneStatus_Fwd = 16#06;
	                END_REGION
	                REGION 2.2.2.3 Arrival / Departure count 
	                    #sa_Status.DownStream_Module.ArrivalCount := #iUDT_AixInputsModuleDownstream.ArrivalCountUpstreamZone;
	                    #sa_Status.DownStream_Module.DepartureCount := #iUDT_AixInputsModuleDownstream.DepartureCountDownstreamZone;
	                END_REGION
	            END_REGION
	            REGION 2.2.3 ZPA section Box Count
	                #sa_Status.ZPA_Section.NumberOfBoxes := #sa_Status.UpStream_Module.ArrivalCount - #sa_Status.DownStream_Module.DepartureCount;
	            END_REGION
	        END_REGION
	    ELSIF #sa_Status.ZPA_Section.InReverse THEN
	        REGION 2.3 Status specific for Reverse Direction
	            REGION 2.3.1 Up stream Module
	                REGION 2.3.1.1 Up Stream Zone
	                    #sa_Status.UpStream_Module.UpstreamZone.PEC :=
	                    #iUDT_AixInputsModuleUpstream.LocalUpstreamZoneStatus_Rev = 16#04 OR
	                    #iUDT_AixInputsModuleUpstream.LocalUpstreamZoneStatus_Rev = 16#05;
	                    
	                    #sa_Status.UpStream_Module.UpstreamZone.MotorRunning :=
	                    #iUDT_AixInputsModuleUpstream.LocalUpstreamZoneStatus_Rev = 16#02 OR
	                    #iUDT_AixInputsModuleUpstream.LocalUpstreamZoneStatus_Rev = 16#04;
	                    
	                    #sa_Status.UpStream_Module.UpstreamZone.Busy :=
	                    #iUDT_AixInputsModuleUpstream.LocalUpstreamZoneStatus_Rev = 16#06;
	                END_REGION
	                REGION 2.3.1.2 Down Stream Zone
	                    #sa_Status.UpStream_Module.DownstreamZone.PEC :=
	                    #iUDT_AixInputsModuleUpstream.LocalDownstreamZoneStatus_Rev = 16#04 OR
	                    #iUDT_AixInputsModuleUpstream.LocalDownstreamZoneStatus_Rev = 16#05;
	                    
	                    #sa_Status.UpStream_Module.DownstreamZone.MotorRunning :=
	                    #iUDT_AixInputsModuleUpstream.LocalDownstreamZoneStatus_Rev = 16#02 OR
	                    #iUDT_AixInputsModuleUpstream.LocalDownstreamZoneStatus_Rev = 16#04;
	                    
	                    #sa_Status.UpStream_Module.DownstreamZone.Busy :=
	                    #iUDT_AixInputsModuleUpstream.LocalDownstreamZoneStatus_Rev = 16#06;
	                END_REGION
	                REGION 2.3.1.3 Arrival / Departure count  
	                    #sa_Status.UpStream_Module.ArrivalCount := #iUDT_AixInputsModuleUpstream.ArrivalCountDownstreamZone;
	                    #sa_Status.UpStream_Module.DepartureCount := #iUDT_AixInputsModuleUpstream.DepartureCountUpstreamZone;
	                END_REGION
	            END_REGION
	            REGION 2.3.2 Down stream Module
	                REGION 2.3.2.1 Up Stream Zone
	                    #sa_Status.DownStream_Module.UpstreamZone.PEC :=
	                    #iUDT_AixInputsModuleDownstream.LocalUpstreamZoneStatus_Rev = 16#04 OR
	                    #iUDT_AixInputsModuleDownstream.LocalUpstreamZoneStatus_Rev = 16#05;
	                    
	                    #sa_Status.DownStream_Module.UpstreamZone.MotorRunning :=
	                    #iUDT_AixInputsModuleDownstream.LocalUpstreamZoneStatus_Rev = 16#02 OR
	                    #iUDT_AixInputsModuleDownstream.LocalUpstreamZoneStatus_Rev = 16#04;
	                    
	                    #sa_Status.DownStream_Module.UpstreamZone.Busy :=
	                    #iUDT_AixInputsModuleDownstream.LocalUpstreamZoneStatus_Rev = 16#06;
	                END_REGION
	                REGION 2.3.2.2 Down Stream Zone
	                    #sa_Status.DownStream_Module.DownstreamZone.PEC :=
	                    #iUDT_AixInputsModuleDownstream.LocalDownstreamZoneStatus_Rev = 16#04 OR
	                    #iUDT_AixInputsModuleDownstream.LocalDownstreamZoneStatus_Rev = 16#05;
	                    
	                    #sa_Status.DownStream_Module.DownstreamZone.MotorRunning :=
	                    #iUDT_AixInputsModuleDownstream.LocalDownstreamZoneStatus_Rev = 16#02 OR
	                    #iUDT_AixInputsModuleDownstream.LocalDownstreamZoneStatus_Rev = 16#04;
	                    
	                    #sa_Status.DownStream_Module.DownstreamZone.Busy :=
	                    #iUDT_AixInputsModuleDownstream.LocalDownstreamZoneStatus_Rev = 16#06;
	                END_REGION
	                REGION 2.3.2.3 Arrival / Departure count 
	                    #sa_Status.DownStream_Module.ArrivalCount := #iUDT_AixInputsModuleDownstream.ArrivalCountDownstreamZone;
	                    #sa_Status.DownStream_Module.DepartureCount := #iUDT_AixInputsModuleDownstream.DepartureCountUpstreamZone;
	                END_REGION
	            END_REGION
	            REGION 2.3.3 ZPA section Box Count
	                #sa_Status.ZPA_Section.NumberOfBoxes := #sa_Status.DownStream_Module.ArrivalCount - #sa_Status.UpStream_Module.DepartureCount;
	            END_REGION
	            
	        END_REGION
	    END_IF;
	    REGION 2.4 Equipment Report
	        REGION 2.4.1 Stopped
	            #iqUDT_EquipmentControl.Report.Stopped :=
	            #iUDT_AixInputsModuleUpstream.ConveyStopStatus.StopActiveCommandPLC OR
	            #iUDT_AixInputsModuleUpstream.ConveyStopStatus.StopActiveOtherModule OR
	            #iUDT_AixInputsModuleDownstream.ConveyStopStatus.StopActiveCommandPLC OR
	            #iUDT_AixInputsModuleDownstream.ConveyStopStatus.StopActiveOtherModule OR
	            FALSE;
	        END_REGION
	        REGION 2.4.1 Halted
	            #iqUDT_EquipmentControl.Report.Halted :=
	            #iUDT_AixInputsModuleUpstream.ConveyStopStatus.StopActiveLostConn OR
	            #iUDT_AixInputsModuleUpstream.ConveyStopStatus.StopActiveLostPLC OR
	            #iUDT_AixInputsModuleDownstream.ConveyStopStatus.StopActiveLostConn OR
	            #iUDT_AixInputsModuleDownstream.ConveyStopStatus.StopActiveLostPLC OR
	            FALSE;
	        END_REGION
	        REGION 2.4.2 Safety Stop
	            #iqUDT_EquipmentControl.Report.SafetyStop :=
	            NOT #ix_SafetyOk;
	        END_REGION
	        REGION 2.4.3 Warning
	            #iqUDT_EquipmentControl.Report.Warning :=
	            #FLT.UpStream_Module.LeftSensor.LowGain OR
	            #FLT.UpStream_Module.RightSensor.LowGain OR
	            #FLT.DownStream_Module.LeftSensor.LowGain OR
	            #FLT.DownStream_Module.RightSensor.LowGain;
	        END_REGION
	        REGION 2.4.4 Manual
	            #iqUDT_EquipmentControl.Report.Manual :=
	            (
	            #qUDT_AixOutputsModuleUpstream.GlobalDirAccModeDnstr = #cw_RunAllFWDDirection OR
	            #qUDT_AixOutputsModuleUpstream.GlobalDirAccModeDnstr = #cw_RunAllREVDirection
	            ) OR
	            (
	            #qUDT_AixOutputsModuleUpstream.GlobalDirAccModeUpstr = #cw_RunAllFWDDirection OR
	            #qUDT_AixOutputsModuleUpstream.GlobalDirAccModeUpstr = #cw_RunAllREVDirection
	            ) OR
	            (
	            #qUDT_AixOutputsModuleDownstream.GlobalDirAccModeDnstr = #cw_RunAllFWDDirection OR
	            #qUDT_AixOutputsModuleDownstream.GlobalDirAccModeDnstr = #cw_RunAllREVDirection
	            ) OR
	            (
	            #qUDT_AixOutputsModuleDownstream.GlobalDirAccModeUpstr = #cw_RunAllFWDDirection OR
	            #qUDT_AixOutputsModuleDownstream.GlobalDirAccModeUpstr = #cw_RunAllREVDirection
	            ) OR
	            FALSE;
	        END_REGION
	        REGION 2.4.5 Running
	            #iqUDT_EquipmentControl.Report.Running := NOT #iqUDT_EquipmentControl.Report.Stopped;
	        END_REGION
	        REGION 2.4.6 Manual Running
	            #iqUDT_EquipmentControl.Report.ManualRun :=
	            #iqUDT_EquipmentControl.Report.Running AND
	            #iqUDT_EquipmentControl.Report.Manual;
	        END_REGION
	        REGION 2.4.7 Energy Save
	            // ZPA is always in energy save
	            #iqUDT_EquipmentControl.Report.EnergySave := TRUE;
	        END_REGION
	        REGION 2.4.8 AutoON
	            #iqUDT_EquipmentControl.Report.AutoON := #iqUDT_EquipmentControl.Report.Running;
	        END_REGION
	        REGION 2.4.9 Error
	            #iqUDT_EquipmentControl.Report.Error :=
	            #FLT.FaultsPresent OR
	            FALSE;
	        END_REGION
	        REGION 2.4.10 Jam detection
	            #sa_Status.UpStream_Module.UpstreamZone.JamDetected := #iUDT_AixInputsModuleUpstream.Diagnostic.UpstreamJamErr;
	            #sa_Status.UpStream_Module.DownstreamZone.JamDetected := #iUDT_AixInputsModuleUpstream.Diagnostic.DownstreamJamErr;
	            #sa_Status.DownStream_Module.UpstreamZone.JamDetected := #iUDT_AixInputsModuleDownstream.Diagnostic.UpstreamJamErr;
	            #sa_Status.DownStream_Module.DownstreamZone.JamDetected := #iUDT_AixInputsModuleDownstream.Diagnostic.DownstreamJamErr;
	            
	            
	        END_REGION
	        REGION 2.4.11 Pass Reset Signal to Module
	            REGION 2.4.11.1 Reset Request
	                IF #iqUDT_EquipmentControl.Command.Reset AND
	                    #iqUDT_EquipmentControl.Report.Error
	                THEN
	                    #sa_Procedure.Reset.RQST := TRUE;
	                END_IF;
	            END_REGION
	            REGION 2.4.11.2 Reset Command
	                IF #sa_Procedure.Reset.RQST AND
	                    NOT #iqUDT_EquipmentControl.Report.Running
	                THEN
	                    #sa_Procedure.Reset.RQST := FALSE;
	                    
	                    // upstream
	                    #qUDT_AixOutputsModuleUpstream.ClearMotorError := 1;
	                    #qUDT_AixOutputsModuleUpstream.ClearJamUpstream := 1;
	                    #qUDT_AixOutputsModuleUpstream.ClearJamDownstream := 1;
	                    // downstream
	                    #qUDT_AixOutputsModuleDownstream.ClearMotorError := 1;
	                    #qUDT_AixOutputsModuleDownstream.ClearJamUpstream := 1;
	                    #qUDT_AixOutputsModuleDownstream.ClearJamDownstream := 1;
	                END_IF;
	            END_REGION
	        END_REGION
	        REGION 2.4.12 Upstream Pass Clear Jam Signal to Module
	            REGION 2.4.12.1 Upstream Clear Jam Request
	                IF #iqUDT_EquipmentControl.Command.Reset AND
	                    (#sa_Status.UpStream_Module.UpstreamZone.JamDetected OR
	                    #sa_Status.UpStream_Module.DownstreamZone.JamDetected)
	                THEN
	                    #sa_Procedure.ClearJamUpstream.RQST := TRUE;
	                END_IF;
	            END_REGION
	            REGION 2.4.12.2 Upstream ClearJam Command
	                IF #sa_Procedure.ClearJamUpstream.RQST
	                THEN
	                    #sa_Procedure.ClearJamUpstream.RQST := FALSE;
	                    #sa_Procedure.ClearJamUpstream.CMD := TRUE;
	                    #qUDT_AixOutputsModuleUpstream.ClearJamUpstream := 1;
	                    #qUDT_AixOutputsModuleUpstream.ClearJamDownstream := 1;
	                END_IF;
	            END_REGION
	            REGION 2.4.12.3 Upstream ClearJamWDT
	                #UpstreamClearJamWDT(iudi_OnDelayTime := 6000,
	                                     iudi_OffDelayTime := 0,
	                                     ix_Enable := TRUE,
	                                     ix_SignalToDelay := #sa_Procedure.ClearJamUpstream.CMD);
	            END_REGION
	            REGION 2.4.12.4 Upstream Exit Clear Jam
	                IF NOT (#sa_Status.UpStream_Module.UpstreamZone.JamDetected OR
	                    #sa_Status.UpStream_Module.DownstreamZone.JamDetected)
	                    OR #UpstreamClearJamWDT.qx_DelayedSignal
	                THEN
	                    #qUDT_AixOutputsModuleUpstream.ClearJamUpstream := 0;
	                    #qUDT_AixOutputsModuleUpstream.ClearJamDownstream := 0;
	                    #sa_Procedure.ClearJamUpstream.CMD := FALSE;
	                END_IF;
	            END_REGION
	        END_REGION
	        REGION 2.4.13 Downstream Pass Clear Jam Signal to Module
	            REGION 2.4.13.1 downstream Clear Jam Request
	                IF #iqUDT_EquipmentControl.Command.Reset AND
	                    (#sa_Status.DownStream_Module.UpstreamZone.JamDetected OR
	                    #sa_Status.DownStream_Module.DownstreamZone.JamDetected)
	                THEN
	                    #sa_Procedure.ClearJamDownstream.RQST := TRUE;
	                END_IF;
	            END_REGION
	            REGION 2.4.13.2 downstream ClearJam Command
	                IF #sa_Procedure.ClearJamDownstream.RQST
	                THEN
	                    #sa_Procedure.ClearJamDownstream.RQST := FALSE;
	                    #sa_Procedure.ClearJamDownstream.CMD := TRUE;
	                    #qUDT_AixOutputsModuleDownstream.ClearJamUpstream := 1;
	                    #qUDT_AixOutputsModuleDownstream.ClearJamDownstream := 1;
	                END_IF;
	            END_REGION
	            REGION 2.4.13.3 downstream ClearJamWDT
	                #DownstreamClearJamWDT(iudi_OnDelayTime := 6000,
	                                       iudi_OffDelayTime := 0,
	                                       ix_Enable := TRUE,
	                                       ix_SignalToDelay := #sa_Procedure.ClearJamDownstream.CMD);
	            END_REGION
	            REGION 2.4.13.4 downstream Exit Clear Jam
	                IF NOT (#sa_Status.DownStream_Module.UpstreamZone.JamDetected OR
	                    #sa_Status.DownStream_Module.DownstreamZone.JamDetected)
	                    OR #DownstreamClearJamWDT.qx_DelayedSignal
	                THEN
	                    #qUDT_AixOutputsModuleDownstream.ClearJamUpstream := 0;
	                    #qUDT_AixOutputsModuleDownstream.ClearJamDownstream := 0;
	                    #sa_Procedure.ClearJamDownstream.CMD := FALSE;
	                END_IF;
	            END_REGION
	        END_REGION
	    END_REGION
	END_REGION
	
	REGION 3 Faults
	    REGION 3.0 Faults present detection
	        
	        #FLT.FaultsPresent := #FLT.UpStream_Module.Module.ConnectionsNotOK
	        OR #FLT.UpStream_Module.LeftMotor.AnyErr
	        OR #FLT.UpStream_Module.RightMotor.AnyErr
	        OR #FLT.UpStream_Module.LeftSensor.LowGain
	        OR #FLT.UpStream_Module.RightSensor.LowGain
	        //  OR #FLT.UpStream_Module.LeftSensor.Jam
	        //  OR #FLT.UpStream_Module.RightSensor.Jam
	        
	        OR #FLT.DownStream_Module.Module.ConnectionsNotOK
	        OR #FLT.DownStream_Module.LeftMotor.AnyErr
	        OR #FLT.DownStream_Module.RightMotor.AnyErr
	        OR #FLT.DownStream_Module.LeftSensor.LowGain
	        OR #FLT.DownStream_Module.RightSensor.LowGain
	        // OR #FLT.DownStream_Module.LeftSensor.Jam
	        // OR #FLT.DownStream_Module.RightSensor.Jam
	        
	        OR #FLT.GeneralFaults.GeneralMotorError
	        OR #FLT.GeneralFaults.GeneralNetworkError
	        OR #FLT.GeneralFaults.GeneralJamError
	        OR #FLT.GeneralFaults.GeneralSensorError
	        
	        OR #iqUDT_ConveyorInterface.InternalErrorPEC
	        OR #iqUDT_ZPAinterface.ConveyorInterface.InternalErrorPEC
	        OR FALSE;
	        
	    END_REGION
	    
	    REGION 3.1 UpStream
	        REGION 3.1.1 Module
	            
	            #FLT.UpStream_Module.Module.ModuleResetFlag := #iUDT_AixInputsModuleUpstream.Diagnostic.ModuleResetFlag;
	            
	            IF #iUDT_AixInputsModuleUpstream.Diagnostic.ConnectionsNotOK THEN
	                #FLT.UpStream_Module.Module.ConnectionsNotOK := TRUE;
	            END_IF;
	        END_REGION
	        REGION 3.1.2 Left Motor
	            
	            IF #iUDT_AixInputsModuleUpstream.Diagnostic.LeftMotorOverheat THEN
	                #FLT.UpStream_Module.LeftMotor.Overheat := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleUpstream.Diagnostic.LeftMotorMaxTorque THEN
	                #FLT.UpStream_Module.LeftMotor.MaxTorque := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleUpstream.Diagnostic.LeftMotorShort THEN
	                #FLT.UpStream_Module.LeftMotor.Short := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleUpstream.Diagnostic.LeftMotorNotConn THEN
	                #FLT.UpStream_Module.LeftMotor.NotConn := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleUpstream.Diagnostic.LeftMotorOverload THEN
	                #FLT.UpStream_Module.LeftMotor.Overload := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleUpstream.Diagnostic.LeftMotorStalled THEN
	                #FLT.UpStream_Module.LeftMotor.Stalled := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleUpstream.Diagnostic.LeftMotorBadHall THEN
	                #FLT.UpStream_Module.LeftMotor.BadHall := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleUpstream.Diagnostic.LeftMotorAnyErr THEN
	                #FLT.UpStream_Module.LeftMotor.AnyErr := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleUpstream.Diagnostic.OverVoltage THEN
	                #FLT.UpStream_Module.LeftMotor.OverVoltage := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleUpstream.Diagnostic.LowVoltage THEN
	                #FLT.UpStream_Module.LeftMotor.LowVoltage := TRUE;
	            END_IF;
	        END_REGION
	        
	        REGION 3.1.3 Right Motor
	            
	            IF #iUDT_AixInputsModuleUpstream.Diagnostic.RightMotorOverheat THEN
	                #FLT.UpStream_Module.RightMotor.Overheat := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleUpstream.Diagnostic.RightMotorMaxTorque THEN
	                #FLT.UpStream_Module.RightMotor.MaxTorque := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleUpstream.Diagnostic.RightMotorShort THEN
	                #FLT.UpStream_Module.RightMotor.Short := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleUpstream.Diagnostic.RightMotorNotConn THEN
	                #FLT.UpStream_Module.RightMotor.NotConn := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleUpstream.Diagnostic.RightMotorOverload THEN
	                #FLT.UpStream_Module.RightMotor.Overload := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleUpstream.Diagnostic.RightMotorStalled THEN
	                #FLT.UpStream_Module.RightMotor.Stalled := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleUpstream.Diagnostic.RightMotorBadHall THEN
	                #FLT.UpStream_Module.RightMotor.BadHall := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleUpstream.Diagnostic.RightMotorAnyErr THEN
	                #FLT.UpStream_Module.RightMotor.AnyErr := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleUpstream.Diagnostic.OverVoltage THEN
	                #FLT.UpStream_Module.RightMotor.OverVoltage := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleUpstream.Diagnostic.LowVoltage THEN
	                #FLT.UpStream_Module.RightMotor.LowVoltage := TRUE;
	            END_IF;
	            
	        END_REGION
	        REGION 3.1.4 Left Sensor
	            IF #iUDT_AixInputsModuleUpstream.Diagnostic.LeftSensLowGain THEN
	                #FLT.UpStream_Module.LeftSensor.LowGain := TRUE;
	            END_IF;
	            
	            IF #sa_Status.UpStream_Module.UpstreamZone.JamDetected
	                AND NOT #sa_Procedure.ClearJamUpstream.CMD
	                AND NOT #sa_Procedure.ClearJamUpstream.RQST
	            THEN
	                #FLT.UpStream_Module.LeftSensor.Jam := TRUE;
	            ELSE
	                #FLT.UpStream_Module.LeftSensor.Jam := FALSE;
	            END_IF;
	        END_REGION
	        REGION 3.1.5 Right Sensor
	            IF #iUDT_AixInputsModuleUpstream.Diagnostic.RightSensLowGain THEN
	                #FLT.UpStream_Module.RightSensor.LowGain := TRUE;
	            END_IF;
	            
	            IF #sa_Status.UpStream_Module.DownstreamZone.JamDetected
	                AND NOT #sa_Procedure.ClearJamUpstream.CMD
	                AND NOT #sa_Procedure.ClearJamUpstream.RQST
	            THEN
	                #FLT.UpStream_Module.RightSensor.Jam := TRUE;
	            ELSE
	                #FLT.UpStream_Module.RightSensor.Jam := FALSE;
	            END_IF;
	        END_REGION
	    END_REGION
	    
	    REGION 3.2 DownStream
	        REGION 3.2.1 Module
	            
	            #FLT.DownStream_Module.Module.ModuleResetFlag := #iUDT_AixInputsModuleDownstream.Diagnostic.ModuleResetFlag;
	            
	            IF #iUDT_AixInputsModuleDownstream.Diagnostic.ConnectionsNotOK THEN
	                #FLT.DownStream_Module.Module.ConnectionsNotOK := TRUE;
	            END_IF;
	        END_REGION
	        REGION 3.2.2 Left Motor
	            
	            IF #iUDT_AixInputsModuleDownstream.Diagnostic.LeftMotorOverheat THEN
	                #FLT.DownStream_Module.LeftMotor.Overheat := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleDownstream.Diagnostic.LeftMotorMaxTorque THEN
	                #FLT.DownStream_Module.LeftMotor.MaxTorque := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleDownstream.Diagnostic.LeftMotorShort THEN
	                #FLT.DownStream_Module.LeftMotor.Short := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleDownstream.Diagnostic.LeftMotorNotConn THEN
	                #FLT.DownStream_Module.LeftMotor.NotConn := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleDownstream.Diagnostic.LeftMotorOverload THEN
	                #FLT.DownStream_Module.LeftMotor.Overload := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleDownstream.Diagnostic.LeftMotorStalled THEN
	                #FLT.DownStream_Module.LeftMotor.Stalled := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleDownstream.Diagnostic.LeftMotorBadHall THEN
	                #FLT.DownStream_Module.LeftMotor.BadHall := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleDownstream.Diagnostic.LeftMotorAnyErr THEN
	                #FLT.DownStream_Module.LeftMotor.AnyErr := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleDownstream.Diagnostic.OverVoltage THEN
	                #FLT.DownStream_Module.LeftMotor.OverVoltage := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleDownstream.Diagnostic.LowVoltage THEN
	                #FLT.DownStream_Module.LeftMotor.LowVoltage := TRUE;
	            END_IF;
	        END_REGION
	        
	        REGION 3.2.3 Right Motor
	            
	            IF #iUDT_AixInputsModuleDownstream.Diagnostic.RightMotorOverheat THEN
	                #FLT.DownStream_Module.RightMotor.Overheat := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleDownstream.Diagnostic.RightMotorMaxTorque THEN
	                #FLT.DownStream_Module.RightMotor.MaxTorque := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleDownstream.Diagnostic.RightMotorShort THEN
	                #FLT.DownStream_Module.RightMotor.Short := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleDownstream.Diagnostic.RightMotorNotConn THEN
	                #FLT.DownStream_Module.RightMotor.NotConn := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleDownstream.Diagnostic.RightMotorOverload THEN
	                #FLT.DownStream_Module.RightMotor.Overload := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleDownstream.Diagnostic.RightMotorStalled THEN
	                #FLT.DownStream_Module.RightMotor.Stalled := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleDownstream.Diagnostic.RightMotorBadHall THEN
	                #FLT.DownStream_Module.RightMotor.BadHall := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleDownstream.Diagnostic.RightMotorAnyErr THEN
	                #FLT.DownStream_Module.RightMotor.AnyErr := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleDownstream.Diagnostic.OverVoltage THEN
	                #FLT.DownStream_Module.RightMotor.OverVoltage := TRUE;
	            END_IF;
	            
	            IF #iUDT_AixInputsModuleDownstream.Diagnostic.LowVoltage THEN
	                #FLT.DownStream_Module.RightMotor.LowVoltage := TRUE;
	            END_IF;
	            
	        END_REGION
	        REGION 3.2.4 Left Sensor
	            IF #iUDT_AixInputsModuleDownstream.Diagnostic.LeftSensLowGain THEN
	                #FLT.DownStream_Module.LeftSensor.LowGain := TRUE;
	            END_IF;
	            
	            IF #sa_Status.DownStream_Module.UpstreamZone.JamDetected
	                AND NOT #sa_Procedure.ClearJamUpstream.CMD
	                AND NOT #sa_Procedure.ClearJamUpstream.RQST
	            THEN
	                #FLT.DownStream_Module.LeftSensor.Jam := TRUE;
	            ELSE
	                #FLT.DownStream_Module.LeftSensor.Jam := FALSE;
	            END_IF;
	        END_REGION
	        REGION 3.2.5 Right Sensor
	            IF #iUDT_AixInputsModuleDownstream.Diagnostic.RightSensLowGain THEN
	                #FLT.DownStream_Module.RightSensor.LowGain := TRUE;
	            END_IF;
	            
	            IF #sa_Status.DownStream_Module.DownstreamZone.JamDetected
	                AND NOT #sa_Procedure.ClearJamDownstream.CMD
	                AND NOT #sa_Procedure.ClearJamDownstream.RQST
	            THEN
	                #FLT.DownStream_Module.RightSensor.Jam := TRUE;
	            ELSE
	                #FLT.DownStream_Module.RightSensor.Jam := FALSE;
	            END_IF;
	        END_REGION
	    END_REGION
	    
	    REGION 3.3 General 
	        // Error present somewhere in whole segment
	        
	        REGION 3.3.1 Motor error
	            IF #iUDT_AixInputsModuleDownstream.GeneralLineError.MotorError THEN
	                #FLT.GeneralFaults.GeneralMotorError := TRUE;
	            END_IF;
	        END_REGION
	        
	        
	        REGION 3.3.2 Network error
	            IF #iUDT_AixInputsModuleDownstream.GeneralLineError.ConnectionError THEN
	                #FLT.GeneralFaults.GeneralNetworkError := TRUE;
	            END_IF;
	        END_REGION
	        
	        REGION 3.3.3 Jam error
	            
	            #sFB_TimerOnOffDelay_GeneralJam(iudi_OnDelayTime := 500,
	                                            ix_SignalToDelay := #iUDT_AixInputsModuleDownstream.GeneralLineError.JamError
	                                            AND #qUDT_AixOutputsModuleUpstream.ConveyStopControl = #cw_ConveyRun,
	                                            ix_Enable := TRUE);
	            
	            IF #sFB_TimerOnOffDelay_GeneralJam.qx_DelayedSignal
	                AND NOT #sa_Procedure.ClearJamDownstream.RQST
	                AND NOT #sa_Procedure.ClearJamUpstream.RQST
	                AND #qUDT_AixOutputsModuleUpstream.ConveyStopControl = #cw_ConveyRun
	            THEN
	                #FLT.GeneralFaults.GeneralJamError := TRUE;
	                
	            ELSIF #iqUDT_EquipmentControl.Command.Reset AND (#qUDT_AixOutputsModuleUpstream.ConveyStopControl = 0) THEN
	                #FLT.GeneralFaults.GeneralJamError := FALSE;
	            END_IF;
	        END_REGION
	        
	        REGION 3.3.4 Sensor Error
	            IF #iUDT_AixInputsModuleDownstream.GeneralLineError.MotorError THEN
	                #FLT.GeneralFaults.GeneralSensorError := TRUE;
	            END_IF;
	        END_REGION
	        
	    END_REGION
	    
	    REGION 3.4 - Error Resets
	        IF #iqUDT_EquipmentControl.Command.Reset THEN
	            
	            #FLT.UpStream_Module.Module.ConnectionsNotOK := FALSE;
	            #FLT.UpStream_Module.LeftMotor.Overheat := FALSE;
	            #FLT.UpStream_Module.LeftMotor.MaxTorque := FALSE;
	            #FLT.UpStream_Module.LeftMotor.Short := FALSE;
	            #FLT.UpStream_Module.LeftMotor.NotConn := FALSE;
	            #FLT.UpStream_Module.LeftMotor.Overload := FALSE;
	            #FLT.UpStream_Module.LeftMotor.Stalled := FALSE;
	            #FLT.UpStream_Module.LeftMotor.BadHall := FALSE;
	            #FLT.UpStream_Module.LeftMotor.AnyErr := FALSE;
	            #FLT.UpStream_Module.LeftMotor.OverVoltage := FALSE;
	            #FLT.UpStream_Module.LeftMotor.LowVoltage := FALSE;
	            #FLT.UpStream_Module.RightMotor.Overheat := FALSE;
	            #FLT.UpStream_Module.RightMotor.MaxTorque := FALSE;
	            #FLT.UpStream_Module.RightMotor.Short := FALSE;
	            #FLT.UpStream_Module.RightMotor.NotConn := FALSE;
	            #FLT.UpStream_Module.RightMotor.Overload := FALSE;
	            #FLT.UpStream_Module.RightMotor.Stalled := FALSE;
	            #FLT.UpStream_Module.RightMotor.BadHall := FALSE;
	            #FLT.UpStream_Module.RightMotor.AnyErr := FALSE;
	            #FLT.UpStream_Module.RightMotor.OverVoltage := FALSE;
	            #FLT.UpStream_Module.RightMotor.LowVoltage := FALSE;
	            #FLT.UpStream_Module.LeftSensor.LowGain := FALSE;
	            #FLT.UpStream_Module.RightSensor.LowGain := FALSE;
	            
	            
	            #FLT.DownStream_Module.Module.ConnectionsNotOK := FALSE;
	            #FLT.DownStream_Module.LeftMotor.Overheat := FALSE;
	            #FLT.DownStream_Module.LeftMotor.MaxTorque := FALSE;
	            #FLT.DownStream_Module.LeftMotor.Short := FALSE;
	            #FLT.DownStream_Module.LeftMotor.NotConn := FALSE;
	            #FLT.DownStream_Module.LeftMotor.Overload := FALSE;
	            #FLT.DownStream_Module.LeftMotor.Stalled := FALSE;
	            #FLT.DownStream_Module.LeftMotor.BadHall := FALSE;
	            #FLT.DownStream_Module.LeftMotor.AnyErr := FALSE;
	            #FLT.DownStream_Module.LeftMotor.OverVoltage := FALSE;
	            #FLT.DownStream_Module.LeftMotor.LowVoltage := FALSE;
	            #FLT.DownStream_Module.RightMotor.Overheat := FALSE;
	            #FLT.DownStream_Module.RightMotor.MaxTorque := FALSE;
	            #FLT.DownStream_Module.RightMotor.Short := FALSE;
	            #FLT.DownStream_Module.RightMotor.NotConn := FALSE;
	            #FLT.DownStream_Module.RightMotor.Overload := FALSE;
	            #FLT.DownStream_Module.RightMotor.Stalled := FALSE;
	            #FLT.DownStream_Module.RightMotor.BadHall := FALSE;
	            #FLT.DownStream_Module.RightMotor.AnyErr := FALSE;
	            #FLT.DownStream_Module.RightMotor.OverVoltage := FALSE;
	            #FLT.DownStream_Module.RightMotor.LowVoltage := FALSE;
	            #FLT.DownStream_Module.LeftSensor.LowGain := FALSE;
	            #FLT.DownStream_Module.RightSensor.LowGain := FALSE;
	            
	            #FLT.GeneralFaults.GeneralMotorError := FALSE;
	            #FLT.GeneralFaults.GeneralSensorError := FALSE;
	            #FLT.GeneralFaults.GeneralNetworkError := FALSE;
	            //  #FLT.GeneralFaults.GeneralJamError := FALSE;
	            
	            #iqUDT_ConveyorInterface.InternalErrorPEC := FALSE;
	            #iqUDT_ZPAinterface.ConveyorInterface.InternalErrorPEC := FALSE;
	            
	        END_IF;
	        
	    END_REGION
	END_REGION
	
	
	REGION 4 HandShake 
	    IF #iqUDT_EquipmentControl.Report.Running THEN
	        REGION 4.1 Forward direction
	            IF #sa_Status.ZPA_Section.InForward THEN
	                
	                
	                REGION 4.1.2 Request received from upstream conveyor
	                    // if module is sleeping empty and upstream is requesting to send then wake up module
	                    IF #iUDT_AixInputsModuleUpstream.LocalUpstreamZoneStatus_Fwd = 16#01 AND NOT #iqUDT_HandShakeUp.RTS THEN
	                        
	                        #qUDT_AixOutputsModuleUpstream.SetInductStatus := #cw_ZoneToWakeUpToAccept;
	                    ELSE
	                        #qUDT_AixOutputsModuleUpstream.SetInductStatus := #cw_ZoneToStopWakeUp;
	                    END_IF;
	                END_REGION ;
	                
	                
	                REGION 4.1.1 RTR ready to receive
	                    // If module is running empty waiting for parcel and no jams are present then send RTR
	                    IF #iUDT_AixInputsModuleUpstream.LocalUpstreamZoneStatus_Fwd = 16#02
	                        AND NOT #sa_Status.UpStream_Module.UpstreamZone.JamDetected
	                        AND NOT #sa_Status.UpStream_Module.DownstreamZone.JamDetected
	                    THEN
	                        #iqUDT_HandShakeUp.RTR := TRUE;
	                    ELSE
	                        #iqUDT_HandShakeUp.RTR := FALSE;
	                    END_IF;
	                END_REGION
	                
	                
	                REGION 4.1.2 Box transfer from PLC to ZPA conveyor
	                    
	                    // When parcel left PLC controlled conveyor and there was GIN in handshake the write it into buffer and set flag
	                    IF #sR_TRIG_UpstreamHandshakeRTS.Q AND #iqUDT_HandShakeUp.GIN <> 0 THEN
	                        
	                        #qUDT_AixOutputsModuleUpstream.InductTrackingOnUpstreamZone := INT_TO_DWORD(#iqUDT_HandShakeUp.GIN);
	                        #sx_GinWrote := TRUE;
	                    END_IF;
	                    
	                    //If there was GIN in handshake and parcel reaches Upstream zone PEC then accept tracking data
	                    IF #sx_GinWrote AND #sR_Trig_ix_PECUpstreamBoS.Q THEN
	                        
	                        #qUDT_AixOutputsModuleUpstream.SetReleaseCountUpstream += 1;  // No protection needed, works after overshoot
	                        #sx_GinWrote := FALSE;
	                        
	                    END_IF;
	                    
	                    // Reset handshake data after TIP ends
	                    IF #sF_TRIG_UpstreamHandshakeTIP.Q THEN
	                        #iqUDT_HandShakeUp.NrOfPosToShift := 0;
	                    END_IF;
	                END_REGION
	                
	                
	                REGION 4.1.4 Send RTS and copy tracking data into buffer when parcel arrives at PEC
	                    IF #sR_Trig_ix_PECDownStreamEoS.Q THEN  // what if jam happens, RTS falls down, but product stays on pec the whole time? needs better condition
	                        #iqUDT_ZPAinterface.Handshake.RTS := TRUE; // is being set to true, but goes to false into the same cycle when rtr present
	                        #si_GinBuffer := DWORD_TO_INT(#iUDT_AixInputsModuleDownstream.TrackingDownstreamZone);
	                    END_IF;
	                END_REGION
	                
	                
	                REGION 4.1.5 Start transfer on RTR and RTS
	                    // Release parcel if RTR is present
	                    
	                    IF #iqUDT_ZPAinterface.Handshake.RTR AND #iqUDT_ZPAinterface.Handshake.RTS AND NOT #iqUDT_ZPAinterface.Handshake.TIP AND #sx_DownstreamZoneOccupied THEN
	                        
	                        #qUDT_AixOutputsModuleDownstream.SetDishargeStatus := #cw_AllowRelease;
	                        #iqUDT_ZPAinterface.Handshake.TIP := TRUE;
	                        #iqUDT_ZPAinterface.Handshake.RTS := FALSE;
	                        
	                    END_IF;
	                END_REGION
	                
	                REGION 4.1.6 Write Gin into handshake when parcel leaves zone
	                    IF #si_GinBuffer <> 0 AND #sF_Trig_ix_PECDownStreamEoS.Q THEN
	                        #iqUDT_ZPAinterface.Handshake.GIN := #si_GinBuffer;
	                        #si_GinBuffer := 0;
	                    END_IF;
	                END_REGION
	                
	                REGION 4.1.7 Box arrives on downstream conveyor and TIP ends
	                    IF #iqUDT_ZPAinterface.Handshake.TIP AND #sF_TRIG_DownstreamPlcPEC.Q
	                    THEN
	                        #iqUDT_ZPAinterface.Handshake.GIN := 0;
	                        #iqUDT_ZPAinterface.Handshake.TIP := FALSE;
	                        #qUDT_AixOutputsModuleDownstream.SetDishargeStatus := #cw_LaneFull;
	                    END_IF;
	                END_REGION
	                
	            END_IF;
	        END_REGION
	    ELSE
	        #iqUDT_HandShakeUp.RTR := FALSE;
	    END_IF;
	END_REGION
	
	(* //         REGION 4.2 Reverse direction
	//             IF #sa_Status.ZPA_Section.InForward THEN
	//                 REGION 4.2.1 RTR ready to receive
	//                     #iqUDT_HandShake.RTR :=
	//                     #sa_Status.DownStream_Module.DepartureCount = #sa_Status.DownStream_Module.ArrivalCount AND
	//                     NOT (
	//                     #sa_Status.DownStream_Module.UpstreamZone.JamDetected OR
	//                     #sa_Status.DownStream_Module.DownstreamZone.JamDetected
	//                     );
	//                 END_REGION
	//                 REGION 4.2.2 RTS recieved from upstream conveyor
	//                     // if module is RTR and Downstream is requesting to send then wake up module
	//                     IF #iqUDT_HandShake.RTR // AND
	//                        // #iqUDT_HandShakeup.RTS
	//                     THEN
	//                         #qUDT_AixOutputsModuleDownstream.SetInductStatus := #cw_ZoneToRunToAccept;
	//                         #iqUDT_HandShake.TIP := TRUE;
	//                     END_IF;
	//                 END_REGION
	//                 REGION 4.2.3 box Exit Upstream zone
	                    
	//                     IF #iqUDT_HandShake.TIP AND
	//                         #sR_Trig_ix_PECDownStreamBoS.Q        // PEC EoS is TRUE if clear
	//                     THEN
	//                         #iqUDT_HandShake.RTR := FALSE;
	//                         #qUDT_AixOutputsModuleDownstream.InductTrackingOnUpstreamZone := INT_TO_DWORD(#iqUDT_HandShakeUp.GIN);
	//                         #qUDT_AixOutputsModuleDownstream.SetInductStatus := #cw_ZoneToAcceptTheTrackingData;
	//                     END_IF;
	//                 END_REGION
	//                 REGION 4.2.4 Send RTS
	//                     IF #sa_Status.UpStream_Module.ArrivalCount > #sa_Status.UpStream_Module.DepartureCount THEN
	//                         #iqUDT_HandShakeUp.RTS := TRUE;
	//                     END_IF;
	//                 END_REGION
	//                 REGION 4.2.5 Start transfer on RTR and RTS
	                    
	//                     IF #iqUDT_HandShakeUp.RTR AND #iqUDT_HandShakeUp.RTS
	//                     THEN
	//                         #qUDT_AixOutputsModuleUpstream.SetDishargeStatus := #cw_AllowRelease;
	//                         #iqUDT_HandShakeUp.TIP := TRUE;
	//                         #iqUDT_HandShakeUp.RTS := FALSE;
	//                     END_IF;
	//                 END_REGION
	//                 REGION 4.2.6 Box arrives on downstream conveyor and TIP ends
	//                     IF #iqUDT_HandShakeUp.TIP AND #sF_Trig_ix_PECUpstreamBoS.Q
	//                     THEN
	//                         #iqUDT_HandShakeUp.TIP := FALSE;
	//                         #qUDT_AixOutputsModuleUpstream.SetDishargeStatus := #cw_LaneFull;
	//                     END_IF;
	//                 END_REGION
	//             END_IF;
	//         END_REGION
	//     END_IF; *)  //reverse direction if needed needs to be rewritten
	
	REGION 5 Actual speed
	    //#si_ActualSpeed := REAL_TO_INT(INT_TO_REAL(WORD_TO_INT(#iUDT_AixInputsModule.RightMotorActualSpeed & #cw_ActualSpeedMask)) * #iUDT_AixConfig.Motor.Ratio);
	    
	END_REGION
	
	REGION 5 Populate qUDT_Status
	    #qUDT_CommonStatus := #iqUDT_EquipmentControl.Report;
	    #iqUDT_ZPAinterface.CommonStatus := #iqUDT_EquipmentControl.Report;
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION "FC_CopyTrackingArray" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 15
// END_ATTRIBUTES
   VAR_INPUT 
      Ix_ConveyorToGlobal : Bool;   // True when data to be moved to global array; FALSE when data to be moved to conveyor array
      ix_FirstConveyor : Bool;   // True when it is first conveyor to global tracking array
      ii_StartPosition : Int;
      ii_Displacement : Int;
      ii_ConveyorLength : DInt;
   END_VAR

   VAR_IN_OUT 
      iqs_ConveyorArray : Array[*] of Int;   // Tracking array
      iqs_GlobalArray : Array[*] of Int;   // Tracking array
      iqUDT_EmptyWindow : "UDT_EmptyWindow";
   END_VAR

   VAR_TEMP 
      ti_LoopCounter : Int;
      ti_EmptyWindowArrayLength : Int;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2019             MHS                                                     |
	|  All Rights Rese9ved         Larenweg 90                                             |
	|                              5234 KC 's-Hertogenbosch,                               |
	|                              Netherlands                                             |
	|                                                                                      |     
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	 29/08/2023 | 3.0       | S. Deulkar    | first release MHS TIA 17
	 13/03/2024 | 4.1       | S. Nieswiec   | first release TIA 18
	*)
	
	REGION 1 - Copy data from conveyor array to global array
	    
	    IF #Ix_ConveyorToGlobal
	    THEN
	        MOVE_BLK(IN := #iqs_ConveyorArray[0],
	                 COUNT := DINT_TO_ULINT(#ii_ConveyorLength / 10),
	                 OUT => #iqs_GlobalArray[#ii_StartPosition]);
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Copy data from global array to conveyor array
	    
	    IF NOT #Ix_ConveyorToGlobal
	    THEN
	        MOVE_BLK(IN := #iqs_GlobalArray[#ii_StartPosition],
	                 COUNT := DINT_TO_ULINT(#ii_ConveyorLength / 10),
	                 OUT => #iqs_ConveyorArray[0]);
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Update empty window position
	    
	    IF #Ix_ConveyorToGlobal
	    THEN
	        #ti_EmptyWindowArrayLength := "FC_GetNrOfArrayEl"(#iqUDT_EmptyWindow.EmptyWIndowPosition);
	        
	        // Update window position with displacement of the conveyor
	        IF (#iqUDT_EmptyWindow.No_Of_Empty_Window > 0)
	            AND (#ii_Displacement > 0)
	        THEN
	            
	            FOR #ti_LoopCounter := 1 TO #iqUDT_EmptyWindow.No_Of_Empty_Window DO
	                
	                IF ((#iqUDT_EmptyWindow.EmptyWIndowPosition[#ti_LoopCounter] >= #ii_StartPosition)
	                    AND (#iqUDT_EmptyWindow.EmptyWIndowPosition[#ti_LoopCounter] <= (#ii_StartPosition + (#ii_ConveyorLength / 10))))
	                    
	                THEN
	                    #iqUDT_EmptyWindow.EmptyWIndowPosition[#ti_LoopCounter] -= #ii_Displacement;
	                END_IF;
	                
	            END_FOR;
	            
	        END_IF;
	        
	    END_IF;
	    
	    // IF #ix_FirstConveyor
	    // THEN
	    
	    //     FOR #ti_LoopCounter := #ii_StartPosition TO #ii_StartPosition + #ii_ConveyorLength DO
	    
	    //         IF #iqs_GlobalArray[#ti_LoopCounter] = -100
	    //             AND (#iq_UDT_EmptyWindow.No_Of_Empty_Window + 1) <= #ti_EmptyWindowArrayLength
	    //         THEN
	    //             #iq_UDT_EmptyWindow.No_Of_Empty_Window += 1;
	    //             #iq_UDT_EmptyWindow.EmptyWIndowPosition[#iq_UDT_EmptyWindow.No_Of_Empty_Window + 1] := #ti_LoopCounter;
	    //         END_IF;
	    
	    //     END_FOR;
	    
	    //     // Remove unused empty window from arrat when it pass last induct position           
	    //     IF #iq_UDT_EmptyWindow.No_Of_Empty_Window > 0
	    //         AND #iq_UDT_EmptyWindow.EmptyWIndowPosition[1] <= 10
	    //     THEN
	    //         // //Remove used emty window from array
	    //         MOVE_BLK(IN := #iq_UDT_EmptyWindow.EmptyWIndowPosition[2],
	    //                  COUNT := INT_TO_ULINT(#ti_EmptyWindowArrayLength - 1),
	    //                  OUT => #iq_UDT_EmptyWindow.EmptyWIndowPosition[1]);
	    //         #iq_UDT_EmptyWindow.No_Of_Empty_Window -= 1;
	    //     END_IF;
	    
	    // END_IF;
	    
	END_REGION
	
END_FUNCTION

