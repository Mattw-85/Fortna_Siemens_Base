TYPE "UDT_FifoHeader"
TITLE = UDT_FifoHeader
VERSION : 0.1
//User-defined structure of FIFO register header information.
   STRUCT
      Status : Struct   // Status bits
         Empty { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO Empty
         Prefull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO Prefull
         Full { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO Full
      END_STRUCT;
      NextEntryToRead : Int;   // Next FIFO entry to read
      NextEntryToWrite : Int;   // Next FIFO entry to write
      MaxNrOfEntries : Int;   // Maximum number of FIFO entries
      TotalEntriesStored : Int;   // Total number of FIFO entries
   END_STRUCT;

END_TYPE

TYPE "UDT_GINWES"
VERSION : 0.1
   STRUCT
      Barcode : String[40];
   END_STRUCT;

END_TYPE

TYPE "UDT_GINWCS"
VERSION : 0.1
   STRUCT
      ActionTaken : String;   // Location code value that describes the actual disposition of the package
      Destination1 : String[20];   // Location code value that describes where the package should go (Diverter Number)
      Destination2 : String[20];   // Location code value that describes where the package should go (Diverter Number)
      Destination3 : String[20];   // Location code value that describes where the package should go (Diverter Number)
      Destination4 : String[20];   // Location code value that describes where the package should go (Diverter Number)
      Destination5 : String[20];   // Location code value that describes where the package should go (Diverter Number)
      ReasonCode : String[2];   // Management Code value that describes the result of attempting to route the package to the Destination
      Barcode1 : String;   // Barcode identifier code
      Barcode2 : String;
      Barcode3 : String;
      Barcode4 : String;
   END_STRUCT;

END_TYPE

TYPE "UDT_GINDHL"
VERSION : 0.1
   STRUCT
      ObjectID : String[10];   // Object ID
      VID : String[16];   // Virtual Item Identifier (VID)
      PieceID : String[40];   // Piece ID barcodes
      SortStrategy : String[1];   // Sort Strategy 1 - Highest priority available , 2 - Nearest
      ParcelReject { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Parcel reject
      Destination : Array[1..6] of Struct   // Destination
         ID : UInt;   // ID
         SortCommandActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sort command
         ParcelSorted { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parcel sorted
         Rejected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parcel rejected
         Reason : Int;   // Reason
      END_STRUCT;
      ParcelLocation : Struct   // Parcel Location
         Current : UInt;   // Current
         Last : UInt;   // Last
         Sort : UInt;   // Sort
      END_STRUCT;
      MFCMessage : Struct   // MFC Sort messages
         Sent : Struct   // Messages sent from the PLC to the MFC system
            SortResult { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Sort Result
            VIDResponse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message VID Response
            ScanReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Scan Reset
            XrayResult { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Xray result
            ParcelRegInfo { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Xray registration info
         END_STRUCT;
         Received : Struct   // Messages received from the MFC system to the PLC
            RejectParcel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Reject Parcel
            Destination { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Destination
            DestinationResent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Destination Resent
            TemporaryParcelIdentifier { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Temporary Parcel Identifier
            XrayRegistrationInfo { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         END_STRUCT;
      END_STRUCT;
      Xray : Struct   // Xray data structure
         RoutingCode : String[2];   // Routing code
         Group : String[1];   // The group field is used to identify the group of the operator decisions came from in a
         Level : String[1];   // Level field is used to identify which level the operator decision came from in a
         Result : String[1];   // Results can be indicated with the following:A = Accept, R = Reject, U = Unavailable (Timeout), Z = High Threat
         BagIDMessage : Struct   // Message from PLC to Xray
            MessagePrepared { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message is prepared and ready to send
            WrongMessageStructure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message has wrong structure
            Sent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message sent by PLC to Xray
            SentTime : String;   // Time when message sent by PLC to Xray
            NotSent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message was not sent from the PLC
            Received { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message received by Xray
            TimeReceived : String;   // Time when message received by Xray
            NotReceived { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message did not reach Xray
         END_STRUCT;
         DecisionMessage : Struct   // Message from Xray to PLC
            Received { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message received by PLC
            ReceivedTime : String;   // The message received by PLC
            NotReceivedOnTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message did not reach PLC
         END_STRUCT;
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_GINFedEx"
VERSION : 0.1
   STRUCT
      Timestamp : String[17];   // Local time timestamp
      TimeZoneDesignator : String[5];   // Time zone designator
      PackageEntrancePoint : String[14];   // Entrance point, where LLC starts tracking the parcel.
      PackageEntranceState : String[1];   // Entrance state
      PackageExitPoint : String[14];   // Exit point name, where LLC reports the last known tracking point.
      PackageExitState : String[1];   // Exit point state when LLC reports the last known tracking point.
      PalletType : String[2];   // Pallet code for different type of pallets on the market
      Mask : String[1];   // Flag to indicate that a pallet has been mask.
      CellNumber : String[4];   // Tray/Cell number (for loop sorters) or generated by LLC (on line sorters).
      CellsOccupied : String[1];   // Cells occupied by the piece for loop sorters.
      ImageID : String[6];   // Image ID number created by the ADC system.
      ScanUnitType : String[1];   // Scan unit type
      ADCSystemID : String[15];   // Number assigned by the ADC system
      PackageID : String[15];   // Number assigned by the LLC system
      LLCSystemID : String[15];
      HLCPackageID : String[10];   // Unique number for the specific package during it stays in HLC system.
      HLCResultCode : String[16];   // Result code based on processing of the scan event messages.
      ShipmentID : String[6];   // Consignment id of the parcel.
      WeightStatus : String[1];   // Status to indicate if the parcel/pallet has weight on the system.
      ActualDestination : String[6];   // Location code value that describes the actual disposition of the package.
      Destination1 : String[6];   // Location code value that describes where the package should go (Diverter Number).
      Destination2 : String[6];   // Location code value that describes where the package should go (Diverter Number).
      Destination3 : String[6];   // Location code value that describes where the package should go (Diverter Number).
      Destination4 : String[6];   // Location code value that describes where the package should go (Diverter Number).
      Destination5 : String[6];   // Location code value that describes where the package should go (Diverter Number).
      CutOffTimeDestination1 : String[5];   // Cut Off Time in Local Time.
      CutOffTimeDestination2 : String[5];   // Cut Off Time in Local Time.
      CutOffTimeDestination3 : String[5];   // Cut Off Time in Local Time.
      CutOffTimeDestination4 : String[5];   // Cut Off Time in Local Time.
      CutOffTimeDestination5 : String[5];   // Cut Off Time in Local Time.
      ReasonCode1 : String[8];   // Management Code value that describes the result of attempting to route the package to the Destination
      ReasonCode2 : String[8];   // Management Code value that describes the result of attempting to route the package to the Destination
      ReasonCode3 : String[8];   // Management Code value that describes the result of attempting to route the package to the Destination
      ReasonCode4 : String[8];   // Management Code value that describes the result of attempting to route the package to the Destination
      ReasonCode5 : String[8];   // Management Code value that describes the result of attempting to route the package to the Destination
      HLCDataText : String[20];   // Free text for future use.
      Customs : String[1];   // Need to be checked by customs
      DIMSystemID : String[15];   // Identifier of dimensioning system.
      DIMStatus : String[5];   // Basic diagnostic information from the dimensioning system at the moment of the measurement.
      PackageDimLength : String[6];   // Length dimension of package in resolution of dim system.
      PackageDimWidth : String[6];   // Width dimension of package in resolution of dim system.
      PackageDimHeight : String[6];   // Height dimension of package in resolution of dim system.
      DIMUOM : String[2];   // Unit of measure of the package dimensions.
      DimLFTstatusCode : String[8];   // Dimension LFT status code.
      DimConfidence : String[2];   // The level of assurance for the correct dimensions.
      DimensionSource : String[1];   // For combined camera/laser dim acquisition devices. It indicates type of capturing mode
      AlibiDims : String[25];   // Alibi for Dimensions
      SCLSystemID : String[15];   // Identifier of weight scale.
      SCLStatus : String[5];   // Basic diagnostic information from the weight scale system.
      SCLWT : String[6];   // Scale weight of package in resolution of scale system.
      SCLWTUOM : String[2];   // Unit of measurement for Weight
      SCLLFTStatusCode : String[2];   // Scale LFT status code.
      AlibiWeight : String[25];   // Alibi for Weight
      ReasonCode : String[1];   // This code should be used when the SI message has some defect.
      Stackable : String[1];   // If stackable recognition is enabled, Y or N
      Stickerstype : String[2];   // When optical recognition is used to sort
      FlyingDocument : String[1];   // Status to confirm if the document/flyer is prone to fly off the sorter.
      ModeofOperation : String[1];   // Camera Tunnel operational mode format:
      CameraHeadstatus : String[2];   // Diagnostic information on camera/laser heads performing barcode reads.
      PackageDataTruncated : String[1];   // Y = Full length of barcode data exceeds 9999 bytes, data truncated
      TotalBarcodeDataLength : String[4];   // Length of all barcode data that was sent in bytes;
      Barcode1Identification : String[3];   // Barcode identifier code.
      Barcode1status : String[2];   // Barcode confidence factor
      Barcode1datalength : String[4];   // String length of barcode data in bytes; inclusive of this field. Use 0054 as a fixed value
      Barcode1data : String[50];   // Highest priority barcode
      Barcode2Identification : String[3];   // Barcode identifier code.
      Barcode2status : String[2];   // Barcode confidence factor
      Barcode2datalength : String[4];   // String length of barcode data in bytes; inclusive of this field. Use 0054 as a fixed value
      Barcode2data : String[50];   // Highest priority barcode
      Barcode3Identification : String[3];   // Barcode identifier code.
      Barcode3status : String[2];   // Barcode confidence factor
      Barcode3datalength : String[4];   // String length of barcode data in bytes; inclusive of this field. Use 0054 as a fixed value
      Barcode3data : String[50];   // Highest priority barcode
      BarcodeIdentification : String[3];   // Barcode identifier code.
      Barcodestatus : String[2];   // Barcode confidence factor
      Barcodedatalength : String[4];   // String length of barcode data in bytes
      Barcodedata : String[50];   // Sortation barcode
      CustomerID : DInt;   // 6 digits SequentialID (NNNNNN)
      AreaNumber : String[2];   // Package Sequence ID "Area Number"
      PurgeEnabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Purge enabled for parcel: destination overwritten with Purge destination
   END_STRUCT;

END_TYPE

TYPE "UDT_GINStandard"
VERSION : 0.1
   STRUCT
      Destination : Array[0..20] of DInt;   // Destination
      Identification : Struct   // Barcode identification
         GoodRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Barcode read was succesful
         NoRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Barcode read was unsuccesful
         MultiRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Multiple Barcodes were detected
         Barcode : Array[0..10] of Char;   // Barcode values
      END_STRUCT;
      GinAssigned { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // GIN is assigned to package
      Lost { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Lost in tracking
      Length : Int;   // Length in mm
      Width : Int;   // Width in mm
      Height : Int;   // Height in mm
      Weight : DInt;   // Weight in g
      PkgTooLong { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is too long
      PkgTooSmall { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is too small
      PkgTooHigh { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is too high
      PkgOverWeight { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is over weight
      TrailingGap : Int;   // Trailing gap size in cm between the package
      LeadingGap : Int;   // Leading gap size in cm between the package
      NrOfRecirculations : Int;   // Number of recirculations
      DestReqSend { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Destination request sent to high level
      DestRcv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Destination received from high level
      SortStatus : Struct   // Sort status of the package
         DivertDestination : Int;   // Destination to which the package is diverted
         GoodDivert { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package diverted
         FailedDivert { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package failed to divert
         NoDivert : Bool := TRUE;   // Divert is not activated
         NoDivertCause : Struct   // Cause for no divert
            ChuteJam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Chute is jammed
            ChuteFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Chute is full
            NoRTR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Downstream conveyor is not ready to receive
            DestDisabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Destination is disabled
            TrayDisabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Tray is disabled
            SorterNotAtSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sorter is not at speed
            LeadingGapError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Gap size with downstream parcel is not enough
            TrailingGapError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Gap size with upstream parcel is not enough
            PkgTooHigh { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is too high to divert
            PkgTooLong { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is too long to divert
            DestNotReachable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sort destionation is not reachable
            InvalidDest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sort destination is invalid
            DestTooLate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Destination too late
            NoDestRcv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Destination not received from high level
         END_STRUCT;
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_GINUPS"
VERSION : 0.1
   STRUCT
      TRKNUM : String[18];   // Tracking number
      PKGUID : String[32];   // Package ID
      MSGID : String[32];   // Message ID
      Length : Int;   // Camera Length in mm
      Width : Int;   // Camera Width in mm
      Height : Int;   // Camera Height in mm
      Weight : DInt;   // Weight in g
      IDCreated { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 1, Bit 0 - PLCID created or TrayID Read
      DimDataRcv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 1, Bit 1 - Package Dimensional Data Received via Camera Scan Data Message
      PkgWrongInduct { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 1, Bit 2 - Package Did NOT Induct Properly (Non-Tray Systems)
      IDCalcFromCamID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 2, Bit 0 - PLCID/TrayID Calculated From CamID
      UnknownParcelID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 2, Bit 4 - Unknown Parcel ID
      UndefinedProblem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 2, Bit 5 - Un-Defined Problem
      UnrecognizedCmd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 2, Bit 6 - Un-recognized command
      SorterInMainteneceMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 2, Bit 7 - Sorter in Maintenance/Commissioning Mode
      DestUserSusp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 3, Bit 3 - Destination User Suspended
      SorterNotSynch { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 3, Bit 6 - Sorter NOT Synchronized (Tilt Tray Systems)
      PkgDetAtVerCheckPoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 4, Bit 0 - Package Detected at Verification Check Point
      ChuteFullAftrAlterDest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 4, Bit 7 - Preferred chute full after passed alternate destination
      ChuteNotAvailAfterAlterDest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 5, Bit 0 - Preferred chute not available after passed alternate destination
      PLCRedirected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 5, Bit 2 - PLC Redirected
      ThreatParcel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Threat parcel
   END_STRUCT;

END_TYPE

FUNCTION "FC_GetNrOfArrayEl" : Int
TITLE = FC_GetNrOfArrayEl
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 19
// END_ATTRIBUTES
//Function to get the number of array elements.
   VAR_INPUT 
      iv_Array : Variant;   // Input array
   END_VAR

   VAR_TEMP 
      ti_NrOfArrayEl : Int;   // Number of array elements
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	27/08/2019  | 2.1       | K.Pokorski    | Comments adjusted
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – Number of an array elements
	    
	    IF IS_ARRAY(#iv_Array)                                                  // Input variable is an array
	    THEN
	        
	        #ti_NrOfArrayEl := UDINT_TO_INT(CountOfElements(#iv_Array));
	        
	        // Reset array length if the input variable isn't an array
	    ELSE
	        
	        #ti_NrOfArrayEl := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 – Return output
	    
	    #FC_GetNrOfArrayEl := #ti_NrOfArrayEl;
	    
	END_REGION
	
END_FUNCTION

TYPE "UDT_FifoStatus"
TITLE = UDT_FifoStatus
VERSION : 0.1
//
//User-defined structure of FC_Fifo function status.
//Version History:
//Date              | Version   | Author         | Remark
//24/05/2019  | 0.1           | K.Pokorski   | first release MHSE TIA 15.1
//24/05/2019  | 0.2           | K.Pokorski   | first release MHSE TIA 15.1
//
   STRUCT
      InvalidMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid mode selected
      InvalidMaxNrOfEntries { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid maximum number of entries or buffer is not an array
      InvalidTotalEntriesStored { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid total number of entries
      InvalidNextEntryToWrite { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid number of next entry to write
      InvalidNextEntryToRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid number of next entry to read
      InvalidDataType { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message and buffer element data type inconsistent
      FifoPreFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 90 % of FIFO data buffer capacity reached
      FifoFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO data buffer full
   END_STRUCT;

END_TYPE

TYPE "UDT_MFCSortMessageHeader"
VERSION : 0.1
   STRUCT
      SOM : Byte := 16#FD;   // Start of message
      SourceNode : Byte;   // Source node ID
      DestinationNode : Byte;   // Destination node ID
      SeqNumber : Byte;   // Sequence number
      DataLength : Word;   // Data segment length (bytes)
      NumMsg : Word;   // Number of messages contained in the Data Segment
   END_STRUCT;

END_TYPE

TYPE "UDT_MFCParcelDestination"
VERSION : 0.1
   STRUCT
      ObjectID : String[10];   // Object ID
      SortStrategy : String[1];   // Sort Strategy 1 - Highest priority available , 2 - Nearest
      Destination_1 : UInt;   // Destination
      Destination_2 : UInt;   // Destination
      Destination_3 : UInt;   // Destination
      Destination_4 : UInt;   // Destination
      Destination_5 : UInt;   // Destination
      Destination_6 : UInt;   // Destination
   END_STRUCT;

END_TYPE

TYPE "UDT_MessageV2"
TITLE = UDT_Message
VERSION : 0.1
//User-defined structure of the message characters array.
   STRUCT
      Bytes : Array[0..499] of Byte;   // Message byte
   END_STRUCT;

END_TYPE

TYPE "UDT_GIN"
VERSION : 0.1
   STRUCT
      General { S7_SetPoint := 'False'} : "UDT_GINStandard";
      FedEx { S7_SetPoint := 'False'} : "UDT_GINFedEx";
      UPS { S7_SetPoint := 'False'} : "UDT_GINUPS";
      DHL { S7_SetPoint := 'False'} : "UDT_GINDHL";
      WCS { S7_SetPoint := 'False'} : "UDT_GINWCS";
      WES { S7_SetPoint := 'False'} : "UDT_GINWES";
   END_STRUCT;

END_TYPE

DATA_BLOCK "DB_Memory"
TITLE = DB_Memory
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
VERSION : 3.0
NON_RETAIN
   VAR 
      ClockByte { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // System clock byte
      Clock_10Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 10 Hz system clock bit
      Clock_5Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 5 Hz system clock bit
      "Clock_2.5Hz" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 2.5 Hz system clock bit
      Clock_2Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 2 Hz system clock bit
      "Clock_1.25Hz" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1.25 Hz system clock bit
      Clock_1Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 Hz system clock bit
      "Clock_0.625Hz" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0.625 Hz system clock bit
      "Clock_0.5Hz" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0.5 Hz system clock bit
      SystemByte { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // System byte
      OSClockByte { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // One shot of clock pulse
      "OS_0.1sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 0.1 sec
      "OS_0.2sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 0.2 sec
      "OS_0.4sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 0.4 sec
      "OS_0.5sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 0.5 sec
      "OS_0.8sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 0.8 sec
      OS_1sec { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 1 sec
      "OS_1.6sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 1.6 sec
      OS_2sec { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 2 sec
      PrevCycleTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Previous PLC cycle Time
      RuntimeMem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Runtime memory
      FirstScan { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // First scan bit
      DiagStatusUpdate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Diagnostic status update
      AlwaysTrue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Always True bit
      AlwaysFalse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Always False bit
      CommissioningFalse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Commissioning always false
      CommissioningTrue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Commissioning always true
      ReconnectCommand { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reconnect command
      ScanMainRack { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Trigger to check main rack confiuration
      ScanProfinet { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Scan profinet bit
      Simulation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Simulation
      PN1OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet ok
      "Local~PROFINET_IO-System" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IO System
      "Local~PROFINET_IO-System_1" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 1
      "Local~PROFINET_IO-System_2" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 2
      "Local~PROFINET_IO-System_3" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 3
      "Local~PROFINET_IO-System_4" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 4
      "Local~PROFINET_IO-System_5" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 5
      "Local~PROFINET_IO-System_6" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 6
      "Local~PROFINET_IO-System_7" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 7
      "Local~PROFINET_IO-System_8" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 8
      "Local~PROFINET_IO-System_9" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 9
   END_VAR


BEGIN

END_DATA_BLOCK

FUNCTION "FC_Fifo" : Void
TITLE = FC_Fifo
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 17
// END_ATTRIBUTES
//Function for controlling FIFO register.
   VAR_INPUT 
      ic_Mode : Char;   // Mode selector: "W" - Write; "R" - Read; "C" - Clear (Reset) "S" - Status
   END_VAR

   VAR_OUTPUT 
      qUDT_Status : "UDT_FifoStatus";   // FIFO status structure
      qx_Error : Bool;   // Collective error output
      qx_Warning : Bool;   // Collective warning output
   END_VAR

   VAR_IN_OUT 
      iqv_Data : Variant;   // Data
      iqUDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqv_DataBuffer : Variant;   // FIFO data buffer
   END_VAR

   VAR_TEMP 
      tUDT_Status : "UDT_FifoStatus";   // Status structure
      ti_MoveBLKErrorCode : Int;   // Move_BLK_Variant function return
      tx_HeaderValid : Bool;   // Header valid
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	14/06/2019  | 0.2       | A.Nowak       | Replacement of instruction if for direct write into variable - Region 3 , 4.1 , 4.2 , 4.3 , 4.4 , 8.1  , 8.2 
	17/07/2019  | 0.3       | L.Klar        | Status handling changed
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	23/08/2019  | 2.1       | K.Pokorski    | Comments corrected
	27/08/2019  | 2.2       | M.Kurpiers    | Comments adjusted
	27/09/2019  | 2.3       | K.Pokorski    | Variant input included
	01/10/2019  | 2.4       | A.Nowak       | Correct comments and rename regions
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – Diagnostic bits initialization
	    
	    // Clear FIFO statuses
	    #tUDT_Status.FifoFull := FALSE;
	    #tUDT_Status.FifoPreFull := FALSE;
	    
	END_REGION
	
	REGION 2 – Array's information
	    
	    // If buffer elements type is invalid, set the error 
	    #tUDT_Status.InvalidDataType := NOT (TypeOf(#iqv_Data) = TypeOfElements(#iqv_DataBuffer));
	    
	END_REGION
	
	REGION 3 – Mode validation
	    
	    // Set the mode invalid if selected mode isn't one of the following: W- Write, R - Read, C - Clear, S - Status
	    #tUDT_Status.InvalidMode := #ic_Mode <> 'W'
	    AND #ic_Mode <> 'R'
	    AND #ic_Mode <> 'C'
	    AND #ic_Mode <> 'S';
	    
	END_REGION
	
	REGION 4 – The header settings checking
	    
	    // The correct mode has been selected and data type is valid
	    IF (NOT #tUDT_Status.InvalidMode
	        AND NOT #tUDT_Status.InvalidDataType)
	    THEN
	        
	        REGION 4.1 – The number of maximum FIFO entries validation 
	            
	            // Write the number of array's elements to FIFO header
	            #iqUDT_FifoHeader.MaxNrOfEntries := "FC_GetNrOfArrayEl"(#iqv_DataBuffer);
	            
	            // Set the invalid maximum number of entries error 
	            #tUDT_Status.InvalidMaxNrOfEntries := #iqUDT_FifoHeader.MaxNrOfEntries <= 0;
	            
	        END_REGION
	        
	        REGION 4.2 – The number of total FIFO entries validation
	            
	            // Set the invalid total number of entries error 
	            #tUDT_Status.InvalidTotalEntriesStored := #iqUDT_FifoHeader.TotalEntriesStored < 0        // The total number of entries is lower than 0
	            OR #iqUDT_FifoHeader.TotalEntriesStored > #iqUDT_FifoHeader.MaxNrOfEntries;               // The total number of entries is greater than the maximum number of entries
	            
	        END_REGION
	        
	        REGION 4.3 – The number of the next entry to write 
	            
	            // Set the invalid next entry to write
	            #tUDT_Status.InvalidNextEntryToWrite := #iqUDT_FifoHeader.NextEntryToWrite < 0            // The number of next entry to write is lower than 0  
	            OR #iqUDT_FifoHeader.NextEntryToWrite >= #iqUDT_FifoHeader.MaxNrOfEntries;                // The number of next entry to write is greater or equal to the maximum number of entries 
	            
	        END_REGION
	        
	        REGION 4.4 – The number of the next entry to read 
	            
	            // Set the invalid next entry to read
	            #tUDT_Status.InvalidNextEntryToRead := #iqUDT_FifoHeader.NextEntryToRead < 0              // The number of next entry to read is lower than 0 
	            OR #iqUDT_FifoHeader.NextEntryToRead >= #iqUDT_FifoHeader.MaxNrOfEntries;                 // The number of next entry to read is greater or equal to the maximum nr of entries 
	            
	        END_REGION
	        
	        REGION 4.5 – FIFO header validation summary
	            
	            // Create collective header error
	            #tx_HeaderValid := NOT #tUDT_Status.InvalidMaxNrOfEntries
	            AND NOT #tUDT_Status.InvalidTotalEntriesStored
	            AND NOT #tUDT_Status.InvalidNextEntryToWrite
	            AND NOT #tUDT_Status.InvalidNextEntryToRead;
	            
	        END_REGION
	        
	    END_IF;
	    
	END_REGION
	
	REGION 5 – Writing the data into the FIFO buffer
	    
	    IF (#ic_Mode = 'W'                                                                          // Write mode selected                                                               
	        AND #tx_HeaderValid                                                                     // FIFO header valid 
	        AND NOT #tUDT_Status.InvalidDataType)                                                  // Buffer data type valid
	    THEN
	        
	        
	        IF (#iqUDT_FifoHeader.TotalEntriesStored < #iqUDT_FifoHeader.MaxNrOfEntries)          // Checking total number of stored entries                
	        THEN
	            
	            // Move input data to FIFO data buffer  
	            #ti_MoveBLKErrorCode := MOVE_BLK_VARIANT(SRC := #iqv_Data,
	                                                     COUNT := 1,
	                                                     SRC_INDEX := 0,
	                                                     DEST_INDEX := #iqUDT_FifoHeader.NextEntryToWrite,
	                                                     DEST => #iqv_DataBuffer);
	            
	            // Increment the number of the next entry to write 
	            #iqUDT_FifoHeader.NextEntryToWrite += 1;
	            
	            // Increment the total number of stored entries 
	            #iqUDT_FifoHeader.TotalEntriesStored += 1;
	            
	            
	            IF (#iqUDT_FifoHeader.NextEntryToWrite >= #iqUDT_FifoHeader.MaxNrOfEntries)       // Check the number of the next entry to write                             
	            THEN
	                
	                #iqUDT_FifoHeader.NextEntryToWrite := 0;
	                
	            END_IF;
	            
	        ELSE
	            
	            #tUDT_Status.FifoFull := TRUE;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 6 – Reading the data from the FIFO data buffer
	    
	    IF (#ic_Mode = 'R'                                                                  // Read mode selected    
	        AND #tx_HeaderValid                                                             // FIFO header valid 
	        AND NOT #tUDT_Status.InvalidDataType)                                           // Buffer data type valid                                                
	    THEN
	        
	        IF (#iqUDT_FifoHeader.TotalEntriesStored > 0)                                   // Checking total number of stored entries                                                     
	        THEN
	            
	            // Move the FIFO data to the data output
	            #ti_MoveBLKErrorCode := MOVE_BLK_VARIANT(SRC := #iqv_DataBuffer,
	                                                     COUNT := 1,
	                                                     SRC_INDEX := #iqUDT_FifoHeader.NextEntryToRead,
	                                                     DEST_INDEX := 0,
	                                                     DEST => #iqv_Data);
	            
	            // Increment the number of the next entry to read
	            #iqUDT_FifoHeader.NextEntryToRead += 1;
	            
	            // Decrement the total number of stored entries
	            #iqUDT_FifoHeader.TotalEntriesStored -= 1;
	            
	            IF (#iqUDT_FifoHeader.NextEntryToRead >= #iqUDT_FifoHeader.MaxNrOfEntries)  // Check the number of the next entry to read                 
	            THEN
	                
	                #iqUDT_FifoHeader.NextEntryToRead := 0;
	                
	            END_IF;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 7 – Clearing the FIFO header
	    
	    IF (#ic_Mode = 'C'                      // Clear mode selected  
	        AND #tx_HeaderValid)                // FIFO header valid                         
	    THEN
	        
	        #iqUDT_FifoHeader.TotalEntriesStored := 0;
	        #iqUDT_FifoHeader.NextEntryToWrite := 0;
	        #iqUDT_FifoHeader.NextEntryToRead := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 8 – FIFO management status update
	    
	    IF (#tx_HeaderValid)                   // The header is valid                                     
	    THEN
	        
	        REGION 8.1 – FIFO Empty
	            
	            // Set the FIFO empty status bit
	            #iqUDT_FifoHeader.Status.Empty := #iqUDT_FifoHeader.TotalEntriesStored = 0;
	            
	        END_REGION
	        
	        REGION 8.2 – FIFO Full
	            
	            // Set the FIFO full status bit 
	            #iqUDT_FifoHeader.Status.Full := #iqUDT_FifoHeader.TotalEntriesStored = #iqUDT_FifoHeader.MaxNrOfEntries;
	            
	        END_REGION
	        
	        REGION 8.3 – FIFO Pre-full
	            
	            IF (#iqUDT_FifoHeader.TotalEntriesStored >= 0.9 * #iqUDT_FifoHeader.MaxNrOfEntries)       // Checking if the number of total stored entries is greater or equal to 90% of the max number of entries     
	            THEN
	                
	                // Set the FIFO pre-full status 
	                #iqUDT_FifoHeader.Status.Prefull := TRUE;
	                #tUDT_Status.FifoPreFull := TRUE;
	                
	            ELSE
	                
	                #iqUDT_FifoHeader.Status.Prefull := FALSE;
	                
	            END_IF;
	            
	        END_REGION
	        
	    END_IF;
	    
	END_REGION
	
	REGION 9 – Status
	    
	    REGION 9.1 – Common status update
	        
	        // Collective error output
	        #qx_Error := NOT #tx_HeaderValid
	        OR #tUDT_Status.InvalidMode
	        OR #tUDT_Status.FifoFull
	        OR #tUDT_Status.InvalidDataType;
	        
	        // Collective warning output              
	        #qx_Warning := #tUDT_Status.FifoPreFull;
	        
	    END_REGION
	    
	    REGION 9.2 – Status update
	        
	        // Update the outer status structure with internal status structure
	        #qUDT_Status := #tUDT_Status;
	        
	    END_REGION
	    
	END_REGION
END_FUNCTION

TYPE "UDT_EquipmentNumber"
VERSION : 0.1
   STRUCT
      Group : Int;   // Part of item number
      Node : Int;   // Part of item number
      Symbolic : DInt;   // Symbolic
   END_STRUCT;

END_TYPE

TYPE "UDT_ConveyorInterface"
TITLE = UDT_ConveyorInterface
VERSION : 0.1
//User-defined structure of conveyor interface variables.
   STRUCT
      Displacement : Int;   // Displacement per PLC scan [cm] either from position (if available) or speed and time
      SpeedSetpoint : Int;   // Conveyor speed setpoint [mm/s]
      ActualSpeed : Int;   // Conveyors actual speed [mm/s]
      DeltaPosition : Int;   // Read from Conveyor Servo Position [mm] after 1 PLC cycle
      RunFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Run forward request
      RunRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Run reverse request
      InternalErrorEncoder { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Encoder has an error
      InternalErrorVFD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // VFD has an error
      InternalErrorTracking { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Tracking has an error
      InternalErrorPEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PEC has an error
      InternalWarningVFD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // VFD has a warning
      InternalWarningTracking { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Tracking has a warning
      InternalErrorReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset internal errors
      ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Configuration error is active
      VFDRunning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor is running
      VFDatSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor at speed setpoint
      Disconnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // VFD disconnected
      ManualModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Covneyor is in manual mode
      ResetStatistics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset statistics
      HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Hardware for the Equipment is available and healthy
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_TimerOnOffDelay"
TITLE = FB_TimerOnOffDelay
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 32
// END_ATTRIBUTES
//Function block to generate on/off signal delay.
   VAR_INPUT 
      iudi_OnDelayTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // On delay time [ms]
      iudi_OffDelayTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Off delay time [ms]
      ix_SignalToDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Input signal to be delayed
      ix_Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;   // Timer Enable
   END_VAR

   VAR_OUTPUT 
      qlr_ActualTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Actual time
      qx_DelayedSignal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Delayed signal output
   END_VAR

   VAR 
      s_R_TRIG_Signal {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Siemens "R_Trig" - to prepare the rising edge trigger on "ix_SignalToDelay" signal
      s_F_TRIG_Signal {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Siemens "F_Trig" - to prepare the falling edge trigger on "ix_SignalToDelay" signal
   END_VAR
   VAR RETAIN
      slr_ActualDelayTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Actual delay time [ms]
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	26/08/2019  | 2.1       | M.Kurpiers    | Comments adjusted
	04/11/2019  | 2.2       | L.Klar        | Prevoius cycle scan changed from memory to DB variable
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION Step 1 – Input signal edge detection 
	    
	    #s_R_TRIG_Signal(CLK := #ix_SignalToDelay);
	    
	    
	    #s_F_TRIG_Signal(CLK := #ix_SignalToDelay);
	    
	END_REGION
	
	REGION Step 2 – Actual delay time initialization
	    
	    IF (#s_R_TRIG_Signal.Q OR #s_F_TRIG_Signal.Q)           // Input signal changed        
	    THEN
	        
	        #slr_ActualDelayTime := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION Step 3 – On/Off delay time calculation
	    
	    
	    IF (#ix_SignalToDelay                                       // Signal to be delayed is active
	        AND #ix_Enable)                                         // Ttimer enabled                   
	    THEN
	        
	        // Timer on
	        IF (#slr_ActualDelayTime >= #iudi_OnDelayTime)
	        THEN
	            
	            #qx_DelayedSignal := TRUE;
	            
	        ELSE
	            
	            #slr_ActualDelayTime += "DB_Memory".PrevCycleTime;
	            
	        END_IF;
	        
	    END_IF;
	    
	    // Timer off
	    IF (NOT #ix_SignalToDelay                                   // Signal to delay is not active
	        AND #ix_Enable)                                         // Timer is enabled                  
	    THEN
	        
	        IF (#slr_ActualDelayTime >= #iudi_OffDelayTime)
	        THEN
	            
	            #qx_DelayedSignal := FALSE;
	            
	        ELSE
	            
	            #slr_ActualDelayTime += "DB_Memory".PrevCycleTime;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION Step 4 – Actual time
	    
	    #qlr_ActualTime := #slr_ActualDelayTime;
	    
	END_REGION
END_FUNCTION_BLOCK

TYPE "UDT_BytesMessage"
VERSION : 0.1
   STRUCT
      Bytes : Array[0..217] of Byte;
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_Pulse"
TITLE = FB_Pulse
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 26
// END_ATTRIBUTES
//Function block to generate custom pulse signal.
   VAR_INPUT 
      iudi_PulseTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Pulse time [ms]
   END_VAR

   VAR_OUTPUT 
      qx_Pulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Pulse output
   END_VAR

   VAR 
      R_TRIG {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Siemens "R_Trig" - to prepare rising edge trigger on "sx_Pulse" signal
      slr_ActualPulseTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Actual pulse time [ms]
      sx_Pulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Pulse signal
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | K.Pokorski    | first release MHS TIA 15.1
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	27/08/2019  | 2.1       | K.Pokorski    | Comments adjusted
	04/11/2019  | 2.2       | L.Klar        | Prevoius cycle scan changed from memory to DB variable
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Pulse calculation
	    
	    // Pulse timer on
	    IF (#iudi_PulseTime <= #slr_ActualPulseTime)
	    THEN
	        
	        #sx_Pulse := TRUE;
	        #slr_ActualPulseTime := 0;
	        
	    ELSE
	        
	        #slr_ActualPulseTime += "DB_Memory".PrevCycleTime;
	        #sx_Pulse := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Pulse output
	    
	    #R_TRIG(CLK := #sx_Pulse,
	            Q => #qx_Pulse);
	    
	END_REGION
END_FUNCTION_BLOCK

TYPE "UDT_DecodeStatistics"
VERSION : 0.1
   STRUCT
      InvalidMessage : UDInt;   // Counter of incorrectly decoded messages
      HeartbeatNotObserved : UDInt;   // Statistics of HB not observed in a preset time
   END_STRUCT;

END_TYPE

TYPE "UDT_TCPIPReceiveStatisticsV2"
TITLE = UDT_TCPIPReceiveStatistics
VERSION : 0.1
//User-defined structure of FB_TCPIPReceive function block statistics.
   STRUCT
      InvalidMsg : UInt;   // Invalid message received
      InvalidID : UInt;   // Invalid destination or source node ID
      InvalidTelegramLength : UInt;   // Invalid telegram length
      InvalidEndSign : UInt;   // Invalid end sign or out of array range
      InvalidMsgNumber : UInt;   // Invalid message number received
      InvalidMsgLength : UInt;   // Invalid message length
   END_STRUCT;

END_TYPE

TYPE "UDT_Connection"
TITLE = UDT_Connection
VERSION : 0.1
//User-defined structure of connection parameters.
   STRUCT
      ActiveEstablished : Bool := FALSE;   // 0 – Passive connection establishment; 1 – Active connection establishment
      Interface_ID : HW_ANY := 64;   // Interface ID of CPU Ethernet interface
      ID : CONN_OUC;   // Unique ID as system reference for the connection
      IP : Array[1..4] of Int;   // IP address
      Port : UInt;   // Port number of the communication partner
      ConTimeout : DInt;   // Maximum waiting time for response from the communication partner [ms]
   END_STRUCT;

END_TYPE

TYPE "UDT_MFCSortMessageData"
VERSION : 0.1
   STRUCT
      TemporaryParcelIdentifier { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Data from "Temporary Parcel Identifier" message
         ObjectID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[10];   // Object ID
      END_STRUCT;
      Destination { S7_SetPoint := 'False'} : "UDT_MFCParcelDestination";   // Data from "Destination" message
      RejectParcel : Struct   // Data from "RejectParcel" message
         ObjectID : String[10];   // Object ID
      END_STRUCT;
      MFCEvent : Struct   // Data from "MFC Event" message
         Event : UInt;   // Event
         Action : Int;   // Action
         Settings : Int;   // Settings
      END_STRUCT;
      SystemStatusRequest : Struct   // Data from "System Status Request" message
         UpdateStatus : Bool;   // Update status
      END_STRUCT;
      System : Array[1..6] of Struct
         LocationIdentifier : UInt := 1;   // Control Location
         Command : Struct   // Command active
            Start : Bool;   // Start system
            Stop : Bool;   // Stop system
            Reset : Bool;   // Reset system
            SystemMode : Int;   // System mode number value
            Mode : Word;   // System mode bit value
            Infeed : Bool;   // Infeed
            Outfeed { S7_SetPoint := 'True'} : Bool;   // Outfeed
         END_STRUCT;
         Modes : Struct   // Mode active
            Mode : Word;   // Mode
            Unknown : Bool;   // Unknown mode
            Infeed : Bool;   // Infeed mode
            Outfeed : Bool;   // Outfeed mode
            Changing : Bool;   // Changing mode
         END_STRUCT;
      END_STRUCT;
   END_STRUCT;

END_TYPE

DATA_BLOCK "DB_GIN"
TITLE = DB_GIN
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
NON_RETAIN
//Data block to store parcels informations.
   VAR 
      GIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Array[1..1] of "UDT_GIN";   // GIN informations - for project remove unneeded customers and extend array bound range to 9999
   END_VAR


BEGIN

END_DATA_BLOCK

FUNCTION_BLOCK "FB_MFC_Sort_SortResult"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 124
// END_ATTRIBUTES
   VAR_INPUT 
      is_ObjectID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[10];   // Parcel identifier
      ii_DischargeLocation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Discharge location identifier
      ii_Result { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 1 = Sorted, 2 = Rejected, 3 = Lost
      ii_Reason { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 0 = Unknown, 1 = Success, 2 = Chute full, 3 = Chute not available, 4 = Unload failed, 5 = Late destination, 6 = Item lost, 7 = Higher priority available
      ii_SourceNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 0;   // Source Node
      ii_DestinationNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 0;   // Destination Node
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block error occurred
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block warning occurred
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Message number
   END_VAR

   VAR 
      s_UDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message array byte
      s_UDT_MessageHeader { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MFCSortMessageHeader";   // Message header
      ss_MessageBody { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Message body
         MsgID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Message ID
         MsgLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Message length
         Object_ID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[10];   // Parcel identifier
         DischargeLocation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Discharge location identifier
         Result { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // 0 = Sorted, 1 = Rejected, 2 = Lost
         Reason { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // 0 = Success, 1 = Chute full, 2 = Chute not available, 3 = Unload failed, 4 = Late destination, 5 = Item lost, 6 = Unknown
         Eom { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // End of message
      END_STRUCT;
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //  FIFO error
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO warning
         InvalidMessageArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message array is too short for message
         InvalidTimeInterval { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat time interval lower than zero
      END_STRUCT;
      sdi_SerializePosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Position in array where serialize finished writing data +1
      si_MaximumMessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum number of elements in message array
      si_SerializeStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Function serialize status
   END_VAR

   VAR CONSTANT 
      ci_MessageLength : Word := 16#000C;   // 10#0012 = 16#000C - Message length
      ci_Som : Byte := 16#FD;   // Start of message
      ci_Eom : Byte := 16#FE;   // End of message
      ci_MsgID : Word := 16#00CB;   // 10#0203 = 16#00CB - Message ID
      ci_MsgLength : Word := 16#0008;   // 10#0008 = 16#0008 - Message length
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	29/06/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec  | Updated for new Baseline
	02/05/2024  | 1.2       | J.Majer      | Datatype conversions changed from automatic to explicit, to accomodate IEC 61131-3 standard
	
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOStatus,
	              qx_Error => #ss_Status.FIFOError,
	              qx_Warning => #ss_Status.FIFOWarning,
	              iqv_Data := #s_UDT_MessageArray,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 2 – Data preparation
	    
	END_REGION
	
	REGION 3 – Message array size validation 
	    
	    // Get size of the array.
	    #si_MaximumMessageLength := "FC_GetNrOfArrayEl"(#s_UDT_MessageArray.Bytes);
	    
	    // Message array size validation. 
	    #ss_Status.InvalidMessageArraySize := WORD_TO_INT(#ci_MessageLength) > #si_MaximumMessageLength;
	    
	END_REGION
	
	REGION 4 – Message preparation 
	    
	    // FIFO full check.
	    IF NOT #iq_UDT_FifoHeader.Status.Full
	    THEN
	        // Errors and send pulse check.
	        IF NOT #ss_Status.FIFOError
	            AND NOT #ss_Status.InvalidMessageArraySize
	        THEN
	            
	            REGION 4.1 – Header preparation 
	                
	                // Check sequence number. If it is equal or greater than 255 reset it to 1.
	                IF #iqdi_MessageSequenceNumber <= 255
	                THEN
	                    #iqdi_MessageSequenceNumber += 1;
	                ELSE
	                    #iqdi_MessageSequenceNumber := 1;
	                END_IF;
	                
	                // Write parts of the header into structure.
	                #s_UDT_MessageHeader.SOM := #ci_Som;
	                #s_UDT_MessageHeader.SourceNode := INT_TO_BYTE(#ii_SourceNode);
	                #s_UDT_MessageHeader.DestinationNode := INT_TO_BYTE(#ii_DestinationNode);
	                #s_UDT_MessageHeader.SeqNumber := INT_TO_BYTE(#iqdi_MessageSequenceNumber);
	                #s_UDT_MessageHeader.DataLength := #ci_MessageLength;
	                #s_UDT_MessageHeader.NumMsg := 1;
	                
	                // Write parts of the body into structure.
	                #ss_MessageBody.MsgID := #ci_MsgID;
	                #ss_MessageBody.MsgLength := #ci_MsgLength;
	                #ss_MessageBody.Object_ID := #is_ObjectID;
	                #ss_MessageBody.DischargeLocation := UINT_TO_WORD(#ii_DischargeLocation);
	                #ss_MessageBody.Result := INT_TO_BYTE(#ii_Result);
	                #ss_MessageBody.Reason := INT_TO_BYTE(#ii_Reason);
	                #ss_MessageBody.Eom := #ci_Eom;
	                
	            END_REGION
	            
	            REGION 4.2 – Convert message into array of bytes
	                
	                // Initialize the header serialize position and convert header structure into array of bytes.
	                #sdi_SerializePosition := 0;
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #s_UDT_MessageHeader,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	                // Initialize the body serialize position and convert header structure into array of bytes
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #ss_MessageBody,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	            END_REGION
	            
	            REGION 4.3 – Write message into the FIFO buffer
	                
	                // Mode 'W' - Write FIFO record.
	                "FC_Fifo"(ic_Mode := 'W',
	                          qUDT_Status => #ss_Status.FIFOStatus,
	                          qx_Error => #ss_Status.FIFOError,
	                          qx_Warning => #ss_Status.FIFOWarning,
	                          iqv_Data := #s_UDT_MessageArray,
	                          iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	                          iqv_DataBuffer := #iqs_FifoData);
	                
	            END_REGION
	            
	        END_IF;
	    ELSE
	        // If FIFO is full set FIFO main and FIFO full errors.
	        #ss_Status.FIFOError := TRUE;
	        #ss_Status.FIFOStatus.FifoFull := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Status
	    
	    // Parametrization collective error output.
	    #qx_Error :=
	    #ss_Status.FIFOError
	    OR #ss_Status.InvalidTimeInterval
	    OR #ss_Status.InvalidMessageArraySize;
	    
	    // Parametrization collective warning output.
	    #qx_Warning := #ss_Status.FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

TYPE "UDT_MFCSortCOYMessageData"
VERSION : 0.1
   STRUCT
      MFCEvent : Struct   // Data from "MFC Event" message
         Event : UInt;   // Event
         Action : Int;   // Action
         Settings : Int;   // Settings
      END_STRUCT;
      SystemStatusRequest : Struct   // Data from "System Status Request" message
         UpdateStatus : Bool;   // Update status
      END_STRUCT;
      XrayRegistrationInfo : Struct   // Data from "Xray Registration Info" message
         ObjectID : String[10];   // Object ID
         VID : String[16];   // VID
         PieceID : String[40];   // Piece ID
         RoutingCode : String[2];   // Routing code
      END_STRUCT;
      System : Array[0..24] of Struct
         LocationIdentifier : UInt;   // Control Location
         Command : Struct   // Command active
            Start : Bool;   // Start system
            Stop : Bool;   // Stop system
            Reset : Bool;   // Reset system
            SystemMode : Int;   // System mode number value
            Mode : Word;   // System mode bit value
            Infeed : Bool;   // Infeed
            Outfeed { S7_SetPoint := 'True'} : Bool;   // Outfeed
            Contingency : Bool;   // Contingency
            NormalOperation : Bool;   // NormalOperation
            XrayScreening : Bool;   // XrayScreening
            XrayTransport : Bool;   // XrayTransport
            TruckLineEmpty : Bool;   // TruckLineEmpty
            TruckLineNormal : Bool;   // TruckLineNormal
         END_STRUCT;
         Modes : Struct   // Mode active
            Mode : Word;   // Mode
            Unknown : Bool;   // Unknown mode
            Infeed : Bool;   // Infeed mode
            Outfeed : Bool;   // Outfeed mode
            Contingency : Bool;   // Contingency mode
            NormalOperation : Bool;   // Normal operation mode
            XrayScreening : Bool;   // Xray screening mode
            XrayTransport : Bool;   // Xray transport mode
            TruckLineEmpty : Bool;   // Truck line empty mode
            TruckLineNormal : Bool;   // Truck line normal mode
            Changing : Bool;   // Changing mode
         END_STRUCT;
      END_STRUCT;
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_MFC_Sort_Decode"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 119
// END_ATTRIBUTES
   VAR_INPUT 
      iudi_HeartbeatTimeout { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   //   Heartbeat timeout [ms]
      ix_Connected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when HB monitoring enable
      ix_ResetData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when reset statistics required
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when collective block error occurred
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when collective block warningoccurred
   END_VAR

   VAR_IN_OUT 
      iqx_Reconnect { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Reconnect connection
      iq_UDT_Statistics : "UDT_DecodeStatistics";   //   Decode statistics
      iq_UDT_FifoReceiveHeader : "UDT_FifoHeader";   //   FIFO receive header
      iqs_FifoReceiveData : Array[*] of "UDT_MessageV2";   //   FIFO receive data
      iq_UDT_MessageData : "UDT_MFCSortMessageData";   // Received message data
   END_VAR

   VAR 
      s_FB_TimerHeartbeatCheck { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //   MHS "FB_TimerOnOffDelay" - to measure the time of missing HB
      s_UDT_FifoMessage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   //   Buffer for fifos message
      s_R_TRIG_Connected {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Siemens "R_TRIG" - to prepare the rising edge trigger on "ix_Connected" signal
      s_F_TRIG_HeartbeatNotOk {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //   Siemens "F_TRIG" - to prepare the falling edge trigger on "sx_HeartbeatOk" signal
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //   Status structure
         BadMessage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..10] of "UDT_BytesMessage";   //     Unknown message read
         FIFOReceiveStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";   //     Receive FIFO status structure
         FIFOReceiveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //     FIFO error
         FIFOReceiveWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //     FIFO warning
         InvalidTimeout { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //     Invalid Heartbeat timeout
      END_STRUCT;
      sdi_SerializePosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   Position in array where serialize finished writing data +1
      si_LocationIdentifier { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Location identifier
      si_SerializeStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Function serialize status
      si_MessageID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Message ID
      si_RingBufferNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 1;   //   Bad messages ringbuffer counter
      sx_Heartbeat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Heartbeat message detected
      sx_HeartbeatOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Heartbeat ok
      ss_CounterRecivedMessage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //  Counters with recived messages
         Heartbeat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // "Heartbeat" message
         TemporaryParcelIdentifier { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // "TemporaryParcelIdentifier" message
         Destination { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // "Destination" message
         RejectParcel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // "RejectParcel" message
         MFCEvent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // "MFCEvent" message
         SystemStatusRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // "SystemStatusRequest" message
         SetSystemMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // "SetSystemMode" message
         InvalidLocationIdentifier { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;
         SetSystemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // "SetSystemStatus" message
      END_STRUCT;
      sudi_CounterInvalidDestination { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Counters with invalid destination ranges
         Destination_1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;
         Destination_2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;
         Destination_3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;
         Destination_4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;
         Destination_5 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;
         Destination_6 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;
      END_STRUCT;
   END_VAR

   VAR_TEMP 
      ta_MessageData : Array[0..3] of Byte;   // Messages ID
      ta_MessageData_1 : Array[0..1] of Byte;   // Messages ID
      tx_MessageRead : Bool;   //   Message read from FIFO
      tx_InvalidHeader : Bool;   //   Invalid header
      tx_InvalidMessageID : Bool;   //   Invalid message ID
      tx_BadMessage : Bool;   //   Message with prohibited data
      ti_BadMessageSize : Int;   //   Bad message buffer size
      ti_NumberOfMessageBytes : Int;   //   Length of FIFO message
      tdi_NumercValue : UDInt;
      ti_NumercValue : Int;
      ti_Loop : Int;   // Loop counter
      ti_NrOfArrayEl : Int;   // Number of array element
      ti_SystemStatus : Int;
   END_VAR

   VAR CONSTANT 
      ci_DestinationMin : Int := 351;   // Minimum value of the destination
      ci_DestinationMax : Int := 355;   // Maximum value of the destination
      ci_SNCYID : Int;   // Complete SNCY system ID
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	15/02/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	12/09/2023  | 1.1       | S. Nikodem   | Update for message "System Modes"
	13/03/2023  | 1.2       | S. Nieswiec  | Updated for new Baseline
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOReceiveStatus,
	              qx_Error => #ss_Status.FIFOReceiveError,
	              qx_Warning => #ss_Status.FIFOReceiveWarning,
	              iqv_Data := #s_UDT_FifoMessage,
	              iqUDT_FifoHeader := #iq_UDT_FifoReceiveHeader,
	              iqv_DataBuffer := #iqs_FifoReceiveData);
	    
	    // FIFO isn't empty and doesn't have error.
	    IF NOT #iq_UDT_FifoReceiveHeader.Status.Empty
	        AND NOT #ss_Status.FIFOReceiveError
	    THEN
	        // Mode 'R' - Read FIFO record.
	        "FC_Fifo"(ic_Mode := 'R',
	                  qUDT_Status => #ss_Status.FIFOReceiveStatus,
	                  qx_Error => #ss_Status.FIFOReceiveError,
	                  qx_Warning => #ss_Status.FIFOReceiveWarning,
	                  iqv_Data := #s_UDT_FifoMessage,
	                  iqUDT_FifoHeader := #iq_UDT_FifoReceiveHeader,
	                  iqv_DataBuffer := #iqs_FifoReceiveData);
	        
	        // Message read bit set. 
	        #tx_MessageRead := TRUE;
	        
	        // FIFO empty or FIFO error occured.      
	    ELSE
	        #tx_MessageRead := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 – Message type recognition 
	    
	    IF #tx_MessageRead
	    THEN
	        
	        #ta_MessageData[0] := #s_UDT_FifoMessage.Bytes[0];
	        #ta_MessageData[1] := #s_UDT_FifoMessage.Bytes[1];
	        
	        // Deserialize Message ID
	        #sdi_SerializePosition := 0;
	        #si_SerializeStatus := Deserialize(SRC_ARRAY := #ta_MessageData,
	                                           DEST_VARIABLE => #si_MessageID,
	                                           POS := #sdi_SerializePosition);
	        
	        CASE #si_MessageID OF
	            90:  //Heartbeat
	                #sx_Heartbeat := TRUE;
	                
	                //Only statistics
	                #ss_CounterRecivedMessage.Heartbeat += 1;
	                
	            101:  //Temporary parcel identifier 
	                
	                //Get the number of Object ID from the reviced message 
	                #ta_MessageData[0] := #s_UDT_FifoMessage.Bytes[4];
	                #ta_MessageData[1] := #s_UDT_FifoMessage.Bytes[5];
	                #ta_MessageData[2] := #s_UDT_FifoMessage.Bytes[6];
	                #ta_MessageData[3] := #s_UDT_FifoMessage.Bytes[7];
	                
	                #sdi_SerializePosition := 0;
	                #si_SerializeStatus := Deserialize(SRC_ARRAY := #ta_MessageData,
	                                                   DEST_VARIABLE => #tdi_NumercValue,
	                                                   POS := #sdi_SerializePosition);
	                
	                #iq_UDT_MessageData.TemporaryParcelIdentifier.ObjectID := DELETE(IN := UDINT_TO_STRING(#tdi_NumercValue), L := 1, P := 1);
	                
	                //Only statistics
	                #ss_CounterRecivedMessage.TemporaryParcelIdentifier += 1;
	                
	            102:  //Destination
	                
	                //Get the number of Object ID from the reviced message 
	                #ta_MessageData[0] := #s_UDT_FifoMessage.Bytes[4];
	                #ta_MessageData[1] := #s_UDT_FifoMessage.Bytes[5];
	                #ta_MessageData[2] := #s_UDT_FifoMessage.Bytes[6];
	                #ta_MessageData[3] := #s_UDT_FifoMessage.Bytes[7];
	                
	                #sdi_SerializePosition := 0;
	                #si_SerializeStatus := Deserialize(SRC_ARRAY := #ta_MessageData,
	                                                   DEST_VARIABLE => #tdi_NumercValue,
	                                                   POS := #sdi_SerializePosition);
	                
	                #iq_UDT_MessageData.Destination.ObjectID := DELETE(IN := UDINT_TO_STRING(#tdi_NumercValue), L := 1, P := 1);
	                
	                //Sort strategy
	                #iq_UDT_MessageData.Destination.SortStrategy := INT_TO_STRING(BYTE_TO_INT(#s_UDT_FifoMessage.Bytes[8]));
	                
	                //Destination
	                //1
	                #ta_MessageData[0] := #s_UDT_FifoMessage.Bytes[9];
	                #ta_MessageData[1] := #s_UDT_FifoMessage.Bytes[10];
	                
	                #sdi_SerializePosition := 0;
	                #si_SerializeStatus := Deserialize(SRC_ARRAY := #ta_MessageData,
	                                                   DEST_VARIABLE => #iq_UDT_MessageData.Destination.Destination_1,
	                                                   POS := #sdi_SerializePosition);
	                
	                
	                //Check range of destination
	                IF NOT (#iq_UDT_MessageData.Destination.Destination_1 = 0)
	                    AND ((#iq_UDT_MessageData.Destination.Destination_1 > #ci_DestinationMax)
	                    OR (#iq_UDT_MessageData.Destination.Destination_1 < #ci_DestinationMin))
	                THEN
	                    #sudi_CounterInvalidDestination.Destination_1 += 1;
	                END_IF;
	                
	                //2
	                #ta_MessageData[0] := #s_UDT_FifoMessage.Bytes[11];
	                #ta_MessageData[1] := #s_UDT_FifoMessage.Bytes[12];
	                
	                #sdi_SerializePosition := 0;
	                #si_SerializeStatus := Deserialize(SRC_ARRAY := #ta_MessageData,
	                                                   DEST_VARIABLE => #iq_UDT_MessageData.Destination.Destination_2,
	                                                   POS := #sdi_SerializePosition);
	                
	                //Check range of destination
	                IF NOT (#iq_UDT_MessageData.Destination.Destination_2 = 0)
	                    AND ((#iq_UDT_MessageData.Destination.Destination_2 > #ci_DestinationMax)
	                    OR (#iq_UDT_MessageData.Destination.Destination_2 < #ci_DestinationMin))
	                THEN
	                    #sudi_CounterInvalidDestination.Destination_2 += 1;
	                END_IF;
	                
	                //3
	                #ta_MessageData[0] := #s_UDT_FifoMessage.Bytes[13];
	                #ta_MessageData[1] := #s_UDT_FifoMessage.Bytes[14];
	                
	                #sdi_SerializePosition := 0;
	                #si_SerializeStatus := Deserialize(SRC_ARRAY := #ta_MessageData,
	                                                   DEST_VARIABLE => #iq_UDT_MessageData.Destination.Destination_3,
	                                                   POS := #sdi_SerializePosition);
	                
	                //Check range of destination
	                IF NOT (#iq_UDT_MessageData.Destination.Destination_3 = 0)
	                    AND ((#iq_UDT_MessageData.Destination.Destination_3 > #ci_DestinationMax)
	                    OR (#iq_UDT_MessageData.Destination.Destination_3 < #ci_DestinationMin))
	                THEN
	                    #sudi_CounterInvalidDestination.Destination_3 += 1;
	                END_IF;
	                
	                //4
	                #ta_MessageData[0] := #s_UDT_FifoMessage.Bytes[15];
	                #ta_MessageData[1] := #s_UDT_FifoMessage.Bytes[16];
	                
	                #sdi_SerializePosition := 0;
	                #si_SerializeStatus := Deserialize(SRC_ARRAY := #ta_MessageData,
	                                                   DEST_VARIABLE => #iq_UDT_MessageData.Destination.Destination_4,
	                                                   POS := #sdi_SerializePosition);
	                
	                //Check range of destination
	                IF NOT (#iq_UDT_MessageData.Destination.Destination_4 = 0)
	                    AND ((#iq_UDT_MessageData.Destination.Destination_4 > #ci_DestinationMax)
	                    OR (#iq_UDT_MessageData.Destination.Destination_4 < #ci_DestinationMin))
	                THEN
	                    #sudi_CounterInvalidDestination.Destination_4 += 1;
	                END_IF;
	                
	                //5
	                #ta_MessageData[0] := #s_UDT_FifoMessage.Bytes[17];
	                #ta_MessageData[1] := #s_UDT_FifoMessage.Bytes[18];
	                
	                #sdi_SerializePosition := 0;
	                #si_SerializeStatus := Deserialize(SRC_ARRAY := #ta_MessageData,
	                                                   DEST_VARIABLE => #iq_UDT_MessageData.Destination.Destination_5,
	                                                   POS := #sdi_SerializePosition);
	                
	                //Check range of destination
	                IF NOT (#iq_UDT_MessageData.Destination.Destination_5 = 0)
	                    AND ((#iq_UDT_MessageData.Destination.Destination_5 > #ci_DestinationMax)
	                    OR (#iq_UDT_MessageData.Destination.Destination_5 < #ci_DestinationMin))
	                THEN
	                    #sudi_CounterInvalidDestination.Destination_5 += 1;
	                END_IF;
	                
	                //6
	                #ta_MessageData[0] := #s_UDT_FifoMessage.Bytes[19];
	                #ta_MessageData[1] := #s_UDT_FifoMessage.Bytes[20];
	                
	                #sdi_SerializePosition := 0;
	                #si_SerializeStatus := Deserialize(SRC_ARRAY := #ta_MessageData,
	                                                   DEST_VARIABLE => #iq_UDT_MessageData.Destination.Destination_6,
	                                                   POS := #sdi_SerializePosition);
	                
	                //Check range of destination
	                IF NOT (#iq_UDT_MessageData.Destination.Destination_6 = 0)
	                    AND ((#iq_UDT_MessageData.Destination.Destination_6 > #ci_DestinationMax)
	                    OR (#iq_UDT_MessageData.Destination.Destination_6 < #ci_DestinationMin))
	                THEN
	                    #sudi_CounterInvalidDestination.Destination_6 += 1;
	                END_IF;
	                
	                //Only statistics
	                #ss_CounterRecivedMessage.Destination += 1;
	                
	            103:  //Reject parcel
	                
	                //Get the number of Object ID from the reviced message 
	                #ta_MessageData[0] := #s_UDT_FifoMessage.Bytes[4];
	                #ta_MessageData[1] := #s_UDT_FifoMessage.Bytes[5];
	                #ta_MessageData[2] := #s_UDT_FifoMessage.Bytes[6];
	                #ta_MessageData[3] := #s_UDT_FifoMessage.Bytes[7];
	                
	                #sdi_SerializePosition := 0;
	                #si_SerializeStatus := Deserialize(SRC_ARRAY := #ta_MessageData,
	                                                   DEST_VARIABLE => #tdi_NumercValue,
	                                                   POS := #sdi_SerializePosition);
	                
	                #iq_UDT_MessageData.RejectParcel.ObjectID := DELETE(IN := UDINT_TO_STRING(#tdi_NumercValue), L := 1, P := 1);
	                
	                //Only statistics
	                #ss_CounterRecivedMessage.RejectParcel += 1;
	                
	            104:  //MFC Event
	                
	                //Get the number of event from the reviced message 
	                #ta_MessageData[0] := #s_UDT_FifoMessage.Bytes[4];
	                #ta_MessageData[1] := #s_UDT_FifoMessage.Bytes[5];
	                
	                #sdi_SerializePosition := 0;
	                #si_SerializeStatus := Deserialize(SRC_ARRAY := #ta_MessageData,
	                                                   DEST_VARIABLE => #iq_UDT_MessageData.MFCEvent.Event,
	                                                   POS := #sdi_SerializePosition);
	                
	                #iq_UDT_MessageData.MFCEvent.Action := BYTE_TO_INT(#s_UDT_FifoMessage.Bytes[6]);
	                #iq_UDT_MessageData.MFCEvent.Settings := BYTE_TO_INT(#s_UDT_FifoMessage.Bytes[7]);
	                
	                //Only statistics
	                #ss_CounterRecivedMessage.MFCEvent += 1;
	                
	            105:  //System status request
	                
	                #iq_UDT_MessageData.SystemStatusRequest.UpdateStatus := TRUE;
	                
	                //Only statistics
	                #ss_CounterRecivedMessage.SystemStatusRequest += 1;
	                
	            106:  //Set system mode
	                
	                //Get location identifier from the reviced message 
	                #ta_MessageData[0] := #s_UDT_FifoMessage.Bytes[4];
	                #ta_MessageData[1] := #s_UDT_FifoMessage.Bytes[5];
	                
	                #sdi_SerializePosition := 0;
	                #si_SerializeStatus := Deserialize(SRC_ARRAY := #ta_MessageData,
	                                                   DEST_VARIABLE => #si_LocationIdentifier,
	                                                   POS := #sdi_SerializePosition);
	                
	                IF #si_LocationIdentifier = #ci_SNCYID THEN
	                    
	                    //System mode - bit value
	                    
	                    //Get location identifier from the reviced message 
	                    #ta_MessageData_1[0] := #s_UDT_FifoMessage.Bytes[6];
	                    #ta_MessageData_1[1] := #s_UDT_FifoMessage.Bytes[7];
	                    
	                    #sdi_SerializePosition := 0;
	                    #si_SerializeStatus := Deserialize(SRC_ARRAY := #ta_MessageData_1,
	                                                       DEST_VARIABLE => #iq_UDT_MessageData.System[1].Command.Mode,
	                                                       POS := #sdi_SerializePosition);
	                    
	                    //System mode - Infeed = 1/Outfeed = 2 - number 
	                    IF #iq_UDT_MessageData.System[1].Command.Mode.%X1 THEN
	                        
	                        #iq_UDT_MessageData.System[1].Command.SystemMode := 1;
	                        
	                    ELSIF #iq_UDT_MessageData.System[1].Command.Mode.%X2 THEN
	                        
	                        #iq_UDT_MessageData.System[1].Command.SystemMode := 2;
	                        
	                    END_IF;
	                    
	                    //System mode - bool value
	                    //Infeed mode
	                    IF #iq_UDT_MessageData.System[1].Command.Mode.%X1 THEN
	                        #iq_UDT_MessageData.System[1].Command.Infeed := True;
	                    ELSE
	                        #iq_UDT_MessageData.System[1].Command.Infeed := False;
	                    END_IF;
	                    
	                    //Outfeed mode
	                    IF #iq_UDT_MessageData.System[1].Command.Mode.%X2 THEN
	                        #iq_UDT_MessageData.System[1].Command.Outfeed := True;
	                    ELSE
	                        #iq_UDT_MessageData.System[1].Command.Outfeed := False;
	                    END_IF;
	                    
	                    //Only statistics
	                    #ss_CounterRecivedMessage.SetSystemMode += 1;
	                    
	                ELSE
	                    
	                    //Only statistics
	                    #ss_CounterRecivedMessage.InvalidLocationIdentifier += 1;
	                    
	                END_IF;
	                
	            107:  //Set system status
	                
	                //Get location identifier from the reviced message 
	                #ta_MessageData[0] := #s_UDT_FifoMessage.Bytes[4];
	                #ta_MessageData[1] := #s_UDT_FifoMessage.Bytes[5];
	                
	                #sdi_SerializePosition := 0;
	                #si_SerializeStatus := Deserialize(SRC_ARRAY := #ta_MessageData,
	                                                   DEST_VARIABLE => #si_LocationIdentifier,
	                                                   POS := #sdi_SerializePosition);
	                
	                #ti_NrOfArrayEl := "FC_GetNrOfArrayEl"(#iq_UDT_MessageData.System);
	                
	                //Matching identifier
	                FOR #ti_Loop := 1 TO #ti_NrOfArrayEl DO
	                    
	                    IF #si_LocationIdentifier = #iq_UDT_MessageData.System[#ti_Loop].LocationIdentifier THEN
	                        
	                        #ti_SystemStatus := BYTE_TO_INT(#s_UDT_FifoMessage.Bytes[6]);
	                        
	                        CASE #ti_SystemStatus OF
	                            1:
	                                #iq_UDT_MessageData.System[#ti_Loop].Command.Start := True;
	                            2:
	                                #iq_UDT_MessageData.System[#ti_Loop].Command.Stop := True;
	                            3:
	                                #iq_UDT_MessageData.System[#ti_Loop].Command.Reset := True;
	                        END_CASE;
	                        
	                    END_IF;
	                    
	                END_FOR;
	                
	                //Only statistics
	                #ss_CounterRecivedMessage.SetSystemStatus += 1;
	                
	            ELSE
	                
	                #tx_InvalidMessageID := TRUE;
	                
	        END_CASE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 – Heartbeat monitoring 
	    
	    //HB timeout validation.
	    #ss_Status.InvalidTimeout := #iudi_HeartbeatTimeout <= 0;
	    
	    //HB monitoring if timeout correct.
	    IF NOT #ss_Status.InvalidTimeout
	    THEN
	        #s_R_TRIG_Connected(CLK := #ix_Connected);
	        
	        // Heartbeat timeout monitoring.
	        #s_FB_TimerHeartbeatCheck(iudi_OnDelayTime := 0,
	                                  iudi_OffDelayTime := #iudi_HeartbeatTimeout,
	                                  ix_SignalToDelay := #sx_Heartbeat OR #s_R_TRIG_Connected.Q,
	                                  qx_DelayedSignal => #sx_HeartbeatOK);
	        
	        #sx_Heartbeat := FALSE;
	        #s_F_TRIG_HeartbeatNotOk(CLK := #sx_HeartbeatOK);
	        
	        IF #s_F_TRIG_HeartbeatNotOk.Q
	            AND "DB_Memory".AlwaysFalse
	        THEN
	            // Re-establish conncect with partner and increment the number of communication lost.
	            #iqx_Reconnect := TRUE;
	            #iq_UDT_Statistics.HeartbeatNotObserved += 1;
	        END_IF;
	    END_IF;
	    
	END_REGION
	
	REGION 4 – Statistics update
	    
	    // Error statistics update required. 
	    IF #tx_InvalidHeader
	        OR #tx_InvalidMessageID
	        OR #tx_BadMessage
	    THEN
	        // Invalid message received counter incrementation.
	        #iq_UDT_Statistics.InvalidMessage += 1;
	        
	        // Maximum number of bad messages array.
	        #ti_BadMessageSize := "FC_GetNrOfArrayEl"(#ss_Status.BadMessage);
	        
	        // Writing invalid message in a bad message array.
	        IF #si_RingBufferNumber >= #ti_BadMessageSize
	        THEN
	            #si_RingBufferNumber := 1;
	        END_IF;
	        
	        #ti_NumberOfMessageBytes := "FC_GetNrOfArrayEl"(iv_Array := #s_UDT_FifoMessage.Bytes);
	        
	        MOVE_BLK(IN := #s_UDT_FifoMessage.Bytes[0],
	                 COUNT := INT_TO_UINT(#ti_NumberOfMessageBytes) - 1,
	                 OUT => #ss_Status.BadMessage[#si_RingBufferNumber].Bytes[0]);
	        
	        #si_RingBufferNumber += 1;
	    END_IF;
	    
	    //Resetting statistics.
	    IF #ix_ResetData
	    THEN
	        #iq_UDT_Statistics.InvalidMessage := 0;
	        #iq_UDT_Statistics.HeartbeatNotObserved := 0;
	    END_IF;
	    
	END_REGION
	
	REGION 5 – Status 
	    
	    // Collective error output.
	    #qx_Error :=
	    #ss_Status.FIFOReceiveError
	    OR #ss_Status.InvalidTimeout;
	    
	    // Collective warning output.
	    #qx_Warning :=
	    #ss_Status.FIFOReceiveWarning;
	    
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Sort_COY_SystemStatus"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 118
// END_ATTRIBUTES
   VAR_INPUT 
      ii_SystemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 1 - System stopped, 2 - System running
      iw_SystemMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Bit value according to the documentation
      ii_SourceNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // ID Source Node
      ii_DestinationNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // ID Destination Node
      ix_SendAllStatuses { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - update all the statuses
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block error occurred
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block warning occurred
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqa_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Message number
   END_VAR

   VAR 
      s_UDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message array byte
      s_UDT_MessageHeader { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MFCSortMessageHeader";   // Message header
      s_F_TRIG_SendAllStatuses {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger from signal send all statuses
      ss_MessageBody { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Message body
         MsgID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Message ID
         MsgLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Message length
         SystemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // System status
         SystemMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // System mode
         Eom { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // End of message
      END_STRUCT;
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //  FIFO error
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO warning
         InvalidMessageArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message array is too short for message
         InvalidTimeInterval { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat time interval lower than zero
      END_STRUCT;
      sdi_SerializePosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Position in array where serialize finished writing data +1
      si_MaximumMessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum number of elements in message array
      si_SerializeStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Function serialize status
      si_SystemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 0;   // 0 - System stopped, 1 - System running
      sw_SystemMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word := 0;   // Bit value according to the documentation
      si_Old_SystemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 0;   // Data from previous PLC cycle: 0 - System stopped, 1 - System running
      sw_Old_SystemMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word := 0;   // Bit value according to the documentation
      sx_NewData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - send a message to the MFC
   END_VAR

   VAR CONSTANT 
      ci_MessageLength : Word := 16#0006;   // 10#0006 = 16#0006 - Message length
      ci_Som : Byte := 16#FD;   // Start of message
      ci_Eom : Byte := 16#FE;   // End of message
      ci_MsgID : Word := 16#00CC;   // 10#0204 = 16#00CC - Message ID
      ci_MsgLength : Word := 16#0002;   // 10#0002 = 16#0002 - Message length
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	25/04/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/09/2023  | 1.1       | S. Nikodem   | Change type of variable System mode to word
	20/10/2023  | 1.2       | S. Nikodem   | Added "ix_SendAllStatuses" input and update for Serialize structure
	13/03/2023  | 1.3       | S. Nieswiec  | Updated for new Baseline
	02/05/2024  | 1.4       | J.Majer      | Datatype conversions changed from automatic to explicit, to accomodate IEC 61131-3 standard
	
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOStatus,
	              qx_Error => #ss_Status.FIFOError,
	              qx_Warning => #ss_Status.FIFOWarning,
	              iqv_Data := #s_UDT_MessageArray,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqa_FifoData);
	    
	END_REGION
	
	REGION 2 – Data preparation
	    
	    // Prepare trigger
	    #s_F_TRIG_SendAllStatuses(CLK := #ix_SendAllStatuses);
	    
	    // Data preparation
	    //  1 - System stopped, 2 - System running
	    #si_SystemStatus := #ii_SystemStatus;
	    // Bit value according to the documentation
	    #sw_SystemMode := #iw_SystemMode;
	    
	    //Check if the data from the previous PLC cycle differs, if so, send a message to the MFC.
	    #sx_NewData := (#si_Old_SystemStatus <> #si_SystemStatus) OR (#sw_Old_SystemMode <> #sw_SystemMode) OR #s_F_TRIG_SendAllStatuses.Q;
	    
	    // Copy data
	    #si_Old_SystemStatus := #si_SystemStatus;
	    #sw_Old_SystemMode := #sw_SystemMode;
	    
	END_REGION
	
	REGION 3 – Message array size validation 
	    
	    // Get size of the array.
	    #si_MaximumMessageLength := "FC_GetNrOfArrayEl"(#s_UDT_MessageArray.Bytes);
	    
	    // Message array size validation. 
	    #ss_Status.InvalidMessageArraySize := WORD_TO_INT(#ci_MessageLength) > #si_MaximumMessageLength;
	    
	END_REGION
	
	REGION 4 – Message preparation 
	    
	    // FIFO full check.
	    IF NOT #iq_UDT_FifoHeader.Status.Full
	    THEN
	        // Errors and send pulse check.
	        IF NOT #ss_Status.FIFOError
	            AND NOT #ss_Status.InvalidMessageArraySize
	            AND #sx_NewData
	        THEN
	            
	            REGION 4.1 – Header preparation 
	                
	                // Check sequence number. If it is equal or greater than 255 reset it to 1.
	                IF #iqi_MessageSequenceNumber <= 255
	                THEN
	                    #iqi_MessageSequenceNumber += 1;
	                ELSE
	                    #iqi_MessageSequenceNumber := 1;
	                END_IF;
	                
	                // Write parts of the header into structure.
	                #s_UDT_MessageHeader.SOM := #ci_Som;
	                #s_UDT_MessageHeader.SourceNode := INT_TO_BYTE(#ii_SourceNode);
	                #s_UDT_MessageHeader.DestinationNode := INT_TO_BYTE(#ii_DestinationNode);
	                #s_UDT_MessageHeader.SeqNumber := INT_TO_BYTE(#iqi_MessageSequenceNumber);
	                #s_UDT_MessageHeader.DataLength := #ci_MessageLength;
	                #s_UDT_MessageHeader.NumMsg := 1;
	                
	                // Write parts of the body into structure.
	                #ss_MessageBody.MsgID := #ci_MsgID;
	                #ss_MessageBody.MsgLength := #ci_MsgLength;
	                #ss_MessageBody.SystemStatus := INT_TO_BYTE(#si_SystemStatus);
	                #ss_MessageBody.SystemMode := #sw_SystemMode;
	                #ss_MessageBody.Eom := #ci_Eom;
	                
	            END_REGION
	            
	            REGION 4.2 – Convert message into array of bytes
	                
	                // Initialize the header serialize position and convert header structure into array of bytes.
	                #sdi_SerializePosition := 0;
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #s_UDT_MessageHeader,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #ss_MessageBody.MsgID,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #ss_MessageBody.MsgLength,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #ss_MessageBody.SystemStatus,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #ss_MessageBody.SystemMode,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #ss_MessageBody.Eom,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	            END_REGION
	            
	            REGION 4.3 – Write message into the FIFO buffer
	                
	                // Mode 'W' - Write FIFO record.
	                "FC_Fifo"(ic_Mode := 'W',
	                          qUDT_Status => #ss_Status.FIFOStatus,
	                          qx_Error => #ss_Status.FIFOError,
	                          qx_Warning => #ss_Status.FIFOWarning,
	                          iqv_Data := #s_UDT_MessageArray,
	                          iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	                          iqv_DataBuffer := #iqa_FifoData);
	                
	            END_REGION
	            
	        END_IF;
	    ELSE
	        // If FIFO is full set FIFO main and FIFO full errors.
	        #ss_Status.FIFOError := TRUE;
	        #ss_Status.FIFOStatus.FifoFull := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Status
	    
	    // Parametrization collective error output.
	    #qx_Error :=
	    #ss_Status.FIFOError
	    OR #ss_Status.InvalidTimeInterval
	    OR #ss_Status.InvalidMessageArraySize;
	    
	    // Parametrization collective warning output.
	    #qx_Warning := #ss_Status.FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Sort_COY_Result"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 117
// END_ATTRIBUTES
   VAR_INPUT 
      ii_GINRangeStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 0;   // GIN range start value
      ii_GINRangeEnd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 0;   // GIN range end value
      is_ObjectID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[10];   // Recived parcel identifier
      ii_SourceNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // ID Source Node
      ii_DestinationNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // ID Destination Node
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block error occurred
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block warning occurred
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqa_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Message number
   END_VAR

   VAR 
      ss_FB_HeartbeatPulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Pulse";   // Heartbeat send pulse generator
      s_UDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message array byte
      s_UDT_MessageHeader { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MFCSortMessageHeader";   // Message header
      ss_MessageBody { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Message body
         MsgID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Message ID
         MsgLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Message length
         VID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..16] of Byte;   // Virtual Item Identifier
         PieceID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..40] of Byte;   // Piece ID
         Group { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Group
         Level { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Level
         Result { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Result
         Eom { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // End of message
      END_STRUCT;
      ss_MessageData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Message data
         VID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..16] of Byte;   // Virtual Item Identifier
         PieceID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..40] of Byte;   // Piece ID
         Group { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[1];   // Group
         Level { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[1];   // Level
         Result { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[1];   // Result
      END_STRUCT;
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //  FIFO error
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO warning
         InvalidMessageArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message array is too short for message
         InvalidTimeInterval { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat time interval lower than zero
      END_STRUCT;
      sS_Old_Object_ID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[10];   // Value from previous PLC cycle
      sdi_SerializePosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Position in array where serialize finished writing data +1
      si_MaximumMessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum number of elements in message array
      si_SerializeStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Function serialize status
      sx_NewData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - send a message to the MFC
   END_VAR

   VAR_TEMP 
      ti_Loop_GIN : Int;   // Loop counter for DB_GIN
      ti_Loop : Int;   // Loop counter
   END_VAR

   VAR CONSTANT 
      ci_MessageLength : Word := 16#003F;   // 10#0063 = 16#003F - Message length
      ci_MsgID : Word := 16#0137;   // 10#0311 = 16#0137 - Message ID
      ci_MsgLength : Word := 16#003B;   // 10#0059 = 16#003B - Message length
      ci_Som : Byte := 16#FD;   // Start of message
      ci_Eom : Byte := 16#FE;   // End of message
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	24/04/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	03/10/2023  | 1.1       | S. Nikodem   | Update
	13/03/2023  | 1.2       | S. Nieswiec  | Updated for new Baseline
	02/05/2024  | 1.3       | J.Majer      | Datatype conversions changed from automatic to explicit, to accomodate IEC 61131-3 standard
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOStatus,
	              qx_Error => #ss_Status.FIFOError,
	              qx_Warning => #ss_Status.FIFOWarning,
	              iqv_Data := #s_UDT_MessageArray,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqa_FifoData);
	    
	END_REGION
	
	REGION 2 – Data preparation
	    
	    //Generation message when is new parcel
	    #sx_NewData := (#is_ObjectID <> #sS_Old_Object_ID) AND NOT (#is_ObjectID = '');
	    // Save last value
	    #sS_Old_Object_ID := #is_ObjectID;
	    
	    IF #sx_NewData THEN
	        
	        FOR #ti_Loop_GIN := #ii_GINRangeStart TO #ii_GINRangeEnd DO
	            
	            IF "DB_GIN".GIN[#ti_Loop_GIN].DHL.ObjectID = #is_ObjectID THEN
	                
	                //VID
	                FOR #ti_Loop := 1 TO 16 DO
	                    
	                    #ss_MessageData.VID[#ti_Loop] := CHAR_TO_BYTE("DB_GIN".GIN[#ti_Loop_GIN].DHL.VID[#ti_Loop]);
	                    
	                END_FOR;
	                
	                //Piece ID
	                FOR #ti_Loop := 1 TO 40 DO
	                    
	                    #ss_MessageData.PieceID[#ti_Loop] := CHAR_TO_BYTE("DB_GIN".GIN[#ti_Loop_GIN].DHL.PieceID[#ti_Loop]);
	                    
	                END_FOR;
	                
	                //Group
	                #ss_MessageData.Group := "DB_GIN".GIN[#ti_Loop_GIN].DHL.Xray.Group;
	                
	                //Level
	                #ss_MessageData.Level := "DB_GIN".GIN[#ti_Loop_GIN].DHL.Xray.Level;
	                
	                //Result
	                #ss_MessageData.Result := "DB_GIN".GIN[#ti_Loop_GIN].DHL.Xray.Result;
	                
	            END_IF;
	            
	        END_FOR;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 – Message array size validation 
	    
	    // Get size of the array.
	    #si_MaximumMessageLength := "FC_GetNrOfArrayEl"(#s_UDT_MessageArray.Bytes);
	    
	    // Message array size validation. 
	    #ss_Status.InvalidMessageArraySize := WORD_TO_INT(#ci_MessageLength) > #si_MaximumMessageLength;
	    
	END_REGION
	
	
	REGION 4 – Message preparation 
	    
	    // FIFO full check.
	    IF NOT #iq_UDT_FifoHeader.Status.Full
	    THEN
	        // Errors and send pulse check.
	        IF NOT #ss_Status.FIFOError
	            AND NOT #ss_Status.InvalidMessageArraySize
	            AND #sx_NewData
	        THEN
	            
	            REGION 4.1 – Header preparation 
	                
	                // Check sequence number. If it is equal or greater than 255 reset it to 1.
	                IF #iqi_MessageSequenceNumber <= 255
	                THEN
	                    #iqi_MessageSequenceNumber += 1;
	                ELSE
	                    #iqi_MessageSequenceNumber := 1;
	                END_IF;
	                
	                // Write parts of the header into structure.
	                #s_UDT_MessageHeader.SOM := #ci_Som;
	                #s_UDT_MessageHeader.SourceNode := INT_TO_BYTE(#ii_SourceNode);
	                #s_UDT_MessageHeader.DestinationNode := INT_TO_BYTE(#ii_DestinationNode);
	                #s_UDT_MessageHeader.SeqNumber := INT_TO_BYTE(#iqi_MessageSequenceNumber);
	                #s_UDT_MessageHeader.DataLength := #ci_MessageLength;
	                #s_UDT_MessageHeader.NumMsg := 1;
	                
	                // Write parts of the body into structure.
	                #ss_MessageBody.MsgID := #ci_MsgID;
	                #ss_MessageBody.MsgLength := #ci_MsgLength;
	                #ss_MessageBody.VID := #ss_MessageData.VID;
	                #ss_MessageBody.PieceID := #ss_MessageData.PieceID;
	                #ss_MessageBody.Group := CHAR_TO_BYTE(STRING_TO_CHAR(#ss_MessageData.Group));
	                #ss_MessageBody.Level := CHAR_TO_BYTE(STRING_TO_CHAR(#ss_MessageData.Level));
	                #ss_MessageBody.Result := CHAR_TO_BYTE(STRING_TO_CHAR(#ss_MessageData.Result));
	                #ss_MessageBody.Eom := #ci_Eom;
	                
	            END_REGION
	            
	            REGION 4.2 – Convert message into array of bytes
	                
	                // Initialize the header serialize position and convert header structure into array of bytes.
	                #sdi_SerializePosition := 0;
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #s_UDT_MessageHeader,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	                // Initialize the body serialize position and convert header structure into array of bytes
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #ss_MessageBody,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	            END_REGION
	            
	            REGION 4.3 – Write message into the FIFO buffer
	                
	                // Mode 'W' - Write FIFO record.
	                "FC_Fifo"(ic_Mode := 'W',
	                          qUDT_Status => #ss_Status.FIFOStatus,
	                          qx_Error => #ss_Status.FIFOError,
	                          qx_Warning => #ss_Status.FIFOWarning,
	                          iqv_Data := #s_UDT_MessageArray,
	                          iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	                          iqv_DataBuffer := #iqa_FifoData);
	                
	            END_REGION
	            
	        END_IF;
	    ELSE
	        // If FIFO is full set FIFO main and FIFO full errors.
	        #ss_Status.FIFOError := TRUE;
	        #ss_Status.FIFOStatus.FifoFull := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Status
	    
	    // Parametrization collective error output.
	    #qx_Error :=
	    #ss_Status.FIFOError
	    OR #ss_Status.InvalidTimeInterval
	    OR #ss_Status.InvalidMessageArraySize;
	    
	    // Parametrization collective warning output.
	    #qx_Warning := #ss_Status.FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Sort_COY_RegInfo"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 116
// END_ATTRIBUTES
   VAR_INPUT 
      is_ObjectID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[10];   // Parcel identifier
      ii_XrayLocation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // X-ray location
      ii_SourceNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // ID Source Node
      ii_DestinationNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // ID Destination Node
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block error occurred
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block warning occurred
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqa_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Message number
   END_VAR

   VAR 
      ss_FB_HeartbeatPulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Pulse";   // Heartbeat send pulse generator
      s_UDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message array byte
      s_UDT_MessageHeader { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MFCSortMessageHeader";   // Message header
      ss_MessageBody { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Message body
         MsgID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Message ID
         MsgLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Message length
         ObjectID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DWord;   // Parcel identifier
         XrayLocation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
         Eom { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // End of message
      END_STRUCT;
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //  FIFO error
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO warning
         InvalidMessageArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message array is too short for message
         InvalidTimeInterval { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat time interval lower than zero
      END_STRUCT;
      si_Old_Object_ID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[10];   // Value from previous PLC cycle
      sdi_SerializePosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Position in array where serialize finished writing data +1
      si_MaximumMessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum number of elements in message array
      si_SerializeStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Function serialize status
      sx_NewData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - send a message to the MFC
   END_VAR

   VAR_TEMP 
      tudi_Temp : UDInt;   // temporarry variable
   END_VAR

   VAR CONSTANT 
      ci_MessageLength : Word := 16#0008;   // 10#0008 = 16#0008 - Message length
      ci_MsgID : Word := 16#0136;   // 10#0310 = 16#0136 - Message ID
      ci_MsgLength : Word := 16#0004;   // 10#0004 = 16#0004 - Message length
      ci_Som : Byte := 16#FD;   // Start of message
      ci_Eom : Byte := 16#FE;   // End of message
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	24/05/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec  | Updated for new Baseline
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOStatus,
	              qx_Error => #ss_Status.FIFOError,
	              qx_Warning => #ss_Status.FIFOWarning,
	              iqv_Data := #s_UDT_MessageArray,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqa_FifoData);
	    
	END_REGION
	
	REGION 2 – Data preparation
	    
	    //Send message when is new parcel
	    #sx_NewData := (#is_ObjectID <> #si_Old_Object_ID) AND NOT (#is_ObjectID = '');
	    // Save last value
	    #si_Old_Object_ID := #is_ObjectID;
	    
	END_REGION
	
	REGION 3 – Message array size validation 
	    
	    // Get size of the array.
	    #si_MaximumMessageLength := "FC_GetNrOfArrayEl"(#s_UDT_MessageArray.Bytes);
	    
	    // Message array size validation. 
	    #ss_Status.InvalidMessageArraySize := WORD_TO_INT(#ci_MessageLength) > #si_MaximumMessageLength;
	    
	END_REGION
	
	
	REGION 4 – Message preparation 
	    
	    // FIFO full check.
	    IF NOT #iq_UDT_FifoHeader.Status.Full
	    THEN
	        // Errors and send pulse check.
	        IF NOT #ss_Status.FIFOError
	            AND NOT #ss_Status.InvalidMessageArraySize
	            AND #sx_NewData
	        THEN
	            
	            REGION 4.1 – Header preparation 
	                
	                // Check sequence number. If it is equal or greater than 255 reset it to 1.
	                IF #iqi_MessageSequenceNumber <= 255
	                THEN
	                    #iqi_MessageSequenceNumber += 1;
	                ELSE
	                    #iqi_MessageSequenceNumber := 1;
	                END_IF;
	                
	                // Write parts of the header into structure.
	                #s_UDT_MessageHeader.SOM := #ci_Som;
	                #s_UDT_MessageHeader.SourceNode := INT_TO_BYTE(#ii_SourceNode);
	                #s_UDT_MessageHeader.DestinationNode := INT_TO_BYTE(#ii_DestinationNode);
	                #s_UDT_MessageHeader.SeqNumber := INT_TO_BYTE(#iqi_MessageSequenceNumber);
	                #s_UDT_MessageHeader.DataLength := #ci_MessageLength;
	                #s_UDT_MessageHeader.NumMsg := 1;
	                
	                //Convert string value to UDINT
	                #tudi_Temp := STRING_TO_UDINT(#is_ObjectID);
	                
	                // Write parts of the body into structure.
	                #ss_MessageBody.MsgID := #ci_MsgID;
	                #ss_MessageBody.MsgLength := #ci_MsgLength;
	                #ss_MessageBody.ObjectID := UDINT_TO_DWORD(#tudi_Temp);
	                #ss_MessageBody.XrayLocation := INT_TO_WORD(#ii_XrayLocation);
	                #ss_MessageBody.Eom := #ci_Eom;
	                
	            END_REGION
	            
	            REGION 4.2 – Convert message into array of bytes
	                
	                // Initialize the header serialize position and convert header structure into array of bytes.
	                #sdi_SerializePosition := 0;
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #s_UDT_MessageHeader,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	                // Initialize the body serialize position and convert header structure into array of bytes
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #ss_MessageBody,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	            END_REGION
	            
	            REGION 4.3 – Write message into the FIFO buffer
	                
	                // Mode 'W' - Write FIFO record.
	                "FC_Fifo"(ic_Mode := 'W',
	                          qUDT_Status => #ss_Status.FIFOStatus,
	                          qx_Error => #ss_Status.FIFOError,
	                          qx_Warning => #ss_Status.FIFOWarning,
	                          iqv_Data := #s_UDT_MessageArray,
	                          iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	                          iqv_DataBuffer := #iqa_FifoData);
	                
	            END_REGION
	            
	        END_IF;
	    ELSE
	        // If FIFO is full set FIFO main and FIFO full errors.
	        #ss_Status.FIFOError := TRUE;
	        #ss_Status.FIFOStatus.FifoFull := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Status
	    
	    // Parametrization collective error output.
	    #qx_Error :=
	    #ss_Status.FIFOError
	    OR #ss_Status.InvalidTimeInterval
	    OR #ss_Status.InvalidMessageArraySize;
	    
	    // Parametrization collective warning output.
	    #qx_Warning := #ss_Status.FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Sort_COY_ReceiveResult"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 115
// END_ATTRIBUTES
   VAR_INPUT 
      is_VID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[16];   // Virtual Item Identifier (VID)
      is_PieceID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[40];   // Piece ID barcodes
      is_Group { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[1];   // The group field is used to identify the group of the operator decisions came from in a
      is_Level { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[1];   // Level field is used to identify which level the operator decision came from in a
      is_Result { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[1];   // Results can be indicated with the following
      ii_SourceNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // ID Source Node
      ii_DestinationNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // ID Destination Node
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block error occurred
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block warning occurred
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqa_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Message number
   END_VAR

   VAR 
      ss_FB_HeartbeatPulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Pulse";   // Heartbeat send pulse generator
      s_UDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message array byte
      s_UDT_MessageHeader { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MFCSortMessageHeader";   // Message header
      ss_MessageBody { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Message body
         MsgID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Message ID
         MsgLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Message length
         VID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..16] of Byte;   // Virtual Item Identifier
         PieceID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..40] of Byte;   // Piece ID
         Group { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Group
         Level { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Level
         Result { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Result
         Eom { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // End of message
      END_STRUCT;
      ss_MessageData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Message data
         VID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..16] of Byte;   // Virtual Item Identifier
         PieceID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..40] of Byte;   // Piece ID
         Group { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[1];   // Group
         Level { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[1];   // Level
         Result { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[1];   // Result
      END_STRUCT;
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //  FIFO error
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO warning
         InvalidMessageArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message array is too short for message
         InvalidTimeInterval { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat time interval lower than zero
      END_STRUCT;
      sdi_SerializePosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Position in array where serialize finished writing data +1
      si_MaximumMessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum number of elements in message array
      si_SerializeStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Function serialize status
      sx_NewData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // New data received
      ss_PieceIDOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[40];   // Piece ID barcodes old value
   END_VAR

   VAR_TEMP 
      ti_Loop : Int;
   END_VAR

   VAR CONSTANT 
      ci_MessageLength : Word := 16#003F;   // 10#0063 = 16#003F - Message length
      ci_MsgID : Word := 16#0137;   // 10#0311 = 16#0137 - Message ID
      ci_MsgLength : Word := 16#003B;   // 10#0059 = 16#003B - Message length
      ci_Som : Byte := 16#FD;   // Start of message
      ci_Eom : Byte := 16#FE;   // End of message
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	05/10/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec  | Updated for new Baseline
	02/05/2024  | 1.2       | J.Majer      | Datatype conversions changed from automatic to explicit, to accomodate IEC 61131-3 standard
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOStatus,
	              qx_Error => #ss_Status.FIFOError,
	              qx_Warning => #ss_Status.FIFOWarning,
	              iqv_Data := #s_UDT_MessageArray,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqa_FifoData);
	    
	END_REGION
	
	REGION 2 – Data preparation
	    
	    IF #is_PieceID <> #ss_PieceIDOld AND NOT (#ss_PieceIDOld = '') THEN
	        
	        //Save
	        #ss_PieceIDOld := #is_PieceID;
	        
	        //VID
	        FOR #ti_Loop := 1 TO 16 DO
	            
	            #ss_MessageData.VID[#ti_Loop] := CHAR_TO_BYTE(#is_VID[#ti_Loop]);
	            
	        END_FOR;
	        
	        //Piece ID
	        FOR #ti_Loop := 1 TO 40 DO
	            
	            #ss_MessageData.PieceID[#ti_Loop] := CHAR_TO_BYTE(#is_PieceID[#ti_Loop]);
	            
	        END_FOR;
	        
	        //Group
	        #ss_MessageData.Group := #is_Group;
	        
	        //Level
	        #ss_MessageData.Level := #is_Level;
	        
	        //Result
	        #ss_MessageData.Result := #is_Result;
	        
	        //New data received
	        #sx_NewData := TRUE;
	        
	    END_IF;
	    
	    
	END_REGION
	
	REGION 3 – Message array size validation 
	    
	    // Get size of the array.
	    #si_MaximumMessageLength := "FC_GetNrOfArrayEl"(#s_UDT_MessageArray.Bytes);
	    
	    // Message array size validation. 
	    #ss_Status.InvalidMessageArraySize := WORD_TO_INT(#ci_MessageLength) > #si_MaximumMessageLength;
	    
	END_REGION
	
	
	REGION 4 – Message preparation 
	    
	    // FIFO full check.
	    IF NOT #iq_UDT_FifoHeader.Status.Full
	    THEN
	        // Errors and send pulse check.
	        IF NOT #ss_Status.FIFOError
	            AND NOT #ss_Status.InvalidMessageArraySize
	            AND #sx_NewData
	        THEN
	            
	            REGION 4.1 – Header preparation 
	                
	                // Check sequence number. If it is equal or greater than 255 reset it to 1.
	                IF #iqi_MessageSequenceNumber <= 255
	                THEN
	                    #iqi_MessageSequenceNumber += 1;
	                ELSE
	                    #iqi_MessageSequenceNumber := 1;
	                END_IF;
	                
	                // Write parts of the header into structure.
	                #s_UDT_MessageHeader.SOM := #ci_Som;
	                #s_UDT_MessageHeader.SourceNode := INT_TO_BYTE(#ii_SourceNode);
	                #s_UDT_MessageHeader.DestinationNode := INT_TO_BYTE(#ii_DestinationNode);
	                #s_UDT_MessageHeader.SeqNumber := INT_TO_BYTE(#iqi_MessageSequenceNumber);
	                #s_UDT_MessageHeader.DataLength := #ci_MessageLength;
	                #s_UDT_MessageHeader.NumMsg := 1;
	                
	                // Write parts of the body into structure.
	                #ss_MessageBody.MsgID := #ci_MsgID;
	                #ss_MessageBody.MsgLength := #ci_MsgLength;
	                #ss_MessageBody.VID := #ss_MessageData.VID;
	                #ss_MessageBody.PieceID := #ss_MessageData.PieceID;
	                #ss_MessageBody.Group := CHAR_TO_BYTE(STRING_TO_CHAR(#ss_MessageData.Group));
	                #ss_MessageBody.Level := CHAR_TO_BYTE(STRING_TO_CHAR(#ss_MessageData.Level));
	                #ss_MessageBody.Result := CHAR_TO_BYTE(STRING_TO_CHAR(#ss_MessageData.Result));
	                #ss_MessageBody.Eom := #ci_Eom;
	                
	            END_REGION
	            
	            REGION 4.2 – Convert message into array of bytes
	                
	                // Initialize the header serialize position and convert header structure into array of bytes.
	                #sdi_SerializePosition := 0;
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #s_UDT_MessageHeader,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	                // Initialize the body serialize position and convert header structure into array of bytes
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #ss_MessageBody,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	            END_REGION
	            
	            REGION 4.3 – Write message into the FIFO buffer
	                
	                // Mode 'W' - Write FIFO record.
	                "FC_Fifo"(ic_Mode := 'W',
	                          qUDT_Status => #ss_Status.FIFOStatus,
	                          qx_Error => #ss_Status.FIFOError,
	                          qx_Warning => #ss_Status.FIFOWarning,
	                          iqv_Data := #s_UDT_MessageArray,
	                          iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	                          iqv_DataBuffer := #iqa_FifoData);
	                
	            END_REGION
	            
	            //Reset
	            #sx_NewData := False;
	            
	        END_IF;
	    ELSE
	        // If FIFO is full set FIFO main and FIFO full errors.
	        #ss_Status.FIFOError := TRUE;
	        #ss_Status.FIFOStatus.FifoFull := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Status
	    
	    // Parametrization collective error output.
	    #qx_Error :=
	    #ss_Status.FIFOError
	    OR #ss_Status.InvalidTimeInterval
	    OR #ss_Status.InvalidMessageArraySize;
	    
	    // Parametrization collective warning output.
	    #qx_Warning := #ss_Status.FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Sort_TCPIPReceive"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 2.3
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 126
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_Connection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_Connection";   // Connection parameters
      ix_EnableReceive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when receive enable
      ii_DestinationID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Destination node ID
      ii_SourceID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Source node ID
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block error occurred
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block warning occurred
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // Fifo header
      iqs_FifoData : Variant;   // Fifo data
      iq_UDT_Statistics : "UDT_TCPIPReceiveStatisticsV2";   // Statistic structure
   END_VAR

   VAR 
      s_FB_TRCV {InstructionName := 'TRCV'; LibVersion := '4.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TRCV;   // Siemens "TRCV" block - to receive the data from TCPIP socket
      ss_TRCV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // TRCV block interface structure
         Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      TRCV - Enable
         NDR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      TRCV - New data available
         Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      TRCV - Busy
         Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      TRCV - Error
         Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   //      TRCV - Status
         ReceivedLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   //      TRCV - Received length
         Data { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..120] of Byte;   //      TRCV - Data
      END_STRUCT;
      ss_TRCV_empty { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // TRCV block interface structure
         Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      TRCV - Enable
         NDR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      TRCV - New data available
         Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      TRCV - Busy
         Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      TRCV - Error
         Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   //      TRCV - Status
         ReceivedLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   //      TRCV - Received length
         Data { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..120] of Byte;   //      TRCV - Data
      END_STRUCT;
      s_UDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message byte array
   END_VAR
   VAR RETAIN
      sa_Invalid_Messages { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..99] of Struct
         Data { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..120] of Byte;
      END_STRUCT;
   END_VAR
   VAR 
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         ErrorCode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //     Error code structure
            TRCV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   //     Siemens TRCV error code - Check documentation
         END_STRUCT;
         FIFOReceiveStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";   //     Receive FIFO status structure
         FIFOReceiveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //     Receive FIFO error
         FIFOReceiveWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //     Receive  FIFO warning
         ReceiveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //     TRCV block operation error - Check TRCVStatus
         sa_InvalidMessages { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..99] of Struct   // Invalid messages
            Data { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..120] of Byte;
         END_STRUCT;
         sui_ReceivedMessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Received message length
      END_STRUCT;
      sui_NumberOfReceivedMessages { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Number of received messages in one frame
      sdi_SerializePosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Position in array where serialize finished writing data +1
      si_MaximumMessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum message length
      si_SerializeStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Function serialize status
      si_TelegramLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Telegram length - envelope + data + tail
      si_MessagesNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Messages number in Telegram
      si_Offset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Data offset
      si_MessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Message length
      si_InvalidMessages { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Arry counter invalid messages
      sx_ValidMessage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Valid message signal
      sx_Watchdog { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Watch dog
   END_VAR

   VAR_TEMP 
      ta_MessageData : Array[0..1] of Byte;   // Array of bytes
      ti_LC_TelegamBytes : Int;   // Telegram bytes loop counter
      ti_Loop_MessageCounter : Int;   // Loop counter
      ti_Loop_MessageLength : Int;   // Loop counter
   END_VAR

   VAR CONSTANT 
      cc_NULL : Byte := 16#00;   // Null sign
      cb_SOM : Byte := 16#FD;   // First termination sign
      cb_EOM : Byte := 16#FE;   // Last termination sign
      ci_HeaderLength : Int := 8;   // Message header length
      ci_BodyLengthPosition : Int := 4;   // Position in header where message body length value starts
      ci_DestinationIDPosition : Int := 2;   // Position in header where destination ID
      ci_SourceIDPosition : Int := 1;   // Position in header where source ID
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	18/01/2023  | 1.0       | S. Nikodem   | Release TIA 17                 | DHL Munich 2023
	31/08/2023  | 2.0       | M.Diebel     | Added security to check message size 
	18/12/2023  | 2.1       | S. Nikodem   | On-site update 
	18/12/2023  | 2.2       | S. Nikodem   | Watchdog
	19/12/2023  | 2.3       | S. Nikodem   | 
	13/03/2023  | 2.4       | S. Nieswiec  | Updated for new Baseline
	02/05/2024  | 2.5       | J.Majer      | Datatype conversions changed from automatic to explicit, to accomodate IEC 61131-3 standard
	
	*) 
	
	REGION 1 – Update FIFO header status bits
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOReceiveStatus,
	              qx_Error => #ss_Status.FIFOReceiveError,
	              qx_Warning => #ss_Status.FIFOReceiveWarning,
	              iqv_Data := #s_UDT_MessageArray,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 2 – Maximum number of message arrays elements
	    
	    #si_MaximumMessageLength := "FC_GetNrOfArrayEl"(iv_Array := #s_UDT_MessageArray.Bytes);
	    
	END_REGION
	
	REGION 3 – Receive enable
	    
	    // Allow receiving if the connection is established and there are no FIFO errors.
	    #ss_TRCV.Enable :=
	    #ix_EnableReceive
	    AND NOT #ss_Status.FIFOReceiveError;
	    
	END_REGION
	
	REGION 4 – Receive data
	    
	    //Reset old data
	    #ss_TRCV.Data := #ss_TRCV_empty.Data;
	    #sx_ValidMessage := False;
	    #sx_Watchdog := False;
	    
	    // Data received in an ADHOC mode - data available immediately.
	    #s_FB_TRCV(EN_R := #ss_TRCV.Enable,
	               ID := #i_UDT_Connection.ID,
	               LEN := 0,
	               ADHOC := TRUE,
	               NDR => #ss_TRCV.NDR,
	               BUSY => #ss_TRCV.Busy,
	               ERROR => #ss_TRCV.Error,
	               STATUS => #ss_TRCV.Status,
	               RCVD_LEN => #ss_TRCV.ReceivedLength,
	               DATA := #ss_TRCV.Data);
	    
	END_REGION
	
	REGION 5 – Received data handling
	    
	    // Receiving data was successful.
	    IF #ss_TRCV.NDR
	        AND NOT #ss_TRCV.Busy
	        AND NOT #ss_TRCV.Error
	        AND #ss_TRCV.ReceivedLength > 0
	    THEN
	        
	        REGION 5.1 – Telegram handling
	            
	            FOR #ti_LC_TelegamBytes := 0 TO (UDINT_TO_INT(#ss_TRCV.ReceivedLength) - 1) DO
	                
	                // First termination sign found.
	                IF (#ss_TRCV.Data[#ti_LC_TelegamBytes] = #cb_SOM)
	                    AND ((#ti_LC_TelegamBytes + #ci_BodyLengthPosition + 1) <= "FC_GetNrOfArrayEl"(#ss_TRCV.Data))
	                THEN
	                    
	                    // Get the length of the telegram by extracting the body length from the telegram header. 
	                    #ta_MessageData[0] := #ss_TRCV.Data[#ti_LC_TelegamBytes + #ci_BodyLengthPosition];
	                    #ta_MessageData[1] := #ss_TRCV.Data[#ti_LC_TelegamBytes + #ci_BodyLengthPosition + 1];
	                    
	                    #sdi_SerializePosition := 0;
	                    #si_SerializeStatus := Deserialize(SRC_ARRAY := #ta_MessageData,
	                                                       DEST_VARIABLE => #si_TelegramLength,
	                                                       POS := #sdi_SerializePosition);
	                    
	                    //Check if telegram lenght is correct
	                    IF #ti_LC_TelegamBytes + #si_TelegramLength + #ci_HeaderLength < "FC_GetNrOfArrayEl"(#ss_TRCV.Data) THEN
	                        
	                        //Check if on the end of the telegram is the end sign
	                        ////Watch dog
	                        IF (#ss_TRCV.Data[#ti_LC_TelegamBytes + #ci_HeaderLength] = #cb_EOM)
	                            AND (#si_TelegramLength = 0)
	                        THEN
	                            
	                            // Get the number of the messages from the telegram header. 
	                            #ta_MessageData[0] := #ss_TRCV.Data[#ti_LC_TelegamBytes + #ci_BodyLengthPosition + 2];
	                            #ta_MessageData[1] := #ss_TRCV.Data[#ti_LC_TelegamBytes + #ci_BodyLengthPosition + 3];
	                            
	                            #sdi_SerializePosition := 0;
	                            #si_SerializeStatus := Deserialize(SRC_ARRAY := #ta_MessageData,
	                                                               DEST_VARIABLE => #si_MessagesNumber,
	                                                               POS := #sdi_SerializePosition);
	                            
	                            IF #si_MessagesNumber = 0 THEN
	                                
	                                #sx_Watchdog := True;
	                                #sx_ValidMessage := TRUE;
	                                
	                            END_IF;
	                            
	                        ELSIF
	                            (#ss_TRCV.Data[#ti_LC_TelegamBytes + #si_TelegramLength + #ci_HeaderLength] = #cb_EOM) THEN
	                            
	                            //Check IF the source AND destination node ID are correct
	                            IF (BYTE_TO_INT(#ss_TRCV.Data[#ti_LC_TelegamBytes + #ci_SourceIDPosition]) = #ii_SourceID)
	                                AND (BYTE_TO_INT(#ss_TRCV.Data[#ti_LC_TelegamBytes + #ci_DestinationIDPosition]) = #ii_DestinationID)
	                            THEN
	                                
	                                // Get the number of the messages from the telegram header. 
	                                #ta_MessageData[0] := #ss_TRCV.Data[#ti_LC_TelegamBytes + #ci_BodyLengthPosition + 2];
	                                #ta_MessageData[1] := #ss_TRCV.Data[#ti_LC_TelegamBytes + #ci_BodyLengthPosition + 3];
	                                
	                                #sdi_SerializePosition := 0;
	                                #si_SerializeStatus := Deserialize(SRC_ARRAY := #ta_MessageData,
	                                                                   DEST_VARIABLE => #si_MessagesNumber,
	                                                                   POS := #sdi_SerializePosition);
	                                
	                                IF (#si_MessagesNumber > 0) AND (#si_MessagesNumber < 100) THEN
	                                    
	                                    //Initial value
	                                    //Telegram offset
	                                    #si_Offset := #ci_HeaderLength + #ti_LC_TelegamBytes;
	                                    
	                                    REGION 5.2 – Messages handling
	                                        
	                                        FOR #ti_Loop_MessageCounter := 1 TO #si_MessagesNumber DO
	                                            
	                                            IF (#si_Offset + 3) < "FC_GetNrOfArrayEl"(#ss_TRCV.Data) THEN
	                                                
	                                                //Copy ID - word 
	                                                #s_UDT_MessageArray.Bytes[0] := #ss_TRCV.Data[#si_Offset];
	                                                #s_UDT_MessageArray.Bytes[1] := #ss_TRCV.Data[#si_Offset + 1];
	                                                
	                                                // Copy data length - word
	                                                #s_UDT_MessageArray.Bytes[2] := #ss_TRCV.Data[#si_Offset + 2];
	                                                #s_UDT_MessageArray.Bytes[3] := #ss_TRCV.Data[#si_Offset + 3];
	                                                
	                                                #ta_MessageData[0] := #ss_TRCV.Data[#si_Offset + 2];
	                                                #ta_MessageData[1] := #ss_TRCV.Data[#si_Offset + 3];
	                                                
	                                                #sdi_SerializePosition := 0;
	                                                #si_SerializeStatus := Deserialize(SRC_ARRAY := #ta_MessageData,
	                                                                                   DEST_VARIABLE => #si_MessageLength,
	                                                                                   POS := #sdi_SerializePosition);
	                                                
	                                                //Copy data - byte
	                                                IF #si_MessageLength > 0 THEN
	                                                    
	                                                    FOR #ti_Loop_MessageLength := 0 TO #si_MessageLength DO
	                                                        
	                                                        #s_UDT_MessageArray.Bytes[4 + #ti_Loop_MessageLength] := #ss_TRCV.Data[#si_Offset + 4 + #ti_Loop_MessageLength];
	                                                        
	                                                    END_FOR;
	                                                    //Save last sign positions from message
	                                                    #si_Offset := #si_Offset + 4 + #si_MessageLength;
	                                                    
	                                                ELSIF #si_MessageLength = 0 THEN
	                                                    
	                                                    #si_Offset := #si_Offset + 4;
	                                                    
	                                                END_IF;
	                                                
	                                                //Write message to Fifo memory
	                                                // Mode 'W' - Write FIFO record.
	                                                "FC_Fifo"(ic_Mode := 'W',
	                                                          qUDT_Status => #ss_Status.FIFOReceiveStatus,
	                                                          qx_Error => #ss_Status.FIFOReceiveError,
	                                                          qx_Warning => #ss_Status.FIFOReceiveWarning,
	                                                          iqv_Data := #s_UDT_MessageArray,
	                                                          iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	                                                          iqv_DataBuffer := #iqs_FifoData);
	                                                
	                                            ELSE
	                                                #iq_UDT_Statistics.InvalidMsgLength += 1;
	                                            END_IF;
	                                            
	                                        END_FOR;
	                                        
	                                        //Set varaible valid message
	                                        #sx_ValidMessage := True;
	                                        
	                                        //Exit loop
	                                        EXIT;
	                                        
	                                    END_REGION
	                                    
	                                ELSE
	                                    
	                                    #iq_UDT_Statistics.InvalidMsgNumber += 1;
	                                END_IF;
	                            ELSE
	                                #iq_UDT_Statistics.InvalidID += 1;
	                            END_IF;
	                            
	                        ELSE
	                            #iq_UDT_Statistics.InvalidEndSign += 1;
	                        END_IF;
	                    ELSE
	                        #iq_UDT_Statistics.InvalidTelegramLength += 1;
	                    END_IF;
	                END_IF;
	            END_FOR;
	            
	            //Copy invalide meessage to base
	            IF NOT #sx_ValidMessage THEN
	                
	                #iq_UDT_Statistics.InvalidMsg += 1;
	                
	                IF #si_InvalidMessages > 99 THEN
	                    #si_InvalidMessages := 0;
	                END_IF;
	                
	                //Save invalid data
	                #sa_Invalid_Messages[#si_InvalidMessages].Data := #ss_TRCV.Data;
	                #si_InvalidMessages += 1;
	                
	            END_IF;
	            
	        END_REGION
	        
	    END_IF;
	    
	END_REGION
	
	REGION 6 – Status
	    
	    REGION 6.1 - Block status
	        
	        // Receive error.
	        #ss_Status.ReceiveError := #ss_TRCV.Error;
	        
	        // Parametrization collective error output.
	        #qx_Error :=
	        #ss_Status.FIFOReceiveError
	        OR #ss_Status.ReceiveError;
	        
	        // Parametrization collective warning output.
	        #qx_Warning := #ss_Status.FIFOReceiveWarning;
	        
	    END_REGION
	    
	    REGION 6.2 - Error code preparation
	        
	        IF (#ss_TRCV.#Status > 16#8000)
	            OR (#ss_TRCV.#Status = 16#0)
	        THEN
	            #ss_Status.ErrorCode.TRCV := #ss_TRCV.#Status;
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Sort_MaintenanceCounters"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 121
// END_ATTRIBUTES
   VAR_INPUT 
      ilr_PeriodConfig { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Configuration of the period how often the message should be sent [sec]
      i_UDT_ConveyorInterface { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorInterface";   // Input conveyor interface structrue
      i_UDT_EquipmentNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EquipmentNumber";   // Item number
      ii_SourceNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // ID Source Node
      ii_DestinationNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // ID Destination Node
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block error occurred
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block warning occurred
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Message number
   END_VAR

   VAR 
      s_UDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message array byte
      s_UDT_MessageHeader { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MFCSortMessageHeader";   // Message header
      ss_MessageBody { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Message body
         MsgID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Message ID
         MsgLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Message length
         Group { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Group part of item location
         Node { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Node part of item location
         RunningTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DWord;   // Motor running time in seconds
         DistanceTravelled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DWord;   // Conveyor distance travelled in mm
         "Start-Stop" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DWord;   // Amount of start / stop actions
         Eom { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // End of message
      END_STRUCT;
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //  FIFO error
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO warning
         InvalidMessageArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message array is too short for message
         InvalidTimeInterval { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat time interval lower than zero
      END_STRUCT;
      s_F_TRIG_ConveyorStop {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger Conveyor stop
      s_R_TRIG_ConveyorStart {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger Conveyor start
      sdi_SerializePosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Position in array where serialize finished writing data +1
      si_MaximumMessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum number of elements in message array
      si_SerializeStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Function serialize status
      slr_RunningTimeMS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Conveyor running time [ms]
      sdi_DistanceTraveled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Distance traveled by conveyor
      sdi_StartStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Value of change conveyor state from start to stop and from stop to start
      sdi_RunningTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Conveyor running time [s]
      slr_PeriodMS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Period to send message [ms]
      sx_SendMessage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send message to MFC
   END_VAR

   VAR CONSTANT 
      ci_MessageLength : Word := 16#0014;   // 10#0020 = 16#0014 - Message length
      ci_Som : Byte := 16#FD;   // Start of message
      ci_Eom : Byte := 16#FE;   // End of message
      ci_MsgID : Word := 16#00CE;   // 10#0206 = 16#00CE - Message ID
      ci_MsgLength : Word := 16#0010;   // 10#0016 = 16#0010 - Message length
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	05/01/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	09/01/2023  | 1.1       | M. Diebel    | Release TIA 17 | Convert sek from input on ms
	26/02/2024  | 1.2       | M. Diebel    | Release TIA 17 | Calculate absolute displacement 
	13/03/2023  | 1.3       | S. Nieswiec  | Updated for new Baseline
	02/05/2024  | 1.4       | J.Majer      | Datatype conversions changed from automatic to explicit, to accomodate IEC 61131-3 standard
	
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOStatus,
	              qx_Error => #ss_Status.FIFOError,
	              qx_Warning => #ss_Status.FIFOWarning,
	              iqv_Data := #s_UDT_MessageArray,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 2 – Data preparation
	    
	    // Maintenance counter message is used to inform the MFC about one of three values. When one of them exceed the configured one, message is prepared and sent.
	    // Values which program is counting :
	    // - distance traveled by conveyor,
	    // - change the state of the conveyor ( stop --> start and start --> stop)
	    // - running time of the conveyor.
	    
	    // Calculate conveyor traveled distance.
	    #sdi_DistanceTraveled += ABS(#i_UDT_ConveyorInterface.Displacement) * 10;
	    
	    // Calculate start-stop.
	    #s_R_TRIG_ConveyorStart(CLK := #i_UDT_ConveyorInterface.RunFwd OR #i_UDT_ConveyorInterface.RunRvs);
	    #s_F_TRIG_ConveyorStop(CLK := #i_UDT_ConveyorInterface.RunRvs OR #i_UDT_ConveyorInterface.RunFwd);
	    
	    // Increment counter on the change of the conveyor's state.
	    IF #s_R_TRIG_ConveyorStart.Q
	        OR #s_F_TRIG_ConveyorStop.Q
	    THEN
	        #sdi_StartStop += 1;
	    END_IF;
	    
	    // Calculate running time.
	    IF #i_UDT_ConveyorInterface.RunFwd
	        OR #i_UDT_ConveyorInterface.RunRvs
	    THEN
	        #slr_RunningTimeMS += "DB_Memory".PrevCycleTime;
	        
	        IF #slr_RunningTimeMS >= 1000
	        THEN
	            #sdi_RunningTime += 1;
	            #slr_RunningTimeMS -= 1000;
	        END_IF;
	        
	    END_IF;
	    
	    //Period timer 
	    #slr_PeriodMS += "DB_Memory".PrevCycleTime;
	    
	    #sx_SendMessage := #ilr_PeriodConfig * 1000.0 < #slr_PeriodMS;  //Convert sek from input on ms and compare to period
	    
	END_REGION
	
	REGION 3 – Message array size validation 
	    
	    // Get size of the array.
	    #si_MaximumMessageLength := "FC_GetNrOfArrayEl"(#s_UDT_MessageArray.Bytes);
	    
	    // Message array size validation. 
	    #ss_Status.InvalidMessageArraySize := WORD_TO_INT(#ci_MessageLength) > #si_MaximumMessageLength;
	    
	END_REGION
	
	
	REGION 4 – Message preparation 
	    
	    // FIFO full check.
	    IF NOT #iq_UDT_FifoHeader.Status.Full
	    THEN
	        // Errors and send pulse check.
	        IF NOT #ss_Status.FIFOError
	            AND NOT #ss_Status.InvalidMessageArraySize
	            AND #sx_SendMessage
	        THEN
	            
	            //Reset counter
	            
	            
	            REGION 4.1 – Header preparation 
	                
	                // Check sequence number. If it is equal or greater than 255 reset it to 1.
	                IF #iqdi_MessageSequenceNumber <= 255
	                THEN
	                    #iqdi_MessageSequenceNumber += 1;
	                ELSE
	                    #iqdi_MessageSequenceNumber := 1;
	                END_IF;
	                
	                // Write parts of the header into structure.
	                #s_UDT_MessageHeader.SOM := #ci_Som;
	                #s_UDT_MessageHeader.SourceNode := INT_TO_BYTE(#ii_SourceNode);
	                #s_UDT_MessageHeader.DestinationNode := INT_TO_BYTE(#ii_DestinationNode);
	                #s_UDT_MessageHeader.SeqNumber := INT_TO_BYTE(#iqdi_MessageSequenceNumber);
	                #s_UDT_MessageHeader.DataLength := #ci_MessageLength;
	                #s_UDT_MessageHeader.NumMsg := 1;
	                
	                // Write parts of the body into structure.
	                #ss_MessageBody.MsgID := #ci_MsgID;
	                #ss_MessageBody.MsgLength := #ci_MsgLength;
	                #ss_MessageBody.Group := INT_TO_WORD(#i_UDT_EquipmentNumber.Group);
	                #ss_MessageBody.Node := INT_TO_WORD(#i_UDT_EquipmentNumber.Node);
	                #ss_MessageBody.RunningTime := DINT_TO_WORD(#sdi_RunningTime);
	                #ss_MessageBody.DistanceTravelled := DINT_TO_WORD(#sdi_DistanceTraveled);
	                #ss_MessageBody."Start-Stop" := DINT_TO_WORD(#sdi_StartStop);
	                #ss_MessageBody.Eom := #ci_Eom;
	                
	            END_REGION
	            
	            REGION 4.2 – Convert message into array of bytes
	                
	                // Initialize the header serialize position and convert header structure into array of bytes.
	                #sdi_SerializePosition := 0;
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #s_UDT_MessageHeader,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	                // Initialize the body serialize position and convert header structure into array of bytes
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #ss_MessageBody,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	            END_REGION
	            
	            REGION 4.3 – Write message into the FIFO buffer
	                
	                // Mode 'W' - Write FIFO record.
	                "FC_Fifo"(ic_Mode := 'W',
	                          qUDT_Status => #ss_Status.FIFOStatus,
	                          qx_Error => #ss_Status.FIFOError,
	                          qx_Warning => #ss_Status.FIFOWarning,
	                          iqv_Data := #s_UDT_MessageArray,
	                          iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	                          iqv_DataBuffer := #iqs_FifoData);
	                
	            END_REGION
	            
	            //Reset data
	            #sdi_DistanceTraveled := 0;
	            #sdi_StartStop := 0;
	            #sdi_RunningTime := 0;
	            //Reset period caouter 
	            #slr_PeriodMS := 0;
	            
	        END_IF;
	    ELSE
	        // If FIFO is full set FIFO main and FIFO full errors.
	        #ss_Status.FIFOError := TRUE;
	        #ss_Status.FIFOStatus.FifoFull := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Status
	    
	    // Parametrization collective error output.
	    #qx_Error :=
	    #ss_Status.FIFOError
	    OR #ss_Status.InvalidTimeInterval
	    OR #ss_Status.InvalidMessageArraySize;
	    
	    // Parametrization collective warning output.
	    #qx_Warning := #ss_Status.FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Sort_ParcelCounter"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 122
// END_ATTRIBUTES
   VAR_INPUT 
      iui_LocationIdentifier { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // SNCY finger identifier
      ix_Trigger { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // A trigger that active message generation.
      ii_SourceNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // ID Source Node
      ii_DestinationNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // ID Destination Node
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block error occurred
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block warning occurred
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Message number
   END_VAR

   VAR 
      s_UDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message array byte
      s_UDT_MessageHeader { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MFCSortMessageHeader";   // Message header
      ss_MessageBody { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Message body
         MsgID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Message ID
         MsgLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Message length
         LocationIdentifier { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Location Identifier
         Counts { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Counts
         Eom { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // End of message
      END_STRUCT;
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //  FIFO error
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO warning
         InvalidMessageArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message array is too short for message
         InvalidTimeInterval { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat time interval lower than zero
      END_STRUCT;
      R_TRIG_SensorActive {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger from sensor
      sdi_SerializePosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Position in array where serialize finished writing data +1
      si_MaximumMessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum number of elements in message array
      si_SerializeStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Function serialize status
   END_VAR

   VAR CONSTANT 
      ci_MessageLength : Word := 16#0008;   // 10#0008 = 16#0008 - Message length
      ci_Som : Byte := 16#FD;   // Start of message
      ci_Eom : Byte := 16#FE;   // End of message
      ci_MsgID : Word := 16#00CD;   // 10#0205 = 16#00CD - Message ID
      ci_MsgLength : Word := 16#0004;   // 10#0004 = 16#0004 - Message length
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	05/01/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec  | Updated for new Baseline
	02/05/2024  | 4.2       | J.Majer      | Datatype conversions changed from automatic to explicit, to accomodate IEC 61131-3 standard
	
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOStatus,
	              qx_Error => #ss_Status.FIFOError,
	              qx_Warning => #ss_Status.FIFOWarning,
	              iqv_Data := #s_UDT_MessageArray,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 2 – Data preparation
	    
	    #R_TRIG_SensorActive(CLK := #ix_Trigger);
	    
	END_REGION
	
	REGION 3 – Message array size validation 
	    
	    // Get size of the array.
	    #si_MaximumMessageLength := "FC_GetNrOfArrayEl"(#s_UDT_MessageArray.Bytes);
	    
	    // Message array size validation. 
	    #ss_Status.InvalidMessageArraySize := WORD_TO_INT(#ci_MessageLength) > #si_MaximumMessageLength;
	    
	END_REGION
	
	
	REGION 4 – Message preparation 
	    
	    // FIFO full check.
	    IF NOT #iq_UDT_FifoHeader.Status.Full
	    THEN
	        // Errors and send pulse check.
	        IF NOT #ss_Status.FIFOError
	            AND NOT #ss_Status.InvalidMessageArraySize
	            AND #R_TRIG_SensorActive.Q
	        THEN
	            
	            REGION 4.1 – Header preparation 
	                
	                // Check sequence number. If it is equal or greater than 255 reset it to 1.
	                IF #iqdi_MessageSequenceNumber <= 255
	                THEN
	                    #iqdi_MessageSequenceNumber += 1;
	                ELSE
	                    #iqdi_MessageSequenceNumber := 1;
	                END_IF;
	                
	                // Write parts of the header into structure.
	                #s_UDT_MessageHeader.SOM := #ci_Som;
	                #s_UDT_MessageHeader.SourceNode := INT_TO_BYTE(#ii_SourceNode);
	                #s_UDT_MessageHeader.DestinationNode := INT_TO_BYTE(#ii_DestinationNode);
	                #s_UDT_MessageHeader.SeqNumber := INT_TO_BYTE(#iqdi_MessageSequenceNumber);
	                #s_UDT_MessageHeader.DataLength := #ci_MessageLength;
	                #s_UDT_MessageHeader.NumMsg := 1;
	                
	                // Write parts of the body into structure.
	                #ss_MessageBody.MsgID := #ci_MsgID;
	                #ss_MessageBody.MsgLength := #ci_MsgLength;
	                #ss_MessageBody.LocationIdentifier := DINT_TO_WORD(#iui_LocationIdentifier);
	                #ss_MessageBody.Counts := 1;
	                #ss_MessageBody.Eom := #ci_Eom;
	                
	            END_REGION
	            
	            REGION 4.2 – Convert message into array of bytes
	                
	                // Initialize the header serialize position and convert header structure into array of bytes.
	                #sdi_SerializePosition := 0;
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #s_UDT_MessageHeader,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	                // Initialize the body serialize position and convert header structure into array of bytes
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #ss_MessageBody,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	            END_REGION
	            
	            REGION 4.3 – Write message into the FIFO buffer
	                
	                // Mode 'W' - Write FIFO record.
	                "FC_Fifo"(ic_Mode := 'W',
	                          qUDT_Status => #ss_Status.FIFOStatus,
	                          qx_Error => #ss_Status.FIFOError,
	                          qx_Warning => #ss_Status.FIFOWarning,
	                          iqv_Data := #s_UDT_MessageArray,
	                          iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	                          iqv_DataBuffer := #iqs_FifoData);
	                
	            END_REGION
	            
	        END_IF;
	    ELSE
	        // If FIFO is full set FIFO main and FIFO full errors.
	        #ss_Status.FIFOError := TRUE;
	        #ss_Status.FIFOStatus.FifoFull := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Status
	    
	    // Parametrization collective error output.
	    #qx_Error :=
	    #ss_Status.FIFOError
	    OR #ss_Status.InvalidTimeInterval
	    OR #ss_Status.InvalidMessageArraySize;
	    
	    // Parametrization collective warning output.
	    #qx_Warning := #ss_Status.FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Sort_ScanReset"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 123
// END_ATTRIBUTES
   VAR_INPUT 
      is_ObjectID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[10];   // Parcel identifier
      ii_SourceNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // ID Source Node
      ii_DestinationNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // ID Destination Node
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block error occurred
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block warning occurred
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Message number
   END_VAR

   VAR 
      ss_FB_HeartbeatPulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Pulse";   // Heartbeat send pulse generator
      s_UDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message array byte
      s_UDT_MessageHeader { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MFCSortMessageHeader";   // Message header
      ss_MessageBody { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Message body
         MsgID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Message ID
         MsgLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Message length
         ObjectID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DWord;   // Parcel identifier
         Eom { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // End of message
      END_STRUCT;
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //  FIFO error
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO warning
         InvalidMessageArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message array is too short for message
         InvalidTimeInterval { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat time interval lower than zero
      END_STRUCT;
      sdi_SerializePosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Position in array where serialize finished writing data +1
      si_MaximumMessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum number of elements in message array
      si_SerializeStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Function serialize status
      ss_Old_Object_ID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[10];   // Value from previous PLC cycle
      sx_NewData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - send a message to the MFC
      sa_EmptyObjectID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..10] of Byte;   // Parcel identifier
   END_VAR

   VAR_TEMP 
      tudi_Temp : UDInt;
   END_VAR

   VAR CONSTANT 
      ci_MessageLength : Word := 16#0006;   // 10#0006 = 16#0006 - Message length
      ci_Som : Byte := 16#FD;   // Start of message
      ci_Eom : Byte := 16#FE;   // End of message
      ci_MsgID : Word := 16#00CA;   // 10#0202 = 16#00CA - Message ID
      ci_MsgLength : Word := 16#0002;   // 10#0002 = 16#0002 - Message length
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	05/01/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec  | Updated for new Baseline
	02/05/2024  | 1.2       | J.Majer      | Datatype conversions changed from automatic to explicit, to accomodate IEC 61131-3 standard
	
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOStatus,
	              qx_Error => #ss_Status.FIFOError,
	              qx_Warning => #ss_Status.FIFOWarning,
	              iqv_Data := #s_UDT_MessageArray,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 2 – Data preparation
	    
	    //Send message when is new parcel
	    #sx_NewData := (#is_ObjectID <> #ss_Old_Object_ID) AND NOT (#is_ObjectID = '0');
	    // Save last value
	    #ss_Old_Object_ID := #is_ObjectID;
	    
	END_REGION
	
	REGION 3 – Message array size validation 
	    
	    // Get size of the array.
	    #si_MaximumMessageLength := "FC_GetNrOfArrayEl"(#s_UDT_MessageArray.Bytes);
	    
	    // Message array size validation. 
	    #ss_Status.InvalidMessageArraySize := WORD_TO_INT(#ci_MessageLength) > #si_MaximumMessageLength;
	    
	END_REGION
	
	
	REGION 4 – Message preparation 
	    
	    // FIFO full check.
	    IF NOT #iq_UDT_FifoHeader.Status.Full
	    THEN
	        // Errors and send pulse check.
	        IF NOT #ss_Status.FIFOError
	            AND NOT #ss_Status.InvalidMessageArraySize
	            AND #sx_NewData
	        THEN
	            
	            REGION 4.1 – Header preparation 
	                
	                // Check sequence number. If it is equal or greater than 255 reset it to 1.
	                IF #iqdi_MessageSequenceNumber <= 255
	                THEN
	                    #iqdi_MessageSequenceNumber += 1;
	                ELSE
	                    #iqdi_MessageSequenceNumber := 1;
	                END_IF;
	                
	                // Write parts of the header into structure.
	                #s_UDT_MessageHeader.SOM := #ci_Som;
	                #s_UDT_MessageHeader.SourceNode := INT_TO_BYTE(#ii_SourceNode);
	                #s_UDT_MessageHeader.DestinationNode := INT_TO_BYTE(#ii_DestinationNode);
	                #s_UDT_MessageHeader.SeqNumber := INT_TO_BYTE(#iqdi_MessageSequenceNumber);
	                #s_UDT_MessageHeader.DataLength := #ci_MessageLength;
	                #s_UDT_MessageHeader.NumMsg := 1;
	                
	                //Convert string value to UDINT
	                #tudi_Temp := STRING_TO_UDINT(#is_ObjectID);
	                
	                // Write parts of the body into structure.
	                #ss_MessageBody.MsgID := #ci_MsgID;
	                #ss_MessageBody.MsgLength := #ci_MsgLength;
	                #ss_MessageBody.ObjectID := UDINT_TO_DWORD(#tudi_Temp);
	                #ss_MessageBody.Eom := #ci_Eom;
	                
	            END_REGION
	            
	            REGION 4.2 – Convert message into array of bytes
	                
	                // Initialize the header serialize position and convert header structure into array of bytes.
	                #sdi_SerializePosition := 0;
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #s_UDT_MessageHeader,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	                // Initialize the body serialize position and convert header structure into array of bytes
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #ss_MessageBody,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	            END_REGION
	            
	            REGION 4.3 – Write message into the FIFO buffer
	                
	                // Mode 'W' - Write FIFO record.
	                "FC_Fifo"(ic_Mode := 'W',
	                          qUDT_Status => #ss_Status.FIFOStatus,
	                          qx_Error => #ss_Status.FIFOError,
	                          qx_Warning => #ss_Status.FIFOWarning,
	                          iqv_Data := #s_UDT_MessageArray,
	                          iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	                          iqv_DataBuffer := #iqs_FifoData);
	                
	            END_REGION
	            
	        END_IF;
	    ELSE
	        // If FIFO is full set FIFO main and FIFO full errors.
	        #ss_Status.FIFOError := TRUE;
	        #ss_Status.FIFOStatus.FifoFull := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Status
	    
	    // Parametrization collective error output.
	    #qx_Error :=
	    #ss_Status.FIFOError
	    OR #ss_Status.InvalidTimeInterval
	    OR #ss_Status.InvalidMessageArraySize;
	    
	    // Parametrization collective warning output.
	    #qx_Warning := #ss_Status.FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Sort_SystemStatus"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 125
// END_ATTRIBUTES
   VAR_INPUT 
      ii_SystemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // 1 - System stopped, 2 - System running
      iw_SystemMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Bit value according to the documentation
      iui_LocationIdentifier { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Location Identifier
      ii_SourceNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // ID Source Node
      ii_DestinationNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // ID Destination Node
      ix_SendAllStatuses { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - update all the statuses
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block error occurred
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block warning occurred
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Message number
   END_VAR

   VAR 
      s_UDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message array byte
      s_UDT_MessageHeader { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MFCSortMessageHeader";   // Message header
      s_F_TRIG_SendAllStatuses {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger from signal send all statuses
      ss_MessageBody { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Message body
         MsgID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Message ID
         MsgLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Message length
         LocationIdentifier { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Location Identifier
         SystemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // System status
         SystemMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // System mode
         Eom { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // End of message
         Test { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word := 16#0011;
         Test_1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte := 16#22;
      END_STRUCT;
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //  FIFO error
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO warning
         InvalidMessageArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message array is too short for message
         InvalidTimeInterval { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat time interval lower than zero
      END_STRUCT;
      sw_SystemMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word := 0;   // Bit value according to the documentation
      sw_Old_SystemMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Data from previous PLC cycle: Maximum number of elements in message array
      sdi_SerializePosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Position in array where serialize finished writing data +1
      si_MaximumMessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum number of elements in message array
      si_SerializeStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Function serialize status
      si_SystemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 0;   // 1 - System stopped, 2 - System running
      si_Old_SystemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 0;   // Data from previous PLC cycle: 0 - System stopped, 1 - System running
      sx_NewData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - send a message to the MFC
   END_VAR

   VAR CONSTANT 
      ci_MessageLength : Word := 16#0009;   // 10#0009 = 16#0009 - Message length
      ci_Som : Byte := 16#FD;   // Start of message
      ci_Eom : Byte := 16#FE;   // End of message
      ci_MsgID : Word := 16#00CC;   // 10#0204 = 16#00CC - Message ID
      ci_MsgLength : Word := 16#0005;   // 10#0005 = 16#0005 - Message length
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	21/07/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	23/08/2023  | 1.1       | S. Theocharis| Serialise byte issue 0 - quick fix 
	19/10/2023  | 1.2       | S. Nikodem   | Added "ix_SendAllStatuses" input and update for Serialize structure
	13/03/2023  | 1.3       | S. Nieswiec  | Updated for new Baseline
	02/05/2024  | 1.4       | J.Majer      | Datatype conversions changed from automatic to explicit, to accomodate IEC 61131-3 standard
	
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOStatus,
	              qx_Error => #ss_Status.FIFOError,
	              qx_Warning => #ss_Status.FIFOWarning,
	              iqv_Data := #s_UDT_MessageArray,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 2 – Data preparation
	    
	    // Prepare trigger
	    #s_F_TRIG_SendAllStatuses(CLK := #ix_SendAllStatuses);
	    
	    // Data preparation
	    //  1 - System stopped, 2 - System running
	    #si_SystemStatus := #ii_SystemStatus;
	    // Bit value according to the documentation
	    #sw_SystemMode := #iw_SystemMode;
	    
	    //Check if the data from the previous PLC cycle differs, if so, send a message to the MFC.
	    #sx_NewData := (#si_Old_SystemStatus <> #si_SystemStatus) OR (#sw_Old_SystemMode <> #sw_SystemMode) OR #s_F_TRIG_SendAllStatuses.Q;
	    
	    // Copy data
	    #si_Old_SystemStatus := #si_SystemStatus;
	    #sw_Old_SystemMode := #sw_SystemMode;
	    
	END_REGION
	
	REGION 3 – Message array size validation 
	    
	    // Get size of the array.
	    #si_MaximumMessageLength := "FC_GetNrOfArrayEl"(#s_UDT_MessageArray.Bytes);
	    
	    // Message array size validation. 
	    #ss_Status.InvalidMessageArraySize := WORD_TO_INT(#ci_MessageLength) > #si_MaximumMessageLength;
	    
	END_REGION
	
	REGION 4 – Message preparation 
	    
	    // FIFO full check.
	    IF NOT #iq_UDT_FifoHeader.Status.Full
	    THEN
	        // Errors and send pulse check.
	        IF NOT #ss_Status.FIFOError
	            AND NOT #ss_Status.InvalidMessageArraySize
	            AND #sx_NewData
	        THEN
	            
	            REGION 4.1 – Header preparation 
	                
	                // Check sequence number. If it is equal or greater than 255 reset it to 1.
	                IF #iqdi_MessageSequenceNumber <= 255
	                THEN
	                    #iqdi_MessageSequenceNumber += 1;
	                ELSE
	                    #iqdi_MessageSequenceNumber := 1;
	                END_IF;
	                
	                // Write parts of the header into structure.
	                // Write parts of the header into structure.
	                #s_UDT_MessageHeader.SOM := #ci_Som;
	                #s_UDT_MessageHeader.SourceNode := INT_TO_BYTE(#ii_SourceNode);
	                #s_UDT_MessageHeader.DestinationNode := INT_TO_BYTE(#ii_DestinationNode);
	                #s_UDT_MessageHeader.SeqNumber := INT_TO_BYTE(#iqdi_MessageSequenceNumber);
	                #s_UDT_MessageHeader.DataLength := #ci_MessageLength;
	                #s_UDT_MessageHeader.NumMsg := 1;
	                
	                // Write parts of the body into structure.
	                #ss_MessageBody.MsgID := #ci_MsgID;
	                #ss_MessageBody.MsgLength := #ci_MsgLength;
	                #ss_MessageBody.LocationIdentifier := DINT_TO_WORD(#iui_LocationIdentifier);
	                #ss_MessageBody.SystemStatus := INT_TO_BYTE(#si_SystemStatus);
	                #ss_MessageBody.SystemMode := #sw_SystemMode;
	                #ss_MessageBody.Eom := #ci_Eom;
	                
	            END_REGION
	            
	            REGION 4.2 – Convert message into array of bytes
	                
	                // Initialize the header serialize position and convert header structure into array of bytes.
	                #sdi_SerializePosition := 0;
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #s_UDT_MessageHeader,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #ss_MessageBody.MsgID,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #ss_MessageBody.MsgLength,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #ss_MessageBody.LocationIdentifier,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #ss_MessageBody.SystemStatus,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #ss_MessageBody.SystemMode,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #ss_MessageBody.Eom,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	            END_REGION
	            
	            REGION 4.3 – Write message into the FIFO buffer
	                
	                // Mode 'W' - Write FIFO record.
	                "FC_Fifo"(ic_Mode := 'W',
	                          qUDT_Status => #ss_Status.FIFOStatus,
	                          qx_Error => #ss_Status.FIFOError,
	                          qx_Warning => #ss_Status.FIFOWarning,
	                          iqv_Data := #s_UDT_MessageArray,
	                          iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	                          iqv_DataBuffer := #iqs_FifoData);
	                
	            END_REGION
	            
	        END_IF;
	    ELSE
	        // If FIFO is full set FIFO main and FIFO full errors.
	        #ss_Status.FIFOError := TRUE;
	        #ss_Status.FIFOStatus.FifoFull := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Status
	    
	    // Parametrization collective error output.
	    #qx_Error :=
	    #ss_Status.FIFOError
	    OR #ss_Status.InvalidTimeInterval
	    OR #ss_Status.InvalidMessageArraySize;
	    
	    // Parametrization collective warning output.
	    #qx_Warning := #ss_Status.FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Sort_TCPIPSend"
TITLE = FB_TCPIPSend
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : Communication
VERSION : 2.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 127
// END_ATTRIBUTES
//Function block to send data from TCPIP.
   VAR_INPUT 
      i_UDT_Connection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_Connection";   // Connection parameters
      ix_EnableSend { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when send is enable
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block error occurred
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block warning occurred
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoLowHeader : "UDT_FifoHeader";   // Low priority FIFO header
      iqs_FifoLowData : Variant;   // Low priority FIFO data
      iq_UDT_FifoMediumHeader : "UDT_FifoHeader";   // Medium priority FIFO header
      iqs_FifoMediumData : Variant;   // Medium priority FIFO data
      iq_UDT_FifoHighHeader : "UDT_FifoHeader";   // High priority FIFO header
      iqs_FifoHighData : Variant;   // High priority FIFO data
   END_VAR

   VAR 
      s_FB_TSEND {InstructionName := 'TSEND'; LibVersion := '4.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TSEND;   // Siemens "TSEND" block - to send the data over TCPIP socket
      s_UDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message
      ss_TSEND { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // TSEND block structure
         Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   //    TSEND - Status
         Request { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    TSEND - Request
         Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    TSEND - Busy
         Done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    TSEND - Done
         Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    TSEND - Error
      END_STRUCT;
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOLowPriorityStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";
         FIFOMedPriorityStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";
         FIFOHighPriorityStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";
         FIFOLowPriorityError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO low priority error
         FIFOLowPriorityWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO low priority warning
         FIFOMedPriorityError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO medium priority error
         FIFOMedPriorityWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO medium priority warning
         FIFOHighPriorityError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO high priority error
         FIFOHighPriorityWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO high priority warning
         SendError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send operation error
      END_STRUCT;
      sw_BodyLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Message body length
      sa_BodyLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..1] of Byte;
      si_MessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Message length
      sx_MessageReady { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message is ready to send
      sx_MessageRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message has been read
      sx_MessageReadRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request to read message
      sx_FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Summary FIFO error
      sdi_SerializePosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Position in array where serialize finished writing data +1
      si_SerializeStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Function serialize status
   END_VAR

   VAR CONSTANT 
      ci_HeaderLength : Int := 8;   // Message header length
      ci_BodyLengthPosition : Int := 4;   // Position in header where message body length value starts
      cdi_POS : DInt := 2;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	16/01/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec  | Updated for new Baseline
	*)                                                                               
	
	REGION 1 – Update FIFO header status bits
	    
	    // Mode 'S' - High priority FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOHighPriorityStatus,
	              qx_Error => #ss_Status.FIFOHighPriorityError,
	              qx_Warning => #ss_Status.FIFOHighPriorityWarning,
	              iqv_Data := #s_UDT_MessageArray,
	              iqUDT_FifoHeader := #iq_UDT_FifoHighHeader,
	              iqv_DataBuffer := #iqs_FifoHighData);
	    
	    // Mode 'S' - Medium priority FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOMedPriorityStatus,
	              qx_Error => #ss_Status.FIFOMedPriorityError,
	              qx_Warning => #ss_Status.FIFOMedPriorityWarning,
	              iqv_Data := #s_UDT_MessageArray,
	              iqUDT_FifoHeader := #iq_UDT_FifoMediumHeader,
	              iqv_DataBuffer := #iqs_FifoMediumData);
	    
	    // Mode 'S' - Low priority FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOLowPriorityStatus,
	              qx_Error => #ss_Status.FIFOLowPriorityError,
	              qx_Warning => #ss_Status.FIFOLowPriorityWarning,
	              iqv_Data := #s_UDT_MessageArray,
	              iqUDT_FifoHeader := #iq_UDT_FifoLowHeader,
	              iqv_DataBuffer := #iqs_FifoLowData);
	    
	END_REGION
	
	REGION 2 – FIFO header summary error 
	    
	    #sx_FIFOError :=
	    #ss_Status.FIFOHighPriorityError
	    OR #ss_Status.FIFOMedPriorityError
	    OR #ss_Status.FIFOLowPriorityError;
	    
	END_REGION
	
	REGION 3 – FIFO Read request
	    
	    #sx_MessageReadRequest :=
	    #ix_EnableSend
	    AND NOT #sx_FIFOError
	    AND NOT #ss_TSEND.Error
	    AND #ss_TSEND.Status = 16#7000;
	    
	END_REGION
	
	REGION 4 – Read the message from high priority FIFO data buffer
	    
	    IF #sx_MessageReadRequest
	        AND NOT #iq_UDT_FifoHighHeader.Status.Empty
	        AND NOT #sx_MessageRead
	    THEN
	        // Mode 'R' - Read high priority FIFO record.
	        "FC_Fifo"(ic_Mode := 'R',
	                  qUDT_Status => #ss_Status.FIFOHighPriorityStatus,
	                  qx_Error => #ss_Status.FIFOHighPriorityError,
	                  qx_Warning => #ss_Status.FIFOHighPriorityWarning,
	                  iqv_Data := #s_UDT_MessageArray,
	                  iqUDT_FifoHeader := #iq_UDT_FifoHighHeader,
	                  iqv_DataBuffer := #iqs_FifoHighData);
	        
	        #sx_MessageRead := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 5 – Read the message from medium priority FIFO data buffer
	    
	    IF #sx_MessageReadRequest
	        AND #iq_UDT_FifoHighHeader.Status.Empty
	        AND NOT #iq_UDT_FifoMediumHeader.Status.Empty
	        AND NOT #sx_MessageRead
	    THEN
	        // Mode 'R' - Read medium priority FIFO record.
	        "FC_Fifo"(ic_Mode := 'R',
	                  qUDT_Status => #ss_Status.FIFOMedPriorityStatus,
	                  qx_Error => #ss_Status.FIFOMedPriorityError,
	                  qx_Warning => #ss_Status.FIFOMedPriorityWarning,
	                  iqv_Data := #s_UDT_MessageArray,
	                  iqUDT_FifoHeader := #iq_UDT_FifoMediumHeader,
	                  iqv_DataBuffer := #iqs_FifoMediumData);
	        
	        #sx_MessageRead := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 6 – Read the message from low priority FIFO data buffer
	    
	    IF #sx_MessageReadRequest
	        AND #iq_UDT_FifoHighHeader.Status.Empty
	        AND #iq_UDT_FifoMediumHeader.Status.Empty
	        AND NOT #iq_UDT_FifoLowHeader.Status.Empty
	        AND NOT #sx_MessageRead
	    THEN
	        #sx_MessageRead := TRUE;
	        
	        // Mode 'R' - Read low priority FIFO record.
	        "FC_Fifo"(ic_Mode := 'R',
	                  qUDT_Status => #ss_Status.FIFOLowPriorityStatus,
	                  qx_Error => #ss_Status.FIFOLowPriorityError,
	                  qx_Warning => #ss_Status.FIFOLowPriorityWarning,
	                  iqv_Data := #s_UDT_MessageArray,
	                  iqUDT_FifoHeader := #iq_UDT_FifoLowHeader,
	                  iqv_DataBuffer := #iqs_FifoLowData);
	    END_IF;
	    
	END_REGION
	
	REGION 7 – Message length
	    
	    // Measuring the length of a read message.
	    IF #sx_MessageRead
	        AND NOT #sx_MessageReady
	    THEN
	        // Initialize the message length. 
	        #si_MessageLength := 0;
	        
	        // Get the length of the message by extracting the body length from the message header. 
	        #sa_BodyLength[0] := #s_UDT_MessageArray.Bytes[#ci_BodyLengthPosition];
	        #sa_BodyLength[1] := #s_UDT_MessageArray.Bytes[#ci_BodyLengthPosition + 1];
	        
	        #sdi_SerializePosition := 0;
	        #si_SerializeStatus := Deserialize(SRC_ARRAY := #sa_BodyLength,
	                                           DEST_VARIABLE => #sw_BodyLength,
	                                           POS := #sdi_SerializePosition);
	        
	        #si_MessageLength := WORD_TO_INT(#sw_BodyLength) + #ci_HeaderLength + 1; // Add body, header and tail
	        #sx_MessageReady := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 8 – Send request
	    
	    IF #sx_MessageRead
	        AND #sx_MessageReady
	    THEN
	        #ss_TSEND.Request := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 9 – Send data
	    
	    #s_FB_TSEND(REQ := #ss_TSEND.Request,
	                ID := #i_UDT_Connection.ID,
	                LEN := INT_TO_UDINT(#si_MessageLength),
	                DONE => #ss_TSEND.Done,
	                BUSY => #ss_TSEND.Busy,
	                ERROR => #ss_TSEND.Error,
	                STATUS => #ss_TSEND.Status,
	                DATA := #s_UDT_MessageArray);
	    
	    // Reset send request, message read and ready bits.
	    IF #ss_TSEND.Request
	        AND NOT #ss_TSEND.Busy
	        AND (#ss_TSEND.Done
	        OR #ss_TSEND.Status = 16#7000)
	    THEN
	        #ss_TSEND.Request := FALSE;
	        #sx_MessageRead := FALSE;
	        #sx_MessageReady := FALSE;
	    END_IF;
	    
	    // Reset send error and TSEND status after correctly sent message.
	    IF #ss_TSEND.Done
	    THEN
	        #ss_Status.SendError := FALSE;
	    END_IF;
	    
	    // Set send error and TSEND status if error occured.
	    IF #ss_TSEND.Error
	    THEN
	        #ss_Status.SendError := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 10 – Status
	    
	    // Parametrization collective error output.
	    #qx_Error :=
	    #sx_FIFOError
	    OR #ss_Status.SendError;
	    
	    // Parametrization collective warning output.
	    #qx_Warning :=
	    #ss_Status.FIFOHighPriorityWarning
	    OR #ss_Status.FIFOMedPriorityWarning
	    OR #ss_Status.FIFOLowPriorityWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Sort_VIDResponse"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 128
// END_ATTRIBUTES
   VAR_INPUT 
      ii_Object_ID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Parcel identifier
      i_ActualTimeDTL {InstructionName := 'DTL'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DTL;   // Actual date and time in DTL
      ii_SourceNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // ID Source Node
      ii_DestinationNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // ID Destination Node
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block error occurred
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block warning occurred
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Message number
   END_VAR

   VAR 
      s_UDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message array byte
      s_UDT_MessageHeader { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MFCSortMessageHeader";   // Message header
      ss_MessageBody { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Message body
         MsgID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Message ID
         MsgLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Message length
         ObjectID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Parcel identifier
         VID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Virtual Item Identifier
            Year { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DWord;   // Year
            Month { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Month
            Day { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Day
            ObjectID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // ObjectID
            Code1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Code1
            Code2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Code2
            Code3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Code3
            Code4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Code4
            Code5 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Code5
            Code6 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Code6
         END_STRUCT;
         Eom { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // End of message
      END_STRUCT;
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //  FIFO error
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO warning
         InvalidMessageArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message array is too short for message
         InvalidTimeInterval { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat time interval lower than zero
      END_STRUCT;
      sdi_SerializePosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Position in array where serialize finished writing data +1
      si_MaximumMessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum number of elements in message array
      si_SerializeStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Function serialize status
      ss_VID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Virtual Item Identifier
         Year { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DWord;   // Year
         Month { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Month
         Day { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Day
         ObjectID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // ObjectID
         Code1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Code1
         Code2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Code2
         Code3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Code3
         Code4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Code4
         Code5 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Code5
         Code6 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Code6
      END_STRUCT;
      si_Old_Object_ID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Value from previous PLC cycle
      sx_NewData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - send a message to the MFC
   END_VAR

   VAR CONSTANT 
      ci_MessageLength : Word := 16#0016;   // 10#0021 = 16#0016 - Message length
      ci_Som : Byte := 16#FD;   // Start of message
      ci_Eom : Byte := 16#FE;   // End of message
      ci_MsgID : Word := 16#00C9;   // 10#0201 = 16#00C9 - Message ID
      ci_MsgLength : Word := 16#0011;   // 10#0017 = 16#0011 - Message length
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	05/01/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec  | Updated for new Baseline
	02/05/2024  | 1.2       | J.Majer      | Datatype conversions changed from automatic to explicit, to accomodate IEC 61131-3 standard
	
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOStatus,
	              qx_Error => #ss_Status.FIFOError,
	              qx_Warning => #ss_Status.FIFOWarning,
	              iqv_Data := #s_UDT_MessageArray,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 2 – Data preparation
	    
	    #ss_MessageBody.VID.Year := UINT_TO_DWORD(#i_ActualTimeDTL.YEAR);
	    #ss_MessageBody.VID.Month := UINT_TO_WORD(#i_ActualTimeDTL.MONTH);
	    #ss_MessageBody.VID.Day := UINT_TO_WORD(#i_ActualTimeDTL.DAY);
	    #ss_MessageBody.VID.ObjectID := INT_TO_WORD(#ii_Object_ID);
	    #ss_MessageBody.VID.Code1 := 0;
	    #ss_MessageBody.VID.Code2 := 0;
	    #ss_MessageBody.VID.Code3 := 0;
	    #ss_MessageBody.VID.Code4 := 0;
	    #ss_MessageBody.VID.Code5 := 0;
	    #ss_MessageBody.VID.Code6 := 0;
	    
	    
	    //Send message when is new parcel
	    #sx_NewData := (#ii_Object_ID <> #si_Old_Object_ID) AND (#ii_Object_ID <> 0);
	    // Save last value
	    #si_Old_Object_ID := #ii_Object_ID;
	    
	    
	END_REGION
	
	REGION 3 – Message array size validation 
	    
	    // Get size of the array.
	    #si_MaximumMessageLength := "FC_GetNrOfArrayEl"(#s_UDT_MessageArray.Bytes);
	    
	    // Message array size validation. 
	    #ss_Status.InvalidMessageArraySize := WORD_TO_INT(#ci_MessageLength) > #si_MaximumMessageLength;
	    
	END_REGION
	
	
	REGION 4 – Message preparation 
	    
	    // FIFO full check.
	    IF NOT #iq_UDT_FifoHeader.Status.Full
	    THEN
	        // Errors and send pulse check.
	        IF NOT #ss_Status.FIFOError
	            AND NOT #ss_Status.InvalidMessageArraySize
	            AND #sx_NewData
	        THEN
	            
	            REGION 4.1 – Header preparation 
	                
	                // Check sequence number. If it is equal or greater than 255 reset it to 1.
	                IF #iqdi_MessageSequenceNumber <= 255
	                THEN
	                    #iqdi_MessageSequenceNumber += 1;
	                ELSE
	                    #iqdi_MessageSequenceNumber := 1;
	                END_IF;
	                
	                
	                // Write parts of the header into structure.
	                #s_UDT_MessageHeader.SOM := #ci_Som;
	                #s_UDT_MessageHeader.SourceNode := INT_TO_BYTE(#ii_SourceNode);
	                #s_UDT_MessageHeader.DestinationNode := INT_TO_BYTE(#ii_DestinationNode);
	                #s_UDT_MessageHeader.SeqNumber := INT_TO_BYTE(#iqdi_MessageSequenceNumber);
	                #s_UDT_MessageHeader.DataLength := #ci_MessageLength;
	                #s_UDT_MessageHeader.NumMsg := 1;
	                
	                // Write parts of the body into structure.
	                #ss_MessageBody.MsgID := #ci_MsgID;
	                #ss_MessageBody.MsgLength := #ci_MsgLength;
	                #ss_MessageBody.ObjectID := INT_TO_WORD(#ii_Object_ID);
	                #ss_MessageBody.VID := #ss_VID;
	                #ss_MessageBody.Eom := #ci_Eom;
	                
	            END_REGION
	            
	            REGION 4.2 – Convert message into array of bytes
	                
	                // Initialize the header serialize position and convert header structure into array of bytes.
	                #sdi_SerializePosition := 0;
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #s_UDT_MessageHeader,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	                // Initialize the body serialize position and convert header structure into array of bytes
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #ss_MessageBody,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	            END_REGION
	            
	            REGION 4.3 – Write message into the FIFO buffer
	                
	                // Mode 'W' - Write FIFO record.
	                "FC_Fifo"(ic_Mode := 'W',
	                          qUDT_Status => #ss_Status.FIFOStatus,
	                          qx_Error => #ss_Status.FIFOError,
	                          qx_Warning => #ss_Status.FIFOWarning,
	                          iqv_Data := #s_UDT_MessageArray,
	                          iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	                          iqv_DataBuffer := #iqs_FifoData);
	                
	            END_REGION
	            
	        END_IF;
	    ELSE
	        // If FIFO is full set FIFO main and FIFO full errors.
	        #ss_Status.FIFOError := TRUE;
	        #ss_Status.FIFOStatus.FifoFull := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Status
	    
	    // Parametrization collective error output.
	    #qx_Error :=
	    #ss_Status.FIFOError
	    OR #ss_Status.InvalidTimeInterval
	    OR #ss_Status.InvalidMessageArraySize;
	    
	    // Parametrization collective warning output.
	    #qx_Warning := #ss_Status.FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Sort_VIDResponse_ASCII"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 129
// END_ATTRIBUTES
   VAR_INPUT 
      is_ObjectID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[10];   // Parcel identifier
      ii_SorterID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Sorter identifier
      i_ActualTimeDTL {InstructionName := 'DTL'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DTL;   // Actual date and time in DTL
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block error occurred
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block warning occurred
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Message number
   END_VAR

   VAR 
      s_UDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message array byte
      s_UDT_MessageHeader { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MFCSortMessageHeader";   // Message header
      ss_MessageBody { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Message body
         MsgID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Message ID
         MsgLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Message length
         ObjectID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[10];   // Parcel identifier
         VID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..15] of Byte;   // Virtual Item Identifier
         Eom { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // End of message
      END_STRUCT;
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";
         HTAReturn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure from HTA function
            Month { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // HTA_Month
            Day { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // HTA_Day
         END_STRUCT;
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //  FIFO error
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO warning
         InvalidMessageArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message array is too short for message
         InvalidTimeInterval { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat time interval lower than zero
         InvalidInputData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Input is not in range
      END_STRUCT;
      ss_VID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Virtual Item Identifier
      sa_VIDBytes { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..16] of Byte;   // VID  - array with data in ASCII
      sdi_SerializePosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Position in array where serialize finished writing data +1
      sdi_VIDCode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // VID Code
      si_MaximumMessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum number of elements in message array
      si_SerializeStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Function serialize status
      ss_OldObjectID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[10];   // Value from previous PLC cycle
      sx_NewData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - prepare data and send a message to the MFC
   END_VAR

   VAR_TEMP 
      ts_StringDate : Struct   // Temporary memory with string value
         Year : String;
         Month : String;
         Day : String;
         SorterID : String;
         Code : String;
      END_STRUCT;
      ti_Loop : Int;   // Loop counter
      ti_ObjectID : UDInt;   // Parcel identifier
   END_VAR

   VAR CONSTANT 
      ci_MessageLength : Word := 16#0016;   // 10#0021 = 16#0016 - Message length
      ci_Som : Byte := 16#FD;   // Start of message
      ci_Eom : Byte := 16#FE;   // End of message
      ci_MsgID : Word := 16#00C9;   // 10#0201 = 16#00C9 - Message ID
      ci_MsgLength : Word := 16#0012;   // 10#0018 = 16#0012 - Message length
      ci_SourceNode : Int := 1;   // 1 - PLC ID Source Node
      ci_DestinationNode : Int := 2;   // 2 - MFC ID Destination Node
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	27/04/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec  | Updated for new Baseline
	02/05/2024  | 1.2       | J.Majer      | Datatype conversions changed from automatic to explicit, to accomodate IEC 61131-3 standard
	
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOStatus,
	              qx_Error => #ss_Status.FIFOError,
	              qx_Warning => #ss_Status.FIFOWarning,
	              iqv_Data := #s_UDT_MessageArray,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 2 - Check input data if are if range
	    
	    //Convert 'is_ObjectID' to numeric variable
	    #ti_ObjectID := STRING_TO_UDINT(#is_ObjectID);
	    
	    IF (#ti_ObjectID < 0)
	        OR (#ii_SorterID < 0)
	        OR (#ii_SorterID > 99)
	    THEN
	        #ss_Status.InvalidInputData := True;
	    ELSE
	        #ss_Status.InvalidInputData := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 3 – Data preparation
	    
	    //Send message when is new parcel
	    #sx_NewData := (#is_ObjectID <> #ss_OldObjectID) AND NOT (#is_ObjectID = '0');
	    // Save last value
	    #ss_OldObjectID := #is_ObjectID;
	    
	END_REGION
	
	REGION 4 – Message array size validation 
	    
	    // Get size of the array.
	    #si_MaximumMessageLength := "FC_GetNrOfArrayEl"(#s_UDT_MessageArray.Bytes);
	    
	    // Message array size validation. 
	    #ss_Status.InvalidMessageArraySize := WORD_TO_INT(#ci_MessageLength) > #si_MaximumMessageLength;
	    
	END_REGION
	
	REGION 5 – Message preparation 
	    
	    // FIFO full check.
	    IF NOT #iq_UDT_FifoHeader.Status.Full
	    THEN
	        // Errors and send pulse check.
	        IF NOT #ss_Status.FIFOError
	            AND NOT #ss_Status.InvalidMessageArraySize
	            AND NOT #ss_Status.InvalidInputData
	            AND #sx_NewData
	        THEN
	            
	            REGION 5.1 – VID preparation 
	                
	                // Convert the year into a character string
	                VAL_STRG(IN := #i_ActualTimeDTL.YEAR,
	                         SIZE := 4,
	                         PREC := 0,
	                         FORMAT := 0,
	                         P := 1,
	                         OUT => #ts_StringDate.Year);
	                
	                // Using the HTA function, convert date into a string format
	                #ss_Status.HTAReturn.Month := HTA(IN := WORD_TO_BYTE(INT_TO_BCD16((USINT_TO_INT(#i_ActualTimeDTL.MONTH)))), N := 1, OUT => #ts_StringDate.Month);   // Convert the month  
	                #ss_Status.HTAReturn.Day := HTA(IN := WORD_TO_BYTE(INT_TO_BCD16((USINT_TO_INT(#i_ActualTimeDTL.DAY)))), N := 1, OUT => #ts_StringDate.Day);         // Convert the day           
	                
	                //Convert Sorter ID value from number to string 
	                #ts_StringDate.SorterID := INT_TO_STRING(#ii_SorterID);
	                
	                //Delete sing '+' from string value
	                IF #ts_StringDate.SorterID[1] = '+' THEN
	                    #ts_StringDate.SorterID := DELETE(IN := #ts_StringDate.SorterID, L := 1, P := 1);
	                END_IF;
	                
	                //Add zero when the variable size is to small 
	                IF #ii_SorterID < 10 THEN
	                    #ts_StringDate.SorterID := INSERT(IN1 := #ts_StringDate.SorterID, IN2 := '0', P := 0);
	                END_IF;
	                
	                //Creat ID code - value 000 001 to 999 999
	                #sdi_VIDCode += 1;
	                
	                IF #sdi_VIDCode > 999999 THEN
	                    #sdi_VIDCode := 0;
	                END_IF;
	                
	                //Convert VID code value from number to string 
	                #ts_StringDate.Code := DINT_TO_STRING(#sdi_VIDCode);
	                
	                //Delete sing '+' from string 
	                IF #ts_StringDate.Code[1] = '+' THEN
	                    #ts_StringDate.Code := DELETE(IN := #ts_StringDate.Code, L := 1, P := 1);
	                END_IF;
	                
	                //Add zero when the variable size is to small
	                IF #sdi_VIDCode < 10 THEN
	                    #ts_StringDate.Code := INSERT(IN1 := #ts_StringDate.Code, IN2 := '00000', P := 0);
	                ELSIF #sdi_VIDCode < 100 THEN
	                    #ts_StringDate.Code := INSERT(IN1 := #ts_StringDate.Code, IN2 := '0000', P := 0);
	                ELSIF #sdi_VIDCode < 1000 THEN
	                    #ts_StringDate.Code := INSERT(IN1 := #ts_StringDate.Code, IN2 := '000', P := 0);
	                ELSIF #sdi_VIDCode < 10000 THEN
	                    #ts_StringDate.Code := INSERT(IN1 := #ts_StringDate.Code, IN2 := '00', P := 0);
	                ELSIF #sdi_VIDCode < 100000 THEN
	                    #ts_StringDate.Code := INSERT(IN1 := #ts_StringDate.Code, IN2 := '0', P := 0);
	                END_IF;
	                
	                //Combine strings
	                #ss_VID := (CONCAT(IN1 := #ts_StringDate.Year,
	                                   IN2 := #ts_StringDate.Month,
	                                   IN3 := #ts_StringDate.Day,
	                                   IN4 := #ts_StringDate.SorterID,
	                                   IN5 := #ts_StringDate.Code));
	                
	                //Convert string value to ASCII
	                FOR #ti_Loop := 1 TO 16 DO
	                    #sa_VIDBytes[#ti_Loop] := CHAR_TO_BYTE(#ss_VID[#ti_Loop]);
	                END_FOR;
	                
	            END_REGION
	            
	            REGION 5.2 – Header preparation 
	                
	                // Check sequence number. If it is equal or greater than 255 reset it to 1.
	                IF #iqdi_MessageSequenceNumber <= 255
	                THEN
	                    #iqdi_MessageSequenceNumber += 1;
	                ELSE
	                    #iqdi_MessageSequenceNumber := 1;
	                END_IF;
	                
	                // Write parts of the header into structure.
	                #s_UDT_MessageHeader.SOM := #ci_Som;
	                #s_UDT_MessageHeader.SourceNode := INT_TO_BYTE(#ci_SourceNode);
	                #s_UDT_MessageHeader.DestinationNode := INT_TO_BYTE(#ci_DestinationNode);
	                #s_UDT_MessageHeader.SeqNumber := INT_TO_BYTE(#iqdi_MessageSequenceNumber);
	                #s_UDT_MessageHeader.DataLength := #ci_MessageLength;
	                #s_UDT_MessageHeader.NumMsg := 1;
	                
	                // Write parts of the body into structure.
	                #ss_MessageBody.MsgID := #ci_MsgID;
	                #ss_MessageBody.MsgLength := #ci_MsgLength;
	                #ss_MessageBody.ObjectID := #is_ObjectID;
	                #ss_MessageBody.VID := #sa_VIDBytes;
	                #ss_MessageBody.Eom := #ci_Eom;
	                
	            END_REGION
	            
	            REGION 5.3 – Convert message into array of bytes
	                
	                // Initialize the header serialize position and convert header structure into array of bytes.
	                #sdi_SerializePosition := 0;
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #s_UDT_MessageHeader,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	                // Initialize the body serialize position and convert header structure into array of bytes
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #ss_MessageBody,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	            END_REGION
	            
	            REGION 5.4 – Write message into the FIFO buffer
	                
	                // Mode 'W' - Write FIFO record.
	                "FC_Fifo"(ic_Mode := 'W',
	                          qUDT_Status => #ss_Status.FIFOStatus,
	                          qx_Error => #ss_Status.FIFOError,
	                          qx_Warning => #ss_Status.FIFOWarning,
	                          iqv_Data := #s_UDT_MessageArray,
	                          iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	                          iqv_DataBuffer := #iqs_FifoData);
	                
	            END_REGION
	            
	        END_IF;
	    ELSE
	        // If FIFO is full set FIFO main and FIFO full errors.
	        #ss_Status.FIFOError := TRUE;
	        #ss_Status.FIFOStatus.FifoFull := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Status
	    
	    // Parametrization collective error output.
	    #qx_Error :=
	    #ss_Status.FIFOError
	    OR #ss_Status.InvalidTimeInterval
	    OR #ss_Status.InvalidMessageArraySize
	    OR #ss_Status.InvalidInputData;
	    
	    // Parametrization collective warning output.
	    #qx_Warning := #ss_Status.FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Sort_Destination"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 248
// END_ATTRIBUTES
   VAR_INPUT 
      ii_GINRangeStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 1;   // GIN range start value
      ii_GINRangeEnd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 100;   // GIN range end value
      ii_SourceNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Source Node
      ii_DestinationNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Destination Node
   END_VAR

   VAR_IN_OUT 
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Message number
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iq_UDT_MFCParcelDestination : "UDT_MFCParcelDestination";   // Structure received from MFC with destination commands for the package (ObjectID)
   END_VAR

   VAR 
      FB_MFC_Sort_SortResult_Instance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MFC_Sort_SortResult";
      sx_NewDataGinNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ss_Counter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Counters for statistics
         NewData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;
         CombinedData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;
         DataNotMerged { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;
         DestinationResent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;
         LateDestination { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;
      END_STRUCT;
   END_VAR

   VAR_TEMP 
      ti_GINLoop : Int;
      ti_DestinationLoop : Int;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	05/07/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec  | Updated for new Baseline
	02/05/2024  | 1.2       | J.Majer      | Datatype conversions changed from automatic to explicit, to accomodate IEC 61131-3 standard
	
	*)
	
	REGION New data recived
	    
	    IF NOT (#iq_UDT_MFCParcelDestination.ObjectID <> '')
	        AND NOT (#iq_UDT_MFCParcelDestination.ObjectID <> '0000000000')
	        AND NOT (#iq_UDT_MFCParcelDestination.ObjectID <> '0')
	    THEN
	        
	        //Counter only for statistics
	        #ss_Counter.NewData += 1;
	        
	        //Reset GIN number
	        #sx_NewDataGinNumber := 0;
	        
	        //Find the Object ID in DB_GIN
	        FOR #ti_GINLoop := #ii_GINRangeStart TO #ii_GINRangeEnd DO
	            
	            IF "DB_GIN".GIN[#ti_GINLoop].DHL.ObjectID = #iq_UDT_MFCParcelDestination.ObjectID THEN
	                
	                //Save GIN number
	                #sx_NewDataGinNumber := #ti_GINLoop;
	                
	                //Copy data to DB_GIN
	                "DB_GIN".GIN[#sx_NewDataGinNumber].DHL.SortStrategy := #iq_UDT_MFCParcelDestination.SortStrategy;
	                "DB_GIN".GIN[#sx_NewDataGinNumber].DHL.Destination[1].ID := #iq_UDT_MFCParcelDestination.Destination_1;
	                "DB_GIN".GIN[#sx_NewDataGinNumber].DHL.Destination[2].ID := #iq_UDT_MFCParcelDestination.Destination_2;
	                "DB_GIN".GIN[#sx_NewDataGinNumber].DHL.Destination[3].ID := #iq_UDT_MFCParcelDestination.Destination_3;
	                "DB_GIN".GIN[#sx_NewDataGinNumber].DHL.Destination[4].ID := #iq_UDT_MFCParcelDestination.Destination_4;
	                "DB_GIN".GIN[#sx_NewDataGinNumber].DHL.Destination[5].ID := #iq_UDT_MFCParcelDestination.Destination_5;
	                "DB_GIN".GIN[#sx_NewDataGinNumber].DHL.Destination[6].ID := #iq_UDT_MFCParcelDestination.Destination_6;
	                
	                //Check if destination message is resent
	                IF "DB_GIN".GIN[#sx_NewDataGinNumber].DHL.MFCMessage.Received.Destination THEN
	                    
	                    "DB_GIN".GIN[#sx_NewDataGinNumber].DHL.MFCMessage.Received.DestinationResent := True;
	                    
	                    //Counter only for statistics
	                    #ss_Counter.DestinationResent += 1;
	                    
	                    //Check whether the parcel can be delivered to the new destination. 
	                    //Destination 0-5
	                    FOR #ti_DestinationLoop := 0 TO 5 DO
	                        
	                        IF (("DB_GIN".GIN[#sx_NewDataGinNumber].General.Destination[#ti_DestinationLoop] > "DB_GIN".GIN[1].DHL.ParcelLocation.Current) AND NOT ("DB_GIN".GIN[1].DHL.ParcelLocation.Current = 0))
	                            OR (("DB_GIN".GIN[#sx_NewDataGinNumber].General.Destination[#ti_DestinationLoop] > "DB_GIN".GIN[1].DHL.ParcelLocation.Last) AND NOT ("DB_GIN".GIN[1].DHL.ParcelLocation.Last = 0))
	                        THEN
	                            
	                            #FB_MFC_Sort_SortResult_Instance(is_ObjectID := "DB_GIN".GIN[#ti_GINLoop].DHL.ObjectID,
	                                                             ii_DischargeLocation := DINT_TO_UINT("DB_GIN".GIN[#sx_NewDataGinNumber].General.Destination[#ti_DestinationLoop]),
	                                                             ii_Result := 2,
	                                                             ii_Reason := 5,
	                                                             ii_SourceNode := #ii_SourceNode,
	                                                             ii_DestinationNode := #ii_DestinationNode,
	                                                             iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                                                             iqs_FifoData := #iqs_FifoData,
	                                                             iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	                            
	                            //Counter only for statistics
	                            #ss_Counter.LateDestination += 1;
	                            
	                        END_IF;
	                        
	                    END_FOR;
	                    
	                END_IF;
	                
	                //Destination message received
	                "DB_GIN".GIN[#sx_NewDataGinNumber].DHL.MFCMessage.Received.Destination := True;
	                
	                //Counter only for statistics
	                #ss_Counter.CombinedData += 1;
	                
	                EXIT;
	                
	            END_IF;
	            
	        END_FOR;
	        
	        //Check if GIN number match with Object ID
	        IF #sx_NewDataGinNumber = 0 THEN
	            
	            //Counter only for statistics
	            #ss_Counter.DataNotMerged += 1;
	            
	        END_IF;
	        
	        //Reset structure
	        #iq_UDT_MFCParcelDestination.ObjectID := '';
	        #iq_UDT_MFCParcelDestination.SortStrategy := '';
	        #iq_UDT_MFCParcelDestination.Destination_1 := 0;
	        #iq_UDT_MFCParcelDestination.Destination_2 := 0;
	        #iq_UDT_MFCParcelDestination.Destination_3 := 0;
	        #iq_UDT_MFCParcelDestination.Destination_4 := 0;
	        #iq_UDT_MFCParcelDestination.Destination_5 := 0;
	        #iq_UDT_MFCParcelDestination.Destination_6 := 0;
	        
	    END_IF;
	    
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Sort_Heartbeat"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 120
// END_ATTRIBUTES
   VAR_INPUT 
      iudi_HeartbeatInterval { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Heartbeat send time interval [ms]
      ii_SourceNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // ID Source Node
      ii_DestinationNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // ID Destination Node
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block error occurred
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block warning occurred
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Message number
   END_VAR

   VAR 
      ss_FB_HeartbeatPulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Pulse";   // Heartbeat send pulse generator
      s_UDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message array byte
      s_UDT_MessageHeader { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MFCSortMessageHeader";   // Message header
      ss_MessageBody { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Message body
         MsgID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Message ID
         MsgLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Message length
         Eom { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // End of message
      END_STRUCT;
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //  FIFO error
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO warning
         InvalidMessageArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message array is too short for message
         InvalidTimeInterval { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat time interval lower than zero
      END_STRUCT;
      sdi_SerializePosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Position in array where serialize finished writing data +1
      si_MaximumMessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum number of elements in message array
      si_SerializeStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Function serialize status
      sx_HeartbeatPulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat pulse
   END_VAR

   VAR CONSTANT 
      ci_MessageLength : Word := 16#0004;   // 10#0004 = 16#0004 - Message length
      ci_Som : Byte := 16#FD;   // Start of message
      ci_Eom : Byte := 16#FE;   // End of message
      ci_MsgID : Word := 16#005A;   // 10#0090 = 16#005A - Message ID
      ci_MsgLength : Word := 16#0000;   // 10#0000 = 16#0000 - Message length
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	05/01/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec  | Updated for new Baseline
	02/05/2024  | 1.2       | J.Majer      | Datatype conversions changed from automatic to explicit, to accomodate IEC 61131-3 standard
	
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOStatus,
	              qx_Error => #ss_Status.FIFOError,
	              qx_Warning => #ss_Status.FIFOWarning,
	              iqv_Data := #s_UDT_MessageArray,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 2 – Heartbeat interval validation
	    
	    // Check Heartbeat interval. 
	    #ss_Status.InvalidTimeInterval := #iudi_HeartbeatInterval <= 0;
	    
	END_REGION
	
	REGION 3 – Message array size validation 
	    
	    // Get size of the array.
	    #si_MaximumMessageLength := "FC_GetNrOfArrayEl"(#s_UDT_MessageArray.Bytes);
	    
	    // Message array size validation. 
	    #ss_Status.InvalidMessageArraySize := WORD_TO_INT(#ci_MessageLength) > #si_MaximumMessageLength;
	    
	END_REGION
	
	REGION 4 – Generate heartbeat pulse 
	    
	    IF NOT #ss_Status.InvalidTimeInterval
	        AND NOT #ss_Status.InvalidMessageArraySize
	    THEN
	        // Heartbeat pulse generator.
	        #ss_FB_HeartbeatPulse(iudi_PulseTime := #iudi_HeartbeatInterval,
	                              qx_Pulse => #sx_HeartbeatPulse);
	    END_IF;
	    
	END_REGION
	
	REGION 5 – Message preparation 
	    
	    // FIFO full check.
	    IF NOT #iq_UDT_FifoHeader.Status.Full
	    THEN
	        // Errors and send pulse check.
	        IF NOT #ss_Status.FIFOError
	            AND NOT #ss_Status.InvalidMessageArraySize
	            AND #sx_HeartbeatPulse
	        THEN
	            
	            REGION 5.1 – Header preparation 
	                
	                // Check sequence number. If it is equal or greater than 255 reset it to 1.
	                IF #iqdi_MessageSequenceNumber <= 255
	                THEN
	                    #iqdi_MessageSequenceNumber += 1;
	                ELSE
	                    #iqdi_MessageSequenceNumber := 1;
	                END_IF;
	                
	                // Write parts of the header into structure.
	                #s_UDT_MessageHeader.SOM := #ci_Som;
	                #s_UDT_MessageHeader.SourceNode := INT_TO_BYTE(#ii_SourceNode);
	                #s_UDT_MessageHeader.DestinationNode := INT_TO_BYTE(#ii_DestinationNode);
	                #s_UDT_MessageHeader.SeqNumber := INT_TO_BYTE(#iqdi_MessageSequenceNumber);
	                #s_UDT_MessageHeader.DataLength := #ci_MessageLength;
	                #s_UDT_MessageHeader.NumMsg := 1;
	                
	                #ss_MessageBody.MsgID := #ci_MsgID;
	                #ss_MessageBody.MsgLength := #ci_MsgLength;
	                #ss_MessageBody.Eom := #ci_Eom;
	                
	            END_REGION
	            
	            REGION 5.2 – Convert message into array of bytes
	                
	                // Initialize the header serialize position and convert header structure into array of bytes.
	                #sdi_SerializePosition := 0;
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #s_UDT_MessageHeader,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	                // Initialize the body serialize position and convert header structure into array of bytes
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #ss_MessageBody,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	            END_REGION
	            
	            REGION 5.3 – Write message into the FIFO buffer
	                
	                // Mode 'W' - Write FIFO record.
	                "FC_Fifo"(ic_Mode := 'W',
	                          qUDT_Status => #ss_Status.FIFOStatus,
	                          qx_Error => #ss_Status.FIFOError,
	                          qx_Warning => #ss_Status.FIFOWarning,
	                          iqv_Data := #s_UDT_MessageArray,
	                          iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	                          iqv_DataBuffer := #iqs_FifoData);
	                
	            END_REGION
	            
	        END_IF;
	    ELSE
	        // If FIFO is full set FIFO main and FIFO full errors.
	        #ss_Status.FIFOError := TRUE;
	        #ss_Status.FIFOStatus.FifoFull := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Status
	    
	    // Parametrization collective error output.
	    #qx_Error :=
	    #ss_Status.FIFOError
	    OR #ss_Status.InvalidTimeInterval
	    OR #ss_Status.InvalidMessageArraySize;
	    
	    // Parametrization collective warning output.
	    #qx_Warning := #ss_Status.FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Sort_COY_Decode"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 114
// END_ATTRIBUTES
   VAR_INPUT 
      iudi_HeartbeatTimeout { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Heartbeat timeout [ms]
      ix_Connected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when HB monitoring enable
      ix_ResetData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when reset statistics required
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block error occurred
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block warningoccurred
   END_VAR

   VAR_IN_OUT 
      iq_UDT_Statistics : "UDT_DecodeStatistics";   // Decode statistics
      iq_UDT_FifoReceiveHeader : "UDT_FifoHeader";   // FIFO receive header
      iqa_FifoReceiveData : Array[*] of "UDT_MessageV2";   // FIFO receive data
      iq_UDT_MessageData : "UDT_MFCSortCOYMessageData";   // Received message data
      iqx_Reconnect { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reconnect connection
   END_VAR

   VAR 
      s_FB_TimerHeartbeatCheck { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // "FB_TimerOnOffDelay" - to measure the time of missing HB
      s_UDT_FifoMessage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Buffer for fifos message
      s_R_TRIG_Connected {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Siemens "R_TRIG" - to prepare the rising edge trigger on "ix_Connected" signal
      s_F_TRIG_HeartbeatNotOk {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Siemens "F_TRIG" - to prepare the falling edge trigger on "sx_HeartbeatOk" signal
      ss_CounterRecivedMessage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Counters with recived messages
         Heartbeat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // "Heartbeat" message
         MFCEvent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // "MFCEvent" message
         SystemStatusRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // "SystemStatusRequest" message
         SetSystemMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // "SetSystemMode" message
         SetSystemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // "SetSystemStatus" message
         XrayRegistrationInfo { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // "XrayRegistrationInfo" message
         InvalidMessageID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // "InvalidMessageID" message
      END_STRUCT;
      ss_CounterInvalidDestination { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Counters with invalid destination ranges
         Destination_1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;
         Destination_2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;
         Destination_3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;
         Destination_4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;
         Destination_5 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;
         Destination_6 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;
      END_STRUCT;
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         BadMessage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..10] of "UDT_BytesMessage";   //     Unknown message read
         FIFOReceiveStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";   //     Receive FIFO status structure
         FIFOReceiveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //     FIFO error
         FIFOReceiveWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //     FIFO warning
         InvalidTimeout { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //     Invalid Heartbeat timeout
      END_STRUCT;
      ss_MessageStructure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Received a message structure
         PieceID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[16];   // Piece ID
         VID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[40];   // VID
         RoutingCode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[1];   // RoutingCode
      END_STRUCT;
      sdi_SerializePosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Position in array where serialize finished writing data +1
      si_SerializeStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Function serialize status
      si_MessageID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Message ID
      si_RingBufferNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 1;   // Bad messages ringbuffer counter
      si_LocationIdentifier { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Location identifier
      sx_Heartbeat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat message detected
      sx_HeartbeatOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat ok
   END_VAR

   VAR_TEMP 
      ta_MessageData : Array[0..3] of Byte;   // Messages ID
      ta_MessageData_1 : Array[0..1] of Byte;   // Messages ID
      tdi_NumericValue : UDInt;   // Numeric Value
      ti_BadMessageSize : Int;   // Bad message buffer size
      ti_NumberOfMessageBytes : Int;   // Length of FIFO message
      ti_NumericValue : Int;   // Numeric Value
      ti_Loop : Int;   // Loop counter
      ti_SystemStatus : Int;
      ti_NrOfArrayElements : Int;   // Number of array elements
      tx_MessageRead : Bool;   // Message read from FIFO
      tx_InvalidHeader : Bool;   // Invalid header
      tx_InvalidMessageID : Bool;   // Invalid message ID
      tx_BadMessage : Bool;   // Message with prohibited data
      ts_RoutingCode : String;
   END_VAR

   VAR CONSTANT 
      ci_DestinationMin : Int := 351;   // Minimum value of the destination
      ci_DestinationMax : Int := 355;   // Maximum value of the destination
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	15/02/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	23/08/2023  | 1.1       | S.Theccharis | bug fix on bit pattern 
	12/09/2023  | 1.2       | S. Nikodem   | Dynamic array length detection
	06/02/2023  | 1.3       | M.Diebel     | Read array from 0 position
	13/03/2023  | 1.4       | S. Nieswiec  | Updated for new Baseline
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOReceiveStatus,
	              qx_Error => #ss_Status.FIFOReceiveError,
	              qx_Warning => #ss_Status.FIFOReceiveWarning,
	              iqv_Data := #s_UDT_FifoMessage,
	              iqUDT_FifoHeader := #iq_UDT_FifoReceiveHeader,
	              iqv_DataBuffer := #iqa_FifoReceiveData);
	    
	    // FIFO isn't empty and doesn't have error.
	    IF NOT #iq_UDT_FifoReceiveHeader.Status.Empty
	        AND NOT #ss_Status.FIFOReceiveError
	    THEN
	        // Mode 'R' - Read FIFO record.
	        "FC_Fifo"(ic_Mode := 'R',
	                  qUDT_Status => #ss_Status.FIFOReceiveStatus,
	                  qx_Error => #ss_Status.FIFOReceiveError,
	                  qx_Warning => #ss_Status.FIFOReceiveWarning,
	                  iqv_Data := #s_UDT_FifoMessage,
	                  iqUDT_FifoHeader := #iq_UDT_FifoReceiveHeader,
	                  iqv_DataBuffer := #iqa_FifoReceiveData);
	        
	        // Message read bit set. 
	        #tx_MessageRead := TRUE;
	        
	        // FIFO empty or FIFO error occured.      
	    ELSE
	        #tx_MessageRead := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 – Message type recognition 
	    
	    IF #tx_MessageRead
	    THEN
	        
	        #ta_MessageData[0] := #s_UDT_FifoMessage.Bytes[0];
	        #ta_MessageData[1] := #s_UDT_FifoMessage.Bytes[1];
	        
	        // Deserialize Message ID
	        #sdi_SerializePosition := 0;
	        #si_SerializeStatus := Deserialize(SRC_ARRAY := #ta_MessageData,
	                                           DEST_VARIABLE => #si_MessageID,
	                                           POS := #sdi_SerializePosition);
	        
	        CASE #si_MessageID OF
	            90:  //Heartbeat
	                #sx_Heartbeat := TRUE;
	                
	                //Only statistics
	                #ss_CounterRecivedMessage.Heartbeat += 1;
	                
	            104:  //MFC Event
	                
	                //Get the number of event from the reviced message 
	                #ta_MessageData_1[0] := #s_UDT_FifoMessage.Bytes[4];
	                #ta_MessageData_1[1] := #s_UDT_FifoMessage.Bytes[5];
	                
	                #sdi_SerializePosition := 0;
	                #si_SerializeStatus := Deserialize(SRC_ARRAY := #ta_MessageData,
	                                                   DEST_VARIABLE => #iq_UDT_MessageData.MFCEvent.Event,
	                                                   POS := #sdi_SerializePosition);
	                
	                #iq_UDT_MessageData.MFCEvent.Action := BYTE_TO_INT(#s_UDT_FifoMessage.Bytes[6]);
	                #iq_UDT_MessageData.MFCEvent.Settings := BYTE_TO_INT(#s_UDT_FifoMessage.Bytes[7]);
	                
	                //Only statistics
	                #ss_CounterRecivedMessage.MFCEvent += 1;
	                
	            105:  //System status request
	                
	                #iq_UDT_MessageData.SystemStatusRequest.UpdateStatus := TRUE;
	                
	                //Only statistics
	                #ss_CounterRecivedMessage.SystemStatusRequest += 1;
	                
	            106:  //Set system mode
	                
	                //Get location identifier from the reviced message 
	                #ta_MessageData_1[0] := #s_UDT_FifoMessage.Bytes[4];
	                #ta_MessageData_1[1] := #s_UDT_FifoMessage.Bytes[5];
	                
	                #sdi_SerializePosition := 0;
	                #si_SerializeStatus := Deserialize(SRC_ARRAY := #ta_MessageData_1,
	                                                   DEST_VARIABLE => #si_LocationIdentifier,
	                                                   POS := #sdi_SerializePosition);
	                
	                #ti_NrOfArrayElements := "FC_GetNrOfArrayEl"(#iq_UDT_MessageData.System);
	                
	                //Matching identifier
	                FOR #ti_Loop := 0 TO (#ti_NrOfArrayElements - 1) DO
	                    
	                    IF #si_LocationIdentifier = #iq_UDT_MessageData.System[#ti_Loop].LocationIdentifier THEN
	                        
	                        //System mode - bit value
	                        
	                        //Get location identifier from the reviced message 
	                        #ta_MessageData_1[0] := #s_UDT_FifoMessage.Bytes[6];
	                        #ta_MessageData_1[1] := #s_UDT_FifoMessage.Bytes[7];
	                        
	                        #sdi_SerializePosition := 0;
	                        #si_SerializeStatus := Deserialize(SRC_ARRAY := #ta_MessageData_1,
	                                                           DEST_VARIABLE => #iq_UDT_MessageData.System[#ti_Loop].Command.Mode,
	                                                           POS := #sdi_SerializePosition);
	                        
	                        //System mode - Infeed = 1/Outfeed = 2 - number 
	                        IF #iq_UDT_MessageData.System[#ti_Loop].Command.Mode.%X1 THEN
	                            
	                            #iq_UDT_MessageData.System[#ti_Loop].Command.SystemMode := 1;
	                            
	                        ELSIF #iq_UDT_MessageData.System[#ti_Loop].Command.Mode.%X2 THEN
	                            
	                            #iq_UDT_MessageData.System[#ti_Loop].Command.SystemMode := 2;
	                            
	                        END_IF;
	                        
	                        
	                        //System mode - bool value
	                        //Infeed mode
	                        IF #iq_UDT_MessageData.System[#ti_Loop].Command.Mode.%X1 THEN
	                            #iq_UDT_MessageData.System[#ti_Loop].Command.Infeed := True;
	                        ELSE
	                            #iq_UDT_MessageData.System[#ti_Loop].Command.Infeed := False;
	                        END_IF;
	                        
	                        //Outfeed mode
	                        IF #iq_UDT_MessageData.System[#ti_Loop].Command.Mode.%X2 THEN
	                            #iq_UDT_MessageData.System[#ti_Loop].Command.Outfeed := True;
	                        ELSE
	                            #iq_UDT_MessageData.System[#ti_Loop].Command.Outfeed := False;
	                        END_IF;
	                        
	                        //Contingency mode
	                        IF #iq_UDT_MessageData.System[#ti_Loop].Command.Mode.%X3 THEN
	                            #iq_UDT_MessageData.System[#ti_Loop].Command.Contingency := True;
	                        ELSE
	                            #iq_UDT_MessageData.System[#ti_Loop].Command.Contingency := False;
	                        END_IF;
	                        
	                        //Normal operation mode
	                        IF #iq_UDT_MessageData.System[#ti_Loop].Command.Mode.%X4 THEN
	                            #iq_UDT_MessageData.System[#ti_Loop].Command.NormalOperation := True;
	                        ELSE
	                            #iq_UDT_MessageData.System[#ti_Loop].Command.NormalOperation := False;
	                        END_IF;
	                        
	                        //Xray screening mode
	                        IF #iq_UDT_MessageData.System[#ti_Loop].Command.Mode.%X5 THEN
	                            #iq_UDT_MessageData.System[#ti_Loop].Command.XrayScreening := True;
	                        ELSE
	                            #iq_UDT_MessageData.System[#ti_Loop].Command.XrayScreening := False;
	                        END_IF;
	                        
	                        //Xray transport mode
	                        IF #iq_UDT_MessageData.System[#ti_Loop].Command.Mode.%X6 THEN
	                            #iq_UDT_MessageData.System[#ti_Loop].Command.XrayTransport := True;
	                        ELSE
	                            #iq_UDT_MessageData.System[#ti_Loop].Command.XrayTransport := False;
	                        END_IF;
	                        
	                        //Truck line empty mode
	                        IF #iq_UDT_MessageData.System[#ti_Loop].Command.Mode.%X7 THEN
	                            #iq_UDT_MessageData.System[#ti_Loop].Command.TruckLineEmpty := True;
	                        ELSE
	                            #iq_UDT_MessageData.System[#ti_Loop].Command.TruckLineEmpty := False;
	                        END_IF;
	                        
	                        //Truck line normal mode
	                        IF #iq_UDT_MessageData.System[#ti_Loop].Command.Mode.%X8 THEN
	                            #iq_UDT_MessageData.System[#ti_Loop].Command.TruckLineNormal := True;
	                        ELSE
	                            #iq_UDT_MessageData.System[#ti_Loop].Command.TruckLineNormal := False;
	                        END_IF;
	                        
	                    END_IF;
	                    
	                END_FOR;
	                
	                //Only statistics
	                #ss_CounterRecivedMessage.SetSystemMode += 1;
	                
	            107:  //Set system status
	                
	                //Get location identifier from the reviced message 
	                #ta_MessageData_1[0] := #s_UDT_FifoMessage.Bytes[4];
	                #ta_MessageData_1[1] := #s_UDT_FifoMessage.Bytes[5];
	                
	                #sdi_SerializePosition := 0;
	                #si_SerializeStatus := Deserialize(SRC_ARRAY := #ta_MessageData_1,
	                                                   DEST_VARIABLE => #si_LocationIdentifier,
	                                                   POS := #sdi_SerializePosition);
	                
	                #ti_NrOfArrayElements := "FC_GetNrOfArrayEl"(#iq_UDT_MessageData.System);
	                
	                //Matching identifier
	                FOR #ti_Loop := 0 TO (#ti_NrOfArrayElements - 1) DO
	                    
	                    IF #si_LocationIdentifier = #iq_UDT_MessageData.System[#ti_Loop].LocationIdentifier THEN
	                        
	                        #ti_SystemStatus := BYTE_TO_INT(#s_UDT_FifoMessage.Bytes[6]);
	                        
	                        CASE #ti_SystemStatus OF
	                            1:
	                                #iq_UDT_MessageData.System[#ti_Loop].Command.Start := True;
	                            2:
	                                #iq_UDT_MessageData.System[#ti_Loop].Command.Stop := True;
	                            3:
	                                #iq_UDT_MessageData.System[#ti_Loop].Command.Reset := True;
	                        END_CASE;
	                        
	                    END_IF;
	                    
	                END_FOR;
	                
	                //Only statistics
	                #ss_CounterRecivedMessage.SetSystemStatus += 1;
	                
	            301:  //X-RAY REGISTRATION INFO
	                
	                //Object ID
	                #ta_MessageData[0] := #s_UDT_FifoMessage.Bytes[4];
	                #ta_MessageData[1] := #s_UDT_FifoMessage.Bytes[5];
	                #ta_MessageData[2] := #s_UDT_FifoMessage.Bytes[6];
	                #ta_MessageData[3] := #s_UDT_FifoMessage.Bytes[7];
	                
	                
	                #sdi_SerializePosition := 0;
	                #si_SerializeStatus := Deserialize(SRC_ARRAY := #ta_MessageData,
	                                                   DEST_VARIABLE => #tdi_NumericValue,
	                                                   POS := #sdi_SerializePosition);
	                
	                #iq_UDT_MessageData.XrayRegistrationInfo.ObjectID := DELETE(IN := UDINT_TO_STRING(#tdi_NumericValue), L := 1, P := 1);
	                
	                //VID
	                #iq_UDT_MessageData.XrayRegistrationInfo.VID := CONCAT(IN1 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[8]),
	                                                                       IN2 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[9]),
	                                                                       IN3 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[10]),
	                                                                       IN4 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[11]),
	                                                                       IN5 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[12]),
	                                                                       IN6 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[13]),
	                                                                       IN7 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[14]),
	                                                                       IN8 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[15]),
	                                                                       IN9 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[16]),
	                                                                       IN10 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[17]),
	                                                                       IN11 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[18]),
	                                                                       IN12 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[19]),
	                                                                       IN13 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[20]),
	                                                                       IN14 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[21]),
	                                                                       IN15 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[22]),
	                                                                       IN16 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[23]));
	                
	                //Piece ID
	                #iq_UDT_MessageData.XrayRegistrationInfo.PieceID := CONCAT(IN1 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[24]),
	                                                                           IN2 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[25]),
	                                                                           IN3 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[26]),
	                                                                           IN4 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[27]),
	                                                                           IN5 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[28]),
	                                                                           IN6 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[29]),
	                                                                           IN7 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[30]),
	                                                                           IN8 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[31]),
	                                                                           IN9 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[32]),
	                                                                           IN10 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[33]),
	                                                                           IN11 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[34]),
	                                                                           IN12 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[35]),
	                                                                           IN13 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[36]),
	                                                                           IN14 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[37]),
	                                                                           IN15 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[38]),
	                                                                           IN16 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[39]),
	                                                                           IN17 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[40]),
	                                                                           IN18 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[41]),
	                                                                           IN19 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[42]),
	                                                                           IN20 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[43]),
	                                                                           IN21 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[44]),
	                                                                           IN22 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[45]),
	                                                                           IN23 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[46]),
	                                                                           IN24 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[47]),
	                                                                           IN25 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[48]),
	                                                                           IN26 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[49]),
	                                                                           IN27 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[50]),
	                                                                           IN28 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[51]),
	                                                                           IN29 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[52]),
	                                                                           IN30 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[53]),
	                                                                           IN31 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[54]),
	                                                                           IN32 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[55]));
	                
	                #iq_UDT_MessageData.XrayRegistrationInfo.PieceID := CONCAT(IN1 := #iq_UDT_MessageData.XrayRegistrationInfo.PieceID,
	                                                                           IN2 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[56]),
	                                                                           IN3 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[57]),
	                                                                           IN4 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[58]),
	                                                                           IN5 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[59]),
	                                                                           IN6 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[60]),
	                                                                           IN7 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[61]),
	                                                                           IN8 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[62]),
	                                                                           IN9 := BYTE_TO_CHAR(#s_UDT_FifoMessage.Bytes[63]));
	                
	                
	                //Routing Code - Changed on version 1.1 
	                #ts_RoutingCode := DELETE(IN := UDINT_TO_STRING(BYTE_TO_UINT(#s_UDT_FifoMessage.Bytes[64])), L := 1, P := 1);
	                #ts_RoutingCode := CONCAT(IN1 := '0', IN2 := #ts_RoutingCode);      //add leading zero ( 1 -> 01 , 22 -> 022)
	                #ts_RoutingCode := RIGHT(IN := #ts_RoutingCode, L := 2);            //take always last two characters  ( 01-> 01 , 022-> 22)
	                #iq_UDT_MessageData.XrayRegistrationInfo.RoutingCode := #ts_RoutingCode;
	                
	                //Only statistics
	                #ss_CounterRecivedMessage.XrayRegistrationInfo += 1;
	                
	            ELSE
	                
	                #tx_InvalidMessageID := TRUE;
	                
	                //Only statistics
	                #ss_CounterRecivedMessage.InvalidMessageID += 1;
	                
	        END_CASE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 – Heartbeat monitoring 
	    
	    //HB timeout validation.
	    #ss_Status.InvalidTimeout := #iudi_HeartbeatTimeout <= 0;
	    
	    //HB monitoring if timeout correct.
	    IF NOT #ss_Status.InvalidTimeout
	    THEN
	        #s_R_TRIG_Connected(CLK := #ix_Connected);
	        
	        // Heartbeat timeout monitoring.
	        #s_FB_TimerHeartbeatCheck(iudi_OnDelayTime := 0,
	                                  iudi_OffDelayTime := #iudi_HeartbeatTimeout,
	                                  ix_SignalToDelay := #sx_Heartbeat OR #s_R_TRIG_Connected.Q,
	                                  qx_DelayedSignal => #sx_HeartbeatOK);
	        
	        #sx_Heartbeat := FALSE;
	        #s_F_TRIG_HeartbeatNotOk(CLK := #sx_HeartbeatOK);
	        
	        IF #s_F_TRIG_HeartbeatNotOk.Q
	            AND "DB_Memory".AlwaysFalse
	        THEN
	            // Re-establish conncect with partner and increment the number of communication lost.
	            #iqx_Reconnect := TRUE;
	            #iq_UDT_Statistics.HeartbeatNotObserved += 1;
	        END_IF;
	    END_IF;
	    
	END_REGION
	
	REGION 4 – Statistics update
	    
	    // Error statistics update required. 
	    IF #tx_InvalidHeader
	        OR #tx_InvalidMessageID
	        OR #tx_BadMessage
	    THEN
	        // Invalid message received counter incrementation.
	        #iq_UDT_Statistics.InvalidMessage += 1;
	        
	        // Maximum number of bad messages array.
	        #ti_BadMessageSize := "FC_GetNrOfArrayEl"(#ss_Status.BadMessage);
	        
	        // Writing invalid message in a bad message array.
	        IF #si_RingBufferNumber >= #ti_BadMessageSize
	        THEN
	            #si_RingBufferNumber := 1;
	        END_IF;
	        
	        #ti_NumberOfMessageBytes := "FC_GetNrOfArrayEl"(iv_Array := #s_UDT_FifoMessage.Bytes);
	        
	        MOVE_BLK(IN := #s_UDT_FifoMessage.Bytes[0],
	                 COUNT := INT_TO_UINT(#ti_NumberOfMessageBytes) - 1,
	                 OUT => #ss_Status.BadMessage[#si_RingBufferNumber].Bytes[0]);
	        
	        #si_RingBufferNumber += 1;
	    END_IF;
	    
	    //Resetting statistics.
	    IF #ix_ResetData
	    THEN
	        #iq_UDT_Statistics.InvalidMessage := 0;
	        #iq_UDT_Statistics.HeartbeatNotObserved := 0;
	    END_IF;
	    
	END_REGION
	
	REGION 5 – Status 
	    
	    // Collective error output.
	    #qx_Error :=
	    #ss_Status.FIFOReceiveError
	    OR #ss_Status.InvalidTimeout;
	    
	    // Collective warning output.
	    #qx_Warning :=
	    #ss_Status.FIFOReceiveWarning;
	    
	END_REGION
	
	
	
	
END_FUNCTION_BLOCK

