TYPE "UDT_EquipmentNumber"
VERSION : 0.1
   STRUCT
      Group : Int;   // Part of item number
      Node : Int;   // Part of item number
      Symbolic : DInt;   // Symbolic
   END_STRUCT;

END_TYPE

TYPE "UDT_FifoHeader"
TITLE = UDT_FifoHeader
VERSION : 0.1
//User-defined structure of FIFO register header information.
   STRUCT
      Status : Struct   // Status bits
         Empty { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO Empty
         Prefull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO Prefull
         Full { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO Full
      END_STRUCT;
      NextEntryToRead : Int;   // Next FIFO entry to read
      NextEntryToWrite : Int;   // Next FIFO entry to write
      MaxNrOfEntries : Int;   // Maximum number of FIFO entries
      TotalEntriesStored : Int;   // Total number of FIFO entries
   END_STRUCT;

END_TYPE

TYPE "UDT_MessageHeaderV2"
VERSION : 0.1
   STRUCT
      STX1 : Byte := 16#02;
      STX2 : Byte := 16#02;
      MessageID : Int;
      Group : Int;
      SequenceNumber : DInt;
      BodyLength : Int;
      TimeSpan : DInt;
      FlagRetry : Byte;
      Checksum : Byte;
   END_STRUCT;

END_TYPE

TYPE "UDT_FifoStatus"
TITLE = UDT_FifoStatus
VERSION : 0.1
//
//User-defined structure of FC_Fifo function status.
//Version History:
//Date              | Version   | Author         | Remark
//24/05/2019  | 0.1           | K.Pokorski   | first release MHSE TIA 15.1
//24/05/2019  | 0.2           | K.Pokorski   | first release MHSE TIA 15.1
//
   STRUCT
      InvalidMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid mode selected
      InvalidMaxNrOfEntries { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid maximum number of entries or buffer is not an array
      InvalidTotalEntriesStored { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid total number of entries
      InvalidNextEntryToWrite { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid number of next entry to write
      InvalidNextEntryToRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid number of next entry to read
      InvalidDataType { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message and buffer element data type inconsistent
      FifoPreFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 90 % of FIFO data buffer capacity reached
      FifoFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO data buffer full
   END_STRUCT;

END_TYPE

FUNCTION "FC_GetNrOfArrayEl" : Int
TITLE = FC_GetNrOfArrayEl
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 19
// END_ATTRIBUTES
//Function to get the number of array elements.
   VAR_INPUT 
      iv_Array : Variant;   // Input array
   END_VAR

   VAR_TEMP 
      ti_NrOfArrayEl : Int;   // Number of array elements
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	27/08/2019  | 2.1       | K.Pokorski    | Comments adjusted
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – Number of an array elements
	    
	    IF IS_ARRAY(#iv_Array)                                                  // Input variable is an array
	    THEN
	        
	        #ti_NrOfArrayEl := UDINT_TO_INT(CountOfElements(#iv_Array));
	        
	        // Reset array length if the input variable isn't an array
	    ELSE
	        
	        #ti_NrOfArrayEl := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 – Return output
	    
	    #FC_GetNrOfArrayEl := #ti_NrOfArrayEl;
	    
	END_REGION
	
END_FUNCTION

FUNCTION "FC_Checksum" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 40
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_MessageHeader : "UDT_MessageHeaderV2";   // Message header structure
   END_VAR

   VAR_OUTPUT 
      qb_Checksum : Byte;   // Checksum
   END_VAR

   VAR_TEMP 
      tb_CheckSum : Byte;   // Temporary checksum
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	21/12/2022  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	*)
	
	REGION 1 - Calculating checksum
	    
	    // Initializing temporary checksum.
	    #tb_CheckSum := 0;
	    
	    // Two first header bytes are XOR-ed.
	    #tb_CheckSum := #i_UDT_MessageHeader.STX1
	    XOR #i_UDT_MessageHeader.STX2;
	    
	    // Result of previous XOR is XOR-ed with next byte. 
	    #tb_CheckSum := #tb_CheckSum
	    XOR #i_UDT_MessageHeader.MessageID.%B1;
	    
	    // Result of previous XOR is XOR-ed with next byte. 
	    #tb_CheckSum := #tb_CheckSum
	    XOR #i_UDT_MessageHeader.MessageID.%B0;
	    
	    // Result of previous XOR is XOR-ed with next byte. 
	    #tb_CheckSum := #tb_CheckSum
	    XOR #i_UDT_MessageHeader.Group.%B1;
	    
	    // Result of previous XOR is XOR-ed with next byte. 
	    #tb_CheckSum := #tb_CheckSum
	    XOR #i_UDT_MessageHeader.Group.%B0;
	    
	    // Result of previous XOR is XOR-ed with next byte. 
	    #tb_CheckSum := #tb_CheckSum
	    XOR #i_UDT_MessageHeader.SequenceNumber.%B3;
	    
	    // Result of previous XOR is XOR-ed with next byte. 
	    #tb_CheckSum := #tb_CheckSum
	    XOR #i_UDT_MessageHeader.SequenceNumber.%B2;
	    
	    // Result of previous XOR is XOR-ed with next byte. 
	    #tb_CheckSum := #tb_CheckSum
	    XOR #i_UDT_MessageHeader.SequenceNumber.%B1;
	    
	    // Result of previous XOR is XOR-ed with next byte. 
	    #tb_CheckSum := #tb_CheckSum
	    XOR #i_UDT_MessageHeader.SequenceNumber.%B0;
	    
	    // Result of previous XOR is XOR-ed with next byte. 
	    #tb_CheckSum := #tb_CheckSum
	    XOR #i_UDT_MessageHeader.BodyLength.%B1;
	    
	    // Result of previous XOR is XOR-ed with next byte. 
	    #tb_CheckSum := #tb_CheckSum
	    XOR #i_UDT_MessageHeader.BodyLength.%B0;
	    
	    // Result of previous XOR is XOR-ed with next byte. 
	    #tb_CheckSum := #tb_CheckSum
	    XOR #i_UDT_MessageHeader.TimeSpan.%B3;
	    
	    // Result of previous XOR is XOR-ed with next byte. 
	    #tb_CheckSum := #tb_CheckSum
	    XOR #i_UDT_MessageHeader.TimeSpan.%B2;
	    
	    // Result of previous XOR is XOR-ed with next byte. 
	    #tb_CheckSum := #tb_CheckSum
	    XOR #i_UDT_MessageHeader.TimeSpan.%B1;
	    
	    // Result of previous XOR is XOR-ed with next byte.  
	    #tb_CheckSum := #tb_CheckSum
	    XOR #i_UDT_MessageHeader.TimeSpan.%B0;
	    
	    // Result of previous XOR is XOR-ed with next byte. 
	    #tb_CheckSum := #tb_CheckSum
	    XOR #i_UDT_MessageHeader.FlagRetry;
	    
	END_REGION
	
	REGION 2 - Write outputs 
	    
	    #qb_Checksum := #tb_CheckSum;
	    
	END_REGION
	
END_FUNCTION

TYPE "UDT_MaintenanceCounterBody"
VERSION : 0.1
   STRUCT
      Group : Int;   // Group part of item location
      Node : Int;   // Node part of item location
      RunningTime : DInt;   // Seconds
      DistanceTravelled : DInt;   // Millimeters
      "Start-Stop" : DInt;   // Dimensionless
   END_STRUCT;

END_TYPE

TYPE "UDT_PECStatus"
VERSION : 0.1
   STRUCT
      PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Current state of the photo eye
      Jam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PEC jam error
   END_STRUCT;

END_TYPE

TYPE "UDT_TIDLostBody"
VERSION : 0.1
   STRUCT
      Group : Int;   // Group part of item location
      Node : Int;   // Node part of item location
      TLLNumber : Int;   // TID Linked List Number
      TID : DInt;   // Transport ID
      Reason : Int;   // 0 - unknown; 10 - TID lost; 20 - End of line; 1000 - User delete
   END_STRUCT;

END_TYPE

DATA_BLOCK "DB_Memory"
TITLE = DB_Memory
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
VERSION : 3.0
NON_RETAIN
   VAR 
      ClockByte { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // System clock byte
      Clock_10Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 10 Hz system clock bit
      Clock_5Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 5 Hz system clock bit
      "Clock_2.5Hz" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 2.5 Hz system clock bit
      Clock_2Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 2 Hz system clock bit
      "Clock_1.25Hz" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1.25 Hz system clock bit
      Clock_1Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 Hz system clock bit
      "Clock_0.625Hz" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0.625 Hz system clock bit
      "Clock_0.5Hz" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0.5 Hz system clock bit
      SystemByte { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // System byte
      OSClockByte { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // One shot of clock pulse
      "OS_0.1sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 0.1 sec
      "OS_0.2sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 0.2 sec
      "OS_0.4sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 0.4 sec
      "OS_0.5sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 0.5 sec
      "OS_0.8sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 0.8 sec
      OS_1sec { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 1 sec
      "OS_1.6sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 1.6 sec
      OS_2sec { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 2 sec
      PrevCycleTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Previous PLC cycle Time
      RuntimeMem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Runtime memory
      FirstScan { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // First scan bit
      DiagStatusUpdate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Diagnostic status update
      AlwaysTrue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Always True bit
      AlwaysFalse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Always False bit
      CommissioningFalse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Commissioning always false
      CommissioningTrue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Commissioning always true
      ReconnectCommand { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reconnect command
      ScanMainRack { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Trigger to check main rack confiuration
      ScanProfinet { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Scan profinet bit
      Simulation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Simulation
      PN1OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet ok
      "Local~PROFINET_IO-System" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IO System
      "Local~PROFINET_IO-System_1" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 1
      "Local~PROFINET_IO-System_2" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 2
      "Local~PROFINET_IO-System_3" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 3
      "Local~PROFINET_IO-System_4" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 4
      "Local~PROFINET_IO-System_5" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 5
      "Local~PROFINET_IO-System_6" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 6
      "Local~PROFINET_IO-System_7" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 7
      "Local~PROFINET_IO-System_8" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 8
      "Local~PROFINET_IO-System_9" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 9
   END_VAR


BEGIN

END_DATA_BLOCK

FUNCTION "FC_Fifo" : Void
TITLE = FC_Fifo
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 17
// END_ATTRIBUTES
//Function for controlling FIFO register.
   VAR_INPUT 
      ic_Mode : Char;   // Mode selector: "W" - Write; "R" - Read; "C" - Clear (Reset) "S" - Status
   END_VAR

   VAR_OUTPUT 
      qUDT_Status : "UDT_FifoStatus";   // FIFO status structure
      qx_Error : Bool;   // Collective error output
      qx_Warning : Bool;   // Collective warning output
   END_VAR

   VAR_IN_OUT 
      iqv_Data : Variant;   // Data
      iqUDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqv_DataBuffer : Variant;   // FIFO data buffer
   END_VAR

   VAR_TEMP 
      tUDT_Status : "UDT_FifoStatus";   // Status structure
      ti_MoveBLKErrorCode : Int;   // Move_BLK_Variant function return
      tx_HeaderValid : Bool;   // Header valid
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	14/06/2019  | 0.2       | A.Nowak       | Replacement of instruction if for direct write into variable - Region 3 , 4.1 , 4.2 , 4.3 , 4.4 , 8.1  , 8.2 
	17/07/2019  | 0.3       | L.Klar        | Status handling changed
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	23/08/2019  | 2.1       | K.Pokorski    | Comments corrected
	27/08/2019  | 2.2       | M.Kurpiers    | Comments adjusted
	27/09/2019  | 2.3       | K.Pokorski    | Variant input included
	01/10/2019  | 2.4       | A.Nowak       | Correct comments and rename regions
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – Diagnostic bits initialization
	    
	    // Clear FIFO statuses
	    #tUDT_Status.FifoFull := FALSE;
	    #tUDT_Status.FifoPreFull := FALSE;
	    
	END_REGION
	
	REGION 2 – Array's information
	    
	    // If buffer elements type is invalid, set the error 
	    #tUDT_Status.InvalidDataType := NOT (TypeOf(#iqv_Data) = TypeOfElements(#iqv_DataBuffer));
	    
	END_REGION
	
	REGION 3 – Mode validation
	    
	    // Set the mode invalid if selected mode isn't one of the following: W- Write, R - Read, C - Clear, S - Status
	    #tUDT_Status.InvalidMode := #ic_Mode <> 'W'
	    AND #ic_Mode <> 'R'
	    AND #ic_Mode <> 'C'
	    AND #ic_Mode <> 'S';
	    
	END_REGION
	
	REGION 4 – The header settings checking
	    
	    // The correct mode has been selected and data type is valid
	    IF (NOT #tUDT_Status.InvalidMode
	        AND NOT #tUDT_Status.InvalidDataType)
	    THEN
	        
	        REGION 4.1 – The number of maximum FIFO entries validation 
	            
	            // Write the number of array's elements to FIFO header
	            #iqUDT_FifoHeader.MaxNrOfEntries := "FC_GetNrOfArrayEl"(#iqv_DataBuffer);
	            
	            // Set the invalid maximum number of entries error 
	            #tUDT_Status.InvalidMaxNrOfEntries := #iqUDT_FifoHeader.MaxNrOfEntries <= 0;
	            
	        END_REGION
	        
	        REGION 4.2 – The number of total FIFO entries validation
	            
	            // Set the invalid total number of entries error 
	            #tUDT_Status.InvalidTotalEntriesStored := #iqUDT_FifoHeader.TotalEntriesStored < 0        // The total number of entries is lower than 0
	            OR #iqUDT_FifoHeader.TotalEntriesStored > #iqUDT_FifoHeader.MaxNrOfEntries;               // The total number of entries is greater than the maximum number of entries
	            
	        END_REGION
	        
	        REGION 4.3 – The number of the next entry to write 
	            
	            // Set the invalid next entry to write
	            #tUDT_Status.InvalidNextEntryToWrite := #iqUDT_FifoHeader.NextEntryToWrite < 0            // The number of next entry to write is lower than 0  
	            OR #iqUDT_FifoHeader.NextEntryToWrite >= #iqUDT_FifoHeader.MaxNrOfEntries;                // The number of next entry to write is greater or equal to the maximum number of entries 
	            
	        END_REGION
	        
	        REGION 4.4 – The number of the next entry to read 
	            
	            // Set the invalid next entry to read
	            #tUDT_Status.InvalidNextEntryToRead := #iqUDT_FifoHeader.NextEntryToRead < 0              // The number of next entry to read is lower than 0 
	            OR #iqUDT_FifoHeader.NextEntryToRead >= #iqUDT_FifoHeader.MaxNrOfEntries;                 // The number of next entry to read is greater or equal to the maximum nr of entries 
	            
	        END_REGION
	        
	        REGION 4.5 – FIFO header validation summary
	            
	            // Create collective header error
	            #tx_HeaderValid := NOT #tUDT_Status.InvalidMaxNrOfEntries
	            AND NOT #tUDT_Status.InvalidTotalEntriesStored
	            AND NOT #tUDT_Status.InvalidNextEntryToWrite
	            AND NOT #tUDT_Status.InvalidNextEntryToRead;
	            
	        END_REGION
	        
	    END_IF;
	    
	END_REGION
	
	REGION 5 – Writing the data into the FIFO buffer
	    
	    IF (#ic_Mode = 'W'                                                                          // Write mode selected                                                               
	        AND #tx_HeaderValid                                                                     // FIFO header valid 
	        AND NOT #tUDT_Status.InvalidDataType)                                                  // Buffer data type valid
	    THEN
	        
	        
	        IF (#iqUDT_FifoHeader.TotalEntriesStored < #iqUDT_FifoHeader.MaxNrOfEntries)          // Checking total number of stored entries                
	        THEN
	            
	            // Move input data to FIFO data buffer  
	            #ti_MoveBLKErrorCode := MOVE_BLK_VARIANT(SRC := #iqv_Data,
	                                                     COUNT := 1,
	                                                     SRC_INDEX := 0,
	                                                     DEST_INDEX := #iqUDT_FifoHeader.NextEntryToWrite,
	                                                     DEST => #iqv_DataBuffer);
	            
	            // Increment the number of the next entry to write 
	            #iqUDT_FifoHeader.NextEntryToWrite += 1;
	            
	            // Increment the total number of stored entries 
	            #iqUDT_FifoHeader.TotalEntriesStored += 1;
	            
	            
	            IF (#iqUDT_FifoHeader.NextEntryToWrite >= #iqUDT_FifoHeader.MaxNrOfEntries)       // Check the number of the next entry to write                             
	            THEN
	                
	                #iqUDT_FifoHeader.NextEntryToWrite := 0;
	                
	            END_IF;
	            
	        ELSE
	            
	            #tUDT_Status.FifoFull := TRUE;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 6 – Reading the data from the FIFO data buffer
	    
	    IF (#ic_Mode = 'R'                                                                  // Read mode selected    
	        AND #tx_HeaderValid                                                             // FIFO header valid 
	        AND NOT #tUDT_Status.InvalidDataType)                                           // Buffer data type valid                                                
	    THEN
	        
	        IF (#iqUDT_FifoHeader.TotalEntriesStored > 0)                                   // Checking total number of stored entries                                                     
	        THEN
	            
	            // Move the FIFO data to the data output
	            #ti_MoveBLKErrorCode := MOVE_BLK_VARIANT(SRC := #iqv_DataBuffer,
	                                                     COUNT := 1,
	                                                     SRC_INDEX := #iqUDT_FifoHeader.NextEntryToRead,
	                                                     DEST_INDEX := 0,
	                                                     DEST => #iqv_Data);
	            
	            // Increment the number of the next entry to read
	            #iqUDT_FifoHeader.NextEntryToRead += 1;
	            
	            // Decrement the total number of stored entries
	            #iqUDT_FifoHeader.TotalEntriesStored -= 1;
	            
	            IF (#iqUDT_FifoHeader.NextEntryToRead >= #iqUDT_FifoHeader.MaxNrOfEntries)  // Check the number of the next entry to read                 
	            THEN
	                
	                #iqUDT_FifoHeader.NextEntryToRead := 0;
	                
	            END_IF;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 7 – Clearing the FIFO header
	    
	    IF (#ic_Mode = 'C'                      // Clear mode selected  
	        AND #tx_HeaderValid)                // FIFO header valid                         
	    THEN
	        
	        #iqUDT_FifoHeader.TotalEntriesStored := 0;
	        #iqUDT_FifoHeader.NextEntryToWrite := 0;
	        #iqUDT_FifoHeader.NextEntryToRead := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 8 – FIFO management status update
	    
	    IF (#tx_HeaderValid)                   // The header is valid                                     
	    THEN
	        
	        REGION 8.1 – FIFO Empty
	            
	            // Set the FIFO empty status bit
	            #iqUDT_FifoHeader.Status.Empty := #iqUDT_FifoHeader.TotalEntriesStored = 0;
	            
	        END_REGION
	        
	        REGION 8.2 – FIFO Full
	            
	            // Set the FIFO full status bit 
	            #iqUDT_FifoHeader.Status.Full := #iqUDT_FifoHeader.TotalEntriesStored = #iqUDT_FifoHeader.MaxNrOfEntries;
	            
	        END_REGION
	        
	        REGION 8.3 – FIFO Pre-full
	            
	            IF (#iqUDT_FifoHeader.TotalEntriesStored >= 0.9 * #iqUDT_FifoHeader.MaxNrOfEntries)       // Checking if the number of total stored entries is greater or equal to 90% of the max number of entries     
	            THEN
	                
	                // Set the FIFO pre-full status 
	                #iqUDT_FifoHeader.Status.Prefull := TRUE;
	                #tUDT_Status.FifoPreFull := TRUE;
	                
	            ELSE
	                
	                #iqUDT_FifoHeader.Status.Prefull := FALSE;
	                
	            END_IF;
	            
	        END_REGION
	        
	    END_IF;
	    
	END_REGION
	
	REGION 9 – Status
	    
	    REGION 9.1 – Common status update
	        
	        // Collective error output
	        #qx_Error := NOT #tx_HeaderValid
	        OR #tUDT_Status.InvalidMode
	        OR #tUDT_Status.FifoFull
	        OR #tUDT_Status.InvalidDataType;
	        
	        // Collective warning output              
	        #qx_Warning := #tUDT_Status.FifoPreFull;
	        
	    END_REGION
	    
	    REGION 9.2 – Status update
	        
	        // Update the outer status structure with internal status structure
	        #qUDT_Status := #tUDT_Status;
	        
	    END_REGION
	    
	END_REGION
END_FUNCTION

TYPE "UDT_ItemError"
VERSION : 0.1
   STRUCT
      ItemNumber : "UDT_EquipmentNumber";   // Part of item number
      Error : DInt;   // Error identification
      State : Int;   // State of error
      Masked : Int;   // Should it be displayed
   END_STRUCT;

END_TYPE

TYPE "UDT_MessageV2"
TITLE = UDT_Message
VERSION : 0.1
//User-defined structure of the message characters array.
   STRUCT
      Bytes : Array[0..499] of Byte;   // Message byte
   END_STRUCT;

END_TYPE

TYPE "UDT_ItemStatus"
VERSION : 0.1
   STRUCT
      Group : Int;   // Part of item number
      Node : Int;   // Part of item number
      Status : Int;   // Item Status
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_TimerOnOffDelay"
TITLE = FB_TimerOnOffDelay
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 32
// END_ATTRIBUTES
//Function block to generate on/off signal delay.
   VAR_INPUT 
      iudi_OnDelayTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // On delay time [ms]
      iudi_OffDelayTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Off delay time [ms]
      ix_SignalToDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Input signal to be delayed
      ix_Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;   // Timer Enable
   END_VAR

   VAR_OUTPUT 
      qlr_ActualTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Actual time
      qx_DelayedSignal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Delayed signal output
   END_VAR

   VAR 
      s_R_TRIG_Signal {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Siemens "R_Trig" - to prepare the rising edge trigger on "ix_SignalToDelay" signal
      s_F_TRIG_Signal {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Siemens "F_Trig" - to prepare the falling edge trigger on "ix_SignalToDelay" signal
   END_VAR
   VAR RETAIN
      slr_ActualDelayTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Actual delay time [ms]
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	26/08/2019  | 2.1       | M.Kurpiers    | Comments adjusted
	04/11/2019  | 2.2       | L.Klar        | Prevoius cycle scan changed from memory to DB variable
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION Step 1 – Input signal edge detection 
	    
	    #s_R_TRIG_Signal(CLK := #ix_SignalToDelay);
	    
	    
	    #s_F_TRIG_Signal(CLK := #ix_SignalToDelay);
	    
	END_REGION
	
	REGION Step 2 – Actual delay time initialization
	    
	    IF (#s_R_TRIG_Signal.Q OR #s_F_TRIG_Signal.Q)           // Input signal changed        
	    THEN
	        
	        #slr_ActualDelayTime := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION Step 3 – On/Off delay time calculation
	    
	    
	    IF (#ix_SignalToDelay                                       // Signal to be delayed is active
	        AND #ix_Enable)                                         // Ttimer enabled                   
	    THEN
	        
	        // Timer on
	        IF (#slr_ActualDelayTime >= #iudi_OnDelayTime)
	        THEN
	            
	            #qx_DelayedSignal := TRUE;
	            
	        ELSE
	            
	            #slr_ActualDelayTime += "DB_Memory".PrevCycleTime;
	            
	        END_IF;
	        
	    END_IF;
	    
	    // Timer off
	    IF (NOT #ix_SignalToDelay                                   // Signal to delay is not active
	        AND #ix_Enable)                                         // Timer is enabled                  
	    THEN
	        
	        IF (#slr_ActualDelayTime >= #iudi_OffDelayTime)
	        THEN
	            
	            #qx_DelayedSignal := FALSE;
	            
	        ELSE
	            
	            #slr_ActualDelayTime += "DB_Memory".PrevCycleTime;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION Step 4 – Actual time
	    
	    #qlr_ActualTime := #slr_ActualDelayTime;
	    
	END_REGION
END_FUNCTION_BLOCK

TYPE "UDT_MFCCommandBody"
VERSION : 0.1
   STRUCT
      ClusterID : DInt;   // Cluster ID
      CommandID : DInt;   // Command ID
   END_STRUCT;

END_TYPE

TYPE "UDT_SetDateTimeBody"
VERSION : 0.1
   STRUCT
      Year : Int;   // Year value
      Month : Int;   // Month value
      Day : Int;   // Day value
      Hour : Int;   // Hour value
      Minute : Int;   // Minute value
      Second : Int;   // Second value
   END_STRUCT;

END_TYPE

TYPE "UDT_PECUpdateStatus"
TITLE = UDT_PECUpdateStatus
VERSION : 0.1
//User-defined structure of FB_PECUpdate function block status.
   STRUCT
      TooManyLost { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Too many parcels lost in a row
      LowPerformance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Performance warning
      PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Current state of the end of section photo eye
      Jam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PEC Jam error
   END_STRUCT;

END_TYPE

TYPE "UDT_EuchnerLockStatusV2"
VERSION : 0.1
   STRUCT
      LockFault : Bool;   // Internal lock fault
      DoorClosed : Bool;   // The door is closed
      DoorOpened : Bool;   // The door is opened
      BoltTongueClosed : Bool;   // The lock bolt tongue is closed
      ReqMissingAccessRights : Bool;   // Button access request triggered without permission from DHL
      ResetMissingAccessRights : Bool;   // Button reset triggered without permission from DHL
      DoorOpenedWithoutReq : Bool;   // Doors were opened without request and permission
      Safelylocked : Bool;   // The lock is safely locked
      SafetyLockAckReq : Bool;   // The safety lock signal needs to be confirmed
   END_STRUCT;

END_TYPE

TYPE "UDT_DimensionsCheckStatusV2"
VERSION : 0.1
   STRUCT
      Status : Int;   // Status number
      Specific : Struct   // Specific status
         ParcelTooLongError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Error - parcel is too long
         ParcelTooShortError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Error - parcel is too short
         ParcelTooHighError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Error - parcel is too high
         ParcelTooLowError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Error - parcel is too low
         ParcelTooWideError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Error - parcel is too wide
         ParcelTooNarrowError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Error - parcel is too narrow
         IncorrectParcelOrientationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Error - Incorrect parcel orientation
         GeneralError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // General error
         DisabledGeneralFunctionality { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disabled general DMC functionality
         DisabledTooLongParcel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disabled "TooLongParcel" detection
         DisabledTooShortParcelError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disabled "TooShortParcel" detection
         DisabledTooHighParcelError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disabled "TooHighParcel" detection
         DisabledTooLowParcelError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disabled "TooLowParcel" detection
         DisabledTooWideParcelError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disabled "TooWideParcel" detection
         DisabledTooNarrowParcelError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disabled "TooNarrowParcel" detection
         DisabledParcelOrientationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disabled "ParcelOrientation" detection
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_EncoderStatusV2"
VERSION : 0.1
   STRUCT
      InvalidValue : Bool;   // Invalid value
      RunningFeedbackError : Bool;   // Running feedback error
   END_STRUCT;

END_TYPE

TYPE "UDT_EStop_Status"
VERSION : 0.1
   STRUCT
      Status : Int;
      Estop : Bool;   // Emergency Stop Status
   END_STRUCT;

END_TYPE

DATA_BLOCK "DB_MFC_Visu"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.1
NON_RETAIN
   VAR 
      MFCConnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // A connection to the MFC has been established
      SendAllErrorsState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Triggers the sending of all messages from each function.
      MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Increments every time when message is sending
      CollectiveReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective reset command of all system controls
      Configuration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         HeartbeatTimeout { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Heartbeat Timeout
         SendAllErrors_FirstConnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         NumberOfCompressedMessages { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Set how many message take to array from FIFO
         ActiveErrorCode_Chute { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      END_STRUCT;
   END_VAR


BEGIN
   Configuration.HeartbeatTimeout := 2000;
   Configuration.SendAllErrors_FirstConnected := TRUE;
   Configuration.NumberOfCompressedMessages := 10;

END_DATA_BLOCK

FUNCTION_BLOCK "FB_Pulse"
TITLE = FB_Pulse
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 26
// END_ATTRIBUTES
//Function block to generate custom pulse signal.
   VAR_INPUT 
      iudi_PulseTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Pulse time [ms]
   END_VAR

   VAR_OUTPUT 
      qx_Pulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Pulse output
   END_VAR

   VAR 
      R_TRIG {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Siemens "R_Trig" - to prepare rising edge trigger on "sx_Pulse" signal
      slr_ActualPulseTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Actual pulse time [ms]
      sx_Pulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Pulse signal
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | K.Pokorski    | first release MHS TIA 15.1
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	27/08/2019  | 2.1       | K.Pokorski    | Comments adjusted
	04/11/2019  | 2.2       | L.Klar        | Prevoius cycle scan changed from memory to DB variable
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Pulse calculation
	    
	    // Pulse timer on
	    IF (#iudi_PulseTime <= #slr_ActualPulseTime)
	    THEN
	        
	        #sx_Pulse := TRUE;
	        #slr_ActualPulseTime := 0;
	        
	    ELSE
	        
	        #slr_ActualPulseTime += "DB_Memory".PrevCycleTime;
	        #sx_Pulse := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Pulse output
	    
	    #R_TRIG(CLK := #sx_Pulse,
	            Q => #qx_Pulse);
	    
	END_REGION
END_FUNCTION_BLOCK

TYPE "UDT_DecodeStatistics"
VERSION : 0.1
   STRUCT
      InvalidMessage : UDInt;   // Counter of incorrectly decoded messages
      HeartbeatNotObserved : UDInt;   // Statistics of HB not observed in a preset time
   END_STRUCT;

END_TYPE

TYPE "UDT_ControlPowerGroupWORStatus"
VERSION : 0.1
   STRUCT
      Status : Int;   // Status number
      Specific : Struct
         PowerSuppliesError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Power supplly error
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_ConnectStatus"
VERSION : 0.1
   STRUCT
      Status : Int;   // Status number
      Specific : Struct   // Specific status structure
         Connected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Connected
         CommunicationFault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Communication fault
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_MaintenanceCounterConfiguration"
VERSION : 0.1
   STRUCT
      RunningTime : DInt;   // Running time [s]
      DistanceTraveled : DInt;   // Distance traveled [mm]
      "Start-Stop" : DInt;   // Changing the state of the conveyor from stop to start and start to stop
   END_STRUCT;

END_TYPE

TYPE "UDT_ConveyorInterface"
TITLE = UDT_ConveyorInterface
VERSION : 0.1
//User-defined structure of conveyor interface variables.
   STRUCT
      Displacement : Int;   // Displacement per PLC scan [cm] either from position (if available) or speed and time
      SpeedSetpoint : Int;   // Conveyor speed setpoint [mm/s]
      ActualSpeed : Int;   // Conveyors actual speed [mm/s]
      DeltaPosition : Int;   // Read from Conveyor Servo Position [mm] after 1 PLC cycle
      RunFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Run forward request
      RunRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Run reverse request
      InternalErrorEncoder { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Encoder has an error
      InternalErrorVFD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // VFD has an error
      InternalErrorTracking { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Tracking has an error
      InternalErrorPEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PEC has an error
      InternalWarningVFD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // VFD has a warning
      InternalWarningTracking { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Tracking has a warning
      InternalErrorReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset internal errors
      ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Configuration error is active
      VFDRunning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor is running
      VFDatSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor at speed setpoint
      Disconnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // VFD disconnected
      ManualModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Covneyor is in manual mode
      ResetStatistics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset statistics
      HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Hardware for the Equipment is available and healthy
   END_STRUCT;

END_TYPE

TYPE "UDT_ConveyorStatus"
TITLE = UDT_ConveyorStatus
VERSION : 0.1
//User-defined structure of FB_Conveyor function block status.
   STRUCT
      Status : Int;   // Status number
      Specific : Struct
         Reverse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor is running in reverse direction
      END_STRUCT;
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_MaintenanceCounter"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 132
// END_ATTRIBUTES
   VAR_INPUT 
      ii_Group { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Group part of item location
      ii_Node { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Node part of item location
      idi_RunningTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Seconds
      idi_DistanceTravelled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Millimeters
      "idi_Start-Stop" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Dimensionless
      ii_MessageGroup { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Message group
      ix_FlagRetry { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when message is sent again
      idi_TimeSpan { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Time difference between messages
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block error occurred
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block warning occurred
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Sequence number
   END_VAR

   VAR 
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";   // FIFO status structure
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO error
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO warning
         InvalidMessageArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid message array size
      END_STRUCT;
      s_UDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message byte array
      s_UDT_MessageHeader { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageHeaderV2";   // Message header
      s_UDT_MessageBody { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MaintenanceCounterBody";   // Message body
      sdi_SerializePosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Serialize position
      si_HeaderSerializeStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Header serialize status
      si_BodySerializeStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Body serialize status
      si_MaximumMessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum message length
   END_VAR

   VAR CONSTANT 
      ci_BodyLength : Int := 16;   // Body length
      ci_MessageID : Int := 1479;   // Message ID
      ci_MessageLength : Int := 34;   // Message length
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	21/12/2022  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec  | Updated for new Baseline
	*)
	
	REGION 1 - FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOStatus,
	              qx_Error => #ss_Status.FIFOError,
	              qx_Warning => #ss_Status.FIFOWarning,
	              iqv_Data := #s_UDT_MessageArray,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 2 - Message array size validation
	    
	    // Get size of the array.
	    #si_MaximumMessageLength := "FC_GetNrOfArrayEl"(iv_Array := #s_UDT_MessageArray.Bytes);
	    
	    // Message array size validation.
	    #ss_Status.InvalidMessageArraySize := #ci_MessageLength > #si_MaximumMessageLength;
	    
	END_REGION
	
	REGION 3 - Message preparation
	    
	    // Errors check.
	    IF NOT #ss_Status.FIFOError
	        AND NOT #ss_Status.InvalidMessageArraySize
	    THEN
	        // FIFO full check.
	        IF NOT #iq_UDT_FifoHeader.Status.Full
	        THEN
	            
	            REGION 3.1 - Header preparation
	                
	                // Check sequence number. If it is equal or greater than 30000 reset it to 1.
	                IF #iqdi_MessageSequenceNumber < 30000
	                THEN
	                    #iqdi_MessageSequenceNumber += 1;
	                ELSE
	                    #iqdi_MessageSequenceNumber := 1;
	                END_IF;
	                
	                // Write parts of the header into structure.
	                #s_UDT_MessageHeader.BodyLength := #ci_BodyLength;
	                #s_UDT_MessageHeader.FlagRetry.%X0 := #ix_FlagRetry;
	                #s_UDT_MessageHeader.Group := #ii_MessageGroup;
	                #s_UDT_MessageHeader.MessageID := #ci_MessageID;
	                #s_UDT_MessageHeader.SequenceNumber := #iqdi_MessageSequenceNumber;
	                #s_UDT_MessageHeader.TimeSpan := #idi_TimeSpan;
	                
	                // Calculate the header checksum.
	                "FC_Checksum"(i_UDT_MessageHeader := #s_UDT_MessageHeader,
	                              qb_Checksum => #s_UDT_MessageHeader.Checksum);
	                
	            END_REGION
	            
	            REGION 3.2 - Convert header into array of bytes
	                
	                // Initialize the header serialize position and convert header structure into array of bytes.
	                #sdi_SerializePosition := 0;
	                #si_HeaderSerializeStatus := Serialize(SRC_VARIABLE := #s_UDT_MessageHeader,
	                                                       DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                       POS := #sdi_SerializePosition);
	                
	            END_REGION
	            
	            REGION 3.3 - Body preparation
	                
	                // Write parts of the message body into the structure.
	                #s_UDT_MessageBody.Group := #ii_Group;
	                #s_UDT_MessageBody.Node := #ii_Node;
	                #s_UDT_MessageBody.RunningTime := #idi_RunningTime;
	                #s_UDT_MessageBody.DistanceTravelled := #idi_DistanceTravelled;
	                #s_UDT_MessageBody."Start-Stop" := #"idi_Start-Stop";
	                
	            END_REGION
	            
	            REGION 3.4 - Convert body into array of bytes
	                
	                // Convert message body structure into array of bytes.
	                #si_BodySerializeStatus := Serialize(SRC_VARIABLE := #s_UDT_MessageBody,
	                                                     DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                     POS := #sdi_SerializePosition);
	                
	            END_REGION
	            
	            REGION 3.5 - Write message into the FIFO buffer
	                
	                // Mode 'W' - Write FIFO record.
	                "FC_Fifo"(ic_Mode := 'W',
	                          qUDT_Status => #ss_Status.FIFOStatus,
	                          qx_Error => #ss_Status.FIFOError,
	                          qx_Warning => #ss_Status.FIFOWarning,
	                          iqv_Data := #s_UDT_MessageArray,
	                          iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	                          iqv_DataBuffer := #iqs_FifoData);
	                
	            END_REGION
	            
	        ELSE
	            // If FIFO is full set FIFO main and FIFO full errors.
	            #ss_Status.FIFOError := TRUE;
	            #ss_Status.FIFOStatus.FifoFull := TRUE;
	        END_IF;
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Status
	    
	    // Parametrization collective error output.
	    #qx_Error :=
	    #ss_Status.InvalidMessageArraySize
	    OR #ss_Status.FIFOError;
	    
	    // Parametrization collective warning output.
	    #qx_Warning := #ss_Status.FIFOWarning;
	    
	END_REGION
	
END_FUNCTION_BLOCK

TYPE "UDT_ColumnLift_Status"
TITLE = UDT_VSUStatus
VERSION : 0.1
//User-defined structure of FB_VerticalSwitch function block status.
   STRUCT
      Status : Int;   // Status number
      Specific : Struct   // Equipment specific warnings and errors
         ReferenceError : Bool;   // Active when more like one position sensor active
         SwitchingTimerError : Bool;   // Switching time error
         LimitSensorUpperPosition : Bool;   // Limit switch for upper position active
         LimitSensorLowerPosition : Bool;   // Limit switch for lower position active
         UpperPosition : Bool;   // Upper position reached
         LowerPosition : Bool;   // Lower position reached
         ChuteNotInPosition : Bool;   // The chute is not supported by a column
         MaintenaceModeActive : Bool;
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_CodingBeltModesStatus"
VERSION : 0.1
   STRUCT
      Status : Int;
      Specific : Struct
         Infeed_LabellingMode : Bool;
         Infeed_ContinueMode : Bool;
         Infeed_BufferMode : Bool;
         Outfeed_LabellingMode : Bool;
         Outfeed_ContinueMode : Bool;
         Outfeed_BufferMode : Bool;
         GeneralError : Bool;
         ConfigurationError : Bool;
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_CaljanStatusV2"
TITLE = UDT_UnloaderStatus
VERSION : 0.1
//User-defined structure of FB_Unloader function block status.
   STRUCT
      Status : Int;   // Status number
      Specific : Struct   // Equipment specific warnings and errors
         PEC_EoS : "UDT_PECStatus";   // PEC status structure
         PNSlaveNotOnline { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet slave is not online
         PNSlaveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet slave is in error
         PNSlaveWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet slave has  a warning
         Disabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Unloader is disabled by HMI
         VFDError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Unloader has an VFD error
         NotHealthy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Unloader is not healthy
         StoreMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Store mode activated
         RunMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Run mode activated
         LowerOngoing { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // "lower belt" hydraulic valve is active
         RaisingOngoing { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // "raise belt" hydraulic valve is active
         ChuteBlocked { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Chute blocked activated
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_BiDirectionalStatus"
VERSION : 0.1
   STRUCT
      InfeedModeRequested : Bool;   // Mode change is in progress
      OutfeedModeRequested : Bool;   // Mode change is in progress
      InfeedModeActive : Bool;   // Mode active and system running
      OutfeedModeActive : Bool;   // Mode active and system running
      InfeedModeReady : Bool;   // System is ready to restart, wait for start command
      OutfeedModeReady : Bool;   // System is ready to restart, wait for start command
      ChangingMode : Bool;   // The mode will now be changed
   END_STRUCT;

END_TYPE

TYPE "UDT_ArmDiverterStatus"
VERSION : 0.1
   STRUCT
      Status : Int;   // Status number
      Specific : Struct   // Equipment specific warnings and errors
         TimeoutError : Bool;   // Arm movement timed out
         LimitHomeError : Bool;   // Limit swich sensor error
         LimitDivertError : Bool;   // Limit swich sensor error
         PXHomeError : Bool;   // Proxy sensor error
         PXDivertError : Bool;   // Proxy sensor error
         AtHomePosition : Bool;   // Arm is in home position
         AtDivertPosition : Bool;   // Arm is in divert position
         ReferencError : Bool;   // Referencing error - the arm is not detected by any sensor.
         ParcelDivertError : Bool;   // Parcel diversion error, time too long
         JamExitSensor : Bool;   // Jam on Exit sensor
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_Message"
TITLE = UDT_Message
VERSION : 0.1
//User-defined structure of the message characters array.
   STRUCT
      Character : Array[0..499] of Char;   // Message character
   END_STRUCT;

END_TYPE

TYPE "UDT_ABSwitchStatus"
TITLE = UDT_VSUStatus
VERSION : 0.1
//User-defined structure of FB_VerticalSwitch function block status.
   STRUCT
      Status : Int;   // Status number
      Specific : Struct   // Equipment specific warnings and errors
         ReferenceError : Bool;   // Active when more like one position sensor active
         SwitchingTimerError : Bool;   // Switching time error
         LimitSensorUpperPosition : Bool;   // Limit switch for upper position active
         LimitSensorLowerPosition : Bool;   // Limit switch for lower position active
         UpperSwitchAreaError : Bool;   // Upper switching area PEC was activated when moving
         LowerSwitchAreaError : Bool;   // Lower switching area PEC was activated when moving
         UpperPosition : Bool;   // Upper position reached
         LowerPosition : Bool;   // Lower position reached
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_ControlPowerGroupStatus"
VERSION : 0.1
   STRUCT
      Status : Int;   // Status number
      Specific : Struct
         Fail_PowerSupply_1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Power supply 1 fail
         Fail_PowerSupply_2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Power supply 2 fail
         Fail_PowerSupply_3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Power supply 3 fail
         Fail_PowerSupply_4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Power supply 4 fail
         Fail_PowerSupply_5 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Power supply 5 fail
         Fail_PowerSupply_6 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Power supply 6 fail
         Fail_PowerSupply_7 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Power supply 7 fail
         Fail_PowerSupply_8 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Power supply 8 fail
         Fail_PowerSupply_9 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Power supply 9 fail
         Fail_PowerSupply_10 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Power supply 10 fail
         PowerSuppliesWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Power supplies warning
         PowerSuppliesError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Power supplies error
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_Outfeed2StatesStatus"
VERSION : 0.1
//User-defined structure of FB_CH03 function block status.
   STRUCT
      Status : Int;   // Status number
      Specific : Struct   // CH02 specific status structure
         ChuteFull : Bool;   // Chute is full status
         ChuteHalfFull : Bool;   // Chute is half full status
         ChuteDisabled : Bool;   // Chute is disabled status
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_MCPStatus"
TITLE = Cabinet MCP Status
VERSION : 0.1
   STRUCT
      Status : Int;   // Status number
      Specific : Struct   // Specific
         PN_PN_MSP_PNSlaveNotOnline : Bool;   // PNPN coupler is not online
         PN_PN_MSP_PNSlaveError : Bool;   // PNPN coupler has an error
         PN_PN_MSP_PNSlaveWarning : Bool;   // PNPN coupler has a warning
         IOModule_PNSlaveNotOnline : Bool;   // I/O Module is not online
         IOModule_PNSlaveError : Bool;   // I/O Module has an error
         IOModule_PNSlaveWarning : Bool;   // I/O Module has a warning
         ScalanceSwitchPNSlaveNotOnline : Bool;   // Scalance switch is not online (Switch 1)
         ScalanceSwitchPNSlaveError : Bool;   // Scalance switch has an error (Switch 1)
         ScalanceSwitchPNSlaveWarning : Bool;   // Scalance switch has a warning (Switch 1)
         ScalanceSwitchStatus : Bool;   // TRUE when Scalance switch is not healthy (Switch 1)
         "2ndScalanceSwitchPNSlaveNotOnline" : Bool;   // Scalance switch is not online (Switch 2)
         "2ndScalanceSwitchPNSlaveError" : Bool;   // Scalance switch has an error (Switch 2)
         "2ndScalanceSwitchPNSlaveWarning" : Bool;   // Scalance switch has a warning (Switch 2)
         "2ndScalanceSwitchStatus" : Bool;   // TRUE when Scalance switch is not healthy (Switch 2)
         Singulator_PNSlaveNotOnline : Bool;   // Singulator coupler is not online
         Singulator_PNSlaveError : Bool;   // Singulator coupler has an error
         Singulator_PNSlaveWarning : Bool;   // Singulator coupler has a warning
         IPC_PNSlaveNotOnline : Bool;   // IPC is not online
         IPC_PNSlaveError : Bool;   // IPC has an error
         IPC_PNSlaveWarning : Bool;   // IPC has a warning
         UPSSwitchTripped : Bool;   // Unit Power Supply switch tripped
         FireAlarmActive : Bool;   // Fire alarm active when the signal is true
         PS_201T1_Tripped : Bool;   // TRUE if power supply 201T1 tripped
         "230VAC_CB101F4Tripped" : Bool;   // TRUE if MCP circuit breaker 101F4 tripped
         "230VAC_CB102F1Tripped" : Bool;   // TRUE if MCP circuit breaker 102F1 tripped
         "24VDC_CB201F1Tripped" : Bool;   // TRUE if MCP circuit breaker 201F1 tripped
         "24VDC_CB205F5Tripped" : Bool;   // TRUE if MCP circuit breaker 205F5 tripped
         Spare_1 : Bool;   // Spare
         Spare_2 : Bool;   // Spare
         Spare_3 : Bool;   // Spare
         RackSlotError : Array[0..31] of Bool;   // One of the main rack slots has an error
         IOModuleSlotError : Array[0..31] of Bool;   // Module error
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_RapiscanStatus"
TITLE = UDT_HS10080XCTStatus
VERSION : 0.1
//User-defined structure of FB_Xray_HS10080XCT function block status.
   STRUCT
      Status : Int;   // Status number
      XraySpecific : Struct   // Equipment specific warnings and errors
         XrayEnergised : Bool;   // Xray Energised
         XrayFault : Bool;   // Xray Fault
         XrayRdyRCV : Bool;   // Xray Ready receive
         XrayRdySend : Bool;   // Xray Ready send
         BagScanning : Bool;   // Xray bag scaning
         TransportMode : Bool;   // Transport mode active
         BackBelt : Bool;   // Backbelt functinality active
      END_STRUCT;
      ConvSpecific : Struct   // Equipment specific warnings and errors
         Status : Int;   // Status number
         Conv_ERR : Bool;   // Conveyor is in error
         Encoder_ERR : Bool;   // Encoder error
         ConvRunFWD : Bool;   // Conveyor run forward direction
         ConvRunREV : Bool;   // Conveyor run reverse direction
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_TCPIPReceiveStatistics"
TITLE = UDT_TCPIPReceiveStatistics
VERSION : 0.1
//User-defined structure of FB_TCPIPReceive function block statistics.
   STRUCT
      InvalidMsg : UInt;   // Invalid message received
   END_STRUCT;

END_TYPE

TYPE "UDT_SystemControlStatus"
TITLE = UDT_SystemControlStatus
VERSION : 0.1
//User-defined structure of FB_SystemControl function block status.
   STRUCT
      Status : Int;   // Status number
   END_STRUCT;

END_TYPE

TYPE "UDT_RIOStatus"
VERSION : 0.1
   STRUCT
      Status : Int;   // Status number
      Specific : Struct   // Specific structure
         PNSlaveNotOnline { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet slave is not online
         PNSlaveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet slave is in error
         ET200sp_ErrorModule : Array[0..31] of Bool;   // Module error
         PNSlaveWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet slave has a warning
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_Connection"
TITLE = UDT_Connection
VERSION : 0.1
//User-defined structure of connection parameters.
   STRUCT
      ActiveEstablished : Bool := FALSE;   // 0 – Passive connection establishment; 1 – Active connection establishment
      Interface_ID : HW_ANY := 64;   // Interface ID of CPU Ethernet interface
      ID : CONN_OUC;   // Unique ID as system reference for the connection
      IP : Array[1..4] of Int;   // IP address
      Port : UInt;   // Port number of the communication partner
      ConTimeout : DInt;   // Maximum waiting time for response from the communication partner [ms]
   END_STRUCT;

END_TYPE

TYPE "UDT_RetractrableRoller_Status"
VERSION : 0.1
   STRUCT
      Status : Int;
      Specific : Struct
         NoHomePosition : Bool;
         RollerError : Bool;
      END_STRUCT;
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_ItemStatus"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 131
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_ItemStatusBody { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ItemStatus";   // Item status message body structure
      ii_MessageGroup { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 0;   // Message group number
      ix_FlagRetry { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when message is sent again
      idi_TimeSpan { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Time since previous message was sent [ms]
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block error occurred
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block warning occurred
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Message number
   END_VAR

   VAR 
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //   FIFO error
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //   FIFO warning
         InvalidMessageArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Message array is too short for message
      END_STRUCT;
      s_UDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message array byte
      s_UDT_MessageHeader { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageHeaderV2";   // Message header
      sdi_SerializePosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Position in array where serialize finished writing data +1
      si_HeaderSerializeStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Function serialize status
      si_BodySerializeStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Body serialize function status
      si_MaximumMessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum number of elements in message array
   END_VAR

   VAR CONSTANT 
      ci_MessageID : Int := 21020;   // Message ID number
      ci_MessageLength : Int := 24;   // Message length in bytes
      ci_BodyLenght : Int := 6;   // Message body length
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	21/12/2022  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec  | Updated for new Baseline
	*)
	
	REGION 1 – FIFO header status updatea
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOStatus,
	              qx_Error => #ss_Status.FIFOError,
	              qx_Warning => #ss_Status.FIFOWarning,
	              iqv_Data := #s_UDT_MessageArray,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 2 – Message array size validation check
	    
	    // Get size of the array.
	    #si_MaximumMessageLength := "FC_GetNrOfArrayEl"(#s_UDT_MessageArray.Bytes);
	    
	    // Message array size validation.
	    #ss_Status.InvalidMessageArraySize := #ci_MessageLength > #si_MaximumMessageLength;
	    
	END_REGION
	
	REGION 3 – Message preparation 
	    
	    // Errors check.
	    IF NOT #ss_Status.FIFOError
	        AND NOT #ss_Status.InvalidMessageArraySize
	    THEN
	        // FIFO full check.
	        IF NOT #iq_UDT_FifoHeader.Status.Full
	        THEN
	            
	            REGION 3.1 – Header preparation 
	                
	                // Check sequence number. If it is equal or greater than 30000 reset it to 1.
	                IF #iqdi_MessageSequenceNumber < 30000
	                THEN
	                    #iqdi_MessageSequenceNumber += 1;
	                ELSE
	                    #iqdi_MessageSequenceNumber := 1;
	                END_IF;
	                
	                // Write parts of the header into structure.
	                #s_UDT_MessageHeader.BodyLength := #ci_BodyLenght;
	                #s_UDT_MessageHeader.FlagRetry.%X0 := #ix_FlagRetry;
	                #s_UDT_MessageHeader.Group := #ii_MessageGroup;
	                #s_UDT_MessageHeader.MessageID := #ci_MessageID;
	                #s_UDT_MessageHeader.SequenceNumber := #iqdi_MessageSequenceNumber;
	                #s_UDT_MessageHeader.TimeSpan := #idi_TimeSpan;
	                
	                // Calculate the header checksum.
	                "FC_Checksum"(i_UDT_MessageHeader := #s_UDT_MessageHeader,
	                              qb_Checksum => #s_UDT_MessageHeader.Checksum);
	                
	            END_REGION
	            
	            REGION 3.2 – Convert header into array of bytes
	                
	                // Initialize the header serialize position and convert header structure into array of bytes.
	                #sdi_SerializePosition := 0;
	                #si_HeaderSerializeStatus := Serialize(SRC_VARIABLE := #s_UDT_MessageHeader,
	                                                       DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                       POS := #sdi_SerializePosition);
	                
	            END_REGION
	            
	            REGION 3.3 - Convert body to array of bytes
	                
	                // Convert message body structure into array of bytes.
	                #si_BodySerializeStatus := Serialize(SRC_VARIABLE := #i_UDT_ItemStatusBody,
	                                                     DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                     POS := #sdi_SerializePosition);
	                
	            END_REGION
	            
	            REGION 3.4 – Write message into the FIFO buffer
	                
	                // Mode 'W' - Write FIFO record.
	                "FC_Fifo"(ic_Mode := 'W',
	                          qUDT_Status => #ss_Status.FIFOStatus,
	                          qx_Error => #ss_Status.FIFOError,
	                          qx_Warning => #ss_Status.FIFOWarning,
	                          iqv_Data := #s_UDT_MessageArray,
	                          iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	                          iqv_DataBuffer := #iqs_FifoData);
	                
	            END_REGION
	            
	        ELSE
	            // If FIFO is full set FIFO main and FIFO full errors.
	            #ss_Status.FIFOError := TRUE;
	            #ss_Status.FIFOStatus.FifoFull := TRUE;
	        END_IF;
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Status
	    
	    // Parametrization collective error output.
	    #qx_Error :=
	    #ss_Status.FIFOError
	    OR #ss_Status.InvalidMessageArraySize;
	    
	    // Parametrization collective warning output.
	    #qx_Warning := #ss_Status.FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

TYPE "UDT_VfdStatus"
TITLE = UDT_VfdStatus
VERSION : 0.1
//User-defined structure of VFD status.
   STRUCT
      ErrorCode : Int;   // Error code
      SubErrorCode : Int;   // Sub error code
      PNSlaveNotonline : Bool := FALSE;   // Profinet slave is not on line
      PNSlaveError : Bool := FALSE;   // Profinet slave has an error
      InternalError : Bool := FALSE;   // A VFD internal error is active, see error code
      InternalWarning : Bool := FALSE;   // A VFD internal warning is active, see error code
      CommunicationErrorMovikit : Bool := FALSE;   // Communication error with MoviKit
      VFDRunningFeedbackError : Bool := FALSE;   // Motor is not running
      PNSlaveWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet slave has a warning
   END_STRUCT;

END_TYPE

TYPE "UDT_TCPIPConnectStatus"
TITLE = UDT_TCPIPConnectStatus
VERSION : 0.1
//User-defined structure of FB_TCPIPConnect function block status.
   STRUCT
      Status : Int;   // Status number
      Specific : Struct   // Specific status structure
         ErrorCode : Struct   // Error code structure
            TCON : Word;   // Siemens TCON error code - Check documetation
            TDISCON : Word;   // Siemens TDISCON error code - Check documetation
            TDIAG : Word;   // Siemens TDIAG error code - Check documetation
         END_STRUCT;
         Connected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Connected
         CommunicationFault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Communication fault
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_BytesMessage"
VERSION : 0.1
   STRUCT
      Bytes : Array[0..217] of Byte;
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_ItemError"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 130
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_ItemErrorBody { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ItemError";   // Item error message body structure
      ii_MessageGroup { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 0;   // Message group number
      ix_FlagRetry { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when message is sent again
      idi_TimeSpan { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Time since previous message was sent [ms]
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block error occurred
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block warning occurred
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Message number
   END_VAR

   VAR 
      s_UDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message array byte
      s_UDT_MessageHeader { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageHeaderV2";   // Message header
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //   FIFO error
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //   FIFO warning
         InvalidMessageArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Message array is too short for message
      END_STRUCT;
      sdi_SerializePosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Position in array where serialize finished writing data +1
      si_HeaderSerializeStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Function serialize status
      si_BodySerializeStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Body serialize function status
      si_MaximumMessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum number of elements in message array
   END_VAR

   VAR CONSTANT 
      ci_MessageID : Int := 21010;   // Message ID number
      ci_MessageLenght : Int := 34;   // Message length in bytes
      ci_BodyLenght : Int := 16;   // Message body length
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	21/12/2022  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec  | Updated for new Baseline
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOStatus,
	              qx_Error => #ss_Status.FIFOError,
	              qx_Warning => #ss_Status.FIFOWarning,
	              iqv_Data := #s_UDT_MessageArray,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 2 – Message array size validation check
	    
	    // Get size of the array.
	    #si_MaximumMessageLength := "FC_GetNrOfArrayEl"(#s_UDT_MessageArray.Bytes);
	    
	    // Message array size validation.
	    #ss_Status.InvalidMessageArraySize := #ci_MessageLenght > #si_MaximumMessageLength;
	    
	END_REGION
	
	REGION 3 – Message preparation 
	    
	    // Errors check.
	    IF NOT #ss_Status.FIFOError
	        AND NOT #ss_Status.InvalidMessageArraySize
	    THEN
	        
	        // FIFO full check.
	        IF NOT #iq_UDT_FifoHeader.Status.Full
	        THEN
	            
	            REGION 3.1 – Header preparation 
	                
	                // Check sequence number. If it is equal or greater than 30000 reset it to 1.
	                IF #iqdi_MessageSequenceNumber < 30000
	                THEN
	                    #iqdi_MessageSequenceNumber += 1;
	                ELSE
	                    #iqdi_MessageSequenceNumber := 1;
	                END_IF;
	                
	                // Write parts of the header into structure.
	                #s_UDT_MessageHeader.BodyLength := #ci_BodyLenght;
	                #s_UDT_MessageHeader.FlagRetry.%X0 := #ix_FlagRetry;
	                #s_UDT_MessageHeader.Group := #ii_MessageGroup;
	                #s_UDT_MessageHeader.MessageID := #ci_MessageID;
	                #s_UDT_MessageHeader.SequenceNumber := #iqdi_MessageSequenceNumber;
	                #s_UDT_MessageHeader.TimeSpan := #idi_TimeSpan;
	                
	                // Calculate the header checksum.
	                "FC_Checksum"(i_UDT_MessageHeader := #s_UDT_MessageHeader,
	                              qb_Checksum => #s_UDT_MessageHeader.Checksum);
	                
	            END_REGION
	            
	            REGION 3.2 – Convert header into array of bytes
	                
	                // Initialize the header serialize position and convert header structure into array of bytes.
	                #sdi_SerializePosition := 0;
	                #si_HeaderSerializeStatus := Serialize(SRC_VARIABLE := #s_UDT_MessageHeader,
	                                                       DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                       POS := #sdi_SerializePosition);
	                
	            END_REGION
	            
	            REGION 3.3 - Convert body to array of bytes
	                
	                // Convert message body structure into array of bytes.
	                #si_BodySerializeStatus := Serialize(SRC_VARIABLE := #i_UDT_ItemErrorBody,
	                                                     DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                     POS := #sdi_SerializePosition);
	                
	            END_REGION
	            
	            REGION 3.4 – Write message into the FIFO buffer
	                
	                // Mode 'W' - Write FIFO record.
	                "FC_Fifo"(ic_Mode := 'W',
	                          qUDT_Status => #ss_Status.FIFOStatus,
	                          qx_Error => #ss_Status.FIFOError,
	                          qx_Warning => #ss_Status.FIFOWarning,
	                          iqv_Data := #s_UDT_MessageArray,
	                          iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	                          iqv_DataBuffer := #iqs_FifoData);
	                
	            END_REGION
	            
	        ELSE
	            // If FIFO is full set FIFO main and FIFO full errors.
	            #ss_Status.FIFOError := TRUE;
	            #ss_Status.FIFOStatus.FifoFull := TRUE;
	        END_IF;
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Status
	    
	    // Parametrization collective error output.
	    #qx_Error :=
	    #ss_Status.FIFOError
	    OR #ss_Status.InvalidMessageArraySize;
	    
	    // Parametrization collective warning output.
	    #qx_Warning := #ss_Status.FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

DATA_BLOCK "DB_MFC_ErrorCode"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
   VAR 
      PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Jam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      END_STRUCT;
      PECUpdate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         TooManyLost { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         LowPerformance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         Jam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      END_STRUCT;
      VFD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         PNSlaveNotonline { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         PNSlaveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         InternalError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         InternalWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CommunicationErrorMovikit { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         VFDRunningFeedbackError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         PNSlaveWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      END_STRUCT;
      Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         ErrorCode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         SubErrorCode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         PNSlaveNotonline { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         PNSlaveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         InternalError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         InternalWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CommunicationErrorMovikit { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         VFDRunningFeedbackError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         PNSlaveWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      END_STRUCT;
      Caljan { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         PNSlaveNotOnline { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         PNSlaveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         PNSlaveWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         Disabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         VFDError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         NotHealthy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         StoreMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         RunMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         ChuteBlocked { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         Jam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      END_STRUCT;
      ArmDiverter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         TimeoutError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         LimitHomeError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         LimitDivertError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         PXHomeError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         PXDivertError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         AtHomePosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         AtDivertPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         ReferencError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         ParcelDivertError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      END_STRUCT;
      MCP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         PN_PN_MSP_PNSlaveNotOnline { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // PNPN coupler is not online
         PN_PN_MSP_PNSlaveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // PNPN coupler has an error
         PN_PN_MSP_PNSlaveWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // PNPN coupler has a warning
         IOModule_PNSlaveNotOnline { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // I/O Module is not online
         IOModule_PNSlaveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // I/O Module has an error
         IOModule_PNSlaveWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // I/O Module has a warning
         ScalanceSwitchPNSlaveNotOnline { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Scalance switch is not online (Switch 1)
         ScalanceSwitchPNSlaveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Scalance switch has an error (Switch 1)
         ScalanceSwitchPNSlaveWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Scalance switch has a warning (Switch 1)
         "2ndScalanceSwitchPNSlaveNotOnline" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Scalance switch is not online (Switch 2)
         "2ndScalanceSwitchPNSlaveError" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Scalance switch has an error (Switch 2)
         "2ndScalanceSwitchPNSlaveWarning" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Scalance switch has a warning (Switch 2)
         Singulator_PNSlaveNotOnline { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Singulator coupler is not online
         Singulator_PNSlaveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Singulator coupler has an error
         Singulator_PNSlaveWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Singulator coupler has a warning
         IPS_PNSlaveNotOnline { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // IPS is not online
         IPS_PNSlaveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // IPS has an error
         IPS_PNSlaveWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // IPS has a warning
         UPSSwitchTripped { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Unit Power Supply switch tripped
         FireAlarmActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Fire alarm active when the signal is true
         PS_201T1_Tripped { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // TRUE if power supply 201T1 tripped
         "230VAC_CB101F4Tripped" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // TRUE if MCP circuit breaker 101F4 tripped
         "230VAC_CB102F1Tripped" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // TRUE if MCP circuit breaker 102F1 tripped
         "24VDC_CB201F1Tripped" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // TRUE if MCP circuit breaker 201F1 tripped
         "24VDC_CB205F5Tripped" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // TRUE if MCP circuit breaker 205F5 tripped
         Spare_1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Spare
         Spare_2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Spare
         Spare_3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Spare
         RackSlotError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..31] of Int;   // One of the main rack slots has an error
         IOModuleSlotError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..31] of Int;   // Module error
      END_STRUCT;
      RIO { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         PNSlaveNotOnline { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         PNSlaveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         PNSlaveWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         ET200sp_ErrorModule { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..31] of Int;
      END_STRUCT;
      Connect { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         CommunicationFault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      END_STRUCT;
      ConveyorInterface { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         InternalErrorTracking { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         InternalWarningTracking { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         Disconnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      END_STRUCT;
      PDP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         CircuitBreakersTripped { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerStateF100_F200_F300 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerStatePM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF101 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF102 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF103 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF104 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF105 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF106 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF107 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF108 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF109 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF110 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF111 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF112 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF113 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF114 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF115 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF116 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF117 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF118 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF119 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF120 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF121 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF122 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF123 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF124 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF125 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF126 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF127 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF128 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF129 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF130 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF131 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF132 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF133 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF134 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF135 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF201 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF202 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF203 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF204 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF205 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF206 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF207 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF208 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF209 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF210 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF211 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF212 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF213 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF214 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF215 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF216 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF217 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF218 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF219 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF220 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF221 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF222 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF223 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF224 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF225 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF226 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF227 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF228 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF229 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF501 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF502 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF503 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF504 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF505 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF506 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF507 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF508 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF509 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF510 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF511 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         CircuitBreakerTrippedF512 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      END_STRUCT;
      TCPIPConnection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         CommunicationFault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      END_STRUCT;
      PNNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         PNSlaveNotOnline { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         PNSlaveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         PNSlaveWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      END_STRUCT;
      EStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         EStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      END_STRUCT;
      Outfeed2States { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         ChuteFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         ChuteHalfFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         ChuteDisabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      END_STRUCT;
      Rapiscan { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         XrayEnergised { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         XrayFault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         XrayRdyRCV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         XrayRdySend { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         BagScanning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         TransportMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         BackBelt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      END_STRUCT;
      BiDirectional { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         InfeedModeRequested { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         OutfeedModeRequested { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         InfeedModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         OutfeedModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         InfeedModeReady { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         OutfeedModeReady { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      END_STRUCT;
      DimensionsCheck_v2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         ParcelTooLongError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         ParcelTooShortError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         ParcelTooHighError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         ParcelTooLowError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         ParcelTooWideError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         ParcelTooNarrowError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         IncorrectParcelOrientationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         GeneralError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         DisabledGeneralFunctionality { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         DisabledTooLongParcel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         DisabledTooShortParcelError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         DisabledTooHighParcelError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         DisabledTooLowParcelError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         DisabledTooWideParcelError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         DisabledTooNarrowParcelError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         DisabledParcelOrientationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      END_STRUCT;
      DMC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Old version (DMC_v1)
         ParcelTooLong { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         ParcelTooShort { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         ParcelTooHigh { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         ParcelTooLow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         ParcelTooWide { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         ParcelTooNarrow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         GeneralError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         IncorrectParcelOrientationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         DisabledGeneralFunctionality { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         DisabledTooLongParcel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         DisabledTooShortParcelError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         DisabledTooHighParcelError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         DisabledTooLowParcelError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         DisabledTooWideParcelError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         DisabledTooNarrowParcelError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         DisabledParcelOrientationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      END_STRUCT;
      Encoder { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         InvalidValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         RunningFeedbackError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      END_STRUCT;
      CPG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         PowerSuppliesError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      END_STRUCT;
      ColumnLift { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         ReferenceError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         SwitchingTimerError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         LimitSensorUpperPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         LimitSensorLowerPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         UpperPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         LowerPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         ChuteNotInPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      END_STRUCT;
      ABSwitch { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         ReferenceError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         SwitchingTimerError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         LimitSensorUpperPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         LimitSensorLowerPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         UpperSwitchArea_Err { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         LowerSwitchArea_Err { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         UpperPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         LowerPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      END_STRUCT;
      Retractable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         NoHomePosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         Errorr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      END_STRUCT;
      CodingBeltModes { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Infeed_LabellingMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         Infeed_ContinueMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         Infeed_BufferMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         Outfeed_LabellingMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         Outfeed_ContinueMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         Outfeed_BufferMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         GeneralError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      END_STRUCT;
      EuchnerLock { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         LockFault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         DoorClosed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         DoorOpened { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         BoltTongueClosed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         Safelylocked { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         SafetyLockAckReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         ReqMissingAccessRights { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         ResetMissingAccessRights { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         DoorOpenedWithoutReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      END_STRUCT;
   END_VAR


BEGIN
   PEC.Jam := 10101;
   PECUpdate.TooManyLost := 10202;
   PECUpdate.LowPerformance := 10201;
   PECUpdate.Jam := 10203;
   VFD.PNSlaveNotonline := 10006;
   VFD.PNSlaveError := 10005;
   VFD.InternalError := 10002;
   VFD.InternalWarning := 10003;
   VFD.CommunicationErrorMovikit := 10001;
   VFD.VFDRunningFeedbackError := 10004;
   VFD.PNSlaveWarning := 10007;
   Conveyor.ErrorCode := 260;
   Conveyor.SubErrorCode := 261;
   Conveyor.PNSlaveNotonline := 262;
   Conveyor.PNSlaveError := 263;
   Conveyor.InternalError := 264;
   Conveyor.InternalWarning := 265;
   Conveyor.CommunicationErrorMovikit := 266;
   Conveyor.VFDRunningFeedbackError := 267;
   Conveyor.PNSlaveWarning := 268;
   Caljan.PNSlaveNotOnline := 10602;
   Caljan.PNSlaveError := 10603;
   Caljan.PNSlaveWarning := 10604;
   Caljan.Disabled := 10605;
   Caljan.VFDError := 10606;
   Caljan.NotHealthy := 10607;
   Caljan.StoreMode := 10609;
   Caljan.RunMode := 10610;
   Caljan.ChuteBlocked := 10608;
   Caljan.Jam := 10601;
   ArmDiverter.TimeoutError := 10701;
   ArmDiverter.LimitHomeError := 10702;
   ArmDiverter.LimitDivertError := 10703;
   ArmDiverter.PXHomeError := 10704;
   ArmDiverter.PXDivertError := 10705;
   ArmDiverter.AtHomePosition := 10706;
   ArmDiverter.AtDivertPosition := 10707;
   ArmDiverter.ReferencError := 10708;
   ArmDiverter.ParcelDivertError := 10709;
   MCP.PN_PN_MSP_PNSlaveNotOnline := 1001;
   MCP.PN_PN_MSP_PNSlaveError := 1002;
   MCP.PN_PN_MSP_PNSlaveWarning := 1003;
   MCP.IOModule_PNSlaveNotOnline := 1004;
   MCP.IOModule_PNSlaveError := 1005;
   MCP.IOModule_PNSlaveWarning := 1006;
   MCP.ScalanceSwitchPNSlaveNotOnline := 1007;
   MCP.ScalanceSwitchPNSlaveError := 1008;
   MCP.ScalanceSwitchPNSlaveWarning := 1009;
   MCP."2ndScalanceSwitchPNSlaveNotOnline" := 1010;
   MCP."2ndScalanceSwitchPNSlaveError" := 1011;
   MCP."2ndScalanceSwitchPNSlaveWarning" := 1012;
   MCP.Singulator_PNSlaveNotOnline := 1013;
   MCP.Singulator_PNSlaveError := 1014;
   MCP.Singulator_PNSlaveWarning := 1015;
   MCP.IPS_PNSlaveNotOnline := 1016;
   MCP.IPS_PNSlaveError := 1017;
   MCP.IPS_PNSlaveWarning := 1018;
   MCP.UPSSwitchTripped := 1019;
   MCP.FireAlarmActive := 1020;
   MCP.PS_201T1_Tripped := 1021;
   MCP."230VAC_CB101F4Tripped" := 1022;
   MCP."230VAC_CB102F1Tripped" := 1023;
   MCP."24VDC_CB201F1Tripped" := 1024;
   MCP."24VDC_CB205F5Tripped" := 1025;
   MCP.Spare_1 := 1026;
   MCP.Spare_2 := 1027;
   MCP.Spare_3 := 1028;
   MCP.RackSlotError[0] := 1029;
   MCP.RackSlotError[1] := 1030;
   MCP.RackSlotError[2] := 1031;
   MCP.RackSlotError[3] := 1032;
   MCP.RackSlotError[4] := 1033;
   MCP.RackSlotError[5] := 1034;
   MCP.RackSlotError[6] := 1035;
   MCP.RackSlotError[7] := 1036;
   MCP.RackSlotError[8] := 1037;
   MCP.RackSlotError[9] := 1038;
   MCP.RackSlotError[10] := 1039;
   MCP.RackSlotError[11] := 1040;
   MCP.RackSlotError[12] := 1041;
   MCP.RackSlotError[13] := 1042;
   MCP.RackSlotError[14] := 1043;
   MCP.RackSlotError[15] := 1044;
   MCP.RackSlotError[16] := 1045;
   MCP.RackSlotError[17] := 1046;
   MCP.RackSlotError[18] := 1047;
   MCP.RackSlotError[19] := 1048;
   MCP.RackSlotError[20] := 1049;
   MCP.RackSlotError[21] := 1050;
   MCP.RackSlotError[22] := 1051;
   MCP.RackSlotError[23] := 1052;
   MCP.RackSlotError[24] := 1053;
   MCP.RackSlotError[25] := 1054;
   MCP.RackSlotError[26] := 1055;
   MCP.RackSlotError[27] := 1056;
   MCP.RackSlotError[28] := 1057;
   MCP.RackSlotError[29] := 1058;
   MCP.RackSlotError[30] := 1059;
   MCP.RackSlotError[31] := 1060;
   MCP.IOModuleSlotError[0] := 1061;
   MCP.IOModuleSlotError[1] := 1062;
   MCP.IOModuleSlotError[2] := 1063;
   MCP.IOModuleSlotError[3] := 1064;
   MCP.IOModuleSlotError[4] := 1065;
   MCP.IOModuleSlotError[5] := 1066;
   MCP.IOModuleSlotError[6] := 1067;
   MCP.IOModuleSlotError[7] := 1068;
   MCP.IOModuleSlotError[8] := 1069;
   MCP.IOModuleSlotError[9] := 1070;
   MCP.IOModuleSlotError[10] := 1071;
   MCP.IOModuleSlotError[11] := 1072;
   MCP.IOModuleSlotError[12] := 1073;
   MCP.IOModuleSlotError[13] := 1074;
   MCP.IOModuleSlotError[14] := 1075;
   MCP.IOModuleSlotError[15] := 1076;
   MCP.IOModuleSlotError[16] := 1077;
   MCP.IOModuleSlotError[17] := 1078;
   MCP.IOModuleSlotError[18] := 1079;
   MCP.IOModuleSlotError[19] := 1080;
   MCP.IOModuleSlotError[20] := 1081;
   MCP.IOModuleSlotError[21] := 1082;
   MCP.IOModuleSlotError[22] := 1083;
   MCP.IOModuleSlotError[23] := 1084;
   MCP.IOModuleSlotError[24] := 1085;
   MCP.IOModuleSlotError[25] := 1086;
   MCP.IOModuleSlotError[26] := 1087;
   MCP.IOModuleSlotError[27] := 1088;
   MCP.IOModuleSlotError[28] := 1089;
   MCP.IOModuleSlotError[29] := 1090;
   MCP.IOModuleSlotError[30] := 1091;
   MCP.IOModuleSlotError[31] := 1092;
   RIO.PNSlaveNotOnline := 1201;
   RIO.PNSlaveError := 1202;
   RIO.PNSlaveWarning := 1235;
   RIO.ET200sp_ErrorModule[0] := 1203;
   RIO.ET200sp_ErrorModule[1] := 1204;
   RIO.ET200sp_ErrorModule[2] := 1205;
   RIO.ET200sp_ErrorModule[3] := 1206;
   RIO.ET200sp_ErrorModule[4] := 1207;
   RIO.ET200sp_ErrorModule[5] := 1208;
   RIO.ET200sp_ErrorModule[6] := 1209;
   RIO.ET200sp_ErrorModule[7] := 1210;
   RIO.ET200sp_ErrorModule[8] := 1211;
   RIO.ET200sp_ErrorModule[9] := 1212;
   RIO.ET200sp_ErrorModule[10] := 1213;
   RIO.ET200sp_ErrorModule[11] := 1214;
   RIO.ET200sp_ErrorModule[12] := 1215;
   RIO.ET200sp_ErrorModule[13] := 1216;
   RIO.ET200sp_ErrorModule[14] := 1217;
   RIO.ET200sp_ErrorModule[15] := 1218;
   RIO.ET200sp_ErrorModule[16] := 1219;
   RIO.ET200sp_ErrorModule[17] := 1220;
   RIO.ET200sp_ErrorModule[18] := 1221;
   RIO.ET200sp_ErrorModule[19] := 1222;
   RIO.ET200sp_ErrorModule[20] := 1223;
   RIO.ET200sp_ErrorModule[21] := 1224;
   RIO.ET200sp_ErrorModule[22] := 1225;
   RIO.ET200sp_ErrorModule[23] := 1226;
   RIO.ET200sp_ErrorModule[24] := 1227;
   RIO.ET200sp_ErrorModule[25] := 1228;
   RIO.ET200sp_ErrorModule[26] := 1229;
   RIO.ET200sp_ErrorModule[27] := 1230;
   RIO.ET200sp_ErrorModule[28] := 1231;
   RIO.ET200sp_ErrorModule[29] := 1232;
   RIO.ET200sp_ErrorModule[30] := 1233;
   RIO.ET200sp_ErrorModule[31] := 1234;
   Connect.CommunicationFault := 101;
   ConveyorInterface.InternalErrorTracking := 10301;
   ConveyorInterface.InternalWarningTracking := 10302;
   ConveyorInterface.Disconnected := 10303;
   PDP.CircuitBreakersTripped := 1101;
   PDP.CircuitBreakerStateF100_F200_F300 := 1102;
   PDP.CircuitBreakerStatePM := 1103;
   PDP.CircuitBreakerTrippedF101 := 1104;
   PDP.CircuitBreakerTrippedF102 := 1105;
   PDP.CircuitBreakerTrippedF103 := 1106;
   PDP.CircuitBreakerTrippedF104 := 1107;
   PDP.CircuitBreakerTrippedF105 := 1108;
   PDP.CircuitBreakerTrippedF106 := 1109;
   PDP.CircuitBreakerTrippedF107 := 1110;
   PDP.CircuitBreakerTrippedF108 := 1111;
   PDP.CircuitBreakerTrippedF109 := 1112;
   PDP.CircuitBreakerTrippedF110 := 1113;
   PDP.CircuitBreakerTrippedF111 := 1114;
   PDP.CircuitBreakerTrippedF112 := 1115;
   PDP.CircuitBreakerTrippedF113 := 1116;
   PDP.CircuitBreakerTrippedF114 := 1117;
   PDP.CircuitBreakerTrippedF115 := 1118;
   PDP.CircuitBreakerTrippedF116 := 1119;
   PDP.CircuitBreakerTrippedF117 := 1120;
   PDP.CircuitBreakerTrippedF118 := 1121;
   PDP.CircuitBreakerTrippedF119 := 1122;
   PDP.CircuitBreakerTrippedF120 := 1123;
   PDP.CircuitBreakerTrippedF121 := 1124;
   PDP.CircuitBreakerTrippedF122 := 1125;
   PDP.CircuitBreakerTrippedF123 := 1126;
   PDP.CircuitBreakerTrippedF124 := 1127;
   PDP.CircuitBreakerTrippedF125 := 1128;
   PDP.CircuitBreakerTrippedF126 := 1129;
   PDP.CircuitBreakerTrippedF127 := 1130;
   PDP.CircuitBreakerTrippedF128 := 1131;
   PDP.CircuitBreakerTrippedF129 := 1132;
   PDP.CircuitBreakerTrippedF130 := 1133;
   PDP.CircuitBreakerTrippedF131 := 1134;
   PDP.CircuitBreakerTrippedF132 := 1135;
   PDP.CircuitBreakerTrippedF133 := 1136;
   PDP.CircuitBreakerTrippedF134 := 1137;
   PDP.CircuitBreakerTrippedF135 := 1138;
   PDP.CircuitBreakerTrippedF201 := 1139;
   PDP.CircuitBreakerTrippedF202 := 1140;
   PDP.CircuitBreakerTrippedF203 := 1141;
   PDP.CircuitBreakerTrippedF204 := 1142;
   PDP.CircuitBreakerTrippedF205 := 1143;
   PDP.CircuitBreakerTrippedF206 := 1144;
   PDP.CircuitBreakerTrippedF207 := 1145;
   PDP.CircuitBreakerTrippedF208 := 1146;
   PDP.CircuitBreakerTrippedF209 := 1147;
   PDP.CircuitBreakerTrippedF210 := 1148;
   PDP.CircuitBreakerTrippedF211 := 1149;
   PDP.CircuitBreakerTrippedF212 := 1150;
   PDP.CircuitBreakerTrippedF213 := 1151;
   PDP.CircuitBreakerTrippedF214 := 1152;
   PDP.CircuitBreakerTrippedF215 := 1153;
   PDP.CircuitBreakerTrippedF216 := 1154;
   PDP.CircuitBreakerTrippedF217 := 1155;
   PDP.CircuitBreakerTrippedF218 := 1156;
   PDP.CircuitBreakerTrippedF219 := 1157;
   PDP.CircuitBreakerTrippedF220 := 1158;
   PDP.CircuitBreakerTrippedF221 := 1159;
   PDP.CircuitBreakerTrippedF222 := 1160;
   PDP.CircuitBreakerTrippedF223 := 1161;
   PDP.CircuitBreakerTrippedF224 := 1162;
   PDP.CircuitBreakerTrippedF225 := 1163;
   PDP.CircuitBreakerTrippedF226 := 1164;
   PDP.CircuitBreakerTrippedF227 := 1165;
   PDP.CircuitBreakerTrippedF228 := 1166;
   PDP.CircuitBreakerTrippedF229 := 1167;
   PDP.CircuitBreakerTrippedF501 := 1168;
   PDP.CircuitBreakerTrippedF502 := 1169;
   PDP.CircuitBreakerTrippedF503 := 1170;
   PDP.CircuitBreakerTrippedF504 := 1171;
   PDP.CircuitBreakerTrippedF505 := 1172;
   PDP.CircuitBreakerTrippedF506 := 1173;
   PDP.CircuitBreakerTrippedF507 := 1174;
   PDP.CircuitBreakerTrippedF508 := 1175;
   PDP.CircuitBreakerTrippedF509 := 1176;
   PDP.CircuitBreakerTrippedF510 := 1177;
   PDP.CircuitBreakerTrippedF511 := 1178;
   PDP.CircuitBreakerTrippedF512 := 1179;
   TCPIPConnection.CommunicationFault := 201;
   PNNode.PNSlaveNotOnline := 1301;
   PNNode.PNSlaveError := 1302;
   PNNode.PNSlaveWarning := 1303;
   EStop.EStop := 1401;
   Outfeed2States.ChuteFull := 10401;
   Outfeed2States.ChuteHalfFull := 10402;
   Outfeed2States.ChuteDisabled := 10403;
   Rapiscan.XrayEnergised := 11101;
   Rapiscan.XrayFault := 11102;
   Rapiscan.XrayRdyRCV := 11103;
   Rapiscan.XrayRdySend := 11104;
   Rapiscan.BagScanning := 11105;
   Rapiscan.TransportMode := 11106;
   Rapiscan.BackBelt := 11107;
   BiDirectional.InfeedModeRequested := 1601;
   BiDirectional.OutfeedModeRequested := 1602;
   BiDirectional.InfeedModeActive := 1603;
   BiDirectional.OutfeedModeActive := 1604;
   BiDirectional.InfeedModeReady := 1605;
   BiDirectional.OutfeedModeReady := 1606;
   DimensionsCheck_v2.ParcelTooLongError := 10501;
   DimensionsCheck_v2.ParcelTooShortError := 10505;
   DimensionsCheck_v2.ParcelTooHighError := 10502;
   DimensionsCheck_v2.ParcelTooLowError := 10504;
   DimensionsCheck_v2.ParcelTooWideError := 10503;
   DimensionsCheck_v2.ParcelTooNarrowError := 10506;
   DimensionsCheck_v2.IncorrectParcelOrientationError := 10508;
   DimensionsCheck_v2.GeneralError := 10507;
   DimensionsCheck_v2.DisabledGeneralFunctionality := 10509;
   DimensionsCheck_v2.DisabledTooLongParcel := 10510;
   DimensionsCheck_v2.DisabledTooShortParcelError := 10511;
   DimensionsCheck_v2.DisabledTooHighParcelError := 10512;
   DimensionsCheck_v2.DisabledTooLowParcelError := 10513;
   DimensionsCheck_v2.DisabledTooWideParcelError := 10514;
   DimensionsCheck_v2.DisabledTooNarrowParcelError := 10515;
   DimensionsCheck_v2.DisabledParcelOrientationError := 10516;
   DMC.ParcelTooLong := 10501;
   DMC.ParcelTooShort := 10505;
   DMC.ParcelTooHigh := 10502;
   DMC.ParcelTooLow := 10504;
   DMC.ParcelTooWide := 10503;
   DMC.ParcelTooNarrow := 10506;
   DMC.GeneralError := 10507;
   DMC.IncorrectParcelOrientationError := 10508;
   DMC.DisabledGeneralFunctionality := 10509;
   DMC.DisabledTooLongParcel := 10510;
   DMC.DisabledTooShortParcelError := 10511;
   DMC.DisabledTooHighParcelError := 10512;
   DMC.DisabledTooLowParcelError := 10513;
   DMC.DisabledTooWideParcelError := 10514;
   DMC.DisabledTooNarrowParcelError := 10515;
   DMC.DisabledParcelOrientationError := 10516;
   Encoder.InvalidValue := 10801;
   Encoder.RunningFeedbackError := 10802;
   CPG.PowerSuppliesError := 1501;
   ColumnLift.ReferenceError := 10901;
   ColumnLift.SwitchingTimerError := 10902;
   ColumnLift.LimitSensorUpperPosition := 10903;
   ColumnLift.LimitSensorLowerPosition := 10904;
   ColumnLift.UpperPosition := 10905;
   ColumnLift.LowerPosition := 10906;
   ColumnLift.ChuteNotInPosition := 10907;
   ABSwitch.ReferenceError := 11001;
   ABSwitch.SwitchingTimerError := 11002;
   ABSwitch.LimitSensorUpperPosition := 11003;
   ABSwitch.LimitSensorLowerPosition := 11004;
   ABSwitch.UpperSwitchArea_Err := 11005;
   ABSwitch.LowerSwitchArea_Err := 11006;
   ABSwitch.UpperPosition := 11007;
   ABSwitch.LowerPosition := 11008;
   Retractable.NoHomePosition := 11301;
   Retractable.Errorr := 11302;
   CodingBeltModes.Infeed_LabellingMode := 11201;
   CodingBeltModes.Infeed_ContinueMode := 11202;
   CodingBeltModes.Infeed_BufferMode := 11203;
   CodingBeltModes.Outfeed_LabellingMode := 11204;
   CodingBeltModes.Outfeed_ContinueMode := 11205;
   CodingBeltModes.Outfeed_BufferMode := 11206;
   CodingBeltModes.GeneralError := 11207;
   CodingBeltModes.ConfigurationError := 11208;
   EuchnerLock.LockFault := 11401;
   EuchnerLock.DoorClosed := 11402;
   EuchnerLock.DoorOpened := 11403;
   EuchnerLock.BoltTongueClosed := 11404;
   EuchnerLock.Safelylocked := 11405;
   EuchnerLock.SafetyLockAckReq := 11406;
   EuchnerLock.ReqMissingAccessRights := 11407;
   EuchnerLock.ResetMissingAccessRights := 11408;
   EuchnerLock.DoorOpenedWithoutReq := 11409;

END_DATA_BLOCK

TYPE "UDT_PDPStatus"
VERSION : 0.1
   STRUCT
      Status : Int;   // Status number
      Specific : Struct   // Specific
         CircuitBreakersTripped : Bool;   // Circuit breakers tripped when the value is true
         CircuitBreakerStateF100_F200_F300 : Bool;   // Circuit Breaker State Ok if the signal is true
         CircuitBreakerStatePM : Bool;   // Circuit Breaker State Ok if the signal is true
         CircuitBreakerTrippedF101 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF102 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF103 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF104 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF105 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF106 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF107 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF108 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF109 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF110 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF111 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF112 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF113 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF114 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF115 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF116 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF117 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF118 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF119 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF120 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF121 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF122 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF123 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF124 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF125 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF126 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF127 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF128 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF129 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF130 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF131 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF132 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF133 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF134 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF135 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF201 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF202 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF203 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF204 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF205 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF206 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF207 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF208 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF209 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF210 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF211 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF212 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF213 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF214 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF215 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF216 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF217 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF218 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF219 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF220 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF221 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF222 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF223 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF224 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF225 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF226 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF227 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF228 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF229 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF501 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF502 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF503 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF504 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF505 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF506 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF507 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF508 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF509 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF510 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF511 : Bool;   // Circuit breaker is tripped when the value is true
         CircuitBreakerTrippedF512 : Bool;   // Circuit breaker is tripped when the value is true
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_PNNodeStatus"
VERSION : 0.1
   STRUCT
      Status : Int;   // Status number
      Specific : Struct   // Specific structure
         PNSlaveNotOnline { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet slave is not online
         PNSlaveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet slave is in error
         PNSlaveWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet slave has  a warning
      END_STRUCT;
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_TIDLost"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 164
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_EquipmentNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EquipmentNumber";   // Item number
      idi_TID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Transport ID
      is_Reason { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // TID lost reason
         Unknown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Unknown
         TIDLost { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TID lost
         EndOfLine { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // End of line
         ParcelDidntArrive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parcel didn't arrave on PEC when expected
         UserDelete { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // User delete
      END_STRUCT;
      ii_MessageGroup { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Message group
      ix_FlagRetry { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when message is sent again
      idi_TimeSpan { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Time difference between messages
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block error occurred
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block warning occurred
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Sequence number
   END_VAR

   VAR 
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";   // FIFO status structure
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO error
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO warning
         InvalidMessageArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid message array size
         InvalidReason { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid reason value
      END_STRUCT;
      s_UDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message byte array
      s_UDT_MessageHeader { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageHeaderV2";   // Message header
      s_UDT_MessageBody { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_TIDLostBody";   // Message body
      sdi_SerializePosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Serialize position
      si_HeaderSerializeStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Header serialize status
      si_BodySerializeStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Body serialize status
      si_MaximumMessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum message length
   END_VAR

   VAR CONSTANT 
      ci_BodyLength : Int := 12;   // Body length
      ci_MessageID : Int := 1478;   // Message ID
      ci_MessageLength : Int := 30;   // Message length
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	21/12/2022  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec  | Updated for new Baseline
	*)
	
	REGION 1 - FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOStatus,
	              qx_Error => #ss_Status.FIFOError,
	              qx_Warning => #ss_Status.FIFOWarning,
	              iqv_Data := #s_UDT_MessageArray,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 2 - Reason validation
	    
	    // Unknown.
	    IF #is_Reason.Unknown
	    THEN
	        #s_UDT_MessageBody.Reason := 0;
	        #ss_Status.InvalidReason := FALSE;
	        // TID lost.
	    ELSIF #is_Reason.TIDLost
	    THEN
	        #s_UDT_MessageBody.Reason := 10;
	        #ss_Status.InvalidReason := FALSE;
	        // End of line.  
	    ELSIF #is_Reason.EndOfLine
	    THEN
	        #s_UDT_MessageBody.Reason := 20;
	        #ss_Status.InvalidReason := FALSE;
	        //Parcel didn't arrive on PEC when expected
	    ELSIF #is_Reason.ParcelDidntArrive
	    THEN
	        #s_UDT_MessageBody.Reason := 30;
	        #ss_Status.InvalidReason := FALSE;
	        // User delete.
	    ELSIF #is_Reason.UserDelete
	    THEN
	        #s_UDT_MessageBody.Reason := 1000;
	        #ss_Status.InvalidReason := FALSE;
	        // There is no reason.
	    ELSE
	        #ss_Status.InvalidReason := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Message array size validation
	    
	    // Get size of the array.
	    #si_MaximumMessageLength := "FC_GetNrOfArrayEl"(iv_Array := #s_UDT_MessageArray.Bytes);
	    
	    // Message array size validation.
	    #ss_Status.InvalidMessageArraySize := #ci_MessageLength > #si_MaximumMessageLength;
	    
	END_REGION
	
	REGION 4 - Message preparation
	    
	    // Errors check.
	    IF NOT #ss_Status.FIFOError
	        AND NOT #ss_Status.InvalidMessageArraySize
	        AND NOT #ss_Status.InvalidReason
	    THEN
	        // FIFO full check.
	        IF NOT #iq_UDT_FifoHeader.Status.Full
	        THEN
	            
	            REGION 4.1 - Header preparation
	                
	                // Check sequence number. If it is equal or greater than 30000 reset it to 1.
	                IF #iqdi_MessageSequenceNumber < 30000
	                THEN
	                    #iqdi_MessageSequenceNumber += 1;
	                ELSE
	                    #iqdi_MessageSequenceNumber := 1;
	                END_IF;
	                
	                // Write parts of the header into structure.
	                #s_UDT_MessageHeader.BodyLength := #ci_BodyLength;
	                #s_UDT_MessageHeader.FlagRetry.%X0 := #ix_FlagRetry;
	                #s_UDT_MessageHeader.Group := #ii_MessageGroup;
	                #s_UDT_MessageHeader.MessageID := #ci_MessageID;
	                #s_UDT_MessageHeader.SequenceNumber := #iqdi_MessageSequenceNumber;
	                #s_UDT_MessageHeader.TimeSpan := #idi_TimeSpan;
	                
	                // Calculate the header checksum.
	                "FC_Checksum"(i_UDT_MessageHeader := #s_UDT_MessageHeader,
	                              qb_Checksum => #s_UDT_MessageHeader.Checksum);
	                
	            END_REGION
	            
	            REGION 4.2 - Convert header into array of bytes
	                
	                // Initialize the header serialize position and convert header structure into array of bytes.
	                #sdi_SerializePosition := 0;
	                #si_HeaderSerializeStatus := Serialize(SRC_VARIABLE := #s_UDT_MessageHeader,
	                                                       DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                       POS := #sdi_SerializePosition);
	                
	            END_REGION
	            
	            REGION 4.3 - Body preparation
	                
	                // Write parts of the message body into the structure.
	                #s_UDT_MessageBody.Group := #i_UDT_EquipmentNumber.Group;
	                #s_UDT_MessageBody.Node := #i_UDT_EquipmentNumber.Node;
	                #s_UDT_MessageBody.TLLNumber := 0;
	                #s_UDT_MessageBody.TID := #idi_TID;
	                
	            END_REGION
	            
	            REGION 4.4 - Convert body into array of bytes
	                
	                // Convert message body structure into array of bytes.
	                #si_BodySerializeStatus := Serialize(SRC_VARIABLE := #s_UDT_MessageBody,
	                                                     DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                     POS := #sdi_SerializePosition);
	                
	            END_REGION
	            
	            REGION 4.5 - Write message into the FIFO buffer
	                
	                // Mode 'W' - Write FIFO record.
	                "FC_Fifo"(ic_Mode := 'W',
	                          qUDT_Status => #ss_Status.FIFOStatus,
	                          qx_Error => #ss_Status.FIFOError,
	                          qx_Warning => #ss_Status.FIFOWarning,
	                          iqv_Data := #s_UDT_MessageArray,
	                          iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	                          iqv_DataBuffer := #iqs_FifoData);
	                
	            END_REGION
	            
	        ELSE
	            // If FIFO is full set FIFO main and FIFO full errors.
	            #ss_Status.FIFOError := TRUE;
	            #ss_Status.FIFOStatus.FifoFull := TRUE;
	        END_IF;
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Status
	    
	    // Parametrization collective error output.
	    #qx_Error :=
	    #ss_Status.InvalidMessageArraySize
	    OR #ss_Status.FIFOError
	    OR #ss_Status.InvalidReason;
	    
	    // Parametrization collective warning output.
	    #qx_Warning := #ss_Status.FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Visu_TCPIPReceive"
TITLE = FB_TCPIPReceive
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : Communication
VERSION : 2.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 161
// END_ATTRIBUTES
//Function block to receive data from TCPIP.
   VAR_INPUT 
      i_UDT_Connection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_Connection";   // Connection parameters
      ix_EnableReceive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when receive enable
      ii_HeaderLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Message header length
      ii_BodyLengthPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Position in header where message body length value starts
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block error occurred
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block warning occurred
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // Fifo header
      iqs_FifoData : Variant;   // Fifo data
      iq_UDT_Statistics : "UDT_TCPIPReceiveStatistics";   // Statistic structure
   END_VAR

   VAR 
      s_FB_TRCV {InstructionName := 'TRCV'; LibVersion := '4.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TRCV;   // Siemens "TRCV" block - to receive the data from TCPIP socket
      ss_TRCV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // TRCV block interface structure
         Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //     TRCV - Enable
         NDR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //     TRCV - New data available
         Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //     TRCV - Busy
         Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //     TRCV - Error
         Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   //     TRCV - Status
         ReceivedLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   //     TRCV - Received length
         Data { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..120] of Byte;   //     TRCV - Data
      END_STRUCT;
      s_UDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message byte array
      s_UDT_MessagePartArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Part of the message byte array
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         ErrorCode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //    Error code structure
            TRCV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   //    Siemens TRCV error code - Check documentation
         END_STRUCT;
         FIFOReceiveStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";   //    Receive FIFO status structure
         FIFOReceiveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //    Receive FIFO error
         FIFOReceiveWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //    Receive  FIFO warning
         ReceiveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    TRCV block operation error - Check TRCVStatus
      END_STRUCT;
      sui_ReceivedMessagesOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Received message offset
      sui_ReceivedMessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Received message length
      sui_NumberOfReceivedMessages { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Number of received messages in one frame
      sui_ReceivedMessagePartLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Length of the part of received message
      si_MaximumMessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum message length
      sx_ReceivedMessagePart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Received part of the message
      sx_STXFound { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // STX in message is found
      sw_BodyLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Message body length
      si_BodyLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Message body length
      si_BodyLengthFirstPart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // First part of the message body length
      si_BodyLengthSecondPart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Second part of the message body length
      sx_STXFoundEnd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // STX found on the end of first message buffer
   END_VAR

   VAR_TEMP 
      ti_LC_MessageChars : Int;   //  Message chars loop counter
   END_VAR

   VAR CONSTANT 
      cb_STX : Byte := 16#02;   // Start of the message sign
      cb_NULL : Byte := 16#00;   // NULL sign
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2019             MHS                                                     |
	|  All Rights Reserved         Larenweg 90                                             |
	|                              5234 KC 's-Hertogenbosch,                               |
	|                              Netherlands                                             |
	|                                                                                      |     
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	28/10/2019  | 3.0       | L. Klar      | Initial version
	13/03/2020  | 3.1       | M. Kurpiers  | Adapting reviews
	16/01/2023  | 4.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 4.1       | S. Nieswiec  | Updated for new Baseline
	*)
	
	REGION 1 – Update FIFO header status bits
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOReceiveStatus,
	              qx_Error => #ss_Status.FIFOReceiveError,
	              qx_Warning => #ss_Status.FIFOReceiveWarning,
	              iqv_Data := #s_UDT_MessageArray,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 2 – Maximum number of message arrays elements
	    
	    #si_MaximumMessageLength := "FC_GetNrOfArrayEl"(iv_Array := #s_UDT_MessageArray.Bytes);
	    
	END_REGION
	
	REGION 3 – Receive enable
	    
	    // Allow receiving if the connection is established and there are no FIFO errors.
	    #ss_TRCV.Enable :=
	    #ix_EnableReceive
	    AND NOT #ss_Status.FIFOReceiveError;
	    
	    IF #si_BodyLength + #ii_HeaderLength > #si_MaximumMessageLength
	    THEN
	        #sx_STXFound := 0;
	        #sui_ReceivedMessageLength := 0;
	        #sx_ReceivedMessagePart := 0;
	        #sui_ReceivedMessagePartLength := 0;
	    END_IF;
	    
	END_REGION
	
	REGION 4 – Receive data
	    
	    // Data received in an ADHOC mode - data available immediately.
	    #s_FB_TRCV(EN_R := #ss_TRCV.Enable,
	               ID := #i_UDT_Connection.ID,
	               LEN := 0,
	               ADHOC := TRUE,
	               NDR => #ss_TRCV.NDR,
	               BUSY => #ss_TRCV.Busy,
	               ERROR => #ss_TRCV.Error,
	               STATUS => #ss_TRCV.Status,
	               RCVD_LEN => #ss_TRCV.ReceivedLength,
	               DATA := #ss_TRCV.Data);
	    
	END_REGION
	
	REGION 5 – Received data handling
	    
	    // Receiving data was successful.
	    IF #ss_TRCV.NDR
	        AND NOT #ss_TRCV.Busy
	        AND NOT #ss_TRCV.Error
	        AND #ss_TRCV.ReceivedLength > 0
	    THEN
	        
	        REGION 5.1 – Initialization
	            
	            #sui_ReceivedMessageLength := 0;
	            #sui_ReceivedMessagesOffset := 0;
	            #sui_NumberOfReceivedMessages := 0;
	            
	        END_REGION
	        
	        REGION 5.2 – Received part of the message
	            
	            // Move part of the messages into a buffer if available.
	            IF #sx_ReceivedMessagePart
	            THEN
	                #s_UDT_MessageArray := #s_UDT_MessagePartArray;
	                
	            END_IF;
	            
	        END_REGION
	        
	        REGION 5.3 – Message handling
	            
	            FOR #ti_LC_MessageChars := 0 TO (UDINT_TO_INT(#ss_TRCV.ReceivedLength) - 1) DO
	                // Message length validation.
	                IF #sui_ReceivedMessageLength <= #si_MaximumMessageLength
	                THEN
	                    // First termination sign found.
	                    IF (#ss_TRCV.Data[#ti_LC_MessageChars] = #cb_STX)
	                        AND NOT #sx_STXFound
	                    THEN
	                        // Message didn't end.
	                        IF #ti_LC_MessageChars < UDINT_TO_INT(#ss_TRCV.ReceivedLength) - 1
	                        THEN
	                            // Second termination sign found.
	                            IF (#ss_TRCV.Data[#ti_LC_MessageChars + 1] = #cb_STX)
	                                OR #sx_STXFoundEnd
	                            THEN
	                                #sx_STXFound := TRUE;
	                                #sui_ReceivedMessagesOffset := #ti_LC_MessageChars;
	                                #sx_STXFoundEnd := FALSE;
	                            ELSE
	                                // Increment invalid meassage statistic.
	                                #iq_UDT_Statistics.InvalidMsg += 1;
	                            END_IF;
	                        ELSE
	                            #sui_ReceivedMessagesOffset := #ti_LC_MessageChars;
	                            #sx_STXFoundEnd := TRUE;
	                            #sui_ReceivedMessageLength := 1;
	                            #sui_ReceivedMessagePartLength := 1;
	                        END_IF;
	                        
	                    ELSIF #sx_STXFoundEnd
	                    THEN
	                        // Increment invalid meassage statistic and reset STX found signal.
	                        #iq_UDT_Statistics.InvalidMsg += 1;
	                        #sx_STXFoundEnd := FALSE;
	                    END_IF;
	                    
	                    // First STX is found.
	                    IF #sx_STXFound
	                    THEN
	                        // Increment received message length.
	                        #sui_ReceivedMessageLength += 1;
	                        
	                        // Take the second part of the body length from the message header.
	                        IF (#sui_ReceivedMessageLength + #sui_ReceivedMessagePartLength) = (#ii_BodyLengthPosition + 1)
	                        THEN
	                            #si_BodyLengthSecondPart := BYTE_TO_INT(#ss_TRCV.Data[#ti_LC_MessageChars]);
	                        END_IF;
	                        
	                        // Take the first part of the body length from the message header and add it to the first one.
	                        IF (#sui_ReceivedMessageLength + #sui_ReceivedMessagePartLength) = (#ii_BodyLengthPosition + 2)
	                        THEN
	                            #si_BodyLengthFirstPart := BYTE_TO_INT(#ss_TRCV.Data[#ti_LC_MessageChars]);
	                            #sw_BodyLength := INT_TO_WORD(IN := #si_BodyLengthFirstPart);
	                            #si_BodyLength := WORD_TO_INT(SHL(IN := #sw_BodyLength, N := 8)) + #si_BodyLengthSecondPart;
	                        END_IF;
	                        
	                        // When the whole message is received write it to the FIFO buffer.
	                        IF (#sui_ReceivedMessageLength + #sui_ReceivedMessagePartLength) = (#ii_HeaderLength + #si_BodyLength)
	                        THEN
	                            // Move received message to the message array.
	                            MOVE_BLK(IN := #ss_TRCV.Data[#sui_ReceivedMessagesOffset],
	                                     COUNT := #sui_ReceivedMessageLength,
	                                     OUT => #s_UDT_MessageArray.Bytes[#sui_ReceivedMessagePartLength]);  //#sui_ReceivedMessagePartLength
	                            
	                            // Clear not used message array characters.
	                            IF (#sui_ReceivedMessageLength + #sui_ReceivedMessagePartLength) < #si_MaximumMessageLength
	                            THEN
	                                FILL_BLK(IN := #cb_NULL,
	                                         COUNT := INT_TO_ULINT(#si_MaximumMessageLength) -
	                                         UDINT_TO_ULINT(#sui_ReceivedMessageLength) + #sui_ReceivedMessagePartLength,
	                                         OUT => #s_UDT_MessageArray.Bytes[#sui_ReceivedMessageLength + #sui_ReceivedMessagePartLength]);
	                            END_IF;
	                            
	                            // Mode 'W' - Write FIFO record.
	                            "FC_Fifo"(ic_Mode := 'W',
	                                      qUDT_Status => #ss_Status.FIFOReceiveStatus,
	                                      qx_Error => #ss_Status.FIFOReceiveError,
	                                      qx_Warning => #ss_Status.FIFOReceiveWarning,
	                                      iqv_Data := #s_UDT_MessageArray,
	                                      iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	                                      iqv_DataBuffer := #iqs_FifoData);
	                            
	                            // Increment number of the received messages and initialize variables.
	                            #sui_NumberOfReceivedMessages += 1;
	                            #sui_ReceivedMessageLength := 0;
	                            #sui_ReceivedMessagePartLength := 0;
	                            #sx_ReceivedMessagePart := FALSE;
	                            #sx_STXFound := FALSE;
	                        END_IF;
	                    END_IF;
	                END_IF;
	            END_FOR;
	            
	        END_REGION
	        
	        REGION 5.4 – Part of the message preparation
	            
	            // Only the part of the message is received.
	            IF (#sui_ReceivedMessageLength < #ii_HeaderLength + #si_BodyLength)
	                AND (#sx_STXFound OR #sx_STXFoundEnd)
	            THEN
	                // Clear not used message array characters. 
	                FILL_BLK(IN := #cb_NULL,
	                         COUNT := INT_TO_ULINT(#si_MaximumMessageLength) -
	                         UDINT_TO_ULINT(#sui_ReceivedMessageLength),
	                         OUT => #s_UDT_MessagePartArray.Bytes[#sui_ReceivedMessageLength]);
	                
	                // Move part of the message into a buffer.
	                MOVE_BLK(IN := #ss_TRCV.Data[#sui_ReceivedMessagesOffset],
	                         COUNT := #sui_ReceivedMessageLength,
	                         OUT => #s_UDT_MessagePartArray.Bytes[0]);
	                
	                // Set the part of the message received bit and move length of the received message into the length of the part of the message variable.
	                #sx_ReceivedMessagePart := TRUE;
	                #sui_ReceivedMessagePartLength := #sui_ReceivedMessageLength;
	                
	                
	            END_IF;
	            
	        END_REGION
	        
	    END_IF;
	    
	END_REGION
	
	REGION 6 – Status
	    
	    REGION 6.1 - Block status
	        
	        // Receive error.
	        #ss_Status.ReceiveError := #ss_TRCV.Error;
	        
	        // Parametrization collective error output.
	        #qx_Error :=
	        #ss_Status.FIFOReceiveError
	        OR #ss_Status.ReceiveError;
	        
	        // Parametrization collective warning output.
	        #qx_Warning := #ss_Status.FIFOReceiveWarning;
	        
	    END_REGION
	    
	    REGION 6.2 - Error code preparation
	        
	        IF #ss_TRCV.#Status > 16#8000
	            OR #ss_TRCV.#Status = 16#0
	        THEN
	            #ss_Status.ErrorCode.TRCV := #ss_TRCV.#Status;
	        END_IF;
	        
	    END_REGION
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Visu_ArmDiverter_Status"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 135
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_ArmDiverterStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ArmDiverterStatus";   // ArmDiverter status structure
      i_UDT_EquipmentNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EquipmentNumber";   // Item number
      ix_SendAllErrorsState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - update all the messages
      ix_MFCConnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - A connection to the MFC has been established
      ix_CollectiveReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Collective reset command of all system controls
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block error
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block warning
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Message number
   END_VAR

   VAR 
      s_FB_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemStatus";   // Item status block's instance
      s_FB_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemError";   // Item error block's instance
      ss_FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoStatus";   // Status structure
      s_UDT_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Message";   // Message
      s_UDT_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemStatus";   // Item status message body structure
      s_UDT_ArmDiverterOldStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ArmDiverterStatus";   // ArmDiverter  old status structure
      s_UDT_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemError";   // Item error message body structure
      s_R_TRIG_Connection {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger connection reastablished
      s_F_TRIG_SendAllErrors {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger from signal send all errors
      sdi_Code { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Error code
      si_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Item status
      ii_ErrorNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Counter Error Number
      si_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Error state
      sx_ItemErrorMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error message required
      sx_ItemStatusMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status message required
      sx_SendAllProcedure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send all procedure
      sx_FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO error
      sx_FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO warning
      sx_ItemErrorBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block error
      sx_ItemErrorBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block warning
      sx_ItemStatusBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block error
      sx_ItemStatusBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block warning
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	21/03/2023  | 1.0       | M. Diebel   | Release TIA 17 | DHL Munich 2023
	04/03/2024  | 1.1       | M. Diebel   | Release TIA 17 | incremant #ii_ErrorNumber for reference error
	13/03/2024  | 1.2       | S. Nieswiec | Updated for new Baseline
	*)
	
	
	REGION 1 - Initialize message required signals
	    
	    #sx_ItemErrorMessageReq := FALSE;
	    #sx_ItemStatusMessageReq := FALSE;
	    
	    // On connection reestablish send last remembered status and error state ( status only when it's diffrent then 0 )
	    #s_R_TRIG_Connection(CLK := #ix_MFCConnected);
	    
	    IF #s_R_TRIG_Connection.Q AND #si_ItemStatus <> 0
	    THEN
	        #sx_ItemStatusMessageReq := TRUE;
	    END_IF;
	    
	    IF #s_R_TRIG_Connection.Q
	    THEN
	        #sx_ItemErrorMessageReq := TRUE;
	    END_IF;
	    
	    // Prepare trigger on the collective reset signal.
	    #s_F_TRIG_SendAllErrors(CLK := #ix_SendAllErrorsState);
	    
	    // When collective reset will go down, start send every equipment errors.
	    IF #s_F_TRIG_SendAllErrors.Q AND NOT #sx_SendAllProcedure
	    THEN
	        #ii_ErrorNumber := 0;
	        #sx_SendAllProcedure := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_FIFOStatus,
	              qx_Error => #sx_FIFOError,
	              qx_Warning => #sx_FIFOWarning,
	              iqv_Data := #s_UDT_Message,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 3 - Prepare message data
	    
	    // When there is no reset errors command, update status and errors.
	    IF NOT #ix_CollectiveReset
	        AND NOT #ss_FIFOStatus.FifoPreFull
	    THEN
	        // Status
	        IF (#i_UDT_ArmDiverterStatus.Status <> #s_UDT_ArmDiverterOldStatus.Status OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0))
	        THEN
	            #sx_ItemStatusMessageReq := TRUE;
	            #si_ItemStatus := #i_UDT_ArmDiverterStatus.Status;
	            #s_UDT_ArmDiverterOldStatus.Status := #i_UDT_ArmDiverterStatus.Status;
	        END_IF;
	        
	        
	        // Check which specific status changed, prepare code, change state and write new status into the old one.
	        IF (#i_UDT_ArmDiverterStatus.Specific.TimeoutError <> #s_UDT_ArmDiverterOldStatus.Specific.TimeoutError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".ArmDiverter.TimeoutError;
	            #si_State := BOOL_TO_INT(#i_UDT_ArmDiverterStatus.Specific.TimeoutError);
	            #s_UDT_ArmDiverterOldStatus.Specific.TimeoutError := #i_UDT_ArmDiverterStatus.Specific.TimeoutError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_ArmDiverterStatus.Specific.LimitHomeError <> #s_UDT_ArmDiverterOldStatus.Specific.LimitHomeError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 1)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".ArmDiverter.LimitHomeError;
	            #si_State := BOOL_TO_INT(#i_UDT_ArmDiverterStatus.Specific.LimitHomeError);
	            #s_UDT_ArmDiverterOldStatus.Specific.LimitHomeError := #i_UDT_ArmDiverterStatus.Specific.LimitHomeError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_ArmDiverterStatus.Specific.LimitDivertError <> #s_UDT_ArmDiverterOldStatus.Specific.LimitDivertError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 2)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".ArmDiverter.LimitDivertError;
	            #si_State := BOOL_TO_INT(#i_UDT_ArmDiverterStatus.Specific.LimitDivertError);
	            #s_UDT_ArmDiverterOldStatus.Specific.LimitDivertError := #i_UDT_ArmDiverterStatus.Specific.LimitDivertError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_ArmDiverterStatus.Specific.PXHomeError <> #s_UDT_ArmDiverterOldStatus.Specific.PXHomeError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 3)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".ArmDiverter.PXHomeError;
	            #si_State := BOOL_TO_INT(#i_UDT_ArmDiverterStatus.Specific.PXHomeError);
	            #s_UDT_ArmDiverterOldStatus.Specific.PXHomeError := #i_UDT_ArmDiverterStatus.Specific.PXHomeError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_ArmDiverterStatus.Specific.PXDivertError <> #s_UDT_ArmDiverterOldStatus.Specific.PXDivertError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 4)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".ArmDiverter.PXDivertError;
	            #si_State := BOOL_TO_INT(#i_UDT_ArmDiverterStatus.Specific.PXDivertError);
	            #s_UDT_ArmDiverterOldStatus.Specific.PXDivertError := #i_UDT_ArmDiverterStatus.Specific.PXDivertError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_ArmDiverterStatus.Specific.AtHomePosition <> #s_UDT_ArmDiverterOldStatus.Specific.AtHomePosition AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 5)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".ArmDiverter.AtHomePosition;
	            #si_State := BOOL_TO_INT(#i_UDT_ArmDiverterStatus.Specific.AtHomePosition);
	            #s_UDT_ArmDiverterOldStatus.Specific.AtHomePosition := #i_UDT_ArmDiverterStatus.Specific.AtHomePosition;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_ArmDiverterStatus.Specific.AtDivertPosition <> #s_UDT_ArmDiverterOldStatus.Specific.AtDivertPosition AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 6)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".ArmDiverter.AtDivertPosition;
	            #si_State := BOOL_TO_INT(#i_UDT_ArmDiverterStatus.Specific.AtDivertPosition);
	            #s_UDT_ArmDiverterOldStatus.Specific.AtDivertPosition := #i_UDT_ArmDiverterStatus.Specific.AtDivertPosition;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_ArmDiverterStatus.Specific.ReferencError <> #s_UDT_ArmDiverterOldStatus.Specific.ReferencError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 7)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".ArmDiverter.ReferencError;
	            #si_State := BOOL_TO_INT(#i_UDT_ArmDiverterStatus.Specific.ReferencError);
	            #s_UDT_ArmDiverterOldStatus.Specific.ReferencError := #i_UDT_ArmDiverterStatus.Specific.ReferencError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_ArmDiverterStatus.Specific.ParcelDivertError <> #s_UDT_ArmDiverterOldStatus.Specific.ParcelDivertError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 8)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".ArmDiverter.ParcelDivertError;
	            #si_State := BOOL_TO_INT(#i_UDT_ArmDiverterStatus.Specific.ParcelDivertError);
	            #s_UDT_ArmDiverterOldStatus.Specific.ParcelDivertError := #i_UDT_ArmDiverterStatus.Specific.ParcelDivertError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #sx_SendAllProcedure := FALSE;
	        END_IF;
	    END_IF;
	END_REGION
	
	REGION 4 - Write message components to the item error structure 
	    
	    #s_UDT_ItemError.ItemNumber := #i_UDT_EquipmentNumber;
	    #s_UDT_ItemError.Error := #sdi_Code;
	    #s_UDT_ItemError.State := #si_State;
	    #s_UDT_ItemError.Masked := 1;
	    
	END_REGION
	
	REGION 5 - Write message components to the item status structure
	    
	    #s_UDT_ItemStatus.Group := #i_UDT_EquipmentNumber.Group;
	    #s_UDT_ItemStatus.Node := #i_UDT_EquipmentNumber.Node;
	    #s_UDT_ItemStatus.Status := #si_ItemStatus;
	    
	END_REGION
	
	REGION 6 - Prepare messages to the MFC
	    
	    // If item error message required signal is set, prepare the item error message.
	    IF (#sx_ItemErrorMessageReq)
	    THEN
	        #s_FB_ItemError(i_UDT_ItemErrorBody := #s_UDT_ItemError,
	                        ii_MessageGroup := 1,
	                        ix_FlagRetry := FALSE,
	                        idi_TimeSpan := 0,
	                        qx_Error => #sx_ItemErrorBlockError,
	                        qx_Warning => #sx_ItemErrorBlockWarning,
	                        iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                        iqs_FifoData := #iqs_FifoData,
	                        iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	    // If item status message required signal is set, prepare the item error message.
	    IF (#sx_ItemStatusMessageReq)
	    THEN
	        #s_FB_ItemStatus(i_UDT_ItemStatusBody := #s_UDT_ItemStatus,
	                         ii_MessageGroup := 1,
	                         ix_FlagRetry := FALSE,
	                         idi_TimeSpan := 0,
	                         qx_Error => #sx_ItemStatusBlockError,
	                         qx_Warning => #sx_ItemStatusBlockWarning,
	                         iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                         iqs_FifoData := #iqs_FifoData,
	                         iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Write outputs
	    
	    // Prepare collective output error.
	    #qx_Error :=
	    #sx_ItemErrorBlockError
	    OR #sx_ItemStatusBlockError
	    OR #sx_FIFOError;
	    
	    // Prepare collective output warning.
	    #qx_Warning :=
	    #sx_ItemErrorBlockWarning
	    OR #sx_ItemStatusBlockWarning
	    OR #sx_FIFOWarning;
	    
	END_REGION
	
	
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Visu_TCPIPSend"
TITLE = FB_TCPIPSend
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : Communication
VERSION : 2.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 162
// END_ATTRIBUTES
//Function block to send data from TCPIP.
   VAR_INPUT 
      i_UDT_Connection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_Connection";   // Connection parameters
      ii_HeaderLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Message header length
      ii_BodyLengthPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Position in header where message body length value starts
      ix_EnableSend { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when send is enable
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block error occurred
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block warning occurred
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoLowHeader : "UDT_FifoHeader";   // Low priority FIFO header
      iqs_FifoLowData : Variant;   // Low priority FIFO data
      iq_UDT_FifoMediumHeader : "UDT_FifoHeader";   // Medium priority FIFO header
      iqs_FifoMediumData : Variant;   // Medium priority FIFO data
      iq_UDT_FifoHighHeader : "UDT_FifoHeader";   // High priority FIFO header
      iqs_FifoHighData : Variant;   // High priority FIFO data
   END_VAR

   VAR 
      s_FB_TSEND {InstructionName := 'TSEND'; LibVersion := '4.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TSEND;   // Siemens "TSEND" block - to send the data over TCPIP socket
      s_UDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message
      ss_TSEND { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // TSEND block structure
         Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   //    TSEND - Status
         Request { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    TSEND - Request
         Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    TSEND - Busy
         Done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    TSEND - Done
         Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //    TSEND - Error
      END_STRUCT;
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOLowPriorityStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";
         FIFOMedPriorityStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";
         FIFOHighPriorityStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";
         FIFOLowPriorityError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO low priority error
         FIFOLowPriorityWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO low priority warning
         FIFOMedPriorityError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO medium priority error
         FIFOMedPriorityWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO medium priority warning
         FIFOHighPriorityError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO high priority error
         FIFOHighPriorityWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO high priority warning
         SendError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send operation error
      END_STRUCT;
      sw_BodyLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Message body length
      si_MessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Message length
      sx_MessageReady { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message is ready to send
      sx_MessageRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message has been read
      sx_MessageReadRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request to read message
      sx_FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Summary FIFO error
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	24/10/2019  | 3.0       | L.Klar       | Initial version
	12/03/2020  | 3.1       | M.Kurpiers   | Adapting reviews
	16/01/2023  | 4.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 4.1       | S. Nieswiec  | Updated for new Baseline
	*)                                                                               
	
	REGION 1 – Update FIFO header status bits
	    
	    // Mode 'S' - High priority FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOHighPriorityStatus,
	              qx_Error => #ss_Status.FIFOHighPriorityError,
	              qx_Warning => #ss_Status.FIFOHighPriorityWarning,
	              iqv_Data := #s_UDT_MessageArray,
	              iqUDT_FifoHeader := #iq_UDT_FifoHighHeader,
	              iqv_DataBuffer := #iqs_FifoHighData);
	    
	    // Mode 'S' - Medium priority FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOMedPriorityStatus,
	              qx_Error => #ss_Status.FIFOMedPriorityError,
	              qx_Warning => #ss_Status.FIFOMedPriorityWarning,
	              iqv_Data := #s_UDT_MessageArray,
	              iqUDT_FifoHeader := #iq_UDT_FifoMediumHeader,
	              iqv_DataBuffer := #iqs_FifoMediumData);
	    
	    // Mode 'S' - Low priority FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOLowPriorityStatus,
	              qx_Error => #ss_Status.FIFOLowPriorityError,
	              qx_Warning => #ss_Status.FIFOLowPriorityWarning,
	              iqv_Data := #s_UDT_MessageArray,
	              iqUDT_FifoHeader := #iq_UDT_FifoLowHeader,
	              iqv_DataBuffer := #iqs_FifoLowData);
	    
	END_REGION
	
	REGION 2 – FIFO header summary error 
	    
	    #sx_FIFOError :=
	    #ss_Status.FIFOHighPriorityError
	    OR #ss_Status.FIFOMedPriorityError
	    OR #ss_Status.FIFOLowPriorityError;
	    
	END_REGION
	
	REGION 3 – FIFO Read request
	    
	    #sx_MessageReadRequest :=
	    #ix_EnableSend
	    AND NOT #sx_FIFOError
	    AND NOT #ss_TSEND.Error
	    AND #ss_TSEND.Status = 16#7000;
	    
	END_REGION
	
	REGION 4 – Read the message from high priority FIFO data buffer
	    
	    IF #sx_MessageReadRequest
	        AND NOT #iq_UDT_FifoHighHeader.Status.Empty
	        AND NOT #sx_MessageRead
	    THEN
	        // Mode 'R' - Read high priority FIFO record.
	        "FC_Fifo"(ic_Mode := 'R',
	                  qUDT_Status => #ss_Status.FIFOHighPriorityStatus,
	                  qx_Error => #ss_Status.FIFOHighPriorityError,
	                  qx_Warning => #ss_Status.FIFOHighPriorityWarning,
	                  iqv_Data := #s_UDT_MessageArray,
	                  iqUDT_FifoHeader := #iq_UDT_FifoHighHeader,
	                  iqv_DataBuffer := #iqs_FifoHighData);
	        
	        #sx_MessageRead := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 5 – Read the message from medium priority FIFO data buffer
	    
	    IF #sx_MessageReadRequest
	        AND #iq_UDT_FifoHighHeader.Status.Empty
	        AND NOT #iq_UDT_FifoMediumHeader.Status.Empty
	        AND NOT #sx_MessageRead
	    THEN
	        // Mode 'R' - Read medium priority FIFO record.
	        "FC_Fifo"(ic_Mode := 'R',
	                  qUDT_Status => #ss_Status.FIFOMedPriorityStatus,
	                  qx_Error => #ss_Status.FIFOMedPriorityError,
	                  qx_Warning => #ss_Status.FIFOMedPriorityWarning,
	                  iqv_Data := #s_UDT_MessageArray,
	                  iqUDT_FifoHeader := #iq_UDT_FifoMediumHeader,
	                  iqv_DataBuffer := #iqs_FifoMediumData);
	        
	        #sx_MessageRead := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 6 – Read the message from low priority FIFO data buffer
	    
	    IF #sx_MessageReadRequest
	        AND #iq_UDT_FifoHighHeader.Status.Empty
	        AND #iq_UDT_FifoMediumHeader.Status.Empty
	        AND NOT #iq_UDT_FifoLowHeader.Status.Empty
	        AND NOT #sx_MessageRead
	    THEN
	        #sx_MessageRead := TRUE;
	        
	        // Mode 'R' - Read low priority FIFO record.
	        "FC_Fifo"(ic_Mode := 'R',
	                  qUDT_Status => #ss_Status.FIFOLowPriorityStatus,
	                  qx_Error => #ss_Status.FIFOLowPriorityError,
	                  qx_Warning => #ss_Status.FIFOLowPriorityWarning,
	                  iqv_Data := #s_UDT_MessageArray,
	                  iqUDT_FifoHeader := #iq_UDT_FifoLowHeader,
	                  iqv_DataBuffer := #iqs_FifoLowData);
	    END_IF;
	    
	END_REGION
	
	REGION 7 – Message length
	    
	    // Measuring the length of a read message.
	    IF #sx_MessageRead
	        AND NOT #sx_MessageReady
	    THEN
	        // Initialize the message length. 
	        #si_MessageLength := 0;
	        
	        // Get the length of the message by extracting the body length from the message header. 
	        #sw_BodyLength := #s_UDT_MessageArray.Bytes[#ii_BodyLengthPosition];
	        #si_MessageLength := WORD_TO_INT(IN := SHL(IN := #sw_BodyLength, N := 8)) + BYTE_TO_INT(#s_UDT_MessageArray.Bytes[#ii_BodyLengthPosition + 1]) + #ii_HeaderLength;
	        #sx_MessageReady := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 8 – Send request
	    
	    IF #sx_MessageRead
	        AND #sx_MessageReady
	    THEN
	        #ss_TSEND.Request := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 9 – Send data
	    
	    #s_FB_TSEND(REQ := #ss_TSEND.Request,
	                ID := #i_UDT_Connection.ID,
	                LEN := INT_TO_UDINT(#si_MessageLength),
	                DONE => #ss_TSEND.Done,
	                BUSY => #ss_TSEND.Busy,
	                ERROR => #ss_TSEND.Error,
	                STATUS => #ss_TSEND.Status,
	                DATA := #s_UDT_MessageArray);
	    
	    // Reset send request, message read and ready bits.
	    IF #ss_TSEND.Request
	        AND NOT #ss_TSEND.Busy
	        AND (#ss_TSEND.Done
	        OR #ss_TSEND.Status = 16#7000)
	    THEN
	        #ss_TSEND.Request := FALSE;
	        #sx_MessageRead := FALSE;
	        #sx_MessageReady := FALSE;
	    END_IF;
	    
	    // Reset send error and TSEND status after correctly sent message.
	    IF #ss_TSEND.Done
	    THEN
	        #ss_Status.SendError := FALSE;
	    END_IF;
	    
	    // Set send error and TSEND status if error occured.
	    IF #ss_TSEND.Error
	    THEN
	        #ss_Status.SendError := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 10 – Status
	    
	    // Parametrization collective error output.
	    #qx_Error :=
	    #sx_FIFOError
	    OR #ss_Status.SendError;
	    
	    // Parametrization collective warning output.
	    #qx_Warning :=
	    #ss_Status.FIFOHighPriorityWarning
	    OR #ss_Status.FIFOMedPriorityWarning
	    OR #ss_Status.FIFOLowPriorityWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Visu_Conveyor_Status"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 141
// END_ATTRIBUTES
   VAR_INPUT 
      ix_SendAllErrorsState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - update all the messages
      ix_MFCConnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - A connection to the MFC has been established
      ix_CollectiveReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Collective reset command of all system controls
      i_UDT_MaintenanceCounterConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_MaintenanceCounterConfiguration" := (86400, 10000000, 100);   // Maintenance counter configuration
      i_UDT_ConveyorInterface { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorInterface";   // Input conveyor interface structrue
      i_UDT_ConveyorStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorStatus";   // Input Conveyor status structure
      i_UDT_EquipmentNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EquipmentNumber";   // Item number
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block error
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block warning
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Message number
   END_VAR

   VAR 
      s_FB_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemError";   // Item error block's instance
      s_FB_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemStatus";   // Item status block's instance
      s_FB_MaintenanceCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MaintenanceCounter";   // Maintenence counter message block instance
      s_UDT_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemError";   // Item error message body structure
      s_UDT_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemStatus";   // Item status message body structure
      s_UDT_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_BytesMessage";   // Message
      s_UDT_ConveyorOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";   // Conveyor old status structure
      s_UDT_ConveyorInterfaceOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorInterface";   // Conveyor old interface structure
      s_UDT_FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoStatus";   // FIFO status structure
      ss_FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoStatus";   // Status structure
      s_R_TRIG_ConveyorStart {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger Conveyor start
      s_R_TRIG_Connection {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger connection reastablished
      s_F_TRIG_ConveyorStop {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger Conveyor stop
      s_F_TRIG_SendAllErrors {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger from signal send all errors
      slr_RunningTimeMS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Conveyor running time [ms]
      sdi_DistanceTraveled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Distance traveled by conveyor
      sdi_StartStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Value of change conveyor state from start to stop and from stop to start
      sdi_Code { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Error code
      sdi_RunningTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Conveyor running time [s]
      si_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Item status
      si_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Error state
      ii_ErrorNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Counter Error Number
      sx_ItemErrorMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error message required
      sx_ItemStatusMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status message required
      sx_ItemErrorBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block error
      sx_ItemStatusBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block error
      sx_FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO error
      sx_FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO warning
      sx_MaintenanceCounterBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Maintenance counter block error
      sx_ItemStatusBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block warning
      sx_ItemErrorBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block warning
      sx_MaintenanceCounterBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Maintenance counter block warning
      sx_SendAllProcedure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send all procedure
   END_VAR

   VAR CONSTANT 
      ci_MessageGroup : Int := 1;
      ci_TimeSpan : Int := 0;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	03/01/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	09/08/2023  | 2.0       | S. Theocharis| Update with DB error code | DHL Munich 2023
	13/03/2023  | 2.1       | S. Nieswiec  | Updated for new Baseline
	
	*)
	
	REGION 1 - Initialize message required signals
	    
	    #sx_ItemErrorMessageReq := FALSE;
	    #sx_ItemStatusMessageReq := FALSE;
	    
	    // On connection reestablish send last remembered status and error state ( status only when it's diffrent then 0 )
	    #s_R_TRIG_Connection(CLK := #ix_MFCConnected);
	    
	    // IF #s_R_TRIG_Connection.Q AND #si_ItemStatus <> 0
	    // THEN
	    //     #ii_ErrorNumber := 0;
	    //     #sx_SendAllProcedure := TRUE;
	    //    // #sx_ItemStatusMessageReq := TRUE;
	    // END_IF;
	    
	    // IF #s_R_TRIG_Connection.Q
	    // THEN
	    //     #ii_ErrorNumber := 0;
	    //     #sx_SendAllProcedure := TRUE;
	    //    // #sx_ItemErrorMessageReq := TRUE;
	    // END_IF;
	    
	    // Prepare trigger on the collective reset signal.
	    #s_F_TRIG_SendAllErrors(CLK := #ix_SendAllErrorsState);
	    
	    // When collective reset will go down, start send every equipment errors.
	    IF #s_F_TRIG_SendAllErrors.Q AND NOT #sx_SendAllProcedure
	    THEN
	        #ii_ErrorNumber := 0;
	        #sx_SendAllProcedure := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - O header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_FIFOStatus,
	              qx_Error => #sx_FIFOError,
	              qx_Warning => #sx_FIFOWarning,
	              iqv_Data := #s_UDT_Message,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 2 - Prepare message data
	    
	    // When there is no reset errors command, update status and errors.
	    IF NOT #ix_CollectiveReset
	        AND NOT #ss_FIFOStatus.FifoPreFull
	    THEN
	        
	        IF (#i_UDT_ConveyorStatus.Status <> #s_UDT_ConveyorOld.Status OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0))
	        THEN
	            #sx_ItemStatusMessageReq := TRUE;
	            #si_ItemStatus := #i_UDT_ConveyorStatus.Status;
	            #s_UDT_ConveyorOld.Status := #i_UDT_ConveyorStatus.Status;
	        END_IF;
	        
	        // Check which specific status changed, prepare code, change state and write new status into the old one.
	        (* 
	       // Do not send the internal tracking error / / internal tracking warning 
	        IF (#i_UDT_ConveyorInterface.InternalErrorTracking <> #s_UDT_ConveyorInterfaceOld.InternalErrorTracking AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0)
	            
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".ConveyorInterface.InternalErrorTracking;
	            #si_State := BOOL_TO_INT(#i_UDT_ConveyorInterface.InternalErrorTracking);
	            #s_UDT_ConveyorInterfaceOld.InternalErrorTracking := #i_UDT_ConveyorInterface.InternalErrorTracking;
	            #sx_ItemErrorMessageReq := TRUE;
	            // #qw_AlarmWord1.%X0 := #s_UDT_ConveyorInterface.InternalErrorTracking;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_ConveyorInterface.InternalWarningTracking <> #s_UDT_ConveyorInterfaceOld.InternalWarningTracking AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 1)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".ConveyorInterface.InternalWarningTracking;
	            #si_State := BOOL_TO_INT(#i_UDT_ConveyorInterface.InternalWarningTracking);
	            #s_UDT_ConveyorInterfaceOld.InternalWarningTracking := #i_UDT_ConveyorInterface.InternalWarningTracking;
	            #sx_ItemErrorMessageReq := TRUE;
	            //  #qw_AlarmWord1.%X1 := #s_UDT_ConveyorInterface.InternalWarningTracking;
	            #ii_ErrorNumber += 1;
	            
	        ELSIF (#i_UDT_ConveyorInterface.Disconnected <> #s_UDT_ConveyorInterfaceOld.Disconnected AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 2)
	        *)
	        IF (#i_UDT_ConveyorInterface.Disconnected <> #s_UDT_ConveyorInterfaceOld.Disconnected AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0)
	            
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".ConveyorInterface.Disconnected;
	            #si_State := BOOL_TO_INT(#i_UDT_ConveyorInterface.Disconnected);
	            #s_UDT_ConveyorInterfaceOld.Disconnected := #i_UDT_ConveyorInterface.Disconnected;
	            #sx_ItemErrorMessageReq := TRUE;
	            // #qw_AlarmWord1.%X2 := #s_UDT_ConveyorInterface.Disconnected;
	            #sx_SendAllProcedure := FALSE;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Write message components to the item error structure 
	    
	    #s_UDT_ItemError.ItemNumber := #i_UDT_EquipmentNumber;
	    #s_UDT_ItemError.Error := #sdi_Code;
	    #s_UDT_ItemError.State := #si_State;
	    #s_UDT_ItemError.Masked := 1;
	    
	END_REGION
	
	REGION 4 - Write message components to the item status structure
	    
	    
	    #s_UDT_ItemStatus.Group := #i_UDT_EquipmentNumber.Group;
	    #s_UDT_ItemStatus.Node := #i_UDT_EquipmentNumber.Node;
	    #s_UDT_ItemStatus.Status := #si_ItemStatus;
	    
	END_REGION
	
	REGION 5 - Prepare messages to the MFC
	    
	    // If item error message required signal is set, prepare the item error message.
	    IF (#sx_ItemErrorMessageReq)
	    THEN
	        #s_FB_ItemError(i_UDT_ItemErrorBody := #s_UDT_ItemError,
	                        ii_MessageGroup := #ci_MessageGroup,
	                        ix_FlagRetry := FALSE,
	                        idi_TimeSpan := #ci_TimeSpan,
	                        qx_Error => #sx_ItemErrorBlockError,
	                        qx_Warning => #sx_ItemErrorBlockWarning,
	                        iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                        iqs_FifoData := #iqs_FifoData,
	                        iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	    // If item status message required signal is set, prepare the item error message.
	    IF (#sx_ItemStatusMessageReq)
	    THEN
	        #s_FB_ItemStatus(i_UDT_ItemStatusBody := #s_UDT_ItemStatus,
	                         ii_MessageGroup := #ci_MessageGroup,
	                         ix_FlagRetry := FALSE,
	                         idi_TimeSpan := #ci_TimeSpan,
	                         qx_Error => #sx_ItemStatusBlockError,
	                         qx_Warning => #sx_ItemStatusBlockWarning,
	                         iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                         iqs_FifoData := #iqs_FifoData,
	                         iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Maintenance counter message
	    
	    // Maintenance counter message is used to inform the MFC about one of three values. When one of them exceed the configured one, message is prepared and sent.
	    // Values which program is counting :
	    // - distance traveled by conveyor,
	    // - change the state of the conveyor ( stop --> start and start --> stop)
	    // - running time of the conveyor.
	    
	    // Calculate conveyor traveled distance.
	    #sdi_DistanceTraveled += #i_UDT_ConveyorInterface.Displacement * 10;
	    
	    // Calculate start-stop.
	    #s_R_TRIG_ConveyorStart(CLK := #i_UDT_ConveyorInterface.RunFwd OR #i_UDT_ConveyorInterface.RunRvs);
	    #s_F_TRIG_ConveyorStop(CLK := #i_UDT_ConveyorInterface.RunRvs OR #i_UDT_ConveyorInterface.RunFwd);
	    
	    // Increment counter on the change of the conveyor's state.
	    IF #s_R_TRIG_ConveyorStart.Q
	        OR #s_F_TRIG_ConveyorStop.Q
	    THEN
	        #sdi_StartStop += 1;
	    END_IF;
	    
	    // Calculate running time.
	    IF #i_UDT_ConveyorInterface.RunFwd
	        OR #i_UDT_ConveyorInterface.RunRvs
	    THEN
	        #slr_RunningTimeMS += "DB_Memory".PrevCycleTime;
	        
	        IF #slr_RunningTimeMS >= 1000
	        THEN
	            #sdi_RunningTime += 1;
	            #slr_RunningTimeMS -= 1000;
	        END_IF;
	        
	    END_IF;
	    
	    // Prepare the maintenance counter message when one of the counted values is equal or bigger then configured one.
	    IF #sdi_RunningTime >= #i_UDT_MaintenanceCounterConfiguration.RunningTime
	        OR #sdi_DistanceTraveled >= #i_UDT_MaintenanceCounterConfiguration.DistanceTraveled
	        OR #sdi_StartStop >= #i_UDT_MaintenanceCounterConfiguration."Start-Stop"
	    THEN
	        
	        #s_FB_MaintenanceCounter(ii_Group := #i_UDT_EquipmentNumber.Group,
	                                 ii_Node := #i_UDT_EquipmentNumber.Node,
	                                 idi_RunningTime := #sdi_RunningTime,
	                                 idi_DistanceTravelled := #sdi_DistanceTraveled,
	                                 "idi_Start-Stop" := #sdi_StartStop,
	                                 ii_MessageGroup := #ci_MessageGroup,
	                                 ix_FlagRetry := FALSE,
	                                 idi_TimeSpan := #ci_TimeSpan,
	                                 qx_Error => #sx_MaintenanceCounterBlockError,
	                                 qx_Warning => #sx_MaintenanceCounterBlockWarning,
	                                 iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                                 iqs_FifoData := #iqs_FifoData,
	                                 iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	        
	        #slr_RunningTimeMS := 0;
	        #sdi_RunningTime := 0;
	        #sdi_DistanceTraveled := 0;
	        #sdi_StartStop := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 8 - Write outputs
	    
	    // Prepare collective output error.
	    #qx_Error :=
	    #sx_ItemErrorBlockError
	    OR #sx_ItemStatusBlockError
	    OR #sx_MaintenanceCounterBlockError
	    OR #sx_FIFOError;
	    
	    // Prepare collective output warning.
	    #qx_Warning :=
	    #sx_ItemErrorBlockWarning
	    OR #sx_ItemStatusBlockWarning
	    OR #sx_MaintenanceCounterBlockWarning
	    OR #sx_FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Visu_Caljan_Status"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 2.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 137
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_CaljanStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CaljanStatusV2";   // Caljan status structure
      i_UDT_EquipmentNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EquipmentNumber";   // Item number
      ix_SendAllErrorsState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - update all the messages
      ix_MFCConnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - A connection to the MFC has been established
      ix_CollectiveReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Collective reset command of all system controls
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block error
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block warning
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Message number
   END_VAR

   VAR 
      s_FB_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemError";   // Item error block's instance
      s_FB_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemStatus";   // Item status block's instance
      ss_FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoStatus";   // Status structure
      s_UDT_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message
      s_UDT_CaljanOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CaljanStatusV2";   // Caljan status structure
      s_UDT_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemError";   // Item error message body structure
      s_UDT_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemStatus";   // Item status message body structure
      s_R_TRIG_Connection {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger connection reastablished
      s_F_TRIG_SendAllErrors {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger from signal send all errors
      sdi_Code { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Error code
      si_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Item status
      ii_ErrorNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Counter Error Number
      si_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Error state
      sx_ItemErrorMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error message required
      sx_ItemStatusMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status message required
      sx_SendAllProcedure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send all procedure
      sx_FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO error
      sx_FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO warning
      sx_ItemErrorBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block error
      sx_ItemErrorBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block warning
      sx_ItemStatusBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block error
      sx_ItemStatusBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block warning
   END_VAR

   VAR_TEMP 
      t_UDT_CaljanStatus : "UDT_CaljanStatusV2";   // Caljan status structure
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	21/03/2023  | 1.0       | M. Diebel   | Release TIA 17 | DHL Munich 2023
	05/09/2023  | 2.0       | M. Diebel   | Disable the information messages to MFC
	13/03/2023  | 2.1       | S. Nieswiec | Updated for new Baseline
	*)
	
	
	REGION 1 - Initialize message required signals
	    
	    //Disable the information messages
	    // - Run mode 
	    // - Store mode
	    // - Chute Disabled
	    // These information and statuses are generated in the Caljan conveyor but visuzalized in other elemenents of the 3D model
	    #t_UDT_CaljanStatus := #i_UDT_CaljanStatus;
	    #t_UDT_CaljanStatus.Specific.ChuteBlocked := FALSE;
	    #t_UDT_CaljanStatus.Specific.StoreMode := FALSE;
	    #t_UDT_CaljanStatus.Specific.RunMode := FALSE;
	    
	    #sx_ItemErrorMessageReq := FALSE;
	    #sx_ItemStatusMessageReq := FALSE;
	    
	    // On connection reestablish send last remembered status and error state ( status only when it's diffrent then 0 )
	    #s_R_TRIG_Connection(CLK := #ix_MFCConnected);
	    
	    IF #s_R_TRIG_Connection.Q AND #si_ItemStatus <> 0
	    THEN
	        #sx_ItemStatusMessageReq := TRUE;
	    END_IF;
	    
	    IF #s_R_TRIG_Connection.Q
	    THEN
	        #sx_ItemErrorMessageReq := TRUE;
	    END_IF;
	    
	    // Prepare trigger on the collective reset signal.
	    #s_F_TRIG_SendAllErrors(CLK := #ix_SendAllErrorsState);
	    
	    // When collective reset will go down, start send every equipment errors.
	    IF #s_F_TRIG_SendAllErrors.Q AND NOT #sx_SendAllProcedure
	    THEN
	        #ii_ErrorNumber := 0;
	        #sx_SendAllProcedure := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_FIFOStatus,
	              qx_Error => #sx_FIFOError,
	              qx_Warning => #sx_FIFOWarning,
	              iqv_Data := #s_UDT_Message,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 3 - Prepare message data
	    
	    // When there is no reset errors command, update status and errors.
	    IF NOT #ix_CollectiveReset
	        AND NOT #ss_FIFOStatus.FifoPreFull
	    THEN
	        // Status
	        IF (#t_UDT_CaljanStatus.Status <> #s_UDT_CaljanOld.Status OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0))
	        THEN
	            #sx_ItemStatusMessageReq := TRUE;
	            #si_ItemStatus := #t_UDT_CaljanStatus.Status;
	            #s_UDT_CaljanOld.Status := #t_UDT_CaljanStatus.Status;
	        END_IF;
	        
	        
	        // Check which specific status changed, prepare code, change state and write new status into the old one.
	        IF (#t_UDT_CaljanStatus.Specific.PNSlaveNotOnline <> #s_UDT_CaljanOld.Specific.PNSlaveNotOnline AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".Caljan.PNSlaveNotOnline;
	            #si_State := BOOL_TO_INT(#t_UDT_CaljanStatus.Specific.PNSlaveNotOnline);
	            #s_UDT_CaljanOld.Specific.PNSlaveNotOnline := #t_UDT_CaljanStatus.Specific.PNSlaveNotOnline;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#t_UDT_CaljanStatus.Specific.PNSlaveError <> #s_UDT_CaljanOld.Specific.PNSlaveError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 1)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".Caljan.PNSlaveError;
	            #si_State := BOOL_TO_INT(#t_UDT_CaljanStatus.Specific.PNSlaveError);
	            #s_UDT_CaljanOld.Specific.PNSlaveError := #t_UDT_CaljanStatus.Specific.PNSlaveError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#t_UDT_CaljanStatus.Specific.PNSlaveWarning <> #s_UDT_CaljanOld.Specific.PNSlaveWarning AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 2)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".Caljan.PNSlaveWarning;
	            #si_State := BOOL_TO_INT(#t_UDT_CaljanStatus.Specific.PNSlaveWarning);
	            #s_UDT_CaljanOld.Specific.PNSlaveWarning := #t_UDT_CaljanStatus.Specific.PNSlaveWarning;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#t_UDT_CaljanStatus.Specific.Disabled <> #s_UDT_CaljanOld.Specific.Disabled AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 3)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".Caljan.Disabled;
	            #si_State := BOOL_TO_INT(#t_UDT_CaljanStatus.Specific.Disabled);
	            #s_UDT_CaljanOld.Specific.Disabled := #t_UDT_CaljanStatus.Specific.Disabled;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#t_UDT_CaljanStatus.Specific.VFDError <> #s_UDT_CaljanOld.Specific.VFDError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 4)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".Caljan.VFDError;
	            #si_State := BOOL_TO_INT(#t_UDT_CaljanStatus.Specific.VFDError);
	            #s_UDT_CaljanOld.Specific.VFDError := #t_UDT_CaljanStatus.Specific.VFDError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#t_UDT_CaljanStatus.Specific.NotHealthy <> #s_UDT_CaljanOld.Specific.NotHealthy AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 5)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".Caljan.NotHealthy;
	            #si_State := BOOL_TO_INT(#t_UDT_CaljanStatus.Specific.NotHealthy);
	            #s_UDT_CaljanOld.Specific.NotHealthy := #t_UDT_CaljanStatus.Specific.NotHealthy;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#t_UDT_CaljanStatus.Specific.StoreMode <> #s_UDT_CaljanOld.Specific.StoreMode AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 6)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".Caljan.StoreMode;
	            #si_State := BOOL_TO_INT(#t_UDT_CaljanStatus.Specific.StoreMode);
	            #s_UDT_CaljanOld.Specific.StoreMode := #t_UDT_CaljanStatus.Specific.StoreMode;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#t_UDT_CaljanStatus.Specific.RunMode <> #s_UDT_CaljanOld.Specific.RunMode AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 7)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".Caljan.RunMode;
	            #si_State := BOOL_TO_INT(#t_UDT_CaljanStatus.Specific.RunMode);
	            #s_UDT_CaljanOld.Specific.RunMode := #t_UDT_CaljanStatus.Specific.RunMode;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#t_UDT_CaljanStatus.Specific.ChuteBlocked <> #s_UDT_CaljanOld.Specific.ChuteBlocked AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 8)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".Caljan.ChuteBlocked;
	            #si_State := BOOL_TO_INT(#t_UDT_CaljanStatus.Specific.ChuteBlocked);
	            #s_UDT_CaljanOld.Specific.ChuteBlocked := #t_UDT_CaljanStatus.Specific.ChuteBlocked;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	            
	        ELSIF (#t_UDT_CaljanStatus.Specific.PEC_EoS.PEC <> #s_UDT_CaljanOld.Specific.PEC_EoS.PEC AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 9)
	        THEN
	            #sx_ItemErrorMessageReq := TRUE;
	            #s_UDT_CaljanOld.Specific.PEC_EoS.PEC := #t_UDT_CaljanStatus.Specific.PEC_EoS.PEC;
	            #ii_ErrorNumber += 1;
	        ELSIF (#t_UDT_CaljanStatus.Specific.PEC_EoS.Jam <> #s_UDT_CaljanOld.Specific.PEC_EoS.Jam AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 10)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".Caljan.Jam;
	            #si_State := BOOL_TO_INT(#t_UDT_CaljanStatus.Specific.PEC_EoS.Jam);
	            #s_UDT_CaljanOld.Specific.PEC_EoS.Jam := #t_UDT_CaljanStatus.Specific.PEC_EoS.Jam;
	            #sx_ItemErrorMessageReq := TRUE;
	            #sx_SendAllProcedure := FALSE;
	        END_IF;
	    END_IF;
	END_REGION
	
	REGION 4 - Write message components to the item error structure 
	    
	    #s_UDT_ItemError.ItemNumber := #i_UDT_EquipmentNumber;
	    #s_UDT_ItemError.Error := #sdi_Code;
	    #s_UDT_ItemError.State := #si_State;
	    #s_UDT_ItemError.Masked := 1;
	    
	END_REGION
	
	REGION 5 - Write message components to the item status structure
	    
	    #s_UDT_ItemStatus.Group := #i_UDT_EquipmentNumber.Group;
	    #s_UDT_ItemStatus.Node := #i_UDT_EquipmentNumber.Node;
	    #s_UDT_ItemStatus.Status := #si_ItemStatus;
	    
	END_REGION
	
	REGION 6 - Prepare messages to the MFC
	    
	    // If item error message required signal is set, prepare the item error message.
	    IF (#sx_ItemErrorMessageReq)
	    THEN
	        #s_FB_ItemError(i_UDT_ItemErrorBody := #s_UDT_ItemError,
	                        ii_MessageGroup := 1,
	                        ix_FlagRetry := FALSE,
	                        idi_TimeSpan := 0,
	                        qx_Error => #sx_ItemErrorBlockError,
	                        qx_Warning => #sx_ItemErrorBlockWarning,
	                        iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                        iqs_FifoData := #iqs_FifoData,
	                        iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	    // If item status message required signal is set, prepare the item error message.
	    IF (#sx_ItemStatusMessageReq)
	    THEN
	        #s_FB_ItemStatus(i_UDT_ItemStatusBody := #s_UDT_ItemStatus,
	                         ii_MessageGroup := 1,
	                         ix_FlagRetry := FALSE,
	                         idi_TimeSpan := 0,
	                         qx_Error => #sx_ItemStatusBlockError,
	                         qx_Warning => #sx_ItemStatusBlockWarning,
	                         iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                         iqs_FifoData := #iqs_FifoData,
	                         iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Write outputs
	    
	    // Prepare collective output error.
	    #qx_Error :=
	    #sx_ItemErrorBlockError
	    OR #sx_ItemStatusBlockError
	    OR #sx_FIFOError;
	    
	    // Prepare collective output warning.
	    #qx_Warning :=
	    #sx_ItemErrorBlockWarning
	    OR #sx_ItemStatusBlockWarning
	    OR #sx_FIFOWarning;
	    
	END_REGION
	
	
	
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Visu_VFD_Status"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 163
// END_ATTRIBUTES
   VAR_INPUT 
      ix_SendAllErrorsState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - update all the messages
      ix_MFCConnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - A connection to the MFC has been established
      ix_CollectiveReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Collective reset command of all system controls
      iUDT_VFDStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdStatus";   // VFD status structrue
      iUDT_EquipmentNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EquipmentNumber";   // Equipment Number
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block error
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block warning
   END_VAR

   VAR_IN_OUT 
      iqUDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqsFifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Message number
   END_VAR

   VAR 
      s_FB_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemError";   // Item error block's instance
      s_UDT_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_BytesMessage";   // Message
      s_UDT_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemError";   // Item error message body structure
      "i_UDT_VFDStatus.OLD" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatus";   // VFD old status structure
      ss_FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoStatus";   // Status structure
      s_R_TRIG_Connection {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger connection reastablished
      s_F_TRIG_SendAllErrors {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger from signal send all errors
      sdi_Code { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Error code
      si_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Error state
      ii_ErrorNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Counter "Error Number"
      sx_ItemErrorMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error message required
      sx_ItemErrorBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block error
      sx_ItemErrorBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block warning
      sx_SendAllProcedure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send all procedure
      sx_FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO Error
      sx_FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO Warning
      sx_FirstCycle { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	03/01/2023  | 1.0       | S. Nikodem   | Release TIA 17     | DHL Munich 2023
	11/08/2023  | 1.1       | M.Diebel     | Send all procedure | DHL Munich 2023
	13/03/2023  | 1.2       | S. Nieswiec  | Updated for new Baseline
	*)
	
	REGION 1 - Initialize message required signals
	    
	    #sx_ItemErrorMessageReq := FALSE;
	    
	    // On connection reestablish send last remembered status and error state ( status only when it's diffrent then 0 )
	    #s_R_TRIG_Connection(CLK := #ix_MFCConnected);
	    
	    
	    IF #s_R_TRIG_Connection.Q
	    THEN
	        #sx_SendAllProcedure := TRUE;
	        #ii_ErrorNumber := 0;
	    END_IF;
	    
	    // Prepare trigger on the collective reset signal.
	    #s_F_TRIG_SendAllErrors(CLK := #ix_SendAllErrorsState);
	    
	    // When collective reset will go down, start send every equipment errors.
	    IF #s_F_TRIG_SendAllErrors.Q AND NOT #sx_SendAllProcedure
	    THEN
	        #ii_ErrorNumber := 0;
	        #sx_SendAllProcedure := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_FIFOStatus,
	              qx_Error => #sx_FIFOError,
	              qx_Warning => #sx_FIFOWarning,
	              iqv_Data := #s_UDT_Message,
	              iqUDT_FifoHeader := #iqUDT_FifoHeader,
	              iqv_DataBuffer := #iqsFifoData);
	    
	END_REGION
	
	REGION 3 - Prepare message data
	    
	    // When there is no reset errors command, update status and errors.
	    IF NOT #ix_CollectiveReset
	        AND NOT #ss_FIFOStatus.FifoPreFull
	    THEN
	        
	        
	        // If the status changed, set item error message required signal.
	        IF (#iUDT_VFDStatus <> #"i_UDT_VFDStatus.OLD" OR #sx_SendAllProcedure OR #sx_FirstCycle)
	        THEN
	            #sx_ItemErrorMessageReq := TRUE;
	            
	            #"i_UDT_VFDStatus.OLD".ErrorCode := #iUDT_VFDStatus.ErrorCode;
	            #"i_UDT_VFDStatus.OLD".SubErrorCode := #iUDT_VFDStatus.SubErrorCode;
	            
	            // Check which specific status changed, prepare code, change state and write new status into the old one.
	            IF (#iUDT_VFDStatus.CommunicationErrorMovikit <> #"i_UDT_VFDStatus.OLD".CommunicationErrorMovikit AND NOT #sx_SendAllProcedure)
	                OR ((#sx_SendAllProcedure OR #sx_FirstCycle) AND #ii_ErrorNumber = 0)
	            THEN
	                #sdi_Code := "DB_MFC_ErrorCode".VFD.CommunicationErrorMovikit;
	                #si_State := BOOL_TO_INT(#iUDT_VFDStatus.CommunicationErrorMovikit);
	                #"i_UDT_VFDStatus.OLD".CommunicationErrorMovikit := #iUDT_VFDStatus.CommunicationErrorMovikit;
	                #ii_ErrorNumber += 1;
	            ELSIF (#iUDT_VFDStatus.InternalError <> #"i_UDT_VFDStatus.OLD".InternalError AND NOT #sx_SendAllProcedure)
	                OR ((#sx_SendAllProcedure OR #sx_FirstCycle) AND #ii_ErrorNumber = 1)
	            THEN
	                #sdi_Code := "DB_MFC_ErrorCode".VFD.InternalError;
	                #si_State := BOOL_TO_INT(#iUDT_VFDStatus.InternalError);
	                #"i_UDT_VFDStatus.OLD".InternalError := #iUDT_VFDStatus.InternalError;
	                #ii_ErrorNumber += 1;
	            ELSIF (#iUDT_VFDStatus.InternalWarning <> #"i_UDT_VFDStatus.OLD".InternalWarning AND NOT #sx_SendAllProcedure)
	                OR ((#sx_SendAllProcedure OR #sx_FirstCycle) AND #ii_ErrorNumber = 2)
	            THEN
	                #sdi_Code := "DB_MFC_ErrorCode".VFD.InternalWarning;
	                #si_State := BOOL_TO_INT(#iUDT_VFDStatus.InternalWarning);
	                #"i_UDT_VFDStatus.OLD".InternalWarning := #iUDT_VFDStatus.InternalWarning;
	                #ii_ErrorNumber += 1;
	                // ELSIF (#i_UDT_VFDStatus.OutOfPosition_Error <> #i_UDT_VFDStatus.OLD.OutOfPosition_Error AND NOT #sx_SendAllProcedure)
	                //     OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 3)
	                // THEN
	                //     #sdi_Code := 104;
	                //     #si_State := BOOL_TO_INT(#i_UDT_VFDStatus..OutOfPosition_Error);
	                //     #i_UDT_VFDStatus.OLD.OutOfPosition_Error := #i_UDT_VFDStatus.OutOfPosition_Error;
	                //     #ii_ErrorNumber += 1;
	            ELSIF (#iUDT_VFDStatus.PNSlaveError <> #"i_UDT_VFDStatus.OLD".PNSlaveError AND NOT #sx_SendAllProcedure)
	                OR ((#sx_SendAllProcedure OR #sx_FirstCycle) AND #ii_ErrorNumber = 3)
	            THEN
	                #sdi_Code := "DB_MFC_ErrorCode".VFD.PNSlaveError;
	                #si_State := BOOL_TO_INT(#iUDT_VFDStatus.PNSlaveError);
	                #"i_UDT_VFDStatus.OLD".PNSlaveError := #iUDT_VFDStatus.PNSlaveError;
	                #ii_ErrorNumber += 1;
	            ELSIF (#iUDT_VFDStatus.PNSlaveNotonline <> #"i_UDT_VFDStatus.OLD".PNSlaveNotonline AND NOT #sx_SendAllProcedure)
	                OR ((#sx_SendAllProcedure OR #sx_FirstCycle) AND #ii_ErrorNumber = 4)
	            THEN
	                #sdi_Code := "DB_MFC_ErrorCode".VFD.PNSlaveNotonline;
	                #si_State := BOOL_TO_INT(#iUDT_VFDStatus.PNSlaveNotonline);
	                #"i_UDT_VFDStatus.OLD".PNSlaveNotonline := #iUDT_VFDStatus.PNSlaveNotonline;
	                #ii_ErrorNumber += 1;
	            ELSIF (#iUDT_VFDStatus.PNSlaveWarning <> #"i_UDT_VFDStatus.OLD".PNSlaveWarning AND NOT #sx_SendAllProcedure)
	                OR ((#sx_SendAllProcedure OR #sx_FirstCycle) AND #ii_ErrorNumber = 5)
	            THEN
	                #sdi_Code := "DB_MFC_ErrorCode".VFD.PNSlaveWarning;
	                #si_State := BOOL_TO_INT(#iUDT_VFDStatus.PNSlaveWarning);
	                #"i_UDT_VFDStatus.OLD".PNSlaveWarning := #iUDT_VFDStatus.PNSlaveWarning;
	                #ii_ErrorNumber += 1;
	            ELSIF (#iUDT_VFDStatus.VFDRunningFeedbackError <> #"i_UDT_VFDStatus.OLD".VFDRunningFeedbackError AND NOT #sx_SendAllProcedure)
	                OR ((#sx_SendAllProcedure OR #sx_FirstCycle) AND #ii_ErrorNumber = 6)
	            THEN
	                #sdi_Code := "DB_MFC_ErrorCode".VFD.VFDRunningFeedbackError;
	                #si_State := BOOL_TO_INT(#iUDT_VFDStatus.VFDRunningFeedbackError);
	                #"i_UDT_VFDStatus.OLD".VFDRunningFeedbackError := #iUDT_VFDStatus.VFDRunningFeedbackError;
	                #sx_SendAllProcedure := FALSE;
	                #sx_FirstCycle := FALSE;
	            END_IF;
	            
	            // // Prepare the alarm word.
	            // #qw_AlarmWord1.%X0 := #i_UDT_VFDStatus..CommunicationErrorMovikit;
	            // #qw_AlarmWord1.%X1 := #i_UDT_VFDStatus..InternalError;
	            // #qw_AlarmWord1.%X2 := #i_UDT_VFDStatus..InternalWarning;
	            // #qw_AlarmWord1.%X3 := #i_UDT_VFDStatus..OutOfPosition_Error;
	            // #qw_AlarmWord1.%X4 := #i_UDT_VFDStatus..PNSlaveError;
	            // #qw_AlarmWord1.%X5 := #i_UDT_VFDStatus..PNSlaveNotonline;
	            // #qw_AlarmWord1.%X6 := #i_UDT_VFDStatus..PNSlaveWarning;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Write message components to the item error structure 
	    
	    #s_UDT_ItemError.ItemNumber := #iUDT_EquipmentNumber;
	    #s_UDT_ItemError.Error := #sdi_Code;
	    #s_UDT_ItemError.State := #si_State;
	    #s_UDT_ItemError.Masked := 1;
	    
	END_REGION
	
	REGION 5 - Prepare messages to the MFC
	    
	    // If item error message required signal is set, prepare the item error message.
	    IF (#sx_ItemErrorMessageReq)
	    THEN
	        #s_FB_ItemError(i_UDT_ItemErrorBody := #s_UDT_ItemError,
	                        ii_MessageGroup := 1,
	                        ix_FlagRetry := FALSE,
	                        idi_TimeSpan := 0,
	                        qx_Error => #sx_ItemErrorBlockError,
	                        qx_Warning => #sx_ItemErrorBlockWarning,
	                        iq_UDT_FifoHeader := #iqUDT_FifoHeader,
	                        iqs_FifoData := #iqsFifoData,
	                        iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Write outputs
	    
	    // Prepare collective output error.
	    #qx_Error := #sx_ItemErrorBlockError
	    OR #sx_FIFOError;
	    
	    // Prepare collective output warning.
	    #qx_Warning := #sx_ItemErrorBlockWarning
	    OR #sx_FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Visu_ColumnLift_Status"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 2.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 139
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_ColumnLiftStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ColumnLift_Status";
      i_UDT_EquipmentNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EquipmentNumber";   // Item number
      ix_SendAllErrorsState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - update all the messages
      ix_MFCConnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - A connection to the MFC has been established
      ix_CollectiveReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Collective reset command of all system controls
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block error
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block warning
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Message number
   END_VAR

   VAR 
      s_FB_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemError";   // Item error block's instance
      s_FB_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemStatus";   // Item status block's instance
      ss_FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoStatus";   // Status structure
      s_UDT_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message
      s_UDT_ColumnLiftOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ColumnLift_Status";   // ColumnLift status structure
      s_UDT_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemError";   // Item error message body structure
      s_UDT_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemStatus";   // Item status message body structure
      s_R_TRIG_Connection {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger connection reastablished
      s_F_TRIG_SendAllErrors {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger from signal send all errors
      sdi_Code { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Error code
      si_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Item status
      ii_ErrorNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Counter Error Number
      si_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Error state
      sx_ItemErrorMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error message required
      sx_ItemStatusMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status message required
      sx_SendAllProcedure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send all procedure
      sx_FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO error
      sx_FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO warning
      sx_ItemErrorBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block error
      sx_ItemErrorBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block warning
      sx_ItemStatusBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block error
      sx_ItemStatusBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block warning
   END_VAR

   VAR_TEMP 
      t_UDT_ColumnLiftStatus : "UDT_ColumnLift_Status";   // ColumnLift status structure
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	24/04/2023  | 1.0       | M. Diebel   | Release TIA 17 | DHL Munich 2023
	11/09/2023  | 2.0       | M. Diebel   | Disable the information messages to MFC
	13/03/2023  | 2.1       | S. Nieswiec  | Updated for new Baseline
	*)
	
	
	REGION 1 - Initialize message required signals
	    //Move input to temp 
	    #t_UDT_ColumnLiftStatus := #i_UDT_ColumnLiftStatus;
	    //Disable the information messages
	    //-UpperPosition
	    //-LowerPosition
	    #t_UDT_ColumnLiftStatus.Specific.UpperPosition := False;
	    #t_UDT_ColumnLiftStatus.Specific.LowerPosition := False;
	    
	    
	    #sx_ItemErrorMessageReq := FALSE;
	    #sx_ItemStatusMessageReq := FALSE;
	    
	    // On connection reestablish send last remembered status and error state ( status only when it's diffrent then 0 )
	    #s_R_TRIG_Connection(CLK := #ix_MFCConnected);
	    
	    IF #s_R_TRIG_Connection.Q AND #si_ItemStatus <> 0
	    THEN
	        #sx_ItemStatusMessageReq := TRUE;
	    END_IF;
	    
	    IF #s_R_TRIG_Connection.Q
	    THEN
	        #sx_ItemErrorMessageReq := TRUE;
	    END_IF;
	    
	    // Prepare trigger on the collective reset signal.
	    #s_F_TRIG_SendAllErrors(CLK := #ix_SendAllErrorsState);
	    
	    // When collective reset will go down, start send every equipment errors.
	    IF #s_F_TRIG_SendAllErrors.Q AND NOT #sx_SendAllProcedure
	    THEN
	        #ii_ErrorNumber := 0;
	        #sx_SendAllProcedure := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_FIFOStatus,
	              qx_Error => #sx_FIFOError,
	              qx_Warning => #sx_FIFOWarning,
	              iqv_Data := #s_UDT_Message,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 3 - Prepare message data
	    
	    // When there is no reset errors command, update status and errors.
	    IF NOT #ix_CollectiveReset
	        AND NOT #ss_FIFOStatus.FifoPreFull
	    THEN
	        // Status
	        IF (#t_UDT_ColumnLiftStatus.Status <> #s_UDT_ColumnLiftOld.Status OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0))
	        THEN
	            #sx_ItemStatusMessageReq := TRUE;
	            #si_ItemStatus := #t_UDT_ColumnLiftStatus.Status;
	            #s_UDT_ColumnLiftOld.Status := #t_UDT_ColumnLiftStatus.Status;
	        END_IF;
	        
	        
	        // Check which specific status changed, prepare code, change state and write new status into the old one.
	        IF (#t_UDT_ColumnLiftStatus.Specific.ReferenceError <> #s_UDT_ColumnLiftOld.Specific.ReferenceError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".ColumnLift.ReferenceError;
	            #si_State := BOOL_TO_INT(#t_UDT_ColumnLiftStatus.Specific.ReferenceError);
	            #s_UDT_ColumnLiftOld.Specific.ReferenceError := #t_UDT_ColumnLiftStatus.Specific.ReferenceError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#t_UDT_ColumnLiftStatus.Specific.SwitchingTimerError <> #s_UDT_ColumnLiftOld.Specific.SwitchingTimerError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 1)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".ColumnLift.SwitchingTimerError;
	            #si_State := BOOL_TO_INT(#t_UDT_ColumnLiftStatus.Specific.SwitchingTimerError);
	            #s_UDT_ColumnLiftOld.Specific.SwitchingTimerError := #t_UDT_ColumnLiftStatus.Specific.SwitchingTimerError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#t_UDT_ColumnLiftStatus.Specific.LimitSensorUpperPosition <> #s_UDT_ColumnLiftOld.Specific.LimitSensorUpperPosition AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 2)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".ColumnLift.LimitSensorUpperPosition;
	            #si_State := BOOL_TO_INT(#t_UDT_ColumnLiftStatus.Specific.LimitSensorUpperPosition);
	            #s_UDT_ColumnLiftOld.Specific.LimitSensorUpperPosition := #t_UDT_ColumnLiftStatus.Specific.LimitSensorUpperPosition;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#t_UDT_ColumnLiftStatus.Specific.LimitSensorLowerPosition <> #s_UDT_ColumnLiftOld.Specific.LimitSensorLowerPosition AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 3)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".ColumnLift.LimitSensorLowerPosition;
	            #si_State := BOOL_TO_INT(#t_UDT_ColumnLiftStatus.Specific.LimitSensorLowerPosition);
	            #s_UDT_ColumnLiftOld.Specific.LimitSensorLowerPosition := #t_UDT_ColumnLiftStatus.Specific.LimitSensorLowerPosition;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#t_UDT_ColumnLiftStatus.Specific.UpperPosition <> #s_UDT_ColumnLiftOld.Specific.UpperPosition AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 4)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".ColumnLift.UpperPosition;
	            #si_State := BOOL_TO_INT(#t_UDT_ColumnLiftStatus.Specific.UpperPosition);
	            #s_UDT_ColumnLiftOld.Specific.UpperPosition := #t_UDT_ColumnLiftStatus.Specific.UpperPosition;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#t_UDT_ColumnLiftStatus.Specific.LowerPosition <> #s_UDT_ColumnLiftOld.Specific.LowerPosition AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 5)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".ColumnLift.LowerPosition;
	            #si_State := BOOL_TO_INT(#t_UDT_ColumnLiftStatus.Specific.LowerPosition);
	            #s_UDT_ColumnLiftOld.Specific.LowerPosition := #t_UDT_ColumnLiftStatus.Specific.LowerPosition;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#t_UDT_ColumnLiftStatus.Specific.ChuteNotInPosition <> #s_UDT_ColumnLiftOld.Specific.ChuteNotInPosition AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 6)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".ColumnLift.ChuteNotInPosition;
	            #si_State := BOOL_TO_INT(#t_UDT_ColumnLiftStatus.Specific.ChuteNotInPosition);
	            #s_UDT_ColumnLiftOld.Specific.ChuteNotInPosition := #t_UDT_ColumnLiftStatus.Specific.ChuteNotInPosition;
	            #sx_ItemErrorMessageReq := TRUE;
	            #sx_SendAllProcedure := FALSE;
	            #ii_ErrorNumber += 1;
	        END_IF;
	    END_IF;
	END_REGION
	
	REGION 4 - Write message components to the item error structure 
	    
	    #s_UDT_ItemError.ItemNumber := #i_UDT_EquipmentNumber;
	    #s_UDT_ItemError.Error := #sdi_Code;
	    #s_UDT_ItemError.State := #si_State;
	    #s_UDT_ItemError.Masked := 1;
	    
	END_REGION
	
	REGION 5 - Write message components to the item status structure
	    
	    #s_UDT_ItemStatus.Group := #i_UDT_EquipmentNumber.Group;
	    #s_UDT_ItemStatus.Node := #i_UDT_EquipmentNumber.Node;
	    #s_UDT_ItemStatus.Status := #si_ItemStatus;
	    
	END_REGION
	
	REGION 6 - Prepare messages to the MFC
	    
	    // If item error message required signal is set, prepare the item error message.
	    IF (#sx_ItemErrorMessageReq)
	    THEN
	        #s_FB_ItemError(i_UDT_ItemErrorBody := #s_UDT_ItemError,
	                        ii_MessageGroup := 1,
	                        ix_FlagRetry := FALSE,
	                        idi_TimeSpan := 0,
	                        qx_Error => #sx_ItemErrorBlockError,
	                        qx_Warning => #sx_ItemErrorBlockWarning,
	                        iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                        iqs_FifoData := #iqs_FifoData,
	                        iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	    // If item status message required signal is set, prepare the item error message.
	    IF (#sx_ItemStatusMessageReq)
	    THEN
	        #s_FB_ItemStatus(i_UDT_ItemStatusBody := #s_UDT_ItemStatus,
	                         ii_MessageGroup := 1,
	                         ix_FlagRetry := FALSE,
	                         idi_TimeSpan := 0,
	                         qx_Error => #sx_ItemStatusBlockError,
	                         qx_Warning => #sx_ItemStatusBlockWarning,
	                         iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                         iqs_FifoData := #iqs_FifoData,
	                         iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Write outputs
	    
	    // Prepare collective output error.
	    #qx_Error :=
	    #sx_ItemErrorBlockError
	    OR #sx_ItemStatusBlockError
	    OR #sx_FIFOError;
	    
	    // Prepare collective output warning.
	    #qx_Warning :=
	    #sx_ItemErrorBlockWarning
	    OR #sx_ItemStatusBlockWarning
	    OR #sx_FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Visu_BiDirectionalStatus"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 136
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_BiDirectionalStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_BiDirectionalStatus";   // MCP status structure
      i_UDT_EquipmentNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EquipmentNumber";   // Item number
      ix_SendAllErrorsState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - update all the messages
      ix_MFCConnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - A connection to the MFC has been established
      ix_CollectiveReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Collective reset command of all system controls
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block error
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block warning
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Message number
   END_VAR

   VAR 
      sx_ItemErrorMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error message required
      sx_ItemStatusMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status message required
      s_R_TRIG_Connection {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger connection reastablished
      s_F_TRIG_SendAllErrors {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger from signal send all errors
      si_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Item status
      sx_SendAllProcedure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send all procedure
      ii_ErrorNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Counter Error Number
      ss_FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoStatus";   // Status structure
      sx_FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO error
      sx_FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO warning
      s_UDT_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message
      s_UDT_BiDirectionalStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_BiDirectionalStatus";   // MCP old status structure
      s_UDT_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemError";   // Item error message body structure
      sdi_Code { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Error code
      si_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Error state
      si_Rack { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_IOModule { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      s_UDT_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemStatus";   // Item status message body structure
      s_FB_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemStatus";   // Item status block's instance
      s_FB_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemError";   // Item error block's instance
      sx_ItemErrorBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block error
      sx_ItemErrorBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block warning
      sx_ItemStatusBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block error
      sx_ItemStatusBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block warning
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	28/03/2023  | 1.0       | M. Diebel   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec | Updated for new Baseline
	*)
	
	
	REGION 1 - Initialize message required signals
	    
	    #sx_ItemErrorMessageReq := FALSE;
	    
	    
	    // On connection reestablish send last remembered status and error state ( status only when it's diffrent then 0 )
	    #s_R_TRIG_Connection(CLK := #ix_MFCConnected);
	    
	    
	    IF #s_R_TRIG_Connection.Q
	    THEN
	        #sx_ItemErrorMessageReq := TRUE;
	    END_IF;
	    
	    // Prepare trigger on the collective reset signal.
	    #s_F_TRIG_SendAllErrors(CLK := #ix_SendAllErrorsState);
	    
	    // When collective reset will go down, start send every equipment errors.
	    IF #s_F_TRIG_SendAllErrors.Q AND NOT #sx_SendAllProcedure
	    THEN
	        #ii_ErrorNumber := 0;
	        #sx_SendAllProcedure := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_FIFOStatus,
	              qx_Error => #sx_FIFOError,
	              qx_Warning => #sx_FIFOWarning,
	              iqv_Data := #s_UDT_Message,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 3 - Prepare message data
	    
	    // When there is no reset errors command, update status and errors.
	    IF NOT #ix_CollectiveReset
	        AND NOT #ss_FIFOStatus.FifoPreFull
	    THEN
	        
	        // Check which specific status changed, prepare code, change state and write new status into the old one.
	        IF (#i_UDT_BiDirectionalStatus.InfeedModeRequested <> #s_UDT_BiDirectionalStatusOld.InfeedModeRequested AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".BiDirectional.InfeedModeRequested;
	            #si_State := BOOL_TO_INT(#i_UDT_BiDirectionalStatus.InfeedModeRequested);
	            #s_UDT_BiDirectionalStatusOld.InfeedModeRequested := #i_UDT_BiDirectionalStatus.InfeedModeRequested;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_BiDirectionalStatus.OutfeedModeRequested <> #s_UDT_BiDirectionalStatusOld.OutfeedModeRequested AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 1)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".BiDirectional.OutfeedModeRequested;
	            #si_State := BOOL_TO_INT(#i_UDT_BiDirectionalStatus.OutfeedModeRequested);
	            #s_UDT_BiDirectionalStatusOld.OutfeedModeRequested := #i_UDT_BiDirectionalStatus.OutfeedModeRequested;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_BiDirectionalStatus.InfeedModeActive <> #s_UDT_BiDirectionalStatusOld.InfeedModeActive AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 2)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".BiDirectional.InfeedModeActive;
	            #si_State := BOOL_TO_INT(#i_UDT_BiDirectionalStatus.InfeedModeActive);
	            #s_UDT_BiDirectionalStatusOld.InfeedModeActive := #i_UDT_BiDirectionalStatus.InfeedModeActive;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_BiDirectionalStatus.OutfeedModeActive <> #s_UDT_BiDirectionalStatusOld.OutfeedModeActive AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 3)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".BiDirectional.OutfeedModeActive;
	            #si_State := BOOL_TO_INT(#i_UDT_BiDirectionalStatus.OutfeedModeActive);
	            #s_UDT_BiDirectionalStatusOld.OutfeedModeActive := #i_UDT_BiDirectionalStatus.OutfeedModeActive;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_BiDirectionalStatus.InfeedModeReady <> #s_UDT_BiDirectionalStatusOld.InfeedModeReady AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 4)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".BiDirectional.InfeedModeReady;
	            #si_State := BOOL_TO_INT(#i_UDT_BiDirectionalStatus.InfeedModeReady);
	            #s_UDT_BiDirectionalStatusOld.InfeedModeReady := #i_UDT_BiDirectionalStatus.InfeedModeReady;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_BiDirectionalStatus.OutfeedModeReady <> #s_UDT_BiDirectionalStatusOld.OutfeedModeReady AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 5)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".BiDirectional.OutfeedModeReady;
	            #si_State := BOOL_TO_INT(#i_UDT_BiDirectionalStatus.OutfeedModeReady);
	            #s_UDT_BiDirectionalStatusOld.OutfeedModeReady := #i_UDT_BiDirectionalStatus.OutfeedModeReady;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	            #sx_SendAllProcedure := FALSE;
	        END_IF;
	    END_IF;
	END_REGION
	
	REGION 4 - Write message components to the item error structure 
	    
	    #s_UDT_ItemError.ItemNumber := #i_UDT_EquipmentNumber;
	    #s_UDT_ItemError.Error := #sdi_Code;
	    #s_UDT_ItemError.State := #si_State;
	    #s_UDT_ItemError.Masked := 1;
	    
	END_REGION
	
	
	
	REGION 5 - Prepare messages to the MFC
	    
	    // If item error message required signal is set, prepare the item error message.
	    IF (#sx_ItemErrorMessageReq)
	    THEN
	        #s_FB_ItemError(i_UDT_ItemErrorBody := #s_UDT_ItemError,
	                        ii_MessageGroup := 1,
	                        ix_FlagRetry := FALSE,
	                        idi_TimeSpan := 0,
	                        qx_Error => #sx_ItemErrorBlockError,
	                        qx_Warning => #sx_ItemErrorBlockWarning,
	                        iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                        iqs_FifoData := #iqs_FifoData,
	                        iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	    
	END_REGION
	
	REGION 7 - Write outputs
	    
	    // Prepare collective output error.
	    #qx_Error :=
	    #sx_ItemErrorBlockError
	    OR #sx_FIFOError;
	    
	    // Prepare collective output warning.
	    #qx_Warning :=
	    #sx_ItemErrorBlockWarning
	    OR #sx_FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Visu_CodingBeltModes_Status"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 138
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_CodingBeltModesStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CodingBeltModesStatus";   // CodingBeltModes status structure
      i_UDT_EquipmentNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EquipmentNumber";   // Item number
      ix_SendAllErrorsState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - update all the messages
      ix_MFCConnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - A connection to the MFC has been established
      ix_CollectiveReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Collective reset command of all system controls
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block error
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block warning
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Message number
   END_VAR

   VAR 
      s_FB_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemError";   // Item error block's instance
      s_FB_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemStatus";   // Item status block's instance
      ss_FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoStatus";   // Status structure
      s_UDT_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message
      s_UDT_CodingBeltModesStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CodingBeltModesStatus";   // CodingBeltModes status structure
      s_UDT_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemError";   // Item error message body structure
      s_UDT_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemStatus";   // Item status message body structure
      s_R_TRIG_Connection {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger connection reastablished
      s_F_TRIG_SendAllErrors {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger from signal send all errors
      sdi_Code { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Error code
      si_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Item status
      ii_ErrorNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Counter Error Number
      si_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Error state
      sx_ItemErrorMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error message required
      sx_ItemStatusMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status message required
      sx_SendAllProcedure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send all procedure
      sx_FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO error
      sx_FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO warning
      sx_ItemErrorBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block error
      sx_ItemErrorBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block warning
      sx_ItemStatusBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block error
      sx_ItemStatusBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block warning
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	26/04/2023  | 1.0       | M. Diebel   | Release TIA 17  | DHL Munich 2023
	06/10/2023  | 1.1       | M. Diebel   | Status handling | DHL Munich 2023
	13/03/2023  | 1.2       | S. Nieswiec  | Updated for new Baseline
	*)
	
	
	REGION 1 - Initialize message required signals
	    
	    #sx_ItemErrorMessageReq := FALSE;
	    #sx_ItemStatusMessageReq := FALSE;
	    
	    // On connection reestablish send last remembered status and error state ( status only when it's diffrent then 0 )
	    #s_R_TRIG_Connection(CLK := #ix_MFCConnected);
	    
	    IF #s_R_TRIG_Connection.Q AND #si_ItemStatus <> 0
	    THEN
	        #sx_ItemStatusMessageReq := TRUE;
	    END_IF;
	    
	    IF #s_R_TRIG_Connection.Q
	    THEN
	        #sx_ItemErrorMessageReq := TRUE;
	    END_IF;
	    
	    // Prepare trigger on the collective reset signal.
	    #s_F_TRIG_SendAllErrors(CLK := #ix_SendAllErrorsState);
	    
	    // When collective reset will go down, start send every equipment errors.
	    IF #s_F_TRIG_SendAllErrors.Q AND NOT #sx_SendAllProcedure
	    THEN
	        #ii_ErrorNumber := 0;
	        #sx_SendAllProcedure := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_FIFOStatus,
	              qx_Error => #sx_FIFOError,
	              qx_Warning => #sx_FIFOWarning,
	              iqv_Data := #s_UDT_Message,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 3 - Prepare message data
	    
	    // When there is no reset errors command, update errors.
	    IF NOT #ix_CollectiveReset
	        AND NOT #ss_FIFOStatus.FifoPreFull
	    THEN
	        
	        // Status
	        IF (#i_UDT_CodingBeltModesStatus.Status <> #s_UDT_CodingBeltModesStatusOld.Status OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0))
	        THEN
	            #sx_ItemStatusMessageReq := TRUE;
	            #si_ItemStatus := #i_UDT_CodingBeltModesStatus.Status;
	            #s_UDT_CodingBeltModesStatusOld.Status := #i_UDT_CodingBeltModesStatus.Status;
	            #sx_SendAllProcedure := FALSE;
	        END_IF;
	        
	        
	        IF (#i_UDT_CodingBeltModesStatus.Specific.GeneralError <> #s_UDT_CodingBeltModesStatusOld.Specific.GeneralError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".CodingBeltModes.GeneralError;
	            #si_State := BOOL_TO_INT(#i_UDT_CodingBeltModesStatus.Specific.GeneralError);
	            #s_UDT_CodingBeltModesStatusOld.Specific.GeneralError := #i_UDT_CodingBeltModesStatus.Specific.GeneralError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_CodingBeltModesStatus.Specific.ConfigurationError <> #s_UDT_CodingBeltModesStatusOld.Specific.ConfigurationError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 1)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".CodingBeltModes.ConfigurationError;
	            #si_State := BOOL_TO_INT(#i_UDT_CodingBeltModesStatus.Specific.ConfigurationError);
	            #s_UDT_CodingBeltModesStatusOld.Specific.ConfigurationError := #i_UDT_CodingBeltModesStatus.Specific.ConfigurationError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	            #sx_SendAllProcedure := FALSE;
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Write message components to the item error structure 
	    
	    #s_UDT_ItemError.ItemNumber := #i_UDT_EquipmentNumber;
	    #s_UDT_ItemError.Error := #sdi_Code;
	    #s_UDT_ItemError.State := #si_State;
	    #s_UDT_ItemError.Masked := 1;
	    
	END_REGION
	
	REGION 5 - Write message components to the item status structure
	    
	    #s_UDT_ItemStatus.Group := #i_UDT_EquipmentNumber.Group;
	    #s_UDT_ItemStatus.Node := #i_UDT_EquipmentNumber.Node;
	    #s_UDT_ItemStatus.Status := #si_ItemStatus;
	    
	END_REGION
	
	REGION 6 - Prepare messages to the MFC
	    
	    // If item error message required signal is set, prepare the item error message.
	    IF (#sx_ItemErrorMessageReq)
	    THEN
	        #s_FB_ItemError(i_UDT_ItemErrorBody := #s_UDT_ItemError,
	                        ii_MessageGroup := 1,
	                        ix_FlagRetry := FALSE,
	                        idi_TimeSpan := 0,
	                        qx_Error => #sx_ItemErrorBlockError,
	                        qx_Warning => #sx_ItemErrorBlockWarning,
	                        iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                        iqs_FifoData := #iqs_FifoData,
	                        iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	    // If item status message required signal is set, prepare the item error message.
	    IF (#sx_ItemStatusMessageReq)
	    THEN
	        #s_FB_ItemStatus(i_UDT_ItemStatusBody := #s_UDT_ItemStatus,
	                         ii_MessageGroup := 1,
	                         ix_FlagRetry := FALSE,
	                         idi_TimeSpan := 0,
	                         qx_Error => #sx_ItemStatusBlockError,
	                         qx_Warning => #sx_ItemStatusBlockWarning,
	                         iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                         iqs_FifoData := #iqs_FifoData,
	                         iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Write outputs
	    
	    // Prepare collective output error.
	    #qx_Error :=
	    #sx_ItemErrorBlockError
	    OR #sx_ItemStatusBlockError
	    OR #sx_FIFOError;
	    
	    // Prepare collective output warning.
	    #qx_Warning :=
	    #sx_ItemErrorBlockWarning
	    OR #sx_ItemStatusBlockWarning
	    OR #sx_FIFOWarning;
	    
	END_REGION
	
	
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Visu_PECUpdate_Status"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 2.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 249
// END_ATTRIBUTES
   VAR_INPUT 
      ix_SendAllErrorsState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - update all the messages
      ix_MFCConnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - A connection to the MFC has been established
      ix_CollectiveReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Collective reset command of all system controls
      i_UDT_PECUpdateStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateStatus";   // Input PEC update status structrue
      i_UDT_EquipmentNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EquipmentNumber";   // Item number
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block error
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block warning
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Message number
   END_VAR

   VAR 
      s_FB_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemError";   // Item error block's instance
      s_FB_TIDLost { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TIDLost";   // TID lost message block instance
      s_UDT_PECUpdateOLD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECUpdateStatus";   // PEC Update old status structure
      s_UDT_PECUpdate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECUpdateStatus";   // PEC Update status structure
      s_UDT_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemError";   // Item error message body structure
      s_UDT_FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoStatus";   // FIFO status structure
      s_UDT_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_BytesMessage";   // Message
      s_R_TRIG_Connection {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Connection reestablished
      s_F_TRIG_SendAllErrors {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;
      ss_TIDLostReason { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // TID lost message reason
         Unknown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //        Unknown
         TIDLost { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //        TID lost
         EndOfLine { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //        End of line
         ParcelDidntArrive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //        Parcel didn't arrave on PEC when expected
         UserDelete { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //        User delete
      END_STRUCT;
      sdi_Code { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Error code
      si_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Item status
      si_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Error state
      ii_ErrorNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      sx_ItemErrorMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error message required
      sx_ItemErrorBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block error
      sx_FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO error
      sx_FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO warning
      sx_ItemErrorBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block warning
      sx_SendAllProcedure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_TEMP 
      ti_GINLost : Int;   //        Lost GIN
      ti_LC_TIDLost : Int;   //        FIFO check for GIN lost
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	03/01/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	10/08/2023  | 2.0       | M. Diebel    | Copy input data to static memory | DHL Munich 2023
	13/03/2023  | 2.1       | S. Nieswiec  | Updated for new Baseline
	*)
	
	// To check line 76 - relation to DB_GIN, in Malmo they updated UDT_GIN
	
	REGION 1 - Initialize message required signals
	    
	    #sx_ItemErrorMessageReq := FALSE;
	    
	    // On connection reestablish send last remembered status and error state ( status only when it's diffrent then 0 )
	    #s_R_TRIG_Connection(CLK := #ix_MFCConnected);
	    
	    // Prepare trigger on the collective reset signal.
	    #s_F_TRIG_SendAllErrors(CLK := #ix_SendAllErrorsState);
	    
	    // When collective reset will go down, start send every equipment errors.
	    IF #s_F_TRIG_SendAllErrors.Q AND NOT #sx_SendAllProcedure
	    THEN
	        #ii_ErrorNumber := 0;
	        #sx_SendAllProcedure := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #s_UDT_FIFOStatus,
	              qx_Error => #sx_FIFOError,
	              qx_Warning => #sx_FIFOWarning,
	              iqv_Data := #s_UDT_Message,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 3 - Prepare message data
	    
	    // When there is no reset errors command, update status and errors.
	    IF NOT #ix_CollectiveReset
	        AND NOT #s_UDT_FIFOStatus.FifoPreFull
	    THEN
	        
	        //Copy input data to static memory
	        #s_UDT_PECUpdate := #i_UDT_PECUpdateStatus;
	        
	        // If the status changed, set item error message required signal.
	        IF (#s_UDT_PECUpdate <> #s_UDT_PECUpdateOLD OR #sx_SendAllProcedure)
	        THEN
	            #sx_ItemErrorMessageReq := TRUE;
	            
	            // Check which specific status changed, prepare code, change state and write new status into the old one.
	            IF (#s_UDT_PECUpdate.LowPerformance <> #s_UDT_PECUpdateOLD.LowPerformance AND NOT #sx_SendAllProcedure)
	                OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0)
	            THEN
	                #sdi_Code := "DB_MFC_ErrorCode".PECUpdate.LowPerformance;
	                #si_State := BOOL_TO_INT(#s_UDT_PECUpdate.LowPerformance);
	                #s_UDT_PECUpdateOLD.LowPerformance := #s_UDT_PECUpdate.LowPerformance;
	                #ii_ErrorNumber += 1;
	            ELSIF (#s_UDT_PECUpdate.TooManyLost <> #s_UDT_PECUpdateOLD.TooManyLost AND NOT #sx_SendAllProcedure)
	                OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 1)
	            THEN
	                #sdi_Code := "DB_MFC_ErrorCode".PECUpdate.TooManyLost;
	                #si_State := BOOL_TO_INT(#s_UDT_PECUpdate.TooManyLost);
	                #s_UDT_PECUpdateOLD.TooManyLost := #s_UDT_PECUpdate.TooManyLost;
	                #ii_ErrorNumber += 1;
	            ELSIF (#s_UDT_PECUpdate.PEC <> #s_UDT_PECUpdateOLD.PEC)
	            THEN
	                #sx_ItemErrorMessageReq := FALSE;
	                #s_UDT_PECUpdateOLD.PEC := #s_UDT_PECUpdate.PEC;
	            ELSIF (#s_UDT_PECUpdate.Jam <> #s_UDT_PECUpdateOLD.Jam AND NOT #sx_SendAllProcedure)
	                OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 2)
	            THEN
	                #sdi_Code := "DB_MFC_ErrorCode".PECUpdate.Jam;
	                #si_State := BOOL_TO_INT(#s_UDT_PECUpdate.Jam);
	                #s_UDT_PECUpdateOLD.Jam := #s_UDT_PECUpdate.Jam;
	                #sx_SendAllProcedure := FALSE;
	            END_IF;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Write message components to the item error structure 
	    
	    #s_UDT_ItemError.ItemNumber := #i_UDT_EquipmentNumber;
	    #s_UDT_ItemError.Error := #sdi_Code;
	    #s_UDT_ItemError.State := #si_State;
	    #s_UDT_ItemError.Masked := 1;
	    
	END_REGION
	
	REGION 5 - Prepare messages to the MFC
	    
	    // If item error message required signal is set, prepare the item error message.
	    IF (#sx_ItemErrorMessageReq)
	    THEN
	        #s_FB_ItemError(i_UDT_ItemErrorBody := #s_UDT_ItemError,
	                        ii_MessageGroup := 1,
	                        ix_FlagRetry := FALSE,
	                        qx_Error => #sx_ItemErrorBlockError,
	                        qx_Warning => #sx_ItemErrorBlockWarning,
	                        iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                        iqs_FifoData := #iqs_FifoData,
	                        iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Write outputs
	    
	    // Prepare collective output error.
	    #qx_Error := #sx_ItemErrorBlockError
	    OR #sx_FIFOError;
	    
	    // Prepare collective output warning.
	    #qx_Warning := #sx_ItemErrorBlockWarning
	    OR #sx_FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Visu_Connect_Status"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 140
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_ConnectStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConnectStatus";   // TCPIPConnection status structure
      i_UDT_EquipmentNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EquipmentNumber";   // Item number
      ix_SendAllErrorsState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - update all the messages
      ix_MFCConnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - A connection to the MFC has been established
      ix_CollectiveReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Collective reset command of all system controls
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block error
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block warning
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Message number
   END_VAR

   VAR 
      s_FB_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemError";   // Item error block's instance
      s_FB_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemStatus";   // Item status block's instance
      ss_FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoStatus";   // Status structure
      s_UDT_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message
      s_UDT_ConnectStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConnectStatus";   // TCPIPConnection status structure
      s_UDT_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemError";   // Item error message body structure
      s_UDT_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemStatus";   // Item status message body structure
      s_R_TRIG_Connection {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger connection reastablished
      s_F_TRIG_SendAllErrors {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger from signal send all errors
      sdi_Code { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Error code
      si_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Item status
      ii_ErrorNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Counter Error Number
      si_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Error state
      sx_ItemErrorMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error message required
      sx_ItemStatusMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status message required
      sx_SendAllProcedure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send all procedure
      sx_FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO error
      sx_FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO warning
      sx_ItemErrorBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block error
      sx_ItemErrorBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block warning
      sx_ItemStatusBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block error
      sx_ItemStatusBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block warning
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	31/03/2023  | 1.0       | M. Diebel   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec | Updated for new Baseline
	*)
	
	
	REGION 1 - Initialize message required signals
	    
	    #sx_ItemErrorMessageReq := FALSE;
	    #sx_ItemStatusMessageReq := FALSE;
	    
	    // On connection reestablish send last remembered status and error state ( status only when it's diffrent then 0 )
	    #s_R_TRIG_Connection(CLK := #ix_MFCConnected);
	    
	    IF #s_R_TRIG_Connection.Q AND #si_ItemStatus <> 0
	    THEN
	        #sx_ItemStatusMessageReq := TRUE;
	    END_IF;
	    
	    IF #s_R_TRIG_Connection.Q
	    THEN
	        #sx_ItemErrorMessageReq := TRUE;
	    END_IF;
	    
	    // Prepare trigger on the collective reset signal.
	    #s_F_TRIG_SendAllErrors(CLK := #ix_SendAllErrorsState);
	    
	    // When collective reset will go down, start send every equipment errors.
	    IF #s_F_TRIG_SendAllErrors.Q AND NOT #sx_SendAllProcedure
	    THEN
	        #ii_ErrorNumber := 0;
	        #sx_SendAllProcedure := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_FIFOStatus,
	              qx_Error => #sx_FIFOError,
	              qx_Warning => #sx_FIFOWarning,
	              iqv_Data := #s_UDT_Message,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 3 - Prepare message data
	    
	    // When there is no reset errors command, update status and errors.
	    IF NOT #ix_CollectiveReset
	        AND NOT #ss_FIFOStatus.FifoPreFull
	    THEN
	        // Status
	        IF (#i_UDT_ConnectStatus.Status <> #s_UDT_ConnectStatusOld.Status OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0))
	        THEN
	            #sx_ItemStatusMessageReq := TRUE;
	            #si_ItemStatus := #i_UDT_ConnectStatus.Status;
	            #s_UDT_ConnectStatusOld.Status := #i_UDT_ConnectStatus.Status;
	        END_IF;
	        
	        
	        // Check which specific status changed, prepare code, change state and write new status into the old one.
	        IF (#i_UDT_ConnectStatus.Specific.CommunicationFault <> #s_UDT_ConnectStatusOld.Specific.CommunicationFault AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".Connect.CommunicationFault;
	            #si_State := BOOL_TO_INT(#i_UDT_ConnectStatus.Specific.CommunicationFault);
	            #s_UDT_ConnectStatusOld.Specific.CommunicationFault := #i_UDT_ConnectStatus.Specific.CommunicationFault;
	            #sx_ItemErrorMessageReq := TRUE;
	            #sx_SendAllProcedure := FALSE;
	        END_IF;
	    END_IF;
	END_REGION
	
	REGION 4 - Write message components to the item error structure 
	    
	    #s_UDT_ItemError.ItemNumber := #i_UDT_EquipmentNumber;
	    #s_UDT_ItemError.Error := #sdi_Code;
	    #s_UDT_ItemError.State := #si_State;
	    #s_UDT_ItemError.Masked := 1;
	    
	END_REGION
	
	REGION 5 - Write message components to the item status structure
	    
	    #s_UDT_ItemStatus.Group := #i_UDT_EquipmentNumber.Group;
	    #s_UDT_ItemStatus.Node := #i_UDT_EquipmentNumber.Node;
	    #s_UDT_ItemStatus.Status := #si_ItemStatus;
	    
	END_REGION
	
	REGION 6 - Prepare messages to the MFC
	    
	    // If item error message required signal is set, prepare the item error message.
	    IF (#sx_ItemErrorMessageReq)
	    THEN
	        #s_FB_ItemError(i_UDT_ItemErrorBody := #s_UDT_ItemError,
	                        ii_MessageGroup := 1,
	                        ix_FlagRetry := FALSE,
	                        idi_TimeSpan := 0,
	                        qx_Error => #sx_ItemErrorBlockError,
	                        qx_Warning => #sx_ItemErrorBlockWarning,
	                        iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                        iqs_FifoData := #iqs_FifoData,
	                        iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	    // If item status message required signal is set, prepare the item error message.
	    IF (#sx_ItemStatusMessageReq)
	    THEN
	        #s_FB_ItemStatus(i_UDT_ItemStatusBody := #s_UDT_ItemStatus,
	                         ii_MessageGroup := 1,
	                         ix_FlagRetry := FALSE,
	                         idi_TimeSpan := 0,
	                         qx_Error => #sx_ItemStatusBlockError,
	                         qx_Warning => #sx_ItemStatusBlockWarning,
	                         iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                         iqs_FifoData := #iqs_FifoData,
	                         iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Write outputs
	    
	    // Prepare collective output error.
	    #qx_Error :=
	    #sx_ItemErrorBlockError
	    OR #sx_ItemStatusBlockError
	    OR #sx_FIFOError;
	    
	    // Prepare collective output warning.
	    #qx_Warning :=
	    #sx_ItemErrorBlockWarning
	    OR #sx_ItemStatusBlockWarning
	    OR #sx_FIFOWarning;
	    
	END_REGION
	
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Visu_Outfeed2States_Status"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 2.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 152
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_Outfeed2StatesStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_Outfeed2StatesStatus";   // Outfeed2States status structure
      i_UDT_EquipmentNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EquipmentNumber";   // Item number
      ix_SendAllErrorsState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - update all the messages
      ix_MFCConnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - A connection to the MFC has been established
      ix_CollectiveReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Collective reset command of all system controls
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block error
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block warning
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Message number
   END_VAR

   VAR 
      s_FB_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemError";   // Item error block's instance
      s_FB_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemStatus";   // Item status block's instance
      ss_FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoStatus";   // Status structure
      s_UDT_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message
      s_UDT_Outfeed2StatesStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Outfeed2StatesStatus";   // Outfeed2States old status structure
      s_UDT_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemError";   // Item error message body structure
      s_UDT_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemStatus";   // Item status message body structure
      s_R_TRIG_Connection {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger connection reastablished
      s_F_TRIG_SendAllErrors {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger from signal send all errors
      sdi_Code { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Error code
      si_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Item status
      ii_ErrorNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Counter Error Number
      si_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Error state
      sx_ItemErrorMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error message required
      sx_ItemStatusMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status message required
      sx_SendAllProcedure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send all procedure
      sx_FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO error
      sx_FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO warning
      sx_ItemErrorBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block error
      sx_ItemErrorBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block warning
      sx_ItemStatusBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block error
      sx_ItemStatusBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block warning
   END_VAR

   VAR_TEMP 
      t_UDT_Outfeed2StatesStatus : "UDT_Outfeed2StatesStatus";   // Outfeed2States status structure
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	27/03/2023  | 1.0       | M. Diebel   | Release TIA 17 | DHL Munich 2023
	11/09/2023  | 2.0       | M. Diebel   | Disable the information messages to MFC
	13/03/2023  | 2.1       | S. Nieswiec | Updated for new Baseline
	*)
	
	
	REGION 1 - Initialize message required signals
	    
	    #sx_ItemErrorMessageReq := FALSE;
	    #sx_ItemStatusMessageReq := FALSE;
	    
	    //Move input to temp 
	    #t_UDT_Outfeed2StatesStatus := #i_UDT_Outfeed2StatesStatus;
	    //Disable the information messages
	    //-ChuteFull
	    //-ChuteHalfFull
	    #t_UDT_Outfeed2StatesStatus.Specific.ChuteFull := FALSE;
	    #t_UDT_Outfeed2StatesStatus.Specific.ChuteHalfFull := FALSE;
	    
	    
	    // Prepare trigger on the collective reset signal.
	    #s_F_TRIG_SendAllErrors(CLK := #ix_SendAllErrorsState);
	    
	    // When collective reset will go down, start send every equipment errors.
	    IF #s_F_TRIG_SendAllErrors.Q AND NOT #sx_SendAllProcedure
	    THEN
	        #ii_ErrorNumber := 0;
	        #sx_SendAllProcedure := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_FIFOStatus,
	              qx_Error => #sx_FIFOError,
	              qx_Warning => #sx_FIFOWarning,
	              iqv_Data := #s_UDT_Message,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 3 - Prepare message data
	    
	    // When there is no reset errors command, update status and errors.
	    IF NOT #ix_CollectiveReset
	        AND NOT #ss_FIFOStatus.FifoPreFull
	    THEN
	        // Status
	        IF (#t_UDT_Outfeed2StatesStatus.Status <> #s_UDT_Outfeed2StatesStatusOld.Status OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0))
	        THEN
	            #sx_ItemStatusMessageReq := TRUE;
	            #si_ItemStatus := #t_UDT_Outfeed2StatesStatus.Status;
	            #s_UDT_Outfeed2StatesStatusOld.Status := #t_UDT_Outfeed2StatesStatus.Status;
	        END_IF;
	        
	        // Check which specific status changed, prepare code, change state and write new status into the old one.
	        IF (#t_UDT_Outfeed2StatesStatus.Specific.ChuteDisabled <> #s_UDT_Outfeed2StatesStatusOld.Specific.ChuteDisabled AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".Outfeed2States.ChuteDisabled;
	            #si_State := BOOL_TO_INT(#t_UDT_Outfeed2StatesStatus.Specific.ChuteDisabled);
	            #s_UDT_Outfeed2StatesStatusOld.Specific.ChuteDisabled := #t_UDT_Outfeed2StatesStatus.Specific.ChuteDisabled;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#t_UDT_Outfeed2StatesStatus.Specific.ChuteFull <> #s_UDT_Outfeed2StatesStatusOld.Specific.ChuteFull AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 1)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".Outfeed2States.ChuteFull;
	            #si_State := BOOL_TO_INT(#t_UDT_Outfeed2StatesStatus.Specific.ChuteFull);
	            #s_UDT_Outfeed2StatesStatusOld.Specific.ChuteFull := #t_UDT_Outfeed2StatesStatus.Specific.ChuteFull;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#t_UDT_Outfeed2StatesStatus.Specific.ChuteHalfFull <> #s_UDT_Outfeed2StatesStatusOld.Specific.ChuteHalfFull AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 2)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".Outfeed2States.ChuteHalfFull;
	            #si_State := BOOL_TO_INT(#t_UDT_Outfeed2StatesStatus.Specific.ChuteHalfFull);
	            #s_UDT_Outfeed2StatesStatusOld.Specific.ChuteHalfFull := #t_UDT_Outfeed2StatesStatus.Specific.ChuteHalfFull;
	            #sx_ItemErrorMessageReq := TRUE;
	            #sx_SendAllProcedure := FALSE;
	            #ii_ErrorNumber += 1;
	        END_IF;
	        
	        
	        
	    END_IF;
	END_REGION
	
	REGION 4 - Write message components to the item error structure 
	    
	    #s_UDT_ItemError.ItemNumber := #i_UDT_EquipmentNumber;
	    #s_UDT_ItemError.Error := #sdi_Code;
	    #s_UDT_ItemError.State := #si_State;
	    #s_UDT_ItemError.Masked := 1;
	    
	END_REGION
	
	REGION 5 - Write message components to the item status structure
	    
	    #s_UDT_ItemStatus.Group := #i_UDT_EquipmentNumber.Group;
	    #s_UDT_ItemStatus.Node := #i_UDT_EquipmentNumber.Node;
	    #s_UDT_ItemStatus.Status := #si_ItemStatus;
	    
	END_REGION
	
	REGION 6 - Prepare messages to the MFC
	    
	    // If item error message required signal is set, prepare the item error message.
	    IF (#sx_ItemErrorMessageReq)
	    THEN
	        #s_FB_ItemError(i_UDT_ItemErrorBody := #s_UDT_ItemError,
	                        ii_MessageGroup := 1,
	                        ix_FlagRetry := FALSE,
	                        idi_TimeSpan := 0,
	                        qx_Error => #sx_ItemErrorBlockError,
	                        qx_Warning => #sx_ItemErrorBlockWarning,
	                        iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                        iqs_FifoData := #iqs_FifoData,
	                        iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	    // If item status message required signal is set, prepare the item error message.
	    IF (#sx_ItemStatusMessageReq)
	    THEN
	        #s_FB_ItemStatus(i_UDT_ItemStatusBody := #s_UDT_ItemStatus,
	                         ii_MessageGroup := 1,
	                         ix_FlagRetry := FALSE,
	                         idi_TimeSpan := 0,
	                         qx_Error => #sx_ItemStatusBlockError,
	                         qx_Warning => #sx_ItemStatusBlockWarning,
	                         iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                         iqs_FifoData := #iqs_FifoData,
	                         iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Write outputs
	    
	    // Prepare collective output error.
	    #qx_Error :=
	    #sx_ItemErrorBlockError
	    OR #sx_ItemStatusBlockError
	    OR #sx_FIFOError;
	    
	    // Prepare collective output warning.
	    #qx_Warning :=
	    #sx_ItemErrorBlockWarning
	    OR #sx_ItemStatusBlockWarning
	    OR #sx_FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Visu_TCPIPConncetion_Status"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 160
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_TCPIPConnectStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_TCPIPConnectStatus";   // TCPIPConnection status structure
      i_UDT_EquipmentNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EquipmentNumber";   // Item number
      ix_SendAllErrorsState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - update all the messages
      ix_MFCConnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - A connection to the MFC has been established
      ix_CollectiveReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Collective reset command of all system controls
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block error
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block warning
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Message number
   END_VAR

   VAR 
      s_FB_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemError";   // Item error block's instance
      s_FB_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemStatus";   // Item status block's instance
      ss_FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoStatus";   // Status structure
      s_UDT_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message
      s_UDT_TCPIPConnectStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_TCPIPConnectStatus";   // TCPIPConnection status structure
      s_UDT_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemError";   // Item error message body structure
      s_UDT_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemStatus";   // Item status message body structure
      s_R_TRIG_Connection {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger connection reastablished
      s_F_TRIG_SendAllErrors {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger from signal send all errors
      sdi_Code { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Error code
      si_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Item status
      ii_ErrorNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Counter Error Number
      si_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Error state
      sx_ItemErrorMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error message required
      sx_ItemStatusMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status message required
      sx_SendAllProcedure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send all procedure
      sx_FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO error
      sx_FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO warning
      sx_ItemErrorBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block error
      sx_ItemErrorBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block warning
      sx_ItemStatusBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block error
      sx_ItemStatusBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block warning
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	24/03/2023  | 1.0       | M. Diebel   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec  | Updated for new Baseline
	*)
	
	
	REGION 1 - Initialize message required signals
	    
	    #sx_ItemErrorMessageReq := FALSE;
	    #sx_ItemStatusMessageReq := FALSE;
	    
	    // On connection reestablish send last remembered status and error state ( status only when it's diffrent then 0 )
	    #s_R_TRIG_Connection(CLK := #ix_MFCConnected);
	    
	    IF #s_R_TRIG_Connection.Q AND #si_ItemStatus <> 0
	    THEN
	        #sx_ItemStatusMessageReq := TRUE;
	    END_IF;
	    
	    IF #s_R_TRIG_Connection.Q
	    THEN
	        #sx_ItemErrorMessageReq := TRUE;
	    END_IF;
	    
	    // Prepare trigger on the collective reset signal.
	    #s_F_TRIG_SendAllErrors(CLK := #ix_SendAllErrorsState);
	    
	    // When collective reset will go down, start send every equipment errors.
	    IF #s_F_TRIG_SendAllErrors.Q AND NOT #sx_SendAllProcedure
	    THEN
	        #ii_ErrorNumber := 0;
	        #sx_SendAllProcedure := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_FIFOStatus,
	              qx_Error => #sx_FIFOError,
	              qx_Warning => #sx_FIFOWarning,
	              iqv_Data := #s_UDT_Message,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 3 - Prepare message data
	    
	    // When there is no reset errors command, update status and errors.
	    IF NOT #ix_CollectiveReset
	        AND NOT #ss_FIFOStatus.FifoPreFull
	    THEN
	        // Status
	        IF (#i_UDT_TCPIPConnectStatus.Status <> #s_UDT_TCPIPConnectStatusOld.Status OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0))
	        THEN
	            #sx_ItemStatusMessageReq := TRUE;
	            #si_ItemStatus := #i_UDT_TCPIPConnectStatus.Status;
	            #s_UDT_TCPIPConnectStatusOld.Status := #i_UDT_TCPIPConnectStatus.Status;
	        END_IF;
	        
	        
	        // Check which specific status changed, prepare code, change state and write new status into the old one.
	        IF (#i_UDT_TCPIPConnectStatus.Specific.CommunicationFault <> #s_UDT_TCPIPConnectStatusOld.Specific.CommunicationFault AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".TCPIPConnection.CommunicationFault;
	            #si_State := BOOL_TO_INT(#i_UDT_TCPIPConnectStatus.Specific.CommunicationFault);
	            #s_UDT_TCPIPConnectStatusOld.Specific.CommunicationFault := #i_UDT_TCPIPConnectStatus.Specific.CommunicationFault;
	            #sx_ItemErrorMessageReq := TRUE;
	            #sx_SendAllProcedure := FALSE;
	        END_IF;
	    END_IF;
	END_REGION
	
	REGION 4 - Write message components to the item error structure 
	    
	    #s_UDT_ItemError.ItemNumber := #i_UDT_EquipmentNumber;
	    #s_UDT_ItemError.Error := #sdi_Code;
	    #s_UDT_ItemError.State := #si_State;
	    #s_UDT_ItemError.Masked := 1;
	    
	END_REGION
	
	REGION 5 - Write message components to the item status structure
	    
	    #s_UDT_ItemStatus.Group := #i_UDT_EquipmentNumber.Group;
	    #s_UDT_ItemStatus.Node := #i_UDT_EquipmentNumber.Node;
	    #s_UDT_ItemStatus.Status := #si_ItemStatus;
	    
	END_REGION
	
	REGION 6 - Prepare messages to the MFC
	    
	    // If item error message required signal is set, prepare the item error message.
	    IF (#sx_ItemErrorMessageReq)
	    THEN
	        #s_FB_ItemError(i_UDT_ItemErrorBody := #s_UDT_ItemError,
	                        ii_MessageGroup := 1,
	                        ix_FlagRetry := FALSE,
	                        idi_TimeSpan := 0,
	                        qx_Error => #sx_ItemErrorBlockError,
	                        qx_Warning => #sx_ItemErrorBlockWarning,
	                        iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                        iqs_FifoData := #iqs_FifoData,
	                        iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	    // If item status message required signal is set, prepare the item error message.
	    IF (#sx_ItemStatusMessageReq)
	    THEN
	        #s_FB_ItemStatus(i_UDT_ItemStatusBody := #s_UDT_ItemStatus,
	                         ii_MessageGroup := 1,
	                         ix_FlagRetry := FALSE,
	                         idi_TimeSpan := 0,
	                         qx_Error => #sx_ItemStatusBlockError,
	                         qx_Warning => #sx_ItemStatusBlockWarning,
	                         iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                         iqs_FifoData := #iqs_FifoData,
	                         iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Write outputs
	    
	    // Prepare collective output error.
	    #qx_Error :=
	    #sx_ItemErrorBlockError
	    OR #sx_ItemStatusBlockError
	    OR #sx_FIFOError;
	    
	    // Prepare collective output warning.
	    #qx_Warning :=
	    #sx_ItemErrorBlockWarning
	    OR #sx_ItemStatusBlockWarning
	    OR #sx_FIFOWarning;
	    
	END_REGION
	
	
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Visu_PDP_Status"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 153
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_PDPStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PDPStatus";
      i_UDT_EquipmentNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EquipmentNumber";   // Item number
      ix_SendAllErrorsState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - update all the messages
      ix_MFCConnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - A connection to the MFC has been established
      ix_CollectiveReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Collective reset command of all system controls
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block error
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block warning
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Message number
   END_VAR

   VAR 
      s_FB_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemStatus";   // Item status block's instance
      s_FB_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemError";   // Item error block's instance
      s_UDT_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemStatus";   // Item status message body structure
      ss_FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoStatus";   // Status structure
      s_UDT_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message
      s_UDT_PDPOldStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PDPStatus";
      s_UDT_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemError";   // Item error message body structure
      s_R_TRIG_Connection {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger connection reastablished
      s_F_TRIG_SendAllErrors {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger from signal send all errors
      sdi_Code { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Error code
      si_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Item status
      ii_ErrorNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Counter Error Number
      si_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Error state
      sx_ItemErrorMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error message required
      sx_ItemStatusMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status message required
      sx_SendAllProcedure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send all procedure
      sx_FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO error
      sx_FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO warning
      sx_ItemErrorBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block error
      sx_ItemErrorBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block warning
      sx_ItemStatusBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block error
      sx_ItemStatusBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block warning
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	20/04/2023  | 1.0       | M. Diebel   | Release TIA 17 | DHL Munich 2023
	16/08/2023  | 1.1       | S. Theocharis| update with new PDP status 
	13/03/2023  | 1.2       | S. Nieswiec  | Updated for new Baseline
	*)
	
	
	
	
	REGION 1 - Initialize message required signals
	    
	    #sx_ItemErrorMessageReq := FALSE;
	    #sx_ItemStatusMessageReq := FALSE;
	    
	    // On connection reestablish send last remembered status and error state ( status only when it's diffrent then 0 )
	    #s_R_TRIG_Connection(CLK := #ix_MFCConnected);
	    
	    IF #s_R_TRIG_Connection.Q AND #si_ItemStatus <> 0
	    THEN
	        #sx_ItemStatusMessageReq := TRUE;
	    END_IF;
	    
	    IF #s_R_TRIG_Connection.Q
	    THEN
	        #sx_ItemErrorMessageReq := TRUE;
	    END_IF;
	    
	    // Prepare trigger on the collective reset signal.
	    #s_F_TRIG_SendAllErrors(CLK := #ix_SendAllErrorsState);
	    
	    // When collective reset will go down, start send every equipment errors.
	    IF #s_F_TRIG_SendAllErrors.Q AND NOT #sx_SendAllProcedure
	    THEN
	        #ii_ErrorNumber := 0;
	        #sx_SendAllProcedure := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_FIFOStatus,
	              qx_Error => #sx_FIFOError,
	              qx_Warning => #sx_FIFOWarning,
	              iqv_Data := #s_UDT_Message,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 3 - Prepare message data
	    
	    // When there is no reset errors command, update status and errors.
	    IF NOT #ix_CollectiveReset
	        AND NOT #ss_FIFOStatus.FifoPreFull
	    THEN
	        
	        // Status
	        IF (#i_UDT_PDPStatus.Status <> #s_UDT_PDPOldStatus.Status OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0))
	        THEN
	            #sx_ItemStatusMessageReq := TRUE;
	            #si_ItemStatus := #i_UDT_PDPStatus.Status;
	            #s_UDT_PDPOldStatus.Status := #i_UDT_PDPStatus.Status;
	        END_IF;
	        
	        
	        // Check which specific status changed, prepare code, change state and write new status into the old one.
	        IF (#i_UDT_PDPStatus.Specific.CircuitBreakersTripped <> #s_UDT_PDPOldStatus.Specific.CircuitBreakersTripped AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakersTripped;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakersTripped);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakersTripped := #i_UDT_PDPStatus.Specific.CircuitBreakersTripped;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerStateF100_F200_F300 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerStateF100_F200_F300 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 1)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerStateF100_F200_F300;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerStateF100_F200_F300);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerStateF100_F200_F300 := #i_UDT_PDPStatus.Specific.CircuitBreakerStateF100_F200_F300;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerStatePM <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerStatePM AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 2)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerStatePM;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerStatePM);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerStatePM := #i_UDT_PDPStatus.Specific.CircuitBreakerStatePM;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF101 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF101 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 3)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF101;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF101);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF101 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF101;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	            
	            
	            
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF102 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF102 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 4)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF102;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF102);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF102 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF102;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF103 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF103 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 5)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF103;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF103);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF103 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF103;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF104 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF104 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 6)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF104;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF104);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF104 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF104;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF105 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF105 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 7)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF105;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF105);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF105 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF105;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF106 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF106 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 8)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF106;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF106);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF106 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF106;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF107 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF107 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 9)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF107;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF107);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF107 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF107;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	            
	            
	            
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF108 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF108 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 10)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF108;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF108);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF108 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF108;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF109 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF109 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 11)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF109;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF109);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF109 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF109;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF110 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF110 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 12)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF110;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF110);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF110 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF110;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF111 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF111 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 13)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF111;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF111);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF111 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF111;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF112 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF112 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 14)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF112;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF112);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF112 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF112;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF113 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF113 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 15)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF113;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF113);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF113 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF113;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF114 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF114 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 16)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF114;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF114);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF114 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF114;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF115 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF115 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 17)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF115;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF115);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF115 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF115;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF116 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF116 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 18)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF116;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF116);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF116 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF116;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF117 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF117 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 19)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF117;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF117);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF117 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF117;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF118 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF118 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 20)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF118;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF118);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF118 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF118;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF119 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF119 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 21)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF119;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF119);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF119 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF119;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF120 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF120 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 22)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF120;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF120);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF120 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF120;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF121 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF121 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 23)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF121;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF121);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF121 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF121;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF122 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF122 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 24)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF122;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF122);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF122 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF122;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF123 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF123 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 25)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF123;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF123);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF123 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF123;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF124 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF124 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 26)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF124;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF124);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF124 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF124;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF125 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF125 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 27)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF125;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF125);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF125 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF125;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF126 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF126 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 28)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF126;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF126);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF126 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF126;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF127 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF127 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 29)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF127;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF127);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF127 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF127;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF128 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF128 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 30)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF128;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF128);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF128 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF128;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF129 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF129 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 31)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF129;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF129);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF129 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF129;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF130 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF130 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 32)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF130;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF130);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF130 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF130;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF131 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF131 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 33)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF131;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF131);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF131 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF131;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF132 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF132 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 34)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF132;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF132);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF132 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF132;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF133 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF133 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 35)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF133;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF133);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF133 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF133;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF134 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF134 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 36)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF134;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF134);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF134 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF134;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF135 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF135 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 37)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF135;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF135);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF135 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF135;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF201 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF201 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 38)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF201;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF201);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF201 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF201;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF202 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF202 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 39)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF202;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF202);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF202 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF202;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF203 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF203 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 40)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF203;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF203);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF203 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF203;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF204 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF204 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 41)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF204;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF204);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF204 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF204;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF205 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF205 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 42)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF205;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF205);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF205 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF205;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF206 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF206 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 43)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF206;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF206);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF206 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF206;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF207 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF207 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 44)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF207;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF207);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF207 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF207;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF208 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF208 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 45)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF208;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF208);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF208 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF208;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF209 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF209 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 46)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF209;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF209);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF209 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF209;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF210 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF210 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 47)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF210;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF210);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF210 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF210;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF211 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF211 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 48)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF211;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF211);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF211 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF211;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF212 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF212 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 49)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF212;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF212);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF212 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF212;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF213 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF213 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 50)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF213;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF213);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF213 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF213;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF214 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF214 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 51)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF214;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF214);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF214 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF214;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF215 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF215 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 52)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF215;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF215);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF215 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF215;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF216 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF216 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 53)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF216;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF216);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF216 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF216;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF217 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF217 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 54)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF217;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF217);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF217 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF217;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF218 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF218 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 55)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF218;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF218);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF218 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF218;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF219 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF219 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 56)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF219;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF219);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF219 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF219;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF220 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF220 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 57)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF220;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF220);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF220 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF220;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF221 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF221 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 58)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF221;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF221);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF221 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF221;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF222 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF222 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 59)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF222;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF222);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF222 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF222;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF223 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF223 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 60)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF223;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF223);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF223 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF223;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF224 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF224 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 61)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF224;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF224);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF224 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF224;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF225 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF225 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 62)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF225;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF225);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF225 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF225;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF226 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF226 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 63)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF226;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF226);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF226 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF226;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF227 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF227 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 64)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF227;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF227);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF227 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF227;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF228 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF228 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 65)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF228;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF228);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF228 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF228;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF229 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF229 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 66)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF229;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF229);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF229 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF229;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	            
	            
	            
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF501 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF501 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 67)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF501;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF501);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF501 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF501;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF502 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF502 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 68)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF502;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF502);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF502 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF502;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF503 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF503 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 69)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF503;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF503);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF503 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF503;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF504 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF504 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 70)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF504;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF504);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF504 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF504;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF505 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF505 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 71)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF505;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF505);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF505 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF505;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF506 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF506 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 72)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF506;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF506);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF506 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF506;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF507 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF507 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 73)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF507;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF507);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF507 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF507;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF508 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF508 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 74)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF508;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF508);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF508 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF508;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF509 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF509 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 75)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF509;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF509);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF509 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF509;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF510 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF510 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 76)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF510;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF510);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF510 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF510;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF511 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF511 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 77)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF511;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF511);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF511 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF511;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF512 <> #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF512 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 78)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PDP.CircuitBreakerTrippedF512;
	            #si_State := BOOL_TO_INT(#i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF512);
	            #s_UDT_PDPOldStatus.Specific.CircuitBreakerTrippedF512 := #i_UDT_PDPStatus.Specific.CircuitBreakerTrippedF512;
	            #sx_ItemErrorMessageReq := TRUE;
	            #sx_SendAllProcedure := FALSE;
	            #ii_ErrorNumber += 1;
	        END_IF;
	    END_IF;
	END_REGION
	
	REGION 4 - Write message components to the item error structure 
	    
	    #s_UDT_ItemError.ItemNumber := #i_UDT_EquipmentNumber;
	    #s_UDT_ItemError.Error := #sdi_Code;
	    #s_UDT_ItemError.State := #si_State;
	    #s_UDT_ItemError.Masked := 1;
	    
	END_REGION
	
	REGION 5 - Write message components to the item status structure
	    
	    #s_UDT_ItemStatus.Group := #i_UDT_EquipmentNumber.Group;
	    #s_UDT_ItemStatus.Node := #i_UDT_EquipmentNumber.Node;
	    #s_UDT_ItemStatus.Status := #si_ItemStatus;
	    
	END_REGION
	
	REGION 6 - Prepare messages to the MFC
	    
	    // If item error message required signal is set, prepare the item error message.
	    IF (#sx_ItemErrorMessageReq)
	    THEN
	        #s_FB_ItemError(i_UDT_ItemErrorBody := #s_UDT_ItemError,
	                        ii_MessageGroup := 1,
	                        ix_FlagRetry := FALSE,
	                        idi_TimeSpan := 0,
	                        qx_Error => #sx_ItemErrorBlockError,
	                        qx_Warning => #sx_ItemErrorBlockWarning,
	                        iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                        iqs_FifoData := #iqs_FifoData,
	                        iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	    // If item status message required signal is set, prepare the item error message.
	    IF (#sx_ItemStatusMessageReq)
	    THEN
	        #s_FB_ItemStatus(i_UDT_ItemStatusBody := #s_UDT_ItemStatus,
	                         ii_MessageGroup := 1,
	                         ix_FlagRetry := FALSE,
	                         idi_TimeSpan := 0,
	                         qx_Error => #sx_ItemStatusBlockError,
	                         qx_Warning => #sx_ItemStatusBlockWarning,
	                         iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                         iqs_FifoData := #iqs_FifoData,
	                         iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Write outputs
	    
	    // Prepare collective output error.
	    #qx_Error :=
	    #sx_ItemErrorBlockError
	    OR #sx_ItemStatusBlockError
	    OR #sx_FIFOError;
	    
	    // Prepare collective output warning.
	    #qx_Warning :=
	    #sx_ItemErrorBlockWarning
	    OR #sx_ItemStatusBlockWarning
	    OR #sx_FIFOWarning;
	    
	END_REGION
	
	
	
	
	
	
	
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Visu_ABSwitch_Status"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 134
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_ABSwitchStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ABSwitchStatus";   // ColumnLift status structure
      i_UDT_EquipmentNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EquipmentNumber";   // Item number
      ix_SendAllErrorsState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - update all the messages
      ix_MFCConnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - A connection to the MFC has been established
      ix_CollectiveReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Collective reset command of all system controls
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block error
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block warning
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Message number
   END_VAR

   VAR 
      s_FB_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemError";   // Item error block's instance
      s_FB_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemStatus";   // Item status block's instance
      ss_FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoStatus";   // Status structure
      s_UDT_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message
      s_UDT_ABSwitch_StatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ABSwitchStatus";   // ColumnLift status structure
      s_UDT_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemError";   // Item error message body structure
      s_UDT_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemStatus";   // Item status message body structure
      s_R_TRIG_Connection {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger connection reastablished
      s_F_TRIG_SendAllErrors {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger from signal send all errors
      sdi_Code { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Error code
      si_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Item status
      ii_ErrorNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Counter Error Number
      si_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Error state
      sx_ItemErrorMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error message required
      sx_ItemStatusMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status message required
      sx_SendAllProcedure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send all procedure
      sx_FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO error
      sx_FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO warning
      sx_ItemErrorBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block error
      sx_ItemErrorBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block warning
      sx_ItemStatusBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block error
      sx_ItemStatusBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block warning
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	24/04/2023  | 1.0       | M. Diebel   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec  | Updated for new Baseline
	*)
	
	
	REGION 1 - Initialize message required signals
	    
	    #sx_ItemErrorMessageReq := FALSE;
	    #sx_ItemStatusMessageReq := FALSE;
	    
	    // On connection reestablish send last remembered status and error state ( status only when it's diffrent then 0 )
	    #s_R_TRIG_Connection(CLK := #ix_MFCConnected);
	    
	    IF #s_R_TRIG_Connection.Q AND #si_ItemStatus <> 0
	    THEN
	        #sx_ItemStatusMessageReq := TRUE;
	    END_IF;
	    
	    IF #s_R_TRIG_Connection.Q
	    THEN
	        #sx_ItemErrorMessageReq := TRUE;
	    END_IF;
	    
	    // Prepare trigger on the collective reset signal.
	    #s_F_TRIG_SendAllErrors(CLK := #ix_SendAllErrorsState);
	    
	    // When collective reset will go down, start send every equipment errors.
	    IF #s_F_TRIG_SendAllErrors.Q AND NOT #sx_SendAllProcedure
	    THEN
	        #ii_ErrorNumber := 0;
	        #sx_SendAllProcedure := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_FIFOStatus,
	              qx_Error => #sx_FIFOError,
	              qx_Warning => #sx_FIFOWarning,
	              iqv_Data := #s_UDT_Message,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 3 - Prepare message data
	    
	    // When there is no reset errors command, update status and errors.
	    IF NOT #ix_CollectiveReset
	        AND NOT #ss_FIFOStatus.FifoPreFull
	    THEN
	        // Status
	        IF (#i_UDT_ABSwitchStatus.Status <> #s_UDT_ABSwitch_StatusOld.Status OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0))
	        THEN
	            #sx_ItemStatusMessageReq := TRUE;
	            #si_ItemStatus := #i_UDT_ABSwitchStatus.Status;
	            #s_UDT_ABSwitch_StatusOld.Status := #i_UDT_ABSwitchStatus.Status;
	        END_IF;
	        
	        
	        // Check which specific status changed, prepare code, change state and write new status into the old one.
	        IF (#i_UDT_ABSwitchStatus.Specific.ReferenceError <> #s_UDT_ABSwitch_StatusOld.Specific.ReferenceError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".ABSwitch.ReferenceError;
	            #si_State := BOOL_TO_INT(#i_UDT_ABSwitchStatus.Specific.ReferenceError);
	            #s_UDT_ABSwitch_StatusOld.Specific.ReferenceError := #i_UDT_ABSwitchStatus.Specific.ReferenceError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_ABSwitchStatus.Specific.SwitchingTimerError <> #s_UDT_ABSwitch_StatusOld.Specific.SwitchingTimerError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 1)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".ABSwitch.SwitchingTimerError;
	            #si_State := BOOL_TO_INT(#i_UDT_ABSwitchStatus.Specific.SwitchingTimerError);
	            #s_UDT_ABSwitch_StatusOld.Specific.SwitchingTimerError := #i_UDT_ABSwitchStatus.Specific.SwitchingTimerError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_ABSwitchStatus.Specific.LimitSensorUpperPosition <> #s_UDT_ABSwitch_StatusOld.Specific.LimitSensorUpperPosition AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 2)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".ABSwitch.LimitSensorUpperPosition;
	            #si_State := BOOL_TO_INT(#i_UDT_ABSwitchStatus.Specific.LimitSensorUpperPosition);
	            #s_UDT_ABSwitch_StatusOld.Specific.LimitSensorUpperPosition := #i_UDT_ABSwitchStatus.Specific.LimitSensorUpperPosition;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_ABSwitchStatus.Specific.LimitSensorLowerPosition <> #s_UDT_ABSwitch_StatusOld.Specific.LimitSensorLowerPosition AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 3)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".ABSwitch.LimitSensorLowerPosition;
	            #si_State := BOOL_TO_INT(#i_UDT_ABSwitchStatus.Specific.LimitSensorLowerPosition);
	            #s_UDT_ABSwitch_StatusOld.Specific.LimitSensorLowerPosition := #i_UDT_ABSwitchStatus.Specific.LimitSensorLowerPosition;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_ABSwitchStatus.Specific.UpperSwitchAreaError <> #s_UDT_ABSwitch_StatusOld.Specific.UpperSwitchAreaError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 4)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".ABSwitch.UpperSwitchArea_Err;
	            #si_State := BOOL_TO_INT(#i_UDT_ABSwitchStatus.Specific.UpperSwitchAreaError);
	            #s_UDT_ABSwitch_StatusOld.Specific.UpperSwitchAreaError := #i_UDT_ABSwitchStatus.Specific.UpperSwitchAreaError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_ABSwitchStatus.Specific.LowerSwitchAreaError <> #s_UDT_ABSwitch_StatusOld.Specific.LowerSwitchAreaError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 5)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".ABSwitch.LowerSwitchArea_Err;
	            #si_State := BOOL_TO_INT(#i_UDT_ABSwitchStatus.Specific.LowerSwitchAreaError);
	            #s_UDT_ABSwitch_StatusOld.Specific.LowerSwitchAreaError := #i_UDT_ABSwitchStatus.Specific.LowerSwitchAreaError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_ABSwitchStatus.Specific.UpperPosition <> #s_UDT_ABSwitch_StatusOld.Specific.UpperPosition AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 6)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".ABSwitch.UpperPosition;
	            #si_State := BOOL_TO_INT(#i_UDT_ABSwitchStatus.Specific.UpperPosition);
	            #s_UDT_ABSwitch_StatusOld.Specific.UpperPosition := #i_UDT_ABSwitchStatus.Specific.UpperPosition;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_ABSwitchStatus.Specific.LowerPosition <> #s_UDT_ABSwitch_StatusOld.Specific.LowerPosition AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 7)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".ABSwitch.LowerPosition;
	            #si_State := BOOL_TO_INT(#i_UDT_ABSwitchStatus.Specific.LowerPosition);
	            #s_UDT_ABSwitch_StatusOld.Specific.LowerPosition := #i_UDT_ABSwitchStatus.Specific.LowerPosition;
	            #sx_ItemErrorMessageReq := TRUE;
	            #sx_SendAllProcedure := FALSE;
	            #ii_ErrorNumber += 1;
	        END_IF;
	    END_IF;
	END_REGION
	
	REGION 4 - Write message components to the item error structure 
	    
	    #s_UDT_ItemError.ItemNumber := #i_UDT_EquipmentNumber;
	    #s_UDT_ItemError.Error := #sdi_Code;
	    #s_UDT_ItemError.State := #si_State;
	    #s_UDT_ItemError.Masked := 1;
	    
	END_REGION
	
	REGION 5 - Write message components to the item status structure
	    
	    #s_UDT_ItemStatus.Group := #i_UDT_EquipmentNumber.Group;
	    #s_UDT_ItemStatus.Node := #i_UDT_EquipmentNumber.Node;
	    #s_UDT_ItemStatus.Status := #si_ItemStatus;
	    
	END_REGION
	
	REGION 6 - Prepare messages to the MFC
	    
	    // If item error message required signal is set, prepare the item error message.
	    IF (#sx_ItemErrorMessageReq)
	    THEN
	        #s_FB_ItemError(i_UDT_ItemErrorBody := #s_UDT_ItemError,
	                        ii_MessageGroup := 1,
	                        ix_FlagRetry := FALSE,
	                        idi_TimeSpan := 0,
	                        qx_Error => #sx_ItemErrorBlockError,
	                        qx_Warning => #sx_ItemErrorBlockWarning,
	                        iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                        iqs_FifoData := #iqs_FifoData,
	                        iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	    // If item status message required signal is set, prepare the item error message.
	    IF (#sx_ItemStatusMessageReq)
	    THEN
	        #s_FB_ItemStatus(i_UDT_ItemStatusBody := #s_UDT_ItemStatus,
	                         ii_MessageGroup := 1,
	                         ix_FlagRetry := FALSE,
	                         idi_TimeSpan := 0,
	                         qx_Error => #sx_ItemStatusBlockError,
	                         qx_Warning => #sx_ItemStatusBlockWarning,
	                         iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                         iqs_FifoData := #iqs_FifoData,
	                         iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Write outputs
	    
	    // Prepare collective output error.
	    #qx_Error :=
	    #sx_ItemErrorBlockError
	    OR #sx_ItemStatusBlockError
	    OR #sx_FIFOError;
	    
	    // Prepare collective output warning.
	    #qx_Warning :=
	    #sx_ItemErrorBlockWarning
	    OR #sx_ItemStatusBlockWarning
	    OR #sx_FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Visu_MCP_Status"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 151
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_MCPStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_MCPStatus";   // MCP status structure
      i_UDT_EquipmentNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EquipmentNumber";   // Item number
      ix_SendAllErrorsState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - update all the messages
      ix_MFCConnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - A connection to the MFC has been established
      ix_CollectiveReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Collective reset command of all system controls
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block error
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block warning
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Message number
   END_VAR

   VAR 
      s_FB_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemError";   // Item error block's instance
      s_FB_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemStatus";   // Item status block's instance
      ss_FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoStatus";   // Status structure
      s_UDT_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message
      s_UDT_MCPOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MCPStatus";   // MCP old status structure
      s_UDT_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemError";   // Item error message body structure
      s_UDT_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemStatus";   // Item status message body structure
      s_R_TRIG_Connection {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger connection reastablished
      s_F_TRIG_SendAllErrors {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger from signal send all errors
      sdi_Code { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Error code
      ii_ErrorNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Counter Error Number
      si_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Item status
      si_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Error state
      si_Rack { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_IOModule { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      sx_ItemErrorMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error message required
      sx_ItemStatusMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status message required
      sx_SendAllProcedure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send all procedure
      sx_FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO error
      sx_FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO warning
      sx_ItemErrorBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block error
      sx_ItemErrorBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block warning
      sx_ItemStatusBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block error
      sx_ItemStatusBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block warning
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	28/03/2023  | 1.0       | M. Diebel   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec  | Updated for new Baseline
	*)
	
	
	REGION 1 - Initialize message required signals
	    
	    #sx_ItemErrorMessageReq := FALSE;
	    #sx_ItemStatusMessageReq := FALSE;
	    
	    // On connection reestablish send last remembered status and error state ( status only when it's diffrent then 0 )
	    #s_R_TRIG_Connection(CLK := #ix_MFCConnected);
	    
	    IF #s_R_TRIG_Connection.Q AND #si_ItemStatus <> 0
	    THEN
	        #sx_ItemStatusMessageReq := TRUE;
	    END_IF;
	    
	    IF #s_R_TRIG_Connection.Q
	    THEN
	        #sx_ItemErrorMessageReq := TRUE;
	    END_IF;
	    
	    // Prepare trigger on the collective reset signal.
	    #s_F_TRIG_SendAllErrors(CLK := #ix_SendAllErrorsState);
	    
	    // When collective reset will go down, start send every equipment errors.
	    IF #s_F_TRIG_SendAllErrors.Q AND NOT #sx_SendAllProcedure
	    THEN
	        #ii_ErrorNumber := 0;
	        #sx_SendAllProcedure := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_FIFOStatus,
	              qx_Error => #sx_FIFOError,
	              qx_Warning => #sx_FIFOWarning,
	              iqv_Data := #s_UDT_Message,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 3 - Prepare message data
	    
	    // When there is no reset errors command, update status and errors.
	    IF NOT #ix_CollectiveReset
	        AND NOT #ss_FIFOStatus.FifoPreFull
	    THEN
	        // Status
	        IF (#i_UDT_MCPStatus.Status <> #s_UDT_MCPOld.Status OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0))
	        THEN
	            #sx_ItemStatusMessageReq := TRUE;
	            #si_ItemStatus := #i_UDT_MCPStatus.Status;
	            #s_UDT_MCPOld.Status := #i_UDT_MCPStatus.Status;
	        END_IF;
	        
	        
	        // Check which specific status changed, prepare code, change state and write new status into the old one.
	        IF (#i_UDT_MCPStatus.Specific.PN_PN_MSP_PNSlaveNotOnline <> #s_UDT_MCPOld.Specific.PN_PN_MSP_PNSlaveNotOnline AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".MCP.PN_PN_MSP_PNSlaveNotOnline;
	            #si_State := BOOL_TO_INT(#i_UDT_MCPStatus.Specific.PN_PN_MSP_PNSlaveNotOnline);
	            #s_UDT_MCPOld.Specific.PN_PN_MSP_PNSlaveNotOnline := #i_UDT_MCPStatus.Specific.PN_PN_MSP_PNSlaveNotOnline;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_MCPStatus.Specific.PN_PN_MSP_PNSlaveError <> #s_UDT_MCPOld.Specific.PN_PN_MSP_PNSlaveError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 1)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".MCP.PN_PN_MSP_PNSlaveError;
	            #si_State := BOOL_TO_INT(#i_UDT_MCPStatus.Specific.PN_PN_MSP_PNSlaveError);
	            #s_UDT_MCPOld.Specific.PN_PN_MSP_PNSlaveError := #i_UDT_MCPStatus.Specific.PN_PN_MSP_PNSlaveError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_MCPStatus.Specific.PN_PN_MSP_PNSlaveWarning <> #s_UDT_MCPOld.Specific.PN_PN_MSP_PNSlaveWarning AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 2)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".MCP.PN_PN_MSP_PNSlaveWarning;
	            #si_State := BOOL_TO_INT(#i_UDT_MCPStatus.Specific.PN_PN_MSP_PNSlaveWarning);
	            #s_UDT_MCPOld.Specific.PN_PN_MSP_PNSlaveWarning := #i_UDT_MCPStatus.Specific.PN_PN_MSP_PNSlaveWarning;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_MCPStatus.Specific.IOModule_PNSlaveNotOnline <> #s_UDT_MCPOld.Specific.IOModule_PNSlaveNotOnline AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 3)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".MCP.IOModule_PNSlaveNotOnline;
	            #si_State := BOOL_TO_INT(#i_UDT_MCPStatus.Specific.IOModule_PNSlaveNotOnline);
	            #s_UDT_MCPOld.Specific.IOModule_PNSlaveNotOnline := #i_UDT_MCPStatus.Specific.IOModule_PNSlaveNotOnline;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_MCPStatus.Specific.IOModule_PNSlaveError <> #s_UDT_MCPOld.Specific.IOModule_PNSlaveError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 4)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".MCP.IOModule_PNSlaveError;
	            #si_State := BOOL_TO_INT(#i_UDT_MCPStatus.Specific.IOModule_PNSlaveError);
	            #s_UDT_MCPOld.Specific.IOModule_PNSlaveError := #i_UDT_MCPStatus.Specific.IOModule_PNSlaveError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_MCPStatus.Specific.IOModule_PNSlaveWarning <> #s_UDT_MCPOld.Specific.IOModule_PNSlaveWarning AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 5)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".MCP.IOModule_PNSlaveWarning;
	            #si_State := BOOL_TO_INT(#i_UDT_MCPStatus.Specific.IOModule_PNSlaveWarning);
	            #s_UDT_MCPOld.Specific.IOModule_PNSlaveWarning := #i_UDT_MCPStatus.Specific.IOModule_PNSlaveWarning;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_MCPStatus.Specific.ScalanceSwitchPNSlaveNotOnline <> #s_UDT_MCPOld.Specific.ScalanceSwitchPNSlaveNotOnline AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 6)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".MCP.ScalanceSwitchPNSlaveNotOnline;
	            #si_State := BOOL_TO_INT(#i_UDT_MCPStatus.Specific.ScalanceSwitchPNSlaveNotOnline);
	            #s_UDT_MCPOld.Specific.ScalanceSwitchPNSlaveNotOnline := #i_UDT_MCPStatus.Specific.ScalanceSwitchPNSlaveNotOnline;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_MCPStatus.Specific.ScalanceSwitchPNSlaveError <> #s_UDT_MCPOld.Specific.ScalanceSwitchPNSlaveError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 7)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".MCP.ScalanceSwitchPNSlaveError;
	            #si_State := BOOL_TO_INT(#i_UDT_MCPStatus.Specific.ScalanceSwitchPNSlaveError);
	            #s_UDT_MCPOld.Specific.ScalanceSwitchPNSlaveError := #i_UDT_MCPStatus.Specific.ScalanceSwitchPNSlaveError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_MCPStatus.Specific.ScalanceSwitchPNSlaveWarning <> #s_UDT_MCPOld.Specific.ScalanceSwitchPNSlaveWarning AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 8)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".MCP.ScalanceSwitchPNSlaveWarning;
	            #si_State := BOOL_TO_INT(#i_UDT_MCPStatus.Specific.ScalanceSwitchPNSlaveWarning);
	            #s_UDT_MCPOld.Specific.ScalanceSwitchPNSlaveWarning := #i_UDT_MCPStatus.Specific.ScalanceSwitchPNSlaveWarning;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_MCPStatus.Specific."2ndScalanceSwitchPNSlaveNotOnline" <> #s_UDT_MCPOld.Specific."2ndScalanceSwitchPNSlaveNotOnline" AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 9)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".MCP."2ndScalanceSwitchPNSlaveNotOnline";
	            #si_State := BOOL_TO_INT(#i_UDT_MCPStatus.Specific."2ndScalanceSwitchPNSlaveNotOnline");
	            #s_UDT_MCPOld.Specific."2ndScalanceSwitchPNSlaveNotOnline" := #i_UDT_MCPStatus.Specific."2ndScalanceSwitchPNSlaveNotOnline";
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_MCPStatus.Specific."2ndScalanceSwitchPNSlaveError" <> #s_UDT_MCPOld.Specific."2ndScalanceSwitchPNSlaveError" AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 10)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".MCP."2ndScalanceSwitchPNSlaveError";
	            #si_State := BOOL_TO_INT(#i_UDT_MCPStatus.Specific."2ndScalanceSwitchPNSlaveError");
	            #s_UDT_MCPOld.Specific."2ndScalanceSwitchPNSlaveError" := #i_UDT_MCPStatus.Specific."2ndScalanceSwitchPNSlaveError";
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_MCPStatus.Specific."2ndScalanceSwitchPNSlaveWarning" <> #s_UDT_MCPOld.Specific."2ndScalanceSwitchPNSlaveWarning" AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 11)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".MCP."2ndScalanceSwitchPNSlaveWarning";
	            #si_State := BOOL_TO_INT(#i_UDT_MCPStatus.Specific."2ndScalanceSwitchPNSlaveWarning");
	            #s_UDT_MCPOld.Specific."2ndScalanceSwitchPNSlaveWarning" := #i_UDT_MCPStatus.Specific."2ndScalanceSwitchPNSlaveWarning";
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_MCPStatus.Specific.Singulator_PNSlaveNotOnline <> #s_UDT_MCPOld.Specific.Singulator_PNSlaveNotOnline AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 12)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".MCP.Singulator_PNSlaveNotOnline;
	            #si_State := BOOL_TO_INT(#i_UDT_MCPStatus.Specific.Singulator_PNSlaveNotOnline);
	            #s_UDT_MCPOld.Specific.Singulator_PNSlaveNotOnline := #i_UDT_MCPStatus.Specific.Singulator_PNSlaveNotOnline;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_MCPStatus.Specific.Singulator_PNSlaveError <> #s_UDT_MCPOld.Specific.Singulator_PNSlaveError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 13)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".MCP.Singulator_PNSlaveError;
	            #si_State := BOOL_TO_INT(#i_UDT_MCPStatus.Specific.Singulator_PNSlaveError);
	            #s_UDT_MCPOld.Specific.Singulator_PNSlaveError := #i_UDT_MCPStatus.Specific.Singulator_PNSlaveError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_MCPStatus.Specific.Singulator_PNSlaveWarning <> #s_UDT_MCPOld.Specific.Singulator_PNSlaveWarning AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 14)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".MCP.Singulator_PNSlaveWarning;
	            #si_State := BOOL_TO_INT(#i_UDT_MCPStatus.Specific.Singulator_PNSlaveWarning);
	            #s_UDT_MCPOld.Specific.Singulator_PNSlaveWarning := #i_UDT_MCPStatus.Specific.Singulator_PNSlaveWarning;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_MCPStatus.Specific.IPC_PNSlaveNotOnline <> #s_UDT_MCPOld.Specific.IPC_PNSlaveNotOnline AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 15)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".MCP.IPS_PNSlaveNotOnline;
	            #si_State := BOOL_TO_INT(#i_UDT_MCPStatus.Specific.IPC_PNSlaveNotOnline);
	            #s_UDT_MCPOld.Specific.IPC_PNSlaveNotOnline := #i_UDT_MCPStatus.Specific.IPC_PNSlaveNotOnline;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_MCPStatus.Specific.IPC_PNSlaveError <> #s_UDT_MCPOld.Specific.IPC_PNSlaveError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 16)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".MCP.IPS_PNSlaveError;
	            #si_State := BOOL_TO_INT(#i_UDT_MCPStatus.Specific.IPC_PNSlaveError);
	            #s_UDT_MCPOld.Specific.IPC_PNSlaveError := #i_UDT_MCPStatus.Specific.IPC_PNSlaveError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_MCPStatus.Specific.IPC_PNSlaveWarning <> #s_UDT_MCPOld.Specific.IPC_PNSlaveWarning AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 17)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".MCP.IPS_PNSlaveWarning;
	            #si_State := BOOL_TO_INT(#i_UDT_MCPStatus.Specific.IPC_PNSlaveWarning);
	            #s_UDT_MCPOld.Specific.IPC_PNSlaveWarning := #i_UDT_MCPStatus.Specific.IPC_PNSlaveWarning;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_MCPStatus.Specific.UPSSwitchTripped <> #s_UDT_MCPOld.Specific.UPSSwitchTripped AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 18)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".MCP.UPSSwitchTripped;
	            #si_State := BOOL_TO_INT(#i_UDT_MCPStatus.Specific.UPSSwitchTripped);
	            #s_UDT_MCPOld.Specific.UPSSwitchTripped := #i_UDT_MCPStatus.Specific.UPSSwitchTripped;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_MCPStatus.Specific.FireAlarmActive <> #s_UDT_MCPOld.Specific.FireAlarmActive AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 19)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".MCP.FireAlarmActive;
	            #si_State := BOOL_TO_INT(#i_UDT_MCPStatus.Specific.FireAlarmActive);
	            #s_UDT_MCPOld.Specific.FireAlarmActive := #i_UDT_MCPStatus.Specific.FireAlarmActive;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_MCPStatus.Specific.PS_201T1_Tripped <> #s_UDT_MCPOld.Specific.PS_201T1_Tripped AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 20)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".MCP.PS_201T1_Tripped;
	            #si_State := BOOL_TO_INT(#i_UDT_MCPStatus.Specific.PS_201T1_Tripped);
	            #s_UDT_MCPOld.Specific.PS_201T1_Tripped := #i_UDT_MCPStatus.Specific.PS_201T1_Tripped;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_MCPStatus.Specific."230VAC_CB101F4Tripped" <> #s_UDT_MCPOld.Specific."230VAC_CB101F4Tripped" AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 21)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".MCP."230VAC_CB101F4Tripped";
	            #si_State := BOOL_TO_INT(#i_UDT_MCPStatus.Specific."230VAC_CB101F4Tripped");
	            #s_UDT_MCPOld.Specific."230VAC_CB101F4Tripped" := #i_UDT_MCPStatus.Specific."230VAC_CB101F4Tripped";
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_MCPStatus.Specific."230VAC_CB102F1Tripped" <> #s_UDT_MCPOld.Specific."230VAC_CB102F1Tripped" AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 22)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".MCP."230VAC_CB102F1Tripped";
	            #si_State := BOOL_TO_INT(#i_UDT_MCPStatus.Specific."230VAC_CB102F1Tripped");
	            #s_UDT_MCPOld.Specific."230VAC_CB102F1Tripped" := #i_UDT_MCPStatus.Specific."230VAC_CB102F1Tripped";
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_MCPStatus.Specific."24VDC_CB201F1Tripped" <> #s_UDT_MCPOld.Specific."24VDC_CB201F1Tripped" AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 23)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".MCP."24VDC_CB201F1Tripped";
	            #si_State := BOOL_TO_INT(#i_UDT_MCPStatus.Specific."24VDC_CB201F1Tripped");
	            #s_UDT_MCPOld.Specific."24VDC_CB201F1Tripped" := #i_UDT_MCPStatus.Specific."24VDC_CB201F1Tripped";
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_MCPStatus.Specific."24VDC_CB205F5Tripped" <> #s_UDT_MCPOld.Specific."24VDC_CB205F5Tripped" AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 24)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".MCP."24VDC_CB205F5Tripped";
	            #si_State := BOOL_TO_INT(#i_UDT_MCPStatus.Specific."24VDC_CB205F5Tripped");
	            #s_UDT_MCPOld.Specific."24VDC_CB205F5Tripped" := #i_UDT_MCPStatus.Specific."24VDC_CB205F5Tripped";
	            #sx_ItemErrorMessageReq := TRUE;
	            #sx_SendAllProcedure := FALSE;
	        ELSIF (#i_UDT_MCPStatus.Specific.Spare_1 <> #s_UDT_MCPOld.Specific.Spare_1 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 25)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".MCP.Spare_1;
	            #si_State := BOOL_TO_INT(#i_UDT_MCPStatus.Specific.Spare_1);
	            #s_UDT_MCPOld.Specific.Spare_1 := #i_UDT_MCPStatus.Specific.Spare_1;
	            #sx_ItemErrorMessageReq := TRUE;
	        ELSIF (#i_UDT_MCPStatus.Specific.Spare_2 <> #s_UDT_MCPOld.Specific.Spare_2 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 26)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".MCP.Spare_2;
	            #si_State := BOOL_TO_INT(#i_UDT_MCPStatus.Specific.Spare_2);
	            #s_UDT_MCPOld.Specific.Spare_2 := #i_UDT_MCPStatus.Specific.Spare_2;
	            #sx_ItemErrorMessageReq := TRUE;
	        ELSIF (#i_UDT_MCPStatus.Specific.Spare_3 <> #s_UDT_MCPOld.Specific.Spare_3 AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 27)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".MCP.Spare_3;
	            #si_State := BOOL_TO_INT(#i_UDT_MCPStatus.Specific.Spare_3);
	            #s_UDT_MCPOld.Specific.Spare_3 := #i_UDT_MCPStatus.Specific.Spare_3;
	            #sx_ItemErrorMessageReq := TRUE;
	            #sx_SendAllProcedure := FALSE;
	        ELSIF (#i_UDT_MCPStatus.Specific.RackSlotError <> #s_UDT_MCPOld.Specific.RackSlotError)
	        THEN
	            FOR #si_Rack := 0 TO 31 DO
	                IF (#i_UDT_MCPStatus.Specific.RackSlotError[#si_Rack] <> #s_UDT_MCPOld.Specific.RackSlotError[#si_Rack])
	                THEN
	                    #sdi_Code := "DB_MFC_ErrorCode".MCP.RackSlotError[#si_Rack];
	                    #si_State := BOOL_TO_INT(#i_UDT_MCPStatus.Specific.RackSlotError[#si_Rack]);
	                    #s_UDT_MCPOld.Specific.RackSlotError[#si_Rack] := #i_UDT_MCPStatus.Specific.RackSlotError[#si_Rack];
	                    #sx_ItemErrorMessageReq := TRUE;
	                    EXIT;
	                END_IF;
	            END_FOR;
	            
	        ELSE
	            
	            FOR #si_IOModule := 0 TO 31 DO
	                IF (#i_UDT_MCPStatus.Specific.IOModuleSlotError[#si_IOModule] <> #s_UDT_MCPOld.Specific.IOModuleSlotError[#si_IOModule])
	                THEN
	                    #sdi_Code := "DB_MFC_ErrorCode".MCP.IOModuleSlotError[#si_IOModule];
	                    #si_State := BOOL_TO_INT(#i_UDT_MCPStatus.Specific.IOModuleSlotError[#si_IOModule]);
	                    #s_UDT_MCPOld.Specific.IOModuleSlotError[#si_IOModule] := #i_UDT_MCPStatus.Specific.IOModuleSlotError[#si_IOModule];
	                    #sx_ItemErrorMessageReq := TRUE;
	                    EXIT;
	                END_IF;
	            END_FOR;
	            
	        END_IF;
	    END_IF;
	END_REGION
	
	REGION 4 - Write message components to the item error structure 
	    
	    #s_UDT_ItemError.ItemNumber := #i_UDT_EquipmentNumber;
	    #s_UDT_ItemError.Error := #sdi_Code;
	    #s_UDT_ItemError.State := #si_State;
	    #s_UDT_ItemError.Masked := 1;
	    
	END_REGION
	
	REGION 5 - Write message components to the item status structure
	    
	    #s_UDT_ItemStatus.Group := #i_UDT_EquipmentNumber.Group;
	    #s_UDT_ItemStatus.Node := #i_UDT_EquipmentNumber.Node;
	    #s_UDT_ItemStatus.Status := #si_ItemStatus;
	    
	END_REGION
	
	REGION 6 - Prepare messages to the MFC
	    
	    // If item error message required signal is set, prepare the item error message.
	    IF (#sx_ItemErrorMessageReq)
	    THEN
	        #s_FB_ItemError(i_UDT_ItemErrorBody := #s_UDT_ItemError,
	                        ii_MessageGroup := 1,
	                        ix_FlagRetry := FALSE,
	                        idi_TimeSpan := 0,
	                        qx_Error => #sx_ItemErrorBlockError,
	                        qx_Warning => #sx_ItemErrorBlockWarning,
	                        iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                        iqs_FifoData := #iqs_FifoData,
	                        iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	    // If item status message required signal is set, prepare the item error message.
	    IF (#sx_ItemStatusMessageReq)
	    THEN
	        #s_FB_ItemStatus(i_UDT_ItemStatusBody := #s_UDT_ItemStatus,
	                         ii_MessageGroup := 1,
	                         ix_FlagRetry := FALSE,
	                         idi_TimeSpan := 0,
	                         qx_Error => #sx_ItemStatusBlockError,
	                         qx_Warning => #sx_ItemStatusBlockWarning,
	                         iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                         iqs_FifoData := #iqs_FifoData,
	                         iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Write outputs
	    
	    // Prepare collective output error.
	    #qx_Error :=
	    #sx_ItemErrorBlockError
	    OR #sx_ItemStatusBlockError
	    OR #sx_FIFOError;
	    
	    // Prepare collective output warning.
	    #qx_Warning :=
	    #sx_ItemErrorBlockWarning
	    OR #sx_ItemStatusBlockWarning
	    OR #sx_FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Visu_PEC_Status"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 154
// END_ATTRIBUTES
   VAR_INPUT 
      ix_SendAllErrorsState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - update all the messages
      ix_MFCConnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - A connection to the MFC has been established
      ix_CollectiveReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Collective reset command of all system controls
      i_UDT_PECStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECStatus";   // PEC status structrue
      i_UDT_EquipmentNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EquipmentNumber";   // Equipment Number
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block error
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block warning
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Message number
   END_VAR

   VAR 
      s_FB_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemError";   // Item error block instance
      s_UDT_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_BytesMessage";   // Message
      s_UDT_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemError";   // Item error message body structure
      s_UDT_PECOLD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatus";   // PEC old status structure
      s_UDT_PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PECStatus";   // PEC status structure
      ss_FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoStatus";   // Status structure
      s_R_TRIG_Connection {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger connection reastablished
      s_F_TRIG_SendAllErrors {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger from signal send all errors
      sdi_Code { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Error code
      si_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Error state
      sx_ItemErrorMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error message required
      sx_ItemErrorBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block error
      sx_ItemErrorBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block warning
      sx_SendAllProcedure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send all procedure
      sx_FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO Error
      sx_FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO Warning
   END_VAR

   VAR CONSTANT 
      ci_MessageGroup : Int := 1;
      ci_TimeSpan : Int := 0;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	03/01/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec  | Updated for new Baseline
	*)
	
	REGION 1 - Initialize message required signals
	    
	    #sx_ItemErrorMessageReq := FALSE;
	    
	    // On connection re-establish send last remembered status and error state ( status only when it's diffrent then 0 )
	    #s_R_TRIG_Connection(CLK := #ix_MFCConnected);
	    
	    IF #s_R_TRIG_Connection.Q
	    THEN
	        #sx_ItemErrorMessageReq := TRUE;
	    END_IF;
	    
	    // Prepare trigger on the collective reset signal.
	    #s_F_TRIG_SendAllErrors(CLK := #ix_SendAllErrorsState);
	    
	    // When collective reset will go down, start send every equipment errors.
	    IF #s_F_TRIG_SendAllErrors.Q AND NOT #sx_SendAllProcedure
	    THEN
	        #sx_SendAllProcedure := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_FIFOStatus,
	              qx_Error => #sx_FIFOError,
	              qx_Warning => #sx_FIFOWarning,
	              iqv_Data := #s_UDT_Message,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 3 - Prepare message data
	    
	    IF NOT #ix_CollectiveReset AND NOT #ss_FIFOStatus.FifoPreFull
	    THEN
	        
	        //Copy input data to static memory
	        #s_UDT_PEC := #i_UDT_PECStatus;
	        // Check which specific status changed, prepare code, change state and write new status into the old one.
	        
	        IF (#s_UDT_PEC.Jam <> #s_UDT_PECOLD.Jam)
	            OR (#sx_SendAllProcedure)
	            OR #sx_ItemErrorMessageReq
	        THEN
	            #sx_ItemErrorMessageReq := TRUE;
	            #sdi_Code := "DB_MFC_ErrorCode".PEC.Jam;
	            #si_State := BOOL_TO_INT(#s_UDT_PEC.Jam);
	            #s_UDT_PECOLD.Jam := #s_UDT_PEC.Jam;
	            #sx_SendAllProcedure := FALSE;
	        END_IF;
	        
	        //The ELSIF needs to be tested
	    ELSIF #sx_ItemErrorMessageReq THEN
	        #sx_ItemErrorMessageReq := FALSE;
	    END_IF;
	    
	    
	END_REGION
	
	REGION 4 - Write message components to the item error structure 
	    
	    #s_UDT_ItemError.ItemNumber := #i_UDT_EquipmentNumber;
	    #s_UDT_ItemError.Error := #sdi_Code;
	    #s_UDT_ItemError.State := #si_State;
	    #s_UDT_ItemError.Masked := 1;
	    
	END_REGION
	
	REGION 5 - Prepare messages to the MFC
	    
	    // If item error message required signal is set, prepare the item error message.
	    IF (#sx_ItemErrorMessageReq)
	    THEN
	        #s_FB_ItemError(i_UDT_ItemErrorBody := #s_UDT_ItemError,
	                        ii_MessageGroup := #ci_MessageGroup,
	                        ix_FlagRetry := FALSE,
	                        idi_TimeSpan := #ci_TimeSpan,
	                        qx_Error => #sx_ItemErrorBlockError,
	                        qx_Warning => #sx_ItemErrorBlockWarning,
	                        iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                        iqs_FifoData := #iqs_FifoData,
	                        iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Write outputs
	    
	    // Prepare collective output error.
	    #qx_Error := #sx_ItemErrorBlockError
	    OR #sx_FIFOError;
	    
	    // Prepare collective output warning.
	    #qx_Warning := #sx_ItemErrorBlockWarning
	    OR #sx_FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Visu_Heartbeat"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 150
// END_ATTRIBUTES
   VAR_INPUT 
      iudi_HeartbeatInterval { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Heartbeat send time interval [ms]
      ii_MessageGroup { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Message group
      ix_FlagRetry { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when message is sent again
      idi_TimeSpan { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Time difference between messages
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block error occurred
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block warning occurred
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Message number
   END_VAR

   VAR 
      ss_FB_HeartbeatPulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Pulse";   // Heartbeat send pulse generator
      s_UDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message array byte
      s_UDT_MessageHeader { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageHeaderV2";   // Message header
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //  FIFO error
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO warning
         InvalidMessageArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message array is too short for message
         InvalidTimeInterval { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat time interval lower than zero
      END_STRUCT;
      sdi_SerializePosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Position in array where serialize finished writing data +1
      si_MaximumMessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum number of elements in message array
      si_SerializeStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Function serialize status
      sx_HeartbeatPulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat pulse
   END_VAR

   VAR CONSTANT 
      ci_MessageID : Int := 20;   // Message ID number
      ci_MessageLength : Int := 18;   // Message length in bytes
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	03/01/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec  | Updated for new Baseline
	*)
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOStatus,
	              qx_Error => #ss_Status.FIFOError,
	              qx_Warning => #ss_Status.FIFOWarning,
	              iqv_Data := #s_UDT_MessageArray,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 2 – Heartbeat interval validation
	    
	    // Check Heartbeat interval. 
	    #ss_Status.InvalidTimeInterval := #iudi_HeartbeatInterval <= 0;
	    
	END_REGION
	
	REGION 3 – Message array size validation 
	    
	    // Get size of the array.
	    #si_MaximumMessageLength := "FC_GetNrOfArrayEl"(#s_UDT_MessageArray.Bytes);
	    
	    // Message array size validation. 
	    #ss_Status.InvalidMessageArraySize := #ci_MessageLength > #si_MaximumMessageLength;
	    
	END_REGION
	
	REGION 4 - Generate heartbeat pulse 
	    
	    IF NOT #ss_Status.InvalidTimeInterval
	        AND NOT #ss_Status.InvalidMessageArraySize
	    THEN
	        // Heartbeat pulse generator.
	        #ss_FB_HeartbeatPulse(iudi_PulseTime := #iudi_HeartbeatInterval,
	                              qx_Pulse => #sx_HeartbeatPulse);
	    END_IF;
	    
	END_REGION
	
	REGION 5 – Message preparation 
	    
	    // FIFO full check.
	    IF NOT #iq_UDT_FifoHeader.Status.Full
	    THEN
	        // Errors and send pulse check.
	        IF NOT #ss_Status.FIFOError
	            AND NOT #ss_Status.InvalidMessageArraySize
	            AND #sx_HeartbeatPulse
	        THEN
	            
	            REGION 5.1 – Header preparation 
	                
	                // Check sequence number. If it is equal or greater than 30000 reset it to 1.
	                IF #iqdi_MessageSequenceNumber < 30000
	                THEN
	                    #iqdi_MessageSequenceNumber += 1;
	                ELSE
	                    #iqdi_MessageSequenceNumber := 1;
	                END_IF;
	                
	                // Write parts of the header into structure.
	                #s_UDT_MessageHeader.BodyLength := 0;
	                #s_UDT_MessageHeader.FlagRetry.%X0 := #ix_FlagRetry;
	                #s_UDT_MessageHeader.Group := #ii_MessageGroup;
	                #s_UDT_MessageHeader.MessageID := #ci_MessageID;
	                #s_UDT_MessageHeader.SequenceNumber := #iqdi_MessageSequenceNumber;
	                #s_UDT_MessageHeader.TimeSpan := #idi_TimeSpan;
	                
	                // Calculate the header checksum.
	                "FC_Checksum"(i_UDT_MessageHeader := #s_UDT_MessageHeader,
	                              qb_Checksum => #s_UDT_MessageHeader.Checksum);
	                
	            END_REGION
	            
	            REGION 5.2 – Convert header into array of bytes
	                
	                // Initialize the header serialize position and convert header structure into array of bytes.
	                #sdi_SerializePosition := 0;
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #s_UDT_MessageHeader,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	            END_REGION
	            
	            REGION 5.3 – Write message into the FIFO buffer
	                
	                // Mode 'W' - Write FIFO record.
	                "FC_Fifo"(ic_Mode := 'W',
	                          qUDT_Status => #ss_Status.FIFOStatus,
	                          qx_Error => #ss_Status.FIFOError,
	                          qx_Warning => #ss_Status.FIFOWarning,
	                          iqv_Data := #s_UDT_MessageArray,
	                          iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	                          iqv_DataBuffer := #iqs_FifoData);
	                
	            END_REGION
	            
	        END_IF;
	    ELSE
	        // If FIFO is full set FIFO main and FIFO full errors.
	        #ss_Status.FIFOError := TRUE;
	        #ss_Status.FIFOStatus.FifoFull := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Status
	    
	    // Parametrization collective error output.
	    #qx_Error :=
	    #ss_Status.FIFOError
	    OR #ss_Status.InvalidTimeInterval
	    OR #ss_Status.InvalidMessageArraySize;
	    
	    // Parametrization collective warning output.
	    #qx_Warning := #ss_Status.FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Visu_PNNode_Status"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 155
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_PNNodeStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PNNodeStatus";   // PNNode status structure
      i_UDT_EquipmentNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EquipmentNumber";   // Item number
      ix_SendAllErrorsState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - update all the messages
      ix_MFCConnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - A connection to the MFC has been established
      ix_CollectiveReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Collective reset command of all system controls
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block error
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block warning
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Message number
   END_VAR

   VAR 
      s_FB_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemError";   // Item error block's instance
      s_FB_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemStatus";   // Item status block's instance
      ss_FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoStatus";   // Status structure
      s_UDT_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message
      s_UDT_PNNodeOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PNNodeStatus";   // PNNode old status structure
      s_UDT_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemError";   // Item error message body structure
      s_UDT_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemStatus";   // Item status message body structure
      s_R_TRIG_Connection {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger connection reastablished
      s_F_TRIG_SendAllErrors {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger from signal send all errors
      sdi_Code { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Error code
      si_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Item status
      ii_ErrorNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Counter Error Number
      si_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Error state
      sx_ItemErrorMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error message required
      sx_ItemStatusMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status message required
      sx_SendAllProcedure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send all procedure
      sx_FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO error
      sx_FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO warning
      sx_ItemErrorBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block error
      sx_ItemErrorBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block warning
      sx_ItemStatusBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block error
      sx_ItemStatusBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block warning
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	24/03/2023  | 1.0       | M. Diebel   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec  | Updated for new Baseline
	*)
	
	
	REGION 1 - Initialize message required signals
	    
	    #sx_ItemErrorMessageReq := FALSE;
	    #sx_ItemStatusMessageReq := FALSE;
	    
	    // On connection reestablish send last remembered status and error state ( status only when it's diffrent then 0 )
	    #s_R_TRIG_Connection(CLK := #ix_MFCConnected);
	    
	    IF #s_R_TRIG_Connection.Q AND #si_ItemStatus <> 0
	    THEN
	        #sx_ItemStatusMessageReq := TRUE;
	    END_IF;
	    
	    IF #s_R_TRIG_Connection.Q
	    THEN
	        #sx_ItemErrorMessageReq := TRUE;
	    END_IF;
	    
	    // Prepare trigger on the collective reset signal.
	    #s_F_TRIG_SendAllErrors(CLK := #ix_SendAllErrorsState);
	    
	    // When collective reset will go down, start send every equipment errors.
	    IF #s_F_TRIG_SendAllErrors.Q AND NOT #sx_SendAllProcedure
	    THEN
	        #ii_ErrorNumber := 0;
	        #sx_SendAllProcedure := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_FIFOStatus,
	              qx_Error => #sx_FIFOError,
	              qx_Warning => #sx_FIFOWarning,
	              iqv_Data := #s_UDT_Message,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 3 - Prepare message data
	    
	    // When there is no reset errors command, update status and errors.
	    IF NOT #ix_CollectiveReset
	        AND NOT #ss_FIFOStatus.FifoPreFull
	    THEN
	        // Status
	        IF (#i_UDT_PNNodeStatus.Status <> #s_UDT_PNNodeOld.Status OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0))
	        THEN
	            #sx_ItemStatusMessageReq := TRUE;
	            #si_ItemStatus := #i_UDT_PNNodeStatus.Status;
	            #s_UDT_PNNodeOld.Status := #i_UDT_PNNodeStatus.Status;
	        END_IF;
	        
	        
	        // Check which specific status changed, prepare code, change state and write new status into the old one.
	        IF (#i_UDT_PNNodeStatus.Specific.PNSlaveNotOnline <> #s_UDT_PNNodeOld.Specific.PNSlaveNotOnline AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PNNode.PNSlaveNotOnline;
	            #si_State := BOOL_TO_INT(#i_UDT_PNNodeStatus.Specific.PNSlaveNotOnline);
	            #s_UDT_PNNodeOld.Specific.PNSlaveNotOnline := #i_UDT_PNNodeStatus.Specific.PNSlaveNotOnline;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PNNodeStatus.Specific.PNSlaveError <> #s_UDT_PNNodeOld.Specific.PNSlaveError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 1)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PNNode.PNSlaveError;
	            #si_State := BOOL_TO_INT(#i_UDT_PNNodeStatus.Specific.PNSlaveError);
	            #s_UDT_PNNodeOld.Specific.PNSlaveError := #i_UDT_PNNodeStatus.Specific.PNSlaveError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_PNNodeStatus.Specific.PNSlaveWarning <> #s_UDT_PNNodeOld.Specific.PNSlaveWarning AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 2)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".PNNode.PNSlaveWarning;
	            #si_State := BOOL_TO_INT(#i_UDT_PNNodeStatus.Specific.PNSlaveWarning);
	            #s_UDT_PNNodeOld.Specific.PNSlaveWarning := #i_UDT_PNNodeStatus.Specific.PNSlaveWarning;
	            #sx_ItemErrorMessageReq := TRUE;
	            #sx_SendAllProcedure := FALSE;
	            #ii_ErrorNumber += 1;
	        END_IF;
	    END_IF;
	END_REGION
	
	REGION 4 - Write message components to the item error structure 
	    
	    #s_UDT_ItemError.ItemNumber := #i_UDT_EquipmentNumber;
	    #s_UDT_ItemError.Error := #sdi_Code;
	    #s_UDT_ItemError.State := #si_State;
	    #s_UDT_ItemError.Masked := 1;
	    
	END_REGION
	
	REGION 5 - Write message components to the item status structure
	    
	    #s_UDT_ItemStatus.Group := #i_UDT_EquipmentNumber.Group;
	    #s_UDT_ItemStatus.Node := #i_UDT_EquipmentNumber.Node;
	    #s_UDT_ItemStatus.Status := #si_ItemStatus;
	    
	END_REGION
	
	REGION 6 - Prepare messages to the MFC
	    
	    // If item error message required signal is set, prepare the item error message.
	    IF (#sx_ItemErrorMessageReq)
	    THEN
	        #s_FB_ItemError(i_UDT_ItemErrorBody := #s_UDT_ItemError,
	                        ii_MessageGroup := 1,
	                        ix_FlagRetry := FALSE,
	                        idi_TimeSpan := 0,
	                        qx_Error => #sx_ItemErrorBlockError,
	                        qx_Warning => #sx_ItemErrorBlockWarning,
	                        iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                        iqs_FifoData := #iqs_FifoData,
	                        iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	    // If item status message required signal is set, prepare the item error message.
	    IF (#sx_ItemStatusMessageReq)
	    THEN
	        #s_FB_ItemStatus(i_UDT_ItemStatusBody := #s_UDT_ItemStatus,
	                         ii_MessageGroup := 1,
	                         ix_FlagRetry := FALSE,
	                         idi_TimeSpan := 0,
	                         qx_Error => #sx_ItemStatusBlockError,
	                         qx_Warning => #sx_ItemStatusBlockWarning,
	                         iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                         iqs_FifoData := #iqs_FifoData,
	                         iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Write outputs
	    
	    // Prepare collective output error.
	    #qx_Error :=
	    #sx_ItemErrorBlockError
	    OR #sx_ItemStatusBlockError
	    OR #sx_FIFOError;
	    
	    // Prepare collective output warning.
	    #qx_Warning :=
	    #sx_ItemErrorBlockWarning
	    OR #sx_ItemStatusBlockWarning
	    OR #sx_FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Visu_EuchnerLock"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 149
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_EuchnerLock { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EuchnerLockStatusV2";
      i_UDT_EquipmentNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EquipmentNumber";   // Item number
      ix_SendAllErrorsState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - update all the messages
      ix_MFCConnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - A connection to the MFC has been established
      ix_CollectiveReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Collective reset command of all system controls
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block error
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block warning
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Message number
   END_VAR

   VAR 
      s_FB_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemError";   // Item error block's instance
      s_FB_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemStatus";   // Item status block's instance
      ss_FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoStatus";   // Status structure
      s_UDT_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message
      s_UDT_EuchnerLockOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_EuchnerLockStatusV2";   // ColumnLift status structure
      s_UDT_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemError";   // Item error message body structure
      s_UDT_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemStatus";   // Item status message body structure
      s_R_TRIG_Connection {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger connection reastablished
      s_F_TRIG_SendAllErrors {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger from signal send all errors
      sdi_Code { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Error code
      si_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Item status
      ii_ErrorNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Counter Error Number
      si_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Error state
      sx_ItemErrorMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error message required
      sx_ItemStatusMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status message required
      sx_SendAllProcedure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send all procedure
      sx_FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO error
      sx_FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO warning
      sx_ItemErrorBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block error
      sx_ItemErrorBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block warning
      sx_ItemStatusBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block error
      sx_ItemStatusBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block warning
      s_UDT_EuchnerLockStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_EuchnerLockStatusV2";   // ColumnLift status structure
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	10/10/2023  | 1.0       | M. Diebel   | Release TIA 17 | DHL Munich 2023
	06/02/2024  | 1.1       | L.Klar      | New alarms added
	13/03/2023  | 1.2       | S. Nieswiec  | Updated for new Baseline
	*)
	
	
	REGION 1 - Initialize message required signals
	    
	    
	    #sx_ItemErrorMessageReq := FALSE;
	    #sx_ItemStatusMessageReq := FALSE;
	    
	    // On connection reestablish send last remembered status and error state ( status only when it's diffrent then 0 )
	    #s_R_TRIG_Connection(CLK := #ix_MFCConnected);
	    
	    IF #s_R_TRIG_Connection.Q AND #si_ItemStatus <> 0
	    THEN
	        #sx_ItemStatusMessageReq := TRUE;
	    END_IF;
	    
	    IF #s_R_TRIG_Connection.Q
	    THEN
	        #sx_ItemErrorMessageReq := TRUE;
	    END_IF;
	    
	    // Prepare trigger on the collective reset signal.
	    #s_F_TRIG_SendAllErrors(CLK := #ix_SendAllErrorsState);
	    
	    // When collective reset will go down, start send every equipment errors.
	    IF #s_F_TRIG_SendAllErrors.Q AND NOT #sx_SendAllProcedure
	    THEN
	        #ii_ErrorNumber := 0;
	        #sx_SendAllProcedure := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_FIFOStatus,
	              qx_Error => #sx_FIFOError,
	              qx_Warning => #sx_FIFOWarning,
	              iqv_Data := #s_UDT_Message,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 3 - Prepare message data
	    
	    //
	    #s_UDT_EuchnerLockStatus := #i_UDT_EuchnerLock;
	    // When there is no reset errors command, update status and errors.
	    IF NOT #ix_CollectiveReset
	        AND NOT #ss_FIFOStatus.FifoPreFull
	    THEN
	        
	        
	        // Check which specific status changed, prepare code, change state and write new status into the old one.
	        IF (#s_UDT_EuchnerLockStatus.LockFault <> #s_UDT_EuchnerLockOld.LockFault AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".EuchnerLock.LockFault;
	            #si_State := BOOL_TO_INT(#s_UDT_EuchnerLockStatus.LockFault);
	            #s_UDT_EuchnerLockOld.LockFault := #s_UDT_EuchnerLockStatus.LockFault;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#s_UDT_EuchnerLockStatus.DoorClosed <> #s_UDT_EuchnerLockOld.DoorClosed AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 1)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".EuchnerLock.DoorClosed;
	            #si_State := BOOL_TO_INT(#s_UDT_EuchnerLockStatus.DoorClosed);
	            #s_UDT_EuchnerLockOld.DoorClosed := #s_UDT_EuchnerLockStatus.DoorClosed;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#s_UDT_EuchnerLockStatus.DoorOpened <> #s_UDT_EuchnerLockOld.DoorOpened AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 2)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".EuchnerLock.DoorOpened;
	            #si_State := BOOL_TO_INT(#s_UDT_EuchnerLockStatus.DoorOpened);
	            #s_UDT_EuchnerLockOld.DoorOpened := #s_UDT_EuchnerLockStatus.DoorOpened;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#s_UDT_EuchnerLockStatus.BoltTongueClosed <> #s_UDT_EuchnerLockOld.BoltTongueClosed AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 3)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".EuchnerLock.BoltTongueClosed;
	            #si_State := BOOL_TO_INT(#s_UDT_EuchnerLockStatus.BoltTongueClosed);
	            #s_UDT_EuchnerLockOld.BoltTongueClosed := #s_UDT_EuchnerLockStatus.BoltTongueClosed;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#s_UDT_EuchnerLockStatus.Safelylocked <> #s_UDT_EuchnerLockOld.Safelylocked AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 4)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".EuchnerLock.Safelylocked;
	            #si_State := BOOL_TO_INT(#s_UDT_EuchnerLockStatus.Safelylocked);
	            #s_UDT_EuchnerLockOld.Safelylocked := #s_UDT_EuchnerLockStatus.Safelylocked;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#s_UDT_EuchnerLockStatus.SafetyLockAckReq <> #s_UDT_EuchnerLockOld.SafetyLockAckReq AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 5)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".EuchnerLock.SafetyLockAckReq;
	            #si_State := BOOL_TO_INT(#s_UDT_EuchnerLockStatus.SafetyLockAckReq);
	            #s_UDT_EuchnerLockOld.SafetyLockAckReq := #s_UDT_EuchnerLockStatus.SafetyLockAckReq;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#s_UDT_EuchnerLockStatus.ReqMissingAccessRights <> #s_UDT_EuchnerLockOld.ReqMissingAccessRights AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 6)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".EuchnerLock.ReqMissingAccessRights;
	            #si_State := BOOL_TO_INT(#s_UDT_EuchnerLockStatus.ReqMissingAccessRights);
	            #s_UDT_EuchnerLockOld.ReqMissingAccessRights := #s_UDT_EuchnerLockStatus.ReqMissingAccessRights;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#s_UDT_EuchnerLockStatus.ResetMissingAccessRights <> #s_UDT_EuchnerLockOld.ResetMissingAccessRights AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 7)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".EuchnerLock.ResetMissingAccessRights;
	            #si_State := BOOL_TO_INT(#s_UDT_EuchnerLockStatus.ResetMissingAccessRights);
	            #s_UDT_EuchnerLockOld.ResetMissingAccessRights := #s_UDT_EuchnerLockStatus.ResetMissingAccessRights;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#s_UDT_EuchnerLockStatus.DoorOpenedWithoutReq <> #s_UDT_EuchnerLockOld.DoorOpenedWithoutReq AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 8)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".EuchnerLock.DoorOpenedWithoutReq;
	            #si_State := BOOL_TO_INT(#s_UDT_EuchnerLockStatus.DoorOpenedWithoutReq);
	            #s_UDT_EuchnerLockOld.DoorOpenedWithoutReq := #s_UDT_EuchnerLockStatus.DoorOpenedWithoutReq;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	            #sx_SendAllProcedure := FALSE;
	        END_IF;
	    END_IF;
	END_REGION
	
	REGION 4 - Write message components to the item error structure 
	    
	    #s_UDT_ItemError.ItemNumber := #i_UDT_EquipmentNumber;
	    #s_UDT_ItemError.Error := #sdi_Code;
	    #s_UDT_ItemError.State := #si_State;
	    #s_UDT_ItemError.Masked := 1;
	    
	END_REGION
	
	REGION 5 - Write message components to the item status structure
	    
	    #s_UDT_ItemStatus.Group := #i_UDT_EquipmentNumber.Group;
	    #s_UDT_ItemStatus.Node := #i_UDT_EquipmentNumber.Node;
	    #s_UDT_ItemStatus.Status := #si_ItemStatus;
	    
	END_REGION
	
	REGION 6 - Prepare messages to the MFC
	    
	    // If item error message required signal is set, prepare the item error message.
	    IF (#sx_ItemErrorMessageReq)
	    THEN
	        #s_FB_ItemError(i_UDT_ItemErrorBody := #s_UDT_ItemError,
	                        ii_MessageGroup := 1,
	                        ix_FlagRetry := FALSE,
	                        idi_TimeSpan := 0,
	                        qx_Error => #sx_ItemErrorBlockError,
	                        qx_Warning => #sx_ItemErrorBlockWarning,
	                        iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                        iqs_FifoData := #iqs_FifoData,
	                        iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	    // If item status message required signal is set, prepare the item error message.
	    IF (#sx_ItemStatusMessageReq)
	    THEN
	        #s_FB_ItemStatus(i_UDT_ItemStatusBody := #s_UDT_ItemStatus,
	                         ii_MessageGroup := 1,
	                         ix_FlagRetry := FALSE,
	                         idi_TimeSpan := 0,
	                         qx_Error => #sx_ItemStatusBlockError,
	                         qx_Warning => #sx_ItemStatusBlockWarning,
	                         iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                         iqs_FifoData := #iqs_FifoData,
	                         iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Write outputs
	    
	    // Prepare collective output error.
	    #qx_Error :=
	    #sx_ItemErrorBlockError
	    OR #sx_ItemStatusBlockError
	    OR #sx_FIFOError;
	    
	    // Prepare collective output warning.
	    #qx_Warning :=
	    #sx_ItemErrorBlockWarning
	    OR #sx_ItemStatusBlockWarning
	    OR #sx_FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Visu_EStop_Status"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 148
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_EStopStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EStop_Status";   // EStop status structure
      i_UDT_EquipmentNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EquipmentNumber";   // Item number
      ix_SendAllErrorsState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - update all the messages
      ix_MFCConnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - A connection to the MFC has been established
      ix_CollectiveReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Collective reset command of all system controls
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block error
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block warning
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Message number
   END_VAR

   VAR 
      s_FB_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemStatus";   // Item status block's instance
      s_FB_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemError";   // Item error block's instance
      ss_FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoStatus";   // Status structure
      s_UDT_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message
      s_UDT_EStopOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_EStop_Status";   // EStop  status structure
      s_UDT_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemError";   // Item error message body structure
      s_UDT_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemStatus";   // Item status message body structure
      s_F_TRIG_SendAllErrors {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger from signal send all errors
      s_R_TRIG_Connection {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger connection reastablished
      sdi_Code { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Error code
      si_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Item status
      ii_ErrorNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Counter Error Number
      si_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Error state
      sx_ItemErrorMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error message required
      sx_ItemStatusMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status message required
      sx_SendAllProcedure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send all procedure
      sx_FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO error
      sx_FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO warning
      sx_ItemErrorBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block error
      sx_ItemErrorBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block warning
      sx_ItemStatusBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block error
      sx_ItemStatusBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block warning
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	21/03/2023  | 1.0       | M. Diebel   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec  | Updated for new Baseline
	*)
	
	
	REGION 1 - Initialize message required signals
	    
	    #sx_ItemErrorMessageReq := FALSE;
	    #sx_ItemStatusMessageReq := FALSE;
	    
	    // On connection reestablish send last remembered status and error state ( status only when it's diffrent then 0 )
	    #s_R_TRIG_Connection(CLK := #ix_MFCConnected);
	    
	    IF #s_R_TRIG_Connection.Q AND #si_ItemStatus <> 0
	    THEN
	        #sx_ItemStatusMessageReq := TRUE;
	    END_IF;
	    
	    IF #s_R_TRIG_Connection.Q
	    THEN
	        #sx_ItemErrorMessageReq := TRUE;
	    END_IF;
	    
	    // Prepare trigger on the collective reset signal.
	    #s_F_TRIG_SendAllErrors(CLK := #ix_SendAllErrorsState);
	    
	    // When collective reset will go down, start send every equipment errors.
	    IF #s_F_TRIG_SendAllErrors.Q AND NOT #sx_SendAllProcedure
	    THEN
	        #sx_SendAllProcedure := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_FIFOStatus,
	              qx_Error => #sx_FIFOError,
	              qx_Warning => #sx_FIFOWarning,
	              iqv_Data := #s_UDT_Message,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 3 - Prepare message data
	    
	    // When there is no reset errors command, update status and errors.
	    IF NOT #ix_CollectiveReset
	        AND NOT #ss_FIFOStatus.FifoPreFull
	    THEN
	        // Status
	        IF (#i_UDT_EStopStatus.Status <> #s_UDT_EStopOld.Status OR (#sx_SendAllProcedure))
	        THEN
	            #sx_ItemStatusMessageReq := TRUE;
	            #si_ItemStatus := #i_UDT_EStopStatus.Status;
	            #s_UDT_EStopOld.Status := #i_UDT_EStopStatus.Status;
	        END_IF;
	        
	        
	        // Check which specific status changed, prepare code, change state and write new status into the old one.
	        IF (#i_UDT_EStopStatus.Estop <> #s_UDT_EStopOld.Estop AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".EStop.EStop;
	            #si_State := BOOL_TO_INT(#i_UDT_EStopStatus.Estop);
	            #s_UDT_EStopOld.Estop := #i_UDT_EStopStatus.Estop;
	            #sx_ItemErrorMessageReq := TRUE;
	            #sx_SendAllProcedure := FALSE;
	        END_IF;
	    END_IF;
	END_REGION
	
	REGION 4 - Write message components to the item error structure 
	    
	    #s_UDT_ItemError.ItemNumber := #i_UDT_EquipmentNumber;
	    #s_UDT_ItemError.Error := #sdi_Code;
	    #s_UDT_ItemError.State := #si_State;
	    #s_UDT_ItemError.Masked := 1;
	    
	END_REGION
	
	REGION 5 - Write message components to the item status structure
	    
	    #s_UDT_ItemStatus.Group := #i_UDT_EquipmentNumber.Group;
	    #s_UDT_ItemStatus.Node := #i_UDT_EquipmentNumber.Node;
	    #s_UDT_ItemStatus.Status := #si_ItemStatus;
	    
	END_REGION
	
	REGION 6 - Prepare messages to the MFC
	    
	    // If item error message required signal is set, prepare the item error message.
	    IF (#sx_ItemErrorMessageReq)
	    THEN
	        #s_FB_ItemError(i_UDT_ItemErrorBody := #s_UDT_ItemError,
	                        ii_MessageGroup := 1,
	                        ix_FlagRetry := FALSE,
	                        idi_TimeSpan := 0,
	                        qx_Error => #sx_ItemErrorBlockError,
	                        qx_Warning => #sx_ItemErrorBlockWarning,
	                        iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                        iqs_FifoData := #iqs_FifoData,
	                        iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	    // If item status message required signal is set, prepare the item error message.
	    IF (#sx_ItemStatusMessageReq)
	    THEN
	        #s_FB_ItemStatus(i_UDT_ItemStatusBody := #s_UDT_ItemStatus,
	                         ii_MessageGroup := 1,
	                         ix_FlagRetry := FALSE,
	                         idi_TimeSpan := 0,
	                         qx_Error => #sx_ItemStatusBlockError,
	                         qx_Warning => #sx_ItemStatusBlockWarning,
	                         iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                         iqs_FifoData := #iqs_FifoData,
	                         iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Write outputs
	    
	    // Prepare collective output error.
	    #qx_Error :=
	    #sx_ItemErrorBlockError
	    OR #sx_ItemStatusBlockError
	    OR #sx_FIFOError;
	    
	    // Prepare collective output warning.
	    #qx_Warning :=
	    #sx_ItemErrorBlockWarning
	    OR #sx_ItemStatusBlockWarning
	    OR #sx_FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Visu_CPG_Status"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 142
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_CPGStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ControlPowerGroupWORStatus";   // CPG status structure
      i_UDT_EquipmentNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EquipmentNumber";   // Item number
      ix_SendAllErrorsState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - update all the messages
      ix_MFCConnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - A connection to the MFC has been established
      ix_CollectiveReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Collective reset command of all system controls
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block error
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block warning
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Message number
   END_VAR

   VAR 
      s_FB_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemError";   // Item error block's instance
      s_FB_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemStatus";   // Item status block's instance
      ss_FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoStatus";   // Status structure
      s_UDT_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message
      s_UDT_CPGOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ControlPowerGroupStatus";   // CPG status structure
      s_UDT_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemError";   // Item error message body structure
      s_UDT_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemStatus";   // Item status message body structure
      s_R_TRIG_Connection {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger connection reastablished
      s_F_TRIG_SendAllErrors {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger from signal send all errors
      sdi_Code { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Error code
      si_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Item status
      ii_ErrorNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Counter Error Number
      si_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Error state
      sx_ItemErrorMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error message required
      sx_ItemStatusMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status message required
      sx_SendAllProcedure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send all procedure
      sx_FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO error
      sx_FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO warning
      sx_ItemErrorBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block error
      sx_ItemErrorBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block warning
      sx_ItemStatusBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block error
      sx_ItemStatusBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block warning
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	30/03/2023  | 1.0       | M. Diebel   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec  | Updated for new Baseline
	*)
	
	
	REGION 1 - Initialize message required signals
	    
	    #sx_ItemErrorMessageReq := FALSE;
	    #sx_ItemStatusMessageReq := FALSE;
	    
	    // On connection reestablish send last remembered status and error state ( status only when it's diffrent then 0 )
	    #s_R_TRIG_Connection(CLK := #ix_MFCConnected);
	    
	    IF #s_R_TRIG_Connection.Q AND #si_ItemStatus <> 0
	    THEN
	        #sx_ItemStatusMessageReq := TRUE;
	    END_IF;
	    
	    IF #s_R_TRIG_Connection.Q
	    THEN
	        #sx_ItemErrorMessageReq := TRUE;
	    END_IF;
	    
	    // Prepare trigger on the collective reset signal.
	    #s_F_TRIG_SendAllErrors(CLK := #ix_SendAllErrorsState);
	    
	    // When collective reset will go down, start send every equipment errors.
	    IF #s_F_TRIG_SendAllErrors.Q AND NOT #sx_SendAllProcedure
	    THEN
	        #ii_ErrorNumber := 0;
	        #sx_SendAllProcedure := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_FIFOStatus,
	              qx_Error => #sx_FIFOError,
	              qx_Warning => #sx_FIFOWarning,
	              iqv_Data := #s_UDT_Message,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 3 - Prepare message data
	    
	    // When there is no reset errors command, update status and errors.
	    IF NOT #ix_CollectiveReset
	        AND NOT #ss_FIFOStatus.FifoPreFull
	    THEN
	        // Status
	        IF (#i_UDT_CPGStatus.Status <> #s_UDT_CPGOld.Status OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0))
	        THEN
	            #sx_ItemStatusMessageReq := TRUE;
	            #si_ItemStatus := #i_UDT_CPGStatus.Status;
	            #s_UDT_CPGOld.Status := #i_UDT_CPGStatus.Status;
	        END_IF;
	        
	        
	        // Check which specific status changed, prepare code, change state and write new status into the old one.
	        IF (#i_UDT_CPGStatus.Specific.PowerSuppliesError <> #s_UDT_CPGOld.Specific.PowerSuppliesError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".CPG.PowerSuppliesError;
	            #si_State := BOOL_TO_INT(#i_UDT_CPGStatus.Specific.PowerSuppliesError);
	            #s_UDT_CPGOld.Specific.PowerSuppliesError := #i_UDT_CPGStatus.Specific.PowerSuppliesError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #sx_SendAllProcedure := FALSE;
	        END_IF;
	    END_IF;
	END_REGION
	
	REGION 4 - Write message components to the item error structure 
	    
	    #s_UDT_ItemError.ItemNumber := #i_UDT_EquipmentNumber;
	    #s_UDT_ItemError.Error := #sdi_Code;
	    #s_UDT_ItemError.State := #si_State;
	    #s_UDT_ItemError.Masked := 1;
	    
	END_REGION
	
	REGION 5 - Write message components to the item status structure
	    
	    #s_UDT_ItemStatus.Group := #i_UDT_EquipmentNumber.Group;
	    #s_UDT_ItemStatus.Node := #i_UDT_EquipmentNumber.Node;
	    #s_UDT_ItemStatus.Status := #si_ItemStatus;
	    
	END_REGION
	
	REGION 6 - Prepare messages to the MFC
	    
	    // If item error message required signal is set, prepare the item error message.
	    IF (#sx_ItemErrorMessageReq)
	    THEN
	        #s_FB_ItemError(i_UDT_ItemErrorBody := #s_UDT_ItemError,
	                        ii_MessageGroup := 1,
	                        ix_FlagRetry := FALSE,
	                        idi_TimeSpan := 0,
	                        qx_Error => #sx_ItemErrorBlockError,
	                        qx_Warning => #sx_ItemErrorBlockWarning,
	                        iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                        iqs_FifoData := #iqs_FifoData,
	                        iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	    // If item status message required signal is set, prepare the item error message.
	    IF (#sx_ItemStatusMessageReq)
	    THEN
	        #s_FB_ItemStatus(i_UDT_ItemStatusBody := #s_UDT_ItemStatus,
	                         ii_MessageGroup := 1,
	                         ix_FlagRetry := FALSE,
	                         idi_TimeSpan := 0,
	                         qx_Error => #sx_ItemStatusBlockError,
	                         qx_Warning => #sx_ItemStatusBlockWarning,
	                         iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                         iqs_FifoData := #iqs_FifoData,
	                         iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Write outputs
	    
	    // Prepare collective output error.
	    #qx_Error :=
	    #sx_ItemErrorBlockError
	    OR #sx_ItemStatusBlockError
	    OR #sx_FIFOError;
	    
	    // Prepare collective output warning.
	    #qx_Warning :=
	    #sx_ItemErrorBlockWarning
	    OR #sx_ItemStatusBlockWarning
	    OR #sx_FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Visu_Error_User"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 147
// END_ATTRIBUTES
   VAR_INPUT 
      ix_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      i_UDT_EquipmentNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EquipmentNumber";   // Item number
      ix_SendAllErrorsState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - update all the messages
      ix_MFCConnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - A connection to the MFC has been established
      ix_CollectiveReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Collective reset command of all system controls
      idi_Code { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block error
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block warning
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Message number
   END_VAR

   VAR 
      s_FB_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemError";   // Item error block's instance
      ss_FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoStatus";   // Status structure
      s_UDT_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message
      s_UDT_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemError";   // Item error message body structure
      s_R_TRIG_Connection {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger connection reastablished
      s_F_TRIG_SendAllErrors {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger from signal send all errors
      sdi_Code { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Error code
      si_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Error state
      sx_ItemErrorMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error message required
      sx_SendAllProcedure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send all procedure
      sx_FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO error
      sx_FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO warning
      sx_ItemErrorBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block error
      sx_ItemErrorBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block warning
      sx_OldError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	29/01/2024  | 1.0       | M. Diebel   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec  | Updated for new Baseline
	*)
	
	REGION 1 - Initialize message required signals
	    
	    #sx_ItemErrorMessageReq := FALSE;
	    
	    // On connection reestablish send last remembered status and error state ( status only when it's diffrent then 0 )
	    #s_R_TRIG_Connection(CLK := #ix_MFCConnected);
	    
	    IF #s_R_TRIG_Connection.Q
	    THEN
	        #sx_ItemErrorMessageReq := TRUE;
	    END_IF;
	    
	    // Prepare trigger on the collective reset signal.
	    #s_F_TRIG_SendAllErrors(CLK := #ix_SendAllErrorsState);
	    
	    // When collective reset will go down, start send every equipment errors.
	    IF #s_F_TRIG_SendAllErrors.Q AND NOT #sx_SendAllProcedure
	    THEN
	        #sx_SendAllProcedure := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_FIFOStatus,
	              qx_Error => #sx_FIFOError,
	              qx_Warning => #sx_FIFOWarning,
	              iqv_Data := #s_UDT_Message,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 3 - Prepare message data
	    
	    // When there is no reset errors command, update status and errors.
	    IF NOT #ix_CollectiveReset
	        AND NOT #ss_FIFOStatus.FifoPreFull
	    THEN
	        
	        // Check which specific status changed, prepare code, change state and write new status into the old one.
	        IF (#ix_Error <> #sx_OldError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure)
	        THEN
	            #sdi_Code := #idi_Code;
	            #si_State := BOOL_TO_INT(#ix_Error);
	            #sx_OldError := #ix_Error;
	            #sx_ItemErrorMessageReq := TRUE;
	            #sx_SendAllProcedure := FALSE;
	        END_IF;
	        
	    END_IF;
	END_REGION
	
	REGION 4 - Write message components to the item error structure 
	    
	    #s_UDT_ItemError.ItemNumber := #i_UDT_EquipmentNumber;
	    #s_UDT_ItemError.Error := #sdi_Code;
	    #s_UDT_ItemError.State := #si_State;
	    #s_UDT_ItemError.Masked := 1;
	    
	END_REGION
	
	REGION 6 - Prepare messages to the MFC
	    
	    // If item error message required signal is set, prepare the item error message.
	    IF (#sx_ItemErrorMessageReq)
	    THEN
	        #s_FB_ItemError(i_UDT_ItemErrorBody := #s_UDT_ItemError,
	                        ii_MessageGroup := 1,
	                        ix_FlagRetry := FALSE,
	                        idi_TimeSpan := 0,
	                        qx_Error => #sx_ItemErrorBlockError,
	                        qx_Warning => #sx_ItemErrorBlockWarning,
	                        iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                        iqs_FifoData := #iqs_FifoData,
	                        iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Write outputs
	    
	    // Prepare collective output error.
	    #qx_Error :=
	    #sx_ItemErrorBlockError
	    OR #sx_FIFOError;
	    
	    // Prepare collective output warning.
	    #qx_Warning :=
	    #sx_ItemErrorBlockWarning
	    OR #sx_FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Visu_EncoderValue_Status"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 146
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_EncoderStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EncoderStatusV2";   // EncoderStatus status structure
      i_UDT_EquipmentNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EquipmentNumber";   // Item number
      ix_SendAllErrorsState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - update all the messages
      ix_MFCConnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - A connection to the MFC has been established
      ix_CollectiveReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Collective reset command of all system controls
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block error
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block warning
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Message number
   END_VAR

   VAR 
      s_FB_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemError";   // Item error block's instance
      s_FB_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemStatus";   // Item status block's instance
      ss_FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoStatus";   // Status structure
      s_UDT_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message
      s_UDT_EncoderOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_EncoderStatusV2";   // Encoder  status structure
      s_UDT_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemError";   // Item error message body structure
      s_UDT_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemStatus";   // Item status message body structure
      s_R_TRIG_Connection {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger connection reastablished
      s_F_TRIG_SendAllErrors {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger from signal send all errors
      sdi_Code { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Error code
      si_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Item status
      ii_ErrorNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Counter Error Number
      si_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Error state
      sx_ItemErrorMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error message required
      sx_ItemStatusMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status message required
      sx_SendAllProcedure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send all procedure
      sx_FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO error
      sx_FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO warning
      sx_ItemErrorBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block error
      sx_ItemErrorBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block warning
      sx_ItemStatusBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block error
      sx_ItemStatusBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block warning
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	29/03/2023  | 1.0       | M. Diebel   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec  | Updated for new Baseline
	*)
	
	
	REGION 1 - Initialize message required signals
	    
	    #sx_ItemErrorMessageReq := FALSE;
	    
	    // On connection reestablish send last remembered status and error state ( status only when it's diffrent then 0 )
	    #s_R_TRIG_Connection(CLK := #ix_MFCConnected);
	    
	    
	    IF #s_R_TRIG_Connection.Q
	    THEN
	        #sx_ItemErrorMessageReq := TRUE;
	    END_IF;
	    
	    // Prepare trigger on the collective reset signal.
	    #s_F_TRIG_SendAllErrors(CLK := #ix_SendAllErrorsState);
	    
	    // When collective reset will go down, start send every equipment errors.
	    IF #s_F_TRIG_SendAllErrors.Q AND NOT #sx_SendAllProcedure
	    THEN
	        #ii_ErrorNumber := 0;
	        #sx_SendAllProcedure := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_FIFOStatus,
	              qx_Error => #sx_FIFOError,
	              qx_Warning => #sx_FIFOWarning,
	              iqv_Data := #s_UDT_Message,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 3 - Prepare message data
	    
	    IF NOT #ix_CollectiveReset
	        AND NOT #ss_FIFOStatus.FifoPreFull
	    THEN
	        
	        // Check which specific status changed, prepare code, change state and write new status into the old one.
	        IF (#i_UDT_EncoderStatus.InvalidValue <> #s_UDT_EncoderOld.InvalidValue AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".Encoder.InvalidValue;
	            #si_State := BOOL_TO_INT(#i_UDT_EncoderStatus.InvalidValue);
	            #s_UDT_EncoderOld.InvalidValue := #i_UDT_EncoderStatus.InvalidValue;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_EncoderStatus.RunningFeedbackError <> #s_UDT_EncoderOld.RunningFeedbackError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 1)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".Encoder.RunningFeedbackError;
	            #si_State := BOOL_TO_INT(#i_UDT_EncoderStatus.RunningFeedbackError);
	            #s_UDT_EncoderOld.RunningFeedbackError := #i_UDT_EncoderStatus.RunningFeedbackError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #sx_SendAllProcedure := FALSE;
	            #ii_ErrorNumber += 1;
	        END_IF;
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Write message components to the item error structure 
	    
	    #s_UDT_ItemError.ItemNumber := #i_UDT_EquipmentNumber;
	    #s_UDT_ItemError.Error := #sdi_Code;
	    #s_UDT_ItemError.State := #si_State;
	    #s_UDT_ItemError.Masked := 1;
	    
	END_REGION
	
	
	REGION 6 - Prepare messages to the MFC
	    
	    // If item error message required signal is set, prepare the item error message.
	    IF (#sx_ItemErrorMessageReq)
	    THEN
	        #s_FB_ItemError(i_UDT_ItemErrorBody := #s_UDT_ItemError,
	                        ii_MessageGroup := 1,
	                        ix_FlagRetry := FALSE,
	                        idi_TimeSpan := 0,
	                        qx_Error => #sx_ItemErrorBlockError,
	                        qx_Warning => #sx_ItemErrorBlockWarning,
	                        iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                        iqs_FifoData := #iqs_FifoData,
	                        iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	    
	END_REGION
	
	REGION 7 - Write outputs
	    
	    // Prepare collective output error.
	    #qx_Error :=
	    #sx_ItemErrorBlockError
	    OR #sx_FIFOError;
	    
	    // Prepare collective output warning.
	    #qx_Warning :=
	    #sx_ItemErrorBlockWarning
	    OR #sx_FIFOWarning;
	    
	END_REGION
	
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Visu_DMC_Status"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 145
// END_ATTRIBUTES
   VAR_INPUT 
      ix_SendAllErrorsState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - update all the messages
      ix_MFCConnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - A connection to the MFC has been established
      ix_CollectiveReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Collective reset command of all system controls
      i_UDT_DMCStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_DimensionsCheckStatusV2";   // Dimensions check status error structure
      i_UDT_EquipmentNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EquipmentNumber";   // Item number
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block error
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block warning
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Message number
   END_VAR

   VAR 
      s_FB_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemError";   // Item error block's instance
      s_FB_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemStatus";   // Item status block's instance
      s_UDT_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemError";   // Item error message body structure
      s_UDT_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemStatus";   // Item status message body structure
      s_UDT_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_BytesMessage";   // Message
      s_UDT_DMCOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_DimensionsCheckStatusV2";   // DMC old status structure
      s_UDT_FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoStatus";   // FIFO status structure
      ss_FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoStatus";   // Status structure
      s_R_TRIG_Connection {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger connection reastablished
      s_F_TRIG_SendAllErrors {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger from signal send all errors
      slr_RunningTimeMS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Conveyor running time [ms]
      sdi_DistanceTraveled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Distance traveled by conveyor
      sdi_StartStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Value of change conveyor state from start to stop and from stop to start
      sdi_Code { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Error code
      sdi_RunningTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Conveyor running time [s]
      si_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Item status
      si_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Error state
      ii_ErrorNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Counter Error Number
      sx_ItemErrorMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error message required
      sx_ItemStatusMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status message required
      sx_ItemErrorBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block error
      sx_ItemStatusBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block error
      sx_FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO error
      sx_FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO warning
      sx_MaintenanceCounterBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Maintenance counter block error
      sx_ItemStatusBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block warning
      sx_ItemErrorBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block warning
      sx_MaintenanceCounterBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Maintenance counter block warning
      sx_SendAllProcedure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send all procedure
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	03/01/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec  | Updated for new Baseline
	*)
	
	REGION 1 - Initialize message required signals
	    
	    #sx_ItemErrorMessageReq := FALSE;
	    #sx_ItemStatusMessageReq := FALSE;
	    
	    // On connection reestablish send last remembered status and error state ( status only when it's diffrent then 0 )
	    #s_R_TRIG_Connection(CLK := #ix_MFCConnected);
	    
	    IF #s_R_TRIG_Connection.Q AND #si_ItemStatus <> 0
	    THEN
	        #sx_ItemStatusMessageReq := TRUE;
	    END_IF;
	    
	    IF #s_R_TRIG_Connection.Q
	    THEN
	        #sx_ItemErrorMessageReq := TRUE;
	    END_IF;
	    
	    // Prepare trigger on the collective reset signal.
	    #s_F_TRIG_SendAllErrors(CLK := #ix_SendAllErrorsState);
	    
	    // When collective reset will go down, start send every equipment errors.
	    IF #s_F_TRIG_SendAllErrors.Q AND NOT #sx_SendAllProcedure
	    THEN
	        #ii_ErrorNumber := 0;
	        #sx_SendAllProcedure := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_FIFOStatus,
	              qx_Error => #sx_FIFOError,
	              qx_Warning => #sx_FIFOWarning,
	              iqv_Data := #s_UDT_Message,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 3 - Prepare message data
	    
	    // When there is no reset errors command, update status and errors.
	    IF NOT #ix_CollectiveReset
	        AND NOT #ss_FIFOStatus.FifoPreFull
	    THEN
	        
	        IF (#i_UDT_DMCStatus.Status <> #s_UDT_DMCOld.Status OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0))
	        THEN
	            #sx_ItemStatusMessageReq := TRUE;
	            #si_ItemStatus := #i_UDT_DMCStatus.Status;
	            #s_UDT_DMCOld.Status := #i_UDT_DMCStatus.Status;
	        END_IF;
	        
	        // Check which specific status changed, prepare code, change state and write new status into the old one.
	        IF (#i_UDT_DMCStatus.Specific.ParcelTooLongError <> #s_UDT_DMCOld.Specific.ParcelTooLongError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".DMC.ParcelTooLong;
	            #si_State := BOOL_TO_INT(#i_UDT_DMCStatus.Specific.ParcelTooLongError);
	            #s_UDT_DMCOld.Specific.ParcelTooLongError := #i_UDT_DMCStatus.Specific.ParcelTooLongError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_DMCStatus.Specific.ParcelTooShortError <> #s_UDT_DMCOld.Specific.ParcelTooShortError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 1)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".DMC.ParcelTooShort;
	            #si_State := BOOL_TO_INT(#i_UDT_DMCStatus.Specific.ParcelTooShortError);
	            #s_UDT_DMCOld.Specific.ParcelTooShortError := #i_UDT_DMCStatus.Specific.ParcelTooShortError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_DMCStatus.Specific.ParcelTooHighError <> #s_UDT_DMCOld.Specific.ParcelTooHighError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 2)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".DMC.ParcelTooHigh;
	            #si_State := BOOL_TO_INT(#i_UDT_DMCStatus.Specific.ParcelTooHighError);
	            #s_UDT_DMCOld.Specific.ParcelTooHighError := #i_UDT_DMCStatus.Specific.ParcelTooHighError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_DMCStatus.Specific.ParcelTooLowError <> #s_UDT_DMCOld.Specific.ParcelTooLowError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 3)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".DMC.ParcelTooLow;
	            #si_State := BOOL_TO_INT(#i_UDT_DMCStatus.Specific.ParcelTooLowError);
	            #s_UDT_DMCOld.Specific.ParcelTooLowError := #i_UDT_DMCStatus.Specific.ParcelTooLowError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_DMCStatus.Specific.ParcelTooWideError <> #s_UDT_DMCOld.Specific.ParcelTooWideError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 4)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".DMC.ParcelTooWide;
	            #si_State := BOOL_TO_INT(#i_UDT_DMCStatus.Specific.ParcelTooWideError);
	            #s_UDT_DMCOld.Specific.ParcelTooWideError := #i_UDT_DMCStatus.Specific.ParcelTooWideError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_DMCStatus.Specific.ParcelTooNarrowError <> #s_UDT_DMCOld.Specific.ParcelTooNarrowError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 5)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".DMC.ParcelTooNarrow;
	            #si_State := BOOL_TO_INT(#i_UDT_DMCStatus.Specific.ParcelTooNarrowError);
	            #s_UDT_DMCOld.Specific.ParcelTooNarrowError := #i_UDT_DMCStatus.Specific.ParcelTooNarrowError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_DMCStatus.Specific.IncorrectParcelOrientationError <> #s_UDT_DMCOld.Specific.IncorrectParcelOrientationError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 6)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".DMC.IncorrectParcelOrientationError;
	            #si_State := BOOL_TO_INT(#i_UDT_DMCStatus.Specific.IncorrectParcelOrientationError);
	            #s_UDT_DMCOld.Specific.IncorrectParcelOrientationError := #i_UDT_DMCStatus.Specific.IncorrectParcelOrientationError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_DMCStatus.Specific.GeneralError <> #s_UDT_DMCOld.Specific.GeneralError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 7)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".DMC.GeneralError;
	            #si_State := BOOL_TO_INT(#i_UDT_DMCStatus.Specific.GeneralError);
	            #s_UDT_DMCOld.Specific.GeneralError := #i_UDT_DMCStatus.Specific.GeneralError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Write message components to the item error structure 
	    
	    #s_UDT_ItemError.ItemNumber := #i_UDT_EquipmentNumber;
	    #s_UDT_ItemError.Error := #sdi_Code;
	    #s_UDT_ItemError.State := #si_State;
	    #s_UDT_ItemError.Masked := 1;
	    
	END_REGION
	
	REGION 5 - Write message components to the item status structure
	    
	    // Adjust library statuses into the client one.
	    // To check later
	    // Status:
	    //     19 – Running
	    //     21 - EnergySave
	    //     0 - Stopped
	    //     23 - DimensionError
	    //     3 – SafetyStop
	    
	    
	    #s_UDT_ItemStatus.Group := #i_UDT_EquipmentNumber.Group;
	    #s_UDT_ItemStatus.Node := #i_UDT_EquipmentNumber.Node;
	    #s_UDT_ItemStatus.Status := #si_ItemStatus;
	    
	END_REGION
	
	REGION 6 - Prepare messages to the MFC
	    
	    // If item error message required signal is set, prepare the item error message.
	    IF (#sx_ItemErrorMessageReq)
	    THEN
	        #s_FB_ItemError(i_UDT_ItemErrorBody := #s_UDT_ItemError,
	                        ii_MessageGroup := 1,
	                        ix_FlagRetry := FALSE,
	                        idi_TimeSpan := 0,
	                        qx_Error => #sx_ItemErrorBlockError,
	                        qx_Warning => #sx_ItemErrorBlockWarning,
	                        iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                        iqs_FifoData := #iqs_FifoData,
	                        iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	    // If item status message required signal is set, prepare the item error message.
	    IF (#sx_ItemStatusMessageReq)
	    THEN
	        #s_FB_ItemStatus(i_UDT_ItemStatusBody := #s_UDT_ItemStatus,
	                         ii_MessageGroup := 1,
	                         ix_FlagRetry := FALSE,
	                         idi_TimeSpan := 0,
	                         qx_Error => #sx_ItemStatusBlockError,
	                         qx_Warning => #sx_ItemStatusBlockWarning,
	                         iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                         iqs_FifoData := #iqs_FifoData,
	                         iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Write outputs
	    
	    // Prepare collective output error.
	    #qx_Error :=
	    #sx_ItemErrorBlockError
	    OR #sx_ItemStatusBlockError
	    OR #sx_MaintenanceCounterBlockError
	    OR #sx_FIFOError;
	    
	    // Prepare collective output warning.
	    #qx_Warning :=
	    #sx_ItemErrorBlockWarning
	    OR #sx_ItemStatusBlockWarning
	    OR #sx_MaintenanceCounterBlockWarning
	    OR #sx_FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Visu_DimensionsCheck_Status"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 144
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_DimensionsCheckStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_DimensionsCheckStatusV2";   // DimensionChceck status structure
      i_UDT_EquipmentNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EquipmentNumber";   // Item number
      ix_SendAllErrorsState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - update all the messages
      ix_MFCConnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - A connection to the MFC has been established
      ix_CollectiveReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Collective reset command of all system controls
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block error
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block warning
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Message number
   END_VAR

   VAR 
      s_FB_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemError";   // Item error block's instance
      s_FB_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemStatus";   // Item status block's instance
      ss_FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoStatus";   // Status structure
      s_UDT_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message
      s_UDT_DimensionsCheckStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_DimensionsCheckStatusV2";   // DimensionChceck  status structure
      s_UDT_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemError";   // Item error message body structure
      s_UDT_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemStatus";   // Item status message body structure
      s_R_TRIG_Connection {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger connection reastablished
      s_F_TRIG_SendAllErrors {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger from signal send all errors
      sdi_Code { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Error code
      si_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Item status
      ii_ErrorNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Counter Error Number
      si_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Error state
      sx_ItemErrorMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error message required
      sx_ItemStatusMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status message required
      sx_SendAllProcedure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send all procedure
      sx_FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO error
      sx_FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO warning
      sx_ItemErrorBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block error
      sx_ItemErrorBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block warning
      sx_ItemStatusBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block error
      sx_ItemStatusBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block warning
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	29/03/2023  | 1.0       | M. Diebel   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec  | Updated for new Baseline
	*)
	
	
	REGION 1 - Initialize message required signals
	    
	    #sx_ItemErrorMessageReq := FALSE;
	    #sx_ItemStatusMessageReq := FALSE;
	    
	    // On connection reestablish send last remembered status and error state ( status only when it's diffrent then 0 )
	    #s_R_TRIG_Connection(CLK := #ix_MFCConnected);
	    
	    IF #s_R_TRIG_Connection.Q AND #si_ItemStatus <> 0
	    THEN
	        #sx_ItemStatusMessageReq := TRUE;
	    END_IF;
	    
	    IF #s_R_TRIG_Connection.Q
	    THEN
	        #sx_ItemErrorMessageReq := TRUE;
	    END_IF;
	    
	    // Prepare trigger on the collective reset signal.
	    #s_F_TRIG_SendAllErrors(CLK := #ix_SendAllErrorsState);
	    
	    // When collective reset will go down, start send every equipment errors.
	    IF #s_F_TRIG_SendAllErrors.Q AND NOT #sx_SendAllProcedure
	    THEN
	        #ii_ErrorNumber := 0;
	        #sx_SendAllProcedure := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_FIFOStatus,
	              qx_Error => #sx_FIFOError,
	              qx_Warning => #sx_FIFOWarning,
	              iqv_Data := #s_UDT_Message,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 3 - Prepare message data
	    
	    // When there is no reset errors command, update status and errors.
	    IF NOT #ix_CollectiveReset
	        AND NOT #ss_FIFOStatus.FifoPreFull
	    THEN
	        // Status
	        IF (#i_UDT_DimensionsCheckStatus.Status <> #s_UDT_DimensionsCheckStatusOld.Status OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0))
	        THEN
	            #sx_ItemStatusMessageReq := TRUE;
	            #si_ItemStatus := #i_UDT_DimensionsCheckStatus.Status;
	            #s_UDT_DimensionsCheckStatusOld.Status := #i_UDT_DimensionsCheckStatus.Status;
	        END_IF;
	        
	        
	        // Check which specific status changed, prepare code, change state and write new status into the old one.
	        IF (#i_UDT_DimensionsCheckStatus.Specific.ParcelTooLongError <> #s_UDT_DimensionsCheckStatusOld.Specific.ParcelTooLongError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".DimensionsCheck_v2.ParcelTooLongError;
	            #si_State := BOOL_TO_INT(#i_UDT_DimensionsCheckStatus.Specific.ParcelTooLongError);
	            #s_UDT_DimensionsCheckStatusOld.Specific.ParcelTooLongError := #i_UDT_DimensionsCheckStatus.Specific.ParcelTooLongError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_DimensionsCheckStatus.Specific.ParcelTooShortError <> #s_UDT_DimensionsCheckStatusOld.Specific.ParcelTooShortError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 1)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".DimensionsCheck_v2.ParcelTooShortError;
	            #si_State := BOOL_TO_INT(#i_UDT_DimensionsCheckStatus.Specific.ParcelTooShortError);
	            #s_UDT_DimensionsCheckStatusOld.Specific.ParcelTooShortError := #i_UDT_DimensionsCheckStatus.Specific.ParcelTooShortError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_DimensionsCheckStatus.Specific.ParcelTooHighError <> #s_UDT_DimensionsCheckStatusOld.Specific.ParcelTooHighError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 2)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".DimensionsCheck_v2.ParcelTooHighError;
	            #si_State := BOOL_TO_INT(#i_UDT_DimensionsCheckStatus.Specific.ParcelTooHighError);
	            #s_UDT_DimensionsCheckStatusOld.Specific.ParcelTooHighError := #i_UDT_DimensionsCheckStatus.Specific.ParcelTooHighError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_DimensionsCheckStatus.Specific.ParcelTooLowError <> #s_UDT_DimensionsCheckStatusOld.Specific.ParcelTooLowError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 3)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".DimensionsCheck_v2.ParcelTooLowError;
	            #si_State := BOOL_TO_INT(#i_UDT_DimensionsCheckStatus.Specific.ParcelTooLowError);
	            #s_UDT_DimensionsCheckStatusOld.Specific.ParcelTooLowError := #i_UDT_DimensionsCheckStatus.Specific.ParcelTooLowError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_DimensionsCheckStatus.Specific.ParcelTooWideError <> #s_UDT_DimensionsCheckStatusOld.Specific.ParcelTooWideError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 4)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".DimensionsCheck_v2.ParcelTooWideError;
	            #si_State := BOOL_TO_INT(#i_UDT_DimensionsCheckStatus.Specific.ParcelTooWideError);
	            #s_UDT_DimensionsCheckStatusOld.Specific.ParcelTooWideError := #i_UDT_DimensionsCheckStatus.Specific.ParcelTooWideError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_DimensionsCheckStatus.Specific.ParcelTooNarrowError <> #s_UDT_DimensionsCheckStatusOld.Specific.ParcelTooNarrowError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 5)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".DimensionsCheck_v2.ParcelTooNarrowError;
	            #si_State := BOOL_TO_INT(#i_UDT_DimensionsCheckStatus.Specific.ParcelTooNarrowError);
	            #s_UDT_DimensionsCheckStatusOld.Specific.ParcelTooNarrowError := #i_UDT_DimensionsCheckStatus.Specific.ParcelTooNarrowError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_DimensionsCheckStatus.Specific.IncorrectParcelOrientationError <> #s_UDT_DimensionsCheckStatusOld.Specific.IncorrectParcelOrientationError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 6)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".DimensionsCheck_v2.IncorrectParcelOrientationError;
	            #si_State := BOOL_TO_INT(#i_UDT_DimensionsCheckStatus.Specific.IncorrectParcelOrientationError);
	            #s_UDT_DimensionsCheckStatusOld.Specific.IncorrectParcelOrientationError := #i_UDT_DimensionsCheckStatus.Specific.IncorrectParcelOrientationError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_DimensionsCheckStatus.Specific.GeneralError <> #s_UDT_DimensionsCheckStatusOld.Specific.GeneralError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 7)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".DimensionsCheck_v2.GeneralError;
	            #si_State := BOOL_TO_INT(#i_UDT_DimensionsCheckStatus.Specific.GeneralError);
	            #s_UDT_DimensionsCheckStatusOld.Specific.GeneralError := #i_UDT_DimensionsCheckStatus.Specific.GeneralError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_DimensionsCheckStatus.Specific.DisabledGeneralFunctionality <> #s_UDT_DimensionsCheckStatusOld.Specific.DisabledGeneralFunctionality AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 8)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".DimensionsCheck_v2.DisabledGeneralFunctionality;
	            #si_State := BOOL_TO_INT(#i_UDT_DimensionsCheckStatus.Specific.DisabledGeneralFunctionality);
	            #s_UDT_DimensionsCheckStatusOld.Specific.DisabledGeneralFunctionality := #i_UDT_DimensionsCheckStatus.Specific.DisabledGeneralFunctionality;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_DimensionsCheckStatus.Specific.DisabledTooLongParcel <> #s_UDT_DimensionsCheckStatusOld.Specific.DisabledTooLongParcel AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 9)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".DimensionsCheck_v2.DisabledTooLongParcel;
	            #si_State := BOOL_TO_INT(#i_UDT_DimensionsCheckStatus.Specific.DisabledTooLongParcel);
	            #s_UDT_DimensionsCheckStatusOld.Specific.DisabledTooLongParcel := #i_UDT_DimensionsCheckStatus.Specific.DisabledTooLongParcel;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_DimensionsCheckStatus.Specific.DisabledTooShortParcelError <> #s_UDT_DimensionsCheckStatusOld.Specific.DisabledTooShortParcelError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 10)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".DimensionsCheck_v2.DisabledTooShortParcelError;
	            #si_State := BOOL_TO_INT(#i_UDT_DimensionsCheckStatus.Specific.DisabledTooShortParcelError);
	            #s_UDT_DimensionsCheckStatusOld.Specific.DisabledTooShortParcelError := #i_UDT_DimensionsCheckStatus.Specific.DisabledTooShortParcelError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_DimensionsCheckStatus.Specific.DisabledTooHighParcelError <> #s_UDT_DimensionsCheckStatusOld.Specific.DisabledTooHighParcelError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 11)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".DimensionsCheck_v2.DisabledTooHighParcelError;
	            #si_State := BOOL_TO_INT(#i_UDT_DimensionsCheckStatus.Specific.DisabledTooHighParcelError);
	            #s_UDT_DimensionsCheckStatusOld.Specific.DisabledTooHighParcelError := #i_UDT_DimensionsCheckStatus.Specific.DisabledTooHighParcelError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_DimensionsCheckStatus.Specific.DisabledTooLowParcelError <> #s_UDT_DimensionsCheckStatusOld.Specific.DisabledTooLowParcelError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 12)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".DimensionsCheck_v2.DisabledTooLowParcelError;
	            #si_State := BOOL_TO_INT(#i_UDT_DimensionsCheckStatus.Specific.DisabledTooLowParcelError);
	            #s_UDT_DimensionsCheckStatusOld.Specific.DisabledTooLowParcelError := #i_UDT_DimensionsCheckStatus.Specific.DisabledTooLowParcelError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_DimensionsCheckStatus.Specific.DisabledTooWideParcelError <> #s_UDT_DimensionsCheckStatusOld.Specific.DisabledTooWideParcelError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 13)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".DimensionsCheck_v2.DisabledTooWideParcelError;
	            #si_State := BOOL_TO_INT(#i_UDT_DimensionsCheckStatus.Specific.DisabledTooWideParcelError);
	            #s_UDT_DimensionsCheckStatusOld.Specific.DisabledTooWideParcelError := #i_UDT_DimensionsCheckStatus.Specific.DisabledTooWideParcelError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_DimensionsCheckStatus.Specific.DisabledTooNarrowParcelError <> #s_UDT_DimensionsCheckStatusOld.Specific.DisabledTooNarrowParcelError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 14)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".DimensionsCheck_v2.DisabledTooNarrowParcelError;
	            #si_State := BOOL_TO_INT(#i_UDT_DimensionsCheckStatus.Specific.DisabledTooNarrowParcelError);
	            #s_UDT_DimensionsCheckStatusOld.Specific.DisabledTooNarrowParcelError := #i_UDT_DimensionsCheckStatus.Specific.DisabledTooNarrowParcelError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_DimensionsCheckStatus.Specific.DisabledParcelOrientationError <> #s_UDT_DimensionsCheckStatusOld.Specific.DisabledParcelOrientationError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 15)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".DimensionsCheck_v2.DisabledParcelOrientationError;
	            #si_State := BOOL_TO_INT(#i_UDT_DimensionsCheckStatus.Specific.DisabledParcelOrientationError);
	            #s_UDT_DimensionsCheckStatusOld.Specific.DisabledParcelOrientationError := #i_UDT_DimensionsCheckStatus.Specific.DisabledParcelOrientationError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #sx_SendAllProcedure := FALSE;
	            #ii_ErrorNumber += 1;
	        END_IF;
	    END_IF;
	END_REGION
	
	REGION 4 - Write message components to the item error structure 
	    
	    #s_UDT_ItemError.ItemNumber := #i_UDT_EquipmentNumber;
	    #s_UDT_ItemError.Error := #sdi_Code;
	    #s_UDT_ItemError.State := #si_State;
	    #s_UDT_ItemError.Masked := 1;
	    
	END_REGION
	
	REGION 5 - Write message components to the item status structure
	    
	    #s_UDT_ItemStatus.Group := #i_UDT_EquipmentNumber.Group;
	    #s_UDT_ItemStatus.Node := #i_UDT_EquipmentNumber.Node;
	    #s_UDT_ItemStatus.Status := #si_ItemStatus;
	    
	END_REGION
	
	REGION 6 - Prepare messages to the MFC
	    
	    // If item error message required signal is set, prepare the item error message.
	    IF (#sx_ItemErrorMessageReq)
	    THEN
	        #s_FB_ItemError(i_UDT_ItemErrorBody := #s_UDT_ItemError,
	                        ii_MessageGroup := 1,
	                        ix_FlagRetry := FALSE,
	                        idi_TimeSpan := 0,
	                        qx_Error => #sx_ItemErrorBlockError,
	                        qx_Warning => #sx_ItemErrorBlockWarning,
	                        iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                        iqs_FifoData := #iqs_FifoData,
	                        iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	    // If item status message required signal is set, prepare the item error message.
	    IF (#sx_ItemStatusMessageReq)
	    THEN
	        #s_FB_ItemStatus(i_UDT_ItemStatusBody := #s_UDT_ItemStatus,
	                         ii_MessageGroup := 1,
	                         ix_FlagRetry := FALSE,
	                         idi_TimeSpan := 0,
	                         qx_Error => #sx_ItemStatusBlockError,
	                         qx_Warning => #sx_ItemStatusBlockWarning,
	                         iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                         iqs_FifoData := #iqs_FifoData,
	                         iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Write outputs
	    
	    // Prepare collective output error.
	    #qx_Error :=
	    #sx_ItemErrorBlockError
	    OR #sx_ItemStatusBlockError
	    OR #sx_FIFOError;
	    
	    // Prepare collective output warning.
	    #qx_Warning :=
	    #sx_ItemErrorBlockWarning
	    OR #sx_ItemStatusBlockWarning
	    OR #sx_FIFOWarning;
	    
	END_REGION
	
	
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Visu_RetractableRoller_Status"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 157
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_RetractrableRollerStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_RetractrableRoller_Status";   // RetractrableRoller status structure
      i_UDT_EquipmentNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EquipmentNumber";   // Item number
      ix_SendAllErrorsState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - update all the messages
      ix_MFCConnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - A connection to the MFC has been established
      ix_CollectiveReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Collective reset command of all system controls
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block error
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block warning
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Message number
   END_VAR

   VAR 
      s_FB_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemError";   // Item error block's instance
      s_FB_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemStatus";   // Item status block's instance
      ss_FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoStatus";   // Status structure
      s_UDT_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message
      s_UDT_RetractrableRollerOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RetractrableRoller_Status";   // RetractrableRoller status structure
      s_UDT_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemError";   // Item error message body structure
      s_UDT_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemStatus";   // Item status message body structure
      s_R_TRIG_Connection {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger connection reastablished
      s_F_TRIG_SendAllErrors {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger from signal send all errors
      sdi_Code { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Error code
      si_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Item status
      ii_ErrorNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Counter Error Number
      si_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Error state
      sx_ItemErrorMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error message required
      sx_ItemStatusMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status message required
      sx_SendAllProcedure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send all procedure
      sx_FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO error
      sx_FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO warning
      sx_ItemErrorBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block error
      sx_ItemErrorBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block warning
      sx_ItemStatusBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block error
      sx_ItemStatusBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block warning
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	09/05/2023  | 1.0       | M. Diebel   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec | Updated for new Baseline
	*)
	
	
	REGION 1 - Initialize message required signals
	    
	    #sx_ItemErrorMessageReq := FALSE;
	    #sx_ItemStatusMessageReq := FALSE;
	    
	    // On connection reestablish send last remembered status and error state ( status only when it's diffrent then 0 )
	    #s_R_TRIG_Connection(CLK := #ix_MFCConnected);
	    
	    IF #s_R_TRIG_Connection.Q AND #si_ItemStatus <> 0
	    THEN
	        #sx_ItemStatusMessageReq := TRUE;
	    END_IF;
	    
	    IF #s_R_TRIG_Connection.Q
	    THEN
	        #sx_ItemErrorMessageReq := TRUE;
	    END_IF;
	    
	    // Prepare trigger on the collective reset signal.
	    #s_F_TRIG_SendAllErrors(CLK := #ix_SendAllErrorsState);
	    
	    // When collective reset will go down, start send every equipment errors.
	    IF #s_F_TRIG_SendAllErrors.Q AND NOT #sx_SendAllProcedure
	    THEN
	        #ii_ErrorNumber := 0;
	        #sx_SendAllProcedure := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_FIFOStatus,
	              qx_Error => #sx_FIFOError,
	              qx_Warning => #sx_FIFOWarning,
	              iqv_Data := #s_UDT_Message,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 3 - Prepare message data
	    
	    // When there is no reset errors command, update status and errors.
	    IF NOT #ix_CollectiveReset
	        AND NOT #ss_FIFOStatus.FifoPreFull
	    THEN
	        // Status
	        IF (#i_UDT_RetractrableRollerStatus.Status <> #s_UDT_RetractrableRollerOld.Status OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0))
	        THEN
	            #sx_ItemStatusMessageReq := TRUE;
	            #si_ItemStatus := #i_UDT_RetractrableRollerStatus.Status;
	            #s_UDT_RetractrableRollerOld.Status := #i_UDT_RetractrableRollerStatus.Status;
	        END_IF;
	        
	        
	        // Check which specific status changed, prepare code, change state and write new status into the old one.
	        IF (#i_UDT_RetractrableRollerStatus.Specific.NoHomePosition <> #s_UDT_RetractrableRollerOld.Specific.NoHomePosition AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".Retractable.NoHomePosition;
	            #si_State := BOOL_TO_INT(#i_UDT_RetractrableRollerStatus.Specific.NoHomePosition);
	            #s_UDT_RetractrableRollerOld.Specific.NoHomePosition := #i_UDT_RetractrableRollerStatus.Specific.NoHomePosition;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_RetractrableRollerStatus.Specific.RollerError <> #s_UDT_RetractrableRollerOld.Specific.RollerError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 1)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".Retractable.Errorr;
	            #si_State := BOOL_TO_INT(#i_UDT_RetractrableRollerStatus.Specific.RollerError);
	            #s_UDT_RetractrableRollerOld.Specific.RollerError := #i_UDT_RetractrableRollerStatus.Specific.RollerError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #sx_SendAllProcedure := FALSE;
	        END_IF;
	    END_IF;
	END_REGION
	
	REGION 4 - Write message components to the item error structure 
	    
	    #s_UDT_ItemError.ItemNumber := #i_UDT_EquipmentNumber;
	    #s_UDT_ItemError.Error := #sdi_Code;
	    #s_UDT_ItemError.State := #si_State;
	    #s_UDT_ItemError.Masked := 1;
	    
	END_REGION
	
	REGION 5 - Write message components to the item status structure
	    
	    #s_UDT_ItemStatus.Group := #i_UDT_EquipmentNumber.Group;
	    #s_UDT_ItemStatus.Node := #i_UDT_EquipmentNumber.Node;
	    #s_UDT_ItemStatus.Status := #si_ItemStatus;
	    
	END_REGION
	
	REGION 6 - Prepare messages to the MFC
	    
	    // If item error message required signal is set, prepare the item error message.
	    IF (#sx_ItemErrorMessageReq)
	    THEN
	        #s_FB_ItemError(i_UDT_ItemErrorBody := #s_UDT_ItemError,
	                        ii_MessageGroup := 1,
	                        ix_FlagRetry := FALSE,
	                        idi_TimeSpan := 0,
	                        qx_Error => #sx_ItemErrorBlockError,
	                        qx_Warning => #sx_ItemErrorBlockWarning,
	                        iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                        iqs_FifoData := #iqs_FifoData,
	                        iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	    // If item status message required signal is set, prepare the item error message.
	    IF (#sx_ItemStatusMessageReq)
	    THEN
	        #s_FB_ItemStatus(i_UDT_ItemStatusBody := #s_UDT_ItemStatus,
	                         ii_MessageGroup := 1,
	                         ix_FlagRetry := FALSE,
	                         idi_TimeSpan := 0,
	                         qx_Error => #sx_ItemStatusBlockError,
	                         qx_Warning => #sx_ItemStatusBlockWarning,
	                         iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                         iqs_FifoData := #iqs_FifoData,
	                         iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Write outputs
	    
	    // Prepare collective output error.
	    #qx_Error :=
	    #sx_ItemErrorBlockError
	    OR #sx_ItemStatusBlockError
	    OR #sx_FIFOError;
	    
	    // Prepare collective output warning.
	    #qx_Warning :=
	    #sx_ItemErrorBlockWarning
	    OR #sx_ItemStatusBlockWarning
	    OR #sx_FIFOWarning;
	    
	END_REGION
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Visu_RIO_Status"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 158
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_RIOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_RIOStatus";   // RIO status structure
      i_UDT_EquipmentNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EquipmentNumber";   // Item number
      ix_SendAllErrorsState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - update all the messages
      ix_MFCConnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - A connection to the MFC has been established
      ix_CollectiveReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Collective reset command of all system controls
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block error
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block warning
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Message number
   END_VAR

   VAR 
      s_FB_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemStatus";   // Item status block's instance
      s_FB_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemError";   // Item error block's instance
      ss_FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoStatus";   // Status structure
      s_UDT_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message
      s_UDT_RIOOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RIOStatus";   // RIO old status structure
      s_UDT_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemError";   // Item error message body structure
      s_UDT_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemStatus";   // Item status message body structure
      s_F_TRIG_SendAllErrors {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger from signal send all errors
      s_R_TRIG_Connection {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger connection reastablished
      sdi_Code { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Error code
      si_ET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Value
      si_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Item status
      ii_ErrorNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Counter Error Number
      si_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Error state
      sx_ItemErrorMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error message required
      sx_ItemStatusMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status message required
      sx_SendAllProcedure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send all procedure
      sx_FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO error
      sx_FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO warning
      sx_ItemErrorBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block error
      sx_ItemErrorBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block warning
      sx_ItemStatusBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block error
      sx_ItemStatusBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block warning
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	21/03/2023  | 1.0       | M. Diebel   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec | Updated for new Baseline
	*)
	
	
	REGION 1 - Initialize message required signals
	    
	    #sx_ItemErrorMessageReq := FALSE;
	    #sx_ItemStatusMessageReq := FALSE;
	    
	    // On connection reestablish send last remembered status and error state ( status only when it's diffrent then 0 )
	    #s_R_TRIG_Connection(CLK := #ix_MFCConnected);
	    
	    IF #s_R_TRIG_Connection.Q AND #si_ItemStatus <> 0
	    THEN
	        #sx_ItemStatusMessageReq := TRUE;
	    END_IF;
	    
	    IF #s_R_TRIG_Connection.Q
	    THEN
	        #sx_ItemErrorMessageReq := TRUE;
	    END_IF;
	    
	    // Prepare trigger on the collective reset signal.
	    #s_F_TRIG_SendAllErrors(CLK := #ix_SendAllErrorsState);
	    
	    // When collective reset will go down, start send every equipment errors.
	    IF #s_F_TRIG_SendAllErrors.Q AND NOT #sx_SendAllProcedure
	    THEN
	        #ii_ErrorNumber := 0;
	        #sx_SendAllProcedure := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_FIFOStatus,
	              qx_Error => #sx_FIFOError,
	              qx_Warning => #sx_FIFOWarning,
	              iqv_Data := #s_UDT_Message,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 3 - Prepare message data
	    
	    // When there is no reset errors command, update status and errors.
	    IF NOT #ix_CollectiveReset
	        AND NOT #ss_FIFOStatus.FifoPreFull
	    THEN
	        // Status
	        IF (#i_UDT_RIOStatus.Status <> #s_UDT_RIOOld.Status OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0))
	        THEN
	            #sx_ItemStatusMessageReq := TRUE;
	            #si_ItemStatus := #i_UDT_RIOStatus.Status;
	            #s_UDT_RIOOld.Status := #i_UDT_RIOStatus.Status;
	        END_IF;
	        
	        
	        // Check which specific status changed, prepare code, change state and write new status into the old one.
	        IF (#i_UDT_RIOStatus.Specific.PNSlaveNotOnline <> #s_UDT_RIOOld.Specific.PNSlaveNotOnline AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".RIO.PNSlaveNotOnline;
	            #si_State := BOOL_TO_INT(#i_UDT_RIOStatus.Specific.PNSlaveNotOnline);
	            #s_UDT_RIOOld.Specific.PNSlaveNotOnline := #i_UDT_RIOStatus.Specific.PNSlaveNotOnline;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_RIOStatus.Specific.PNSlaveError <> #s_UDT_RIOOld.Specific.PNSlaveError AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 1)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".RIO.PNSlaveError;
	            #si_State := BOOL_TO_INT(#i_UDT_RIOStatus.Specific.PNSlaveError);
	            #s_UDT_RIOOld.Specific.PNSlaveError := #i_UDT_RIOStatus.Specific.PNSlaveError;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_RIOStatus.Specific.PNSlaveWarning <> #s_UDT_RIOOld.Specific.PNSlaveWarning AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 2)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".RIO.PNSlaveWarning;
	            #si_State := BOOL_TO_INT(#i_UDT_RIOStatus.Specific.PNSlaveWarning);
	            #s_UDT_RIOOld.Specific.PNSlaveWarning := #i_UDT_RIOStatus.Specific.PNSlaveWarning;
	            #sx_ItemErrorMessageReq := TRUE;
	            #sx_SendAllProcedure := FALSE;
	            #ii_ErrorNumber += 1;
	        ELSE
	            
	            FOR #si_ET := 0 TO 31 DO
	                
	                IF (#i_UDT_RIOStatus.Specific.ET200sp_ErrorModule[#si_ET] <> #s_UDT_RIOOld.Specific.ET200sp_ErrorModule[#si_ET])
	                THEN
	                    #sdi_Code := "DB_MFC_ErrorCode".RIO.ET200sp_ErrorModule[#si_ET];
	                    #si_State := BOOL_TO_INT(#i_UDT_RIOStatus.Specific.ET200sp_ErrorModule[#si_ET]);
	                    #s_UDT_RIOOld.Specific.ET200sp_ErrorModule[#si_ET] := #i_UDT_RIOStatus.Specific.ET200sp_ErrorModule[#si_ET];
	                    #sx_ItemErrorMessageReq := TRUE;
	                    EXIT;
	                END_IF;
	            END_FOR;
	        END_IF;
	        
	    END_IF;
	END_REGION
	
	REGION 4 - Write message components to the item error structure 
	    
	    #s_UDT_ItemError.ItemNumber := #i_UDT_EquipmentNumber;
	    #s_UDT_ItemError.Error := #sdi_Code;
	    #s_UDT_ItemError.State := #si_State;
	    #s_UDT_ItemError.Masked := 1;
	    
	END_REGION
	
	REGION 5 - Write message components to the item status structure
	    
	    #s_UDT_ItemStatus.Group := #i_UDT_EquipmentNumber.Group;
	    #s_UDT_ItemStatus.Node := #i_UDT_EquipmentNumber.Node;
	    #s_UDT_ItemStatus.Status := #si_ItemStatus;
	    
	END_REGION
	
	REGION 6 - Prepare messages to the MFC
	    
	    // If item error message required signal is set, prepare the item error message.
	    IF (#sx_ItemErrorMessageReq)
	    THEN
	        #s_FB_ItemError(i_UDT_ItemErrorBody := #s_UDT_ItemError,
	                        ii_MessageGroup := 1,
	                        ix_FlagRetry := FALSE,
	                        idi_TimeSpan := 0,
	                        qx_Error => #sx_ItemErrorBlockError,
	                        qx_Warning => #sx_ItemErrorBlockWarning,
	                        iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                        iqs_FifoData := #iqs_FifoData,
	                        iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	    // If item status message required signal is set, prepare the item error message.
	    IF (#sx_ItemStatusMessageReq)
	    THEN
	        #s_FB_ItemStatus(i_UDT_ItemStatusBody := #s_UDT_ItemStatus,
	                         ii_MessageGroup := 1,
	                         ix_FlagRetry := FALSE,
	                         idi_TimeSpan := 0,
	                         qx_Error => #sx_ItemStatusBlockError,
	                         qx_Warning => #sx_ItemStatusBlockWarning,
	                         iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                         iqs_FifoData := #iqs_FifoData,
	                         iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Write outputs
	    
	    // Prepare collective output error.
	    #qx_Error :=
	    #sx_ItemErrorBlockError
	    OR #sx_ItemStatusBlockError
	    OR #sx_FIFOError;
	    
	    // Prepare collective output warning.
	    #qx_Warning :=
	    #sx_ItemErrorBlockWarning
	    OR #sx_ItemStatusBlockWarning
	    OR #sx_FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Visu_SystemControl_Status"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 159
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_SystemControlStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_SystemControlStatus";   // System control status structure
      i_UDT_EquipmentNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EquipmentNumber";   // Item number
      ix_SendAllErrorsState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - update all the messages
      ix_MFCConnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - A connection to the MFC has been established
      ix_CollectiveReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Collective reset command of all system controls
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block error
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block warning
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Message number
   END_VAR

   VAR 
      s_FB_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemStatus";   // Item status block's instance
      s_FB_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemError";   // Item error block's instance
      ss_FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoStatus";   // Status structure
      s_UDT_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message
      s_UDT_SystemControlStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_SystemControlStatus";   // System control old status structure
      s_UDT_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemError";   // Item error message body structure
      s_UDT_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemStatus";   // Item status message body structure
      s_F_TRIG_SendAllErrors {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger from signal send all errors
      s_R_TRIG_Connection {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger connection reastablished
      sdi_Code { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Error code
      si_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Item status
      ii_ErrorNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Counter Error Number
      si_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Error state
      sx_ItemErrorMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error message required
      sx_ItemStatusMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status message required
      sx_SendAllProcedure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send all procedure
      sx_FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO error
      sx_FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO warning
      sx_ItemStatusBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block error
      sx_ItemStatusBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block warning
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	24/03/2023  | 1.0       | M. Diebel   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec  | Updated for new Baseline
	*)
	
	
	REGION 1 - Initialize message required signals
	    
	    
	    #sx_ItemStatusMessageReq := FALSE;
	    
	    // On connection reestablish send last remembered status and error state ( status only when it's diffrent then 0 )
	    #s_R_TRIG_Connection(CLK := #ix_MFCConnected);
	    
	    IF #s_R_TRIG_Connection.Q AND #si_ItemStatus <> 0
	    THEN
	        #sx_ItemStatusMessageReq := TRUE;
	    END_IF;
	    
	    
	    // Prepare trigger on the collective reset signal.
	    #s_F_TRIG_SendAllErrors(CLK := #ix_SendAllErrorsState);
	    
	    // When collective reset will go down, start send every equipment errors.
	    IF #s_F_TRIG_SendAllErrors.Q AND NOT #sx_SendAllProcedure
	    THEN
	        #ii_ErrorNumber := 0;
	        #sx_SendAllProcedure := TRUE;
	    END_IF;
	    
	END_REGION
	
	
	REGION 2 - FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_FIFOStatus,
	              qx_Error => #sx_FIFOError,
	              qx_Warning => #sx_FIFOWarning,
	              iqv_Data := #s_UDT_Message,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	
	REGION 3 - Prepare message data
	    
	    // When there is no reset errors command, update status and errors.
	    IF NOT #ix_CollectiveReset
	        AND NOT #ss_FIFOStatus.FifoPreFull
	    THEN
	        // Status
	        IF (#i_UDT_SystemControlStatus.Status <> #s_UDT_SystemControlStatusOld.Status OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0))
	        THEN
	            #sx_ItemStatusMessageReq := TRUE;
	            #si_ItemStatus := #i_UDT_SystemControlStatus.Status;
	            #s_UDT_SystemControlStatusOld.Status := #i_UDT_SystemControlStatus.Status;
	            #sx_SendAllProcedure := FALSE;
	        END_IF;
	    END_IF;
	END_REGION
	
	
	REGION 4 - Write message components to the item status structure
	    
	    #s_UDT_ItemStatus.Group := #i_UDT_EquipmentNumber.Group;
	    #s_UDT_ItemStatus.Node := #i_UDT_EquipmentNumber.Node;
	    #s_UDT_ItemStatus.Status := #si_ItemStatus;
	    
	END_REGION
	
	REGION 5 - Prepare messages to the MFC
	    
	    // If item status message required signal is set, prepare the item error message.
	    IF (#sx_ItemStatusMessageReq)
	    THEN
	        #s_FB_ItemStatus(i_UDT_ItemStatusBody := #s_UDT_ItemStatus,
	                         ii_MessageGroup := 1,
	                         ix_FlagRetry := FALSE,
	                         idi_TimeSpan := 0,
	                         qx_Error => #sx_ItemStatusBlockError,
	                         qx_Warning => #sx_ItemStatusBlockWarning,
	                         iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                         iqs_FifoData := #iqs_FifoData,
	                         iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Write outputs
	    
	    // Prepare collective output error.
	    #qx_Error :=
	    #sx_ItemStatusBlockError
	    OR #sx_FIFOError;
	    
	    // Prepare collective output warning.
	    #qx_Warning :=
	    #sx_ItemStatusBlockWarning
	    OR #sx_FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Visu_Decode"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 143
// END_ATTRIBUTES
   VAR_INPUT 
      iudi_HeartbeatTimeout { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   //   Heartbeat timeout [ms]
      ix_Connected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when HB monitoring enable
      ix_ResetData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when reset statistics required
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when collective block error occurred
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when collective block warningoccurred
      qx_SendAllErrorsState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_IN_OUT 
      iqx_Reconnect { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Reconnect connection
      iq_UDT_Statistics : "UDT_DecodeStatistics";   //   Decode statistics
      iq_UDT_FifoReceiveHeader : "UDT_FifoHeader";   //   FIFO receive header
      iqs_FifoReceiveData : Array[*] of "UDT_MessageV2";   //   FIFO receive data
   END_VAR

   VAR 
      s_FB_TimerHeartbeatCheck { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //   MHS "FB_TimerOnOffDelay" - to measure the time of missing HB
      s_UDT_FifoMessage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   //   Buffer for fifos message
      s_UDT_MessageHeader { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageHeaderV2";   //   Message header
      s_UDT_Heartbeat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageHeaderV2";   //   Heartbeat message
      s_UDT_SetDateTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_SetDateTimeBody";   //   Set date time message body
      s_UDT_MFCCommand { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MFCCommandBody";   // MFC command message body
      s_R_TRIG_Connected {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Siemens "R_TRIG" - to prepare the rising edge trigger on "ix_Connected" signal
      s_R_TRIG_FirstConnection {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      s_F_TRIG_HeartbeatNotOk {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //   Siemens "F_TRIG" - to prepare the falling edge trigger on "sx_HeartbeatOk" signal
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //   Status structure
         BadMessage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..10] of "UDT_MessageV2";   //     Unknown message read
         FIFOReceiveStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";   //     Receive FIFO status structure
         FIFOReceiveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //     FIFO error
         FIFOReceiveWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //     FIFO warning
         OperationModeError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //     Operation mode error
         OperationModeWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //     Operation mode warning
         OverflowModeError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //     Overflow mode error
         OverflowModeWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //     Overflow mode error
         SetDateTimeError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //     Set date time error
         SetDateTimeWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //     Set date time warning
         InvalidTimeout { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //     Invalid Heartbeat timeout
      END_STRUCT;
      ss_MFCCommand { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // MFC command message body for  MessageID = 30020
         Groups { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         Nodes { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      END_STRUCT;
      st_TimeConverted {InstructionName := 'DTL'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DTL;   //   Message date and time converted into DTL data type
      st_PLCTime {InstructionName := 'DTL'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DTL;   //   Date and type of the PLC
      sdi_DeserializePosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //   Deserialize position
      si_DeserializeHeaderStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Header deserialize status
      si_DeserializeBodyStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Body deserialize status
      si_ReadStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Status of the PLC date and time read operation
      si_WriteStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Status of the PLC date and time write operation
      si_RingBufferNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 1;   //   Bad messages ringbuffer counter
      sb_CalculatedChecksum { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   //   Calculated checksum
      sx_Heartbeat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Heartbeat message detected
      sx_HeartbeatOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Heartbeat ok
      sx_SendAllErrorsState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_TEMP 
      tx_MessageRead : Bool;   //   Message read from FIFO
      tx_InvalidHeader : Bool;   //   Invalid header
      tx_InvalidMessageID : Bool;   //   Invalid message ID
      tx_BadMessage : Bool;   //   Message with prohibited data
      ti_BadMessageSize : Int;   //   Bad message buffer size
      ti_NumberOfMessageBytes : Int;   //   Length of FIFO message
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	03/01/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	10/08/2023  | 2.0       | M. Diebel    | Send all messages in first connected | DHL Munich 2023
	13/03/2023  | 2.1       | S. Nieswiec  | Updated for new Baseline
	*)
	
	
	REGION 1 - Initialize value
	    
	    #sx_SendAllErrorsState := FALSE;
	    
	END_REGION
	
	
	REGION 2 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOReceiveStatus,
	              qx_Error => #ss_Status.FIFOReceiveError,
	              qx_Warning => #ss_Status.FIFOReceiveWarning,
	              iqv_Data := #s_UDT_FifoMessage,
	              iqUDT_FifoHeader := #iq_UDT_FifoReceiveHeader,
	              iqv_DataBuffer := #iqs_FifoReceiveData);
	    
	    // FIFO isn't empty and doesn't have error.
	    IF NOT #iq_UDT_FifoReceiveHeader.Status.Empty
	        AND NOT #ss_Status.FIFOReceiveError
	    THEN
	        // Mode 'R' - Read FIFO record.
	        "FC_Fifo"(ic_Mode := 'R',
	                  qUDT_Status => #ss_Status.FIFOReceiveStatus,
	                  qx_Error => #ss_Status.FIFOReceiveError,
	                  qx_Warning => #ss_Status.FIFOReceiveWarning,
	                  iqv_Data := #s_UDT_FifoMessage,
	                  iqUDT_FifoHeader := #iq_UDT_FifoReceiveHeader,
	                  iqv_DataBuffer := #iqs_FifoReceiveData);
	        
	        // Message read bit set. 
	        #tx_MessageRead := TRUE;
	        
	        // FIFO empty or FIFO error occured.      
	    ELSE
	        #tx_MessageRead := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 3 – Decoding header
	    
	    IF #tx_MessageRead
	    THEN
	        // Converting message header from array of bytes to UDT.
	        #sdi_DeserializePosition := 0;
	        #si_DeserializeHeaderStatus := Deserialize(SRC_ARRAY := #s_UDT_FifoMessage.Bytes,
	                                                   DEST_VARIABLE => #s_UDT_MessageHeader,
	                                                   POS := #sdi_DeserializePosition);
	        REGION 3.1 – Checking checksum
	            
	            "FC_Checksum"(i_UDT_MessageHeader := #s_UDT_MessageHeader,
	                          qb_Checksum => #sb_CalculatedChecksum);
	            
	            // Checking if calculated checksum is valid with checksum in header.
	            IF #sb_CalculatedChecksum <> #s_UDT_MessageHeader.Checksum
	            THEN
	                #tx_InvalidHeader := TRUE;
	            ELSE
	                #tx_InvalidHeader := FALSE;
	            END_IF;
	            
	        END_REGION
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 – Message type recognition 
	    
	    IF #tx_MessageRead
	        AND NOT #tx_InvalidHeader
	        AND #si_DeserializeHeaderStatus = 0
	    THEN
	        // Invalid message ID initialize.
	        #tx_InvalidMessageID := FALSE;
	        #tx_BadMessage := FALSE;
	        
	        // Heartbeat message.
	        IF #s_UDT_MessageHeader.MessageID = 20
	        THEN
	            #s_UDT_Heartbeat := #s_UDT_MessageHeader;
	            #sx_Heartbeat := TRUE;
	            
	            // Set date time message.   
	        ELSIF #s_UDT_MessageHeader.MessageID = 30
	        THEN
	            // Convert array of bytes into body structure
	            #si_DeserializeBodyStatus := Deserialize(SRC_ARRAY := #s_UDT_FifoMessage.Bytes,
	                                                     DEST_VARIABLE => #s_UDT_SetDateTime,
	                                                     POS := #sdi_DeserializePosition);
	            
	            // Date and time validation.
	            IF #s_UDT_SetDateTime.Month >= 1
	                AND #s_UDT_SetDateTime.Month <= 12
	                AND #s_UDT_SetDateTime.Day >= 1
	                AND #s_UDT_SetDateTime.Day <= 31
	                AND #s_UDT_SetDateTime.Hour >= 0
	                AND #s_UDT_SetDateTime.Hour <= 23
	                AND #s_UDT_SetDateTime.Minute >= 0
	                AND #s_UDT_SetDateTime.Minute <= 59
	                AND #s_UDT_SetDateTime.Second >= 0
	                AND #s_UDT_SetDateTime.Second <= 59
	            THEN
	                // Write all others converted components of date and time into the DTL data type variable.
	                #st_TimeConverted.YEAR := INT_TO_UINT(#s_UDT_SetDateTime.Year) + 2000;
	                #st_TimeConverted.MONTH := INT_TO_USINT(#s_UDT_SetDateTime.Month);
	                #st_TimeConverted.DAY := INT_TO_USINT(#s_UDT_SetDateTime.Day);
	                #st_TimeConverted.HOUR := INT_TO_USINT(#s_UDT_SetDateTime.Hour);
	                #st_TimeConverted.MINUTE := INT_TO_USINT(#s_UDT_SetDateTime.Minute);
	                #st_TimeConverted.SECOND := INT_TO_USINT(#s_UDT_SetDateTime.Second);
	                
	                // Read value of the date and time of the PLC and clear the nanoseconds.
	                //#si_ReadStatus := RD_SYS_T(#st_PLCTime);
	                #si_ReadStatus := RD_LOC_T(#st_PLCTime);
	                #st_PLCTime.NANOSECOND := 0;
	                
	                // If the date and time from the message is different then the PLC one change it to the one from message.
	                IF #st_TimeConverted <> #st_PLCTime
	                THEN
	                    //#si_WriteStatus := WR_SYS_T(#st_TimeConverted);
	                    #si_WriteStatus := WR_LOC_T(LOCTIME := #st_TimeConverted, DST := FALSE);
	                    
	                END_IF;
	                
	                // Invalid set time message.
	            ELSE
	                #tx_BadMessage := TRUE;
	            END_IF;
	            
	        ELSIF #s_UDT_MessageHeader.MessageID = 30900
	        THEN
	            
	            // Convert array of bytes into structure.
	            #si_DeserializeBodyStatus := Deserialize(SRC_ARRAY := #s_UDT_FifoMessage.Bytes,
	                                                     DEST_VARIABLE => #s_UDT_MFCCommand,
	                                                     POS := #sdi_DeserializePosition);
	            
	            IF #s_UDT_MFCCommand.ClusterID = 2
	                AND #s_UDT_MFCCommand.CommandID = 10
	            THEN
	                #sx_SendAllErrorsState := TRUE;
	            END_IF;
	            
	            // IF #s_UDT_MFCCommand.ClusterID = 1
	            // THEN
	            
	            // IF  #s_UDT_MFCCommand.CommandID = 1
	            // THEN
	            //     "DB_HMICommands".MFCSystemControl.Start := TRUE;
	            
	            // ELSIF #s_UDT_MFCCommand.CommandID = 2
	            // THEN
	            //     "DB_HMICommands".MFCSystemControl.Stop := TRUE;
	            
	            // ELSIF #s_UDT_MFCCommand.CommandID = 3
	            // THEN
	            //     "DB_HMICommands".MFCSystemControl.Reset := TRUE;
	            // END_IF;
	            
	            // END_IF;
	            
	        ELSIF #s_UDT_MessageHeader.MessageID = 30020
	        THEN
	            
	            // Convert array of bytes into structure.
	            #si_DeserializeBodyStatus := Deserialize(SRC_ARRAY := #s_UDT_FifoMessage.Bytes,
	                                                     DEST_VARIABLE => #ss_MFCCommand,
	                                                     POS := #sdi_DeserializePosition);
	            
	            
	            
	            IF #ss_MFCCommand.Groups = 0 AND #ss_MFCCommand.Nodes = 0
	            THEN
	                #sx_SendAllErrorsState := TRUE;
	            END_IF;
	            
	        ELSE
	            // Invalid messsage ID.
	            #tx_InvalidMessageID := TRUE;
	        END_IF;
	    END_IF;
	    
	END_REGION
	
	REGION 5 - First connection
	    
	    #s_R_TRIG_FirstConnection(CLK := #ix_Connected);
	    
	    
	    IF #s_R_TRIG_FirstConnection.Q AND "DB_MFC_Visu".Configuration.SendAllErrors_FirstConnected
	    THEN
	        
	        #sx_SendAllErrorsState := TRUE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 6 – Heartbeat monitoring 
	    
	    //HB timeout validation.
	    #ss_Status.InvalidTimeout := #iudi_HeartbeatTimeout <= 0;
	    
	    //HB monitoring if timeout correct.
	    IF NOT #ss_Status.InvalidTimeout
	    THEN
	        #s_R_TRIG_Connected(CLK := #ix_Connected);
	        
	        // Heartbeat timeout monitoring.
	        #s_FB_TimerHeartbeatCheck(iudi_OnDelayTime := 0,
	                                  iudi_OffDelayTime := #iudi_HeartbeatTimeout,
	                                  ix_SignalToDelay := #sx_Heartbeat OR #s_R_TRIG_Connected.Q,
	                                  qx_DelayedSignal => #sx_HeartbeatOK);
	        
	        #sx_Heartbeat := FALSE;
	        #s_F_TRIG_HeartbeatNotOk(CLK := #sx_HeartbeatOK);
	        
	        IF #s_F_TRIG_HeartbeatNotOk.Q
	            AND "DB_Memory".AlwaysFalse
	        THEN
	            // Re-establish conncect with partner and increment the number of communication lost.
	            #iqx_Reconnect := TRUE;
	            #iq_UDT_Statistics.HeartbeatNotObserved += 1;
	        END_IF;
	    END_IF;
	    
	END_REGION
	
	REGION 7 – Statistics update
	    
	    // Error statistics update required. 
	    IF #tx_InvalidHeader
	        OR #tx_InvalidMessageID
	        OR #tx_BadMessage
	    THEN
	        // Invalid message received counter incrementation.
	        #iq_UDT_Statistics.InvalidMessage += 1;
	        
	        // Maximum number of bad messages array.
	        #ti_BadMessageSize := "FC_GetNrOfArrayEl"(#ss_Status.BadMessage);
	        
	        // Writing invalid message in a bad message array.
	        IF #si_RingBufferNumber >= #ti_BadMessageSize
	        THEN
	            #si_RingBufferNumber := 1;
	        END_IF;
	        
	        #ti_NumberOfMessageBytes := "FC_GetNrOfArrayEl"(iv_Array := #s_UDT_FifoMessage.Bytes);
	        
	        MOVE_BLK(IN := #s_UDT_FifoMessage.Bytes[0],
	                 COUNT := INT_TO_UINT(#ti_NumberOfMessageBytes) - 1,
	                 OUT => #ss_Status.BadMessage[#si_RingBufferNumber].Bytes[0]);
	        
	        #si_RingBufferNumber += 1;
	    END_IF;
	    
	    //Resetting statistics.
	    IF #ix_ResetData
	    THEN
	        #iq_UDT_Statistics.InvalidMessage := 0;
	        #iq_UDT_Statistics.HeartbeatNotObserved := 0;
	    END_IF;
	    
	END_REGION
	
	REGION 9 – Status 
	    
	    // Collective error output.
	    #qx_Error :=
	    #ss_Status.FIFOReceiveError
	    OR #ss_Status.InvalidTimeout
	    OR #ss_Status.SetDateTimeError
	    OR #ss_Status.OverflowModeError
	    OR #ss_Status.OperationModeError;
	    
	    // Collective warning output.
	    #qx_Warning :=
	    #ss_Status.FIFOReceiveWarning
	    OR #ss_Status.OperationModeWarning
	    OR #ss_Status.OverflowModeWarning
	    OR #ss_Status.SetDateTimeWarning;
	    
	END_REGION
	
	REGION Write Output
	    
	    #qx_SendAllErrorsState := #sx_SendAllErrorsState;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Visu_Rapiscan_Status"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 156
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_RapiscanStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_RapiscanStatus";   // Rapiscan status structure
      i_UDT_EquipmentNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EquipmentNumber";   // Item number
      ix_SendAllErrorsState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - update all the messages
      ix_MFCConnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - A connection to the MFC has been established
      ix_CollectiveReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Collective reset command of all system controls
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block error
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Block warning
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Message number
   END_VAR

   VAR 
      s_FB_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemError";   // Item error block's instance
      s_FB_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ItemStatus";   // Item status block's instance
      ss_FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoStatus";   // Status structure
      s_UDT_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message
      s_UDT_RapiscanOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RapiscanStatus";   // Rapiscan status structure
      s_UDT_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemError";   // Item error message body structure
      s_UDT_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemStatus";   // Item status message body structure
      s_R_TRIG_Connection {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger connection reastablished
      s_F_TRIG_SendAllErrors {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger from signal send all errors
      sdi_Code { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Error code
      si_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Item status
      ii_ErrorNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Counter Error Number
      si_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Error state
      sx_ItemErrorMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error message required
      sx_ItemStatusMessageReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status message required
      sx_SendAllProcedure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Send all procedure
      sx_FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO error
      sx_FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO warning
      sx_ItemErrorBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block error
      sx_ItemErrorBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item error block warning
      sx_ItemStatusBlockError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block error
      sx_ItemStatusBlockWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Item status block warning
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	27/03/2023  | 1.0       | M. Diebel   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec | Updated for new Baseline
	*)
	
	
	REGION 1 - Initialize message required signals
	    
	    #sx_ItemErrorMessageReq := FALSE;
	    #sx_ItemStatusMessageReq := FALSE;
	    
	    // On connection reestablish send last remembered status and error state ( status only when it's diffrent then 0 )
	    #s_R_TRIG_Connection(CLK := #ix_MFCConnected);
	    
	    IF #s_R_TRIG_Connection.Q AND #si_ItemStatus <> 0
	    THEN
	        #sx_ItemStatusMessageReq := TRUE;
	    END_IF;
	    
	    IF #s_R_TRIG_Connection.Q
	    THEN
	        #sx_ItemErrorMessageReq := TRUE;
	    END_IF;
	    
	    // Prepare trigger on the collective reset signal.
	    #s_F_TRIG_SendAllErrors(CLK := #ix_SendAllErrorsState);
	    
	    // When collective reset will go down, start send every equipment errors.
	    IF #s_F_TRIG_SendAllErrors.Q AND NOT #sx_SendAllProcedure
	    THEN
	        #ii_ErrorNumber := 0;
	        #sx_SendAllProcedure := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_FIFOStatus,
	              qx_Error => #sx_FIFOError,
	              qx_Warning => #sx_FIFOWarning,
	              iqv_Data := #s_UDT_Message,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 3 - Prepare message data
	    
	    // When there is no reset errors command, update status and errors.
	    IF NOT #ix_CollectiveReset
	        AND NOT #ss_FIFOStatus.FifoPreFull
	    THEN
	        // Status
	        IF (#i_UDT_RapiscanStatus.Status <> #s_UDT_RapiscanOld.Status OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0))
	        THEN
	            #sx_ItemStatusMessageReq := TRUE;
	            #si_ItemStatus := #i_UDT_RapiscanStatus.Status;
	            #s_UDT_RapiscanOld.Status := #i_UDT_RapiscanStatus.Status;
	        END_IF;
	        
	        
	        // Check which specific status changed, prepare code, change state and write new status into the old one.
	        IF (#i_UDT_RapiscanStatus.XraySpecific.XrayEnergised <> #s_UDT_RapiscanOld.XraySpecific.XrayEnergised AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 0)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".Rapiscan.XrayEnergised;
	            #si_State := BOOL_TO_INT(#i_UDT_RapiscanStatus.XraySpecific.XrayEnergised);
	            #s_UDT_RapiscanOld.XraySpecific.XrayEnergised := #i_UDT_RapiscanStatus.XraySpecific.XrayEnergised;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_RapiscanStatus.XraySpecific.XrayFault <> #s_UDT_RapiscanOld.XraySpecific.XrayFault AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 1)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".Rapiscan.XrayFault;
	            #si_State := BOOL_TO_INT(#i_UDT_RapiscanStatus.XraySpecific.XrayFault);
	            #s_UDT_RapiscanOld.XraySpecific.XrayFault := #i_UDT_RapiscanStatus.XraySpecific.XrayFault;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_RapiscanStatus.XraySpecific.XrayRdyRCV <> #s_UDT_RapiscanOld.XraySpecific.XrayRdyRCV AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 2)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".Rapiscan.XrayRdyRCV;
	            #si_State := BOOL_TO_INT(#i_UDT_RapiscanStatus.XraySpecific.XrayRdyRCV);
	            #s_UDT_RapiscanOld.XraySpecific.XrayRdyRCV := #i_UDT_RapiscanStatus.XraySpecific.XrayRdyRCV;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_RapiscanStatus.XraySpecific.XrayRdySend <> #s_UDT_RapiscanOld.XraySpecific.XrayRdySend AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 3)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".Rapiscan.XrayRdySend;
	            #si_State := BOOL_TO_INT(#i_UDT_RapiscanStatus.XraySpecific.XrayRdySend);
	            #s_UDT_RapiscanOld.XraySpecific.XrayRdySend := #i_UDT_RapiscanStatus.XraySpecific.XrayRdySend;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_RapiscanStatus.XraySpecific.BagScanning <> #s_UDT_RapiscanOld.XraySpecific.BagScanning AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 4)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".Rapiscan.BagScanning;
	            #si_State := BOOL_TO_INT(#i_UDT_RapiscanStatus.XraySpecific.BagScanning);
	            #s_UDT_RapiscanOld.XraySpecific.BagScanning := #i_UDT_RapiscanStatus.XraySpecific.BagScanning;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_RapiscanStatus.XraySpecific.TransportMode <> #s_UDT_RapiscanOld.XraySpecific.TransportMode AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 5)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".Rapiscan.TransportMode;
	            #si_State := BOOL_TO_INT(#i_UDT_RapiscanStatus.XraySpecific.TransportMode);
	            #s_UDT_RapiscanOld.XraySpecific.TransportMode := #i_UDT_RapiscanStatus.XraySpecific.TransportMode;
	            #sx_ItemErrorMessageReq := TRUE;
	            #ii_ErrorNumber += 1;
	        ELSIF (#i_UDT_RapiscanStatus.XraySpecific.BackBelt <> #s_UDT_RapiscanOld.XraySpecific.BackBelt AND NOT #sx_SendAllProcedure)
	            OR (#sx_SendAllProcedure AND #ii_ErrorNumber = 6)
	        THEN
	            #sdi_Code := "DB_MFC_ErrorCode".Rapiscan.BackBelt;
	            #si_State := BOOL_TO_INT(#i_UDT_RapiscanStatus.XraySpecific.BackBelt);
	            #s_UDT_RapiscanOld.XraySpecific.BackBelt := #i_UDT_RapiscanStatus.XraySpecific.BackBelt;
	            #sx_ItemErrorMessageReq := TRUE;
	            #sx_SendAllProcedure := FALSE;
	            #ii_ErrorNumber += 1;
	        END_IF;
	    END_IF;
	END_REGION
	
	REGION 4 - Write message components to the item error structure 
	    
	    #s_UDT_ItemError.ItemNumber := #i_UDT_EquipmentNumber;
	    #s_UDT_ItemError.Error := #sdi_Code;
	    #s_UDT_ItemError.State := #si_State;
	    #s_UDT_ItemError.Masked := 1;
	    
	END_REGION
	
	REGION 5 - Write message components to the item status structure
	    
	    #s_UDT_ItemStatus.Group := #i_UDT_EquipmentNumber.Group;
	    #s_UDT_ItemStatus.Node := #i_UDT_EquipmentNumber.Node;
	    #s_UDT_ItemStatus.Status := #si_ItemStatus;
	    
	END_REGION
	
	REGION 6 - Prepare messages to the MFC
	    
	    // If item error message required signal is set, prepare the item error message.
	    IF (#sx_ItemErrorMessageReq)
	    THEN
	        #s_FB_ItemError(i_UDT_ItemErrorBody := #s_UDT_ItemError,
	                        ii_MessageGroup := 1,
	                        ix_FlagRetry := FALSE,
	                        idi_TimeSpan := 0,
	                        qx_Error => #sx_ItemErrorBlockError,
	                        qx_Warning => #sx_ItemErrorBlockWarning,
	                        iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                        iqs_FifoData := #iqs_FifoData,
	                        iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	    // If item status message required signal is set, prepare the item error message.
	    IF (#sx_ItemStatusMessageReq)
	    THEN
	        #s_FB_ItemStatus(i_UDT_ItemStatusBody := #s_UDT_ItemStatus,
	                         ii_MessageGroup := 1,
	                         ix_FlagRetry := FALSE,
	                         idi_TimeSpan := 0,
	                         qx_Error => #sx_ItemStatusBlockError,
	                         qx_Warning => #sx_ItemStatusBlockWarning,
	                         iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                         iqs_FifoData := #iqs_FifoData,
	                         iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Write outputs
	    
	    // Prepare collective output error.
	    #qx_Error :=
	    #sx_ItemErrorBlockError
	    OR #sx_ItemStatusBlockError
	    OR #sx_FIFOError;
	    
	    // Prepare collective output warning.
	    #qx_Warning :=
	    #sx_ItemErrorBlockWarning
	    OR #sx_ItemStatusBlockWarning
	    OR #sx_FIFOWarning;
	    
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MessageCompresion"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 2.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 133
// END_ATTRIBUTES
   VAR_IN_OUT 
      iq_UDT_FifoReceiveHeader_In : "UDT_FifoHeader";   // Data to be compressed - Fifo Header
      iqs_FifoReceiveData_In : Array[*] of "UDT_MessageV2";   // Data to be compressed - Fiffo Data
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Message number
      iq_UDT_FifoReceiveHeader_Out : "UDT_FifoHeader";   // Data compressed - Fifo Header
      iqs_FifoReceiveData_Out : Array[*] of "UDT_MessageV2";   // Data compressed - Fiffo Data
   END_VAR

   VAR 
      s_UDT_MessageHeader { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageHeaderV2";   // Message header
      s_UDT_FifoMessage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";
      s_UDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";
      s_UDT_MessageArray_Empty { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";
      s_UDT_ItemErrorBody { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemError";   // Item error message body structure
      s_UDT_ItemStatusBody { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ItemStatus";   // Item status message body structure
      sa_Data_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Array[0..1001] of "UDT_ItemError";
      sa_Data_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Array[0..1001] of "UDT_ItemStatus";
      sa_Data_InvalidMessageID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Array[0..1001] of "UDT_MessageV2";
      ss_NewErrorMessage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..101] of Struct
         Size { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         Body { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Array[1..100] of "UDT_ItemError";
      END_STRUCT;
      ss_NewStatusMessage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..101] of Struct
         Size { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         Body { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Array[1..1000] of "UDT_ItemStatus";
      END_STRUCT;
      ss_NewErrorMessage_Empty { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..101] of Struct
         Size { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         Body { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Array[1..100] of "UDT_ItemError";
      END_STRUCT;
      ss_NewStatusMessage_Empty { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..101] of Struct
         Size { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         Body { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Array[1..1000] of "UDT_ItemStatus";
      END_STRUCT;
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure - Fifo
         FIFOReceiveStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";
         FIFOInvalidMessageIDStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";
         FIFOItemErrorStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";
         FIFOItemStatusStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //   FIFO error
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //   FIFO warning
         InvalidMessageArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Message array is too short for message
      END_STRUCT;
      sdi_DeserializePosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Deserialize position
      si_DeserializeHeaderStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Header deserialize status
      sb_CalculatedChecksum { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Calculated checksum
      si_DeserializeBodyStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Body deserialize status
      si_Counter_ItemError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 0;
      si_Counter_ItemStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 0;
      si_Counter_InvalidMessageID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 0;
      si_ItemError_MessageToCompress { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_NewMessage_Counter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_StoredMessages { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_HeaderSerializeStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_BodySerializeStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      sdi_SerializePosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      si_BodyLenght { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      test { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..1000] of Int;
   END_VAR

   VAR_TEMP 
      tx_MessageRead : Bool;   // Message read correctly
      tx_InvalidHeader : Bool;   // Invalid header
      ti_Loop_CopyData : Int;   // Loop counter - Copy data from Fifo
      ti_Loop_InvalidMessageID : Int;   // Loop counter - Write data to Fifo
      ti_Loop_ItemError : Int;   // Loop counter - Write data to Fifo
      ti_Loop_ItemError_FiFo : Int;
      ti_Loop_ItemError_FiFo_1 : Int;
      ti_Loop_ItemStatus_FiFo : Int;
      ti_Loop_ItemStatus_FiFo_1 : Int;
      ti_Loop_ItemStatus : Int;   // Loop counter - Write data to Fifo
   END_VAR

   VAR CONSTANT 
      ci_ItemStatus_MessageLength : Int := 24;   // Message length in bytes
      ci_ItemStatus_BodyLenght : Int := 6;   // Message body length
      ci_ItemError_MessageLenght : Int := 34;   // Message length in bytes
      ci_ItemError_BodyLenght : Int := 16;   // Message body length
      ci_ItemError_BodyMaxSize : Int := 16;
      ci_ItemStatus_BodyMaxSize : Int := 12;
      ci_ItemStatus_MessageID : Int := 21020;   // Message ID number
      ci_ItemError_MessageID : Int := 21010;   // Message ID number
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------      
	
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	21/12/2022  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	11/08/2023  | 2.0       | M. Diebel    | Fixed issues   | DHL Munich 2023
	05/03/2024  | 2.1       | M. Diebel    | Cleas message data   | DHL Munich 2023
	13/03/2023  | 2.2       | S. Nieswiec  | Updated for new Baseline
	*)
	
	
	REGION 1 - Deactivate the function 
	    
	    //When are less like 2 messages in the array
	    IF #iq_UDT_FifoReceiveHeader_In.TotalEntriesStored < 2 THEN
	        
	        RETURN;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Copy data 
	    //Copy data from FiFo to static memory
	    
	    //Set how many message take to array from FIFO
	    #si_StoredMessages := "DB_MFC_Visu".Configuration.NumberOfCompressedMessages;
	    
	    //Initial value
	    #si_Counter_ItemError := 0;
	    #si_Counter_ItemStatus := 0;
	    #si_Counter_InvalidMessageID := 0;
	    
	    FOR #ti_Loop_CopyData := 1 TO #si_StoredMessages DO
	        
	        REGION 2.1 – FIFO 
	            
	            // Mode 'S' - FIFO register status update.
	            "FC_Fifo"(ic_Mode := 'S',
	                      qUDT_Status => #ss_Status.FIFOReceiveStatus,
	                      qx_Error => #ss_Status.FIFOError,
	                      qx_Warning => #ss_Status.FIFOWarning,
	                      iqv_Data := #s_UDT_FifoMessage,
	                      iqUDT_FifoHeader := #iq_UDT_FifoReceiveHeader_In,
	                      iqv_DataBuffer := #iqs_FifoReceiveData_In);
	            
	            // FIFO isn't empty and doesn't have error.
	            IF NOT #iq_UDT_FifoReceiveHeader_In.Status.Empty
	                AND NOT #ss_Status.FIFOError
	            THEN
	                // Mode 'R' - Read FIFO record.
	                "FC_Fifo"(ic_Mode := 'R',
	                          qUDT_Status => #ss_Status.FIFOReceiveStatus,
	                          qx_Error => #ss_Status.FIFOError,
	                          qx_Warning => #ss_Status.FIFOWarning,
	                          iqv_Data := #s_UDT_FifoMessage,
	                          iqUDT_FifoHeader := #iq_UDT_FifoReceiveHeader_In,
	                          iqv_DataBuffer := #iqs_FifoReceiveData_In);
	                
	                // Message read bit set. 
	                #tx_MessageRead := TRUE;
	            ELSE
	                #tx_MessageRead := FALSE;
	            END_IF;
	            
	        END_REGION
	        
	        REGION 2.2 – Decoding header
	            
	            IF #tx_MessageRead
	            THEN
	                // Converting message header from array of bytes to UDT.
	                #sdi_DeserializePosition := 0;
	                #si_DeserializeHeaderStatus := Deserialize(SRC_ARRAY := #s_UDT_FifoMessage.Bytes,
	                                                           DEST_VARIABLE => #s_UDT_MessageHeader,
	                                                           POS := #sdi_DeserializePosition);
	                
	                //Checking checksum
	                "FC_Checksum"(i_UDT_MessageHeader := #s_UDT_MessageHeader,
	                              qb_Checksum => #sb_CalculatedChecksum);
	                
	                // Checking if calculated checksum is valid with checksum in header.
	                IF #sb_CalculatedChecksum <> #s_UDT_MessageHeader.Checksum
	                THEN
	                    #tx_InvalidHeader := TRUE;
	                ELSE
	                    #tx_InvalidHeader := FALSE;
	                END_IF;
	                
	            END_IF;
	            
	        END_REGION
	        
	        REGION 2.3 – Message type recognition 
	            
	            IF #tx_MessageRead
	                AND NOT #tx_InvalidHeader
	                AND #si_DeserializeHeaderStatus = 0
	            THEN
	                
	                //Item error message.
	                IF #s_UDT_MessageHeader.MessageID = #ci_ItemError_MessageID AND #s_UDT_MessageHeader.BodyLength = #ci_ItemError_BodyLenght
	                THEN
	                    // Convert array of bytes into body structure.
	                    #si_DeserializeBodyStatus := Deserialize(SRC_ARRAY := #s_UDT_FifoMessage.Bytes,
	                                                             DEST_VARIABLE => #s_UDT_ItemErrorBody,
	                                                             POS := #sdi_DeserializePosition);
	                    //Add up position
	                    #si_Counter_ItemError += 1;
	                    //Copy data to array
	                    #sa_Data_ItemError[#si_Counter_ItemError] := #s_UDT_ItemErrorBody;
	                    
	                    
	                    // Item status message.
	                ELSIF #s_UDT_MessageHeader.MessageID = #ci_ItemStatus_MessageID AND #s_UDT_MessageHeader.BodyLength = #ci_ItemStatus_BodyLenght
	                THEN
	                    // Convert array of bytes into body structure.
	                    #si_DeserializeBodyStatus := Deserialize(SRC_ARRAY := #s_UDT_FifoMessage.Bytes,
	                                                             DEST_VARIABLE => #s_UDT_ItemStatusBody,
	                                                             POS := #sdi_DeserializePosition);
	                    //Add up position
	                    #si_Counter_ItemStatus += 1;
	                    //Copy data to array
	                    #sa_Data_ItemStatus[#si_Counter_ItemStatus] := #s_UDT_ItemStatusBody;
	                    
	                ELSE
	                    
	                    //Add up position
	                    #si_Counter_InvalidMessageID += 1;
	                    //Copy data to array
	                    #sa_Data_InvalidMessageID[#si_Counter_InvalidMessageID] := #s_UDT_FifoMessage;
	                    
	                END_IF;
	                
	            END_IF;
	            
	        END_REGION
	        
	    END_FOR;
	    
	END_REGION
	
	REGION 3 - Crate new message
	    
	    REGION 3.1 - Item Error
	        
	        IF #si_Counter_ItemError >= 1 THEN
	            
	            #si_NewMessage_Counter := 1;
	            #ss_NewErrorMessage := #ss_NewErrorMessage_Empty;
	            #s_UDT_MessageArray.Bytes := #s_UDT_MessageArray_Empty.Bytes;
	            
	            // Crate new messages
	            FOR #ti_Loop_ItemError := 1 TO #si_Counter_ItemError DO
	                
	                IF #ss_NewErrorMessage[#si_NewMessage_Counter].Size > #ci_ItemError_BodyMaxSize THEN
	                    
	                    #si_NewMessage_Counter += 1;
	                    
	                END_IF;
	                
	                #ss_NewErrorMessage[#si_NewMessage_Counter].Body[#ti_Loop_ItemError] := #sa_Data_ItemError[#ti_Loop_ItemError];
	                #ss_NewErrorMessage[#si_NewMessage_Counter].Size += 1;
	                
	            END_FOR;
	            
	            
	            FOR #ti_Loop_ItemError_FiFo := 1 TO #si_NewMessage_Counter DO
	                
	                // Check sequence number. If it is equal or greater than 30000 reset it to 1.
	                IF #iqdi_MessageSequenceNumber < 30000
	                THEN
	                    #iqdi_MessageSequenceNumber += 1;
	                ELSE
	                    #iqdi_MessageSequenceNumber := 1;
	                END_IF;
	                
	                #ss_NewErrorMessage[#ti_Loop_ItemError_FiFo].Size := #ss_NewErrorMessage[#ti_Loop_ItemError_FiFo].Size * #ci_ItemError_BodyLenght;
	                
	                // Write parts of the header into structure.
	                #s_UDT_MessageHeader.BodyLength := #ss_NewErrorMessage[#ti_Loop_ItemError_FiFo].Size;
	                #s_UDT_MessageHeader.FlagRetry.%X0 := FALSE;
	                #s_UDT_MessageHeader.Group := 1;
	                #s_UDT_MessageHeader.MessageID := #ci_ItemError_MessageID;
	                #s_UDT_MessageHeader.SequenceNumber := #iqdi_MessageSequenceNumber;
	                #s_UDT_MessageHeader.TimeSpan := 0;
	                
	                // Calculate the header checksum.
	                "FC_Checksum"(i_UDT_MessageHeader := #s_UDT_MessageHeader,
	                              qb_Checksum => #s_UDT_MessageHeader.Checksum);
	                
	                
	                // Initialize the header serialize position and convert header structure into array of bytes.
	                #sdi_SerializePosition := 0;
	                #si_HeaderSerializeStatus := Serialize(SRC_VARIABLE := #s_UDT_MessageHeader,
	                                                       DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                       POS := #sdi_SerializePosition);
	                
	                FOR #ti_Loop_ItemError_FiFo_1 := 1 TO #ss_NewErrorMessage[#ti_Loop_ItemError_FiFo].Size / #ci_ItemError_BodyLenght DO
	                    
	                    #s_UDT_ItemErrorBody := #ss_NewErrorMessage[#ti_Loop_ItemError_FiFo].Body[#ti_Loop_ItemError_FiFo_1];
	                    
	                    // Convert message body structure into array of bytes.
	                    #si_BodySerializeStatus := Serialize(SRC_VARIABLE := #s_UDT_ItemErrorBody,
	                                                         DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                         POS := #sdi_SerializePosition);
	                END_FOR;
	                
	                // Mode 'W' - Write FIFO record.
	                "FC_Fifo"(ic_Mode := 'W',
	                          qUDT_Status => #ss_Status.FIFOItemErrorStatus,
	                          qx_Error => #ss_Status.FIFOError,
	                          qx_Warning => #ss_Status.FIFOWarning,
	                          iqv_Data := #s_UDT_MessageArray,
	                          iqUDT_FifoHeader := #iq_UDT_FifoReceiveHeader_Out,
	                          iqv_DataBuffer := #iqs_FifoReceiveData_Out);
	            END_FOR;
	            
	            #si_Counter_ItemError := 0;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 3.2 - Item Status     
	        
	        IF #si_Counter_ItemStatus >= 1 THEN
	            
	            #si_NewMessage_Counter := 1;
	            #ss_NewStatusMessage := #ss_NewStatusMessage_Empty;
	            #s_UDT_MessageArray.Bytes := #s_UDT_MessageArray_Empty.Bytes;
	            
	            // Crate new messages
	            FOR #ti_Loop_ItemStatus := 1 TO #si_Counter_ItemStatus DO
	                
	                IF #ss_NewStatusMessage[#si_NewMessage_Counter].Size > #ci_ItemStatus_BodyMaxSize THEN
	                    
	                    #si_NewMessage_Counter += 1;
	                    
	                END_IF;
	                
	                #ss_NewStatusMessage[#si_NewMessage_Counter].Body[#ti_Loop_ItemStatus] := #sa_Data_ItemStatus[#ti_Loop_ItemStatus];
	                #ss_NewStatusMessage[#si_NewMessage_Counter].Size += 1;
	                
	            END_FOR;
	            
	            
	            FOR #ti_Loop_ItemStatus_FiFo := 1 TO #si_NewMessage_Counter DO
	                
	                // Check sequence number. If it is equal or greater than 30000 reset it to 1.
	                IF #iqdi_MessageSequenceNumber < 30000
	                THEN
	                    #iqdi_MessageSequenceNumber += 1;
	                ELSE
	                    #iqdi_MessageSequenceNumber := 1;
	                END_IF;
	                
	                #ss_NewStatusMessage[#ti_Loop_ItemStatus_FiFo].Size := #ss_NewStatusMessage[#ti_Loop_ItemStatus_FiFo].Size * #ci_ItemStatus_BodyLenght;
	                
	                // Write parts of the header into structure.
	                #s_UDT_MessageHeader.BodyLength := #ss_NewStatusMessage[#ti_Loop_ItemStatus_FiFo].Size;
	                #s_UDT_MessageHeader.FlagRetry.%X0 := FALSE;
	                #s_UDT_MessageHeader.Group := 1;
	                #s_UDT_MessageHeader.MessageID := #ci_ItemStatus_MessageID;
	                #s_UDT_MessageHeader.SequenceNumber := #iqdi_MessageSequenceNumber;
	                #s_UDT_MessageHeader.TimeSpan := 0;
	                
	                // Calculate the header checksum.
	                "FC_Checksum"(i_UDT_MessageHeader := #s_UDT_MessageHeader,
	                              qb_Checksum => #s_UDT_MessageHeader.Checksum);
	                
	                // Initialize the header serialize position and convert header structure into array of bytes.
	                #sdi_SerializePosition := 0;
	                #si_HeaderSerializeStatus := Serialize(SRC_VARIABLE := #s_UDT_MessageHeader,
	                                                       DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                       POS := #sdi_SerializePosition);
	                
	                FOR #ti_Loop_ItemStatus_FiFo_1 := 1 TO #ss_NewStatusMessage[#ti_Loop_ItemStatus_FiFo].Size / #ci_ItemStatus_BodyLenght DO
	                    
	                    #s_UDT_ItemStatusBody := #ss_NewStatusMessage[#ti_Loop_ItemStatus_FiFo].Body[#ti_Loop_ItemStatus_FiFo_1];
	                    
	                    // Convert message body structure into array of bytes.
	                    #si_BodySerializeStatus := Serialize(SRC_VARIABLE := #s_UDT_ItemStatusBody,
	                                                         DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                         POS := #sdi_SerializePosition);
	                END_FOR;
	                
	                // Mode 'W' - Write FIFO record.
	                "FC_Fifo"(ic_Mode := 'W',
	                          qUDT_Status => #ss_Status.FIFOItemStatusStatus,
	                          qx_Error => #ss_Status.FIFOError,
	                          qx_Warning => #ss_Status.FIFOWarning,
	                          iqv_Data := #s_UDT_MessageArray,
	                          iqUDT_FifoHeader := #iq_UDT_FifoReceiveHeader_Out,
	                          iqv_DataBuffer := #iqs_FifoReceiveData_Out);
	            END_FOR;
	            
	            #si_Counter_ItemStatus := 0;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 3.3 Other types of messages
	        
	        IF #si_Counter_InvalidMessageID > 0 THEN
	            
	            FOR #ti_Loop_InvalidMessageID := 1 TO #si_Counter_InvalidMessageID DO
	                
	                // Mode 'W' - Write FIFO record.
	                "FC_Fifo"(ic_Mode := 'W',
	                          qUDT_Status => #ss_Status.FIFOInvalidMessageIDStatus,
	                          qx_Error => #ss_Status.FIFOError,
	                          qx_Warning => #ss_Status.FIFOWarning,
	                          iqv_Data := #sa_Data_InvalidMessageID[#ti_Loop_InvalidMessageID],
	                          iqUDT_FifoHeader := #iq_UDT_FifoReceiveHeader_Out,
	                          iqv_DataBuffer := #iqs_FifoReceiveData_Out);
	                
	            END_FOR;
	            
	            #si_Counter_InvalidMessageID := 0;
	            
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	
	
END_FUNCTION_BLOCK

