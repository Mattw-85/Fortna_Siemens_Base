TYPE "UDT_ModuleState"
TITLE = UDT_ModuleState
VERSION : 0.1
//User-defined structure of module states.
   STRUCT
      Configured { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Module configured
      Exist { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Module exist
      Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Module has error
   END_STRUCT;

END_TYPE

TYPE "UDT_DeviceState"
TITLE = UDT_DeviceState
VERSION : 0.1
//User-defined structure of device states.
   STRUCT
      Configure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Device configured in TIA Portal hardware
      Exist { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Device physically connected
      Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Device has an error
      ProfinetNumber : UInt;   // Profinet slave number
      HW_ID : UInt;   // Device's HW_ID
      PNDeviceName : String;   // Device's project name
   END_STRUCT;

END_TYPE

TYPE "UDT_ProfinetDevice"
TITLE = UDT_ProfinetDevice
VERSION : 0.1
//User-defined structure of profinet device state.
   STRUCT
      DeviceState : "UDT_DeviceState";   // Device state
      Module { S7_SetPoint := 'False'} : Array[0..31] of "UDT_ModuleState";   // Modules
   END_STRUCT;

END_TYPE

TYPE "UDT_GINWCS"
VERSION : 0.1
   STRUCT
      ActionTaken : String;   // Location code value that describes the actual disposition of the package
      Destination1 : String[20];   // Location code value that describes where the package should go (Diverter Number)
      Destination2 : String[20];   // Location code value that describes where the package should go (Diverter Number)
      Destination3 : String[20];   // Location code value that describes where the package should go (Diverter Number)
      Destination4 : String[20];   // Location code value that describes where the package should go (Diverter Number)
      Destination5 : String[20];   // Location code value that describes where the package should go (Diverter Number)
      ReasonCode : String[2];   // Management Code value that describes the result of attempting to route the package to the Destination
      Barcode1 : String;   // Barcode identifier code
      Barcode2 : String;
      Barcode3 : String;
      Barcode4 : String;
   END_STRUCT;

END_TYPE

TYPE "UDT_ProfinetNetwork"
TITLE = UDT_ProfinetNetwork
VERSION : 0.1
//User-defined structure of profinet network state.
   STRUCT
      DeviceStatus : Array[0..512] of "UDT_ProfinetDevice";   // Profinet device status
   END_STRUCT;

END_TYPE

TYPE "UDT_GINWES"
VERSION : 0.1
   STRUCT
      Barcode : String[40];
   END_STRUCT;

END_TYPE

TYPE "UDT_GINDHL"
VERSION : 0.1
   STRUCT
      ObjectID : String[10];   // Object ID
      VID : String[16];   // Virtual Item Identifier (VID)
      PieceID : String[40];   // Piece ID barcodes
      SortStrategy : String[1];   // Sort Strategy 1 - Highest priority available , 2 - Nearest
      ParcelReject { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Parcel reject
      Destination : Array[1..6] of Struct   // Destination
         ID : UInt;   // ID
         SortCommandActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sort command
         ParcelSorted { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parcel sorted
         Rejected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parcel rejected
         Reason : Int;   // Reason
      END_STRUCT;
      ParcelLocation : Struct   // Parcel Location
         Current : UInt;   // Current
         Last : UInt;   // Last
         Sort : UInt;   // Sort
      END_STRUCT;
      MFCMessage : Struct   // MFC Sort messages
         Sent : Struct   // Messages sent from the PLC to the MFC system
            SortResult { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Sort Result
            VIDResponse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message VID Response
            ScanReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Scan Reset
            XrayResult { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Xray result
            ParcelRegInfo { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Xray registration info
         END_STRUCT;
         Received : Struct   // Messages received from the MFC system to the PLC
            RejectParcel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Reject Parcel
            Destination { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Destination
            DestinationResent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Destination Resent
            TemporaryParcelIdentifier { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message Temporary Parcel Identifier
            XrayRegistrationInfo { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         END_STRUCT;
      END_STRUCT;
      Xray : Struct   // Xray data structure
         RoutingCode : String[2];   // Routing code
         Group : String[1];   // The group field is used to identify the group of the operator decisions came from in a
         Level : String[1];   // Level field is used to identify which level the operator decision came from in a
         Result : String[1];   // Results can be indicated with the following:A = Accept, R = Reject, U = Unavailable (Timeout), Z = High Threat
         BagIDMessage : Struct   // Message from PLC to Xray
            MessagePrepared { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message is prepared and ready to send
            WrongMessageStructure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message has wrong structure
            Sent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message sent by PLC to Xray
            SentTime : String;   // Time when message sent by PLC to Xray
            NotSent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message was not sent from the PLC
            Received { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message received by Xray
            TimeReceived : String;   // Time when message received by Xray
            NotReceived { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message did not reach Xray
         END_STRUCT;
         DecisionMessage : Struct   // Message from Xray to PLC
            Received { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message received by PLC
            ReceivedTime : String;   // The message received by PLC
            NotReceivedOnTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The message did not reach PLC
         END_STRUCT;
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_GINUPS"
VERSION : 0.1
   STRUCT
      TRKNUM : String[18];   // Tracking number
      PKGUID : String[32];   // Package ID
      MSGID : String[32];   // Message ID
      Length : Int;   // Camera Length in mm
      Width : Int;   // Camera Width in mm
      Height : Int;   // Camera Height in mm
      Weight : DInt;   // Weight in g
      IDCreated { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 1, Bit 0 - PLCID created or TrayID Read
      DimDataRcv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 1, Bit 1 - Package Dimensional Data Received via Camera Scan Data Message
      PkgWrongInduct { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 1, Bit 2 - Package Did NOT Induct Properly (Non-Tray Systems)
      IDCalcFromCamID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 2, Bit 0 - PLCID/TrayID Calculated From CamID
      UnknownParcelID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 2, Bit 4 - Unknown Parcel ID
      UndefinedProblem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 2, Bit 5 - Un-Defined Problem
      UnrecognizedCmd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 2, Bit 6 - Un-recognized command
      SorterInMainteneceMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 2, Bit 7 - Sorter in Maintenance/Commissioning Mode
      DestUserSusp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 3, Bit 3 - Destination User Suspended
      SorterNotSynch { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 3, Bit 6 - Sorter NOT Synchronized (Tilt Tray Systems)
      PkgDetAtVerCheckPoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 4, Bit 0 - Package Detected at Verification Check Point
      ChuteFullAftrAlterDest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 4, Bit 7 - Preferred chute full after passed alternate destination
      ChuteNotAvailAfterAlterDest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 5, Bit 0 - Preferred chute not available after passed alternate destination
      PLCRedirected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Byte 5, Bit 2 - PLC Redirected
      ThreatParcel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Threat parcel
   END_STRUCT;

END_TYPE

TYPE "UDT_GINFedEx"
VERSION : 0.1
   STRUCT
      Timestamp : String[17];   // Local time timestamp
      TimeZoneDesignator : String[5];   // Time zone designator
      PackageEntrancePoint : String[14];   // Entrance point, where LLC starts tracking the parcel.
      PackageEntranceState : String[1];   // Entrance state
      PackageExitPoint : String[14];   // Exit point name, where LLC reports the last known tracking point.
      PackageExitState : String[1];   // Exit point state when LLC reports the last known tracking point.
      PalletType : String[2];   // Pallet code for different type of pallets on the market
      Mask : String[1];   // Flag to indicate that a pallet has been mask.
      CellNumber : String[4];   // Tray/Cell number (for loop sorters) or generated by LLC (on line sorters).
      CellsOccupied : String[1];   // Cells occupied by the piece for loop sorters.
      ImageID : String[6];   // Image ID number created by the ADC system.
      ScanUnitType : String[1];   // Scan unit type
      ADCSystemID : String[15];   // Number assigned by the ADC system
      PackageID : String[15];   // Number assigned by the LLC system
      LLCSystemID : String[15];
      HLCPackageID : String[10];   // Unique number for the specific package during it stays in HLC system.
      HLCResultCode : String[16];   // Result code based on processing of the scan event messages.
      ShipmentID : String[6];   // Consignment id of the parcel.
      WeightStatus : String[1];   // Status to indicate if the parcel/pallet has weight on the system.
      ActualDestination : String[6];   // Location code value that describes the actual disposition of the package.
      Destination1 : String[6];   // Location code value that describes where the package should go (Diverter Number).
      Destination2 : String[6];   // Location code value that describes where the package should go (Diverter Number).
      Destination3 : String[6];   // Location code value that describes where the package should go (Diverter Number).
      Destination4 : String[6];   // Location code value that describes where the package should go (Diverter Number).
      Destination5 : String[6];   // Location code value that describes where the package should go (Diverter Number).
      CutOffTimeDestination1 : String[5];   // Cut Off Time in Local Time.
      CutOffTimeDestination2 : String[5];   // Cut Off Time in Local Time.
      CutOffTimeDestination3 : String[5];   // Cut Off Time in Local Time.
      CutOffTimeDestination4 : String[5];   // Cut Off Time in Local Time.
      CutOffTimeDestination5 : String[5];   // Cut Off Time in Local Time.
      ReasonCode1 : String[8];   // Management Code value that describes the result of attempting to route the package to the Destination
      ReasonCode2 : String[8];   // Management Code value that describes the result of attempting to route the package to the Destination
      ReasonCode3 : String[8];   // Management Code value that describes the result of attempting to route the package to the Destination
      ReasonCode4 : String[8];   // Management Code value that describes the result of attempting to route the package to the Destination
      ReasonCode5 : String[8];   // Management Code value that describes the result of attempting to route the package to the Destination
      HLCDataText : String[20];   // Free text for future use.
      Customs : String[1];   // Need to be checked by customs
      DIMSystemID : String[15];   // Identifier of dimensioning system.
      DIMStatus : String[5];   // Basic diagnostic information from the dimensioning system at the moment of the measurement.
      PackageDimLength : String[6];   // Length dimension of package in resolution of dim system.
      PackageDimWidth : String[6];   // Width dimension of package in resolution of dim system.
      PackageDimHeight : String[6];   // Height dimension of package in resolution of dim system.
      DIMUOM : String[2];   // Unit of measure of the package dimensions.
      DimLFTstatusCode : String[8];   // Dimension LFT status code.
      DimConfidence : String[2];   // The level of assurance for the correct dimensions.
      DimensionSource : String[1];   // For combined camera/laser dim acquisition devices. It indicates type of capturing mode
      AlibiDims : String[25];   // Alibi for Dimensions
      SCLSystemID : String[15];   // Identifier of weight scale.
      SCLStatus : String[5];   // Basic diagnostic information from the weight scale system.
      SCLWT : String[6];   // Scale weight of package in resolution of scale system.
      SCLWTUOM : String[2];   // Unit of measurement for Weight
      SCLLFTStatusCode : String[2];   // Scale LFT status code.
      AlibiWeight : String[25];   // Alibi for Weight
      ReasonCode : String[1];   // This code should be used when the SI message has some defect.
      Stackable : String[1];   // If stackable recognition is enabled, Y or N
      Stickerstype : String[2];   // When optical recognition is used to sort
      FlyingDocument : String[1];   // Status to confirm if the document/flyer is prone to fly off the sorter.
      ModeofOperation : String[1];   // Camera Tunnel operational mode format:
      CameraHeadstatus : String[2];   // Diagnostic information on camera/laser heads performing barcode reads.
      PackageDataTruncated : String[1];   // Y = Full length of barcode data exceeds 9999 bytes, data truncated
      TotalBarcodeDataLength : String[4];   // Length of all barcode data that was sent in bytes;
      Barcode1Identification : String[3];   // Barcode identifier code.
      Barcode1status : String[2];   // Barcode confidence factor
      Barcode1datalength : String[4];   // String length of barcode data in bytes; inclusive of this field. Use 0054 as a fixed value
      Barcode1data : String[50];   // Highest priority barcode
      Barcode2Identification : String[3];   // Barcode identifier code.
      Barcode2status : String[2];   // Barcode confidence factor
      Barcode2datalength : String[4];   // String length of barcode data in bytes; inclusive of this field. Use 0054 as a fixed value
      Barcode2data : String[50];   // Highest priority barcode
      Barcode3Identification : String[3];   // Barcode identifier code.
      Barcode3status : String[2];   // Barcode confidence factor
      Barcode3datalength : String[4];   // String length of barcode data in bytes; inclusive of this field. Use 0054 as a fixed value
      Barcode3data : String[50];   // Highest priority barcode
      BarcodeIdentification : String[3];   // Barcode identifier code.
      Barcodestatus : String[2];   // Barcode confidence factor
      Barcodedatalength : String[4];   // String length of barcode data in bytes
      Barcodedata : String[50];   // Sortation barcode
      CustomerID : DInt;   // 6 digits SequentialID (NNNNNN)
      AreaNumber : String[2];   // Package Sequence ID "Area Number"
      PurgeEnabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Purge enabled for parcel: destination overwritten with Purge destination
   END_STRUCT;

END_TYPE

TYPE "UDT_GINStandard"
VERSION : 0.1
   STRUCT
      Destination : Array[0..20] of DInt;   // Destination
      Identification : Struct   // Barcode identification
         GoodRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Barcode read was succesful
         NoRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Barcode read was unsuccesful
         MultiRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Multiple Barcodes were detected
         Barcode : Array[0..10] of Char;   // Barcode values
      END_STRUCT;
      GinAssigned { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // GIN is assigned to package
      Lost { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Lost in tracking
      Length : Int;   // Length in mm
      Width : Int;   // Width in mm
      Height : Int;   // Height in mm
      Weight : DInt;   // Weight in g
      PkgTooLong { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is too long
      PkgTooSmall { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is too small
      PkgTooHigh { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is too high
      PkgOverWeight { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is over weight
      TrailingGap : Int;   // Trailing gap size in cm between the package
      LeadingGap : Int;   // Leading gap size in cm between the package
      NrOfRecirculations : Int;   // Number of recirculations
      DestReqSend { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Destination request sent to high level
      DestRcv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Destination received from high level
      SortStatus : Struct   // Sort status of the package
         DivertDestination : Int;   // Destination to which the package is diverted
         GoodDivert { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package diverted
         FailedDivert { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package failed to divert
         NoDivert : Bool := TRUE;   // Divert is not activated
         NoDivertCause : Struct   // Cause for no divert
            ChuteJam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Chute is jammed
            ChuteFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Chute is full
            NoRTR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Downstream conveyor is not ready to receive
            DestDisabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Destination is disabled
            TrayDisabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Tray is disabled
            SorterNotAtSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sorter is not at speed
            LeadingGapError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Gap size with downstream parcel is not enough
            TrailingGapError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Gap size with upstream parcel is not enough
            PkgTooHigh { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is too high to divert
            PkgTooLong { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Package is too long to divert
            DestNotReachable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sort destionation is not reachable
            InvalidDest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sort destination is invalid
            DestTooLate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Destination too late
            NoDestRcv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Destination not received from high level
         END_STRUCT;
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_CommonStatus"
TITLE = UDT_CommonStatus
VERSION : 0.1
//User-defined structure of common statuses.
   STRUCT
      SafetyStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Emergancy stop
      Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // An error is active
      Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // A warning is active
      ManualRun { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Running in manual mode
      Manual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // In manual mode
      Halted { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Halted
      Dieback { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // In dieback
      Stopped { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stopped
      Running { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Running
      EnergySave { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // In energy saving mode
      AutoON { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Automatic started
   END_STRUCT;

END_TYPE

TYPE "UDT_FifoStatus"
TITLE = UDT_FifoStatus
VERSION : 0.1
//
//User-defined structure of FC_Fifo function status.
//Version History:
//Date              | Version   | Author         | Remark
//24/05/2019  | 0.1           | K.Pokorski   | first release MHSE TIA 15.1
//24/05/2019  | 0.2           | K.Pokorski   | first release MHSE TIA 15.1
//
   STRUCT
      InvalidMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid mode selected
      InvalidMaxNrOfEntries { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid maximum number of entries or buffer is not an array
      InvalidTotalEntriesStored { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid total number of entries
      InvalidNextEntryToWrite { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid number of next entry to write
      InvalidNextEntryToRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid number of next entry to read
      InvalidDataType { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message and buffer element data type inconsistent
      FifoPreFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 90 % of FIFO data buffer capacity reached
      FifoFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO data buffer full
   END_STRUCT;

END_TYPE

DATA_BLOCK "DB_Memory"
TITLE = DB_Memory
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
VERSION : 3.0
NON_RETAIN
   VAR 
      ClockByte { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // System clock byte
      Clock_10Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 10 Hz system clock bit
      Clock_5Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 5 Hz system clock bit
      "Clock_2.5Hz" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 2.5 Hz system clock bit
      Clock_2Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 2 Hz system clock bit
      "Clock_1.25Hz" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1.25 Hz system clock bit
      Clock_1Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 1 Hz system clock bit
      "Clock_0.625Hz" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0.625 Hz system clock bit
      "Clock_0.5Hz" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0.5 Hz system clock bit
      SystemByte { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // System byte
      OSClockByte { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // One shot of clock pulse
      "OS_0.1sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 0.1 sec
      "OS_0.2sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 0.2 sec
      "OS_0.4sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 0.4 sec
      "OS_0.5sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 0.5 sec
      "OS_0.8sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 0.8 sec
      OS_1sec { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 1 sec
      "OS_1.6sec" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 1.6 sec
      OS_2sec { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One shot every 2 sec
      PrevCycleTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Previous PLC cycle Time
      RuntimeMem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Runtime memory
      FirstScan { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // First scan bit
      DiagStatusUpdate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Diagnostic status update
      AlwaysTrue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Always True bit
      AlwaysFalse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Always False bit
      CommissioningFalse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Commissioning always false
      CommissioningTrue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Commissioning always true
      ReconnectCommand { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reconnect command
      ScanMainRack { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Trigger to check main rack confiuration
      ScanProfinet { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Scan profinet bit
      Simulation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Simulation
      PN1OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet ok
      "Local~PROFINET_IO-System" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IO System
      "Local~PROFINET_IO-System_1" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 1
      "Local~PROFINET_IO-System_2" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 2
      "Local~PROFINET_IO-System_3" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 3
      "Local~PROFINET_IO-System_4" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 4
      "Local~PROFINET_IO-System_5" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 5
      "Local~PROFINET_IO-System_6" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 6
      "Local~PROFINET_IO-System_7" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 7
      "Local~PROFINET_IO-System_8" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 8
      "Local~PROFINET_IO-System_9" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   // HW Intentifier of PN-IOSystem 9
   END_VAR


BEGIN

END_DATA_BLOCK

TYPE "UDT_GIN"
VERSION : 0.1
   STRUCT
      General { S7_SetPoint := 'False'} : "UDT_GINStandard";
      FedEx { S7_SetPoint := 'False'} : "UDT_GINFedEx";
      UPS { S7_SetPoint := 'False'} : "UDT_GINUPS";
      DHL { S7_SetPoint := 'False'} : "UDT_GINDHL";
      WCS { S7_SetPoint := 'False'} : "UDT_GINWCS";
      WES { S7_SetPoint := 'False'} : "UDT_GINWES";
   END_STRUCT;

END_TYPE

DATA_BLOCK "DB_ProfinetDiagnostic"
TITLE = DB_ProfinetDiagnostic
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
NON_RETAIN
//Data block to store profinet network diagnostic data.
   VAR 
      ProfinetNetworks { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Array[1..10] of "UDT_ProfinetNetwork";
   END_VAR


BEGIN

END_DATA_BLOCK

TYPE "UDT_EventStatistic"
TITLE = UDT_EventStatistic
VERSION : 0.1
//User-defined structure of event statistic data.
   STRUCT
      NumberOfTimes : DInt;   // Number of times the event occurred since last reset
      LastEventSeconds : DInt;   // Number of seconds of the current or last event
      TotalEventSeconds : DInt;   // Total number of seconds the event occurred since last reset
   END_STRUCT;

END_TYPE

TYPE "UDT_FifoHeader"
TITLE = UDT_FifoHeader
VERSION : 0.1
//User-defined structure of FIFO register header information.
   STRUCT
      Status : Struct   // Status bits
         Empty { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO Empty
         Prefull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO Prefull
         Full { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FIFO Full
      END_STRUCT;
      NextEntryToRead : Int;   // Next FIFO entry to read
      NextEntryToWrite : Int;   // Next FIFO entry to write
      MaxNrOfEntries : Int;   // Maximum number of FIFO entries
      TotalEntriesStored : Int;   // Total number of FIFO entries
   END_STRUCT;

END_TYPE

FUNCTION "FC_GetNrOfArrayEl" : Int
TITLE = FC_GetNrOfArrayEl
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 19
// END_ATTRIBUTES
//Function to get the number of array elements.
   VAR_INPUT 
      iv_Array : Variant;   // Input array
   END_VAR

   VAR_TEMP 
      ti_NrOfArrayEl : Int;   // Number of array elements
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	27/08/2019  | 2.1       | K.Pokorski    | Comments adjusted
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – Number of an array elements
	    
	    IF IS_ARRAY(#iv_Array)                                                  // Input variable is an array
	    THEN
	        
	        #ti_NrOfArrayEl := UDINT_TO_INT(CountOfElements(#iv_Array));
	        
	        // Reset array length if the input variable isn't an array
	    ELSE
	        
	        #ti_NrOfArrayEl := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 – Return output
	    
	    #FC_GetNrOfArrayEl := #ti_NrOfArrayEl;
	    
	END_REGION
	
END_FUNCTION

TYPE "UDT_PNDevice"
VERSION : 0.1
   STRUCT
      PNNetworknumber : Int := 1;   // Number of the profinet network where device exist
      PNDeviceNumber : Int := 0;   // Profinet number of the device
      PNDeviceFound { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Device found in Profinet structure
   END_STRUCT;

END_TYPE

TYPE "UDT_VfdStatistics"
TITLE = UDT_VFDStatistics_SEW
VERSION : 0.1
//User-defined structure of FB_VFD_SEW_MOVI-C function block statistics.
   STRUCT
      PNSlaveNotOnline : "UDT_EventStatistic";   // Statistics of Profinet slave not online
      PNSlaveError : "UDT_EventStatistic";   // Statistics of a Profinet slave error
      VFDInternalError : "UDT_EventStatistic";   // Statistics of an internal VFD error
      CommunicationErrorMovikit : "UDT_EventStatistic";   // Statistics of a communication error
      Running : "UDT_EventStatistic";   // Statistics for running time
   END_STRUCT;

END_TYPE

TYPE "UDT_Sorter_DownStream_Basic"
VERSION : 0.1
   STRUCT
      ChuteFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ChuteHalfFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ChuteSensorIncongruence { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ChuteDisabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ChuteJam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ChuteFullSensor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ChuteHalfFullSensor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ChuteJamSensor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_STRUCT;

END_TYPE

TYPE "UDT_ConveyorInterface"
TITLE = UDT_ConveyorInterface
VERSION : 0.1
//User-defined structure of conveyor interface variables.
   STRUCT
      Displacement : Int;   // Displacement per PLC scan [cm] either from position (if available) or speed and time
      SpeedSetpoint : Int;   // Conveyor speed setpoint [mm/s]
      ActualSpeed : Int;   // Conveyors actual speed [mm/s]
      DeltaPosition : Int;   // Read from Conveyor Servo Position [mm] after 1 PLC cycle
      RunFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Run forward request
      RunRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Run reverse request
      InternalErrorEncoder { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Encoder has an error
      InternalErrorVFD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // VFD has an error
      InternalErrorTracking { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Tracking has an error
      InternalErrorPEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PEC has an error
      InternalWarningVFD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // VFD has a warning
      InternalWarningTracking { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Tracking has a warning
      InternalErrorReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset internal errors
      ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Configuration error is active
      VFDRunning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor is running
      VFDatSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Motor at speed setpoint
      Disconnected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // VFD disconnected
      ManualModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Covneyor is in manual mode
      ResetStatistics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset statistics
      HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Hardware for the Equipment is available and healthy
   END_STRUCT;

END_TYPE

TYPE "UDT_SerialComConfiguration"
VERSION : 0.1
   STRUCT
      Port : UInt;   // "HW identifier" from the serial communication module
      ResponseTime : LTime := LT#0NS;   // Time when Xray should send Decision message [ms]
      SendMessageLength : UInt;   // Length of the message frame send in bytes
      ReceiveMessageLength : UInt;   // Length of the message frame receive in bytes
      GINRangeStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // GIN range start value
      GINRangeEnd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // GIN range end value
   END_STRUCT;

END_TYPE

FUNCTION "FC_GetDevicePN" : Void
TITLE = FC_GetDevicePN
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 18
// END_ATTRIBUTES
   VAR_INPUT 
      is_PNDeviceName : String;   // Name of the device
      ix_SimulationModeActive : Bool;   // True = Simulation mode active
   END_VAR

   VAR_IN_OUT 
      iqUDT_PND : "UDT_PNDevice";   // Device found in Profinet structure
   END_VAR

   VAR_TEMP 
      ti_NrOfConfiguredPNNetworks : Int;   // Number of networks configured in project
      ti_NrOfDevices : Int;   // Nr of devices is networks
      ti_LcPNNetworkNumber : Int;   // Loop counter to find PN network number
      ti_LcPNDeviceNumber : Int;   // Loop counter to find PN device number
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	16/09/2019  | 2.3       | F.Baten       | Cut out of 'FB_RIO'
	29/09/2019  | 2.4       | K.Pokorski    | Network seach started from 1 instead 0
	30/09/2019  | 2.5       | K.Pokorski    | Chagne prefixes of temporary varaibles from 'si' to 'ti'
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Get Device Profinet number
	    // if simulation is disabled 
	    IF NOT #ix_SimulationModeActive
	    THEN
	        // And the profinet device is not found yet
	        IF (#is_PNDeviceName <> "DB_ProfinetDiagnostic".ProfinetNetworks[#iqUDT_PND.PNNetworknumber].DeviceStatus[#iqUDT_PND.PNDeviceNumber].DeviceState.PNDeviceName)
	            OR #iqUDT_PND.PNDeviceFound = FALSE
	        THEN
	            #iqUDT_PND.PNDeviceFound := FALSE;
	            
	            // check how many profinet networks are configured
	            #ti_NrOfConfiguredPNNetworks := "FC_GetNrOfArrayEl"("DB_ProfinetDiagnostic".ProfinetNetworks);
	            
	            FOR #ti_LcPNNetworkNumber := 1 TO (#ti_NrOfConfiguredPNNetworks) DO
	                
	                #iqUDT_PND.PNNetworknumber := #ti_LcPNNetworkNumber;
	                
	                // and check how many devices are configured per network
	                #ti_NrOfDevices := "FC_GetNrOfArrayEl"("DB_ProfinetDiagnostic".ProfinetNetworks[#iqUDT_PND.PNNetworknumber].DeviceStatus);
	                
	                // check for each of the devices in the networks if the PN device name is similair to the configured device name
	                FOR #ti_LcPNDeviceNumber := 0 TO (#ti_NrOfDevices - 1) DO
	                    
	                    #iqUDT_PND.PNDeviceNumber := #ti_LcPNDeviceNumber;
	                    
	                    // set device found when a match is found for the device name in the PN network
	                    IF (#is_PNDeviceName = "DB_ProfinetDiagnostic".ProfinetNetworks[#iqUDT_PND.PNNetworknumber].DeviceStatus[#iqUDT_PND.PNDeviceNumber].DeviceState.PNDeviceName
	                        AND #is_PNDeviceName <> '')
	                    THEN
	                        
	                        #iqUDT_PND.PNDeviceFound := TRUE;
	                        EXIT;
	                        
	                    END_IF;
	                END_FOR;
	                
	                // exit loop when device name is matching
	                IF #iqUDT_PND.PNDeviceFound
	                THEN
	                    
	                    EXIT;
	                    
	                END_IF;
	            END_FOR;
	        END_IF;
	    END_IF;
	    
	END_REGION
END_FUNCTION

FUNCTION "FC_Statistics" : Void
TITLE = FC_Statistics
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 26
// END_ATTRIBUTES
//Function to calculate statistics.
   VAR_INPUT 
      ix_Reset : Bool;   // Reset statistics data
      ix_Activate : Bool;   // Activete statistics counters
      ix_RTrigActivate : Bool;   // Activation rise trigger
   END_VAR

   VAR_IN_OUT 
      iqUDT_Statistics : "UDT_EventStatistic";   // Statistic structure
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | C. Leite      | first release MHS TIA 15.1
	17/07/2019  | 0.2       | A.Nowak       | Add comments
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	27/08/2019  | 2.1       | M.Kurpiers    | Comments adjusted
	04/11/2019  | 2.2       | L.Klar        | 1 second pulse changed from memory bit to DB variable
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Number of events
	    
	    IF (#ix_RTrigActivate)      // Event occured                                
	    THEN
	        
	        // Increment the number of times the event occurred and clear the time of the current or last event
	        #iqUDT_Statistics.NumberOfTimes += 1;
	        #iqUDT_Statistics.LastEventSeconds := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Event time
	    
	    // 1 shot every 1 sec and activate statistic counter 
	    IF ("DB_Memory".OS_1sec AND #ix_Activate)
	    THEN
	        
	        // Increment the time of the current or last event and the time of all events that occured
	        #iqUDT_Statistics.LastEventSeconds += 1;
	        #iqUDT_Statistics.TotalEventSeconds += 1;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Data reset
	    
	    
	    IF (#ix_Reset)                                            // Reset statistics data                                          
	    THEN
	        
	        IF (NOT #ix_Activate)                                 // Statistic counter isn't activate                                
	        THEN
	            
	            // Clear statistics data
	            #iqUDT_Statistics.NumberOfTimes := 0;
	            #iqUDT_Statistics.LastEventSeconds := 0;
	            #iqUDT_Statistics.TotalEventSeconds := 0;
	            
	        ELSE
	            
	            // Write 1 to the number of times the event occurred and clear times  
	            #iqUDT_Statistics.NumberOfTimes := 1;
	            #iqUDT_Statistics.LastEventSeconds := 0;
	            #iqUDT_Statistics.TotalEventSeconds := 0;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
END_FUNCTION

TYPE "UDT_ConveyorCommonConfiguration"
VERSION : 0.1
   STRUCT
      Length : DInt;   // Conveyor length [mm]
      LengthCorrection : DInt;   // Length correction [mm]
   END_STRUCT;

END_TYPE

TYPE "UDT_VfdStatus"
TITLE = UDT_VfdStatus
VERSION : 0.1
//User-defined structure of VFD status.
   STRUCT
      ErrorCode : Int;   // Error code
      SubErrorCode : Int;   // Sub error code
      PNSlaveNotonline : Bool := FALSE;   // Profinet slave is not on line
      PNSlaveError : Bool := FALSE;   // Profinet slave has an error
      InternalError : Bool := FALSE;   // A VFD internal error is active, see error code
      InternalWarning : Bool := FALSE;   // A VFD internal warning is active, see error code
      CommunicationErrorMovikit : Bool := FALSE;   // Communication error with MoviKit
      VFDRunningFeedbackError : Bool := FALSE;   // Motor is not running
      PNSlaveWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Profinet slave has a warning
   END_STRUCT;

END_TYPE

TYPE "UDT_VFD_MultiControl_PI"
VERSION : 0.1
   STRUCT
      ErrorMotor1 : Bool;   // High = motor error, Low = motor OK
      ErrorMotor2 : Bool := FALSE;   // High = motor error, Low = motor OK
      ErrorMotor3 : Bool := FALSE;   // High = motor error, Low = motor OK
      ErrorMotor4 : Bool := FALSE;   // High = motor error, Low = motor OK
      Reserve5 : Bool;   // Not used
      Reserve6 : Bool := FALSE;   // Not used
      Reserve7 : Bool := FALSE;   // Not used
      Reserve8 : Bool := FALSE;   // Not used
      SpeedMotor1 : SInt;   // Speed 0...100 (0 = stop, 100 = max speed ), negative values indicate reversed direction of rotation
      SpeedMotor2 : SInt;   // Speed 0...100 (0 = stop, 100 = max speed ), negative values indicate reversed direction of rotation
      SpeedMotor3 : SInt;   // Speed 0...100 (0 = stop, 100 = max speed ), negative values indicate reversed direction of rotation
      SpeedMotor4 : SInt;   // Speed 0...100 (0 = stop, 100 = max speed ), negative values indicate reversed direction of rotation
      Reserve10 : Bool := FALSE;   // Not used
      CurrentMotor1 : UInt;   // Average current in mA
      CurrentMotor2 : UInt;   // Average current in mA
      CurrentMotor3 : UInt;   // Average current in mA
      CurrentMotor4 : UInt;   // Average current in mA
      MotorVoltage : UInt;   // Voltage “Motor Power” in mV
      LogicVoltage : UInt;   // Voltage “Power Logic + Sensors” in mV
   END_STRUCT;

END_TYPE

TYPE "UDT_EquipmentControl"
TITLE = UDT_EquipmentControl
VERSION : 0.1
//User-defined structure of equipment control commands.
   STRUCT
      Command : Struct   // Control command
         Start { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start conveyor
         Stop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stop conveyor
         Reset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Faults reset
         ResetData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Statistics reset
         ManualMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual mode required
         DisableManualMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disable manual mode
         AutomaticOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // System is started in automatic mode
         StopRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      END_STRUCT;
      Report { S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Conveyors state
      Request : Struct   // Request from equipment
         RestartRequired { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Restart required from system control
         SignalingRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Beeper required
         InhibitStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      END_STRUCT;
   END_STRUCT;

END_TYPE

DATA_BLOCK "DB_HMIStatusConfiguration"
TITLE = DB_HMIStatusConfiguration
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
VERSION : 3.0
NON_RETAIN
   VAR 
      FireAlarm : Int;   // Fire alarm active
      SafetyStop : Int;   // Safety stop error status
      Error : Int;   // Error status
      Warning : Int;   // Warning status
      ManualRun : Int;   // Manual run status
      Manual : Int;   // Manual status
      Halted : Int;   // Halted status
      Dieback : Int;   // Die back status
      Stopped : Int;   // Stopped status
      Running : Int;   // Running status
      EnergySave : Int;   // Energy save status
      CommunicationError : Int;   // Communication error status
      CBError : Int;   // CB error status
      ProfinetError : Int;   // Profinet error status
      HardwareError : Int;   // Hardware error status
      VFDNotHealthy : Int;   // VFD noth healthy status
      VFDError : Int;   // VFD error status
      PECJam : Int;   // PEC jam status
      ChuteFull : Int;   // Chute full status
      EncoderError : Int;   // Encoder error status
      TrackingError : Int;   // Tracking error status
      DimensionError : Int;   // Dimension error status
      OperationalError : Int;   // Operational error status
      AutoON : Int;   // Automatic is on
      ChuteHalfFull : Int;   // Disable by operator
      DisableByManagement : Int;   // Disable by management
      GateOpen : Int;   // Manual operated gate is open
      GateClosed : Int;   // Manual operated gate is closed
      GateClosedAndNoOperatorPresent : Int;   // Manual operated gate is closed and no operator is present
      PositionChangeOngoing : Int;   // Lifting device or arm diverter changing position
      BufferMode : Int;   // BufferMode Active
      ContinuousMode : Int;   // ContinuousMode Active
      LabbelingMode : Int;   // LabbelingMode Active
   END_VAR


BEGIN
   FireAlarm := 1;
   SafetyStop := 3;
   Error := 5;
   Warning := 7;
   ManualRun := 9;
   Manual := 11;
   Halted := 13;
   Dieback := 15;
   Stopped := 17;
   Running := 19;
   EnergySave := 21;
   CommunicationError := 23;
   CBError := 25;
   ProfinetError := 27;
   HardwareError := 29;
   VFDNotHealthy := 31;
   VFDError := 33;
   PECJam := 35;
   ChuteFull := 37;
   EncoderError := 39;
   TrackingError := 41;
   DimensionError := 43;
   OperationalError := 45;
   AutoON := 47;
   ChuteHalfFull := 49;
   DisableByManagement := 51;
   GateOpen := 53;
   GateClosed := 55;
   GateClosedAndNoOperatorPresent := 57;
   PositionChangeOngoing := 59;
   BufferMode := 61;
   ContinuousMode := 63;
   LabbelingMode := 65;

END_DATA_BLOCK

FUNCTION_BLOCK "FB_TimerOnOffDelay"
TITLE = FB_TimerOnOffDelay
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 32
// END_ATTRIBUTES
//Function block to generate on/off signal delay.
   VAR_INPUT 
      iudi_OnDelayTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // On delay time [ms]
      iudi_OffDelayTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Off delay time [ms]
      ix_SignalToDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Input signal to be delayed
      ix_Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;   // Timer Enable
   END_VAR

   VAR_OUTPUT 
      qlr_ActualTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Actual time
      qx_DelayedSignal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Delayed signal output
   END_VAR

   VAR 
      s_R_TRIG_Signal {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Siemens "R_Trig" - to prepare the rising edge trigger on "ix_SignalToDelay" signal
      s_F_TRIG_Signal {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Siemens "F_Trig" - to prepare the falling edge trigger on "ix_SignalToDelay" signal
   END_VAR
   VAR RETAIN
      slr_ActualDelayTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Actual delay time [ms]
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	26/08/2019  | 2.1       | M.Kurpiers    | Comments adjusted
	04/11/2019  | 2.2       | L.Klar        | Prevoius cycle scan changed from memory to DB variable
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION Step 1 – Input signal edge detection 
	    
	    #s_R_TRIG_Signal(CLK := #ix_SignalToDelay);
	    
	    
	    #s_F_TRIG_Signal(CLK := #ix_SignalToDelay);
	    
	END_REGION
	
	REGION Step 2 – Actual delay time initialization
	    
	    IF (#s_R_TRIG_Signal.Q OR #s_F_TRIG_Signal.Q)           // Input signal changed        
	    THEN
	        
	        #slr_ActualDelayTime := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION Step 3 – On/Off delay time calculation
	    
	    
	    IF (#ix_SignalToDelay                                       // Signal to be delayed is active
	        AND #ix_Enable)                                         // Ttimer enabled                   
	    THEN
	        
	        // Timer on
	        IF (#slr_ActualDelayTime >= #iudi_OnDelayTime)
	        THEN
	            
	            #qx_DelayedSignal := TRUE;
	            
	        ELSE
	            
	            #slr_ActualDelayTime += "DB_Memory".PrevCycleTime;
	            
	        END_IF;
	        
	    END_IF;
	    
	    // Timer off
	    IF (NOT #ix_SignalToDelay                                   // Signal to delay is not active
	        AND #ix_Enable)                                         // Timer is enabled                  
	    THEN
	        
	        IF (#slr_ActualDelayTime >= #iudi_OffDelayTime)
	        THEN
	            
	            #qx_DelayedSignal := FALSE;
	            
	        ELSE
	            
	            #slr_ActualDelayTime += "DB_Memory".PrevCycleTime;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION Step 4 – Actual time
	    
	    #qlr_ActualTime := #slr_ActualDelayTime;
	    
	END_REGION
END_FUNCTION_BLOCK

TYPE "UDT_ConnectStatus"
VERSION : 0.1
   STRUCT
      Status : Int;   // Status number
      Specific : Struct   // Specific status structure
         Connected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Connected
         CommunicationFault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Communication fault
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_VFD_MultiControl_Configuration"
TITLE = UDT_VFD_Configuration
VERSION : 0.1
//User-defined structure oparameters.
   STRUCT
      MaximumSpeed : Real;   // Maximum speed [mm/s]
      VFDRampUpTime : UDInt;   // VFD ramp up time for monitoring starting [ms]
      VFDRampDownTime : UDInt;   // VFD ramp up time for monitoring stopping [ms]
      SpeedSetpointWindow : Int := 5;   // VFD speed setpoint window (tolerance) [mm/s]
      VFDPNDeviceName : String;   // VFD's Profinet device name
      CorrectionFactor : Real := 1.0;   // Motor factor to correct diagonal mounting (1.0 = straight, standard)
      DirectionReversal : Bool;   // If true, direction will be swapped
      InterlockFwd : Bool;   // False when turning in forward direction is not possible / allowed
      InterlockRvs : Bool;   // False when turning in reverse direction is not possible / allowed
      MinimumCurrentWhenRunninng : UInt;   // Minimum current from motor when it is running. This setting is used to detect that motor is not running when PLC is sending start command
      AutoReset : Bool;
      TimePNErrorMasking : UDInt := 30000;   // Time how long the PN error will be masked, active if AutoReset is True.
   END_STRUCT;

END_TYPE

FUNCTION "FC_StringToTime" : Void
TITLE = FC_StringToTime
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 27
// END_ATTRIBUTES
//Function to convert date in string format to the DTL.
   VAR_INPUT 
      is_StringTime : String;   // Input string with date
   END_VAR

   VAR_OUTPUT 
      qt_Date {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;   // Output Date in DTL
   END_VAR

   VAR_TEMP 
      ts_DateInt : Struct   // Temp partial date in integer
         Year : UInt;
         Month : USInt;
         Day : USInt;
         Hour : USInt;
         Minute : USInt;
         Second : USInt;
         Millisecond : UDInt;
      END_STRUCT;
      ts_DateString : Struct   // Temp partial date in string
         Hour : String[2];
         Minute : String[2];
         Second : String[2];
         Millisecond : String[3];
      END_STRUCT;
   END_VAR

   VAR CONSTANT 
      ci_StringLength2 : Int := 2;   // Length of the part of the string
      ci_StringLength3 : Int := 3;   // Length of the part of the string
      ci_StringPosition1 : Int := 1;   // Position of the first caracter inside the string
      ci_StringPosition4 : Int := 4;   // Position of the first caracter inside the string
      ci_StringPosition7 : Int := 7;   // Position of the first caracter inside the string
      ci_StringPosition10 : Int := 10;   // Position of the first caracter inside the string
      cw_FormatZero : Word := 0;   // Simple value format
      Ci_Year : UInt := 1970;   // Fixed year 1970, start value dtl
      ci_Month : USInt := 1;   // Fixed month 1, start value dtl
      ci_Day : USInt := 1;   // Fixed day 1, start value dtl
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | K.Pokorski    | first release MHS TIA 15.1
	26/06/2019  | 0.2       | M.Kurpiers    | Change in region 1 P:=3 -> P:=4
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	26/07/2019  | 2.1       | M.Kurpiers    | Comments adjusted
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	16/02/2023  | 3.1       | F.Baten       | Added constants
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Separation different part of the date 
	    
	    // Separation different part of the date from the data string and saving it to the structure
	    #ts_DateString.Hour := MID(IN := #is_StringTime,
	                               L := #ci_StringLength2,
	                               P := #ci_StringPosition1);               // Separating an hour from the date string  
	    #ts_DateString.Minute := MID(IN := #is_StringTime,
	                                 L := #ci_StringLength2,
	                                 P := #ci_StringPosition4);             // Separating a minute from the date string 
	    #ts_DateString.Second := MID(IN := #is_StringTime,
	                                 L := #ci_StringLength2,
	                                 P := #ci_StringPosition7);             // Separating a second from the date string 
	    #ts_DateString.Millisecond := MID(IN := #is_StringTime,
	                                      L := #ci_StringLength3,
	                                      P := #ci_StringPosition10);       // Separating a millisecond from the date string 
	    
	END_REGION
	
	REGION 2 - Conversion string to integer
	    
	    STRG_VAL(IN := #ts_DateString.Hour,                         // Conversion a hour from string 
	             FORMAT := #cw_FormatZero,                          // Simple value format
	             P := INT_TO_UINT(#ci_StringPosition1),             // First position in string
	             OUT => #ts_DateInt.Hour);                          // Integer temporary variable
	    // Conversion a minute from string 
	    STRG_VAL(IN := #ts_DateString.Minute,
	             FORMAT := #cw_FormatZero,
	             P := INT_TO_UINT(#ci_StringPosition1),
	             OUT => #ts_DateInt.Minute);
	    // Conversion a second from string 
	    STRG_VAL(IN := #ts_DateString.Second,
	             FORMAT := #cw_FormatZero,
	             P := INT_TO_UINT(#ci_StringPosition1),
	             OUT => #ts_DateInt.Second);
	    // Conversion a milisecond from string
	    STRG_VAL(IN := #ts_DateString.Millisecond,
	             FORMAT := #cw_FormatZero,
	             P := INT_TO_UINT(#ci_StringPosition1),
	             OUT => #ts_DateInt.Millisecond);
	    
	END_REGION
	
	REGION 3 - Combine integer to "DTL" data type and setting output
	    
	    // Move parts of the date to the DTL output structure 
	    #qt_Date.YEAR := #Ci_Year;
	    #qt_Date.MONTH := #ci_Month;
	    #qt_Date.DAY := #ci_Day;
	    #qt_Date.HOUR := #ts_DateInt.Hour;
	    #qt_Date.MINUTE := #ts_DateInt.Minute;
	    #qt_Date.SECOND := #ts_DateInt.Second;
	    #qt_Date.NANOSECOND := #ts_DateInt.Millisecond * 1000000;
	    
	END_REGION
END_FUNCTION

TYPE "UDT_MessageV2"
TITLE = UDT_Message
VERSION : 0.1
//User-defined structure of the message characters array.
   STRUCT
      Bytes : Array[0..499] of Byte;   // Message byte
   END_STRUCT;

END_TYPE

DATA_BLOCK "DB_GIN"
TITLE = DB_GIN
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
NON_RETAIN
//Data block to store parcels informations.
   VAR 
      GIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Array[1..1] of "UDT_GIN";   // GIN informations - for project remove unneeded customers and extend array bound range to 9999
   END_VAR


BEGIN

END_DATA_BLOCK

TYPE "UDT_MFCSortMessageHeader"
VERSION : 0.1
   STRUCT
      SOM : Byte := 16#FD;   // Start of message
      SourceNode : Byte;   // Source node ID
      DestinationNode : Byte;   // Destination node ID
      SeqNumber : Byte;   // Sequence number
      DataLength : Word;   // Data segment length (bytes)
      NumMsg : Word;   // Number of messages contained in the Data Segment
   END_STRUCT;

END_TYPE

FUNCTION "FC_Fifo" : Void
TITLE = FC_Fifo
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 17
// END_ATTRIBUTES
//Function for controlling FIFO register.
   VAR_INPUT 
      ic_Mode : Char;   // Mode selector: "W" - Write; "R" - Read; "C" - Clear (Reset) "S" - Status
   END_VAR

   VAR_OUTPUT 
      qUDT_Status : "UDT_FifoStatus";   // FIFO status structure
      qx_Error : Bool;   // Collective error output
      qx_Warning : Bool;   // Collective warning output
   END_VAR

   VAR_IN_OUT 
      iqv_Data : Variant;   // Data
      iqUDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqv_DataBuffer : Variant;   // FIFO data buffer
   END_VAR

   VAR_TEMP 
      tUDT_Status : "UDT_FifoStatus";   // Status structure
      ti_MoveBLKErrorCode : Int;   // Move_BLK_Variant function return
      tx_HeaderValid : Bool;   // Header valid
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | L.Klar        | first release MHS TIA 15.1
	14/06/2019  | 0.2       | A.Nowak       | Replacement of instruction if for direct write into variable - Region 3 , 4.1 , 4.2 , 4.3 , 4.4 , 8.1  , 8.2 
	17/07/2019  | 0.3       | L.Klar        | Status handling changed
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	23/08/2019  | 2.1       | K.Pokorski    | Comments corrected
	27/08/2019  | 2.2       | M.Kurpiers    | Comments adjusted
	27/09/2019  | 2.3       | K.Pokorski    | Variant input included
	01/10/2019  | 2.4       | A.Nowak       | Correct comments and rename regions
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 – Diagnostic bits initialization
	    
	    // Clear FIFO statuses
	    #tUDT_Status.FifoFull := FALSE;
	    #tUDT_Status.FifoPreFull := FALSE;
	    
	END_REGION
	
	REGION 2 – Array's information
	    
	    // If buffer elements type is invalid, set the error 
	    #tUDT_Status.InvalidDataType := NOT (TypeOf(#iqv_Data) = TypeOfElements(#iqv_DataBuffer));
	    
	END_REGION
	
	REGION 3 – Mode validation
	    
	    // Set the mode invalid if selected mode isn't one of the following: W- Write, R - Read, C - Clear, S - Status
	    #tUDT_Status.InvalidMode := #ic_Mode <> 'W'
	    AND #ic_Mode <> 'R'
	    AND #ic_Mode <> 'C'
	    AND #ic_Mode <> 'S';
	    
	END_REGION
	
	REGION 4 – The header settings checking
	    
	    // The correct mode has been selected and data type is valid
	    IF (NOT #tUDT_Status.InvalidMode
	        AND NOT #tUDT_Status.InvalidDataType)
	    THEN
	        
	        REGION 4.1 – The number of maximum FIFO entries validation 
	            
	            // Write the number of array's elements to FIFO header
	            #iqUDT_FifoHeader.MaxNrOfEntries := "FC_GetNrOfArrayEl"(#iqv_DataBuffer);
	            
	            // Set the invalid maximum number of entries error 
	            #tUDT_Status.InvalidMaxNrOfEntries := #iqUDT_FifoHeader.MaxNrOfEntries <= 0;
	            
	        END_REGION
	        
	        REGION 4.2 – The number of total FIFO entries validation
	            
	            // Set the invalid total number of entries error 
	            #tUDT_Status.InvalidTotalEntriesStored := #iqUDT_FifoHeader.TotalEntriesStored < 0        // The total number of entries is lower than 0
	            OR #iqUDT_FifoHeader.TotalEntriesStored > #iqUDT_FifoHeader.MaxNrOfEntries;               // The total number of entries is greater than the maximum number of entries
	            
	        END_REGION
	        
	        REGION 4.3 – The number of the next entry to write 
	            
	            // Set the invalid next entry to write
	            #tUDT_Status.InvalidNextEntryToWrite := #iqUDT_FifoHeader.NextEntryToWrite < 0            // The number of next entry to write is lower than 0  
	            OR #iqUDT_FifoHeader.NextEntryToWrite >= #iqUDT_FifoHeader.MaxNrOfEntries;                // The number of next entry to write is greater or equal to the maximum number of entries 
	            
	        END_REGION
	        
	        REGION 4.4 – The number of the next entry to read 
	            
	            // Set the invalid next entry to read
	            #tUDT_Status.InvalidNextEntryToRead := #iqUDT_FifoHeader.NextEntryToRead < 0              // The number of next entry to read is lower than 0 
	            OR #iqUDT_FifoHeader.NextEntryToRead >= #iqUDT_FifoHeader.MaxNrOfEntries;                 // The number of next entry to read is greater or equal to the maximum nr of entries 
	            
	        END_REGION
	        
	        REGION 4.5 – FIFO header validation summary
	            
	            // Create collective header error
	            #tx_HeaderValid := NOT #tUDT_Status.InvalidMaxNrOfEntries
	            AND NOT #tUDT_Status.InvalidTotalEntriesStored
	            AND NOT #tUDT_Status.InvalidNextEntryToWrite
	            AND NOT #tUDT_Status.InvalidNextEntryToRead;
	            
	        END_REGION
	        
	    END_IF;
	    
	END_REGION
	
	REGION 5 – Writing the data into the FIFO buffer
	    
	    IF (#ic_Mode = 'W'                                                                          // Write mode selected                                                               
	        AND #tx_HeaderValid                                                                     // FIFO header valid 
	        AND NOT #tUDT_Status.InvalidDataType)                                                  // Buffer data type valid
	    THEN
	        
	        
	        IF (#iqUDT_FifoHeader.TotalEntriesStored < #iqUDT_FifoHeader.MaxNrOfEntries)          // Checking total number of stored entries                
	        THEN
	            
	            // Move input data to FIFO data buffer  
	            #ti_MoveBLKErrorCode := MOVE_BLK_VARIANT(SRC := #iqv_Data,
	                                                     COUNT := 1,
	                                                     SRC_INDEX := 0,
	                                                     DEST_INDEX := #iqUDT_FifoHeader.NextEntryToWrite,
	                                                     DEST => #iqv_DataBuffer);
	            
	            // Increment the number of the next entry to write 
	            #iqUDT_FifoHeader.NextEntryToWrite += 1;
	            
	            // Increment the total number of stored entries 
	            #iqUDT_FifoHeader.TotalEntriesStored += 1;
	            
	            
	            IF (#iqUDT_FifoHeader.NextEntryToWrite >= #iqUDT_FifoHeader.MaxNrOfEntries)       // Check the number of the next entry to write                             
	            THEN
	                
	                #iqUDT_FifoHeader.NextEntryToWrite := 0;
	                
	            END_IF;
	            
	        ELSE
	            
	            #tUDT_Status.FifoFull := TRUE;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 6 – Reading the data from the FIFO data buffer
	    
	    IF (#ic_Mode = 'R'                                                                  // Read mode selected    
	        AND #tx_HeaderValid                                                             // FIFO header valid 
	        AND NOT #tUDT_Status.InvalidDataType)                                           // Buffer data type valid                                                
	    THEN
	        
	        IF (#iqUDT_FifoHeader.TotalEntriesStored > 0)                                   // Checking total number of stored entries                                                     
	        THEN
	            
	            // Move the FIFO data to the data output
	            #ti_MoveBLKErrorCode := MOVE_BLK_VARIANT(SRC := #iqv_DataBuffer,
	                                                     COUNT := 1,
	                                                     SRC_INDEX := #iqUDT_FifoHeader.NextEntryToRead,
	                                                     DEST_INDEX := 0,
	                                                     DEST => #iqv_Data);
	            
	            // Increment the number of the next entry to read
	            #iqUDT_FifoHeader.NextEntryToRead += 1;
	            
	            // Decrement the total number of stored entries
	            #iqUDT_FifoHeader.TotalEntriesStored -= 1;
	            
	            IF (#iqUDT_FifoHeader.NextEntryToRead >= #iqUDT_FifoHeader.MaxNrOfEntries)  // Check the number of the next entry to read                 
	            THEN
	                
	                #iqUDT_FifoHeader.NextEntryToRead := 0;
	                
	            END_IF;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 7 – Clearing the FIFO header
	    
	    IF (#ic_Mode = 'C'                      // Clear mode selected  
	        AND #tx_HeaderValid)                // FIFO header valid                         
	    THEN
	        
	        #iqUDT_FifoHeader.TotalEntriesStored := 0;
	        #iqUDT_FifoHeader.NextEntryToWrite := 0;
	        #iqUDT_FifoHeader.NextEntryToRead := 0;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 8 – FIFO management status update
	    
	    IF (#tx_HeaderValid)                   // The header is valid                                     
	    THEN
	        
	        REGION 8.1 – FIFO Empty
	            
	            // Set the FIFO empty status bit
	            #iqUDT_FifoHeader.Status.Empty := #iqUDT_FifoHeader.TotalEntriesStored = 0;
	            
	        END_REGION
	        
	        REGION 8.2 – FIFO Full
	            
	            // Set the FIFO full status bit 
	            #iqUDT_FifoHeader.Status.Full := #iqUDT_FifoHeader.TotalEntriesStored = #iqUDT_FifoHeader.MaxNrOfEntries;
	            
	        END_REGION
	        
	        REGION 8.3 – FIFO Pre-full
	            
	            IF (#iqUDT_FifoHeader.TotalEntriesStored >= 0.9 * #iqUDT_FifoHeader.MaxNrOfEntries)       // Checking if the number of total stored entries is greater or equal to 90% of the max number of entries     
	            THEN
	                
	                // Set the FIFO pre-full status 
	                #iqUDT_FifoHeader.Status.Prefull := TRUE;
	                #tUDT_Status.FifoPreFull := TRUE;
	                
	            ELSE
	                
	                #iqUDT_FifoHeader.Status.Prefull := FALSE;
	                
	            END_IF;
	            
	        END_REGION
	        
	    END_IF;
	    
	END_REGION
	
	REGION 9 – Status
	    
	    REGION 9.1 – Common status update
	        
	        // Collective error output
	        #qx_Error := NOT #tx_HeaderValid
	        OR #tUDT_Status.InvalidMode
	        OR #tUDT_Status.FifoFull
	        OR #tUDT_Status.InvalidDataType;
	        
	        // Collective warning output              
	        #qx_Warning := #tUDT_Status.FifoPreFull;
	        
	    END_REGION
	    
	    REGION 9.2 – Status update
	        
	        // Update the outer status structure with internal status structure
	        #qUDT_Status := #tUDT_Status;
	        
	    END_REGION
	    
	END_REGION
END_FUNCTION

FUNCTION_BLOCK "FB_Pulse"
TITLE = FB_Pulse
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 26
// END_ATTRIBUTES
//Function block to generate custom pulse signal.
   VAR_INPUT 
      iudi_PulseTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Pulse time [ms]
   END_VAR

   VAR_OUTPUT 
      qx_Pulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Pulse output
   END_VAR

   VAR 
      R_TRIG {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Siemens "R_Trig" - to prepare rising edge trigger on "sx_Pulse" signal
      slr_ActualPulseTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Actual pulse time [ms]
      sx_Pulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Pulse signal
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | K.Pokorski    | first release MHS TIA 15.1
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	27/08/2019  | 2.1       | K.Pokorski    | Comments adjusted
	04/11/2019  | 2.2       | L.Klar        | Prevoius cycle scan changed from memory to DB variable
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Pulse calculation
	    
	    // Pulse timer on
	    IF (#iudi_PulseTime <= #slr_ActualPulseTime)
	    THEN
	        
	        #sx_Pulse := TRUE;
	        #slr_ActualPulseTime := 0;
	        
	    ELSE
	        
	        #slr_ActualPulseTime += "DB_Memory".PrevCycleTime;
	        #sx_Pulse := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Pulse output
	    
	    #R_TRIG(CLK := #sx_Pulse,
	            Q => #qx_Pulse);
	    
	END_REGION
END_FUNCTION_BLOCK

TYPE "UDT_ColumnLift_Statistics"
TITLE = UDT_VSUStatistics
VERSION : 0.1
//User-defined structure of FB_VerticalSwitch function block statistics.
   STRUCT
      UpTime : "UDT_EventStatistic";   // VSU up time
      DownTime : "UDT_EventStatistic";   // VSU down time
      ManualMode : "UDT_EventStatistic";
      SwitchingTimeError : "UDT_EventStatistic";
   END_STRUCT;

END_TYPE

TYPE "UDT_SecurityCageStatus"
VERSION : 0.1
   STRUCT
      InfeedMode : Bool;   // Infeed mode
      OutfeedMode : Bool;   // Outfeed mode
   END_STRUCT;

END_TYPE

TYPE "UDT_SHA_StationInterface"
VERSION : 0.1
   STRUCT
      Manned : Bool;
      NumberOfParcel : Int;
      TransferInProgres : Bool;
      Conveyor : Array[1..3] of Struct
         Empty : Bool;
         Occupied : Bool;
         Locked : Bool;
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_SHAStatus"
VERSION : 0.1
   STRUCT
      Status : Int;   // Status number
      Specific : Struct   // Equipment specific
         HalfFull : Bool;   // Halffull status
         Full : Bool;   // Full status
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_TrackingMonitor"
VERSION : 0.1
   STRUCT
      Data : Int;
      Position : Int;
      DataLength : Int;
   END_STRUCT;

END_TYPE

TYPE "UDT_TrackingOverview"
VERSION : 0.1
   STRUCT
      TotalObject : Int;
      FillingRate : Int;
   END_STRUCT;

END_TYPE

TYPE "UDT_VFD_MultiControl_Universal_Full"
VERSION : 0.1
   STRUCT
      ErrorMotor1 : Bool;   // High = motor error, Low = motor OK
      ErrorMotor2 : Bool := FALSE;   // High = motor error, Low = motor OK
      ErrorMotor3 : Bool := FALSE;   // High = motor error, Low = motor OK
      ErrorMotor4 : Bool := FALSE;   // High = motor error, Low = motor OK
      Reserve5 : Bool;   // Not used
      Reserve6 : Bool := FALSE;   // Not used
      Reserve7 : Bool := FALSE;   // Not used
      Reserve8 : Bool := FALSE;   // Not used
      SpeedMotor1 : SInt;   // Speed 0...100 (0 = stop, 100 = max speed ), negative values indicate reversed direction of rotation
      SpeedMotor2 : SInt;   // Speed 0...100 (0 = stop, 100 = max speed ), negative values indicate reversed direction of rotation
      SpeedMotor3 : SInt;   // Speed 0...100 (0 = stop, 100 = max speed ), negative values indicate reversed direction of rotation
      SpeedMotor4 : SInt;   // Speed 0...100 (0 = stop, 100 = max speed ), negative values indicate reversed direction of rotation
      Reserve10 : Bool := FALSE;   // Not used
      CurrentMotor1 : UInt;   // Average current in mA
      CurrentMotor2 : UInt;   // Average current in mA
      CurrentMotor3 : UInt;   // Average current in mA
      CurrentMotor4 : UInt;   // Average current in mA
      MotorVoltage : UInt;   // Voltage “Motor Power” in mV
      LogicVoltage : UInt;   // Voltage “Power Logic + Sensors” in mV
   END_STRUCT;

END_TYPE

TYPE "UDT_VFD_MultiControl_IOMode"
VERSION : 0.1
   STRUCT
      ErrorMotor1 : Bool;   // High = motor error, Low = motor OK
      ErrorMotor2 : Bool;   // High = motor error, Low = motor OK
      ErrorMotor3 : Bool;   // High = motor error, Low = motor OK
      ErrorMotor4 : Bool;   // High = motor error, Low = motor OK
      ComFail : Bool;   // True = communication error
      PowerFail : Bool;   // True = supply voltage error
      TempFail : Bool;   // True = temperature too high
      ControlFail : Bool;   // True = control system error
      Error : USInt;   // Actual error state: 1 = ready for operation, 2 = minor error, 3 = severe error.
      LastError : USInt;   // Most recent error
      SpeedMotor1 : SInt;   // Speed 0...100 (0 = stop, 100 = max speed ), negative values indicate reversed direction of rotation
      SpeedMotor2 : SInt;   // Speed 0...100 (0 = stop, 100 = max speed ), negative values indicate reversed direction of rotation
      SpeedMotor3 : SInt;   // Speed 0...100 (0 = stop, 100 = max speed ), negative values indicate reversed direction of rotation
      SpeedMotor4 : SInt;   // Speed 0...100 (0 = stop, 100 = max speed ), negative values indicate reversed direction of rotation
   END_STRUCT;

END_TYPE

TYPE "UDT_SystemControlCommand"
TITLE = UDT_SystemControlCommand
VERSION : 0.1
//User-defined structure of system control commands.
   STRUCT
      Start { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start Command from HMI
      Stop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stop command from HMI
      Reset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset command from HMI
      ResetData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset data command from HMI
      ResetSafety { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset safety command from HMI
      ManualMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual mode command from HMI
   END_STRUCT;

END_TYPE

TYPE "UDT_XbeltExitInterface"
VERSION : 0.1
   STRUCT
      ProductLength : Int;   // Product lenght
      ObjectID : DInt;   // Object ID
      NewObjectID : Bool;   // New Object ID
   END_STRUCT;

END_TYPE

TYPE "UDT_XBeltExitStatus"
VERSION : 0.1
   STRUCT
      ChuteDisabled : Bool;   // Chute disabled
      ChuteJam : Bool;   // Chute jam
      ChuteSensorIncongruence : Bool;   // Chute sensor incongruence
   END_STRUCT;

END_TYPE

TYPE "DownStream_Sorter_Basic"
VERSION : 0.1
   STRUCT
      ReadyToReceive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      Running { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      Fault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      HalfFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      Full { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_STRUCT;

END_TYPE

TYPE "UDT_ABSwitchStatus"
TITLE = UDT_VSUStatus
VERSION : 0.1
//User-defined structure of FB_VerticalSwitch function block status.
   STRUCT
      Status : Int;   // Status number
      Specific : Struct   // Equipment specific warnings and errors
         ReferenceError : Bool;   // Active when more like one position sensor active
         SwitchingTimerError : Bool;   // Switching time error
         LimitSensorUpperPosition : Bool;   // Limit switch for upper position active
         LimitSensorLowerPosition : Bool;   // Limit switch for lower position active
         UpperSwitchAreaError : Bool;   // Upper switching area PEC was activated when moving
         LowerSwitchAreaError : Bool;   // Lower switching area PEC was activated when moving
         UpperPosition : Bool;   // Upper position reached
         LowerPosition : Bool;   // Lower position reached
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_Outfeed2StatesStatus"
VERSION : 0.1
//User-defined structure of FB_CH03 function block status.
   STRUCT
      Status : Int;   // Status number
      Specific : Struct   // CH02 specific status structure
         ChuteFull : Bool;   // Chute is full status
         ChuteHalfFull : Bool;   // Chute is half full status
         ChuteDisabled : Bool;   // Chute is disabled status
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "Sorter_DownStream_Advanced"
VERSION : 0.1
   STRUCT
      Basic { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Sorter_DownStream_Basic";
      DischargedObjectID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      DischargedPackageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      DeletedObjectID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
   END_STRUCT;

END_TYPE

FUNCTION "FC_GetPNPortStatus" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 20
// END_ATTRIBUTES
   VAR_INPUT 
      ii_NumberOfPorts : Int;   //  Number of ports in device
      iUDT_DevicePNInfo : "UDT_PNDevice";   //  PN device info structure
   END_VAR

   VAR_OUTPUT 
      qa_PortFault : Array[1..8] of Bool;   //  When TRUE then specific port has a fault
   END_VAR

   VAR_TEMP 
      tp_GetDiagInfo {InstructionName := 'DIS'; LibVersion := '1.0'} : DIS;   //  Diagnostic structure
      tp_DeviceGeoAddr {InstructionName := 'GEOADDR'; LibVersion := '1.0'} : GEOADDR;   //  Device pointer structre
      ta_PortFault : Array[1..8] of Bool;   //  When TRUE then port has a fault
      ti_Geo2LogStatus : Int;   //  GEO2LOG status code
      ti_GetDiagStatus : Int;   //  Get_Diag status code
      ti_Log2GeoStatus : Int;   //  LOG2GEO status code
      ti_Loopcounter : Int;   //  Loop counter
      tui_cnt : UInt;   //  Not used
      tdi_PortLaddr : HW_ANY;   //  HW identifier
      ti_PortFault : Bool;   //  At least one port is faulty
      tx_ConfigurationError : Bool;   //  Configuration error occurred
   END_VAR

   VAR CONSTANT 
      ci_Area : UInt := 1;   //     Area ID of IO Profinet devices
      ci_HWTYPE : UInt := 5;
      ci_PortSlot : UInt := 0;
      ci_PortSubslot : Word := 16#8000;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	03/11/2020  | 3.0       | K.Pokorski    | first release MHS TIA 15.1
	17/12/2020  | 3.1       | K.Pokorski    | Run operation only during error
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Check configuration
	    
	    #tx_ConfigurationError := #ii_NumberOfPorts < 1
	    OR #ii_NumberOfPorts > 8
	    OR NOT #iUDT_DevicePNInfo.PNDeviceFound;
	    
	END_REGION
	
	REGION 2 - Read profinet network number
	    
	    // Using LOG2GEO profinet network address is read
	    #ti_Log2GeoStatus := LOG2GEO(LADDR := "DB_ProfinetDiagnostic".ProfinetNetworks[#iUDT_DevicePNInfo.PNNetworknumber].DeviceStatus[#iUDT_DevicePNInfo.PNDeviceNumber].DeviceState.HW_ID,
	                                 GEOADDR := #tp_DeviceGeoAddr);
	    
	END_REGION
	
	REGION 3 - Preparation the device pointer
	    
	    // HWTYPE = 5 - Submodule
	    #tp_DeviceGeoAddr.HWTYPE := #ci_HWTYPE;
	    // AREA = 1 - PROFINET IO
	    #tp_DeviceGeoAddr.AREA := #ci_Area;
	    // SLOT = 0 - Ports are on slot 0 
	    #tp_DeviceGeoAddr.SLOT := #ci_PortSlot;
	    // STATION - Profinet number
	    #tp_DeviceGeoAddr.STATION := "DB_ProfinetDiagnostic".ProfinetNetworks[#iUDT_DevicePNInfo.PNNetworknumber].DeviceStatus[#iUDT_DevicePNInfo.PNDeviceNumber].DeviceState.ProfinetNumber;
	    
	END_REGION
	
	REGION 4 - Checking the port status
	    // If device report error and is available on the PN network
	    IF "DB_ProfinetDiagnostic".ProfinetNetworks[#iUDT_DevicePNInfo.PNNetworknumber].DeviceStatus[#iUDT_DevicePNInfo.PNDeviceNumber].DeviceState.Error
	        AND "DB_ProfinetDiagnostic".ProfinetNetworks[#iUDT_DevicePNInfo.PNNetworknumber].DeviceStatus[#iUDT_DevicePNInfo.PNDeviceNumber].DeviceState.Exist
	        AND NOT #tx_ConfigurationError
	    THEN
	        
	        // Loop through all profinet ports
	        FOR #ti_Loopcounter := 1 TO #ii_NumberOfPorts DO
	            // Reset auxiliary port fault bit 
	            #ta_PortFault[#ti_Loopcounter] := FALSE;
	            // SUBSLOT = 16#8000 plus port number (TIA structure to refer to port)
	            #tp_DeviceGeoAddr.SUBSLOT := INT_TO_UINT(WORD_TO_INT(#ci_PortSubslot) + (#ti_Loopcounter));
	            // Using GEO2LOG port address is read
	            #ti_Geo2LogStatus := GEO2LOG(GEOADDR := #tp_DeviceGeoAddr, LADDR => #tdi_PortLaddr);
	            // Using GET_DIAG port status is read
	            #ti_GetDiagStatus := GET_DIAG(MODE := 1, LADDR := #tdi_PortLaddr, CNT_DIAG => #tui_cnt, DIAG := #tp_GetDiagInfo);
	            
	            // Set port fault if all operations do not report any error and port is faulty
	            IF #ti_GetDiagStatus = 0
	                AND #ti_Geo2LogStatus = 0
	                AND #ti_Log2GeoStatus = 0
	                AND #tp_GetDiagInfo.OwnState = 4
	            THEN
	                #ta_PortFault[#ti_Loopcounter] := TRUE;
	            END_IF;
	        END_FOR;
	        // Reset module status if error occurred
	    ELSIF #tx_ConfigurationError
	    THEN
	        FOR #ti_Loopcounter := 1 TO 8 DO
	            #ta_PortFault[#ti_Loopcounter] := FALSE;
	        END_FOR;
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Write output
	    
	    #qa_PortFault := #ta_PortFault;
	    
	END_REGION
	
	
END_FUNCTION

TYPE "UDT_RetractrableRoller_Status"
VERSION : 0.1
   STRUCT
      Status : Int;
      Specific : Struct
         NoHomePosition : Bool;
         RollerError : Bool;
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_InchingStatus"
VERSION : 0.1
   STRUCT
      Full { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor is full
      Active { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Inching is active
   END_STRUCT;

END_TYPE

TYPE "UDT_Outfeed2StatesStatistics"
VERSION : 0.1
//User-defined structure of FB_CH03 function block statistics.
   STRUCT
      ChuteFull { S7_SetPoint := 'False'} : "UDT_EventStatistic";   // Chute full statistics
      ChuteHalfFull : "UDT_EventStatistic";   // Chute half full statistics
      ChuteDisabled { S7_SetPoint := 'False'} : "UDT_EventStatistic";   // Chute disabled statistics
   END_STRUCT;

END_TYPE

TYPE "UDT_ColumnLiftCommand"
VERSION : 0.1
   STRUCT
      MaintenanceControl : Bool;
   END_STRUCT;

END_TYPE

TYPE "UDT_CodingBeltModesConfiguration"
VERSION : 0.1
   STRUCT
      Infeed : Struct   // Infeed configuration:
         LabellingMode : Bool;   // TRUE when mode can be active
         ContinueMode : Bool;   // TRUE when mode can be active
         BufferMode : Bool;   // TRUE when mode can be active
      END_STRUCT;
      Outfeed : Struct   // Outfeed configuration:
         LabellingMode : Bool;   // TRUE when mode can be active
         ContinueMode : Bool;   // TRUE when mode can be active
         BufferMode : Bool;   // TRUE when mode can be active
      END_STRUCT;
      LabellingMode_ParcelStop : Int;   // Parcel stop position in labeling mode, distance between photocell at the beginning of the belt and parcel end.
   END_STRUCT;

END_TYPE

TYPE "UDT_CodingBeltModesStatus"
VERSION : 0.1
   STRUCT
      Status : Int;
      Specific : Struct
         Infeed_LabellingMode : Bool;
         Infeed_ContinueMode : Bool;
         Infeed_BufferMode : Bool;
         Outfeed_LabellingMode : Bool;
         Outfeed_ContinueMode : Bool;
         Outfeed_BufferMode : Bool;
         GeneralError : Bool;
         ConfigurationError : Bool;
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_CapacityControlConfiguration"
VERSION : 0.1
   STRUCT
      ChuteLength : DInt;   // Hardcode chute lenght [mm]
      MaxProductLenght : DInt;   // Hardcode maximum product lenght [mm]
      ProductLenghtHalfFull : DInt;   // Hardcode halfull product lenght [mm]
   END_STRUCT;

END_TYPE

TYPE "UDT_BiDirectionalConfiguration"
VERSION : 0.1
   STRUCT
      TimeDelayInfeed : UDInt;   // Delay time to keep the system running before turning it off when request a mode change
      TimeDelayOutfeed : UDInt;   // Delay time to keep the system running before turning it off when request a mode change
   END_STRUCT;

END_TYPE

TYPE "UDT_BiDirectionalStatus"
VERSION : 0.1
   STRUCT
      InfeedModeRequested : Bool;   // Mode change is in progress
      OutfeedModeRequested : Bool;   // Mode change is in progress
      InfeedModeActive : Bool;   // Mode active and system running
      OutfeedModeActive : Bool;   // Mode active and system running
      InfeedModeReady : Bool;   // System is ready to restart, wait for start command
      OutfeedModeReady : Bool;   // System is ready to restart, wait for start command
      ChangingMode : Bool;   // The mode will now be changed
   END_STRUCT;

END_TYPE

TYPE "UDT_BiDirectionalInterface"
VERSION : 0.1
   STRUCT
      RequestToStopOutfeed : Bool;   // Request signal to stop outfeed system
      RequestToStopInfeed : Bool;   // Request signal to stop infeed system
      RequestToStopBidirectional : Bool;   // Request signal to stop bidirectional system
      RequestToSwitchingSystem : Bool;   // Request signal to switching system
      RequestToStopSwitchingSystem : Bool;   // Request signal to stop switching system
      OutfeedStopped : Bool;   // Feedback signal from the Outfeed system
      InfeedStopped : Bool;   // Feedback signal from the Intfeed system
      BidirectionalStopped : Bool;   // Feedback signal from the BiDirectional system
      SwitchingSystemReady : Bool;   // Feedback signal from the Switching system
      ElapsedTime : UDInt;   // Change mode elapsed time [sec]
   END_STRUCT;

END_TYPE

TYPE "UDT_ABSwitchConfiguration"
TITLE = UDT_VSUConfig
VERSION : 0.1
//User-defined structure of VSU parameters.
   STRUCT
      JogNoHornTime : UDInt := 1000;   // Time within jog buttons can be pressed without new startup indication
      SwitchingTime : UDInt;   // Time when switching device sholud reach position [ms]
      NominalSpeedSetPoint : Int;   // Nominal spped for position change [mm/s]
      BrakingSpeedSetpoint : Int;   // Speed after braking PEC [mm/s]
      ManualModeSpeed : Int;   // Speed in manual mode [mm/s]
   END_STRUCT;

END_TYPE

TYPE "UDT_ColumnLift_Status"
TITLE = UDT_VSUStatus
VERSION : 0.1
//User-defined structure of FB_VerticalSwitch function block status.
   STRUCT
      Status : Int;   // Status number
      Specific : Struct   // Equipment specific warnings and errors
         ReferenceError : Bool;   // Active when more like one position sensor active
         SwitchingTimerError : Bool;   // Switching time error
         LimitSensorUpperPosition : Bool;   // Limit switch for upper position active
         LimitSensorLowerPosition : Bool;   // Limit switch for lower position active
         UpperPosition : Bool;   // Upper position reached
         LowerPosition : Bool;   // Lower position reached
         ChuteNotInPosition : Bool;   // The chute is not supported by a column
         MaintenaceModeActive : Bool;
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_ColumnLift_Configuration"
TITLE = UDT_VSUConfig
VERSION : 0.1
//User-defined structure of VSU parameters.
   STRUCT
      ColumnLiftBase : Bool;   // True when downstair base is normal conveyor ; False when downstair base is Caljan with changing height elevation
      JogNoHornTime : UDInt := 1000;   // Time within jog buttons can be pressed without new startup indication [ms]
      SwitchingTime : UDInt;   // Time when switching device sholud reach position [ms]
      NominalSpeedSetPoint : Int;   // Nominal spped for position change [mm/s]
      ManualModeSpeed : Int;   // Speed in manual mode [mm/s]
   END_STRUCT;

END_TYPE

TYPE "UDT_ConveyorStatistics"
TITLE = UDT_ConveyorStatistics
VERSION : 0.1
//User-defined structure of FB_Conveyor function block statistics.
   STRUCT
      EnergySave : "UDT_EventStatistic";   // Number of times that save energy mode occurs
      ConveyorUp : "UDT_EventStatistic";   // Conveyor up statistics
      ConveyorDown : "UDT_EventStatistic";   // Conveyor down statistics
      ConveyorStop : "UDT_EventStatistic";   // Conveyor down statistics
   END_STRUCT;

END_TYPE

TYPE "UDT_ConveyorStatus"
TITLE = UDT_ConveyorStatus
VERSION : 0.1
//User-defined structure of FB_Conveyor function block status.
   STRUCT
      Status : Int;   // Status number
      Specific : Struct
         Reverse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor is running in reverse direction
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_EncoderStatisticsV2"
VERSION : 0.1
   STRUCT
      RunningFeedbackError : "UDT_EventStatistic";
      InvalidValue : "UDT_EventStatistic";
   END_STRUCT;

END_TYPE

TYPE "UDT_EncoderStatusV2"
VERSION : 0.1
   STRUCT
      InvalidValue : Bool;   // Invalid value
      RunningFeedbackError : Bool;   // Running feedback error
   END_STRUCT;

END_TYPE

TYPE "UDT_EncoderConfigurationV2"
VERSION : 0.1
   STRUCT
      EncoderMaxValue : DInt;   // The maximum value of the encoder where will rollover
      mmPerIncrement : Real;   // The mm per encoder incremental [mm]
      ErrorFilter : UDInt;   // Movment timeout without encoder data [ms]
      SamplingTime : UDInt;   // Save actual speed sampling time [ms]
   END_STRUCT;

END_TYPE

TYPE "UDT_EuchnerLockStatusV2"
VERSION : 0.1
   STRUCT
      LockFault : Bool;   // Internal lock fault
      DoorClosed : Bool;   // The door is closed
      DoorOpened : Bool;   // The door is opened
      BoltTongueClosed : Bool;   // The lock bolt tongue is closed
      ReqMissingAccessRights : Bool;   // Button access request triggered without permission from DHL
      ResetMissingAccessRights : Bool;   // Button reset triggered without permission from DHL
      DoorOpenedWithoutReq : Bool;   // Doors were opened without request and permission
      Safelylocked : Bool;   // The lock is safely locked
      SafetyLockAckReq : Bool;   // The safety lock signal needs to be confirmed
   END_STRUCT;

END_TYPE

TYPE "UDT_ConveyorCommand"
TITLE = UDT_ConveyorCommand
VERSION : 0.1
//User-defined structure of conveyor commands.
   STRUCT
      ManualMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual mode command from HMI
      ManualStartStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Run conveyor in manual mode
      ManualFullSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Full speed conveyor in manual mode
      ManualJog { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command to jog conveyor in slow speed from HMI
      Reverse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command to run conveyor in reverse direction from HMI
      ManualSpeed : Int := 50;   // Manual mode speed as percentage of nominal speed [0-100%]
   END_STRUCT;

END_TYPE

TYPE "UDT_Outfeed2StatesConfiguration"
VERSION : 0.1
//User-defined structure of FB_Chute2PEC function block configuration.
   STRUCT
      FullDetectionTime : UDInt;   // Time after which chute full is detected
      FullReleaseTime : UDInt;   // Time after which chute full is released
      HalfFullDetectionTime : UDInt;   // Time after which chute half full is detected
      HalfFullReleaseTime : UDInt;   // Time after which chute half full is released
   END_STRUCT;

END_TYPE

TYPE "UDT_ConveyorConfiguration"
TITLE = UDT_ConveyorConfiguration
VERSION : 0.1
//User-defined structure of conveyor parameters.
   STRUCT
      Common : "UDT_ConveyorCommonConfiguration";   // Common configuration
      Forward_Direction : Struct   // Forward Direction configuration
         EnergySaveLenght : DInt;   // Distance conveyor travelled before energy save activate [cm]
         GapHeadToHead : DInt;   // Gapping head to head value [cm]
         GapTailToHead : DInt;   // Gapping tail to head value [cm]
         GapCorrection : DInt;   // Gap offset to cover VFD's ramps [cm]
         PEC_EoSDistanceOffset : DInt;   // Distance offset between photo eye and the end of conveyor [mm]
         Mode : Int;   // Automatic operation; 1- Slave; 2- Queue;
         FirstConveyorToStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // First conveyor to start cascade mode forward direction
      END_STRUCT;
      Reverse_Direction : Struct   // Reverse Direction configuration
         EnergySaveLenght : DInt;   // Distance conveyor travelled before energy save activate [cm]
         GapHeadToHead : DInt;   // Gapping head to head value [cm]
         GapTailToHead : DInt;   // Gapping tail to head value [cm]
         GapCorrection : DInt;   // Gap offset to cover VFD's ramps [cm]
         PEC_BoSDistanceOffset : DInt;   // Distance offset between photo eye and the end of conveyor [mm]
         Mode : Int;   // Automatic operation; 1- Slave; 2- Queue;
         FirstConveyorToStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // First conveyor to start cascade mode reverse direction
      END_STRUCT;
      CascadeTimeOnDelay : UDInt;   // Cascade time on delay [ms]
      ExtraGapRecovery : DInt;   // Extra gap to recovery die back [cm]
      SpeedSetpointLow : Int;   // Low speed setpoint [mm/s]
      SpeedSetpointNominal : Int;   // Nominal speed setpoint [mm/s]
      Energy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Energy save mode enable
      Bi_Directional_Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The conveyor can run in both directions
   END_STRUCT;

END_TYPE

TYPE "UDT_SerialCommunicationStatus"
VERSION : 0.1
   STRUCT
      ErrorCode : Word;   // Siemens Signal_Get error code - Check documetation
      Connected : Bool;   // Connected
      CommunicationFault : Bool;   // Communication fault
   END_STRUCT;

END_TYPE

TYPE "UDT_XrayInterface"
VERSION : 0.1
   STRUCT
      Backbelt : Struct   // Bacbelt function signals structure
         Enable : Bool;   // TRUE when Backbelt functionality for input conveyor is active
         Active : Bool;   // TRUE when Backbelt functionality activeted
      END_STRUCT;
      XrayConveyor : Struct   // Xray conveyor signals structure
         RunFwd : Bool;   // TRUE when conveyor is running forward
         RunRvs : Bool;   // TRUE when conveyor is running reverse
      END_STRUCT;
      InputConveyor : Struct   // Input conveyor signals structure
         CommandRunRvs : Bool;   // Request command to run reverse
      END_STRUCT;
      Communication : Struct   // SerialCommunication signals structure
         Connceted : Bool;   // Devices connected
         SendMessage : Struct   // Send message signal structure
            SendTrigger : Bool;   // Send message trigger
            GIN : Int;   // GIN number for new message
         END_STRUCT;
      END_STRUCT;
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_VFD_MultiControl_V4"
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'KBA-PM'
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 107
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_VFDConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VFD_MultiControl_Configuration";   //   VFD configuration structure
      i_UDT_VFDInputs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VFD_MultiControl_PI";   //   VFD inputs structure
      ix_PowerOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when External Power OK
      ix_SafetyOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when Safety OK
      ix_SimulationModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when Simulation mode active
   END_VAR

   VAR_OUTPUT 
      q_UDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdStatus";   //   HMI status structure
      qsi_UDT_VFDSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : SInt;   //   VFD speed setpoint
   END_VAR

   VAR_IN_OUT 
      iq_UDT_ConveyorInterface : "UDT_ConveyorInterface";   //   Conveyor interface structure
      iq_UDT_VFDStatistics : "UDT_VfdStatistics";   //   Statistics structure
      iq_UDT_Equipment : "UDT_EquipmentControl";   //   Equipment structure
   END_VAR

   VAR 
      s_FB_TimerOnOffDelayCheckSupply { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //  "TimerOnOffDelay" - to delay time for VFD supply contactor
      s_FB_TimerOnOffDelay_ProfinetNotOnlineMasking { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //   "TimerOnOffDelay" - to delay time for profinet not online masking
      s_FB_TimerOnOffDelay_ProfinetSlaveErrorMasking { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //   "TimerOnOffDelay" - to delay time for profinet error masking
      s_FB_TimerOnOffDelay_RunCommand_Motor_1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //   "TimerOnOffDelay" - to delay time for run command motor 1
      s_FB_TimerOnOffDelay_RunCommand_Motor_2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //   "TimerOnOffDelay" - to delay time for run command motor 2
      s_FB_TimerOnOffDelay_RunCommand_Motor_3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //   "TimerOnOffDelay" - to delay time for run command motor 3
      s_FB_TimerOnOffDelay_SafetyOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //   "TimerOnOffDelay" - to delay time for safety
      s_FB_TimerOnOffDelay_RunCommand_Motor_4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //   "TimerOnOffDelay" - to delay time for run command motor 4
      s_FB_TimerOnOffDelay_Instance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //   "TimerOnOffDelay" - to delay time for Instance
      s_UDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatus";   //   HMI status structure
      s_UDT_PNDevice { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PNDevice";   //   PN device info structure
      s_R_TRIG_RunForward {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge of Run forward signal
      s_R_TRIG_RunReverse {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge of Run reverse
      s_R_TRIG_PNSlaveNotOnline {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge for trigger Profinet slave not online statistics
      s_R_TRIG_PNSlaveError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge for trigger Profinet slave error statistics
      s_R_TRIG_InternalError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge for trigger Internal VFD Error statistics
      s_R_TRIG_Running {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge for starting of the running signal
      s_R_TRIG_Instance {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Raising edge for Instance
      s_R_TRIG_NewPNSlaveError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   New profinet slave error trigger
      s_R_TRIG_NewPNSlaveNotOnline {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   New profinet slave not online trigger
      ss_RDREC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //   Read error code record structure
         Valid { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      Read operation is done
         Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      Read operation is in progress
         Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      Read operation has an error
         Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DWord;   //      Read operation status
         Lenght { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   //      Lenght of the read record
      END_STRUCT;
      ss_WRREC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //   Write record structure
         Acceleration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //      Acceleration
            REQ { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      Requirement
            Index { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //      Index
            Done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      Operation is done
            Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      Write operation is in progress
            Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      Write operation has an error
            Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DWord;   //      Write operation status
            Data { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   //      Data to write
         END_STRUCT;
         Deceleration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //      Deceleration
            REQ { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      Requirement
            Index { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //      Index
            Done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      Operation is done
            Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      Write operation is in progress
            Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      Write operation has an error
            Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DWord;   //      Write operation status
            Data { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   //      Data to write
         END_STRUCT;
      END_STRUCT;
      ss_AccelerationDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //   Acceleration is written
         Motor_1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Motor_2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Motor_3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Motor_4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         All { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      END_STRUCT;
      ss_DecelerationDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //   Deceleration is written
         Motor_1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Motor_2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Motor_3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Motor_4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         All { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      END_STRUCT;
      s_VFDGeoStruct {InstructionName := 'GEOADDR'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : GEOADDR;   //   Geo structure indicate to telegram
      s_RDREC_ErrorCode {InstructionName := 'RDREC'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : RDREC;   //   Read error code record instruction
      s_WRREC_ACC {InstructionName := 'WRREC'; LibVersion := '1.1'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : WRREC;   //   Write acceleration record inctruction
      s_WRREC_DEC {InstructionName := 'WRREC'; LibVersion := '1.1'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : WRREC;   //   Write deceleration record instruction
      shw_VFD_Telegram { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   //   Free telegram's HW_ID
      sr_MaximumSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   //   Maximum speed [mm/s]
      sr_SpeedsetpointCorrected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   //   Speedsetpoint corrected with factor
      sw_ErrorCode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   //   VFD error code
      si_RequiredSpeedSetpoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Required speed setpoint
      si_ActualSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Actual speed in [mm/s]
      si_Log2GeoReturn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Log2Geo function return
      si_Geo2LogReturn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Geo2Log function return
      si_AccelerationSetpoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Acceleration setpoint value
      si_DecelerationSetpoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Deceleration setpoint value
      si_AccelerationOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Old acceleration value
      si_DecelerationOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Old deceleration value
      si_MotorNumber_Acc { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Motor number that is connected to the Multicontrol module [1,2,3 or 4]
      si_MotorNumber_Dec { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Motor number that is connected to the Multicontrol module [1,2,3 or 4]
      si_PNSlaveErrorCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Profinet slave error counter
      si_PNSlaveNotOnlineCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Profinet slave not online counter
      ssi_MotorSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : SInt;   //   Motor speed value
      sx_ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Commissioning: configuration error
      sx_PNDeviceHealthy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Profinet device is online and error free
      sx_PowerOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Communication, safety and power are available
      sx_VFD_Available { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Hardware of VFD is ok
      sx_ErrorActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Block has an error
      sx_MotorError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Motor error all
      sx_Motor_1_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Motor error 1
      sx_Motor_2_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Motor error 2
      sx_Motor_3_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Motor error 3
      sx_Motor_4_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Motor error 4
      sx_EnableOperation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Enable operation signal
      sx_RunVFDForward { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Start VFD forward
      sx_RunVFDReverse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Start VFD backward
      sx_SpeedSetpointReached { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Motor is running at requested speed
      sx_ErrorDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Error code is read
      sx_SafetyOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Safety ok
      sx_MaskingReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Masking reset
      sx_PNSlaveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Profinet slave error
      sx_PNSlaveNotOnline { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Profinet slave not online
   END_VAR

   VAR CONSTANT 
      ci_VFDArea : UInt := 1;   //   Area ID of IO Profinet devices
      ci_SubmoduleHWType : UInt := 5;   //   Submodule HW_type number
      ci_TelegramSlot : UInt := 2;   //   Free Siemens telegram slot
      ci_TelegramSubslot : UInt := 1;   //   Free Siemens telegram subslot
      cdi_ErrorCodeIndex : DInt := 17154;   //   Error code index
      cdi_AccelerationIndex : DInt := 18200;   //   Acceleration index
      cdi_DecelerationIndex : DInt := 18204;   //   Deceleration index
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------      
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2023  | 1.0       | S.Nikodem     | Initial version for 4 motors | DHL Munich 2023
	13/03/2024  | 1.1       | S. Nieswiec   | Added to new baseline
	*)
	
	REGION 1 - Get Device Profinet number
	    
	    // Getting information about Profinet Device.
	    "FC_GetDevicePN"(is_PNDeviceName := #i_UDT_VFDConfiguration.VFDPNDeviceName,
	                     ix_SimulationModeActive := #ix_SimulationModeActive,
	                     iqUDT_PND := #s_UDT_PNDevice);
	    
	END_REGION
	
	REGION 2 - Motor validation
	    
	    //Motor number 1
	    // Delay
	    #s_FB_TimerOnOffDelay_RunCommand_Motor_1(iudi_OnDelayTime := 1500,
	                                             ix_SignalToDelay :=
	                                             (#sx_RunVFDForward
	                                             OR #sx_RunVFDReverse)
	                                             AND #i_UDT_VFDInputs.CurrentMotor1 < #i_UDT_VFDConfiguration.MinimumCurrentWhenRunninng);
	    
	    #ssi_MotorSpeed := #i_UDT_VFDInputs.SpeedMotor1;
	    
	    IF (#s_FB_TimerOnOffDelay_RunCommand_Motor_1.qx_DelayedSignal AND #sx_EnableOperation) OR #i_UDT_VFDInputs.ErrorMotor1
	    THEN
	        
	        #sx_Motor_1_Error := TRUE;
	        
	    END_IF;
	    
	    //Motor number 2
	    #s_FB_TimerOnOffDelay_RunCommand_Motor_2(iudi_OnDelayTime := 1500,
	                                             ix_SignalToDelay :=
	                                             (#sx_RunVFDForward
	                                             OR #sx_RunVFDReverse)
	                                             AND #i_UDT_VFDInputs.CurrentMotor2 < #i_UDT_VFDConfiguration.MinimumCurrentWhenRunninng);
	    
	    #ssi_MotorSpeed := #i_UDT_VFDInputs.SpeedMotor2;
	    
	    IF (#s_FB_TimerOnOffDelay_RunCommand_Motor_2.qx_DelayedSignal AND #sx_EnableOperation) OR #i_UDT_VFDInputs.ErrorMotor2
	        
	    THEN
	        
	        #sx_Motor_2_Error := TRUE;
	        
	    END_IF;
	    
	    //Motor number 3
	    #s_FB_TimerOnOffDelay_RunCommand_Motor_3(iudi_OnDelayTime := 1500,
	                                             ix_SignalToDelay :=
	                                             (#sx_RunVFDForward
	                                             OR #sx_RunVFDReverse)
	                                             AND #i_UDT_VFDInputs.CurrentMotor3 < #i_UDT_VFDConfiguration.MinimumCurrentWhenRunninng);
	    
	    #ssi_MotorSpeed := #i_UDT_VFDInputs.SpeedMotor3;
	    
	    IF (#s_FB_TimerOnOffDelay_RunCommand_Motor_3.qx_DelayedSignal AND #sx_EnableOperation) OR #i_UDT_VFDInputs.ErrorMotor3
	    THEN
	        
	        #sx_Motor_3_Error := TRUE;
	        
	    END_IF;
	    
	    //Motor number 4
	    #s_FB_TimerOnOffDelay_RunCommand_Motor_4(iudi_OnDelayTime := 1500,
	                                             ix_SignalToDelay :=
	                                             (#sx_RunVFDForward
	                                             OR #sx_RunVFDReverse)
	                                             AND #i_UDT_VFDInputs.CurrentMotor4 < #i_UDT_VFDConfiguration.MinimumCurrentWhenRunninng);
	    
	    #ssi_MotorSpeed := #i_UDT_VFDInputs.SpeedMotor4;
	    
	    IF (#s_FB_TimerOnOffDelay_RunCommand_Motor_4.qx_DelayedSignal AND #sx_EnableOperation) OR #i_UDT_VFDInputs.ErrorMotor4
	    THEN
	        
	        #sx_Motor_4_Error := TRUE;
	        
	    END_IF;
	    
	    //Collect errors from all motors
	    #sx_MotorError := #sx_Motor_1_Error OR #sx_Motor_2_Error OR #sx_Motor_3_Error OR #sx_Motor_4_Error;
	    
	END_REGION
	
	REGION 3 - Reset errors
	    
	    // Reset the errors on the command from the conveyor interface.
	    // 
	    #s_R_TRIG_Instance(CLK := #ix_SafetyOK,
	                       Q => #sx_SafetyOK);
	    
	    #s_FB_TimerOnOffDelay_Instance(iudi_OffDelayTime := 10000,
	                                   ix_SignalToDelay := #sx_SafetyOK,
	                                   qx_DelayedSignal => #sx_MaskingReset);
	    
	    
	    IF #iq_UDT_ConveyorInterface.InternalErrorReset
	        OR (#sx_MaskingReset
	        AND "DB_Memory".Clock_2Hz)
	    THEN
	        #s_UDT_HMIStatus.PNSlaveNotonline := FALSE;
	        #s_UDT_HMIStatus.PNSlaveError := FALSE;
	        #s_UDT_HMIStatus.InternalError := FALSE;
	        #sx_MotorError := FALSE;
	        #sx_Motor_1_Error := FALSE;
	        #sx_Motor_2_Error := FALSE;
	        #sx_Motor_3_Error := FALSE;
	        #sx_Motor_4_Error := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Hardware check
	    
	    //Auto reset for Profinet errors, when inactive the masking time is 0
	    IF NOT #i_UDT_VFDConfiguration.AutoReset THEN
	        
	        #i_UDT_VFDConfiguration.TimePNErrorMasking := 0;
	        
	    END_IF;
	    
	    // Hardware will be available only after the delay, so the device has time for the initialization.
	    #s_FB_TimerOnOffDelayCheckSupply(iudi_OnDelayTime := 2000,
	                                     ix_SignalToDelay := #ix_PowerOK,
	                                     qx_DelayedSignal => #sx_PowerOk);
	    
	    #s_FB_TimerOnOffDelay_ProfinetNotOnlineMasking(iudi_OnDelayTime := #i_UDT_VFDConfiguration.TimePNErrorMasking,
	                                                   iudi_OffDelayTime := 0,
	                                                   ix_SignalToDelay := #sx_PNSlaveNotOnline,
	                                                   qx_DelayedSignal => #s_UDT_HMIStatus.PNSlaveNotonline);
	    
	    #s_FB_TimerOnOffDelay_ProfinetSlaveErrorMasking(iudi_OnDelayTime := #i_UDT_VFDConfiguration.TimePNErrorMasking,
	                                                    iudi_OffDelayTime := 0,
	                                                    ix_SignalToDelay := #sx_PNSlaveError,
	                                                    qx_DelayedSignal => #s_UDT_HMIStatus.PNSlaveError);
	    
	    #s_R_TRIG_NewPNSlaveNotOnline(CLK := #sx_PNSlaveNotOnline);
	    #s_R_TRIG_NewPNSlaveError(CLK := #sx_PNSlaveError);
	    // Check if PN device is online.
	    IF NOT "DB_ProfinetDiagnostic".ProfinetNetworks[#s_UDT_PNDevice.PNNetworknumber].DeviceStatus[#s_UDT_PNDevice.PNDeviceNumber].DeviceState.Exist
	        AND NOT #ix_SimulationModeActive
	        AND #sx_PowerOk
	    THEN
	        #sx_PNSlaveNotOnline := TRUE;
	        #iq_UDT_Equipment.Command.Reset := "DB_Memory".Clock_1Hz AND #i_UDT_VFDConfiguration.AutoReset;
	    ELSE
	        #sx_PNSlaveNotOnline := FALSE;
	    END_IF;
	    
	    IF #s_R_TRIG_NewPNSlaveNotOnline.Q THEN
	        #si_PNSlaveNotOnlineCount += 1;
	    END_IF;
	    
	    // Check if PN device has an error.
	    IF "DB_ProfinetDiagnostic".ProfinetNetworks[#s_UDT_PNDevice.PNNetworknumber].DeviceStatus[#s_UDT_PNDevice.PNDeviceNumber].DeviceState.Error
	        AND NOT #ix_SimulationModeActive
	        AND #sx_PowerOk
	    THEN
	        #sx_PNSlaveError := TRUE;
	        #iq_UDT_Equipment.Command.Reset := "DB_Memory".Clock_1Hz AND #i_UDT_VFDConfiguration.AutoReset;
	    ELSE
	        #sx_PNSlaveError := FALSE;
	    END_IF;
	    
	    IF #s_R_TRIG_NewPNSlaveError.Q THEN
	        #si_PNSlaveErrorCount += 1;
	    END_IF;
	    
	    // Set bit when PN device is healthy (online and no error).
	    #sx_PNDeviceHealthy :=
	    NOT #s_UDT_HMIStatus.PNSlaveNotonline
	    AND NOT #s_UDT_HMIStatus.PNSlaveError
	    AND #s_UDT_PNDevice.PNDeviceFound
	    AND #sx_PowerOk;
	    
	    // Set VFD available bit when all conditions are met.
	    #sx_VFD_Available :=
	    (NOT #sx_MotorError
	    AND #sx_PowerOk
	    AND #sx_PNDeviceHealthy)
	    OR #ix_SimulationModeActive;
	    
	END_REGION
	
	REGION 5 - Extract telegram's HW_ID
	    
	    // Extract telegram's HW_ID 
	    #si_Log2GeoReturn := LOG2GEO(LADDR := "DB_ProfinetDiagnostic".ProfinetNetworks[#s_UDT_PNDevice.PNNetworknumber].DeviceStatus[#s_UDT_PNDevice.PNDeviceNumber].DeviceState.HW_ID, GEOADDR := #s_VFDGeoStruct);
	    #s_VFDGeoStruct.AREA := #ci_VFDArea;
	    #s_VFDGeoStruct.HWTYPE := #ci_SubmoduleHWType;
	    #s_VFDGeoStruct.STATION := INT_TO_UINT(#s_UDT_PNDevice.PNDeviceNumber);
	    #s_VFDGeoStruct.SLOT := #ci_TelegramSlot;
	    #s_VFDGeoStruct.SUBSLOT := #ci_TelegramSubslot;
	    
	    #si_Geo2LogReturn := GEO2LOG(GEOADDR := #s_VFDGeoStruct, LADDR => #shw_VFD_Telegram);
	    
	END_REGION
	
	REGION 6 - Check errors 
	    
	    #s_FB_TimerOnOffDelay_SafetyOK(iudi_OnDelayTime := 10000,
	                                   ix_SignalToDelay := #ix_SafetyOK);
	    
	    // Check if the motor has an error.
	    IF #s_FB_TimerOnOffDelay_SafetyOK.qx_DelayedSignal  //#ix_SafetyOK
	    THEN
	        #s_UDT_HMIStatus.InternalError := #sx_MotorError;
	        
	    END_IF;
	    // Create trigger on error.
	    #s_R_TRIG_InternalError(CLK := #s_UDT_HMIStatus.InternalError);
	    
	    // If the internal error occured, reset the error code read done signal.
	    IF #s_R_TRIG_InternalError.Q
	    THEN
	        #sx_ErrorDone := FALSE;
	    END_IF;
	    
	    // If there is an internal error, read the error code from the Interroll VFD. Otherwise, reset it.
	    IF NOT #s_UDT_HMIStatus.InternalError
	    THEN
	        #s_UDT_HMIStatus.ErrorCode := 0;
	    ELSE
	        // Read the error code from the multicontrol.
	        #s_RDREC_ErrorCode(REQ := ((NOT #sx_ErrorDone OR "mx_FirstScan") AND NOT #s_UDT_HMIStatus.PNSlaveNotonline),
	                           ID := #shw_VFD_Telegram,
	                           INDEX := #cdi_ErrorCodeIndex,
	                           MLEN := 0,
	                           VALID => #ss_RDREC.Valid,
	                           BUSY => #ss_RDREC.Busy,
	                           ERROR => #ss_RDREC.Error,
	                           STATUS => #ss_RDREC.Status,
	                           LEN => #ss_RDREC.Lenght,
	                           RECORD := #sw_ErrorCode);
	        
	        // IF error code is read, set the error code read signal and write it to the structure.
	        IF #s_RDREC_ErrorCode.VALID
	        THEN
	            #sx_ErrorDone := TRUE;
	            #s_UDT_HMIStatus.ErrorCode := WORD_TO_INT(SWAP_WORD(IN := #sw_ErrorCode));
	        END_IF;
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Check if configuration is ok for commissioning purposes
	    
	    // Validate the VFD configuration and motor number.
	    IF #i_UDT_VFDConfiguration.MaximumSpeed > 0.0
	    THEN
	        #sx_ConfigurationError := FALSE;
	    ELSE
	        #sx_ConfigurationError := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 8 - Handle speed
	    
	    // Write max speed to static.
	    #sr_MaximumSpeed := #i_UDT_VFDConfiguration.MaximumSpeed;
	    
	    // Use correction factor to calculate setpint for diaginal use
	    #sr_SpeedsetpointCorrected := INT_TO_REAL(#iq_UDT_ConveyorInterface.SpeedSetpoint) * #i_UDT_VFDConfiguration.CorrectionFactor;
	    
	    // Actual speed setpoint
	    #si_RequiredSpeedSetpoint := REAL_TO_INT((#sr_SpeedsetpointCorrected * 100.0) / (#sr_MaximumSpeed));
	    
	    // Speed setpoint saturation in case when the speed setpoint is higher than the max speed.
	    IF #si_RequiredSpeedSetpoint > 100
	    THEN
	        #si_RequiredSpeedSetpoint := 100;
	        #iq_UDT_ConveyorInterface.ConfigurationError := TRUE;
	    ELSIF #si_RequiredSpeedSetpoint < -100
	    THEN
	        #si_RequiredSpeedSetpoint := -100;
	        #iq_UDT_ConveyorInterface.ConfigurationError := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 9 - Prepare output data VFD
	    
	    REGION 9.1 - Set speed setpoint in forward and reverse direction 
	        // Get rising edge of Run forward and reverse signal.
	        #s_R_TRIG_RunForward(CLK := #iq_UDT_ConveyorInterface.RunFwd);
	        #s_R_TRIG_RunReverse(CLK := #iq_UDT_ConveyorInterface.RunRvs);
	        
	        // When rising edge of the forward or reverse signal is received, the drive has to stop to be able to make the switch.
	        IF #s_R_TRIG_RunForward.Q
	            OR #s_R_TRIG_RunReverse.Q
	        THEN
	            #qsi_UDT_VFDSpeed := 0;
	        END_IF;
	        
	        // If motor stopped and Run forward is requested and forward direction is interlock, set run forward signal and reset run reverse signal.
	        IF //#ssi_MotorSpeed = 0 and
	            #iq_UDT_ConveyorInterface.RunFwd
	            AND #i_UDT_VFDConfiguration.InterlockFwd
	        THEN
	            #sx_RunVFDForward := TRUE;
	            #sx_RunVFDReverse := FALSE;
	        END_IF;
	        
	        // If motor stopped and Run reverse is requested and reverse direction is interlock, set run reverse signal and reset run forward signal.
	        IF // #ssi_MotorSpeed = 0 AND
	            #iq_UDT_ConveyorInterface.RunRvs
	            AND #i_UDT_VFDConfiguration.InterlockRvs
	        THEN
	            #sx_RunVFDReverse := TRUE;
	            #sx_RunVFDForward := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 9.2 - Stopping
	        
	        // Stop the VFD if one of the following conditions is met.
	        IF (NOT #iq_UDT_ConveyorInterface.RunRvs AND NOT #iq_UDT_ConveyorInterface.RunFwd)
	            OR (#iq_UDT_ConveyorInterface.RunRvs AND #iq_UDT_ConveyorInterface.RunFwd)
	            OR (#sx_RunVFDReverse AND NOT #i_UDT_VFDConfiguration.InterlockRvs)
	            OR (#sx_RunVFDForward AND NOT #i_UDT_VFDConfiguration.InterlockFwd)
	            OR ((#s_R_TRIG_RunForward.Q AND #ssi_MotorSpeed < 0)
	            OR (#s_R_TRIG_RunReverse.Q AND #ssi_MotorSpeed > 0))
	        THEN
	            #sx_RunVFDReverse := FALSE;
	            #sx_RunVFDForward := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 9.3 - Check for enable operation signal
	        
	        // Operation is enable when VFD is available and there is one of the run commands.
	        #sx_EnableOperation :=
	        #sx_VFD_Available
	        AND (#sx_RunVFDForward OR #sx_RunVFDReverse)
	        AND NOT #sx_ConfigurationError;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 10 - Write outputs to VFD  
	    
	    REGION 10.1 - Write speed setpoint to drive
	        
	        // The conveyor stopped and may now run in forward direction.
	        IF ((#sx_RunVFDForward AND NOT #i_UDT_VFDConfiguration.DirectionReversal)
	            OR (#sx_RunVFDReverse AND #i_UDT_VFDConfiguration.DirectionReversal))
	            AND #sx_EnableOperation
	        THEN
	            #qsi_UDT_VFDSpeed := INT_TO_SINT(#si_RequiredSpeedSetpoint);
	        END_IF;
	        
	        // The conveyor stopped and may now run in reverse direction.
	        IF ((#sx_RunVFDReverse AND NOT #i_UDT_VFDConfiguration.DirectionReversal)
	            OR (#sx_RunVFDForward AND #i_UDT_VFDConfiguration.DirectionReversal))
	            AND #sx_EnableOperation
	        THEN
	            #qsi_UDT_VFDSpeed := - INT_TO_SINT(#si_RequiredSpeedSetpoint);
	        END_IF;
	        
	        // Clear speed setpoint when run isn't request.
	        IF (NOT #sx_RunVFDForward
	            AND NOT #sx_RunVFDReverse)
	            OR NOT #sx_EnableOperation
	        THEN
	            #qsi_UDT_VFDSpeed := 0;
	        END_IF;
	        
	    END_REGION
	    
	    
	    REGION 10.2 - Calculate acceleration and deceleration values
	        
	        // Recalculating Acceleration ramp - deviding maximum configured speed by Ramp up time and devide it by 1000.
	        #si_AccelerationSetpoint := REAL_TO_INT(#sr_MaximumSpeed / (UDINT_TO_REAL(#i_UDT_VFDConfiguration.VFDRampUpTime) / 1000.0));
	        
	        // Recalculating Deceleration ramp - deviding maximum configured speed by Ramp down time and devide it by 1000.
	        #si_DecelerationSetpoint := REAL_TO_INT(#sr_MaximumSpeed / (UDINT_TO_REAL(#i_UDT_VFDConfiguration.VFDRampDownTime) / 1000.0));
	        
	    END_REGION
	    
	    REGION 10.3 - Write acceleration to drive
	        
	        
	        REGION 10.3.1 - Acceleration write operation is done.
	            
	            IF #ss_AccelerationDone.All
	            THEN
	                // There is new acceleration value or device is offline.
	                IF #si_AccelerationSetpoint <> #si_AccelerationOld
	                    OR NOT #s_UDT_HMIStatus.PNSlaveNotonline
	                THEN
	                    // Reset the accleration operation done signal.
	                    #ss_AccelerationDone.Motor_1 := FALSE;
	                    #ss_AccelerationDone.Motor_2 := FALSE;
	                    #ss_AccelerationDone.Motor_3 := FALSE;
	                    #ss_AccelerationDone.Motor_4 := FALSE;
	                    #ss_AccelerationDone.All := FALSE;
	                END_IF;
	            END_IF;
	            
	        END_REGION
	        
	        
	        // The acceleration operation isn't done or there is first scan and device is online.
	        IF (NOT #ss_AccelerationDone.All OR "mx_FirstScan")
	            AND NOT #s_UDT_HMIStatus.PNSlaveNotonline
	        THEN
	            
	            //Set motor number
	            IF NOT #ss_AccelerationDone.Motor_1 THEN
	                #si_MotorNumber_Acc := 1;
	            ELSIF NOT #ss_AccelerationDone.Motor_2 THEN
	                #si_MotorNumber_Acc := 2;
	            ELSIF NOT #ss_AccelerationDone.Motor_3 THEN
	                #si_MotorNumber_Acc := 3;
	            ELSIF NOT #ss_AccelerationDone.Motor_4 THEN
	                #si_MotorNumber_Acc := 4;
	            ELSE
	                #si_MotorNumber_Acc := 0;
	            END_IF;
	            
	            // There isn't an  acceleration equal to 0.
	            IF #si_AccelerationSetpoint > 0 THEN
	                
	                // Calculate the index of the acceleration.
	                #ss_WRREC.Acceleration.Index := #cdi_AccelerationIndex + #si_MotorNumber_Acc;
	                // Prepare the data.
	                #ss_WRREC.Acceleration.Data := SWAP(INT_TO_WORD(#si_AccelerationSetpoint));
	                // Set operation is required.
	                #ss_WRREC.Acceleration.REQ := TRUE;
	                
	                // Send acceleration to the device.
	                #s_WRREC_ACC(REQ := #ss_WRREC.Acceleration.REQ,
	                             ID := #shw_VFD_Telegram,
	                             INDEX := #ss_WRREC.Acceleration.Index,
	                             LEN := 0,
	                             DONE => #ss_WRREC.Acceleration.Done,
	                             BUSY => #ss_WRREC.Acceleration.Busy,
	                             ERROR => #ss_WRREC.Acceleration.Error,
	                             STATUS => #ss_WRREC.Acceleration.Status,
	                             RECORD := #ss_WRREC.Acceleration.Data);
	                
	                // Send operation is done.
	                IF #ss_WRREC.Acceleration.Done
	                THEN
	                    // Reset operation is required bit.
	                    #ss_WRREC.Acceleration.REQ := FALSE;
	                    
	                    // Set the operation is done signal.
	                    CASE #si_MotorNumber_Acc OF
	                        1:
	                            #ss_AccelerationDone.Motor_1 := TRUE;
	                            
	                        2:
	                            #ss_AccelerationDone.Motor_1 := TRUE;
	                            
	                        3:
	                            #ss_AccelerationDone.Motor_1 := TRUE;
	                            
	                        4:
	                            #ss_AccelerationDone.Motor_1 := TRUE;
	                            #ss_AccelerationDone.All := TRUE;
	                    END_CASE;
	                    
	                    // Write acceleration value into the old one.
	                    #si_AccelerationOld := #si_AccelerationSetpoint;
	                END_IF;
	            END_IF;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 10.4 - Write deceleration to drive
	        
	        // Deceleration write operation is done.
	        IF #ss_DecelerationDone.All
	        THEN
	            // There is new deceleration value or device is offline.
	            IF #si_DecelerationSetpoint <> #si_DecelerationOld
	                OR NOT #s_UDT_HMIStatus.PNSlaveNotonline
	            THEN
	                // Reset the deceleration operation done signal.
	                #ss_DecelerationDone.Motor_1 := FALSE;
	                #ss_DecelerationDone.Motor_2 := FALSE;
	                #ss_DecelerationDone.Motor_3 := FALSE;
	                #ss_DecelerationDone.Motor_4 := FALSE;
	                #ss_DecelerationDone.All := FALSE;
	                
	            END_IF;
	        END_IF;
	        
	        // The deceleration operation isn't done or there is first scan and device is online.
	        IF NOT #ss_DecelerationDone.All OR "mx_FirstScan"
	            AND NOT #s_UDT_HMIStatus.PNSlaveNotonline
	        THEN
	            // There isn't an  deceleration equal to 0.
	            IF #si_DecelerationSetpoint > 0 THEN
	                
	                //Set motor number
	                IF NOT #ss_DecelerationDone.Motor_1 THEN
	                    #si_MotorNumber_Dec := 1;
	                ELSIF NOT #ss_DecelerationDone.Motor_2 THEN
	                    #si_MotorNumber_Dec := 2;
	                ELSIF NOT #ss_DecelerationDone.Motor_3 THEN
	                    #si_MotorNumber_Dec := 3;
	                ELSIF NOT #ss_DecelerationDone.Motor_4 THEN
	                    #si_MotorNumber_Dec := 4;
	                ELSE
	                    #si_MotorNumber_Dec := 0;
	                END_IF;
	                
	                // Calculate the index of the deceleration.
	                #ss_WRREC.Deceleration.Index := #cdi_DecelerationIndex + #si_MotorNumber_Dec;
	                // Prepare the data.
	                #ss_WRREC.Deceleration.Data := SWAP(INT_TO_WORD(#si_DecelerationSetpoint));
	                // Set operation is required.
	                #ss_WRREC.Deceleration.REQ := TRUE;
	                
	                // Send deceleration to the device.
	                #s_WRREC_DEC(REQ := #ss_WRREC.Deceleration.REQ,
	                             ID := #shw_VFD_Telegram,
	                             INDEX := #ss_WRREC.Deceleration.Index,
	                             LEN := 0,
	                             DONE => #ss_WRREC.Deceleration.Done,
	                             BUSY => #ss_WRREC.Deceleration.Busy,
	                             ERROR => #ss_WRREC.Deceleration.Error,
	                             STATUS => #ss_WRREC.Deceleration.Status,
	                             RECORD := #ss_WRREC.Deceleration.Data);
	                
	                // Send operation is done.
	                IF #ss_WRREC.Deceleration.Done
	                THEN
	                    // Reset operation is required bit.
	                    #ss_WRREC.Deceleration.REQ := FALSE;
	                    
	                    // Set the operation is done signal.
	                    CASE #si_MotorNumber_Dec OF
	                        1:
	                            #ss_DecelerationDone.Motor_1 := TRUE;
	                            
	                        2:
	                            #ss_DecelerationDone.Motor_1 := TRUE;
	                            
	                        3:
	                            #ss_DecelerationDone.Motor_1 := TRUE;
	                            
	                        4:
	                            #ss_DecelerationDone.Motor_1 := TRUE;
	                            #ss_DecelerationDone.All := TRUE;
	                    END_CASE;
	                    
	                    // Write deceleration value into the old one.
	                    #si_DecelerationOld := #si_DecelerationSetpoint;
	                END_IF;
	            END_IF;
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 11 - Copy signals to interface DB and to status output UDT
	    
	    // Create collective error.
	    #sx_ErrorActive :=
	    #s_UDT_HMIStatus.PNSlaveNotonline
	    OR #s_UDT_HMIStatus.PNSlaveError
	    OR #s_UDT_HMIStatus.InternalError
	    OR #sx_ConfigurationError;
	    
	    // Motor is giving direct signal on start, move setpoint to actual speed.                                                                                    
	    IF #ssi_MotorSpeed <> 0
	    THEN
	        #si_ActualSpeed := #iq_UDT_ConveyorInterface.SpeedSetpoint;
	        #sx_SpeedSetpointReached := TRUE;
	    ELSE
	        #si_ActualSpeed := 0;
	        #sx_SpeedSetpointReached := FALSE;
	    END_IF;
	    
	    // Write interface bits.
	    #iq_UDT_ConveyorInterface.VFDRunning :=
	    #sx_VFD_Available
	    AND #iq_UDT_ConveyorInterface.ActualSpeed <> 0;
	    
	    // Speed setpoint is reached.
	    #iq_UDT_ConveyorInterface.VFDatSpeed :=
	    #sx_SpeedSetpointReached
	    AND #sx_VFD_Available;
	    
	    // Set the internal VFD error bit if any fault is active.
	    #iq_UDT_ConveyorInterface.InternalErrorVFD := #sx_ErrorActive;
	    // Copy the speed value to the output.
	    #iq_UDT_ConveyorInterface.ActualSpeed := #si_ActualSpeed;
	    
	    // Copy error status to output.
	    #q_UDT_HMIStatus := #s_UDT_HMIStatus;
	    
	END_REGION
	
	REGION 12 - Statistics
	    
	    // Create trigger on error and create statistics for profinet slave not online.
	    #s_R_TRIG_PNSlaveNotOnline(CLK := #s_UDT_HMIStatus.PNSlaveNotonline);
	    
	    IF #iq_UDT_ConveyorInterface.ResetStatistics
	        OR #s_UDT_HMIStatus.PNSlaveNotonline
	    THEN
	        "FC_Statistics"(ix_Reset := #iq_UDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #s_UDT_HMIStatus.PNSlaveNotonline,
	                        ix_RTrigActivate := #s_R_TRIG_PNSlaveNotOnline.Q,
	                        iqUDT_Statistics := #iq_UDT_VFDStatistics.PNSlaveNotOnline);
	    END_IF;
	    
	    // Create trigger on error and create statistics for profinet slave error.
	    #s_R_TRIG_PNSlaveError(CLK := #s_UDT_HMIStatus.PNSlaveError);
	    
	    IF #iq_UDT_ConveyorInterface.ResetStatistics
	        OR #s_UDT_HMIStatus.PNSlaveError
	    THEN
	        "FC_Statistics"(ix_Reset := #iq_UDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #s_UDT_HMIStatus.PNSlaveError,
	                        ix_RTrigActivate := #s_R_TRIG_PNSlaveError.Q,
	                        iqUDT_Statistics := #iq_UDT_VFDStatistics.PNSlaveError);
	    END_IF;
	    
	    IF #iq_UDT_ConveyorInterface.ResetStatistics
	        OR #s_UDT_HMIStatus.InternalError
	    THEN
	        "FC_Statistics"(ix_Reset := #iq_UDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #s_UDT_HMIStatus.InternalError,
	                        ix_RTrigActivate := #s_R_TRIG_InternalError.Q,
	                        iqUDT_Statistics := #iq_UDT_VFDStatistics.VFDInternalError);
	    END_IF;
	    
	    // Create trigger on running signal and create statistics for running status.
	    #s_R_TRIG_Running(CLK := #iq_UDT_ConveyorInterface.VFDRunning);
	    
	    IF #iq_UDT_ConveyorInterface.ResetStatistics
	        OR #iq_UDT_ConveyorInterface.VFDRunning
	    THEN
	        "FC_Statistics"(ix_Reset := #iq_UDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #iq_UDT_ConveyorInterface.VFDRunning,
	                        ix_RTrigActivate := #s_R_TRIG_Running.Q,
	                        iqUDT_Statistics := #iq_UDT_VFDStatistics.Running);
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

TYPE "UDT_ConveyorHandshake"
TITLE = UDT_ConveyorHandshake
VERSION : 0.1
//User-defined structure of conveyor handshake variables.
   STRUCT
      GIN : Int;   // General identification number
      NrOfPosToShift : Int;   // Number of positions to shift
      DownstreamDisplacement : Int;   // Displacement from downstream [cm]
      RTS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor ready to send
      RTR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor ready to receive
      TIP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Transfer in progress
      ResetEnergySave { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset energy save mode
      CascadeStartUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Cascade startup
      ReqStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request stop
   END_STRUCT;

END_TYPE

TYPE "UDT_OutfeedStatus"
VERSION : 0.1
   STRUCT
      ID : UInt := 0;   // ID
      NotAvailable : Bool;   // Collect signal - TRUE when outfeed not available
      Full : Bool;   // Outfeed full , impossible to send next parcels.
      Disable : Bool;   // Deactivated by the operator from the HMI or MFC
   END_STRUCT;

END_TYPE

TYPE "UDT_ArmDiverterConfiguration"
VERSION : 0.1
   STRUCT
      VerticalConveyorMode : Int;   // [1]Continuous operation if the main conveyor is running; [2]Operation if arm is not in Home position.
      ArmDiverterSpeedSetpointLow : Int;   // Arm diverter low speed setpoint [mm/s]
      ArmDiverterSpeedSetpointNominal : Int;   // Arm diverter nominal speed setpoint [mm/s]
      DischargeLocationID : UInt;   // Discharge Location ID
      OutfeedsNumber : UInt;   // OutfeedsNumber [1 ..5]
      DecisionPoint : Int;   // Decision Point - Distance from the end of the conveyor [cm]
      DecisionParcelWindow : Int;   // Decision window - Maximum distance from the beginning of the parcel to the "Decision point"
      AssociatedConveyorLength : DInt;   // Associated conveyor length
      ParcelFreeWindow : Int;   // Distance from the end of the parcel that must be left empty to sort the parcel correctly
      ParcelFreeWindowStart : Int;   // Start point in tracking data -  Window in which the package must not be in order to start the arm [cm]
      ParcelFreeWindowEnd : Int;   // End point in tracking data - Window in which the package must not be in order to start the arm [cm]
      DataTransferPoint : Int;   // Transfer point to the exit conveyor [cm]
      MaximumMovementTime : UDInt;   // Maximum time to move [ms]
      JogNoHornTime : UDInt;   // Time within jog buttons can be pressed without new startup indication [ms]
      MaximumParcelDivertTime : UDInt;   // Maximum parcel divert time [ms]
      Sensor : Struct   // Sensors on/off time configuration
         PRX_HomeTimeOnDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Proxy sensor home position on delay [ms]
         PRX_HomeTimeOffDelay : UDInt;   // Proxy sensor home position off delay [ms]
         PRX_DivertTimeOnDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Proxy sensor divert position on delay [ms]
         PRX_DivertTimeOffDelay : UDInt;   // Proxy sensor divert position off delay [ms]
         LS_HomeTimeOnDelay : UDInt;   // Limit switch home position on delay [ms]
         LS_HomeTimeOffDelay : UDInt;   // Limit switch home position off delay [ms]
         LS_DivertTimeOnDelay : UDInt;   // Limit switch divert position on delay [ms]
         LS_DivertTimeOffDelay : UDInt;   // Limit switch divert position off delay [ms]
         PRX_BRK_HomeTimeOnDelay : UDInt;   // Brake sensor home position on delay [ms]
         PRX_BRK_HomeTimeOffDelay : UDInt;   // Brake sensor home position off delay [ms]
         PRX_BRK_DivertTimeOnDelay : UDInt;   // Brake sensor divert position on delay [ms]
         PRX_BRK_DivertTimeOffDelay : UDInt;   // Brake sensor divert position off delay [ms]
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_ArmDiverterCommand"
VERSION : 0.1
   STRUCT
      ManualMode : Bool;   // Manual mode command from HMI
      ManualHomePosition : Bool;   // Manual mode command go to home position
      ManualDivertPosition : Bool;   // Manual mode command go to divert position
      JogHomePosition : Bool;   // Jog command go to home position
      JogDivertPosition : Bool;   // Jog command go to divert position
      Reset : Bool;   // Reset command
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_ConnectionCheck"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 3.2
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 205
// END_ATTRIBUTES
   VAR_INPUT 
      ib_Watchdog { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Input watchdog
      ix_Trigger100ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Cycled 100 ms trigger
   END_VAR

   VAR_OUTPUT 
      qb_Watchdog { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Generated watchdog
   END_VAR

   VAR_IN_OUT 
      iqudt_ConnectionStatus : "UDT_ConnectStatus";   // Connection status
   END_VAR

   VAR 
      s_FB_ConnectionFaultTimerOnDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Connection fault timer on delay
      sb_InWatchdogOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Watch dog old
      sb_GeneratedWatchdog { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Generated watchdog
      sx_SetConnectionFaultTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Set connection fault timer
      sx_ConnectionFault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Connection faulr
   END_VAR

   VAR CONSTANT 
      cudi_ConnectionFaultOnDelay : UDInt := 10000;   // Connection On Delay
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------   
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	31/03/2022  | 3.0       | M. Piela      | First release TIA 16
	06/09/2023  | 3.1       | S. Nikodem    | Added watchdog generations on output
	11/09/2023  | 3.2       | S. Theocharis | Corrected variable prefixes
	*)
	
	REGION 1 - Connection check
	    
	    #sx_SetConnectionFaultTimer := (#ib_Watchdog = #sb_InWatchdogOld);
	    
	    IF #ib_Watchdog <> #sb_InWatchdogOld
	    THEN
	        #sb_InWatchdogOld := #ib_Watchdog;
	    END_IF;
	    
	    #s_FB_ConnectionFaultTimerOnDelay(iudi_OnDelayTime := #cudi_ConnectionFaultOnDelay,
	                                      ix_SignalToDelay := #sx_SetConnectionFaultTimer,
	                                      ix_Enable := TRUE,
	                                      qx_DelayedSignal => #sx_ConnectionFault);
	    
	END_REGION
	
	REGION 2 - Status update
	    
	    #iqudt_ConnectionStatus.Specific.CommunicationFault := #sx_ConnectionFault;
	    #iqudt_ConnectionStatus.Specific.Connected := NOT #sx_ConnectionFault;
	    
	    IF #sx_ConnectionFault
	    THEN
	        #iqudt_ConnectionStatus.Status := "DB_HMIStatusConfiguration".CommunicationError;
	    END_IF;
	    
	    IF NOT #sx_ConnectionFault
	    THEN
	        #iqudt_ConnectionStatus.Status := "DB_HMIStatusConfiguration".AutoON;
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Watchdog generations
	    
	    //Watchdog counter to be updated after every 100 msec
	    IF #ix_Trigger100ms THEN
	        
	        IF #sb_GeneratedWatchdog >= 255 OR #sb_GeneratedWatchdog < 0
	        THEN
	            #sb_GeneratedWatchdog := 0;
	        END_IF;
	        
	        #sb_GeneratedWatchdog := INT_TO_BYTE(BYTE_TO_INT(#sb_GeneratedWatchdog) + 1);
	        
	    END_IF;
	    
	    //Copy value
	    #qb_Watchdog := #sb_GeneratedWatchdog;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MFC_Sort_COY_RegInfo"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 116
// END_ATTRIBUTES
   VAR_INPUT 
      is_ObjectID : String[10];   // Parcel identifier
      ii_XrayLocation : Int;   // X-ray location
      ii_SourceNode : Int;   // ID Source Node
      ii_DestinationNode : Int;   // ID Destination Node
   END_VAR

   VAR_OUTPUT 
      qx_Error : Bool;   // TRUE when collective block error occurred
      qx_Warning : Bool;   // TRUE when collective block warning occurred
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqa_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqi_MessageSequenceNumber : Int;   // Message number
   END_VAR

   VAR 
      ss_FB_HeartbeatPulse : "FB_Pulse";   // Heartbeat send pulse generator
      s_UDT_MessageArray : "UDT_MessageV2";   // Message array byte
      s_UDT_MessageHeader : "UDT_MFCSortMessageHeader";   // Message header
      ss_MessageBody : Struct   // Message body
         MsgID : Word;   // Message ID
         MsgLength : Word;   // Message length
         ObjectID : DWord;   // Parcel identifier
         XrayLocation : Word;
         Eom : Byte;   // End of message
      END_STRUCT;
      ss_Status : Struct   // Status structure
         FIFOStatus : "UDT_FifoStatus";
         FIFOError { S7_SetPoint := 'True'} : Bool;   //  FIFO error
         FIFOWarning { S7_SetPoint := 'True'} : Bool;   // FIFO warning
         InvalidMessageArraySize : Bool;   // Message array is too short for message
         InvalidTimeInterval : Bool;   // Heartbeat time interval lower than zero
      END_STRUCT;
      si_Old_Object_ID : String[10];   // Value from previous PLC cycle
      sdi_SerializePosition : DInt;   // Position in array where serialize finished writing data +1
      si_MaximumMessageLength : Int;   // Maximum number of elements in message array
      si_SerializeStatus : Int;   // Function serialize status
      sx_NewData : Bool;   // True - send a message to the MFC
   END_VAR

   VAR_TEMP 
      tudi_Temp : UDInt;   // temporarry variable
   END_VAR

   VAR CONSTANT 
      ci_MessageLength : Word := 16#0008;   // 10#0008 = 16#0008 - Message length
      ci_MsgID : Word := 16#0136;   // 10#0310 = 16#0136 - Message ID
      ci_MsgLength : Word := 16#0004;   // 10#0004 = 16#0004 - Message length
      ci_Som : Byte := 16#FD;   // Start of message
      ci_Eom : Byte := 16#FE;   // End of message
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	24/05/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec  | Updated for new Baseline
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOStatus,
	              qx_Error => #ss_Status.FIFOError,
	              qx_Warning => #ss_Status.FIFOWarning,
	              iqv_Data := #s_UDT_MessageArray,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqa_FifoData);
	    
	END_REGION
	
	REGION 2 – Data preparation
	    
	    //Send message when is new parcel
	    #sx_NewData := (#is_ObjectID <> #si_Old_Object_ID) AND NOT (#is_ObjectID = '');
	    // Save last value
	    #si_Old_Object_ID := #is_ObjectID;
	    
	END_REGION
	
	REGION 3 – Message array size validation 
	    
	    // Get size of the array.
	    #si_MaximumMessageLength := "FC_GetNrOfArrayEl"(#s_UDT_MessageArray.Bytes);
	    
	    // Message array size validation. 
	    #ss_Status.InvalidMessageArraySize := WORD_TO_INT(#ci_MessageLength) > #si_MaximumMessageLength;
	    
	END_REGION
	
	
	REGION 4 – Message preparation 
	    
	    // FIFO full check.
	    IF NOT #iq_UDT_FifoHeader.Status.Full
	    THEN
	        // Errors and send pulse check.
	        IF NOT #ss_Status.FIFOError
	            AND NOT #ss_Status.InvalidMessageArraySize
	            AND #sx_NewData
	        THEN
	            
	            REGION 4.1 – Header preparation 
	                
	                // Check sequence number. If it is equal or greater than 255 reset it to 1.
	                IF #iqi_MessageSequenceNumber <= 255
	                THEN
	                    #iqi_MessageSequenceNumber += 1;
	                ELSE
	                    #iqi_MessageSequenceNumber := 1;
	                END_IF;
	                
	                // Write parts of the header into structure.
	                #s_UDT_MessageHeader.SOM := #ci_Som;
	                #s_UDT_MessageHeader.SourceNode := INT_TO_BYTE(#ii_SourceNode);
	                #s_UDT_MessageHeader.DestinationNode := INT_TO_BYTE(#ii_DestinationNode);
	                #s_UDT_MessageHeader.SeqNumber := INT_TO_BYTE(#iqi_MessageSequenceNumber);
	                #s_UDT_MessageHeader.DataLength := #ci_MessageLength;
	                #s_UDT_MessageHeader.NumMsg := 1;
	                
	                //Convert string value to UDINT
	                #tudi_Temp := STRING_TO_UDINT(#is_ObjectID);
	                
	                // Write parts of the body into structure.
	                #ss_MessageBody.MsgID := #ci_MsgID;
	                #ss_MessageBody.MsgLength := #ci_MsgLength;
	                #ss_MessageBody.ObjectID := UDINT_TO_DWORD(#tudi_Temp);
	                #ss_MessageBody.XrayLocation := INT_TO_WORD(#ii_XrayLocation);
	                #ss_MessageBody.Eom := #ci_Eom;
	                
	            END_REGION
	            
	            REGION 4.2 – Convert message into array of bytes
	                
	                // Initialize the header serialize position and convert header structure into array of bytes.
	                #sdi_SerializePosition := 0;
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #s_UDT_MessageHeader,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	                // Initialize the body serialize position and convert header structure into array of bytes
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #ss_MessageBody,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	            END_REGION
	            
	            REGION 4.3 – Write message into the FIFO buffer
	                
	                // Mode 'W' - Write FIFO record.
	                "FC_Fifo"(ic_Mode := 'W',
	                          qUDT_Status => #ss_Status.FIFOStatus,
	                          qx_Error => #ss_Status.FIFOError,
	                          qx_Warning => #ss_Status.FIFOWarning,
	                          iqv_Data := #s_UDT_MessageArray,
	                          iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	                          iqv_DataBuffer := #iqa_FifoData);
	                
	            END_REGION
	            
	        END_IF;
	    ELSE
	        // If FIFO is full set FIFO main and FIFO full errors.
	        #ss_Status.FIFOError := TRUE;
	        #ss_Status.FIFOStatus.FifoFull := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Status
	    
	    // Parametrization collective error output.
	    #qx_Error :=
	    #ss_Status.FIFOError
	    OR #ss_Status.InvalidTimeInterval
	    OR #ss_Status.InvalidMessageArraySize;
	    
	    // Parametrization collective warning output.
	    #qx_Warning := #ss_Status.FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

TYPE "UDT_DownStream_Sorter_Common"
VERSION : 0.1
   STRUCT
      Watchdog { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;
      FireAlarm : Bool;
   END_STRUCT;

END_TYPE

TYPE "UDT_Sorter_DownStream_Common"
VERSION : 0.1
   STRUCT
      Watchdog { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;
      AvailableCarriers { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      SignalManagement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_MFC_Sort_SortResult"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 124
// END_ATTRIBUTES
   VAR_INPUT 
      is_ObjectID : String[10];   // Parcel identifier
      ii_DischargeLocation : UInt;   // Discharge location identifier
      ii_Result : Int;   // 1 = Sorted, 2 = Rejected, 3 = Lost
      ii_Reason : Int;   // 0 = Unknown, 1 = Success, 2 = Chute full, 3 = Chute not available, 4 = Unload failed, 5 = Late destination, 6 = Item lost, 7 = Higher priority available
      ii_SourceNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 0;   // Source Node
      ii_DestinationNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 0;   // Destination Node
   END_VAR

   VAR_OUTPUT 
      qx_Error : Bool;   // TRUE when collective block error occurred
      qx_Warning : Bool;   // TRUE when collective block warning occurred
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber : Int;   // Message number
   END_VAR

   VAR 
      s_UDT_MessageArray : "UDT_MessageV2";   // Message array byte
      s_UDT_MessageHeader : "UDT_MFCSortMessageHeader";   // Message header
      ss_MessageBody : Struct   // Message body
         MsgID : Word;   // Message ID
         MsgLength : Word;   // Message length
         Object_ID : String[10];   // Parcel identifier
         DischargeLocation : Word;   // Discharge location identifier
         Result : Byte;   // 0 = Sorted, 1 = Rejected, 2 = Lost
         Reason : Byte;   // 0 = Success, 1 = Chute full, 2 = Chute not available, 3 = Unload failed, 4 = Late destination, 5 = Item lost, 6 = Unknown
         Eom : Byte;   // End of message
      END_STRUCT;
      ss_Status : Struct   // Status structure
         FIFOStatus : "UDT_FifoStatus";
         FIFOError { S7_SetPoint := 'True'} : Bool;   //  FIFO error
         FIFOWarning { S7_SetPoint := 'True'} : Bool;   // FIFO warning
         InvalidMessageArraySize : Bool;   // Message array is too short for message
         InvalidTimeInterval : Bool;   // Heartbeat time interval lower than zero
      END_STRUCT;
      sdi_SerializePosition : DInt;   // Position in array where serialize finished writing data +1
      si_MaximumMessageLength : Int;   // Maximum number of elements in message array
      si_SerializeStatus : Int;   // Function serialize status
   END_VAR

   VAR CONSTANT 
      ci_MessageLength : Word := 16#000C;   // 10#0012 = 16#000C - Message length
      ci_Som : Byte := 16#FD;   // Start of message
      ci_Eom : Byte := 16#FE;   // End of message
      ci_MsgID : Word := 16#00CB;   // 10#0203 = 16#00CB - Message ID
      ci_MsgLength : Word := 16#0008;   // 10#0008 = 16#0008 - Message length
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	29/06/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec  | Updated for new Baseline
	02/05/2024  | 1.2       | J.Majer      | Datatype conversions changed from automatic to explicit, to accomodate IEC 61131-3 standard
	
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOStatus,
	              qx_Error => #ss_Status.FIFOError,
	              qx_Warning => #ss_Status.FIFOWarning,
	              iqv_Data := #s_UDT_MessageArray,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 2 – Data preparation
	    
	END_REGION
	
	REGION 3 – Message array size validation 
	    
	    // Get size of the array.
	    #si_MaximumMessageLength := "FC_GetNrOfArrayEl"(#s_UDT_MessageArray.Bytes);
	    
	    // Message array size validation. 
	    #ss_Status.InvalidMessageArraySize := WORD_TO_INT(#ci_MessageLength) > #si_MaximumMessageLength;
	    
	END_REGION
	
	REGION 4 – Message preparation 
	    
	    // FIFO full check.
	    IF NOT #iq_UDT_FifoHeader.Status.Full
	    THEN
	        // Errors and send pulse check.
	        IF NOT #ss_Status.FIFOError
	            AND NOT #ss_Status.InvalidMessageArraySize
	        THEN
	            
	            REGION 4.1 – Header preparation 
	                
	                // Check sequence number. If it is equal or greater than 255 reset it to 1.
	                IF #iqdi_MessageSequenceNumber <= 255
	                THEN
	                    #iqdi_MessageSequenceNumber += 1;
	                ELSE
	                    #iqdi_MessageSequenceNumber := 1;
	                END_IF;
	                
	                // Write parts of the header into structure.
	                #s_UDT_MessageHeader.SOM := #ci_Som;
	                #s_UDT_MessageHeader.SourceNode := INT_TO_BYTE(#ii_SourceNode);
	                #s_UDT_MessageHeader.DestinationNode := INT_TO_BYTE(#ii_DestinationNode);
	                #s_UDT_MessageHeader.SeqNumber := INT_TO_BYTE(#iqdi_MessageSequenceNumber);
	                #s_UDT_MessageHeader.DataLength := #ci_MessageLength;
	                #s_UDT_MessageHeader.NumMsg := 1;
	                
	                // Write parts of the body into structure.
	                #ss_MessageBody.MsgID := #ci_MsgID;
	                #ss_MessageBody.MsgLength := #ci_MsgLength;
	                #ss_MessageBody.Object_ID := #is_ObjectID;
	                #ss_MessageBody.DischargeLocation := UINT_TO_WORD(#ii_DischargeLocation);
	                #ss_MessageBody.Result := INT_TO_BYTE(#ii_Result);
	                #ss_MessageBody.Reason := INT_TO_BYTE(#ii_Reason);
	                #ss_MessageBody.Eom := #ci_Eom;
	                
	            END_REGION
	            
	            REGION 4.2 – Convert message into array of bytes
	                
	                // Initialize the header serialize position and convert header structure into array of bytes.
	                #sdi_SerializePosition := 0;
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #s_UDT_MessageHeader,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	                // Initialize the body serialize position and convert header structure into array of bytes
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #ss_MessageBody,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	            END_REGION
	            
	            REGION 4.3 – Write message into the FIFO buffer
	                
	                // Mode 'W' - Write FIFO record.
	                "FC_Fifo"(ic_Mode := 'W',
	                          qUDT_Status => #ss_Status.FIFOStatus,
	                          qx_Error => #ss_Status.FIFOError,
	                          qx_Warning => #ss_Status.FIFOWarning,
	                          iqv_Data := #s_UDT_MessageArray,
	                          iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	                          iqv_DataBuffer := #iqs_FifoData);
	                
	            END_REGION
	            
	        END_IF;
	    ELSE
	        // If FIFO is full set FIFO main and FIFO full errors.
	        #ss_Status.FIFOError := TRUE;
	        #ss_Status.FIFOStatus.FifoFull := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Status
	    
	    // Parametrization collective error output.
	    #qx_Error :=
	    #ss_Status.FIFOError
	    OR #ss_Status.InvalidTimeInterval
	    OR #ss_Status.InvalidMessageArraySize;
	    
	    // Parametrization collective warning output.
	    #qx_Warning := #ss_Status.FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

TYPE "UDT_SerialCommunicationSendStatus"
VERSION : 0.1
   STRUCT
      Done : Bool;   // Status from Send_P2P function
      Error : Bool;   // Status from Send_P2P function
      Status : Word;   // Status from Send_P2P function
      WrongMessageLength : Bool;   // Wrong prepared message length
   END_STRUCT;

END_TYPE

TYPE "UDT_ArmDiverterStatus"
VERSION : 0.1
   STRUCT
      Status : Int;   // Status number
      Specific : Struct   // Equipment specific warnings and errors
         TimeoutError : Bool;   // Arm movement timed out
         LimitHomeError : Bool;   // Limit swich sensor error
         LimitDivertError : Bool;   // Limit swich sensor error
         PXHomeError : Bool;   // Proxy sensor error
         PXDivertError : Bool;   // Proxy sensor error
         AtHomePosition : Bool;   // Arm is in home position
         AtDivertPosition : Bool;   // Arm is in divert position
         ReferencError : Bool;   // Referencing error - the arm is not detected by any sensor.
         ParcelDivertError : Bool;   // Parcel diversion error, time too long
         JamExitSensor : Bool;   // Jam on Exit sensor
      END_STRUCT;
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_MFC_Sort_VIDResponse_ASCII"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 129
// END_ATTRIBUTES
   VAR_INPUT 
      is_ObjectID : String[10];   // Parcel identifier
      ii_SorterID : Int;   // Sorter identifier
      i_ActualTimeDTL {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;   // Actual date and time in DTL
   END_VAR

   VAR_OUTPUT 
      qx_Error : Bool;   // TRUE when collective block error occurred
      qx_Warning : Bool;   // TRUE when collective block warning occurred
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqs_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqdi_MessageSequenceNumber : Int;   // Message number
   END_VAR

   VAR 
      s_UDT_MessageArray : "UDT_MessageV2";   // Message array byte
      s_UDT_MessageHeader : "UDT_MFCSortMessageHeader";   // Message header
      ss_MessageBody : Struct   // Message body
         MsgID : Word;   // Message ID
         MsgLength : Word;   // Message length
         ObjectID : String[10];   // Parcel identifier
         VID : Array[0..15] of Byte;   // Virtual Item Identifier
         Eom : Byte;   // End of message
      END_STRUCT;
      ss_Status : Struct   // Status structure
         FIFOStatus : "UDT_FifoStatus";
         HTAReturn : Struct   // Status structure from HTA function
            Month : Word;   // HTA_Month
            Day : Word;   // HTA_Day
         END_STRUCT;
         FIFOError { S7_SetPoint := 'True'} : Bool;   //  FIFO error
         FIFOWarning { S7_SetPoint := 'True'} : Bool;   // FIFO warning
         InvalidMessageArraySize : Bool;   // Message array is too short for message
         InvalidTimeInterval : Bool;   // Heartbeat time interval lower than zero
         InvalidInputData : Bool;   // Input is not in range
      END_STRUCT;
      ss_VID : String;   // Virtual Item Identifier
      sa_VIDBytes : Array[1..16] of Byte;   // VID  - array with data in ASCII
      sdi_SerializePosition : DInt;   // Position in array where serialize finished writing data +1
      sdi_VIDCode : DInt;   // VID Code
      si_MaximumMessageLength : Int;   // Maximum number of elements in message array
      si_SerializeStatus : Int;   // Function serialize status
      ss_OldObjectID : String[10];   // Value from previous PLC cycle
      sx_NewData : Bool;   // True - prepare data and send a message to the MFC
   END_VAR

   VAR_TEMP 
      ts_StringDate : Struct   // Temporary memory with string value
         Year : String;
         Month : String;
         Day : String;
         SorterID : String;
         Code : String;
      END_STRUCT;
      ti_Loop : Int;   // Loop counter
      ti_ObjectID : UDInt;   // Parcel identifier
   END_VAR

   VAR CONSTANT 
      ci_MessageLength : Word := 16#0016;   // 10#0021 = 16#0016 - Message length
      ci_Som : Byte := 16#FD;   // Start of message
      ci_Eom : Byte := 16#FE;   // End of message
      ci_MsgID : Word := 16#00C9;   // 10#0201 = 16#00C9 - Message ID
      ci_MsgLength : Word := 16#0012;   // 10#0018 = 16#0012 - Message length
      ci_SourceNode : Int := 1;   // 1 - PLC ID Source Node
      ci_DestinationNode : Int := 2;   // 2 - MFC ID Destination Node
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	27/04/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec  | Updated for new Baseline
	02/05/2024  | 1.2       | J.Majer      | Datatype conversions changed from automatic to explicit, to accomodate IEC 61131-3 standard
	
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOStatus,
	              qx_Error => #ss_Status.FIFOError,
	              qx_Warning => #ss_Status.FIFOWarning,
	              iqv_Data := #s_UDT_MessageArray,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqs_FifoData);
	    
	END_REGION
	
	REGION 2 - Check input data if are if range
	    
	    //Convert 'is_ObjectID' to numeric variable
	    #ti_ObjectID := STRING_TO_UDINT(#is_ObjectID);
	    
	    IF (#ti_ObjectID < 0)
	        OR (#ii_SorterID < 0)
	        OR (#ii_SorterID > 99)
	    THEN
	        #ss_Status.InvalidInputData := True;
	    ELSE
	        #ss_Status.InvalidInputData := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 3 – Data preparation
	    
	    //Send message when is new parcel
	    #sx_NewData := (#is_ObjectID <> #ss_OldObjectID) AND NOT (#is_ObjectID = '0');
	    // Save last value
	    #ss_OldObjectID := #is_ObjectID;
	    
	END_REGION
	
	REGION 4 – Message array size validation 
	    
	    // Get size of the array.
	    #si_MaximumMessageLength := "FC_GetNrOfArrayEl"(#s_UDT_MessageArray.Bytes);
	    
	    // Message array size validation. 
	    #ss_Status.InvalidMessageArraySize := WORD_TO_INT(#ci_MessageLength) > #si_MaximumMessageLength;
	    
	END_REGION
	
	REGION 5 – Message preparation 
	    
	    // FIFO full check.
	    IF NOT #iq_UDT_FifoHeader.Status.Full
	    THEN
	        // Errors and send pulse check.
	        IF NOT #ss_Status.FIFOError
	            AND NOT #ss_Status.InvalidMessageArraySize
	            AND NOT #ss_Status.InvalidInputData
	            AND #sx_NewData
	        THEN
	            
	            REGION 5.1 – VID preparation 
	                
	                // Convert the year into a character string
	                VAL_STRG(IN := #i_ActualTimeDTL.YEAR,
	                         SIZE := 4,
	                         PREC := 0,
	                         FORMAT := 0,
	                         P := 1,
	                         OUT => #ts_StringDate.Year);
	                
	                // Using the HTA function, convert date into a string format
	                #ss_Status.HTAReturn.Month := HTA(IN := WORD_TO_BYTE(INT_TO_BCD16((USINT_TO_INT(#i_ActualTimeDTL.MONTH)))), N := 1, OUT => #ts_StringDate.Month);   // Convert the month  
	                #ss_Status.HTAReturn.Day := HTA(IN := WORD_TO_BYTE(INT_TO_BCD16((USINT_TO_INT(#i_ActualTimeDTL.DAY)))), N := 1, OUT => #ts_StringDate.Day);         // Convert the day           
	                
	                //Convert Sorter ID value from number to string 
	                #ts_StringDate.SorterID := INT_TO_STRING(#ii_SorterID);
	                
	                //Delete sing '+' from string value
	                IF #ts_StringDate.SorterID[1] = '+' THEN
	                    #ts_StringDate.SorterID := DELETE(IN := #ts_StringDate.SorterID, L := 1, P := 1);
	                END_IF;
	                
	                //Add zero when the variable size is to small 
	                IF #ii_SorterID < 10 THEN
	                    #ts_StringDate.SorterID := INSERT(IN1 := #ts_StringDate.SorterID, IN2 := '0', P := 0);
	                END_IF;
	                
	                //Creat ID code - value 000 001 to 999 999
	                #sdi_VIDCode += 1;
	                
	                IF #sdi_VIDCode > 999999 THEN
	                    #sdi_VIDCode := 0;
	                END_IF;
	                
	                //Convert VID code value from number to string 
	                #ts_StringDate.Code := DINT_TO_STRING(#sdi_VIDCode);
	                
	                //Delete sing '+' from string 
	                IF #ts_StringDate.Code[1] = '+' THEN
	                    #ts_StringDate.Code := DELETE(IN := #ts_StringDate.Code, L := 1, P := 1);
	                END_IF;
	                
	                //Add zero when the variable size is to small
	                IF #sdi_VIDCode < 10 THEN
	                    #ts_StringDate.Code := INSERT(IN1 := #ts_StringDate.Code, IN2 := '00000', P := 0);
	                ELSIF #sdi_VIDCode < 100 THEN
	                    #ts_StringDate.Code := INSERT(IN1 := #ts_StringDate.Code, IN2 := '0000', P := 0);
	                ELSIF #sdi_VIDCode < 1000 THEN
	                    #ts_StringDate.Code := INSERT(IN1 := #ts_StringDate.Code, IN2 := '000', P := 0);
	                ELSIF #sdi_VIDCode < 10000 THEN
	                    #ts_StringDate.Code := INSERT(IN1 := #ts_StringDate.Code, IN2 := '00', P := 0);
	                ELSIF #sdi_VIDCode < 100000 THEN
	                    #ts_StringDate.Code := INSERT(IN1 := #ts_StringDate.Code, IN2 := '0', P := 0);
	                END_IF;
	                
	                //Combine strings
	                #ss_VID := (CONCAT(IN1 := #ts_StringDate.Year,
	                                   IN2 := #ts_StringDate.Month,
	                                   IN3 := #ts_StringDate.Day,
	                                   IN4 := #ts_StringDate.SorterID,
	                                   IN5 := #ts_StringDate.Code));
	                
	                //Convert string value to ASCII
	                FOR #ti_Loop := 1 TO 16 DO
	                    #sa_VIDBytes[#ti_Loop] := CHAR_TO_BYTE(#ss_VID[#ti_Loop]);
	                END_FOR;
	                
	            END_REGION
	            
	            REGION 5.2 – Header preparation 
	                
	                // Check sequence number. If it is equal or greater than 255 reset it to 1.
	                IF #iqdi_MessageSequenceNumber <= 255
	                THEN
	                    #iqdi_MessageSequenceNumber += 1;
	                ELSE
	                    #iqdi_MessageSequenceNumber := 1;
	                END_IF;
	                
	                // Write parts of the header into structure.
	                #s_UDT_MessageHeader.SOM := #ci_Som;
	                #s_UDT_MessageHeader.SourceNode := INT_TO_BYTE(#ci_SourceNode);
	                #s_UDT_MessageHeader.DestinationNode := INT_TO_BYTE(#ci_DestinationNode);
	                #s_UDT_MessageHeader.SeqNumber := INT_TO_BYTE(#iqdi_MessageSequenceNumber);
	                #s_UDT_MessageHeader.DataLength := #ci_MessageLength;
	                #s_UDT_MessageHeader.NumMsg := 1;
	                
	                // Write parts of the body into structure.
	                #ss_MessageBody.MsgID := #ci_MsgID;
	                #ss_MessageBody.MsgLength := #ci_MsgLength;
	                #ss_MessageBody.ObjectID := #is_ObjectID;
	                #ss_MessageBody.VID := #sa_VIDBytes;
	                #ss_MessageBody.Eom := #ci_Eom;
	                
	            END_REGION
	            
	            REGION 5.3 – Convert message into array of bytes
	                
	                // Initialize the header serialize position and convert header structure into array of bytes.
	                #sdi_SerializePosition := 0;
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #s_UDT_MessageHeader,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	                // Initialize the body serialize position and convert header structure into array of bytes
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #ss_MessageBody,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	            END_REGION
	            
	            REGION 5.4 – Write message into the FIFO buffer
	                
	                // Mode 'W' - Write FIFO record.
	                "FC_Fifo"(ic_Mode := 'W',
	                          qUDT_Status => #ss_Status.FIFOStatus,
	                          qx_Error => #ss_Status.FIFOError,
	                          qx_Warning => #ss_Status.FIFOWarning,
	                          iqv_Data := #s_UDT_MessageArray,
	                          iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	                          iqv_DataBuffer := #iqs_FifoData);
	                
	            END_REGION
	            
	        END_IF;
	    ELSE
	        // If FIFO is full set FIFO main and FIFO full errors.
	        #ss_Status.FIFOError := TRUE;
	        #ss_Status.FIFOStatus.FifoFull := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 6 - Status
	    
	    // Parametrization collective error output.
	    #qx_Error :=
	    #ss_Status.FIFOError
	    OR #ss_Status.InvalidTimeInterval
	    OR #ss_Status.InvalidMessageArraySize
	    OR #ss_Status.InvalidInputData;
	    
	    // Parametrization collective warning output.
	    #qx_Warning := #ss_Status.FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION "FC_EquipmentReport" : Void
TITLE = FC_Equipment_Report
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 16
// END_ATTRIBUTES
//Function to generate equipment report.
   VAR_INPUT 
      iUDT_Status : "UDT_CommonStatus";   // Status structure
   END_VAR

   VAR_IN_OUT 
      iqUDT_Control : "UDT_EquipmentControl";   // Equipment control
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | F.Baten       | first release MHS TIA 15.1
	17/06/2019  | 0.3       | L.Klar        | Manual mode added to "UDT_EquipmentControl"
	17/07/2019  | 0.4       | A.Nowak       | Add all statuses and comments
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	27/08/2019  | 2.1       | K.Pokorski    | Comments adjusted
	16/09/2019  | 2.2       | K.Pokorski    | Equipment error free condition added to "Restart required" status
	06/10/2019  | 2.3       | S. Deukar     | Updated accoring to new UDT equipment report
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	05/02/2024  | 3.1       | L.Klar        | Auto On extention added 
	13/03/2024  | 4.0       | S. Nieswiec   | Added to baseline
	*)
	
	REGION 1 - Equipment report update
	    
	    // Extension of stopped equipment report with the stopped status
	    #iqUDT_Control.Report.Stopped := #iUDT_Status.Stopped
	    OR #iqUDT_Control.Report.Stopped;
	    
	    // Extension of started equipment report with the started status
	    #iqUDT_Control.Report.Running := #iUDT_Status.Running
	    OR #iqUDT_Control.Report.Running;
	    
	    // Extension of energy save equipment report with the energy save status
	    #iqUDT_Control.Report.EnergySave := #iUDT_Status.EnergySave
	    OR #iqUDT_Control.Report.EnergySave;
	    
	    // Extension of warning equipment report with the warning status
	    #iqUDT_Control.Report.Warning := #iUDT_Status.Warning
	    OR #iqUDT_Control.Report.Warning;
	    
	    // Extension of manual mode equipment report with the manual mode status
	    #iqUDT_Control.Report.Manual := #iUDT_Status.Manual
	    OR #iqUDT_Control.Report.Manual;
	    
	    // Extension of error equipment report with the error status
	    #iqUDT_Control.Report.Error := #iUDT_Status.Error
	    OR #iqUDT_Control.Report.Error;
	    
	    // Extension of safety stop equipment report with the safety stop status
	    #iqUDT_Control.Report.SafetyStop := #iUDT_Status.SafetyStop
	    OR #iqUDT_Control.Report.SafetyStop;
	    
	    // Extension of Auto On equipment report with the Auto On status
	    #iqUDT_Control.Report.AutoON := #iUDT_Status.AutoON
	    OR #iqUDT_Control.Report.AutoON;
	    
	    // Extension of restart required equipment report with the restart required and no equipment error statuses
	    #iqUDT_Control.Request.RestartRequired := #iUDT_Status.Stopped
	    AND NOT #iUDT_Status.Error
	    OR #iqUDT_Control.Request.RestartRequired;
	    
	END_REGION
END_FUNCTION

FUNCTION "FC_TimeDiff" : Void
TITLE = FC_TimeDiff
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : GeneralSystemFunctions
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 28
// END_ATTRIBUTES
//Function to calculate time difference.
   VAR_INPUT 
      is_EarlierTimeAsString : String;   // Earlier time in string
      is_LaterTimeAsString : String;   // Later time in sting
   END_VAR

   VAR_OUTPUT 
      qt_TimeDifference : LTime;   // Difference between times
   END_VAR

   VAR_TEMP 
      tt_EarlierDate {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;   // Earlier date in DTL
      tt_LaterDate {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;   // Later date in DTL
      tt_LaterDateInc {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;   // Later date in DTL with one additional day
      tt_TimeDifference : LTime;   // Time differance
   END_VAR

   VAR CONSTANT 
      ct_OneDay : Time := T#1D;   // One day
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	24/05/2019  | 0.1       | K.Pokorski    | first release MHS TIA 15.1
	24/07/2019  | 2.0       | L.Klar        | 2.0 MHS library release TIA 15.1
	26/08/2019  | 2.1       | M.Kurpiers    | Comments adjusted
	06/09/2019  | 2.2       | M.Kurpiers    | Change in region 2. Correcting the names of inputs variables.
	21/10/2019  | 2.3       | P.Majka       | Logic changed in region 2 and 3. Simpler checking for the date changed
	12/11/2019  | 3.0       | P.Majka       | 3.0 MHS library release TIA 15.1
	21/02/2023  | 4.0       | F.Baten       | 4.0 Release TIA 17.5
	*)
	
	REGION 1 - Conversion string TO DTL
	    
	    // Using MHS "FC_StringToTime" standard function convert time in string format to date in DTL format
	    "FC_StringToTime"(is_StringTime := #is_EarlierTimeAsString,
	                      qt_Date => #tt_EarlierDate);
	    
	    "FC_StringToTime"(is_StringTime := #is_LaterTimeAsString,
	                      qt_Date => #tt_LaterDate);
	    
	END_REGION
	
	REGION 2 - Difference between times   
	    
	    // Calculate difference between times
	    #tt_TimeDifference := #tt_LaterDate - #tt_EarlierDate;
	    
	    // Checking the negativity in the time difference                                              
	    IF (LTIME_TO_DINT(#tt_TimeDifference) < 0)
	    THEN
	        
	        // Add one day to later date - later time is smaller than ealier time 
	        #tt_LaterDateInc := T_ADD(IN1 := #tt_LaterDate, IN2 := #ct_OneDay);
	        
	        // Calculate difference between times 
	        #tt_TimeDifference := #tt_LaterDateInc - #tt_EarlierDate;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Write outputs
	    
	    // Saving time difference to the output    
	    #qt_TimeDifference := #tt_TimeDifference;
	    
	END_REGION
END_FUNCTION

TYPE "UDT_XrayCommand"
VERSION : 0.1
   STRUCT
      TransportModeOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command to active the Transport mode
      TransportModeOff { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command to deactivate the Transport mode
   END_STRUCT;

END_TYPE

TYPE "UDT_SerialCommunicationReceiveStatus"
VERSION : 0.1
   STRUCT
      NRD : Bool;   // Status from Send_P2P function
      Erro : Bool;   // Status from Send_P2P function
      Status : Word;   // Status from Send_P2P function
      Leng : UInt;   // Status from Send_P2P function
   END_STRUCT;

END_TYPE

TYPE "UDT_ABSwitchStatistics"
TITLE = UDT_VSUStatistics
VERSION : 0.1
//User-defined structure of FB_VerticalSwitch function block statistics.
   STRUCT
      UpTime : "UDT_EventStatistic";   // VSU up time
      DownTime : "UDT_EventStatistic";   // VSU down time
      UpperSwitchArea_Error : "UDT_EventStatistic";   // Error statistics for VSU
      LowerSwitchArea_Error : "UDT_EventStatistic";   // Error statistics for VSU
      UpperEntranceJam_Error : "UDT_EventStatistic";   // Error statistics for VSU
      LowerEntranceJam_Error : "UDT_EventStatistic";   // Error statistics for VSU
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_MFC_Sort_COY_Result"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 117
// END_ATTRIBUTES
   VAR_INPUT 
      ii_GINRangeStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 0;   // GIN range start value
      ii_GINRangeEnd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 0;   // GIN range end value
      is_ObjectID : String[10];   // Recived parcel identifier
      ii_SourceNode : Int;   // ID Source Node
      ii_DestinationNode : Int;   // ID Destination Node
   END_VAR

   VAR_OUTPUT 
      qx_Error : Bool;   // TRUE when collective block error occurred
      qx_Warning : Bool;   // TRUE when collective block warning occurred
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqa_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqi_MessageSequenceNumber : Int;   // Message number
   END_VAR

   VAR 
      ss_FB_HeartbeatPulse : "FB_Pulse";   // Heartbeat send pulse generator
      s_UDT_MessageArray : "UDT_MessageV2";   // Message array byte
      s_UDT_MessageHeader : "UDT_MFCSortMessageHeader";   // Message header
      ss_MessageBody : Struct   // Message body
         MsgID : Word;   // Message ID
         MsgLength : Word;   // Message length
         VID : Array[1..16] of Byte;   // Virtual Item Identifier
         PieceID : Array[1..40] of Byte;   // Piece ID
         Group : Byte;   // Group
         Level : Byte;   // Level
         Result : Byte;   // Result
         Eom : Byte;   // End of message
      END_STRUCT;
      ss_MessageData : Struct   // Message data
         VID : Array[1..16] of Byte;   // Virtual Item Identifier
         PieceID : Array[1..40] of Byte;   // Piece ID
         Group : String[1];   // Group
         Level : String[1];   // Level
         Result : String[1];   // Result
      END_STRUCT;
      ss_Status : Struct   // Status structure
         FIFOStatus : "UDT_FifoStatus";
         FIFOError { S7_SetPoint := 'True'} : Bool;   //  FIFO error
         FIFOWarning { S7_SetPoint := 'True'} : Bool;   // FIFO warning
         InvalidMessageArraySize : Bool;   // Message array is too short for message
         InvalidTimeInterval : Bool;   // Heartbeat time interval lower than zero
      END_STRUCT;
      sS_Old_Object_ID : String[10];   // Value from previous PLC cycle
      sdi_SerializePosition : DInt;   // Position in array where serialize finished writing data +1
      si_MaximumMessageLength : Int;   // Maximum number of elements in message array
      si_SerializeStatus : Int;   // Function serialize status
      sx_NewData : Bool;   // True - send a message to the MFC
   END_VAR

   VAR_TEMP 
      ti_Loop_GIN : Int;   // Loop counter for DB_GIN
      ti_Loop : Int;   // Loop counter
   END_VAR

   VAR CONSTANT 
      ci_MessageLength : Word := 16#003F;   // 10#0063 = 16#003F - Message length
      ci_MsgID : Word := 16#0137;   // 10#0311 = 16#0137 - Message ID
      ci_MsgLength : Word := 16#003B;   // 10#0059 = 16#003B - Message length
      ci_Som : Byte := 16#FD;   // Start of message
      ci_Eom : Byte := 16#FE;   // End of message
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	24/04/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	03/10/2023  | 1.1       | S. Nikodem   | Update
	13/03/2023  | 1.2       | S. Nieswiec  | Updated for new Baseline
	02/05/2024  | 1.3       | J.Majer      | Datatype conversions changed from automatic to explicit, to accomodate IEC 61131-3 standard
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOStatus,
	              qx_Error => #ss_Status.FIFOError,
	              qx_Warning => #ss_Status.FIFOWarning,
	              iqv_Data := #s_UDT_MessageArray,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqa_FifoData);
	    
	END_REGION
	
	REGION 2 – Data preparation
	    
	    //Generation message when is new parcel
	    #sx_NewData := (#is_ObjectID <> #sS_Old_Object_ID) AND NOT (#is_ObjectID = '');
	    // Save last value
	    #sS_Old_Object_ID := #is_ObjectID;
	    
	    IF #sx_NewData THEN
	        
	        FOR #ti_Loop_GIN := #ii_GINRangeStart TO #ii_GINRangeEnd DO
	            
	            IF "DB_GIN".GIN[#ti_Loop_GIN].DHL.ObjectID = #is_ObjectID THEN
	                
	                //VID
	                FOR #ti_Loop := 1 TO 16 DO
	                    
	                    #ss_MessageData.VID[#ti_Loop] := CHAR_TO_BYTE("DB_GIN".GIN[#ti_Loop_GIN].DHL.VID[#ti_Loop]);
	                    
	                END_FOR;
	                
	                //Piece ID
	                FOR #ti_Loop := 1 TO 40 DO
	                    
	                    #ss_MessageData.PieceID[#ti_Loop] := CHAR_TO_BYTE("DB_GIN".GIN[#ti_Loop_GIN].DHL.PieceID[#ti_Loop]);
	                    
	                END_FOR;
	                
	                //Group
	                #ss_MessageData.Group := "DB_GIN".GIN[#ti_Loop_GIN].DHL.Xray.Group;
	                
	                //Level
	                #ss_MessageData.Level := "DB_GIN".GIN[#ti_Loop_GIN].DHL.Xray.Level;
	                
	                //Result
	                #ss_MessageData.Result := "DB_GIN".GIN[#ti_Loop_GIN].DHL.Xray.Result;
	                
	            END_IF;
	            
	        END_FOR;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 – Message array size validation 
	    
	    // Get size of the array.
	    #si_MaximumMessageLength := "FC_GetNrOfArrayEl"(#s_UDT_MessageArray.Bytes);
	    
	    // Message array size validation. 
	    #ss_Status.InvalidMessageArraySize := WORD_TO_INT(#ci_MessageLength) > #si_MaximumMessageLength;
	    
	END_REGION
	
	
	REGION 4 – Message preparation 
	    
	    // FIFO full check.
	    IF NOT #iq_UDT_FifoHeader.Status.Full
	    THEN
	        // Errors and send pulse check.
	        IF NOT #ss_Status.FIFOError
	            AND NOT #ss_Status.InvalidMessageArraySize
	            AND #sx_NewData
	        THEN
	            
	            REGION 4.1 – Header preparation 
	                
	                // Check sequence number. If it is equal or greater than 255 reset it to 1.
	                IF #iqi_MessageSequenceNumber <= 255
	                THEN
	                    #iqi_MessageSequenceNumber += 1;
	                ELSE
	                    #iqi_MessageSequenceNumber := 1;
	                END_IF;
	                
	                // Write parts of the header into structure.
	                #s_UDT_MessageHeader.SOM := #ci_Som;
	                #s_UDT_MessageHeader.SourceNode := INT_TO_BYTE(#ii_SourceNode);
	                #s_UDT_MessageHeader.DestinationNode := INT_TO_BYTE(#ii_DestinationNode);
	                #s_UDT_MessageHeader.SeqNumber := INT_TO_BYTE(#iqi_MessageSequenceNumber);
	                #s_UDT_MessageHeader.DataLength := #ci_MessageLength;
	                #s_UDT_MessageHeader.NumMsg := 1;
	                
	                // Write parts of the body into structure.
	                #ss_MessageBody.MsgID := #ci_MsgID;
	                #ss_MessageBody.MsgLength := #ci_MsgLength;
	                #ss_MessageBody.VID := #ss_MessageData.VID;
	                #ss_MessageBody.PieceID := #ss_MessageData.PieceID;
	                #ss_MessageBody.Group := CHAR_TO_BYTE(STRING_TO_CHAR(#ss_MessageData.Group));
	                #ss_MessageBody.Level := CHAR_TO_BYTE(STRING_TO_CHAR(#ss_MessageData.Level));
	                #ss_MessageBody.Result := CHAR_TO_BYTE(STRING_TO_CHAR(#ss_MessageData.Result));
	                #ss_MessageBody.Eom := #ci_Eom;
	                
	            END_REGION
	            
	            REGION 4.2 – Convert message into array of bytes
	                
	                // Initialize the header serialize position and convert header structure into array of bytes.
	                #sdi_SerializePosition := 0;
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #s_UDT_MessageHeader,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	                // Initialize the body serialize position and convert header structure into array of bytes
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #ss_MessageBody,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	            END_REGION
	            
	            REGION 4.3 – Write message into the FIFO buffer
	                
	                // Mode 'W' - Write FIFO record.
	                "FC_Fifo"(ic_Mode := 'W',
	                          qUDT_Status => #ss_Status.FIFOStatus,
	                          qx_Error => #ss_Status.FIFOError,
	                          qx_Warning => #ss_Status.FIFOWarning,
	                          iqv_Data := #s_UDT_MessageArray,
	                          iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	                          iqv_DataBuffer := #iqa_FifoData);
	                
	            END_REGION
	            
	        END_IF;
	    ELSE
	        // If FIFO is full set FIFO main and FIFO full errors.
	        #ss_Status.FIFOError := TRUE;
	        #ss_Status.FIFOStatus.FifoFull := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Status
	    
	    // Parametrization collective error output.
	    #qx_Error :=
	    #ss_Status.FIFOError
	    OR #ss_Status.InvalidTimeInterval
	    OR #ss_Status.InvalidMessageArraySize;
	    
	    // Parametrization collective warning output.
	    #qx_Warning := #ss_Status.FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

TYPE "UDT_PECUpdateConfiguration"
TITLE = UDT_PECConfiguration
VERSION : 0.1
//User-defined structure of PEC parameters.
   STRUCT
      Distance : DInt;   // Distance between photo eye and the end of conveyor [mm]
      JamDisplacementLimit : Int;   // Limit displacement with PEC blocked o detect jam [cm]
      TimeOnDelay : UDInt;   // Photo eye time on delay [ms]
      TimeOffDelay : UDInt;   // Photo eye time off delay [ms]
      ParcelLengthFilter : Bool := TRUE;   // Parcel length filter
      ResetWithPECBlocked { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // When 'True' Allow reset system after jam with PEC blocked
      SearchWindowFwd : Int;   // Search window in forward direction [cm]
      SearchWindowRvs : Int;   // Search window in reverse direction [cm]
      GINRangeStart : Int;   // GIN range start value
      GINRangeEnd : Int;   // GIN range end value
      NrOfTeachParcels : Int;   // Number of parcels to teach
      DefaultGIN : Int := 1;   // Default GIN record
      MaxLost : Int;   // Maximum number of lost parcels in a row
      GenerationPoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Generation point
      NegativeGINDelete { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True when negative GIN has to be deleted
      ParcelLengthMeasurement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parcel length measurement
      GapLengthMeasurement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Gap length measurement
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_MFC_Sort_COY_ReceiveResult"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 115
// END_ATTRIBUTES
   VAR_INPUT 
      is_VID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[16];   // Virtual Item Identifier (VID)
      is_PieceID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[40];   // Piece ID barcodes
      is_Group { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[1];   // The group field is used to identify the group of the operator decisions came from in a
      is_Level { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[1];   // Level field is used to identify which level the operator decision came from in a
      is_Result { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[1];   // Results can be indicated with the following
      ii_SourceNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // ID Source Node
      ii_DestinationNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // ID Destination Node
   END_VAR

   VAR_OUTPUT 
      qx_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block error occurred
      qx_Warning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when collective block warning occurred
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqa_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Message number
   END_VAR

   VAR 
      ss_FB_HeartbeatPulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Pulse";   // Heartbeat send pulse generator
      s_UDT_MessageArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MessageV2";   // Message array byte
      s_UDT_MessageHeader { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_MFCSortMessageHeader";   // Message header
      ss_MessageBody { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Message body
         MsgID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Message ID
         MsgLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Message length
         VID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..16] of Byte;   // Virtual Item Identifier
         PieceID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..40] of Byte;   // Piece ID
         Group { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Group
         Level { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Level
         Result { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Result
         Eom { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // End of message
      END_STRUCT;
      ss_MessageData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Message data
         VID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..16] of Byte;   // Virtual Item Identifier
         PieceID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..40] of Byte;   // Piece ID
         Group { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[1];   // Group
         Level { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[1];   // Level
         Result { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[1];   // Result
      END_STRUCT;
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_FifoStatus";
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   //  FIFO error
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // FIFO warning
         InvalidMessageArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Message array is too short for message
         InvalidTimeInterval { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Heartbeat time interval lower than zero
      END_STRUCT;
      sdi_SerializePosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Position in array where serialize finished writing data +1
      si_MaximumMessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Maximum number of elements in message array
      si_SerializeStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Function serialize status
      sx_NewData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // New data received
      ss_PieceIDOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[40];   // Piece ID barcodes old value
   END_VAR

   VAR_TEMP 
      ti_Loop : Int;
   END_VAR

   VAR CONSTANT 
      ci_MessageLength : Word := 16#003F;   // 10#0063 = 16#003F - Message length
      ci_MsgID : Word := 16#0137;   // 10#0311 = 16#0137 - Message ID
      ci_MsgLength : Word := 16#003B;   // 10#0059 = 16#003B - Message length
      ci_Som : Byte := 16#FD;   // Start of message
      ci_Eom : Byte := 16#FE;   // End of message
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	05/10/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/03/2023  | 1.1       | S. Nieswiec  | Updated for new Baseline
	02/05/2024  | 1.2       | J.Majer      | Datatype conversions changed from automatic to explicit, to accomodate IEC 61131-3 standard
	*)
	
	REGION 1 – FIFO header status update
	    
	    // Mode 'S' - FIFO register status update.
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOStatus,
	              qx_Error => #ss_Status.FIFOError,
	              qx_Warning => #ss_Status.FIFOWarning,
	              iqv_Data := #s_UDT_MessageArray,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	              iqv_DataBuffer := #iqa_FifoData);
	    
	END_REGION
	
	REGION 2 – Data preparation
	    
	    IF #is_PieceID <> #ss_PieceIDOld AND NOT (#ss_PieceIDOld = '') THEN
	        
	        //Save
	        #ss_PieceIDOld := #is_PieceID;
	        
	        //VID
	        FOR #ti_Loop := 1 TO 16 DO
	            
	            #ss_MessageData.VID[#ti_Loop] := CHAR_TO_BYTE(#is_VID[#ti_Loop]);
	            
	        END_FOR;
	        
	        //Piece ID
	        FOR #ti_Loop := 1 TO 40 DO
	            
	            #ss_MessageData.PieceID[#ti_Loop] := CHAR_TO_BYTE(#is_PieceID[#ti_Loop]);
	            
	        END_FOR;
	        
	        //Group
	        #ss_MessageData.Group := #is_Group;
	        
	        //Level
	        #ss_MessageData.Level := #is_Level;
	        
	        //Result
	        #ss_MessageData.Result := #is_Result;
	        
	        //New data received
	        #sx_NewData := TRUE;
	        
	    END_IF;
	    
	    
	END_REGION
	
	REGION 3 – Message array size validation 
	    
	    // Get size of the array.
	    #si_MaximumMessageLength := "FC_GetNrOfArrayEl"(#s_UDT_MessageArray.Bytes);
	    
	    // Message array size validation. 
	    #ss_Status.InvalidMessageArraySize := WORD_TO_INT(#ci_MessageLength) > #si_MaximumMessageLength;
	    
	END_REGION
	
	
	REGION 4 – Message preparation 
	    
	    // FIFO full check.
	    IF NOT #iq_UDT_FifoHeader.Status.Full
	    THEN
	        // Errors and send pulse check.
	        IF NOT #ss_Status.FIFOError
	            AND NOT #ss_Status.InvalidMessageArraySize
	            AND #sx_NewData
	        THEN
	            
	            REGION 4.1 – Header preparation 
	                
	                // Check sequence number. If it is equal or greater than 255 reset it to 1.
	                IF #iqi_MessageSequenceNumber <= 255
	                THEN
	                    #iqi_MessageSequenceNumber += 1;
	                ELSE
	                    #iqi_MessageSequenceNumber := 1;
	                END_IF;
	                
	                // Write parts of the header into structure.
	                #s_UDT_MessageHeader.SOM := #ci_Som;
	                #s_UDT_MessageHeader.SourceNode := INT_TO_BYTE(#ii_SourceNode);
	                #s_UDT_MessageHeader.DestinationNode := INT_TO_BYTE(#ii_DestinationNode);
	                #s_UDT_MessageHeader.SeqNumber := INT_TO_BYTE(#iqi_MessageSequenceNumber);
	                #s_UDT_MessageHeader.DataLength := #ci_MessageLength;
	                #s_UDT_MessageHeader.NumMsg := 1;
	                
	                // Write parts of the body into structure.
	                #ss_MessageBody.MsgID := #ci_MsgID;
	                #ss_MessageBody.MsgLength := #ci_MsgLength;
	                #ss_MessageBody.VID := #ss_MessageData.VID;
	                #ss_MessageBody.PieceID := #ss_MessageData.PieceID;
	                #ss_MessageBody.Group := CHAR_TO_BYTE(STRING_TO_CHAR(#ss_MessageData.Group));
	                #ss_MessageBody.Level := CHAR_TO_BYTE(STRING_TO_CHAR(#ss_MessageData.Level));
	                #ss_MessageBody.Result := CHAR_TO_BYTE(STRING_TO_CHAR(#ss_MessageData.Result));
	                #ss_MessageBody.Eom := #ci_Eom;
	                
	            END_REGION
	            
	            REGION 4.2 – Convert message into array of bytes
	                
	                // Initialize the header serialize position and convert header structure into array of bytes.
	                #sdi_SerializePosition := 0;
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #s_UDT_MessageHeader,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	                // Initialize the body serialize position and convert header structure into array of bytes
	                #si_SerializeStatus := Serialize(SRC_VARIABLE := #ss_MessageBody,
	                                                 DEST_ARRAY => #s_UDT_MessageArray.Bytes,
	                                                 POS := #sdi_SerializePosition);
	                
	            END_REGION
	            
	            REGION 4.3 – Write message into the FIFO buffer
	                
	                // Mode 'W' - Write FIFO record.
	                "FC_Fifo"(ic_Mode := 'W',
	                          qUDT_Status => #ss_Status.FIFOStatus,
	                          qx_Error => #ss_Status.FIFOError,
	                          qx_Warning => #ss_Status.FIFOWarning,
	                          iqv_Data := #s_UDT_MessageArray,
	                          iqUDT_FifoHeader := #iq_UDT_FifoHeader,
	                          iqv_DataBuffer := #iqa_FifoData);
	                
	            END_REGION
	            
	            //Reset
	            #sx_NewData := False;
	            
	        END_IF;
	    ELSE
	        // If FIFO is full set FIFO main and FIFO full errors.
	        #ss_Status.FIFOError := TRUE;
	        #ss_Status.FIFOStatus.FifoFull := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Status
	    
	    // Parametrization collective error output.
	    #qx_Error :=
	    #ss_Status.FIFOError
	    OR #ss_Status.InvalidTimeInterval
	    OR #ss_Status.InvalidMessageArraySize;
	    
	    // Parametrization collective warning output.
	    #qx_Warning := #ss_Status.FIFOWarning;
	    
	END_REGION
END_FUNCTION_BLOCK

TYPE "UDT_XrayRapiscanConfiguration"
VERSION : 0.1
   STRUCT
      EstopResetPluse : UDInt;   // Time how long the pulse should be active [ms]
      IDmessageTimeout : UDInt;   // The maximum time after which Xray must receive a Bag ID [ms]
      BagIDPoint : UDInt;   // Place in the Xray conveyor tracking from which Bag ID is to be taken [cm]
      ScanningWindowStartPoint : Int;   // Scanning window a start point in the Xray conveyor tracking [cm]
      ScanningWindowEndPoint : Int;   // Scanning window a end point in the Xray conveyor tracking [cm]
      BackBeltDistance : UDInt;   // Back belt distance [cm]
      XrayConveyor { S7_SetPoint := 'False'} : "UDT_ConveyorCommonConfiguration";   // Conveyor configuration
      SerialCommunicationConfiguration { S7_SetPoint := 'False'} : "UDT_SerialComConfiguration";
   END_STRUCT;

END_TYPE

TYPE "UDT_RapiscanStatus"
TITLE = UDT_HS10080XCTStatus
VERSION : 0.1
//User-defined structure of FB_Xray_HS10080XCT function block status.
   STRUCT
      Status : Int;   // Status number
      XraySpecific : Struct   // Equipment specific warnings and errors
         XrayEnergised : Bool;   // Xray Energised
         XrayFault : Bool;   // Xray Fault
         XrayRdyRCV : Bool;   // Xray Ready receive
         XrayRdySend : Bool;   // Xray Ready send
         BagScanning : Bool;   // Xray bag scaning
         TransportMode : Bool;   // Transport mode active
         BackBelt : Bool;   // Backbelt functinality active
      END_STRUCT;
      ConvSpecific : Struct   // Equipment specific warnings and errors
         Status : Int;   // Status number
         Conv_ERR : Bool;   // Conveyor is in error
         Encoder_ERR : Bool;   // Encoder error
         ConvRunFWD : Bool;   // Conveyor run forward direction
         ConvRunREV : Bool;   // Conveyor run reverse direction
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "UDT_RapiscanStatistics"
TITLE = UDT_HS10080XCTStatistics
VERSION : 0.1
//User-defined structure of FB_Xray_HS10080XCT function block statistics.
   STRUCT
      TransportMode : "UDT_EventStatistic";   // Running in transit mode
      EncoderError : "UDT_EventStatistic";   // One of the encoders has faulted
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_VFD_FishBone"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 245
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_MultiControlConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VFD_MultiControl_Configuration";   //   VFD configuration structure
      i_UDT_MultiControl_1_Inputs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VFD_MultiControl_PI";   //   VFD inputs structure
      i_UDT_MultiControl_2_Inputs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VFD_MultiControl_PI";   //   VFD inputs structure
      is_MultiControl_1_PNDeviceName { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // MultiControl 1 Profinet device name
      is_MultiControl_2_PNDeviceName { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // MultiControl 2 Profinet device name
      ix_PowerOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when External Power OK
      ix_SafetyOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when Safety OK
   END_VAR

   VAR_OUTPUT 
      q_UDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdStatus";   //   HMI status structure
      qsi_VFDSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : SInt;   //   VFD speed setpoint
   END_VAR

   VAR_IN_OUT 
      iq_UDT_ConveyorInterface : "UDT_ConveyorInterface";   //   Conveyor interface structure
      iq_UDT_VFDStatistics : "UDT_VfdStatistics";   //   Statistics structure
      iq_UDT_Equipment : "UDT_EquipmentControl";   // equipment control commands
   END_VAR

   VAR 
      s_FB_VFD_MultiControl_1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_VFD_MultiControl_V4";   // FB multi control 1
      s_FB_VFD_MultiControl_2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_VFD_MultiControl_V4";   // FB multi control 2
      s_UDT_MultiControlConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VFD_MultiControl_Configuration";   //   VFD configuration structure
      s_UDT_Multicontrol_1_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatus";   //   HMI status structure
      s_UDT_Multicontrol_2_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatus";   //   HMI status structure
      s_UDT_Multicontrol_1_Statistics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";   //   Statistics structure
      s_UDT_Multicontrol_2_Statistics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatistics";   //   Statistics structure
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------      
	                                                           
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	08/12/2022  | 1.0       | S. Nikodem    | Initial version | DHL Munich 2023
	13/03/2024  | 1.1       | S. Nieswiec       | Added to new baseline
	*)
	
	REGION 1 - MultiControl 1 
	    
	    //Copy configuration to static memory
	    #s_UDT_MultiControlConfiguration := #i_UDT_MultiControlConfiguration;
	    
	    //Write Profinet name
	    #s_UDT_MultiControlConfiguration.VFDPNDeviceName := #is_MultiControl_1_PNDeviceName;
	    
	    //Call MultiControl function for 4 motors handling
	    #s_FB_VFD_MultiControl_1(i_UDT_VFDConfiguration := #i_UDT_MultiControlConfiguration,
	                             i_UDT_VFDInputs := #i_UDT_MultiControl_1_Inputs,
	                             ix_PowerOK := #ix_PowerOK,
	                             ix_SafetyOK := #ix_SafetyOK,
	                             q_UDT_HMIStatus => #q_UDT_HMIStatus,
	                             qsi_UDT_VFDSpeed => #qsi_VFDSpeed,
	                             iq_UDT_ConveyorInterface := #iq_UDT_ConveyorInterface,
	                             iq_UDT_VFDStatistics := #iq_UDT_VFDStatistics,
	                             iq_UDT_Equipment := #iq_UDT_Equipment);
	    
	END_REGION
	
	REGION 2 - MultiControl 2
	    
	    //Write Profinet name
	    #s_UDT_MultiControlConfiguration.VFDPNDeviceName := #is_MultiControl_2_PNDeviceName;
	    
	    //Call MultiControl function for 4 motors handling
	    #s_FB_VFD_MultiControl_2(i_UDT_VFDConfiguration := #i_UDT_MultiControlConfiguration,
	                             i_UDT_VFDInputs := #i_UDT_MultiControl_2_Inputs,
	                             ix_PowerOK := #ix_PowerOK,
	                             ix_SafetyOK := #ix_SafetyOK,
	                             q_UDT_HMIStatus => #q_UDT_HMIStatus,
	                             qsi_UDT_VFDSpeed => #qsi_VFDSpeed,
	                             iq_UDT_ConveyorInterface := #iq_UDT_ConveyorInterface,
	                             iq_UDT_VFDStatistics := #iq_UDT_VFDStatistics,
	                             iq_UDT_Equipment := #iq_UDT_Equipment);
	    
	END_REGION
	
	REGION 3 - HMI Status
	    
	    #q_UDT_HMIStatus.PNSlaveNotonline := #s_UDT_Multicontrol_1_HMIStatus.PNSlaveNotonline OR #s_UDT_Multicontrol_2_HMIStatus.PNSlaveNotonline;
	    #q_UDT_HMIStatus.PNSlaveError := #s_UDT_Multicontrol_1_HMIStatus.PNSlaveError OR #s_UDT_Multicontrol_2_HMIStatus.PNSlaveError;
	    #q_UDT_HMIStatus.InternalError := #s_UDT_Multicontrol_1_HMIStatus.InternalError OR #s_UDT_Multicontrol_2_HMIStatus.InternalError;
	    
	END_REGION
	
	REGION 4- Statistics
	    
	    //Piority for first MultiControl
	    
	    //PNSlaveNotOnline
	    #iq_UDT_VFDStatistics.PNSlaveNotOnline.LastEventSeconds := #s_UDT_Multicontrol_1_Statistics.PNSlaveNotOnline.LastEventSeconds;
	    #iq_UDT_VFDStatistics.PNSlaveNotOnline.NumberOfTimes := #s_UDT_Multicontrol_1_Statistics.PNSlaveNotOnline.NumberOfTimes + #s_UDT_Multicontrol_2_Statistics.PNSlaveNotOnline.NumberOfTimes;
	    #iq_UDT_VFDStatistics.PNSlaveNotOnline.TotalEventSeconds := #s_UDT_Multicontrol_1_Statistics.PNSlaveNotOnline.TotalEventSeconds + #s_UDT_Multicontrol_2_Statistics.PNSlaveNotOnline.TotalEventSeconds;
	    
	    //PNSlaveError
	    #iq_UDT_VFDStatistics.PNSlaveError.LastEventSeconds := #s_UDT_Multicontrol_1_Statistics.PNSlaveError.LastEventSeconds;
	    #iq_UDT_VFDStatistics.PNSlaveError.NumberOfTimes := #s_UDT_Multicontrol_1_Statistics.PNSlaveError.NumberOfTimes + #s_UDT_Multicontrol_2_Statistics.PNSlaveError.NumberOfTimes;
	    #iq_UDT_VFDStatistics.PNSlaveError.TotalEventSeconds := #s_UDT_Multicontrol_1_Statistics.PNSlaveError.TotalEventSeconds + #s_UDT_Multicontrol_2_Statistics.PNSlaveError.TotalEventSeconds;
	    
	    //VFDInternalError
	    #iq_UDT_VFDStatistics.VFDInternalError.LastEventSeconds := #s_UDT_Multicontrol_1_Statistics.VFDInternalError.LastEventSeconds;
	    #iq_UDT_VFDStatistics.VFDInternalError.NumberOfTimes := #s_UDT_Multicontrol_1_Statistics.VFDInternalError.NumberOfTimes + #s_UDT_Multicontrol_2_Statistics.VFDInternalError.NumberOfTimes;
	    #iq_UDT_VFDStatistics.VFDInternalError.TotalEventSeconds := #s_UDT_Multicontrol_1_Statistics.VFDInternalError.TotalEventSeconds + #s_UDT_Multicontrol_2_Statistics.VFDInternalError.TotalEventSeconds;
	    
	    //Running
	    //Piority for first MultiControl
	    #iq_UDT_VFDStatistics.Running := #s_UDT_Multicontrol_1_Statistics.Running;
	    
	END_REGION
	
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_ConveyorV2"
TITLE = FB_Conveyor_BiDirectional
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MHSE
FAMILY : Equimpent
VERSION : 3.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 94
// END_ATTRIBUTES
//Function block to control the bi-directional conveyor.
   VAR_INPUT 
      i_UDT_ConveyorConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorConfiguration";   //           Conveyor configuration structure
      idi_PEC_EoSDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Distance between photo eye and the end of conveyor [mm] in forward direction
      idi_PEC_BoSDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Distance between photo eye and the end of conveyor [mm] in reverse direction
      ii_ExternalSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //           External speed [mm/s]
      ix_SafetyOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           TRUE when safety is ok
      ix_24vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           TRUE when 24VDC is healthy
      ix_400vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           TRUE when 400VAC is healthy
      ix_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           TRUE when  hardware is Ok
      ix_PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;   //           TRUE when the end of section photoeye in forward direction is not blocked
      ix_PEC_BoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;   //           TRUE when the end of section photoeye in reverse direction is not blocked
      ix_ReverseDirection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           FALSE when to run in forward direction and True to run in Reverse direction
      ix_ExternalRequestDieBack { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           External input to request die back
      ix_ExternalRequestHold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           External input to request conveyor hold
      ix_ResetEnergySave { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Reset energy save mode timer
   END_VAR

   VAR_OUTPUT 
      q_UDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorStatus";   //           HMI status structure
      q_UDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   //           Common status structure
   END_VAR

   VAR_IN_OUT 
      iq_UDT_EquipmentControl : "UDT_EquipmentControl";   //           Equipment control structure
      iq_UDT_ConveyorCommand : "UDT_ConveyorCommand";   //           Conveyor command stucture
      iq_UDT_ConveyorInterface : "UDT_ConveyorInterface";   //           Interface structure
      iq_UDT_HandShakeUp : "UDT_ConveyorHandshake";   //           Upstream handshake structure in forward direction
      iq_UDT_HandShake : "UDT_ConveyorHandshake";   //           Handshake structure in forward direction
      iq_UDT_Statistics : "UDT_ConveyorStatistics";   //           Statistics structure
   END_VAR

   VAR 
      s_UDT_CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //           Common status structure
      s_UDT_CommonStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   //           Auxiliary status structure
      s_UDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ConveyorStatus";   //           HMI status structure
      s_FB_CascadeModeTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //           Timer to cascade start
      sdi_GapHeadToHeadConfiguration_Fwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Preset forward gap head to head with correction [cm]
      sdi_GapTailToHeadConfiguration_Fwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Preset forward gap tail to head with correction [cm]
      sdi_GapHeadToHeadConfiguration_Rvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Preset reverse gap head to head with correction [cm]
      sdi_GapTailToHeadConfiguration_Rvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Preset reverse gap tail to head with correction [cm]
   END_VAR
   VAR RETAIN
      sdi_AuxGapHeadToHeadCounter_Fwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Aux variable to count the head to head
      sdi_AuxGapTailtoHeadCounter_Fwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Aux variable to count the gap
      sdi_AuxGapHeadToHeadCounter_Rvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Aux variable to count the head to head
      sdi_AuxGapTailtoHeadCounter_Rvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Aux variable to count the gap
      sdi_Gap_Fwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Gap between two products
      sdi_GapHeadToHead_Fwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Head to head between two products
      sdi_Gap_Rvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Gap between two products
      sdi_GapHeadToHead_Rvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Head to head between two products
      sdi_TailToBegin_Fwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Count tail to next conveyor distance
      sdi_HeadToEnd_Fwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Count head to end distance
      sdi_TailToBegin_Rvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Count tail to next conveyor distance
      sdi_HeadToEnd_Rvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Count head to end distance
   END_VAR
   VAR 
      sdi_PEC_EoSDistance_Fwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Real distance between PEC and the end of distance
      sdi_PECtoEndDistance_Fwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Distance between photeye and the end of the conveyor in cm
      sdi_PEC_EoSDistance_Rvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Real distance between PEC and the end of distance
      sdi_PECtoEndDistance_Rvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Distance between photeye and the end of the conveyor in cm
   END_VAR
   VAR RETAIN
      sdi_AuxEnergySave_Fwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Auxiliary variable to calculate energy save displacement
      sdi_AuxEnergySave_Rvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Auxiliary variable to calculate energy save displacement
      sdi_DownstreamGapTailtoHead_Fwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Gap between the beginning of the conveyor and the closer parcel in that conveyor
      sdi_DownstreamGapHeadToHead_Fwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Head to head between the beginning of the conveyor and the closer parcel in that conveyor
      sdi_DownstreamGapTailtoHead_Rvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Gap between the beginning of the conveyor and the closer parcel in that conveyor
      sdi_DownstreamGapHeadToHead_Rvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //           Head to head between the beginning of the conveyor and the closer parcel in that conveyor
      sdi_TransitionZone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Counter of product in transition zone
   END_VAR
   VAR 
      R_TRIG_ManualMode {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge trigger manual mode
      R_TRIG_Jog {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge trigger manual jog
      R_TRIG_PE_EoSFiltered_Rvs {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge trigger end of section photo eye filtered
      R_TRIG_PE_EoSFiltered_Fwd {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge trigger end of section photo eye filtered
      R_TRIG_TailToBegin_Rvs {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge trigger Tail arrive at the beginning of next conveyor
      R_TRIG_TailToBegin_Fwd {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge trigger Tail arrive at the beginning of next conveyor
      F_TRIG_ManualMode {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //           Falling edge trigger manual mode
      F_TRIG_Jog {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //           Falling edge trigger manual mode jog
      F_TRIG_PEC_EoSFiltered_Rvs {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //           Falling edge trigger end of section photo eye filtered
      F_TRIG_PEC_EoSFiltered_Fwd {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //           Falling edge trigger end of section photo eye filtered
      F_TRIG_AuxHeadToEnd_Rvs {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //           Falling edge trigger Aux head to end bit
      F_TRIG_AuxHeadToEnd_Fwd {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //           Falling edge trigger Aux head to end bit
      R_TRIG_ConveyorUp {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge trigger conveyor up time
      R_TRIG_EnergySave {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge trigger energy save
      R_TRIG_VFDRunning {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge trigger VFD running
      R_TRIG_ConveyorDownTime {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge trigger conveyor down
      R_TRIG_RunManual {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge run conveyor in manual mode
      R_TRIG_Transfering_Rvs {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge transfering
      R_TRIG_Transfering_Fwd {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge transfering
      F_TRIG_HeadAtEnd_Rvs {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //           Falling edge head at the end of the conveyor
      F_TRIG_HeadAtEnd_Fwd {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //           Falling edge head at the end of the conveyor
      R_TRIG_Reverse {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge of reverse direction
      F_TRIG_Reverse {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //           Falling edge of reverse direction
      R_Trig_DirectionChange {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //           Rising edge of change direction
      F_Trig_DirectionChange {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   //           Falling edge of change direction
      R_TRIG_PrestartManual {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge of manual prestart
      R_TRIG_ConveyorStopped {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //  Rising edge of stop
      sx_Ready { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Conveyor Ready to operate in Automatic mode
   END_VAR
   VAR RETAIN
      sx_StartReceived { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Save start trigger from the system
      sx_EnergySaveActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Active energy save mode
      sx_AuxHeadToEnd_Fwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Aux bit to control head to end positioning in forward direction
      sx_AuxHeadToEnd_Rvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Aux bit to control head to end positioning in reverse direction
      sx_TailToBegin_Fwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Tail to begin done in forward direction
      sx_TailToBegin_Rvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Tail to begin done in reverse direction
      sx_Gapping_Fwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Gapping in process in forward direction
      sx_Gapping_Rvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Gapping in process in reverse direction
   END_VAR
   VAR 
      sx_AutomaticActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Automatic active
   END_VAR
   VAR RETAIN
      sx_RecoveryGap_Fwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Recovery gap activated in forward direction
      sx_RecoveryGap_Rvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Recovery gap activated in reverse direction
   END_VAR
   VAR 
      sx_ManualModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Manual mode active
      sx_PreStartManual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Pre conditions to run conveyor in manual mode
   END_VAR
   VAR RETAIN
      sx_AuxHeadAtEnd_Fwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Parcel reach the end of the conveyor in forward direction
      sx_AuxHeadAtEnd_Rvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Parcel reach the end of the conveyor in reverse direction
   END_VAR
   VAR 
      sx_CascadeStartUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Cascade startup auxiliary bit
      sx_DirectionChanged { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Change direction until stop
      sx_ReverseDirection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //           Direction Selection auxiliary bit
      sx_ManualRunning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //          Conveyor running in manual mode
      sx_Up { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Conveyor is up
      sx_Down { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Conveyor is down
      sx_Stopped { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  Conveyor is stopped
      si_EnergySaveFilter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Energy save filter distance
   END_VAR

   VAR_TEMP 
      tx_CascadeStart : Bool;
   END_VAR

   VAR CONSTANT 
      ci_OverflowLimit : Int := 32000;   //           Limit int overflow
      ci_MinimumParcelLength : Int := 13;   // Minimum parcel length [cm]
   END_VAR


BEGIN
	
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2019             MHS Europe BV                                           |
	|  All Rights Rese9ved         Larenweg 90                                             |
	|                              5234 KC 's-Hertogenbosch,                               |
	|                              Netherlands                                             |
	|                                                                                      |     
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	            | 3.0       | C.Leite       | First release TIA 15.1
	01/01/2020  | 3.1       | S. Deulkar    | Modified error loging, added reset to reset internal error
	                                        | Cosidered commissioning error to put conveyor in ready state
	07/01/2020  | 3.2       | C. Leite      | Manual mode bug corrected related with conveyor start 
	10/01/2020  | 3.3       | C. Leite      | Manual mode start\stop change
	                                        | Lenght conveyor data type was changed to DInt  
	14/01/2020  | 3.4       | F.Baten       | Renamed Trail to Tail
	                                        | Renamed ii_PEC_EosDistance_EoS to idi_PEC_EoSDistance same for BoS 
	21/01/2020  | 3.5       | C.Leite       | Reset gapping bits when the direction changes 
	06/01/2020  | 3.6       | S. Deulkar    | Added safety Ok in condition to make ready status
	25/02/2020  | 3.7       | S. Deulkar    | Modified to update ststus output every cycle
	21/04/2020  | 3.8       | F.Baten       | Modified energysave reset
	23/04/2020  | 3.9       | S. Deulkar    | Modified logic for reset energy save command if it is slave conveyor
	22/06/2020  | 3.10      | K. Pokorski   | Modified singaling request activation, modified stop conditions (Handshake ReqStop)
	02/07/2020  | 3.11      | K. Pokorski   | Modified condition to disable manual mode (safety ok)
	30/07/2020  | 3.12      | S. Theocharis | Reset HMI commands of manual mode when conveyor no ready
	                                        | Keep downstream running when the a PEC error occurs 
	04/08/2020  | 3.13      | S. Deulkar    | Deletded Manual run stop command and Modified code to let 
	                                        | let slave conveyor go in energy save, Optimized energy save logic
	17/08/2020  | 3.14      | L.Klar        | Gapping corrected to work with PEC offset. Gap correction configuration added
	17/08/2020  | 3.15      | S. Theocharis | Encoder fault added. Manual mode active to interface. Stop trigger added for statistics
	                                        | Fix  statistics 
	11/01/2021  | 3.16      | L.Klar        | Input safety ok added to stop conveyor condition
	02/03/2021  | 3.17      | K. Pokorski   | Halted status enable only when automatic on
	11/03/2021  | 3.18      | S. Theocharis | Added bulk flow mode 3
	13/03/2021  | 3.19      | S. Theocharis | Warning color commented, line 665 added, sensors initial values changed to true
	15/03/2021  | 3.20      | S. Theocharis | Energy safe corrected
	29/03/2021  | 3.21      | M. Kocot      | Added HMI command for manual speed percetage selection and modified logic for cascade 
	                                        | startup
	31/03/2021  | 3.22      | H.Rutkowski   | Changed logic for TransitionZone calculation in mode 3( Converted PEC distance to cm)
	14/05/2021  | 3.23      | S. Nikodem    | Reset value from iq_UDT_HandShakeUp.DownstreamDisplacement and iq_UDT_HandShake.DownstreamDisplacement
	28/06/2021  | 3.24      | N.Kadam       | Modified logic for conveyor downtime and Esave statistics
	29/07/2021  | 3.25      | S. Deulkar    | Autotic ON condition is added to excecut region 7: Automatic mode active
	                                        | Statistics are updated after status
	11/11/2021  | 3.26      | M.Singh       |Shared Hardware signal over Interface
	28/03/2022  | 3.27      | M.Singh       |Solved Esave Bug, Swapped regions "Operation modes" and "Energy Save"
	28/07/2022  | 3.28      | M.Singh       |Removed handsakeUP.RTR from conditions determining downstream TIP and RTS
	30/07/2022  | 3.28      | M.Singh       |Addded hardware ok as condition to show safety status 
	                                        |Added Aux Head at end and TIP to Esave Reset conditions
	11.08.2023  | 3.29      | M.Diebel      |Comment logic to set #s_UDT_CommonStatus.Warning
	08.09.2023  | 3.30      | M.Diebel      |Updated Lenght for transition Zone in reverse direction
	05.10.2023  | 3.31      | M.Diebel      |Updated Reset Energe Save in reverse direction   
	20.12.2023  | 3.32      | M.Diebel      |Reset Energy save in reverse direction     
	31.01.2024  | 3.33      | L.Klar        |Energy save filter added   
	*)
	
	REGION 1 - Initial
	    
	    REGION 1.1 - First PLC cycle
	        
	        // Conveyor stops in the first scan of the PLC
	        IF "DB_Memory".FirstScan
	        THEN
	            #iq_UDT_EquipmentControl.Command.Start := FALSE;    // Command start
	            #sx_AutomaticActive := FALSE;                       // switch of automatic active
	            #iq_UDT_HandShakeUp.RTR := False;                   // Reset RTR signal
	            
	            #iq_UDT_HandShakeUp.CascadeStartUp := FALSE;        // Reset cascade start signal
	            
	            #iq_UDT_ConveyorInterface.RunFwd := FALSE;          // Order to run forward to VFD
	            #iq_UDT_ConveyorInterface.RunRvs := FALSE;          // Order to run reverse to VFD
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 1.2 - Conversion distance between PEC and end of conveyor [mm to cm]
	        
	        // Move PEC Distance into a static variable. Added on version 2.8
	        #sdi_PEC_EoSDistance_Fwd := #idi_PEC_EoSDistance;
	        #sdi_PEC_EoSDistance_Rvs := #i_UDT_ConveyorConfiguration.Common.Length - #idi_PEC_BoSDistance;
	        
	        // Limit to prevent malfunctions with zero or negative values. Added on version 2.8
	        IF #sdi_PEC_EoSDistance_Fwd < 10
	        THEN
	            #sdi_PEC_EoSDistance_Fwd := 10;
	        END_IF;
	        
	        IF #sdi_PEC_EoSDistance_Rvs < 10
	        THEN
	            #sdi_PEC_EoSDistance_Rvs := 10;
	        END_IF;
	        
	        //  Convertion of the distance between photo eye and the end of the conveyor from mm to cm.
	        #sdi_PECtoEndDistance_Fwd := (#sdi_PEC_EoSDistance_Fwd
	        - #i_UDT_ConveyorConfiguration.Forward_Direction.PEC_EoSDistanceOffset) / 10;
	        
	        #sdi_PECtoEndDistance_Rvs := (#sdi_PEC_EoSDistance_Rvs
	        - #i_UDT_ConveyorConfiguration.Reverse_Direction.PEC_BoSDistanceOffset) / 10;
	        
	        
	        // Limit the Pec to End distance in positive ranges. Added on version 2.7
	        IF #sdi_PECtoEndDistance_Fwd < 1 THEN
	            #sdi_PECtoEndDistance_Fwd := 1;
	        END_IF;
	        
	        IF #sdi_PECtoEndDistance_Rvs < 1 THEN
	            #sdi_PECtoEndDistance_Rvs := 1;
	        END_IF;
	        
	        #sx_ReverseDirection := (#iq_UDT_ConveyorCommand.Reverse OR #ix_ReverseDirection) AND #i_UDT_ConveyorConfiguration.Bi_Directional_Enable;
	        
	        
	    END_REGION
	    
	    REGION 1.3 Conditions Up - Down - Stopped
	        //Used for statistics
	        
	        #sx_Up := (#sx_AutomaticActive                               // Automatic active
	        AND #sx_Ready                                                // Ready active
	        AND NOT #sx_EnergySaveActive);                              // Not in energy save
	        
	        #sx_Down := (NOT #sx_ManualModeActive                                                   // Not in manual mode
	        AND #s_UDT_CommonStatus.Error                                                           // in error 
	        AND NOT #sx_Ready                                                                       // Conveyor not ready
	        AND NOT #sx_EnergySaveActive);                                                          // Not in energy save
	        
	        #sx_Stopped := (NOT #sx_AutomaticActive AND #sx_Ready);
	        
	    END_REGION
	    
	    REGION 1.3 - Triggers
	        
	        // Rising edge trigger manual mode
	        #R_TRIG_ManualMode(CLK := #iq_UDT_ConveyorCommand.ManualMode
	                           OR #iq_UDT_EquipmentControl.Command.ManualMode);
	        
	        // Falling edge trigger manual mode
	        #F_TRIG_ManualMode(CLK := #iq_UDT_ConveyorCommand.ManualMode
	                           OR #iq_UDT_EquipmentControl.Command.ManualMode);
	        
	        // Rising edge trigger manual mode jog
	        #R_TRIG_Jog(CLK := #iq_UDT_ConveyorCommand.ManualJog);
	        
	        // Falling edge trigger manual mode jog
	        #F_TRIG_Jog(CLK := #iq_UDT_ConveyorCommand.ManualJog);
	        
	        // Rising edge trigger to start in manual mode
	        #R_TRIG_RunManual(CLK := #iq_UDT_ConveyorCommand.ManualStartStop);
	        
	        // Rising edge trigger end of section photo eye filtered
	        #R_TRIG_PE_EoSFiltered_Fwd(CLK := #ix_PEC_EoS);
	        #R_TRIG_PE_EoSFiltered_Rvs(CLK := #ix_PEC_BoS);
	        
	        // Falling edge trigger end of section photo eye filtered
	        #F_TRIG_PEC_EoSFiltered_Fwd(CLK := #ix_PEC_EoS);
	        #F_TRIG_PEC_EoSFiltered_Rvs(CLK := #ix_PEC_BoS);
	        
	        // Rising edge conveyor up
	        #R_TRIG_ConveyorUp(CLK := #sx_Up);
	        
	        // Rising edge energy save mode
	        #R_TRIG_EnergySave(CLK := #sx_EnergySaveActive);
	        
	        // Rising edge running
	        #R_TRIG_VFDRunning(CLK := #iq_UDT_ConveyorInterface.VFDRunning);
	        
	        // Rising edge conveyor conveyor down
	        #R_TRIG_ConveyorDownTime(CLK := #sx_Down);
	        
	        //Rising edge conveyor stopped
	        #R_TRIG_ConveyorStopped(CLK := #sx_Stopped);
	        
	        // Rising edge conveyor command reverse direction
	        #R_TRIG_Reverse(CLK := #iq_UDT_ConveyorCommand.Reverse);
	        
	        // Falling edge conveyor command reverse direction
	        #F_TRIG_Reverse(CLK := #iq_UDT_ConveyorCommand.Reverse);
	        
	        // Rising edge conveyor change direction
	        #R_Trig_DirectionChange(CLK := #sx_ReverseDirection);
	        
	        // Falling edge conveyor change direction
	        #F_Trig_DirectionChange(CLK := #sx_ReverseDirection);
	        
	    END_REGION
	    
	    REGION 1.4 - Move displacement to upstream
	        
	        // Downstream displacement is mode to upstream conveyor to calculate gap
	        
	        IF NOT #sx_ReverseDirection
	        THEN
	            #iq_UDT_HandShakeUp.DownstreamDisplacement := #iq_UDT_ConveyorInterface.Displacement;
	        ELSE
	            #iq_UDT_HandShake.DownstreamDisplacement := #iq_UDT_ConveyorInterface.Displacement;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 1.5 - Change direction
	        
	        // The memory bit to change direction is activated when the input is trigger
	        
	        IF #R_Trig_DirectionChange.Q
	            OR #F_Trig_DirectionChange.Q
	        THEN
	            #sx_DirectionChanged := TRUE;
	        END_IF;
	        
	        // The direction changed memory bit is just reset when the conveyor stops to prevente mechanical problems
	        
	        IF #sx_DirectionChanged
	            AND #i_UDT_ConveyorConfiguration.Bi_Directional_Enable
	            AND NOT #iq_UDT_ConveyorInterface.VFDatSpeed
	            AND NOT #iq_UDT_ConveyorInterface.VFDRunning
	            AND (#iq_UDT_ConveyorInterface.ActualSpeed <= 0)
	        THEN
	            #sx_DirectionChanged := FALSE;
	            
	            #sx_AuxHeadAtEnd_Fwd := FALSE;
	            #sx_AuxHeadAtEnd_Rvs := FALSE;
	            
	            #sdi_AuxGapHeadToHeadCounter_Fwd := 0;
	            #sdi_AuxGapHeadToHeadCounter_Rvs := 0;
	            
	            #sdi_AuxGapTailtoHeadCounter_Rvs := 0;
	            #sdi_AuxGapTailtoHeadCounter_Fwd := 0;
	            
	            #sx_Gapping_Rvs := FALSE;
	            #sx_Gapping_Fwd := FALSE;
	            
	            #iq_UDT_HandShake.TIP := FALSE;
	            #iq_UDT_HandShakeUp.TIP := FALSE;
	            
	            #iq_UDT_HandShakeUp.DownstreamDisplacement := 0;     // v3.23
	            #iq_UDT_HandShake.DownstreamDisplacement := 0;       // v3.23
	            
	        END_IF;
	        
	        IF (#R_Trig_DirectionChange.Q
	            AND NOT #ix_PEC_BoS)
	            OR (#F_Trig_DirectionChange.Q
	            AND NOT #ix_PEC_EoS)
	            AND #i_UDT_ConveyorConfiguration.Bi_Directional_Enable
	        THEN
	            #sdi_AuxGapHeadToHeadCounter_Fwd := 0;
	            #sdi_AuxGapHeadToHeadCounter_Rvs := 0;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 1.5 - Gaps configuration
	        
	        // Forward head to head
	        #sdi_GapHeadToHeadConfiguration_Fwd := #i_UDT_ConveyorConfiguration.Forward_Direction.GapHeadToHead + #i_UDT_ConveyorConfiguration.Forward_Direction.GapCorrection;
	        // Forward tail to head
	        #sdi_GapTailToHeadConfiguration_Fwd := #i_UDT_ConveyorConfiguration.Forward_Direction.GapTailToHead + #i_UDT_ConveyorConfiguration.Forward_Direction.GapCorrection;
	        // Reverse head to head
	        #sdi_GapHeadToHeadConfiguration_Rvs := #i_UDT_ConveyorConfiguration.Reverse_Direction.GapHeadToHead + #i_UDT_ConveyorConfiguration.Reverse_Direction.GapCorrection;
	        // Reverse tail to head
	        #sdi_GapTailToHeadConfiguration_Rvs := #i_UDT_ConveyorConfiguration.Reverse_Direction.GapTailToHead + #i_UDT_ConveyorConfiguration.Reverse_Direction.GapCorrection;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 2 - Reset faults
	    
	    REGION 2.1 - Send reset request to interface UDT
	        
	        // Reset signal is sent to the interface UDT (VFD block, Tracking block, PEC update block)
	        #iq_UDT_ConveyorInterface.InternalErrorReset := #iq_UDT_EquipmentControl.Command.Reset;
	        
	        #iq_UDT_ConveyorInterface.ResetStatistics := #iq_UDT_EquipmentControl.Command.ResetData;
	        
	    END_REGION
	    
	    
	    REGION 2.2 - Error / warning
	        
	        #s_UDT_CommonStatus.Error := #iq_UDT_ConveyorInterface.InternalErrorPEC               // Internal PEC error status
	        OR #iq_UDT_ConveyorInterface.InternalErrorVFD               // Internal VFD error status
	        OR #iq_UDT_ConveyorInterface.InternalErrorTracking          // Internal tracking error status
	        OR #iq_UDT_ConveyorInterface.Disconnected                   // Isolator switch error status 
	        OR #iq_UDT_ConveyorInterface.InternalErrorEncoder;          // Encoder error
	        
	        
	        // #s_UDT_CommonStatus.Warning := #iq_UDT_ConveyorInterface.InternalWarningTracking        // v2.3 Internal Warning Tracking  added
	        // OR #iq_UDT_ConveyorInterface.InternalWarningVFD;                                        // v2.3 Internal Warning VFD added
	        
	    END_REGION
	    
	END_REGION
	
	REGION 3 - Check conditions to set conveyor ready
	    //Share HardwareOK signal over interface
	    #iq_UDT_ConveyorInterface.HardwareOk := #ix_HardwareOk;
	    
	    //  Conditions to set bit sx_Ready to operate in automatic mode
	    #sx_Ready := NOT #s_UDT_CommonStatus.Error                              // Ready bit is set true when common error status its false
	    AND #ix_SafetyOk
	    AND #ix_24vOk                                                        // 24V error status
	    AND #ix_400vOk                                                       // 400V error status
	    AND #ix_HardwareOk                                                   // Profinet error status
	    AND NOT #iq_UDT_ConveyorInterface.ConfigurationError;                // No configuration error      
	    
	END_REGION
	
	REGION 4 - Stop conveyor
	    
	    // Conditions to stop conveyor
	    IF (#F_TRIG_Jog.Q                                           // Trigger when conveyor stops jogging by HMI
	        AND #sx_ManualModeActive)                                   // Manual mode is active
	        
	        OR (NOT #iq_UDT_EquipmentControl.Command.AutomaticOn        // Conveyor stops if the bit AutomaticOn from control block is false
	        AND NOT #sx_ManualModeActive)                               // Manual mode active bit
	        
	        OR (NOT #sx_Ready                                           // Bit conveyor ready to run in automatic mode
	        AND NOT #sx_ManualModeActive)                               // Manual mode active
	        
	        OR #R_TRIG_ManualMode.Q                                     // Trigger when manual mode is set on
	        OR #F_TRIG_ManualMode.Q                                     // Trigger when manual mode is set off
	        
	        OR (#iq_UDT_HandShakeUp.ReqStop                             // Stop request from upstream if direction not changed
	        AND NOT #sx_DirectionChanged)
	        
	        OR (#iq_UDT_HandShake.ReqStop                               // Stop request from downstream if direction changed
	        AND #sx_DirectionChanged)
	        
	        OR NOT #ix_SafetyOk
	        
	    THEN
	        //  Order to stop VFD
	        #iq_UDT_ConveyorInterface.RunFwd := FALSE;                  // Set false order to VFD run in forward direction
	        #iq_UDT_ConveyorInterface.RunRvs := FALSE;                  // Set false order to VFD run in reverse direction
	        
	        IF NOT #sx_ReverseDirection
	        THEN
	            
	            #iq_UDT_HandShakeUp.RTR := FALSE;                       // Set false the bit ready to receive
	            #iq_UDT_HandShakeUp.CascadeStartUp := FALSE;            // Set false cascade start up bit
	            
	        ELSE
	            
	            #iq_UDT_HandShake.RTR := FALSE;                       // Set false the bit ready to receive
	            #iq_UDT_HandShake.CascadeStartUp := FALSE;            // Set false cascade start up bit
	            
	        END_IF;
	        
	        #sx_AutomaticActive := FALSE;                               // Automatic mode is disable
	        //    #sx_StartReceived := FALSE;                                 // Clear start receive bit 
	        
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Start
	    
	    REGION 5.1 - Save Start bit request
	        
	        // The conditions to set the bit "startReceived" are: 
	        // - Conveyor not in manual mode.
	        // - Conveyor ready to run.
	        // - Bit AutomaticOn from control block must be on.
	        // - Bit start form control block on.
	        
	        IF #iq_UDT_EquipmentControl.Command.Start
	            AND #iq_UDT_EquipmentControl.Command.AutomaticOn
	        THEN
	            #sx_StartReceived := TRUE;          // Start bit from control block received
	        END_IF;
	        
	    END_REGION
	    
	    REGION 5.2 - Cascade mode
	        
	        (* If the bit "StartReceived" is set, automatic mode is activated if the conveyor is set as the first one to run
	         or the bit cascadestartup from downstream is on. *)
	        
	        IF #iq_UDT_EquipmentControl.Command.Start
	            AND #iq_UDT_EquipmentControl.Command.AutomaticOn
	            AND NOT #sx_ManualModeActive
	            AND #sx_Ready
	        THEN
	            #sx_AutomaticActive := TRUE;        // Conveyor active automatic mode
	        END_IF;
	        
	        //Timer to cascade mode
	        #tx_CascadeStart := #sx_StartReceived
	        AND ((NOT #sx_ReverseDirection
	        AND (#i_UDT_ConveyorConfiguration.Forward_Direction.FirstConveyorToStart
	        OR #iq_UDT_HandShake.CascadeStartUp))
	        OR (#sx_ReverseDirection
	        AND (#i_UDT_ConveyorConfiguration.Reverse_Direction.FirstConveyorToStart
	        OR #iq_UDT_HandShakeUp.CascadeStartUp)));
	        
	        #s_FB_CascadeModeTimer(iudi_OnDelayTime := #i_UDT_ConveyorConfiguration.CascadeTimeOnDelay,      // Cascade mode timer
	                               ix_SignalToDelay := #tx_CascadeStart,
	                               ix_Enable := TRUE,                                                   // Signal ready to enable cascade mode
	                               qx_DelayedSignal => #sx_CascadeStartUp);
	        
	        IF NOT #iq_UDT_EquipmentControl.Command.AutomaticOn
	        THEN
	            #sx_StartReceived := False;
	        END_IF;
	        
	        
	        // Cascade mode signal to upstream
	        IF NOT #sx_ReverseDirection
	        THEN
	            #iq_UDT_HandShakeUp.CascadeStartUp := #sx_CascadeStartUp;
	        ELSE
	            #iq_UDT_HandShake.CascadeStartUp := #sx_CascadeStartUp;
	        END_IF;
	        
	        
	        
	    END_REGION
	    
	END_REGION
	
	REGION 6 - Manual mode
	    
	    REGION 6.1 - Manual mode force disable
	        
	        // Manual mode bits inputs can be reset in case of malfunction
	        IF #iq_UDT_EquipmentControl.Command.DisableManualMode
	        THEN
	            #iq_UDT_ConveyorCommand.ManualMode := False;
	            #iq_UDT_EquipmentControl.Command.ManualMode := False;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 6.2 - Manual mode activation 
	        
	        // Manual mode is active if it is active from hmi or by control block  
	        #sx_ManualModeActive := #iq_UDT_ConveyorCommand.ManualMode
	        OR #iq_UDT_EquipmentControl.Command.ManualMode;
	        
	        //Send manual mode active to PEC/VFD blocks to supress errors
	        #iq_UDT_ConveyorInterface.ManualModeActive := #sx_ManualModeActive;
	        
	    END_REGION
	    
	    REGION 6.3 - Reset manual commands 
	        //When the system is not any more in manual mode or when fatal error occurs the HMI commands should be reset
	        //Added in V3.12 as bug fix. 
	        IF NOT #ix_SafetyOk
	            OR NOT #ix_24vOk                                                        // 24V error status
	            OR NOT #ix_400vOk                                                       // 400V error status
	            OR NOT #ix_HardwareOk                                                   // Profinet error status
	            OR #iq_UDT_ConveyorInterface.ConfigurationError                          // No configuration err
	            OR #iq_UDT_ConveyorInterface.InternalErrorVFD
	            OR #iq_UDT_ConveyorInterface.Disconnected
	            OR NOT #sx_ManualModeActive
	        THEN
	            #iq_UDT_ConveyorCommand.ManualStartStop := FALSE;
	            #iq_UDT_ConveyorCommand.ManualFullSpeed := FALSE;
	            #iq_UDT_ConveyorCommand.ManualJog := FALSE;
	            #iq_UDT_ConveyorCommand.Reverse := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 6.4 - Start/Stop
	        
	        // Pre start conditions to run in manual mode
	        #sx_PreStartManual := #sx_ManualModeActive              // Manual mode active bit
	        AND #ix_SafetyOk                                        // Safety healthy bit
	        AND NOT #iq_UDT_ConveyorInterface.Disconnected          // Isolator switch connected
	        AND #ix_HardwareOk                                      // Profinet comunication 
	        AND NOT #iq_UDT_ConveyorInterface.InternalErrorVFD;     // Internal error from VFD
	        
	        #R_TRIG_PrestartManual(CLK := #sx_PreStartManual);
	        
	        
	        IF (#sx_PreStartManual                                  // Pre start conditions to run in manual mode
	            AND (#R_TRIG_RunManual.Q                            // Trigger when conveyor start running in manual mode
	            OR (#iq_UDT_ConveyorCommand.ManualStartStop             // Conveyor start running in manual mode active
	            AND #R_TRIG_PrestartManual.Q)                       // Trigger when pre start conditions ti run in manual mode
	            AND NOT #iq_UDT_ConveyorCommand.ManualJog)          // Conveyor is not running in jog
	            OR (#sx_PreStartManual AND #R_TRIG_Jog.Q                                   // Trigger to start jogging
	            AND NOT #iq_UDT_ConveyorCommand.ManualStartStop))       // Conveyor is not running in manual mode
	        THEN
	            
	            #iq_UDT_EquipmentControl.Request.SignalingRequest := TRUE;  // Request signaling to control block before conveyor run in manual mode
	            
	        END_IF;
	        
	        // Run conveyor forward in manual mode
	        #iq_UDT_ConveyorInterface.RunFwd := #sx_PreStartManual           // Pre start conditions to run in manual mode
	        AND NOT #iq_UDT_ConveyorCommand.Reverse                          // Not in reverse direction
	        AND (NOT #iq_UDT_EquipmentControl.Request.SignalingRequest       // Signaling request done
	        OR #sx_ManualRunning)
	        AND (#iq_UDT_ConveyorCommand.ManualStartStop                         // Manual mode start to run
	        OR #iq_UDT_ConveyorCommand.ManualJog);                           // Jogging
	        
	        // Run conveyor reverse in manual mode
	        #iq_UDT_ConveyorInterface.RunRvs := #sx_PreStartManual           // Pre start conditions to run in manual mode
	        AND #iq_UDT_ConveyorCommand.Reverse                              // Reverse direction
	        AND (NOT #iq_UDT_EquipmentControl.Request.SignalingRequest       // Signaling request done
	        OR #sx_ManualRunning)
	        AND (#iq_UDT_ConveyorCommand.ManualStartStop                         // Manual mode start to run
	        OR #iq_UDT_ConveyorCommand.ManualJog);                           // Jogging
	        
	        #sx_ManualRunning := #iq_UDT_ConveyorInterface.RunFwd
	        OR #iq_UDT_ConveyorInterface.RunRvs;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 7 - Automatic mode active
	    
	    IF NOT #sx_ManualModeActive // Manual mode is not active
	    THEN
	        REGION 7.1 - Head to End
	            
	            (*  Function to calculate when the head of the parcel reaches the end of the conveyor
	                When PEC detects parcels head, the functionality increments the displacement of the conveyor until reach the value of the distance
	                between PEC and the end of the conveyor. After that, the counter is reset and the bit #sx_AuxHeadToEnd is triggered to inform the system. *)
	            IF NOT #sx_ReverseDirection
	            THEN
	                REGION 7.1.1 - Forward
	                    
	                    IF #F_TRIG_PEC_EoSFiltered_Fwd.Q      // Detects the product's head
	                    THEN
	                        
	                        #sdi_HeadToEnd_Fwd := #sdi_PECtoEndDistance_Fwd;                // move the distance between PE and the end of the conveyor to auxiliary variable 
	                        #sx_AuxHeadToEnd_Fwd := TRUE;                             // Active head to end function
	                        
	                        #sdi_GapHeadToHead_Fwd := #sdi_AuxGapHeadToHeadCounter_Fwd;     // Move gap calculated to variable
	                        #sdi_AuxGapHeadToHeadCounter_Fwd := 0;                     // Reset gap counter
	                        
	                        #sdi_Gap_Fwd := #sdi_AuxGapTailtoHeadCounter_Fwd;    // Move gap calculated to variable
	                        #sdi_AuxGapTailtoHeadCounter_Fwd := 0;                     // Reset gap counter
	                        
	                        #iq_UDT_HandShake.RTS := TRUE;                         // Set ready to send true when a parcel is detected in the PEC
	                        
	                    END_IF;
	                    
	                    IF #sx_AuxHeadToEnd_Fwd                 // Parcel's head detected in photo cell
	                        AND (#sdi_HeadToEnd_Fwd > 0)         // Psrcel's head do not arrive in the end of the conveyor yet
	                    THEN
	                        
	                        #sdi_HeadToEnd_Fwd -= #iq_UDT_ConveyorInterface.Displacement;   // Count displacement until arrive to the end of the conveyor
	                        
	                    ELSE
	                        
	                        #sx_AuxHeadToEnd_Fwd := FALSE;      // Stop function head to end
	                        
	                    END_IF;
	                    
	                    // Falling edge trigger Aux Head to End bit
	                    #F_TRIG_AuxHeadToEnd_Fwd(CLK := #sx_AuxHeadToEnd_Fwd);
	                    
	                    IF #F_TRIG_AuxHeadToEnd_Fwd.Q
	                    THEN
	                        #sx_AuxHeadAtEnd_Fwd := TRUE;                       // The head of the parcel is at the front positon of the conveyor
	                    END_IF;
	                    
	                    
	                    #F_TRIG_HeadAtEnd_Fwd(CLK := #sx_AuxHeadAtEnd_Fwd);
	                    
	                END_REGION
	            ELSE
	                REGION 7.1.2 - Reverse
	                    
	                    IF #F_TRIG_PEC_EoSFiltered_Rvs.Q      // Detects the product's head
	                    THEN
	                        
	                        #sdi_HeadToEnd_Rvs := #sdi_PECtoEndDistance_Rvs;                // move the distance between PE and the end of the conveyor to auxiliary variable 
	                        #sx_AuxHeadToEnd_Rvs := TRUE;                             // Active head to end function
	                        
	                        #sdi_GapHeadToHead_Rvs := #sdi_AuxGapHeadToHeadCounter_Rvs;     // Move gap calculated to variable
	                        #sdi_AuxGapHeadToHeadCounter_Rvs := 0;                     // Reset gap counter
	                        
	                        #sdi_Gap_Rvs := #sdi_AuxGapTailtoHeadCounter_Rvs;    // Move gap calculated to variable
	                        #sdi_AuxGapTailtoHeadCounter_Rvs := 0;                     // Reset gap counter
	                        
	                        #iq_UDT_HandShakeUp.RTS := TRUE;                         // Set ready to send true when a parcel is detected in the PEC
	                        
	                    END_IF;
	                    
	                    IF #sx_AuxHeadToEnd_Rvs                 // Parcel's head detected in photo cell
	                        AND (#sdi_HeadToEnd_Rvs > 0)         // Psrcel's head do not arrive in the end of the conveyor yet
	                    THEN
	                        
	                        #sdi_HeadToEnd_Rvs += #iq_UDT_ConveyorInterface.Displacement;   // Count displacement until arrive to the end of the conveyor
	                        
	                    ELSE
	                        
	                        #sx_AuxHeadToEnd_Rvs := FALSE;      // Stop function head to end
	                        
	                    END_IF;
	                    
	                    // Falling edge trigger Aux Head to End bit
	                    #F_TRIG_AuxHeadToEnd_Rvs(CLK := #sx_AuxHeadToEnd_Rvs);
	                    
	                    IF #F_TRIG_AuxHeadToEnd_Rvs.Q
	                    THEN
	                        #sx_AuxHeadAtEnd_Rvs := TRUE;                       // The head of the parcel is at the front positon of the conveyor
	                    END_IF;
	                    
	                    
	                    #F_TRIG_HeadAtEnd_Rvs(CLK := #sx_AuxHeadAtEnd_Rvs);
	                    
	                END_REGION
	            END_IF;
	        END_REGION
	        
	        REGION 7.2 - Tail to Begin
	            
	            (*   This function tracks when parcels tail reaches the begin of downstream conveyor
	                 When the PEC is clear, the function start to increase the displacement until reaches the distance
	                 between PEC and the end of conveyor. *)
	            IF NOT #sx_ReverseDirection
	            THEN
	                REGION 7.2.1 - Forward
	                    
	                    IF #R_TRIG_PE_EoSFiltered_Fwd.Q                     // Detects product's tail
	                    THEN
	                        
	                        #sdi_TailToBegin_Fwd := (#sdi_PEC_EoSDistance_Fwd / 10);   // move distance between PE and the end of the conveyor to auxiliar variable
	                        
	                    END_IF;
	                    
	                    IF (#sdi_TailToBegin_Fwd > 0)                                           // While tails parcel do not reach the beginning of next conveyor
	                    THEN
	                        
	                        #sdi_TailToBegin_Fwd -= #iq_UDT_ConveyorInterface.Displacement;   // count displacement until the product's tail arrive to the next conveyor
	                        #sx_TailToBegin_Fwd := FALSE;                                    // Reset tail to begin bit
	                        
	                    ELSE
	                        
	                        #sx_TailToBegin_Fwd := TRUE;                                     // Product's tail arrived at the begin OF next conveyor
	                        
	                    END_IF;
	                    
	                    // Rising edge trigger Aux tail to Begin bit
	                    #R_TRIG_TailToBegin_Fwd(CLK := #sx_TailToBegin_Fwd);
	                    
	                END_REGION
	            ELSE
	                REGION 7.2.2 - Reverse
	                    
	                    IF #R_TRIG_PE_EoSFiltered_Rvs.Q                     // Detects product's tail
	                    THEN
	                        
	                        #sdi_TailToBegin_Rvs := (#sdi_PEC_EoSDistance_Rvs / 10);   // move distance between PE and the end of the conveyor to auxiliar variable
	                        
	                    END_IF;
	                    
	                    IF (#sdi_TailToBegin_Rvs > 0)                                           // While tails parcel do not reach the beginning of next conveyor
	                    THEN
	                        
	                        #sdi_TailToBegin_Rvs += #iq_UDT_ConveyorInterface.Displacement;   // count displacement until the product's tail arrive to the next conveyor
	                        #sx_TailToBegin_Rvs := FALSE;                                    // Reset tail to begin bit
	                        
	                    ELSE
	                        
	                        #sx_TailToBegin_Rvs := TRUE;                                     // Product's tail arrived at the begin OF next conveyor
	                        
	                    END_IF;
	                    
	                    // Rising edge trigger Aux tail to Begin bit
	                    #R_TRIG_TailToBegin_Rvs(CLK := #sx_TailToBegin_Rvs);
	                    
	                END_REGION
	            END_IF;
	        END_REGION
	        
	        REGION 7.3 - Gap
	            
	            (*    Gap tail TO head function calculates the distance (Gap) between two parcels.                                       
	                  The function increases the Counter WHILE the photo eye is clear.                                                    
	                  Everytime a parcel trigger the photo eye, gap value is save AND the counter is reset.  *)
	            IF NOT #sx_ReverseDirection
	            THEN
	                REGION 7.3.1 - Forward
	                    
	                    IF #ix_PEC_EoS       // Count displacement when the PE do not detects the product
	                    THEN
	                        
	                        IF #sdi_AuxGapTailtoHeadCounter_Fwd < #ci_OverflowLimit        // Prevent integer variable overflow
	                        THEN
	                            IF #iq_UDT_HandShake.RTR THEN
	                                #sdi_AuxGapTailtoHeadCounter_Fwd += #iq_UDT_ConveyorInterface.Displacement;    // Calculate the gap
	                            END_IF;
	                            
	                        END_IF;
	                        
	                    END_IF;
	                    
	                END_REGION
	            ELSE
	                REGION 7.3.2 - Reverse
	                    
	                    IF #ix_PEC_BoS       // Count displacement when the PE do not detects the product
	                    THEN
	                        
	                        IF #sdi_AuxGapTailtoHeadCounter_Rvs < #ci_OverflowLimit        // Prevent integer variable overflow
	                        THEN
	                            
	                            #sdi_AuxGapTailtoHeadCounter_Rvs -= #iq_UDT_ConveyorInterface.Displacement;    // Calculate the gap
	                            
	                        END_IF;
	                    END_IF;
	                    
	                END_REGION
	            END_IF;
	        END_REGION
	        
	        REGION 7.4 - Head to head
	            
	            // The functionality head to head is used to calculate the distance between one head's parcel and the head's parcel behind.
	            // To do it, everytime the PEC is triggered, the function save the distance calculated and reset the counter to start
	            // counting again, over and over again.
	            IF NOT #sx_ReverseDirection
	            THEN
	                REGION 7.4.1 - Forward
	                    
	                    IF #sdi_AuxGapHeadToHeadCounter_Fwd < #ci_OverflowLimit        // Prevent integer variable overflow
	                    THEN
	                        
	                        #sdi_AuxGapHeadToHeadCounter_Fwd += #iq_UDT_ConveyorInterface.Displacement;   // measure the distance between two products
	                        
	                    END_IF;
	                    
	                END_REGION
	            ELSE
	                REGION 7.4.2 - Reverse
	                    
	                    IF #sdi_AuxGapHeadToHeadCounter_Rvs < #ci_OverflowLimit        // Prevent integer variable overflow
	                    THEN
	                        
	                        #sdi_AuxGapHeadToHeadCounter_Rvs -= #iq_UDT_ConveyorInterface.Displacement;   // measure the distance between two products
	                        
	                    END_IF;
	                    
	                END_REGION
	            END_IF;
	        END_REGION
	        
	        REGION 7.5 - Check gaps between products
	            
	            // Check gaps is a routine that checks all the time if the gap and head to head distance is acording to the configuration.
	            // If not, the bit "sx_Gapping" is set true and the conveyor stops to gap.
	            // Compare gaps calculated with the configured gaps 
	            IF NOT #sx_ReverseDirection
	            THEN
	                REGION 7.5.1 - Forward
	                    
	                    IF ((#sdi_GapHeadToHeadConfiguration_Fwd > #sdi_GapHeadToHead_Fwd               // Compare head to head configured with real distance
	                        OR #sdi_GapTailToHeadConfiguration_Fwd > #sdi_Gap_Fwd
	                        OR #sdi_GapTailToHeadConfiguration_Fwd > #sdi_DownstreamGapTailtoHead_Fwd           // Compare gap configured with real gap
	                        OR #sdi_GapHeadToHeadConfiguration_Fwd > #sdi_DownstreamGapHeadToHead_Fwd)
	                        AND #F_TRIG_AuxHeadToEnd_Fwd.Q)                                                         // Trigger when parcel arrive in the end of the conveyor
	                    THEN
	                        
	                        #sx_Gapping_Fwd := TRUE;        // Bit to inform the system that conveyor needs to stop to apply gap
	                        
	                    END_IF;
	                    
	                END_REGION
	            ELSE
	                REGION 7.5.1 - Reverse
	                    
	                    IF ((#sdi_GapHeadToHeadConfiguration_Rvs > #sdi_GapHeadToHead_Rvs               // Compare head to head configured with real distance
	                        OR #sdi_GapTailToHeadConfiguration_Rvs > #sdi_Gap_Rvs
	                        OR #sdi_GapTailToHeadConfiguration_Rvs > #sdi_DownstreamGapTailtoHead_Rvs           // Compare gap configured with real gap
	                        OR #sdi_GapHeadToHeadConfiguration_Rvs > #sdi_DownstreamGapHeadToHead_Rvs)
	                        AND #F_TRIG_AuxHeadToEnd_Rvs.Q)                                                         // Trigger when parcel arrive in the end of the conveyor
	                    THEN
	                        
	                        #sx_Gapping_Rvs := TRUE;        // Bit to inform the system that conveyor needs to stop to apply gap
	                        
	                    END_IF;
	                    
	                END_REGION
	            END_IF;
	            //    When conveyor stops to gapping, displacement values from downstream are used to 
	            //    apply new gap.
	            //    When the new gap applied fits with the configured one, the conveyor starts running again.
	            //    If the conveyor stops for die back reason and the gap its been applied, and extra gap value it will be applied.
	            //    This recovery gap it helps to recovery the system after die back.
	            IF NOT #sx_ReverseDirection
	            THEN
	                REGION 7.5.3 - Forward
	                    
	                    IF (#sx_Gapping_Fwd          // Gapping needs to be applied bit
	                        AND ((#sdi_GapHeadToHeadConfiguration_Fwd > #sdi_GapHeadToHead_Fwd    // Configured head to head bigger than the actual one
	                        OR #sdi_GapHeadToHeadConfiguration_Fwd - #idi_PEC_EoSDistance / 10 + #sdi_PECtoEndDistance_Fwd > #sdi_DownstreamGapHeadToHead_Fwd
	                        OR #sdi_GapTailToHeadConfiguration_Fwd > #sdi_Gap_Fwd     // Configured gap bigger than the actual one
	                        OR #sdi_GapTailToHeadConfiguration_Fwd - #idi_PEC_EoSDistance / 10 + #sdi_PECtoEndDistance_Fwd > #sdi_DownstreamGapTailtoHead_Fwd)
	                        AND NOT #sx_RecoveryGap_Fwd)                                                // Die back recovery gap bit not active
	                        OR (((#sdi_GapHeadToHeadConfiguration_Fwd + #i_UDT_ConveyorConfiguration.ExtraGapRecovery)   // Add recovery gap to the configured
	                        > #sdi_GapHeadToHead_Fwd                                                                                 // Actual head to head distance
	                        OR (#sdi_GapHeadToHeadConfiguration_Fwd - #idi_PEC_EoSDistance / 10 + #sdi_PECtoEndDistance_Fwd + #i_UDT_ConveyorConfiguration.ExtraGapRecovery)
	                        > #sdi_DownstreamGapHeadToHead_Fwd
	                        OR (#sdi_GapTailToHeadConfiguration_Fwd + #i_UDT_ConveyorConfiguration.ExtraGapRecovery)    // Add recovery gap to the configured
	                        > #sdi_Gap_Fwd                                                                               // Actual gap between parcels
	                        OR (#sdi_GapTailToHeadConfiguration_Fwd - #idi_PEC_EoSDistance / 10 + #sdi_PECtoEndDistance_Fwd + #i_UDT_ConveyorConfiguration.ExtraGapRecovery)
	                        > #sdi_DownstreamGapTailtoHead_Fwd)
	                        AND #sx_RecoveryGap_Fwd))                                                                       // Recovery gap bit activate
	                    THEN
	                        
	                        #sdi_GapHeadToHead_Fwd += #iq_UDT_HandShake.DownstreamDisplacement;      // Increase head to head counter with conveyor downstream displacement
	                        #sdi_Gap_Fwd += #iq_UDT_HandShake.DownstreamDisplacement;     // Increase gap counter with conveyor downstream displacement
	                        
	                    ELSE
	                        
	                        #sx_Gapping_Fwd := FALSE;                   // Set gapping bit to false
	                        
	                    END_IF;
	                    
	                    IF #sx_Gapping_Fwd                              // Gapping bit active
	                        AND NOT #iq_UDT_HandShake.RTR           // Ready to receive not active
	                    THEN
	                        
	                        #sx_RecoveryGap_Fwd := TRUE;                // Recovery gap activation after die back
	                        
	                    END_IF;
	                    
	                    IF #sx_RecoveryGap_Fwd                          // Recovery gap active
	                        AND NOT #sx_Gapping_Fwd                     // Gapping bit not active
	                    THEN
	                        
	                        #sx_RecoveryGap_Fwd := FALSE;               // Recovery gap disable
	                        
	                    END_IF;
	                    
	                END_REGION
	            ELSE
	                REGION 7.5.4 - Reverse
	                    
	                    IF (#sx_Gapping_Rvs          // Gapping needs to be applied bit
	                        AND ((#sdi_GapHeadToHeadConfiguration_Rvs > #sdi_GapHeadToHead_Rvs    // Configured head to head bigger than the actual one
	                        OR #sdi_GapHeadToHeadConfiguration_Rvs - #idi_PEC_BoSDistance / 10 + #sdi_PECtoEndDistance_Rvs > #sdi_DownstreamGapHeadToHead_Rvs
	                        OR #sdi_GapTailToHeadConfiguration_Rvs > #sdi_Gap_Rvs     // Configured gap bigger than the actual one
	                        OR #sdi_GapTailToHeadConfiguration_Rvs - #idi_PEC_BoSDistance / 10 + #sdi_PECtoEndDistance_Rvs > #sdi_DownstreamGapTailtoHead_Rvs)
	                        AND NOT #sx_RecoveryGap_Rvs)                                                // Die back recovery gap bit not active
	                        OR (((#sdi_GapHeadToHeadConfiguration_Rvs + #i_UDT_ConveyorConfiguration.ExtraGapRecovery)   // Add recovery gap to the configured
	                        > #sdi_GapHeadToHead_Rvs                                                                                 // Actual head to head distance
	                        OR (#sdi_GapHeadToHeadConfiguration_Rvs - #idi_PEC_BoSDistance / 10 + #sdi_PECtoEndDistance_Rvs + #i_UDT_ConveyorConfiguration.ExtraGapRecovery)
	                        > #sdi_DownstreamGapHeadToHead_Rvs
	                        OR (#sdi_GapTailToHeadConfiguration_Rvs + #i_UDT_ConveyorConfiguration.ExtraGapRecovery)    // Add recovery gap to the configured
	                        > #sdi_Gap_Rvs                                                                               // Actual gap between parcels
	                        OR (#sdi_GapTailToHeadConfiguration_Rvs - #idi_PEC_BoSDistance / 10 + #sdi_PECtoEndDistance_Rvs + #i_UDT_ConveyorConfiguration.ExtraGapRecovery)
	                        > #sdi_DownstreamGapTailtoHead_Rvs)
	                        AND #sx_RecoveryGap_Rvs))                                                                                // Recovery gap bit activate
	                    THEN
	                        
	                        #sdi_GapHeadToHead_Rvs -= #iq_UDT_HandShakeUp.DownstreamDisplacement;      // Increase head to head counter with conveyor downstream displacement
	                        #sdi_Gap_Rvs -= #iq_UDT_HandShakeUp.DownstreamDisplacement;     // Increase gap counter with conveyor downstream displacement
	                        
	                    ELSE
	                        
	                        #sx_Gapping_Rvs := FALSE;                   // Set gapping bit to false
	                        
	                    END_IF;
	                    
	                    IF #sx_Gapping_Rvs                              // Gapping bit active
	                        AND NOT #iq_UDT_HandShakeUp.RTR           // Ready to receive not active
	                    THEN
	                        
	                        #sx_RecoveryGap_Rvs := TRUE;                // Recovery gap activation after die back
	                        
	                    END_IF;
	                    
	                    IF #sx_RecoveryGap_Rvs                          // Recovery gap active
	                        AND NOT #sx_Gapping_Rvs                     // Gapping bit not active
	                    THEN
	                        
	                        #sx_RecoveryGap_Rvs := FALSE;               // Recovery gap disable
	                        
	                    END_IF;
	                    
	                END_REGION
	            END_IF;
	        END_REGION
	        
	        REGION 7.6 - Ready to send and Transfer in progress
	            IF NOT #sx_ReverseDirection
	            THEN
	                REGION 7.6.1 - Forward
	                    
	                    IF #iq_UDT_HandShake.RTR                                            // Ready to receive bit
	                        AND NOT #sx_Gapping_Fwd
	                        AND #sx_AuxHeadAtEnd_Fwd                                            // Parcel is at end of conveyor
	                        AND NOT #ix_ExternalRequestDieBack
	                    THEN
	                        
	                        #iq_UDT_HandShake.TIP := TRUE;      // Transfer in progress bit
	                        #iq_UDT_HandShake.RTS := FALSE;     // Ready to send bit
	                        #sx_AuxHeadAtEnd_Fwd := FALSE;
	                        
	                    END_IF;
	                    
	                    IF #R_TRIG_TailToBegin_Fwd.Q               // Reset TIP when the parcel leaves interlock
	                    THEN
	                        
	                        #iq_UDT_HandShake.TIP := FALSE;     // Transfer in progress bit
	                        
	                    END_IF;
	                    
	                END_REGION
	            ELSE
	                REGION 7.6.2 - Reverse
	                    
	                    IF #iq_UDT_HandShakeUp.RTR                                            // Ready to receive bit
	                        AND #iq_UDT_HandShake.RTR
	                        AND NOT #sx_Gapping_Rvs
	                        AND #sx_AuxHeadAtEnd_Rvs                                            // Parcel is at end of conveyor
	                        AND NOT #ix_ExternalRequestDieBack
	                    THEN
	                        
	                        #iq_UDT_HandShakeUp.TIP := TRUE;      // Transfer in progress bit
	                        #iq_UDT_HandShakeUp.RTS := FALSE;     // Ready to send bit
	                        #sx_AuxHeadAtEnd_Rvs := FALSE;
	                        
	                    END_IF;
	                    
	                    IF #R_TRIG_TailToBegin_Rvs.Q               // Reset TIP when the parcel leaves interlock
	                    THEN
	                        
	                        #iq_UDT_HandShakeUp.TIP := FALSE;     // Transfer in progress bit
	                        
	                    END_IF;
	                    
	                END_REGION
	            END_IF;
	        END_REGION
	        
	        REGION 7.7 - Downstream gap
	            
	            (* This functionality is used to maintain the gap between parcel conveyor's downstream.
	               To do this, is used the downstream displacement.  *)
	            IF NOT #sx_ReverseDirection
	            THEN
	                REGION 7.7.1 - Forward
	                    
	                    IF #R_TRIG_TailToBegin_Fwd.Q                       // When the parcel's tail reach the beginning of downstream conveyor
	                    THEN
	                        
	                        #sdi_DownstreamGapTailtoHead_Fwd := 0;                     // Reset downstream gap counter
	                        
	                    END_IF;
	                    
	                    IF #sdi_DownstreamGapTailtoHead_Fwd < #ci_OverflowLimit        // Prevent integer variable overflow
	                    THEN
	                        
	                        #sdi_DownstreamGapTailtoHead_Fwd += #iq_UDT_HandShake.DownstreamDisplacement;          // Downstream displacement gap counter
	                        
	                    END_IF;
	                    
	                END_REGION
	            ELSE
	                REGION 7.7.2 - Reverse
	                    
	                    IF #R_TRIG_TailToBegin_Rvs.Q                       // When the parcel's tail reach the beginning of downstream conveyor
	                    THEN
	                        
	                        #sdi_DownstreamGapTailtoHead_Rvs := 0;                     // Reset downstream gap counter
	                        
	                    END_IF;
	                    
	                    IF #sdi_DownstreamGapTailtoHead_Rvs < #ci_OverflowLimit        // Prevent integer variable overflow
	                    THEN
	                        
	                        #sdi_DownstreamGapTailtoHead_Rvs -= #iq_UDT_HandShakeUp.DownstreamDisplacement;          // Downstream displacement gap counter
	                        
	                    END_IF;
	                    
	                END_REGION
	            END_IF;
	        END_REGION
	        
	        REGION 7.8 - Downstream Head to Head
	            IF NOT #sx_ReverseDirection
	            THEN
	                REGION 7.8.1 - Forward
	                    
	                    #R_TRIG_Transfering_Fwd(CLK := #iq_UDT_HandShake.TIP);
	                    
	                    IF #R_TRIG_Transfering_Fwd.Q                                                           // Transfering aux bit rising trigger
	                    THEN
	                        
	                        #sdi_DownstreamGapHeadToHead_Fwd := 0;                                              // Downstream head to head reset counter
	                        
	                    END_IF;
	                    
	                    IF #sdi_DownstreamGapHeadToHead_Fwd < #ci_OverflowLimit                                 // Prevent integer variable overflow
	                    THEN
	                        
	                        #sdi_DownstreamGapHeadToHead_Fwd += #iq_UDT_HandShake.DownstreamDisplacement;       // Downstream displacement head to head counter 
	                        
	                    END_IF;
	                    
	                END_REGION
	            ELSE
	                REGION 7.8.2 - Reverse
	                    
	                    #R_TRIG_Transfering_Rvs(CLK := #iq_UDT_HandShake.TIP);
	                    
	                    IF #R_TRIG_Transfering_Rvs.Q                                                           // Transfering aux bit rising trigger
	                    THEN
	                        
	                        #sdi_DownstreamGapHeadToHead_Rvs := 0;                                              // Downstream head to head reset counter
	                        
	                    END_IF;
	                    
	                    IF #sdi_DownstreamGapHeadToHead_Rvs < #ci_OverflowLimit                                 // Prevent integer variable overflow
	                    THEN
	                        
	                        #sdi_DownstreamGapHeadToHead_Rvs -= #iq_UDT_HandShakeUp.DownstreamDisplacement;       // Downstream displacement head to head counter 
	                        
	                    END_IF;
	                    
	                END_REGION
	            END_IF;
	        END_REGION
	        
	        REGION 7.9 - Energy save
	            
	            (* Save energy functionality is used to stop conveyor if no parcels are in the system to save energy
	               Save energy function counts displacement if the photo eye do not detects parcels. The counter is reset if:
	               - Photo eye is triggered.
	               - Reset is required from external.
	               - Ready to send is active from upstream. *)
	            
	            // Energy save sensors filter 
	            IF NOT #ix_PEC_EoS OR NOT #ix_PEC_BoS
	            THEN
	                #si_EnergySaveFilter += ABS(IN := #iq_UDT_ConveyorInterface.Displacement);
	            ELSE
	                #si_EnergySaveFilter := 0;
	            END_IF;
	            
	            IF #i_UDT_ConveyorConfiguration.Energy                                       // Energy save functionality enable from configuration
	            THEN
	                
	                IF #sdi_AuxEnergySave_Fwd >= #i_UDT_ConveyorConfiguration.Forward_Direction.EnergySaveLenght        // Compare energy save counter with configured lenght
	                    OR #sdi_AuxEnergySave_Rvs >= #i_UDT_ConveyorConfiguration.Reverse_Direction.EnergySaveLenght
	                THEN
	                    #sx_EnergySaveActive := TRUE;                                           // Set energy save active true
	                END_IF;
	                
	                IF ((#si_EnergySaveFilter >= #ci_MinimumParcelLength)                                  // Photo eye detects a parcel
	                    AND NOT #sx_EnergySaveActive)                                         // Energy save active bit
	                    OR #ix_ResetEnergySave                                               // Reset energy save
	                    OR (#iq_UDT_HandShakeUp.ResetEnergySave AND NOT #sx_ReverseDirection)                               // Reset energy save externaly 
	                    OR (#iq_UDT_HandShake.ResetEnergySave AND #sx_ReverseDirection)
	                    OR NOT #iq_UDT_EquipmentControl.Command.AutomaticOn                  // Automatic ON from control block
	                    OR #iq_UDT_EquipmentControl.Command.Stop                             // Stop command from control block
	                THEN
	                    #sdi_AuxEnergySave_Fwd := 0;                                        // Reset energy save counter
	                    #sdi_AuxEnergySave_Rvs := 0;                                        // Reset energy save counter
	                    #sx_EnergySaveActive := FALSE;                                      // Set energy save active to false
	                ELSE
	                    // Increament displacement counter
	                    IF NOT #sx_ReverseDirection
	                    THEN
	                        #sdi_AuxEnergySave_Fwd += #iq_UDT_ConveyorInterface.Displacement;
	                    ELSE
	                        #sdi_AuxEnergySave_Rvs -= #iq_UDT_ConveyorInterface.Displacement;
	                    END_IF;
	                END_IF;
	                
	            ELSE
	                // If energy save functionality is disable from configuration
	                #sdi_AuxEnergySave_Fwd := 0;
	                #sdi_AuxEnergySave_Rvs := 0;// Reset energy save counter
	                #sx_EnergySaveActive := FALSE;                                      // Set energy save false
	            END_IF;
	            // Reset to downstream when not already in enery save on signal of PEC
	            // When slave conveyor pass reset esave command to master conveyor
	            
	            IF NOT #sx_ReverseDirection
	            THEN
	                #iq_UDT_HandShake.ResetEnergySave := (NOT #ix_PEC_EoS OR #sx_AuxHeadAtEnd_Fwd OR #iq_UDT_HandShake.TIP) AND NOT #sx_EnergySaveActive
	                OR (#i_UDT_ConveyorConfiguration.Forward_Direction.Mode = 1 AND #iq_UDT_HandShakeUp.ResetEnergySave);
	            ELSE
	                #iq_UDT_HandShakeUp.ResetEnergySave := (NOT #ix_PEC_BoS OR #sx_AuxHeadAtEnd_Rvs OR #iq_UDT_HandShakeUp.TIP) AND NOT #sx_EnergySaveActive
	                OR (#i_UDT_ConveyorConfiguration.Reverse_Direction.Mode = 1 AND #iq_UDT_HandShake.ResetEnergySave);
	            END_IF;
	        END_REGION
	        
	        REGION 7.10 - Operation modes
	            
	            // Different modes in automatic can be configured
	            // 1 - Slave
	            // 2 - Queue
	            // 3 - Bulk flow
	            
	            IF #sx_AutomaticActive                                          // Automatic mode active
	                AND #tx_CascadeStart                                        // Cascade startup
	            THEN
	                
	                IF NOT #sx_ReverseDirection
	                THEN
	                    
	                    CASE #i_UDT_ConveyorConfiguration.Forward_Direction.Mode OF                   // Operation mode configured 
	                            
	                        1:  // Slave
	                            
	                            // Run conveyor if ready to receive if on, and conveyor is not gapping,
	                            // and not halt request and not energy save active
	                            
	                            #iq_UDT_ConveyorInterface.RunFwd := #sx_AutomaticActive     // Automatic mode active
	                            AND #sx_Ready                                               // Ready active
	                            AND NOT #ix_ExternalRequestHold                             // Halt request is not active
	                            AND NOT #sx_EnergySaveActive                                // Energy save not active
	                            AND #iq_UDT_HandShake.RTR                               // Ready to receive active
	                            AND NOT #sx_DirectionChanged;
	                            
	                            #iq_UDT_HandShakeUp.RTR := #iq_UDT_ConveyorInterface.RunFwd;
	                            
	                        2:  // Master 
	                            
	                            // With queue configuration, conveyor runs if ready to receive is true.
	                            // If ready to receive is false, conveyor runs until parcel reach the end of the conveyor.
	                            
	                            // Conveyor stops if heads parcel reache the end of the conveyor and:
	                            // - Ready to receive is false
	                            // - Or die back requested.
	                            // - Or halt requested
	                            // Conveyor also stops if gapping is active or energy save mode active.
	                            
	                            #iq_UDT_ConveyorInterface.RunFwd := #sx_AutomaticActive             // Automatic mode active
	                            AND #sx_Ready                                                       // Ready active
	                            AND NOT #sx_DirectionChanged
	                            AND NOT #sx_Gapping_Fwd                                                 // Gapping request
	                            AND NOT #sx_EnergySaveActive                                        // Energy save request
	                            AND NOT #ix_ExternalRequestHold                                     // Halt requested from external
	                            AND ((NOT #ix_ExternalRequestDieBack
	                            AND #iq_UDT_HandShake.RTR)
	                            OR (NOT #sx_AuxHeadAtEnd_Fwd
	                            AND NOT #iq_UDT_HandShake.TIP)
	                            OR (#iq_UDT_HandShake.RTR
	                            AND NOT #sx_AuxHeadAtEnd_Fwd));
	                            
	                            #iq_UDT_HandShakeUp.RTR := #iq_UDT_ConveyorInterface.RunFwd;
	                            
	                            
	                        3: //Master at bulk flow
	                            
	                            #iq_UDT_ConveyorInterface.RunFwd := #sx_AutomaticActive             // Automatic mode active
	                            AND #sx_Ready                                                       // Ready active
	                            AND NOT #sx_DirectionChanged
	                            AND NOT #sx_EnergySaveActive                                        // Energy save request
	                            AND NOT #ix_ExternalRequestHold                                     // Halt requested from external
	                            AND (
	                            (NOT #ix_ExternalRequestDieBack                                     //no die back request and the downstream is running
	                            AND #iq_UDT_HandShake.RTR)
	                            OR                                                                  //..or..
	                            (#sdi_TransitionZone = 0)                                            // no parcels at the transition zone
	                            OR                                                                  //..or..
	                            (#iq_UDT_HandShake.RTR
	                            AND NOT #ix_ExternalRequestDieBack
	                            AND NOT (#sdi_TransitionZone = 0)));                                  //downstream is running and there are   
	                            
	                            //If PEC is blocked, reset tracking counter
	                            IF NOT #ix_PEC_EoS THEN
	                                #sdi_TransitionZone := #sdi_PEC_EoSDistance_Fwd / 10;
	                            END_IF;
	                            
	                            //Track parcels at the zone between EoS and conveyor end (Transition Zone)
	                            #sdi_TransitionZone := #sdi_TransitionZone - ABS(#iq_UDT_ConveyorInterface.Displacement);
	                            
	                            //If Value is negative then set to 0
	                            IF #sdi_TransitionZone < 0 THEN
	                                #sdi_TransitionZone := 0;
	                            END_IF;
	                            
	                            #iq_UDT_HandShakeUp.RTR := #iq_UDT_ConveyorInterface.RunFwd;
	                            
	                    END_CASE;
	                    
	                ELSE
	                    
	                    CASE #i_UDT_ConveyorConfiguration.Reverse_Direction.Mode OF                   // Operation mode configured 
	                            
	                        1:  // Slave
	                            
	                            // Run conveyor if ready to receive if on, and conveyor is not gapping,
	                            // and not halt request and not energy save active
	                            
	                            #iq_UDT_ConveyorInterface.RunRvs := #sx_AutomaticActive     // Automatic mode active
	                            AND #sx_Ready                                               // Ready active
	                            AND NOT #ix_ExternalRequestHold                             // Halt request is not active
	                            AND NOT #sx_EnergySaveActive                                // Energy save not active
	                            AND #iq_UDT_HandShakeUp.RTR                                 // Ready to receive active
	                            AND NOT #sx_DirectionChanged;
	                            
	                            #iq_UDT_HandShake.RTR := #iq_UDT_ConveyorInterface.RunRvs;
	                            
	                        2:  // Master 
	                            
	                            // With queue configuration, conveyor runs if ready to receive is true.
	                            // If ready to receive is false, conveyor runs until parcel reach the end of the conveyor.
	                            
	                            // Conveyor stops if heads parcel reache the end of the conveyor and:
	                            // - Ready to receive is false
	                            // - Or die back requested.
	                            // - Or halt requested
	                            // Conveyor also stops if gapping is active or energy save mode active.
	                            
	                            #iq_UDT_ConveyorInterface.RunRvs := #sx_AutomaticActive             // Automatic mode active
	                            AND #sx_Ready                                                       // Ready active
	                            AND NOT #sx_DirectionChanged
	                            AND NOT #sx_Gapping_Rvs                                             // Gapping request
	                            AND NOT #sx_EnergySaveActive                                        // Energy save request
	                            AND NOT #ix_ExternalRequestHold                                     // Halt requested from external
	                            AND ((NOT #ix_ExternalRequestDieBack
	                            AND #iq_UDT_HandShakeUp.RTR)
	                            OR (NOT #sx_AuxHeadAtEnd_Rvs
	                            AND NOT #iq_UDT_HandShakeUp.TIP)
	                            OR (#iq_UDT_HandShakeUp.RTR
	                            AND NOT #sx_AuxHeadAtEnd_Rvs));
	                            
	                            #iq_UDT_HandShake.RTR := #iq_UDT_ConveyorInterface.RunRvs;
	                            
	                            
	                        3: //Master at bulk flow
	                            
	                            #iq_UDT_ConveyorInterface.RunRvs := #sx_AutomaticActive             // Automatic mode active
	                            AND #sx_Ready                                                       // Ready active
	                            AND NOT #sx_DirectionChanged
	                            AND NOT #sx_EnergySaveActive                                        // Energy save request
	                            AND NOT #ix_ExternalRequestHold                                     // Halt requested from external
	                            AND (
	                            (NOT #ix_ExternalRequestDieBack                                     //no die back request and the downstream is running
	                            AND #iq_UDT_HandShakeUp.RTR)
	                            OR                                                                  //..or..
	                            (#sdi_TransitionZone = 0)                                            // no parcels at the transition zone
	                            OR                                                                  //..or..
	                            (#iq_UDT_HandShakeUp.RTR
	                            AND NOT #ix_ExternalRequestDieBack
	                            AND NOT (#sdi_TransitionZone = 0)));                                  //downstream is running and there are   
	                            
	                            //If PEC is blocked, reset tracking counter
	                            IF NOT #ix_PEC_BoS THEN
	                                #sdi_TransitionZone := #sdi_PEC_EoSDistance_Rvs / 10;
	                            END_IF;
	                            //Track parcels at the zone between EoS and conveyor end (Transition Zone)
	                            #sdi_TransitionZone := #sdi_TransitionZone - ABS(#iq_UDT_ConveyorInterface.Displacement);
	                            
	                            //If Value is negative then set to 0
	                            IF #sdi_TransitionZone < 0 THEN
	                                #sdi_TransitionZone := 0;
	                            END_IF;
	                            
	                            #iq_UDT_HandShake.RTR := #iq_UDT_ConveyorInterface.RunRvs;
	                    END_CASE;
	                    
	                END_IF;
	                
	            ELSE
	                
	                // If conveyor is not in manual mode and not ready
	                IF NOT #sx_ReverseDirection
	                THEN
	                    #iq_UDT_ConveyorInterface.RunFwd := FALSE;                      // Order to VFD stop conveyor
	                    #iq_UDT_HandShakeUp.RTR := FALSE;                               // Set ready to receive false
	                ELSE
	                    #iq_UDT_ConveyorInterface.RunRvs := FALSE;                      // Order to VFD stop conveyor
	                    #iq_UDT_HandShake.RTR := FALSE;                               // Set ready to receive false
	                END_IF;
	                
	            END_IF;
	            
	        END_REGION
	        
	    END_IF;
	END_REGION
	
	REGION 8 - Speed control
	    
	    (*In manual mode, conveyor default runs with manual speed which is calculated as a percentage of nominal speed. If "ManualFullSpeed" is set true, conveyor runs with high speed in manual mode. 
	     In jog mode conveyor always runs in low speed. In automatic mode, conveyor runs with full speed if external is zero. If external speed is bigger than zero, conveyor will run with that speed. *)
	    
	    
	    // security
	    IF #iq_UDT_ConveyorCommand.ManualSpeed > 100 THEN
	        #iq_UDT_ConveyorCommand.ManualSpeed := 100;
	    END_IF;
	    
	    IF #iq_UDT_ConveyorCommand.ManualSpeed < 0 THEN
	        #iq_UDT_ConveyorCommand.ManualSpeed := 0;
	    END_IF;
	    
	    
	    
	    IF #sx_ManualModeActive                                                                         // Manual mode active
	    THEN
	        
	        IF #iq_UDT_ConveyorCommand.ManualStartStop                                              // Full speed in manual mode
	        THEN
	            
	            IF #iq_UDT_ConveyorCommand.ManualFullSpeed                                                  // Full speed in manual mode
	            THEN
	                #iq_UDT_ConveyorInterface.SpeedSetpoint := #i_UDT_ConveyorConfiguration.SpeedSetpointNominal;    // Move nominal setpoint to the VDF
	                
	            ELSE
	                #iq_UDT_ConveyorInterface.SpeedSetpoint := REAL_TO_INT(INT_TO_REAL(#iq_UDT_ConveyorCommand.ManualSpeed) * (INT_TO_REAL(#i_UDT_ConveyorConfiguration.SpeedSetpointNominal) / 100));     // Calculate and Move manual speed setpoint to VFD
	                
	            END_IF;
	            
	        ELSE                                                                                             //low speed for jog mode
	            
	            IF #i_UDT_ConveyorConfiguration.SpeedSetpointLow < #i_UDT_ConveyorConfiguration.SpeedSetpointNominal  //Low speed can't be higher than nominal speed 
	            THEN
	                #iq_UDT_ConveyorInterface.SpeedSetpoint := #i_UDT_ConveyorConfiguration.SpeedSetpointLow;    // Move low speed setpoint to the VDF
	                
	            ELSE
	                
	                #iq_UDT_ConveyorInterface.SpeedSetpoint := #i_UDT_ConveyorConfiguration.SpeedSetpointNominal;    // Move low speed setpoint to the VDF
	            END_IF;
	        END_IF;
	        
	        
	        
	    ELSE
	        
	        IF #ii_ExternalSpeed > 0                                                                      // If external speed bigger than zero
	        THEN
	            #iq_UDT_ConveyorInterface.SpeedSetpoint := #ii_ExternalSpeed;                                     // Move external speed to VFD
	        ELSE
	            #iq_UDT_ConveyorInterface.SpeedSetpoint := #i_UDT_ConveyorConfiguration.SpeedSetpointNominal;       // Move nominal setpoint to VFD
	        END_IF;
	        
	    END_IF;
	    
	    
	    
	END_REGION
	
	
	REGION 9 - Status
	    #s_UDT_HMIStatus.Specific.Reverse := #sx_ReverseDirection;
	    
	    // stopped 
	    #s_UDT_CommonStatus.Stopped := NOT #sx_Ready OR NOT #sx_AutomaticActive;
	    
	    // Auto ON
	    #s_UDT_CommonStatus.AutoON := #sx_Ready AND #sx_AutomaticActive;
	    
	    // Running
	    #s_UDT_CommonStatus.Running := #iq_UDT_ConveyorInterface.RunFwd
	    OR #iq_UDT_ConveyorInterface.RunRvs;
	    
	    // Halted
	    #s_UDT_CommonStatus.Halted := #ix_ExternalRequestHold
	    AND #s_UDT_CommonStatus.AutoON
	    AND NOT #s_UDT_CommonStatus.EnergySave;
	    
	    // Energy save active
	    #s_UDT_CommonStatus.EnergySave := #sx_EnergySaveActive AND #sx_AutomaticActive;
	    
	    // Die back
	    #s_UDT_CommonStatus.Dieback := #s_UDT_CommonStatus.AutoON
	    AND NOT #s_UDT_CommonStatus.EnergySave
	    AND NOT #s_UDT_CommonStatus.Running;
	    
	    // Manual
	    #s_UDT_CommonStatus.Manual := #sx_ManualModeActive;
	    
	    // Manual Running
	    #s_UDT_CommonStatus.ManualRun := #sx_ManualModeActive AND #s_UDT_CommonStatus.Running;
	    
	    // Safety not ok
	    #s_UDT_CommonStatus.SafetyStop := NOT #ix_SafetyOk AND #ix_HardwareOk;
	    
	    // HMI status update
	    IF #s_UDT_CommonStatusOld <> #s_UDT_CommonStatus                                            // update on change
	        OR (#R_TRIG_Reverse.Q OR #F_TRIG_Reverse.Q)
	    THEN
	        // HMI status initialization
	        #s_UDT_HMIStatus.Status := 0;
	        
	        
	        // Energy save
	        IF #s_UDT_CommonStatus.EnergySave
	        THEN
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".EnergySave;
	        END_IF;
	        
	        // Running
	        IF #s_UDT_CommonStatus.Running
	        THEN
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Running;
	        END_IF;
	        
	        // Stopped
	        IF #s_UDT_CommonStatus.Stopped
	        THEN
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Stopped;
	        END_IF;
	        
	        // Dieback
	        IF #s_UDT_CommonStatus.Dieback
	        THEN
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Dieback;
	        END_IF;
	        
	        // Halted
	        IF #s_UDT_CommonStatus.Halted
	        THEN
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Halted;
	        END_IF;
	        
	        // Manual
	        IF #s_UDT_CommonStatus.Manual
	        THEN
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Manual;
	        END_IF;
	        
	        // Running in manual mode
	        IF #s_UDT_CommonStatus.ManualRun
	        THEN
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".ManualRun;
	        END_IF;
	        
	(*        // Internal tracking warning
	        IF #iq_UDT_ConveyorInterface.InternalWarningTracking
	        THEN
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Warning;
	        END_IF; *)
	        
	        // Internal tracking error
	        IF #iq_UDT_ConveyorInterface.InternalErrorTracking
	        THEN
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".TrackingError;
	        END_IF;
	        
	        // Internal PEC error
	        IF #iq_UDT_ConveyorInterface.InternalErrorPEC
	        THEN
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".PECJam;
	        END_IF;
	        
	        // Internal Encoder error
	        IF #iq_UDT_ConveyorInterface.InternalErrorEncoder
	        THEN
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".EncoderError;
	        END_IF;
	        
	        // Internal VFD error
	        IF #iq_UDT_ConveyorInterface.InternalErrorVFD
	        THEN
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".VFDError;
	        END_IF;
	        
	        // Disconnect error
	        IF #iq_UDT_ConveyorInterface.Disconnected
	        THEN
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".CBError;
	        END_IF;
	        
	        // Safety stop
	        IF (#s_UDT_CommonStatus.SafetyStop)
	        THEN
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".SafetyStop;
	        END_IF;
	        
	        #s_UDT_CommonStatusOld := #s_UDT_CommonStatus;              // Copy status to memory
	        #q_UDT_Status := #s_UDT_CommonStatus;                       // Copy status to output
	        
	    END_IF;
	    
	    // Copy HMI status to output
	    #q_UDT_HMIStatus := #s_UDT_HMIStatus;
	    
	END_REGION
	
	
	REGION 10 - Statistics
	    
	    REGION 10.1 - Conveyor up time
	        
	        IF #sx_Up OR #iq_UDT_EquipmentControl.Command.ResetData    // Reset statistics
	        THEN
	            
	            "FC_Statistics"(ix_Reset := #iq_UDT_EquipmentControl.Command.ResetData,      // Reset statistics input
	                            ix_Activate := #sx_Up,
	                            ix_RTrigActivate := #R_TRIG_ConveyorUp.Q,                     // Statistics active trigger
	                            iqUDT_Statistics := #iq_UDT_Statistics.ConveyorUp);      // Statistics values output
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 10.2 - Energy save
	        
	        // Statistics Energy save mode active
	        IF #s_UDT_CommonStatus.EnergySave(* #sx_EnergySaveActive *)                                                        // Energy save active
	            OR #iq_UDT_EquipmentControl.Command.ResetData                               // Reset statistics
	        THEN
	            "FC_Statistics"(ix_Reset := #iq_UDT_EquipmentControl.Command.ResetData,      // Reset statistics input
	                            ix_Activate := #s_UDT_CommonStatus.EnergySave,                         // Activate statistics functions input
	                            ix_RTrigActivate := #R_TRIG_EnergySave.Q,                    // Statistics active trigger
	                            iqUDT_Statistics := #iq_UDT_Statistics.EnergySave);         // Statistics values output
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 10.3 - Conveyor down time
	        
	        // Conveyor down is when conveyor is not in manual mode and has an error
	        IF #sx_Down OR #iq_UDT_EquipmentControl.Command.ResetData OR #s_UDT_CommonStatus.SafetyStop                                    // Reset statistics
	        THEN
	            
	            "FC_Statistics"(ix_Reset := #iq_UDT_EquipmentControl.Command.ResetData,             // Reset statistics input
	                            ix_Activate := #sx_Down OR #s_UDT_CommonStatus.SafetyStop, // Activate statistics functions input
	                            ix_RTrigActivate := #R_TRIG_ConveyorDownTime.Q,                     // Statistics active trigger
	                            iqUDT_Statistics := #iq_UDT_Statistics.ConveyorDown);              // Statistics values output
	            
	        END_IF;
	    END_REGION
	    
	    REGION 10.4 - Conveyor stop time
	        
	        IF #sx_Stopped OR #iq_UDT_EquipmentControl.Command.ResetData                                           // Reset statistics
	        THEN
	            
	            "FC_Statistics"(ix_Reset := #iq_UDT_EquipmentControl.Command.ResetData,        // Reset statistics input
	                            ix_Activate := #sx_Stopped,                                           // Activate statistics functions input
	                            ix_RTrigActivate := #R_TRIG_ConveyorStopped.Q,                        // Statistics active trigger
	                            iqUDT_Statistics := #iq_UDT_Statistics.ConveyorStop);                  // Statistics values output
	            
	        END_IF;
	    END_REGION
	    
	END_REGION
	
	REGION 11 - Report to control block    
	    // Function to manage report between control block and conveyor block
	    "FC_EquipmentReport"(iUDT_Status := #s_UDT_CommonStatus,
	                         iqUDT_Control := #iq_UDT_EquipmentControl);
	    
	END_REGION
	
	REGION 12 - Internal errors and warnings reset
	    
	    IF #iq_UDT_EquipmentControl.Command.Reset
	    THEN
	        
	        #iq_UDT_ConveyorInterface.InternalErrorEncoder := FALSE;
	        #iq_UDT_ConveyorInterface.InternalErrorPEC := FALSE;
	        #iq_UDT_ConveyorInterface.InternalWarningTracking := FALSE;
	        #iq_UDT_ConveyorInterface.InternalErrorTracking := FALSE;
	        #iq_UDT_ConveyorInterface.InternalWarningVFD := FALSE;
	        #iq_UDT_ConveyorInterface.InternalErrorVFD := FALSE;
	        #iq_UDT_ConveyorInterface.Disconnected := FALSE;
	        #iq_UDT_ConveyorInterface.ConfigurationError := FALSE;
	    END_IF;
	    
	END_REGION
	
	
	
	
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_ConnectionCheck1Hz"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 3.2
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 93
// END_ATTRIBUTES
   VAR_INPUT 
      ix_LifebitIn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Input life bit
      ix_IOModuleOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when IO module is Ok
   END_VAR

   VAR_OUTPUT 
      qx_LifebitOut { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Generated life bit 1 sec ON/1 sec OFF
   END_VAR

   VAR_IN_OUT 
      iqudt_ConnectionStatus : "UDT_ConnectStatus";   // Connection status
   END_VAR

   VAR 
      FB_Pulse_Instance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Pulse";
      F_TRIG_LifebitIn {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger Lifebit in
      R_TRIG_LifebitIn {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger  Lifebit in
      sx_LifebitValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Lifebit value
      sx_ConnectionFault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Connection Fault
   END_VAR

   VAR_TEMP 
      tx_Pulse : Bool;   // Generated pulse signal
   END_VAR

   VAR CONSTANT 
      cudi_ConnectionFaultOnDelay : UDInt := 5000;   // Connection On Delay
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------   
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	12/10/2023  | 1.0       | S. Nikodem    | First release TIA 17 | DHL Munich
	12/03/2024  | 1.1       | S. Nieswiec      | Added to new Baseline
	*)
	
	REGION 1 - Life bit generations
	    
	    //Generation
	    #qx_LifebitOut := "DB_Memory".Clock_1Hz;
	    
	END_REGION
	
	REGION 2 - Hardware Ok
	    
	    IF NOT #ix_IOModuleOK THEN
	        
	        //Status update
	        #iqudt_ConnectionStatus.Specific.CommunicationFault := False;
	        #iqudt_ConnectionStatus.Specific.Connected := False;
	        
	        #iqudt_ConnectionStatus.Status := 0;
	        
	        RETURN;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Connection check
	    
	    //Trigger
	    #F_TRIG_LifebitIn(CLK := #ix_LifebitIn);
	    #R_TRIG_LifebitIn(CLK := #ix_LifebitIn);
	    
	    IF (#F_TRIG_LifebitIn.Q OR #R_TRIG_LifebitIn.Q) THEN
	        
	        #sx_LifebitValue := TRUE;
	    END_IF;
	    
	    #FB_Pulse_Instance(iudi_PulseTime := #cudi_ConnectionFaultOnDelay,
	                       qx_Pulse => #tx_Pulse);
	    
	    IF #tx_Pulse THEN
	        IF #sx_LifebitValue THEN
	            
	            #sx_LifebitValue := False;
	            
	            #sx_ConnectionFault := False;
	            
	        ELSE
	            
	            #sx_ConnectionFault := TRUE;
	            
	        END_IF;
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Status update
	    
	    #iqudt_ConnectionStatus.Specific.CommunicationFault := #sx_ConnectionFault;
	    #iqudt_ConnectionStatus.Specific.Connected := NOT #sx_ConnectionFault;
	    
	    IF #sx_ConnectionFault
	    THEN
	        #iqudt_ConnectionStatus.Status := "DB_HMIStatusConfiguration".CommunicationError;
	    END_IF;
	    
	    IF NOT #sx_ConnectionFault
	    THEN
	        #iqudt_ConnectionStatus.Status := "DB_HMIStatusConfiguration".AutoON;
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_Xray_Rapiscan"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 110
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_XrayConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_XrayRapiscanConfiguration";   // Xray configuration structure
      ix_XrayEnergised { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Xray input signal - Energised
      ix_XrayFault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Xray input signal - Fault
      ix_XrayReadyReceive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Xray input signal - Ready receive
      ix_XrayReadySend { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Xray input signal - Ready send
      ix_XrayConveyorRunFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Xray input signal - Conveyor run Fwd
      ix_XrayConveyorRunRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Xray input signal - Conveyor run Rvs
      ix_XrayBagScaning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Xray input signal - Xray bag scaning
      ix_XrayEmergencyStop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Xray input signal - Emergency Stop
      ix_SafetyOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when Safety Circuit is healthy
      ix_24vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 24VDC is healthy
      ix_400vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 400VAC is healthy
      ix_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when  hardware is Ok
      ix_SafetyReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE Safety reset command is active
      is_ActualTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Actual date and time in String
   END_VAR

   VAR_OUTPUT 
      q_UDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_RapiscanStatus";   // HMI status structure
      qx_BHS_RDY_SEND { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Xray output signal - Input conveyor is ready to pass a bag to the Xray
      qx_BHS_RDY_RCV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Xray output signal - Output conveyor is ready to accept a bag from the Xray
      qx_DECISION_ACK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Xray output signal - Decision confirmation (only for Xray local control)
      qx_TRANSPORT_ENABLE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Xray output signal - Transport mode eneble
      qx_TRANSPORT_FWD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Xray output signal - Run forward request
      qx_TRANSPORT_REV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Xray output signal - Run reverse request
      qx_ESTOP_IN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Xray output signal - Estop
      qx_EMERGENCY_STOP_RESET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Xray output signal - Estop resert
   END_VAR

   VAR_IN_OUT 
      iq_UDT_Statistics : "UDT_RapiscanStatistics";   // Statistics structure
      iq_UDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control stucture
      iq_UDT_XrayConveyorInterface : "UDT_ConveyorInterface";   // Xray conveyor interface structure
      iq_UDT_Handshake : "UDT_ConveyorHandshake";   // Downstream handshake structure
      iq_UDT_HandShakeUp : "UDT_ConveyorHandshake";   // Upstream handshake structure
      iq_UDT_MFCCommand : "UDT_XrayCommand";   // Xray command structure
      iqs_XrayConveyorTrackingData : Array[*] of Int;   // Xray conveyor tracking array
      iq_UDT_XrayInterface : "UDT_XrayInterface";   // Xray interface structure
   END_VAR

   VAR 
      s_EstopReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Estop reset puls
      s_BagScaningTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Bag scaning time
      s_UDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RapiscanStatus";   // HMI status structure
      s_UDT_CommonStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Common status structure
      s_UDT_CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Common status structure
      R_TRIG_TransportMode {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of Xray transport mode signal
      R_TRIG_XrayBagScaning {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of Xray b ag scaning signal
      F_TRIG_XrayBagScaning {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger of Xray b ag scaning signal
      R_TRIG_SystemReadyRcv {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of System ready to receive signal
      F_TRIG_SystemReadyRcv {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger of System ready to receive signal
      F_TRIG_ConveyorRunRvs {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger of Conveyor runs reverse direction signal
      ss_Counter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Statistics counters
         BagIDMessageNotReceived { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Bag ID Message not received on time
         TransportmodeOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Transport mode on
         TransportmodeOff { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Transport mode off
         BackBelt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Backbelt functionality active
      END_STRUCT;
      si_GIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // GIN number
      sx_StartReceived { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start command received from system
      sx_Ready { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Ready to operate in Automatic mode
      sx_AutomaticOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Automatic mode active
      sx_TransportmodeOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Transport mode active
      sx_TransportRunFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Transport mode - Run forward request
      sx_SystemReadyRcv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // System is ready to receive signal
      sx_ParcelInScanningArea { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parcel is in scanning area
   END_VAR

   VAR_TEMP 
      ti_ScanningWindow : Int;   // Loop counter - To check if some parcel is in the scanning area
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	07/03/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/03/2024  | 1.1       | S. Nieswiec  | Added to new baseline
	02/05/2024  | 1.2       | J.Majer      | Datatype conversions changed from automatic to explicit, to accomodate IEC 61131-3 standard
	*)
	
	REGION 1 - Triggers
	    
	    //Transport mode
	    #R_TRIG_TransportMode(CLK := #sx_TransportmodeOn);
	    
	    //Xray Bag Scaning
	    #R_TRIG_XrayBagScaning(CLK := #ix_XrayBagScaning);
	    #F_TRIG_XrayBagScaning(CLK := #ix_XrayBagScaning);
	    
	    //System is ready to receive
	    //Rising edge trigger
	    #R_TRIG_SystemReadyRcv(CLK := #sx_SystemReadyRcv);
	    //Falling edge trigger
	    #F_TRIG_SystemReadyRcv(CLK := #sx_SystemReadyRcv);
	    
	    //Conveyor runs reverse direction
	    #F_TRIG_ConveyorRunRvs(CLK := #ix_XrayConveyorRunRvs);
	    
	END_REGION
	
	REGION 2 - Operation conditions
	    //Add doors sensors to conditions
	    
	    #sx_Ready := #ix_SafetyOk
	    AND #ix_24vOk
	    AND #ix_400vOk
	    AND #ix_HardwareOk
	    AND #ix_XrayEnergised
	    AND NOT #ix_XrayFault;
	    
	END_REGION
	
	REGION 3 - Communication with Xray 
	    
	    //When BagScanning signal is active then check at the decision point what parcel is there
	    IF #R_TRIG_XrayBagScaning.Q THEN
	        
	        #iq_UDT_XrayInterface.Communication.SendMessage.GIN := #si_GIN := #iqs_XrayConveyorTrackingData[UDINT_TO_INT(#i_UDT_XrayConfiguration.BagIDPoint)];
	        
	    END_IF;
	    
	    #s_BagScaningTime(iudi_OnDelayTime := #i_UDT_XrayConfiguration.IDmessageTimeout,
	                      ix_SignalToDelay := #ix_XrayBagScaning);
	    
	    IF #s_BagScaningTime.qx_DelayedSignal
	        AND (#si_GIN > 0)
	        AND NOT "DB_GIN".GIN[#si_GIN].DHL.Xray.BagIDMessage.NotReceived
	    THEN
	        
	        //Set variable
	        "DB_GIN".GIN[#si_GIN].DHL.Xray.BagIDMessage.NotReceived := TRUE;
	        
	        //Only for statisctics
	        #ss_Counter.BagIDMessageNotReceived += 1;
	        
	    END_IF;
	    
	    IF #F_TRIG_XrayBagScaning.Q
	        AND NOT "DB_GIN".GIN[#si_GIN].DHL.Xray.BagIDMessage.NotReceived
	    THEN
	        //Set varaible
	        "DB_GIN".GIN[#si_GIN].DHL.Xray.BagIDMessage.Received := True;
	        //Save time
	        "DB_GIN".GIN[#si_GIN].DHL.Xray.BagIDMessage.TimeReceived := #is_ActualTime;
	        
	    END_IF;
	    
	    //Copy send message tirgger to Xray Interface
	    #iq_UDT_XrayInterface.Communication.SendMessage.SendTrigger := #R_TRIG_XrayBagScaning.Q;
	    
	END_REGION
	
	REGION 4 - Automatic/scan mode
	    
	    //Automatic mode start
	    IF #iq_UDT_EquipmentControl.Command.Start                                                                       // If Start command from from system received 
	    THEN
	        #sx_StartReceived := True;
	        
	    END_IF;
	    
	    IF #sx_StartReceived AND
	        #iq_UDT_Handshake.CascadeStartUp
	    THEN
	        
	        #sx_AutomaticOn := TRUE;                                                                            // Set Automatic active
	        #sx_StartReceived := FALSE;                                                                                 // and reset start received bit
	    END_IF;
	    
	    //Automatic mode stop
	    IF (NOT #iq_UDT_EquipmentControl.Command.AutomaticOn                                                             // if Stop active from system control ( Means Not automatic ON)
	        AND NOT #iq_UDT_EquipmentControl.Command.Start                                                              // And no start command from system control
	        AND #sx_AutomaticOn)
	        OR #s_UDT_CommonStatus.Error
	    THEN
	        
	        #sx_AutomaticOn := FALSE;
	        
	    END_IF;
	    
	    //Conveyor before Xray device
	    // Input conveyor is ready to pass a bag to the Xray machine
	    #qx_BHS_RDY_SEND := #sx_AutomaticOn AND #iq_UDT_Handshake.TIP;
	    
	    //Conveyor after Xray device
	    //Output conveyor is ready to accept a bag from the Xray machine
	    #sx_SystemReadyRcv := #sx_AutomaticOn
	    AND #sx_Ready
	    AND #ix_XrayReadyReceive
	    AND #iq_UDT_HandShakeUp.RTR
	    AND (NOT #iq_UDT_XrayInterface.Backbelt.Enable
	    OR (#iq_UDT_XrayInterface.Backbelt.Enable));
	    
	    //Copy static variable to output
	    #qx_BHS_RDY_RCV := #sx_SystemReadyRcv;
	    
	END_REGION
	
	REGION 5 - Transport mode
	    //Transport mode in automatic mode add condition-     #iq_UDT_OutputConveyor.RTR
	    
	    //Set Transport mode
	    IF #iq_UDT_MFCCommand.TransportModeOn THEN
	        
	        //Set static variable
	        #sx_TransportmodeOn := TRUE;
	        
	        //Reset command
	        #iq_UDT_MFCCommand.TransportModeOn := FALSE;
	        
	        //Only for statisctics
	        #ss_Counter.TransportmodeOn += 1;
	        
	    END_IF;
	    
	    //Reset Transport mode
	    IF #iq_UDT_MFCCommand.TransportModeOff THEN
	        
	        //Set static variable
	        #sx_TransportmodeOn := FALSE;
	        
	        //Reset command
	        #iq_UDT_MFCCommand.TransportModeOff := FALSE;
	        
	        //Only for statisctics
	        #ss_Counter.TransportmodeOff += 1;
	        
	    END_IF;
	    
	    //Copy value to output
	    #qx_TRANSPORT_ENABLE := #sx_TransportmodeOn
	    AND #sx_Ready
	    AND #sx_AutomaticOn;
	    
	    //Run forward request
	    #sx_TransportRunFwd := #sx_TransportmodeOn AND #iq_UDT_HandShakeUp.RTR;
	    
	    #qx_TRANSPORT_FWD := #sx_TransportRunFwd;
	    
	    //Run reverse request - not used
	    #qx_TRANSPORT_REV := FALSE;
	    
	END_REGION
	
	REGION 6 - Dieback / Backbelt operation
	    
	    REGION 6.1 - Parcel is in the scanning area
	        
	        //Reset varaible
	        #sx_ParcelInScanningArea := False;
	        
	        //Check if some parcel is in the scanning area
	        IF #F_TRIG_SystemReadyRcv.Q THEN
	            
	            FOR #ti_ScanningWindow := #i_UDT_XrayConfiguration.ScanningWindowStartPoint TO #i_UDT_XrayConfiguration.ScanningWindowEndPoint DO
	                
	                IF #iqs_XrayConveyorTrackingData[#ti_ScanningWindow] > 0 THEN
	                    
	                    #sx_ParcelInScanningArea := TRUE;
	                    
	                END_IF;
	                
	            END_FOR;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 6.2 - Backbelt
	        
	        //Set variable Backbelt if the conditions pass
	        IF #F_TRIG_SystemReadyRcv.Q
	            AND #sx_ParcelInScanningArea
	            AND NOT #ix_XrayReadyReceive
	            AND NOT #ix_XrayConveyorRunFwd
	            AND #iq_UDT_XrayInterface.Backbelt.Enable
	            AND NOT #iq_UDT_XrayInterface.Backbelt.Active
	        THEN
	            
	            #iq_UDT_XrayInterface.Backbelt.Active := True;
	            
	            //Only for staristics
	            #ss_Counter.BackBelt += 1;
	            
	        END_IF;
	        
	        IF (#F_TRIG_ConveyorRunRvs.Q
	            OR #R_TRIG_SystemReadyRcv.Q)
	            AND #iq_UDT_XrayInterface.Backbelt.Active
	        THEN
	            
	            #iq_UDT_XrayInterface.Backbelt.Active := False;
	            
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 6 - Handshake
	    
	    //Machine is ready to receive a bag for scanning
	    #iq_UDT_Handshake.RTR := (NOT #sx_TransportmodeOn AND #ix_XrayReadyReceive) OR (#sx_TransportmodeOn AND #ix_XrayConveyorRunFwd);
	    
	    //Machine ready to send a bag from "Exit Sensor"
	    #iq_UDT_HandShakeUp.RTS := (NOT #sx_TransportmodeOn AND #ix_XrayReadySend) OR (#sx_TransportmodeOn AND #ix_XrayConveyorRunFwd);
	    
	END_REGION
	
	REGION 7 - Errors
	    
	    //Safety reset
	    //Generate pulse
	    #s_EstopReset(iudi_OffDelayTime := #i_UDT_XrayConfiguration.EstopResetPluse,
	                  ix_SignalToDelay := #ix_SafetyReset AND #ix_SafetyOk);
	    
	    #qx_EMERGENCY_STOP_RESET := #s_EstopReset.ix_SignalToDelay;
	    
	    //Estop / To check
	    #qx_ESTOP_IN := #ix_SafetyOk;
	    
	END_REGION
	
	
	REGION 8 - Status
	    
	    
	    
	    // Safety not ok
	    #s_UDT_CommonStatus.SafetyStop := NOT #ix_SafetyOk AND #ix_HardwareOk;
	    
	    //Error
	    #s_UDT_CommonStatus.Error := NOT #sx_Ready;
	    
	    // HMI status update
	    IF #s_UDT_CommonStatusOld <> #s_UDT_CommonStatus                                      // update on change
	        
	    THEN
	        // HMI status initialization
	        #s_UDT_HMIStatus.Status := 0;
	        
	        
	        // Safety stop
	        IF (#s_UDT_CommonStatus.SafetyStop)
	        THEN
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".SafetyStop;
	        END_IF;
	        
	        // Error
	        IF (#s_UDT_CommonStatus.Error)
	        THEN
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Error;
	        END_IF;
	        
	        #s_UDT_CommonStatusOld := #s_UDT_CommonStatus;              // Copy status to memory
	        
	        
	    END_IF;
	    
	    
	    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	    
	    // Xray machine errors and arnings
	    #s_UDT_HMIStatus.XraySpecific.XrayEnergised := #ix_XrayEnergised;
	    #s_UDT_HMIStatus.XraySpecific.XrayFault := #ix_XrayFault;
	    #s_UDT_HMIStatus.XraySpecific.XrayRdyRCV := #ix_XrayReadyReceive;
	    #s_UDT_HMIStatus.XraySpecific.XrayRdySend := #ix_XrayReadySend;
	    #s_UDT_HMIStatus.XraySpecific.BagScanning := #ix_XrayBagScaning;
	    #s_UDT_HMIStatus.ConvSpecific.ConvRunFWD := #ix_XrayConveyorRunFwd;
	    #s_UDT_HMIStatus.ConvSpecific.ConvRunREV := #ix_XrayConveyorRunRvs;
	    
	    //Copy value to interface
	    #iq_UDT_XrayInterface.XrayConveyor.RunFwd := #ix_XrayConveyorRunFwd;
	    #iq_UDT_XrayInterface.XrayConveyor.RunRvs := #ix_XrayConveyorRunRvs;
	    
	    //Xray
	    "FC_EquipmentReport"(iUDT_Status := #s_UDT_CommonStatus,
	                         iqUDT_Control := #iq_UDT_EquipmentControl);
	    
	    // Copy HMI status to output
	    #q_UDT_HMIStatus := #s_UDT_HMIStatus;
	    
	END_REGION
	
	REGION 9 - Statistics
	    
	    // Transport mode active   
	    IF (NOT #s_UDT_CommonStatus.Stopped AND #sx_TransportmodeOn)
	        OR #iq_UDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iq_UDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := NOT #s_UDT_CommonStatus.Stopped AND #sx_TransportmodeOn,
	                        ix_RTrigActivate := #R_TRIG_TransportMode.Q,
	                        iqUDT_Statistics := #iq_UDT_Statistics.TransportMode);
	    END_IF;
	    
	    
	    
	    
	    
	    
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_CodingBeltModes_Van_Line"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 91
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_Configuration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CodingBeltModesConfiguration";   // Function configuration
      ii_Displacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Conveyor displacement in one PLC cycle [cm]
      ix_KneeButton { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Knee button
      ix_LabellingMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Local switch Labeling mode
      ix_ContinueMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Local switch Continue mode
      ix_BufferMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Local switch Buffer mode
      ix_LineModeInfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Interface with main line - bool or new UDT??? Infeed and Outfeed?
      ix_LineModeOutfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Interface with main line - bool or new UDT??? Infeed and Outfeed?
      ix_PEC_BoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // BoS sensor
      ix_PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // EoS sensor
   END_VAR

   VAR_OUTPUT 
      q_UDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CodingBeltModesStatus";   // Status
      qx_RequestHold_Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request hold for conveyor
   END_VAR

   VAR 
      R_TRIG_KneeButton {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of toogle button
      R_TRIG_LabellingMode {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of labelling mode
      R_TRIG_ContinueMode {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of continue mode
      R_TRIG_BufferMode {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of buffer mode
      R_TRIG_LineModeInfeed {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of Infeed mode
      R_TRIG_LineModeOutfeed {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of Outfeed mode
      R_TRIG_PEC_BoS {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Falling edge trigger of sensor
      R_TRIG_PEC_EoS {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sx_LabellingMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Labelling Mode
      sx_ContinueMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Continue Mode
      sx_BufferMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Buffer Mode
      sx_RequestHold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request hold for conveyor
      sx_GeneralError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // General error
      sx_ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Configuration error
      sx_CountDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start counting distance to stop position
      sx_ParcelAtPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The parcel has reached the position
      si_DistanceToStopPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Distance to stop position
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             Fortna Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |
	|                                                                                      |     
	----------------------------------------------------------------------------------------
	                        
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	27/07/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	27/09/2023  | 1.1       | M. Diebel    | Logic changed for two two-position buttons | DHL Munich 2023
	07/02/2024  | 1.2       | L.Klar       | Counting distance fromt he end of the parcel
	12/03/2024  | 1.3       | S. Nieswiec      | Added to new Baseline
	*)
	
	REGION 1 - Triggers
	    
	    //Knee button 
	    #R_TRIG_KneeButton(CLK := (#ix_KneeButton));
	    
	    //Detect end of the parcel
	    //BoS
	    #R_TRIG_PEC_BoS(CLK := #ix_PEC_BoS);
	    //EoS
	    #R_TRIG_PEC_EoS(CLK := #ix_PEC_EoS);
	    
	END_REGION
	
	REGION 2 - Error detection
	    
	    // Only one mode can be active
	    IF (#ix_LabellingMode AND #ix_ContinueMode)
	        OR (#ix_LabellingMode AND #ix_BufferMode)
	        OR (#ix_ContinueMode AND #ix_BufferMode)
	    THEN
	        
	        #sx_GeneralError := TRUE;
	        
	    ELSE
	        
	        #sx_GeneralError := False;
	        
	    END_IF;
	    
	    //Configuration Error
	    IF #i_UDT_Configuration.LabellingMode_ParcelStop <= 0 THEN
	        
	        #sx_ConfigurationError := TRUE;
	        
	    ELSE
	        
	        #sx_ConfigurationError := False;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Modes
	    
	    // Select mode - when the local switch is used or the main line mode is changed 
	    
	    #R_TRIG_LabellingMode(CLK := #ix_LabellingMode AND NOT #sx_BufferMode);
	    
	    #R_TRIG_ContinueMode(CLK := (NOT #ix_LabellingMode AND
	                         ((#i_UDT_Configuration.Infeed.LabellingMode AND #ix_LineModeInfeed)
	                         OR (#i_UDT_Configuration.Outfeed.LabellingMode AND #ix_LineModeOutfeed))
	                         OR
	                         NOT #ix_BufferMode AND
	                         ((#i_UDT_Configuration.Infeed.BufferMode AND #ix_LineModeInfeed)
	                         OR (#i_UDT_Configuration.Outfeed.BufferMode AND #ix_LineModeOutfeed))
	                         )
	                         AND
	                         ((#i_UDT_Configuration.Infeed.ContinueMode AND #ix_LineModeInfeed)
	                         OR (#i_UDT_Configuration.Outfeed.ContinueMode AND #ix_LineModeOutfeed)));
	    
	    #R_TRIG_BufferMode(CLK := #ix_BufferMode AND NOT #sx_LabellingMode);
	    
	    #R_TRIG_LineModeInfeed(CLK := #ix_LineModeInfeed);
	    
	    #R_TRIG_LineModeOutfeed(CLK := #ix_LineModeOutfeed);
	    
	    IF #R_TRIG_LabellingMode.Q
	        OR #R_TRIG_ContinueMode.Q
	        OR #R_TRIG_BufferMode.Q
	        OR #R_TRIG_LineModeInfeed.Q
	        OR #R_TRIG_LineModeOutfeed.Q
	    THEN
	        
	        //Clean value from variable when new mode is selected. 
	        #sx_LabellingMode := FALSE;
	        #sx_ContinueMode := FALSE;
	        #sx_BufferMode := FALSE;
	        
	        #sx_CountDistance := FALSE;
	        #si_DistanceToStopPosition := 0;
	        #sx_ParcelAtPosition := FALSE;
	        #sx_RequestHold := FALSE;
	        
	        //
	        IF #ix_LabellingMode AND
	            ((#i_UDT_Configuration.Infeed.LabellingMode AND #ix_LineModeInfeed)
	            OR (#i_UDT_Configuration.Outfeed.LabellingMode AND #ix_LineModeOutfeed))
	        THEN
	            
	            #sx_LabellingMode := True;
	            
	        ELSIF
	            (NOT #ix_LabellingMode AND
	            ((#i_UDT_Configuration.Infeed.LabellingMode AND #ix_LineModeInfeed)
	            OR (#i_UDT_Configuration.Outfeed.LabellingMode AND #ix_LineModeOutfeed))
	            OR
	            NOT #ix_BufferMode AND
	            ((#i_UDT_Configuration.Infeed.BufferMode AND #ix_LineModeInfeed)
	            OR (#i_UDT_Configuration.Outfeed.BufferMode AND #ix_LineModeOutfeed))
	            )
	            AND
	            ((#i_UDT_Configuration.Infeed.ContinueMode AND #ix_LineModeInfeed)
	            OR (#i_UDT_Configuration.Outfeed.ContinueMode AND #ix_LineModeOutfeed))
	        THEN
	            
	            #sx_ContinueMode := True;
	            
	        ELSIF
	            #ix_BufferMode AND
	            ((#i_UDT_Configuration.Infeed.BufferMode AND #ix_LineModeInfeed)
	            OR (#i_UDT_Configuration.Outfeed.BufferMode AND #ix_LineModeOutfeed))
	        THEN
	            
	            #sx_BufferMode := True;
	            
	        END_IF;
	        
	    END_IF;
	    
	    REGION 3.1 - Labelling mode 
	        
	        IF #sx_LabellingMode THEN
	            
	            IF (#R_TRIG_PEC_BoS.Q AND #ix_LineModeInfeed) OR (#R_TRIG_PEC_EoS.Q AND #ix_LineModeOutfeed) THEN
	                
	                #sx_CountDistance := TRUE;
	                
	            END_IF;
	            
	            //Count the distance to stop parcel position
	            IF #sx_CountDistance THEN
	                
	                #si_DistanceToStopPosition += ABS(#ii_Displacement);
	                
	                IF #si_DistanceToStopPosition > #i_UDT_Configuration.LabellingMode_ParcelStop THEN
	                    
	                    #sx_CountDistance := FALSE;
	                    #si_DistanceToStopPosition := 0;
	                    #sx_ParcelAtPosition := True;
	                    
	                END_IF;
	                
	            END_IF;
	            
	            //When parcel is at position then stop conveyor 
	            #sx_RequestHold := #sx_ParcelAtPosition;
	            
	            //Operator confirm the parcel using knee button
	            IF #R_TRIG_KneeButton.Q THEN
	                
	                #sx_ParcelAtPosition := False;
	                
	            END_IF;
	            
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 3.2 - Continue mode
	        
	        IF #sx_ContinueMode THEN
	            
	            IF #R_TRIG_KneeButton.Q THEN
	                
	                #sx_RequestHold := NOT #sx_RequestHold;
	                
	            END_IF;
	            
	        END_IF;
	        
	    END_REGION
	END_REGION
	
	REGION 4 - Status
	    
	    //Selected mode
	    #q_UDT_HMIStatus.Specific.Infeed_LabellingMode := #sx_LabellingMode AND #ix_LineModeInfeed;
	    #q_UDT_HMIStatus.Specific.Infeed_ContinueMode := #sx_ContinueMode AND #ix_LineModeInfeed;
	    #q_UDT_HMIStatus.Specific.Infeed_BufferMode := #sx_BufferMode AND #ix_LineModeInfeed;
	    #q_UDT_HMIStatus.Specific.Outfeed_LabellingMode := #sx_LabellingMode AND #ix_LineModeOutfeed;
	    #q_UDT_HMIStatus.Specific.Outfeed_ContinueMode := #sx_ContinueMode AND #ix_LineModeOutfeed;
	    #q_UDT_HMIStatus.Specific.Outfeed_BufferMode := #sx_BufferMode AND #ix_LineModeOutfeed;
	    
	    IF (#sx_LabellingMode AND #ix_LineModeInfeed) OR (#sx_LabellingMode AND #ix_LineModeOutfeed)
	    THEN
	        
	        #q_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".LabbelingMode;
	        
	    END_IF;
	    
	    IF (#sx_ContinueMode AND #ix_LineModeInfeed) OR (#sx_ContinueMode AND #ix_LineModeOutfeed)
	    THEN
	        
	        #q_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".ContinuousMode;
	        
	    END_IF;
	    
	    IF (#sx_BufferMode AND #ix_LineModeInfeed) OR (#sx_BufferMode AND #ix_LineModeOutfeed)
	    THEN
	        
	        #q_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".BufferMode;
	        
	    END_IF;
	    
	    IF (NOT #sx_BufferMode AND NOT #sx_ContinueMode AND NOT #sx_LabellingMode AND NOT #ix_LineModeInfeed AND NOT #ix_LineModeOutfeed)
	    THEN
	        
	        #q_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Stopped;
	        
	    END_IF;
	    //Errors
	    #q_UDT_HMIStatus.Specific.GeneralError := #sx_GeneralError;
	    #q_UDT_HMIStatus.Specific.ConfigurationError := #sx_ConfigurationError;
	    
	END_REGION
	
	REGION 5 - Write Output
	    
	    #qx_RequestHold_Conveyor := #sx_RequestHold;
	    
	END_REGION
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_ColumnLift"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 92
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_ColumnLiftConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ColumnLift_Configuration";   // Column lift configuration structure
      ix_SafetyOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when Safety Circuit of the Conveyor is healthy
      ix_ChuteUpSensor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when upper position sensor is covered
      ix_ChuteDownSensor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when lower position sensor is covered
      ix_LiftUpSensor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when lift up sensor is not covered
      ix_LiftDownSensor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when lift down sensor is not covered
      ix_ChuteNotInPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when chut sensor is covered
      ix_PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;   // TRUE when the end of section photoeye in forward direction is not blocked
      ix_SS_Man { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when on Local Controll Panel switch [1] Manual; [0] Automatic
      ix_PB_Down { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when on Local Control Panel button Down is on
      ix_PB_Up { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when on Local Control Panel button Up is on
      ix_PB_Rst { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when on Local Control Panel button reset is on
      ii_Mode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Mode - [1] Infeed [2] Outfeed
      ix_ChangeModeSignal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when change mode command active
      ix_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when hardware is Ok
      ix_RIONotOnline { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ix_CaljanLowerOngoing { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when the "lower belt" hydraulic valve is active
      ix_CaljanRaisingOngoing { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when the "raise belt" hydraulic valve is active
   END_VAR

   VAR_OUTPUT 
      q_UDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ColumnLift_Status";   // HMI status structure
      q_UDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   // Common status structure
      qx_ExternalHold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External hold for base conveyor
   END_VAR

   VAR_IN_OUT 
      iq_UDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
      iq_UDT_LiftInterface : "UDT_ConveyorInterface";   // Column lift interface
      iq_UDT_Statistics : "UDT_ColumnLift_Statistics";   // Statistics structure
      iq_UDT_HMICommand : "UDT_ColumnLiftCommand";   // Colum lift command from HMI
   END_VAR

   VAR 
      s_UDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ColumnLift_Status";   // HMI status structure
      s_UDT_StatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Common status structure
      s_UDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Common status structure
      Jog_Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Filtering lower jam photo eye signal
      SwitchingTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Switching time
      s_FB_Timer_ChuteNoInPosFilter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Chute not in position filter
      s_FB_Timer_LiftUpFilter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      R_TRIG_ManualMode {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger manual mode
      R_TRIG_ManualJogUp {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger manual jog mode command
      R_TRIG_ManualJogDown {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger manual jog mode command
      R_TRIG_DownTime {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger Column lift is stopped
      R_TRIG_Error {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger for Error
      R_TRIG_UpTime {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger Column lift is running automatic
      R_TRIG_RestartFromError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger Restart from error
      R_TRIG_PreStartSemiAutomaticUp {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger for Pre start semi automatic up signal
      R_TRIG_PreStartSemiAutomaticDown {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger for Pre start semi automatic down signal
      R_TRIG_PECUp {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger for PEC up position
      R_TRIG_PECDown {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger for PEC down position
      F_TRIG_ChuteNotInPosition {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger for chute position sensor
      F_TRIG_PECUp {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger for PEC up position
      F_TRIG_PECDown {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger for PEC down position
      ss_ColumLiftInterface { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Column lift interface static structure
         Positioning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         SemiAutomatic { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Manual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         RunEnabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      END_STRUCT;
      sx_StartReceived { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start command received from system
      sx_Ready { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor Ready to operate in Automatic mode
      sx_SemiAutomatic { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Running in semi automatic
      sx_PreStartManual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Pre conditions to run conveyor in manual mode
      sx_PreStartSemiAutomaticUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Pre conditions to run conveyor in semi automatic up mode
      sx_PreStartSemiAutomaticDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Pre conditions to run conveyor in semi automatic down  mode
      sx_Stopping { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stopping is active, first reach position
      sx_SwitchEnable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Switching conditions
      sx_UpRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request upper outfeed position for actual parcel
      sx_DownRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request lower outfeed position for actual parcel
      sx_CombinedJogUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Combined signal of jogging buttons
      sx_CombinedJogDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Combined signal of jogging buttons
      sx_RestartFromError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // After an error has occurred the action to be done before resuming normal operation
      sx_Jog { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Off delayed signal Jogging was activated
      sx_ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Commissioning: configuration of parameters is wrong
      sx_JogUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Column lift in manual mode - jog up
      sx_JogDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Column lift in manual mode - jog down
      sx_UpperPositionReached { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Column lift is in upper position
      sx_LowerPositionReached { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Column lift is in lower position
      sx_MaintenanceControl { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // When maintenance control is active then in manual mode operaton can move column lift to limit swicht
      sx_LiftUpFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;
   END_VAR

   VAR_TEMP 
      ti_ActiveSensor : Int;   // Active sensor counter
   END_VAR

   VAR CONSTANT 
      ci_InfeedMode : Int := 1;   // Infeed mode number
      ci_OutfeedMode : Int := 2;   // Outfeed mode number
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	11/07/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	12/09/2023  | 2.0       | M.Diebel     | Addition of AutoOn and Error status upload, Remove hardwareOK from the condition to set warning status
	12/09/2023  | 2.1       | M.Diebel     | New status PositionChangeOngoing instead of running
	05/12/2023  | 2.2       | S. Nikodem   | Functionality update on site
	16/12/2023  | 2.3       | R. Golonka   | HMI command added, HMI status upgrade
	11/01/2024  | 2.4       | L.Klar       | Chute not in position error logic changed
	15/01/2024  | 2.5       | M.Diebel     | Stop on Lift down sensor not on chute down sensor
	17/01/2024  | 2.6       | M.Diebel     | Added filtr for limit UP sensor
	01/02/2024  | 2.7       | M.Diebel     | Added signal from RIO to mask error
	16/02/2024  | 2.8       | M.Diebel     | Add reset for MaintenaceModeActive status
	01/03/2024  | 2.9       | P.Gryszczyk  | Lower position HMI status changed
	13/03/2024  | 2.91      | S. Nieswiec  | Added to new baseline
	*)
	
	REGION 1 - Initial
	    
	    REGION 1.1 - Triggers
	        
	        // Detecting rising edge on manual mode Or from Equipment Control
	        #R_TRIG_ManualMode(CLK := #s_UDT_Status.Manual);
	        
	        // Rising edge trigger running        
	        #R_TRIG_UpTime(CLK := #sx_SemiAutomatic AND #sx_Ready);
	        
	        // Detecting rising edge VSU stopped        
	        #R_TRIG_DownTime(CLK := #sx_SemiAutomatic AND NOT #sx_Ready);
	        
	        // Detecting rising edge on VSU error
	        #R_TRIG_Error(CLK := #s_UDT_Status.Error);
	        
	        // Detecting rising edge on start of the restart from error sequence
	        #R_TRIG_RestartFromError(CLK := #sx_RestartFromError);
	        
	        // Detecting falling edge on chute position sensor
	        #F_TRIG_ChuteNotInPosition(CLK := #ix_ChuteNotInPosition);
	        
	        //Maintenance Control 
	        #sx_MaintenanceControl := #iq_UDT_HMICommand.MaintenanceControl;
	        
	    END_REGION
	    
	    REGION 1.2 - Filters
	        
	        // Time to start without start warning while jogging
	        #Jog_Enable(iudi_OffDelayTime := #i_UDT_ColumnLiftConfiguration.JogNoHornTime,
	                    ix_SignalToDelay := #sx_Jog);
	        
	        #s_FB_Timer_ChuteNoInPosFilter(iudi_OnDelayTime := 200,
	                                       ix_SignalToDelay := NOT #ix_ChuteDownSensor AND NOT #ix_ChuteNotInPosition);
	        
	        #s_FB_Timer_LiftUpFilter(iudi_OnDelayTime := 100,
	                                 iudi_OffDelayTime := 100,
	                                 ix_SignalToDelay := NOT #ix_LiftUpSensor,
	                                 qx_DelayedSignal => #sx_LiftUpFiltered);
	        
	    END_REGION
	    
	    REGION 1.3 - Switching conditions
	        
	        #sx_SwitchEnable := NOT #iq_UDT_EquipmentControl.Command.StopRequest
	        AND NOT #iq_UDT_LiftInterface.VFDRunning
	        AND NOT #s_UDT_HMIStatus.Specific.ReferenceError
	        AND NOT #s_UDT_HMIStatus.Specific.LimitSensorLowerPosition
	        AND NOT #s_UDT_HMIStatus.Specific.LimitSensorUpperPosition
	        AND NOT #s_UDT_HMIStatus.Specific.ChuteNotInPosition;
	        
	    END_REGION
	    
	    REGION 1.4 - Positioning
	        
	        #ss_ColumLiftInterface.Positioning := #iq_UDT_LiftInterface.ActualSpeed <> 0
	        AND #sx_SemiAutomatic
	        AND NOT #iq_UDT_LiftInterface.InternalErrorVFD;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 2 - Errors
	    
	    REGION 2.1 - Reset errors
	        
	        //Global reset
	        IF #iq_UDT_EquipmentControl.Command.Reset
	        THEN
	            
	            #s_UDT_HMIStatus.Specific.MaintenaceModeActive := FALSE;
	            #s_UDT_HMIStatus.Specific.SwitchingTimerError := False;
	            
	        END_IF;
	        
	        //Local reset
	        IF #ix_PB_Rst THEN
	            
	            #s_UDT_HMIStatus.Specific.MaintenaceModeActive := FALSE;
	            #s_UDT_HMIStatus.Specific.SwitchingTimerError := False;
	            #s_UDT_HMIStatus.Specific.LimitSensorLowerPosition := False;
	            #s_UDT_HMIStatus.Specific.LimitSensorUpperPosition := False;
	            #s_UDT_HMIStatus.Specific.ChuteNotInPosition := False;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 2.2 - Set errors
	        
	        //Configuration error
	        #sx_ConfigurationError := #i_UDT_ColumnLiftConfiguration.NominalSpeedSetPoint = 0
	        OR #i_UDT_ColumnLiftConfiguration.ManualModeSpeed = 0;
	        
	        //Switching Time
	        #SwitchingTime(iudi_OnDelayTime := #i_UDT_ColumnLiftConfiguration.SwitchingTime,
	                       iudi_OffDelayTime := 0,
	                       ix_SignalToDelay := #sx_SemiAutomatic AND (NOT #iq_UDT_EquipmentControl.Request.SignalingRequest) AND ((#sx_UpRequest AND (NOT #ix_ChuteUpSensor)) OR (#sx_DownRequest AND (NOT #ix_ChuteDownSensor))));
	        
	        IF #SwitchingTime.qx_DelayedSignal THEN
	            #s_UDT_HMIStatus.Specific.SwitchingTimerError := True;
	        END_IF;
	        
	        // Reference error - set error when more like one position sensor is active
	        #ti_ActiveSensor := 0;
	        
	        IF #ix_ChuteUpSensor THEN
	            #ti_ActiveSensor += 1;
	        END_IF;
	        
	        // IF #ix_ChuteDownSensor THEN
	        //     #ti_ActiveSensor += 1;
	        // END_IF;
	        
	        IF NOT #ix_LiftUpSensor THEN
	            #ti_ActiveSensor += 1;
	        END_IF;
	        
	        IF NOT #ix_LiftDownSensor THEN
	            #ti_ActiveSensor += 1;
	        END_IF;
	        
	        IF #ti_ActiveSensor >= 2 AND NOT #ix_RIONotOnline THEN
	            #s_UDT_HMIStatus.Specific.ReferenceError := True;
	        ELSE
	            #s_UDT_HMIStatus.Specific.ReferenceError := False;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 2.3 - Common Error
	        
	        #s_UDT_Status.Error := NOT #ix_HardwareOk
	        OR #iq_UDT_LiftInterface.InternalErrorVFD
	        OR #sx_ConfigurationError
	        OR #s_UDT_HMIStatus.Specific.LimitSensorLowerPosition
	        OR #s_UDT_HMIStatus.Specific.LimitSensorUpperPosition;
	        
	    END_REGION
	    
	    REGION 2.4 - Chute not in position error
	        
	        //Chute not in position
	        IF #s_FB_Timer_ChuteNoInPosFilter.qx_DelayedSignal AND NOT #ix_RIONotOnline THEN
	            //Activate alarm if chuta position is lost
	            #s_UDT_HMIStatus.Specific.ChuteNotInPosition := True;
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 3 - Check conditions to set Equipment ready
	    
	    //Conditions to set bit sx_Ready to operate 
	    #sx_Ready := NOT #s_UDT_Status.Error                                              // Error not present
	    AND #ix_SafetyOk;                                                                 // Safety signalling OK
	    
	END_REGION
	
	REGION 4 - Stop Equipment
	    
	    IF (#ix_SS_Man                                                                  // Manual mode is active
	        AND #sx_SemiAutomatic                                                       // Column lift is in semi-automatic mode
	        OR (NOT #iq_UDT_EquipmentControl.Command.AutomaticOn                        // Column lift stops if the bit AutomaticOn from control block is false
	        AND NOT #ix_SS_Man)                                                         // Manual mode active bit
	        OR (NOT #sx_Ready                                                           // Bit column lift ready to run in automatic mode
	        AND NOT #ix_SS_Man)                                                         // Manual mode active
	        OR #ix_SS_Man                                                               // LCP is not set to automatic
	        OR NOT #ix_SafetyOk)                                                        // Safety is not ok
	    THEN
	        #sx_Stopping := TRUE;                                                       // stopping is activated
	        #sx_SemiAutomatic := FALSE;                                                 // switch of automatic activ
	        #sx_StartReceived := FALSE;                                                 // Start command received from system 
	    END_IF;
	    
	    IF (#sx_Stopping                                                                 // stopping is activated
	        AND NOT #ss_ColumLiftInterface.Positioning)                                  // The positioning device is not active positioning 
	        OR NOT #sx_Ready                                                             // VSU is not ready to run
	    THEN
	        #sx_Stopping := FALSE;                                                       // stopping is activated
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Start Semi-automatic mode 
	    
	    REGION 5.1 - Start 
	        
	        // if start (OS) is received from system, this is memorised until started in cascade 
	        IF #iq_UDT_EquipmentControl.Command.Start                                       // Start from system
	            AND #sx_Ready                                                               // Equipment has no errors
	        THEN
	            #sx_StartReceived := TRUE;                                                  // Start command received from system 
	        END_IF;
	        
	        IF #sx_StartReceived                                                            // Start command received from system
	            AND NOT #ix_SS_Man                                                         // and the LCP is set to auto
	        THEN
	            #sx_SemiAutomatic := TRUE;                                                  // Automatic activated
	            #sx_StartReceived := FALSE;                                                 // Start command received from system
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 6 - Manual mode 
	    
	    REGION 6.1 - Jog signals
	        
	        #sx_CombinedJogUp := (#ix_SS_Man                                               // box in manual
	        AND #ix_PB_Up);                                                                // If selected jog in positive direction 
	        
	        #sx_CombinedJogDown := (#ix_SS_Man                                             // box in manual
	        AND #ix_PB_Down);                                                              // If selected jog in negative direction 
	        
	        // Detecting rising edge on manual jog Up           
	        #R_TRIG_ManualJogUp(CLK := #sx_CombinedJogUp);
	        
	        // Detecting rising edge on manual jog Down          
	        #R_TRIG_ManualJogDown(CLK := #sx_CombinedJogDown);
	        
	    END_REGION
	    
	    REGION 6.2 - Manual mode: disabled
	        
	        // Manual mode bits inputs can be reset in case of malfunction
	        IF NOT #ix_SS_Man
	        THEN
	            #iq_UDT_EquipmentControl.Command.ManualMode := FALSE;                       // reset manual mode command 
	            #sx_Jog := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 6.3 - Manual PreStart up or down
	        
	        // Pre start conditions to run in manual mode
	        #sx_PreStartManual := #ix_SS_Man                                            // Manual mode active bit
	        AND #ix_SafetyOk                                                            // Safety healthy bit
	        AND NOT #iq_UDT_LiftInterface.InternalErrorVFD;                             // Profinet comunication or PN_DEvice not ok 
	        
	        IF #sx_PreStartManual                                                           // Pre start conditions to run in manual mode
	            AND (#R_TRIG_ManualJogUp.Q                                                  // Trigger to start VSU run in manual jog mode UP
	            OR #R_TRIG_ManualJogDown.Q)                                                 // Trigger to start VSU run in manual jog mode Down
	            AND NOT #Jog_Enable.qx_DelayedSignal
	        THEN
	            #iq_UDT_EquipmentControl.Request.SignalingRequest := TRUE;                  // Request signaling TO control block before lift runs in manual mode
	        END_IF;
	        
	    END_REGION
	    
	    REGION 6.4 - Jog mode Up / Down
	        
	        IF #sx_PreStartManual                                                           // IF in manual jog mode 
	            AND (NOT #iq_UDT_EquipmentControl.Request.SignalingRequest                  // Signaling request done
	            OR #Jog_Enable.qx_DelayedSignal)
	            AND #sx_CombinedJogUp                                                       // If selected jog in positive direction 
	            AND NOT #sx_CombinedJogDown                                                 // And not selected jog in negative direction
	        THEN
	            
	            #sx_JogUp := TRUE;                                                          // set jog positive 
	            #sx_JogDown := FALSE;                                                       // reset jog negative 
	            #sx_Jog := true;
	            
	        ELSIF
	            #sx_PreStartManual                                                          // IF in manual jog mode 
	            AND (NOT #iq_UDT_EquipmentControl.Request.SignalingRequest                  // Signaling request done
	            OR #Jog_Enable.qx_DelayedSignal)
	            AND NOT #sx_CombinedJogUp                                                   // If selected jog in positive direction 
	            AND #sx_CombinedJogDown                                                     // and there is command to jog in negative direction 
	        THEN
	            
	            #sx_JogUp := FALSE;                                                         // reset jog positive 
	            #sx_JogDown := TRUE;                                                        // set jog negative 
	            #sx_Jog := true;
	            
	        ELSIF
	            NOT #sx_PreStartManual                                                      // If not in manual mode 
	            OR (#sx_PreStartManual                                                      // or in manual mode
	            AND (#sx_CombinedJogUp                                                      // and jog positive is off 
	            AND #sx_CombinedJogDown)                                                    // AND jog negative is off 
	            OR (NOT #sx_CombinedJogUp                                                   // or jog positive is on 
	            AND NOT #sx_CombinedJogDown))                                               // and jog negative is on 
	        THEN
	            
	            #sx_JogUp := FALSE;                                                         // reset jog positive 
	            #sx_JogDown := FALSE;                                                       // reset jog negative 
	            #sx_Jog := False;
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 7 - Semi automatic
	    
	    REGION 7.1 - Semi automatic
	        
	        IF #sx_SemiAutomatic                                                            // Not running Semi-Automatic
	            AND (#ix_ChangeModeSignal
	            AND #ii_Mode = #ci_InfeedMode)
	            AND #sx_SwitchEnable
	            AND NOT #ix_ChuteUpSensor
	        THEN
	            
	            #sx_PreStartSemiAutomaticUp := TRUE;
	            
	            #sx_DownRequest := FALSE;                                                   // Reset down command
	            #sx_UpRequest := TRUE;                                                      // Set up command
	            
	        END_IF;
	        
	        IF #sx_SemiAutomatic                                                            // Not running Semi-Automatic
	            AND (#ix_ChangeModeSignal
	            AND #ii_Mode = #ci_OutfeedMode)
	            AND #sx_SwitchEnable
	            AND NOT #ix_ChuteDownSensor
	        THEN
	            
	            #sx_PreStartSemiAutomaticDown := TRUE;
	            
	            #sx_DownRequest := TRUE;                                                    // Reset down command
	            #sx_UpRequest := FALSE;                                                     // Set up command
	            
	        END_IF;
	        
	        #R_TRIG_PreStartSemiAutomaticUp(CLK := #sx_PreStartSemiAutomaticUp);
	        #R_TRIG_PreStartSemiAutomaticDown(CLK := #sx_PreStartSemiAutomaticDown);
	        
	        //Set Signaling Request 
	        IF #R_TRIG_PreStartSemiAutomaticUp.Q OR #R_TRIG_PreStartSemiAutomaticDown.Q THEN
	            #iq_UDT_EquipmentControl.Request.SignalingRequest := TRUE;
	        END_IF;
	        
	        IF #sx_SemiAutomatic
	            AND (#ix_ChuteUpSensor
	            AND #sx_UpRequest)
	            OR #s_UDT_HMIStatus.Specific.SwitchingTimerError
	        THEN
	            #sx_UpRequest := false;
	            #sx_PreStartSemiAutomaticUp := false;
	        END_IF;
	        
	        IF #sx_SemiAutomatic
	            AND (NOT #ix_LiftDownSensor
	            AND #sx_DownRequest)
	            OR #s_UDT_HMIStatus.Specific.SwitchingTimerError
	        THEN
	            #sx_DownRequest := false;
	            #sx_PreStartSemiAutomaticDown := false;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 7.2 - Stop conveyor 
	        
	        #qx_ExternalHold := #ss_ColumLiftInterface.Positioning;                                            // External stop signal
	        
	    END_REGION
	    
	END_REGION
	
	REGION 8 - Write interface DB signals
	    
	    REGION 8.1 - Signal interface
	        
	        #iq_UDT_LiftInterface.InternalErrorReset := #iq_UDT_EquipmentControl.Command.Reset;      // Write Reset signal to the VFD interface
	        #iq_UDT_LiftInterface.ResetStatistics := #iq_UDT_EquipmentControl.Command.ResetData;     // Write Reset data signal to the VFD interface
	        
	    END_REGION
	    
	    REGION 8.1 - Mode selection 
	        
	        #ss_ColumLiftInterface.SemiAutomatic :=
	        (#sx_SemiAutomatic                                                               // Automatic started
	        OR #sx_Stopping);                                                                // stopping is activated Go to default position
	        
	        #ss_ColumLiftInterface.Manual :=                                                         // Manual mode is started
	        #sx_CombinedJogUp                                                           // IF selected jog in positive direction 
	        OR #sx_CombinedJogDown;
	        
	    END_REGION
	    
	    REGION 8.2 - Run enable
	        
	        #ss_ColumLiftInterface.RunEnabled :=                                                  // Enable the positioning device to run
	        NOT #iq_UDT_LiftInterface.InternalErrorVFD                               // or there are errors in the VFD
	        AND NOT #sx_ConfigurationError                                                   // configuration is wrong
	        AND #ix_HardwareOk                                                        // or an internal error in the RIO panel occured                             
	        AND (#ss_ColumLiftInterface.SemiAutomatic                                             // VSU is in semi-automatic mode
	        OR (#ss_ColumLiftInterface.Manual                                                     // manual mode is active
	        AND (#sx_CombinedJogUp                                                           // If selected jog in positive direction 
	        OR #sx_CombinedJogDown)))                                                        // If selected jog in negative direction
	        AND NOT #ix_RIONotOnline;                                                       // If we don't have signal from sensors
	        
	    END_REGION
	    
	END_REGION
	
	REGION 9 - Positions reached
	    
	    // triggers of PEC's down/up
	    #F_TRIG_PECUp(CLK := #ix_ChuteUpSensor);
	    #R_TRIG_PECUp(CLK := #ix_ChuteUpSensor);
	    
	    #F_TRIG_PECDown(CLK := #ix_LiftDownSensor);
	    #R_TRIG_PECDown(CLK := #ix_LiftDownSensor);
	    
	    IF #R_TRIG_PECUp.Q THEN
	        #sx_UpperPositionReached := true;
	    ELSIF (#sx_DownRequest OR #sx_JogDown) AND #F_TRIG_PECUp.Q THEN
	        #sx_UpperPositionReached := false;
	    END_IF;
	    
	    IF #R_TRIG_PECDown.Q THEN
	        #sx_LowerPositionReached := true;
	    ELSIF (#sx_UpRequest OR #sx_JogUp) AND #F_TRIG_PECDown.Q THEN
	        #sx_LowerPositionReached := false;
	    END_IF;
	    
	END_REGION
	
	REGION 10 - Run up/down
	    
	    // Conditions to run column lift upwards
	    #iq_UDT_LiftInterface.RunRvs := ((#sx_UpRequest AND #sx_SemiAutomatic AND NOT #iq_UDT_EquipmentControl.Request.SignalingRequest)
	    OR #sx_JogUp)
	    AND (NOT #sx_UpperPositionReached OR (#sx_MaintenanceControl AND #sx_JogUp))
	    AND #ss_ColumLiftInterface.RunEnabled
	    AND #ix_LiftUpSensor;
	    
	    // Conditions to run column lift down
	    #iq_UDT_LiftInterface.RunFwd := ((#sx_DownRequest AND #sx_SemiAutomatic AND NOT #iq_UDT_EquipmentControl.Request.SignalingRequest)
	    OR #sx_JogDown)
	    AND #ss_ColumLiftInterface.RunEnabled
	    AND #ix_LiftDownSensor;
	    
	END_REGION
	
	REGION 11 - Column lift speed
	    
	    IF #ss_ColumLiftInterface.Manual THEN
	        #iq_UDT_LiftInterface.SpeedSetpoint := #i_UDT_ColumnLiftConfiguration.ManualModeSpeed;
	    ELSE
	        #iq_UDT_LiftInterface.SpeedSetpoint := #i_UDT_ColumnLiftConfiguration.NominalSpeedSetPoint;
	    END_IF;
	    
	END_REGION
	
	REGION 12 - Statistics
	    
	    // Down Time
	    IF #sx_SemiAutomatic                                                                 // Automatic active
	        AND NOT #sx_Ready                                                                // Conveyor not ready
	        OR #iq_UDT_EquipmentControl.Command.ResetData                                    // Reset statistics
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iq_UDT_EquipmentControl.Command.ResetData,              // Or reset statistics from control
	                        ix_Activate := #sx_SemiAutomatic AND NOT #sx_Ready,                  // VSU is stopped 
	                        ix_RTrigActivate := #R_TRIG_DownTime.Q,                              // VSU is stopped triger 
	                        iqUDT_Statistics := #iq_UDT_Statistics.DownTime);                   // VSU is stopped statistics 
	    END_IF;
	    
	    // Up time
	    IF #sx_SemiAutomatic                                // Automatic active
	        AND #sx_Ready                                   // Ready active
	        OR #iq_UDT_EquipmentControl.Command.ResetData   // Reset statistics
	    THEN
	        "FC_Statistics"(ix_Reset := #iq_UDT_EquipmentControl.Command.ResetData,        // OR reset statistics from control
	                        ix_Activate := #sx_SemiAutomatic AND #sx_Ready,                // VSU is running 
	                        ix_RTrigActivate := #R_TRIG_UpTime.Q,                          // VSU running trigger 
	                        iqUDT_Statistics := #iq_UDT_Statistics.UpTime);               // VSU running statistics
	        
	    END_IF;
	    
	END_REGION
	
	REGION 13 - Status 
	    
	    #s_UDT_Status.Stopped := #sx_Ready AND NOT #sx_SemiAutomatic AND NOT #sx_Stopping;      // stopped
	    #s_UDT_Status.AutoON := #sx_SemiAutomatic OR #sx_Stopping;                              // Auto On
	    #s_UDT_Status.Halted := FALSE;                                                          // Halted
	    #s_UDT_Status.Dieback := FALSE;                                                         // Die back
	    #s_UDT_Status.Running := (#sx_UpRequest OR #sx_DownRequest) AND #sx_SemiAutomatic;      // Running
	    #s_UDT_Status.ManualRun := #ix_SS_Man AND #iq_UDT_LiftInterface.VFDRunning;            // Manual run
	    #s_UDT_Status.Manual := #ix_SS_Man;                                                     // Manual
	    #s_UDT_Status.EnergySave := FALSE;                                                      // Energy save active
	    #s_UDT_Status.SafetyStop := NOT #ix_SafetyOk;                                           // Safety not ok
	    
	    //   Specific status
	    IF #s_UDT_StatusOld <> #s_UDT_Status                                            // update on change
	    THEN
	        
	        // Set status to status number
	        #s_UDT_HMIStatus.Status := 0;                                               // Initialise status number              
	        
	        IF #s_UDT_Status.Running                                                    // Running in semi automatic
	        THEN
	            
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".PositionChangeOngoing;
	            
	        END_IF;
	        
	        IF #s_UDT_Status.Stopped                                                    // Stopped
	        THEN
	            
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Stopped;
	            
	        END_IF;
	        
	        IF #s_UDT_Status.AutoON                                                   // Dieback
	        THEN
	            
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".AutoON;
	            
	        END_IF;
	        
	        IF #s_UDT_Status.ManualRun                                                  // Manual run
	        THEN
	            
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".ManualRun;
	            
	        END_IF;
	        
	        IF #s_UDT_Status.Manual                                                     // Manual
	        THEN
	            
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Manual;
	            
	        END_IF;
	        
	        IF #iq_UDT_LiftInterface.InternalWarningVFD                                  // The VFD has an internal warning
	            
	        THEN
	            
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Warning;
	            
	        END_IF;
	        
	        IF #s_UDT_Status.Error                                 // The VFD has an internal warning
	        THEN
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Error;
	        END_IF;
	        
	        IF #s_UDT_Status.SafetyStop                                                 // Safety stop
	        THEN
	            
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".SafetyStop;
	            
	        END_IF;
	        
	        
	        #s_UDT_StatusOld := #s_UDT_Status;                                          // Copy status TO memory
	        #q_UDT_Status := #s_UDT_Status;                                             // Copy status to output
	        
	    END_IF;
	    
	    //Actual position
	    #s_UDT_HMIStatus.Specific.UpperPosition := #ix_ChuteUpSensor;
	    #s_UDT_HMIStatus.Specific.LowerPosition := NOT #ix_LiftDownSensor;                  //Lower position was changed to use limit switch down because of the project specyfic equipment 
	    
	    //Limit switch active
	    IF #sx_LiftUpFiltered AND NOT #ix_RIONotOnline THEN
	        
	        #s_UDT_HMIStatus.Specific.LimitSensorUpperPosition := True;
	        
	    END_IF;
	    
	(*    IF NOT #ix_LiftDownSensor THEN
	        
	        #s_UDT_HMIStatus.Specific.LimitSensorLowerPosition := True;
	        
	    END_IF; *)
	    
	    IF #sx_MaintenanceControl THEN
	        
	        #s_UDT_HMIStatus.Specific.MaintenaceModeActive := True;
	        
	    END_IF;
	    
	    #q_UDT_HMIStatus := #s_UDT_HMIStatus;                                       // Copy status to output
	    
	END_REGION
	
	REGION 14 - Report to control block
	    
	    #iq_UDT_EquipmentControl.Request.InhibitStop := #iq_UDT_EquipmentControl.Request.InhibitStop OR #ss_ColumLiftInterface.Positioning;
	    
	    "FC_EquipmentReport"(iUDT_Status := #s_UDT_Status,
	                         iqUDT_Control := #iq_UDT_EquipmentControl);
	    
	END_REGION
	
	REGION 15 - Internal errors and warnings reset
	    
	    #iq_UDT_LiftInterface.InternalErrorPEC := FALSE;
	    #iq_UDT_LiftInterface.InternalWarningTracking := FALSE;
	    #iq_UDT_LiftInterface.InternalErrorTracking := FALSE;
	    #iq_UDT_LiftInterface.InternalWarningVFD := FALSE;
	    #iq_UDT_LiftInterface.InternalErrorVFD := FALSE;
	    #iq_UDT_LiftInterface.Disconnected := FALSE;
	    
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_CodingBeltModes"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 90
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_Configuration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CodingBeltModesConfiguration";   // Function configuration
      ii_Displacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Conveyor displacement in one PLC cycle [cm]
      ix_KneeButton { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Knee button
      ix_LabellingMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Local switch Labeling mode
      ix_ContinueMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Local switch Continue mode
      ix_BufferMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Local switch Buffer mode
      ix_LineModeInfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Interface with main line - bool or new UDT??? Infeed and Outfeed?
      ix_LineModeOutfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Interface with main line - bool or new UDT??? Infeed and Outfeed?
      ix_PEC_BoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // BoS sensor
      ix_PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // EoS sensor
   END_VAR

   VAR_OUTPUT 
      q_UDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CodingBeltModesStatus";   // Status
      qx_RequestHold_Conveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request hold for conveyor
   END_VAR

   VAR 
      R_TRIG_KneeButton {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of toogle button
      R_TRIG_LabellingMode {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of labelling mode
      R_TRIG_ContinueMode {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of continue mode
      R_TRIG_BufferMode {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of buffer mode
      R_TRIG_LineModeInfeed {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of Infeed mode
      R_TRIG_LineModeOutfeed {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of Outfeed mode
      F_TRIG_PEC_BoS {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger of sensor
      F_TRIG_PEC_EoS {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;
      sx_LabellingMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Labelling Mode
      sx_ContinueMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Continue Mode
      sx_BufferMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Buffer Mode
      sx_RequestHold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request hold for conveyor
      sx_GeneralError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // General error
      sx_ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Configuration error
      sx_CountDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start counting distance to stop position
      sx_ParcelAtPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // The parcel has reached the position
      si_DistanceToStopPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Distance to stop position
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             Fortna Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |
	|                                                                                      |     
	----------------------------------------------------------------------------------------
	                        
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	27/07/2023  | 1.0       | S. Nikodem   | Release TIA 17  | DHL Munich 2023
	06/10/2023  | 1.1       | M.Diebel     | Status handling | DHL Munich 2023
	04.12/2023  | 1.2       | M.Diebel     | Stop status     | DHL Munich 2023 
	12/03/2024  | 1.3       | S. Nieswiec  | Added to new Baseline
	*)
	
	REGION 1 - Triggers
	    
	    //Knee button 
	    #R_TRIG_KneeButton(CLK := (#ix_KneeButton));
	    
	    //Detect end of the parcel
	    //BoS
	    #F_TRIG_PEC_BoS(CLK := #ix_PEC_BoS);
	    //EoS
	    #F_TRIG_PEC_EoS(CLK := #ix_PEC_EoS);
	    
	END_REGION
	
	REGION 2 - Error detection
	    
	    // Only one mode can be active
	    IF (#ix_LabellingMode AND #ix_ContinueMode)
	        OR (#ix_LabellingMode AND #ix_BufferMode)
	        OR (#ix_ContinueMode AND #ix_BufferMode)
	    THEN
	        
	        #sx_GeneralError := TRUE;
	        
	    ELSE
	        
	        #sx_GeneralError := False;
	        
	    END_IF;
	    
	    //Configuration Error
	    IF #i_UDT_Configuration.LabellingMode_ParcelStop <= 0 THEN
	        
	        #sx_ConfigurationError := TRUE;
	        
	    ELSE
	        
	        #sx_ConfigurationError := False;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Modes
	    
	    // Select mode - when the local switch is used or the main line mode is changed 
	    
	    #R_TRIG_LabellingMode(CLK := #ix_LabellingMode AND NOT #sx_BufferMode);
	    
	    #R_TRIG_ContinueMode(CLK := #ix_ContinueMode);
	    
	    #R_TRIG_BufferMode(CLK := #ix_BufferMode AND NOT #sx_LabellingMode);
	    
	    #R_TRIG_LineModeInfeed(CLK := #ix_LineModeInfeed);
	    
	    #R_TRIG_LineModeOutfeed(CLK := #ix_LineModeOutfeed);
	    
	    IF #R_TRIG_LabellingMode.Q
	        OR #R_TRIG_ContinueMode.Q
	        OR #R_TRIG_BufferMode.Q
	        OR #R_TRIG_LineModeInfeed.Q
	        OR #R_TRIG_LineModeOutfeed.Q
	    THEN
	        
	        //Clean value from variable when new mode is selected. 
	        #sx_LabellingMode := FALSE;
	        #sx_ContinueMode := FALSE;
	        #sx_BufferMode := FALSE;
	        
	        #sx_CountDistance := FALSE;
	        #si_DistanceToStopPosition := 0;
	        #sx_ParcelAtPosition := FALSE;
	        #sx_RequestHold := FALSE;
	        
	        //
	        IF #ix_LabellingMode AND
	            ((#i_UDT_Configuration.Infeed.LabellingMode AND #ix_LineModeInfeed)
	            OR (#i_UDT_Configuration.Outfeed.LabellingMode AND #ix_LineModeOutfeed))
	        THEN
	            
	            #sx_LabellingMode := True;
	            
	        ELSIF
	            #ix_ContinueMode AND
	            ((#i_UDT_Configuration.Infeed.ContinueMode AND #ix_LineModeInfeed)
	            OR (#i_UDT_Configuration.Outfeed.ContinueMode AND #ix_LineModeOutfeed))
	        THEN
	            
	            #sx_ContinueMode := True;
	            
	        ELSIF
	            #ix_BufferMode AND
	            ((#i_UDT_Configuration.Infeed.BufferMode AND #ix_LineModeInfeed)
	            OR (#i_UDT_Configuration.Outfeed.BufferMode AND #ix_LineModeOutfeed))
	        THEN
	            
	            #sx_BufferMode := True;
	            
	        END_IF;
	        
	    END_IF;
	    
	    REGION 3.1 - Labelling mode 
	        
	        IF #sx_LabellingMode THEN
	            
	            IF (#F_TRIG_PEC_BoS.Q AND #ix_LineModeInfeed) OR (#F_TRIG_PEC_EoS.Q AND #ix_LineModeOutfeed) THEN
	                
	                #sx_CountDistance := TRUE;
	                
	            END_IF;
	            
	            //Count the distance to stop parcel position
	            IF #sx_CountDistance THEN
	                
	                #si_DistanceToStopPosition += ABS(#ii_Displacement);
	                
	                IF #si_DistanceToStopPosition > #i_UDT_Configuration.LabellingMode_ParcelStop THEN
	                    
	                    #sx_CountDistance := FALSE;
	                    #si_DistanceToStopPosition := 0;
	                    #sx_ParcelAtPosition := True;
	                    
	                END_IF;
	                
	            END_IF;
	            
	            //When parcel is at position then stop conveyor 
	            #sx_RequestHold := #sx_ParcelAtPosition;
	            
	            //Operator confirm the parcel using knee button
	            IF #R_TRIG_KneeButton.Q THEN
	                
	                #sx_ParcelAtPosition := False;
	                
	            END_IF;
	            
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 3.2 - Continue mode
	        
	        IF #sx_ContinueMode THEN
	            
	            IF #R_TRIG_KneeButton.Q THEN
	                
	                #sx_RequestHold := NOT #sx_RequestHold;
	                
	            END_IF;
	            
	        END_IF;
	        
	    END_REGION
	END_REGION
	
	REGION 4 - Status
	    
	    //Selected mode
	    #q_UDT_HMIStatus.Specific.Infeed_LabellingMode := #sx_LabellingMode AND #ix_LineModeInfeed;
	    #q_UDT_HMIStatus.Specific.Infeed_ContinueMode := #sx_ContinueMode AND #ix_LineModeInfeed;
	    #q_UDT_HMIStatus.Specific.Infeed_BufferMode := #sx_BufferMode AND #ix_LineModeInfeed;
	    #q_UDT_HMIStatus.Specific.Outfeed_LabellingMode := #sx_LabellingMode AND #ix_LineModeOutfeed;
	    #q_UDT_HMIStatus.Specific.Outfeed_ContinueMode := #sx_ContinueMode AND #ix_LineModeOutfeed;
	    #q_UDT_HMIStatus.Specific.Outfeed_BufferMode := #sx_BufferMode AND #ix_LineModeOutfeed;
	    
	    IF (#sx_LabellingMode AND #ix_LineModeInfeed) OR (#sx_LabellingMode AND #ix_LineModeOutfeed)
	    THEN
	        
	        #q_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".LabbelingMode;
	        
	    END_IF;
	    
	    IF (#sx_ContinueMode AND #ix_LineModeInfeed) OR (#sx_ContinueMode AND #ix_LineModeOutfeed)
	    THEN
	        
	        #q_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".ContinuousMode;
	        
	    END_IF;
	    
	    IF (#sx_BufferMode AND #ix_LineModeInfeed) OR (#sx_BufferMode AND #ix_LineModeOutfeed)
	    THEN
	        
	        #q_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".BufferMode;
	        
	    END_IF;
	    
	    IF (NOT #sx_BufferMode AND NOT #sx_ContinueMode AND NOT #sx_LabellingMode AND NOT #ix_LineModeInfeed AND NOT #ix_LineModeOutfeed)
	    THEN
	        
	        #q_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Stopped;
	        
	    END_IF;
	    
	    //Errors
	    #q_UDT_HMIStatus.Specific.GeneralError := #sx_GeneralError;
	    #q_UDT_HMIStatus.Specific.ConfigurationError := #sx_ConfigurationError;
	    
	END_REGION
	
	REGION 5 - Write Output
	    
	    #qx_RequestHold_Conveyor := #sx_RequestHold;
	    
	END_REGION
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_Xray_SerialCommunication_Receive"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 247
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_SerialCommunicationConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_SerialComConfiguration";   // Serial communication configuration
      is_ActualTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Actual date and time in String
      ii_SourceNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // ID Source Node
      ii_DestinationNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // ID Destination Node
   END_VAR

   VAR_OUTPUT 
      q_UDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_SerialCommunicationReceiveStatus";   // Status structure
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqa_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Message number
   END_VAR

   VAR 
      FB_MFC_Sort_COY_ReceiveResult_Instance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MFC_Sort_COY_ReceiveResult";   // MFC message generation
      FB_MFC_Sort_COY_Result_Instance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MFC_Sort_COY_Result";
      s_Receive_P2P {InstructionName := 'Receive_P2P'; LibVersion := '4.1'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Receive_P2P;   // PtP receive standard function
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_SerialCommunicationReceiveStatus";   // Status structure
      sa_ReceivedMessage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..71] of Char;   // Received a message in Array of chars format
      ss_MessageStructure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Received a message structure
         EOT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Message structure
         PieceID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Piece ID
         VID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // VID
         RoutingCode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // RoutingCode
         Group { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Char;   // Group
         Level { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Char;   // Level
         Result { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Char;   // Result
         SOT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // SOT
      END_STRUCT;
      ss_Counter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Counterts only for statistics
         RecivedMessage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : ULInt;   // Counter of recived message
         CorrectLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : ULInt;   // Counter of recived message with correct lenght
         IncorrectLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : ULInt;   // Counter of recived message with incorrect lenght
         IncorrectStructure { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : ULInt;   // Counter of recived message with incorrect structure
      END_STRUCT;
      ss_ReceivedMessage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Received a message in String format
      sx_MessageRecived { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when new message recived
   END_VAR

   VAR_TEMP 
      tui_Cnt : UInt;   // Number of moved characters
      ti_LoopGIN : Int;   // Loop counter - to scan DB_GIN
      ti_LoopTimeout : Int;   // Loop counter - to scan DB_GIN
      tt_TimeDifference : LTime;   // Time difference
      ts_Time1 : String;   // Time value
      ts_Time2 : String;   // Time value
   END_VAR

   VAR CONSTANT 
      cs_SOT : String := 'ABC';   // Message constans - SOT
      cc_Underscore : Char := '_';   // Message constans - underscore
      cs_EOT : String := 'XYZ$R$L';   // Message constans - EOT
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	27/04/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	05/10/2023  | 1.1       | S. Nikodem   | Add MFc message generation
	13/03/2024  | 1.2       | S. Nieswiec  | Added to new baseline
	*)
	
	REGION 1 - Receive
	    
	    #s_Receive_P2P("PORT" := #i_UDT_SerialCommunicationConfiguration."Port",
	                   BUFFER := #ss_ReceivedMessage,
	                   NDR => #ss_Status.NRD,
	                   ERROR => #ss_Status.Erro,
	                   STATUS => #ss_Status.Status,
	                   LENGTH => #ss_Status.Leng);
	    
	    //Check received message lenght
	    IF #ss_Status.NRD THEN
	        
	        //Only for statistics
	        #ss_Counter.RecivedMessage += 1;
	        
	        IF #ss_Status.Leng = #i_UDT_SerialCommunicationConfiguration.ReceiveMessageLength THEN
	            
	            #sx_MessageRecived := True;
	            
	            //Only for statistics
	            #ss_Counter.CorrectLength += 1;
	            
	        ELSE
	            
	            //Only for statistics
	            #ss_Counter.IncorrectLength += 1;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 5- Decode
	    
	    IF #sx_MessageRecived THEN
	        
	        Strg_TO_Chars(Strg := #ss_ReceivedMessage,
	                      pChars := 0,
	                      Cnt => #tui_Cnt,
	                      Chars := #sa_ReceivedMessage);
	        
	        //Combine SOT characters
	        #ss_MessageStructure.SOT := CONCAT(IN1 := #sa_ReceivedMessage[1], IN2 := #sa_ReceivedMessage[2], IN3 := #sa_ReceivedMessage[3]);
	        
	        //Combine EOT characters
	        #ss_MessageStructure.EOT := CONCAT(IN1 := #sa_ReceivedMessage[25],
	                                           IN2 := #sa_ReceivedMessage[26],
	                                           IN3 := #sa_ReceivedMessage[27],
	                                           IN4 := #sa_ReceivedMessage[28],
	                                           IN5 := #sa_ReceivedMessage[29]);
	        
	        
	        IF (#ss_MessageStructure.SOT = #cs_SOT)
	            AND (#ss_MessageStructure.EOT = #cs_EOT)
	        THEN
	            
	            //Piece ID
	            #ss_MessageStructure.PieceID := CONCAT(IN1 := #sa_ReceivedMessage[4],
	                                                   IN2 := #sa_ReceivedMessage[5],
	                                                   IN3 := #sa_ReceivedMessage[6],
	                                                   IN4 := #sa_ReceivedMessage[7],
	                                                   IN5 := #sa_ReceivedMessage[8],
	                                                   IN6 := #sa_ReceivedMessage[9],
	                                                   IN7 := #sa_ReceivedMessage[10],
	                                                   IN8 := #sa_ReceivedMessage[11],
	                                                   IN9 := #sa_ReceivedMessage[12],
	                                                   IN10 := #sa_ReceivedMessage[13],
	                                                   IN11 := #sa_ReceivedMessage[14],
	                                                   IN12 := #sa_ReceivedMessage[15],
	                                                   IN13 := #sa_ReceivedMessage[16],
	                                                   IN14 := #sa_ReceivedMessage[17],
	                                                   IN15 := #sa_ReceivedMessage[18],
	                                                   IN16 := #sa_ReceivedMessage[19],
	                                                   IN17 := #sa_ReceivedMessage[20],
	                                                   IN18 := #sa_ReceivedMessage[21],
	                                                   IN19 := #sa_ReceivedMessage[22],
	                                                   IN20 := #sa_ReceivedMessage[23],
	                                                   IN21 := #sa_ReceivedMessage[24],
	                                                   IN22 := #sa_ReceivedMessage[25],
	                                                   IN23 := #sa_ReceivedMessage[26],
	                                                   IN24 := #sa_ReceivedMessage[27],
	                                                   IN25 := #sa_ReceivedMessage[28],
	                                                   IN26 := #sa_ReceivedMessage[29],
	                                                   IN27 := #sa_ReceivedMessage[30],
	                                                   IN28 := #sa_ReceivedMessage[31],
	                                                   IN29 := #sa_ReceivedMessage[32],
	                                                   IN30 := #sa_ReceivedMessage[33],
	                                                   IN31 := #sa_ReceivedMessage[34],
	                                                   IN32 := #sa_ReceivedMessage[35]);
	            
	            #ss_MessageStructure.PieceID := CONCAT(IN1 := #ss_MessageStructure.PieceID,
	                                                   IN2 := #sa_ReceivedMessage[36],
	                                                   IN3 := #sa_ReceivedMessage[37],
	                                                   IN4 := #sa_ReceivedMessage[38],
	                                                   IN5 := #sa_ReceivedMessage[39],
	                                                   IN6 := #sa_ReceivedMessage[40],
	                                                   IN7 := #sa_ReceivedMessage[41],
	                                                   IN8 := #sa_ReceivedMessage[42],
	                                                   IN9 := #sa_ReceivedMessage[43]);
	            
	            //VID
	            #ss_MessageStructure.VID := CONCAT(IN1 := #sa_ReceivedMessage[45],
	                                               IN2 := #sa_ReceivedMessage[46],
	                                               IN3 := #sa_ReceivedMessage[47],
	                                               IN4 := #sa_ReceivedMessage[48],
	                                               IN5 := #sa_ReceivedMessage[49],
	                                               IN6 := #sa_ReceivedMessage[50],
	                                               IN7 := #sa_ReceivedMessage[51],
	                                               IN8 := #sa_ReceivedMessage[52],
	                                               IN9 := #sa_ReceivedMessage[53],
	                                               IN10 := #sa_ReceivedMessage[54],
	                                               IN11 := #sa_ReceivedMessage[55],
	                                               IN12 := #sa_ReceivedMessage[56],
	                                               IN13 := #sa_ReceivedMessage[57],
	                                               IN14 := #sa_ReceivedMessage[58],
	                                               IN15 := #sa_ReceivedMessage[59],
	                                               IN16 := #sa_ReceivedMessage[60]);
	            
	            //Routing Code
	            #ss_MessageStructure.RoutingCode := CONCAT(IN1 := #sa_ReceivedMessage[61],
	                                                       IN2 := #sa_ReceivedMessage[62]);
	            
	            //Group
	            #ss_MessageStructure.Group := #sa_ReceivedMessage[63];
	            
	            //Level
	            #ss_MessageStructure.Level := #sa_ReceivedMessage[65];
	            
	            //Result
	            #ss_MessageStructure.Result := #sa_ReceivedMessage[66];
	            
	            //Copy data to DB_GIN structure
	            FOR #ti_LoopGIN := #i_UDT_SerialCommunicationConfiguration.GINRangeStart TO #i_UDT_SerialCommunicationConfiguration.GINRangeEnd DO
	                
	                IF ("DB_GIN".GIN[#ti_LoopGIN].DHL.PieceID = #ss_MessageStructure.PieceID)
	                THEN
	                    
	                    //Message reviced
	                    "DB_GIN".GIN[#ti_LoopGIN].DHL.Xray.DecisionMessage.Received := TRUE;
	                    
	                    //Save message reviced time
	                    "DB_GIN".GIN[#ti_LoopGIN].DHL.Xray.DecisionMessage.ReceivedTime := #is_ActualTime;
	                    
	                    //Routing Code
	                    "DB_GIN".GIN[#ti_LoopGIN].DHL.Xray.RoutingCode := #ss_MessageStructure.RoutingCode;
	                    
	                    //Group
	                    "DB_GIN".GIN[#ti_LoopGIN].DHL.Xray.Group := #ss_MessageStructure.Group;
	                    
	                    //Level
	                    "DB_GIN".GIN[#ti_LoopGIN].DHL.Xray.Level := #ss_MessageStructure.Level;
	                    
	                    //Result
	                    "DB_GIN".GIN[#ti_LoopGIN].DHL.Xray.Result := #ss_MessageStructure.Result;
	                    
	                    //Message generation
	                    "DB_GIN".GIN[#ti_LoopGIN].DHL.MFCMessage.Sent.XrayResult := TRUE;
	                    
	                    //Exit 'for loop'
	                    EXIT;
	                    
	                END_IF;
	                
	            END_FOR;
	            
	            //Generate message to MFC
	            //Based on the received message from Xray, generate a message to MFC
	            
	            #FB_MFC_Sort_COY_ReceiveResult_Instance(is_VID := #ss_MessageStructure.VID,
	                                                    is_PieceID := #ss_MessageStructure.PieceID,
	                                                    is_Group := #ss_MessageStructure.Group,
	                                                    is_Level := #ss_MessageStructure.Level,
	                                                    is_Result := #ss_MessageStructure.Result,
	                                                    ii_SourceNode := #ii_SourceNode,
	                                                    ii_DestinationNode := #ii_DestinationNode,
	                                                    iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                                                    iqa_FifoData := #iqa_FifoData,
	                                                    iqi_MessageSequenceNumber := #iqi_MessageSequenceNumber);
	            
	        ELSE
	            
	            #ss_Counter.IncorrectStructure += 1;
	            
	        END_IF;
	        
	        //Reset varaible
	        #sx_MessageRecived := false;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Receive message timeout
	    
	    FOR #ti_LoopTimeout := #i_UDT_SerialCommunicationConfiguration.GINRangeStart TO #i_UDT_SerialCommunicationConfiguration.GINRangeEnd DO
	        
	        IF "DB_GIN".GIN[#ti_LoopTimeout].DHL.Xray.BagIDMessage.Received
	            AND NOT "DB_GIN".GIN[#ti_LoopTimeout].DHL.Xray.DecisionMessage.Received
	            AND NOT "DB_GIN".GIN[#ti_LoopTimeout].DHL.Xray.DecisionMessage.NotReceivedOnTime
	        THEN
	            
	            //Delete year, month and day from variable
	            #ts_Time1 := DELETE(IN := "DB_GIN".GIN[#ti_LoopTimeout].DHL.Xray.BagIDMessage.TimeReceived, L := 11, P := 1);
	            #ts_Time2 := DELETE(IN := #is_ActualTime, L := 11, P := 1);
	            
	            //Time difference
	            "FC_TimeDiff"(is_EarlierTimeAsString := #ts_Time1,
	                          is_LaterTimeAsString := #ts_Time2,
	                          qt_TimeDifference => #tt_TimeDifference);
	            
	            //Check response time
	            IF #tt_TimeDifference > #i_UDT_SerialCommunicationConfiguration.ResponseTime THEN
	                
	                //Message not received on time
	                "DB_GIN".GIN[#ti_LoopTimeout].DHL.Xray.DecisionMessage.NotReceivedOnTime := True;
	                
	                //FORTNA internal exception results: T = Time-out receiving result 
	                "DB_GIN".GIN[#ti_LoopTimeout].DHL.Xray.Result := 'T';
	                
	                //Generate message to MFC
	                #FB_MFC_Sort_COY_Result_Instance(ii_GINRangeStart := #i_UDT_SerialCommunicationConfiguration.GINRangeStart,
	                                                 ii_GINRangeEnd := #i_UDT_SerialCommunicationConfiguration.GINRangeEnd,
	                                                 is_ObjectID := "DB_GIN".GIN[#ti_LoopTimeout].DHL.ObjectID,
	                                                 ii_SourceNode := #ii_SourceNode,
	                                                 ii_DestinationNode := #ii_DestinationNode,
	                                                 iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                                                 iqa_FifoData := #iqa_FifoData,
	                                                 iqi_MessageSequenceNumber := #iqi_MessageSequenceNumber);
	                
	                //Message generation
	                "DB_GIN".GIN[#ti_LoopTimeout].DHL.MFCMessage.Sent.XrayResult := TRUE;
	                
	            END_IF;
	            
	        END_IF;
	        
	    END_FOR;
	    
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_ChuteCapacityControl"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 89
// END_ATTRIBUTES
   VAR_INPUT 
      ix_EnableCapacityControl { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Enable Capacity Control
      ix_ProductSortedToChute { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Edge on end of  product sorted to chute signal
      idi_DisplacementConveyor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Displacment of conveyor [cm]
      idi_GapBack { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Gap back [mm]
      i_UDT_CapacityControlConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CapacityControlConfiguration";   // Capacity control configuration
   END_VAR

   VAR_OUTPUT 
      qx_CapacityControlActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Chute capacity control is active
      qx_ProductInChute { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Product is in chute
   END_VAR

   VAR_IN_OUT 
      iqi_ProductLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Product Length [mm]
   END_VAR

   VAR 
      sdi_ChuteFilling { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Chute filling
      R_TRIG_EnableCapacityControl {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // R_Trig enable capacity control
   END_VAR

   VAR_TEMP 
      tx_CapacityControlActive : Bool;   // TRUE if Chute filling is more than halfull but isn't full
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------   
	                                                                                     
	Version history:
	Date        | Version   | Author            | Remark
	----------------------------------------------------------------------------------------
	 01/03/2023 | 1.0       | R. Golonka       | first release TIA 17.0 | DHL Munich
	 01/03/2023 | 1.1       | S.Theocharis     | Add absolute instruction for displacement
	 12/03/2024 | 1.2       | S. Nieswiec      | Added to new Baseline
	 *)
	
	REGION 1 - Inicialization 
	    // Reset outputs and status
	    IF NOT #ix_EnableCapacityControl THEN
	        #sdi_ChuteFilling := 0;
	        #qx_CapacityControlActive := 0;
	        #qx_ProductInChute := 0;
	        RETURN;
	    END_IF;
	    
	    // Rising trig after enable
	    #R_TRIG_EnableCapacityControl(CLK := #ix_EnableCapacityControl);
	    
	    // Set zero to chute filing at first scan or function enable 
	    IF "DB_Memory".FirstScan OR #R_TRIG_EnableCapacityControl.Q
	    THEN
	        #sdi_ChuteFilling := 0;
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Chute filling count down
	    // Count chute filling with conveyor displacement
	    IF (#idi_DisplacementConveyor <> 0) AND (#sdi_ChuteFilling >= 0)
	    THEN
	        // Chute filing subtract displacement of conveyor [cm to mm]
	        #sdi_ChuteFilling -= (ABS(#idi_DisplacementConveyor) * 10);
	        // Set zero to chute filling 
	        IF (#sdi_ChuteFilling < 0)
	        THEN
	            #sdi_ChuteFilling := 0;
	        END_IF;
	    END_IF;
	END_REGION
	
	REGION 3 - Chute filling count up
	    // Calculate chute filling when product appear (ProductSortedToChute appear for one cycle)
	    IF #ix_ProductSortedToChute AND (#sdi_ChuteFilling >= 0) AND (#sdi_ChuteFilling < #i_UDT_CapacityControlConfiguration.ChuteLength)
	    THEN
	        #sdi_ChuteFilling := #sdi_ChuteFilling + #idi_GapBack + INT_TO_DINT(#iqi_ProductLength);
	        #iqi_ProductLength := 0;
	    END_IF;
	    
	    //Set maximum chute lenght when chute filing is biger than maximum chute lenght  
	    IF #sdi_ChuteFilling >= #i_UDT_CapacityControlConfiguration.ChuteLength THEN
	        #sdi_ChuteFilling := #i_UDT_CapacityControlConfiguration.ChuteLength;
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Capacity control active
	    // Capacity Control is active if chute filling isn't halffull or isn't full 
	    #tx_CapacityControlActive :=
	    (#sdi_ChuteFilling > #i_UDT_CapacityControlConfiguration.MaxProductLenght) OR (#sdi_ChuteFilling > #i_UDT_CapacityControlConfiguration.ProductLenghtHalfFull);
	    
	END_REGION
	
	REGION 5 - Outputs
	    // Set output of capacity control (True when chute don't want more parcel)
	    #qx_CapacityControlActive := #tx_CapacityControlActive;
	    
	    // Product is in Chute 
	    #qx_ProductInChute := (#sdi_ChuteFilling > 0);
	    
	END_REGION
	
	REGION 6 - Status 
	    // Status of chute capacity control
	    
	END_REGION
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_BiDirectionalControl"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 88
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_BiDirectionalConfguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_BiDirectionalConfiguration";   // Configuration structure
      ii_SystemMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // System mode message from MFC
      ix_EmptyInfeedLine { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Empty infeed line
      ix_EmptyOutfeedLine { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Empty outfeed line
   END_VAR

   VAR_OUTPUT 
      q_UDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_BiDirectionalStatus";   // Status structure
   END_VAR

   VAR_IN_OUT 
      iq_UDT_InfeedSystem : "UDT_EquipmentControl";   // Infeed system equipment control
      iq_UDT_OutfeedSystem : "UDT_EquipmentControl";   // Outfeed system equipment control
      iq_UDT_BiDirectionalInterface : "UDT_BiDirectionalInterface";   // BiDirectional function inteface structure
   END_VAR

   VAR 
      R_TRIG_InfeedMode {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of infeed mode
      R_TRIG_OutfeedMode {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of outfeed mode
      R_TRIG_OutfeedStopped {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of outfeed system stopped
      R_TRIG_InfeedStopped {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of infeed system stopped
   END_VAR
   VAR RETAIN
      s_UDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_BiDirectionalStatus";   // Status structure
      si_StepNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Step number
   END_VAR

   VAR CONSTANT 
      ci_InfeedMode : Int := 1;   // Infeed mode number
      ci_OutfeedMode : Int := 2;   // Outfeed mode number
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------    
	
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	20/07/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/12/2023  | 1.1       | S. Nikodem   | Added input time freeze
	13/12/2023  | 1.2       | S. Nikodem   | Update
	17/01/2024  | 1.3       | L. Klar      | Update
	07/02/2024  | 1.3       | L. Klar      | Stop switching device added
	*)
	
	REGION 1 - Triggers
	    
	    //Infeed mode active
	    #R_TRIG_InfeedMode(CLK := (#ii_SystemMode = #ci_InfeedMode));
	    
	    //Outfeed mode active
	    #R_TRIG_OutfeedMode(CLK := (#ii_SystemMode = #ci_OutfeedMode));
	    
	    //Outfeed system stopped
	    #R_TRIG_OutfeedStopped(CLK := #iq_UDT_BiDirectionalInterface.OutfeedStopped);
	    
	    //Infeed system stopped
	    #R_TRIG_InfeedStopped(CLK := #iq_UDT_BiDirectionalInterface.InfeedStopped);
	    
	END_REGION
	
	REGION 2 - Select mode
	    
	    //Initial value when mode changed
	    IF (#R_TRIG_OutfeedMode.Q OR #R_TRIG_InfeedMode.Q) AND NOT "DB_Memory".FirstScan THEN
	        
	        //Reset
	        #si_StepNumber := 1;
	        
	        #s_UDT_HMIStatus.InfeedModeRequested := False;
	        #s_UDT_HMIStatus.OutfeedModeRequested := False;
	        #s_UDT_HMIStatus.InfeedModeReady := False;
	        #s_UDT_HMIStatus.OutfeedModeReady := False;
	        #s_UDT_HMIStatus.ChangingMode := False;
	        
	    END_IF;
	    
	    //Proces selected mode
	    CASE #ii_SystemMode OF
	        #ci_InfeedMode://InfeedMode
	            
	            CASE #si_StepNumber OF
	                1: //Requested to change the mode of operation of the system
	                    
	                    //Set 
	                    #s_UDT_HMIStatus.InfeedModeRequested := TRUE;
	                    #s_UDT_HMIStatus.ChangingMode := TRUE;
	                    #si_StepNumber := 2;
	                    
	                2://Waiting for the line to empty, according to the configured time
	                    
	                    IF #ix_EmptyOutfeedLine//#s_FB_TimeDelayInfeed.qx_DelayedSignal
	                    THEN
	                        //Set
	                        #iq_UDT_BiDirectionalInterface.RequestToStopOutfeed := TRUE;
	                        #iq_UDT_BiDirectionalInterface.RequestToStopBidirectional := TRUE;
	                        #si_StepNumber := 3;
	                    END_IF;
	                    
	                3://Checking if the line stopped 
	                    
	                    IF #iq_UDT_BiDirectionalInterface.OutfeedStopped THEN
	                        //Reset
	                        #iq_UDT_BiDirectionalInterface.RequestToStopOutfeed := False;
	                        #s_UDT_HMIStatus.OutfeedModeActive := False;
	                    END_IF;
	                    IF #iq_UDT_BiDirectionalInterface.BidirectionalStopped THEN
	                        //Reset
	                        #iq_UDT_BiDirectionalInterface.RequestToStopBidirectional := False;
	                    END_IF;
	                    
	                    //Stopping or changing the position of the switching device
	                    IF NOT #iq_UDT_BiDirectionalInterface.RequestToStopOutfeed
	                        AND NOT #iq_UDT_BiDirectionalInterface.RequestToStopBidirectional
	                    THEN
	                        //Set
	                        #iq_UDT_BiDirectionalInterface.RequestToSwitchingSystem := True;
	                        #si_StepNumber := 4;
	                    END_IF;
	                    
	                4://Check if Switching system is in position
	                    
	                    IF #iq_UDT_BiDirectionalInterface.SwitchingSystemReady
	                    THEN
	                        //Reset
	                        #iq_UDT_BiDirectionalInterface.RequestToSwitchingSystem := FALSE;
	                        #iq_UDT_BiDirectionalInterface.RequestToStopSwitchingSystem := TRUE;
	                        #s_UDT_HMIStatus.InfeedModeRequested := FALSE;
	                        #s_UDT_HMIStatus.ChangingMode := FALSE;
	                        
	                        //Set
	                        #s_UDT_HMIStatus.InfeedModeReady := True;
	                        #si_StepNumber := 5;
	                    END_IF;
	                    
	                5://The system is ready to restart, waiting for the command. 
	                    
	                    IF #s_UDT_HMIStatus.InfeedModeReady
	                        
	                        AND (#iq_UDT_InfeedSystem.Command.Start
	                        OR #iq_UDT_InfeedSystem.Command.AutomaticOn)
	                    THEN
	                        //Reset
	                        #iq_UDT_BiDirectionalInterface.RequestToStopSwitchingSystem := FALSE;
	                        #s_UDT_HMIStatus.InfeedModeReady := False;
	                        //Set
	                        #s_UDT_HMIStatus.InfeedModeActive := True;
	                    END_IF;
	                    
	                    IF (#iq_UDT_InfeedSystem.Command.Stop
	                        OR NOT #iq_UDT_InfeedSystem.Command.AutomaticOn)
	                    THEN
	                        // Set
	                        #s_UDT_HMIStatus.InfeedModeReady := True;
	                        
	                    END_IF;
	                    
	            END_CASE;
	            
	        #ci_OutfeedMode://OutfeedMode
	            
	            CASE #si_StepNumber OF
	                1://Requested to change the mode of operation of the system
	                    
	                    //Set 
	                    #s_UDT_HMIStatus.OutfeedModeRequested := TRUE;
	                    #s_UDT_HMIStatus.ChangingMode := TRUE;
	                    #si_StepNumber := 2;
	                    
	                    
	                2:   //Waiting for the line to empty, according to the configured time
	                    
	                    IF #ix_EmptyInfeedLine// #s_FB_TimeDelayOutfeed.qx_DelayedSignal
	                        
	                    THEN
	                        #iq_UDT_BiDirectionalInterface.RequestToStopInfeed := TRUE;
	                        #iq_UDT_BiDirectionalInterface.RequestToStopBidirectional := TRUE;
	                        #si_StepNumber := 3;
	                    END_IF;
	                    
	                    
	                3: //Checking if the line stopped 
	                    
	                    IF #iq_UDT_BiDirectionalInterface.InfeedStopped THEN
	                        //Reset
	                        #iq_UDT_BiDirectionalInterface.RequestToStopInfeed := False;
	                        #s_UDT_HMIStatus.InfeedModeActive := False;
	                    END_IF;
	                    IF #iq_UDT_BiDirectionalInterface.BidirectionalStopped THEN
	                        //Reset
	                        #iq_UDT_BiDirectionalInterface.RequestToStopBidirectional := False;
	                    END_IF;
	                    
	                    //Stopping or changing the position of the switching device
	                    IF NOT #iq_UDT_BiDirectionalInterface.RequestToStopInfeed
	                        AND NOT #iq_UDT_BiDirectionalInterface.RequestToStopBidirectional
	                    THEN
	                        //Set
	                        #iq_UDT_BiDirectionalInterface.RequestToSwitchingSystem := True;
	                        #si_StepNumber := 4;
	                    END_IF;
	                    
	                4://Check if Switching system is in position
	                    
	                    IF #iq_UDT_BiDirectionalInterface.SwitchingSystemReady
	                    THEN
	                        //Reset
	                        #iq_UDT_BiDirectionalInterface.RequestToSwitchingSystem := FALSE;
	                        #iq_UDT_BiDirectionalInterface.RequestToStopSwitchingSystem := TRUE;
	                        #s_UDT_HMIStatus.OutfeedModeRequested := FALSE;
	                        #s_UDT_HMIStatus.ChangingMode := FALSE;
	                        //Set
	                        #s_UDT_HMIStatus.OutfeedModeReady := True;
	                        #si_StepNumber := 5;
	                    END_IF;
	                    
	                5://The system is ready to restart, waiting for the command. 
	                    
	                    IF #s_UDT_HMIStatus.OutfeedModeReady
	                        AND (#iq_UDT_OutfeedSystem.Command.Start
	                        OR #iq_UDT_OutfeedSystem.Command.AutomaticOn)
	                    THEN
	                        //Reset
	                        #s_UDT_HMIStatus.OutfeedModeReady := False;
	                        #iq_UDT_BiDirectionalInterface.RequestToStopSwitchingSystem := FALSE;
	                        //Set
	                        #s_UDT_HMIStatus.OutfeedModeActive := True;
	                    END_IF;
	                    
	                    IF (#iq_UDT_OutfeedSystem.Command.Stop
	                        OR NOT #iq_UDT_OutfeedSystem.Command.AutomaticOn)
	                    THEN
	                        // Set
	                        #s_UDT_HMIStatus.OutfeedModeReady := True;
	                        
	                    END_IF;
	                    
	            END_CASE;
	            
	    END_CASE;
	    
	END_REGION
	
	REGION 3 - Status
	    
	    // //Copy time
	    // CASE #ii_SystemMode OF
	    //     1:
	    //         //Convert time from ms to sec 
	    //         #iq_UDT_BiDirectionalInterface.ElapsedTime := LREAL_TO_UDINT(#s_FB_TimeDelayInfeed.qlr_ActualTime) / 1000;
	    
	    //         IF #i_UDT_BiDirectionalConfguration.TimeDelayInfeed <= #s_FB_TimeDelayInfeed.qlr_ActualTime THEN
	    //             #iq_UDT_BiDirectionalInterface.ElapsedTime := 0;
	    //         END_IF;
	    
	    //     2:
	    //         //Convert time from ms to sec 
	    //         #iq_UDT_BiDirectionalInterface.ElapsedTime := LREAL_TO_UDINT(#s_FB_TimeDelayOutfeed.qlr_ActualTime) / 1000;
	    
	    //         IF #i_UDT_BiDirectionalConfguration.TimeDelayOutfeed <= #s_FB_TimeDelayOutfeed.qlr_ActualTime THEN
	    //             #iq_UDT_BiDirectionalInterface.ElapsedTime := 0;
	    //         END_IF;
	    
	    //     ELSE
	    
	    //         #iq_UDT_BiDirectionalInterface.ElapsedTime := 0;
	    
	    // END_CASE;
	    
	    // //Reset ststem mode status
	    // IF #R_TRIG_OutfeedStopped.Q THEN
	    
	    //     #s_UDT_HMIStatus.OutfeedModeActive := False;
	    
	    // END_IF;
	    
	    // //Reset ststem mode status
	    // IF #R_TRIG_InfeedStopped.Q THEN
	    
	    //     #s_UDT_HMIStatus.InfeedModeActive := False;
	    
	    // END_IF;
	    
	    //Copy starus to output structure
	    #q_UDT_HMIStatus := #s_UDT_HMIStatus;
	    
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_XbeltCommon_Interface"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 246
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_Sorter_DownStream_Common { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_Sorter_DownStream_Common";   // Sorter Downstream structure
      ix_FireAlarm { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Fire alarm
   END_VAR

   VAR_OUTPUT 
      q_UDT_DownStream_Sorter_Common { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_DownStream_Sorter_Common";   // Downstream Sorter structure
      qx_WatchDogError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // WatchDog error
      qx_AvailableCarriers { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Available carriers
   END_VAR

   VAR_IN_OUT 
      iq_UDT_ConnectStatus : "UDT_ConnectStatus";   // Connect status structure
   END_VAR

   VAR 
      s_FB_ConnectionCheck { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_ConnectionCheck";   // FB to connection check
      s_UDT_DownStream_Sorter_Common { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_DownStream_Sorter_Common";   // static DownStream Sorter
      sx_WatchDogError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // static WatchDog Error
      sx_AvailableCarriers { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // static available Carriers
   END_VAR


BEGIN
	
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------    
	                                                                                      
	Version history:
	Date        | Version   | Author            | Remark
	----------------------------------------------------------------------------------------
	 30/03/2023 | 0.1       | R.Golonka         | first release TIA 17.0 | DHL Munich 
	 11/09/2023 | 1.0       | S.Theocharis      | Added watchdog output
	 13/03/2024 | 1.1       | S. Nieswiec       | Added to new baseline
	 *)
	
	REGION 1 - Fire alarm
	    
	    // Fire alarm 
	    #s_UDT_DownStream_Sorter_Common.FireAlarm := #ix_FireAlarm;
	    
	END_REGION
	
	REGION 2 - Available carriees
	    
	    // Available carriees 
	    #sx_AvailableCarriers := (#i_UDT_Sorter_DownStream_Common.AvailableCarriers = 1);
	    
	END_REGION
	
	REGION 3 - Connection check 
	    
	    // Connection status check
	    #s_FB_ConnectionCheck(ib_Watchdog := #i_UDT_Sorter_DownStream_Common.Watchdog,
	                          ix_Trigger100ms := "DB_Memory"."OS_0.1sec",
	                          qb_Watchdog => #s_UDT_DownStream_Sorter_Common.Watchdog,
	                          iqudt_ConnectionStatus := #iq_UDT_ConnectStatus);
	    
	END_REGION
	
	REGION 4 - Output update 
	    
	    // Output update 
	    #q_UDT_DownStream_Sorter_Common := #s_UDT_DownStream_Sorter_Common;
	    #qx_AvailableCarriers := #sx_AvailableCarriers;
	    #qx_WatchDogError := #sx_WatchDogError;
	    
	END_REGION
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_SNCY_Result"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 244
// END_ATTRIBUTES
   VAR_INPUT 
      ii_DecisionPoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Decision Point - Distance from the end of the conveyor
      ii_DischargeLocation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Discharge location identifier
      ix_PEC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when PEC is not blocked
   END_VAR

   VAR_IN_OUT 
      iqa_TrackingData : Array[*] of Int;   // Conveyor tracking data
      iq_UDT_FifoHeader_MFCMessage : "UDT_FifoHeader";   // MFC Message FIFO header
      iqs_FifoData_MFCMessage : Array[*] of "UDT_MessageV2";   // MFC Message FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // MFC Message Message number
   END_VAR

   VAR 
      s_FB_MFC_Sort_SortResult { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MFC_Sort_SortResult";
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	05/07/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/03/2024  | 1.1       | S. Nieswiec  | Added to new baseline, block needs uptade after munich is finished
	02/05/2024  | 1.2       | J.Majer      | Datatype conversions changed from automatic to explicit, to accomodate IEC 61131-3 standard
	
	*)
	
	REGION 1 - Combine data
	    
	    IF NOT #ix_PEC
	        AND #iqa_TrackingData[#ii_DecisionPoint] <> 0
	        AND NOT "DB_GIN".GIN[#iqa_TrackingData[#ii_DecisionPoint]].DHL.MFCMessage.Sent.SortResult
	    THEN
	        
	        //Parcel sorted correctly
	        "DB_GIN".GIN[#iqa_TrackingData[#ii_DecisionPoint]].General.SortStatus.GoodDivert := True;
	        "DB_GIN".GIN[#iqa_TrackingData[#ii_DecisionPoint]].General.SortStatus.DivertDestination := UINT_TO_INT(#ii_DischargeLocation);
	        
	        //Sort Result message - parcel sorted correctly
	        #s_FB_MFC_Sort_SortResult(is_ObjectID := "DB_GIN".GIN[#iqa_TrackingData[#ii_DecisionPoint]].DHL.ObjectID,
	                                  ii_DischargeLocation := #ii_DischargeLocation,
	                                  ii_Result := 1,
	                                  ii_Reason := 1,
	                                  iq_UDT_FifoHeader := #iq_UDT_FifoHeader_MFCMessage,
	                                  iqs_FifoData := #iqs_FifoData_MFCMessage,
	                                  iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	        
	        //Sort Result message generated
	        "DB_GIN".GIN[#iqa_TrackingData[#ii_DecisionPoint]].DHL.MFCMessage.Sent.SortResult := True;
	        
	    END_IF;
	    
	END_REGION
	
	
	
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_LocalMotorControl"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 98
// END_ATTRIBUTES
   VAR_INPUT 
      ix_StartStopButton { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Local motor control pushbutton
   END_VAR

   VAR_OUTPUT 
      qx_PilotLamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Pilot lamp of blue colour
   END_VAR

   VAR_IN_OUT 
      iq_UDT_EquipmentControl : "UDT_EquipmentControl";   //           Equipment control structure
      iq_UDT_ConveyorCommand : "UDT_ConveyorCommand";   // Conveyor command stucture
      iq_UDT_ConveyorInterface : "UDT_ConveyorInterface";   // Interface structure
   END_VAR

   VAR 
      R_TRIG_ToogleButton {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger manual mode
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             Fortna Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |
	|                                                                                      |     
	----------------------------------------------------------------------------------------
	                        
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	18/11/2022  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	07/12/2023  | 1.1       | S. Nikodem   | Added Equipment Control structure
	13/03/2024  | 1.2       | S. Nieswiec  | Added to new Baseline
	*)
	
	REGION 1  - Pilot blue lamp
	    
	    //Is flash when manual mode is acive and motor is ready to start. When the motor is running then lamp will stay solid
	    #qx_PilotLamp := ((#iq_UDT_ConveyorCommand.ManualMode OR #iq_UDT_EquipmentControl.Command.ManualMode) AND "mx_Clock_1Hz") OR #iq_UDT_ConveyorInterface.VFDRunning;
	    
	END_REGION
	
	REGION 2 - Toggle button function
	    
	    //One button can start and stop the conveyor
	    //Memory to save information about positive edge
	    #R_TRIG_ToogleButton(CLK := (#ix_StartStopButton));
	    
	    IF #iq_UDT_ConveyorCommand.ManualMode OR #iq_UDT_EquipmentControl.Command.ManualMode THEN
	        IF #R_TRIG_ToogleButton.Q THEN
	            
	            #iq_UDT_ConveyorCommand.ManualStartStop := NOT #iq_UDT_ConveyorCommand.ManualStartStop;
	            
	        END_IF;
	    ELSE
	        //Reset value
	        #iq_UDT_ConveyorCommand.ManualStartStop := 0;
	        
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_SNCY_Lost"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 243
// END_ATTRIBUTES
   VAR_INPUT 
      ii_SourceNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 0;   // Source Node
      ii_DestinationNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 0;   // Destination Node
   END_VAR

   VAR_IN_OUT 
      iqs_FifoData_LostGin : Array[*] of Int;   //  Lost Gin Fifo data
      iq_UDT_FifoHeader_LostGin : "UDT_FifoHeader";   //  Lost Gin Fifo header
      iq_UDT_FifoHeader_MFCMessage : "UDT_FifoHeader";   // MFC Message FIFO header
      iqs_FifoData_MFCMessage : Array[*] of "UDT_MessageV2";   // MFC Message FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // MFC Message Message number
   END_VAR

   VAR 
      s_FB_MFC_Sort_SortResult { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MFC_Sort_SortResult";   // Message generator
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // FiFo status
         FIFOStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_FifoStatus";   // Fifo status
         FIFOError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Fifo error
         FIFOWarning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Fifio warning
         InvalidGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid GIN
         InvalidMessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid message lenght
         InvalidMessagegArraySize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid message array size
      END_STRUCT;
      si_GIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // GIN number from Fifo
      sudi_LostCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Counter of generated messages
      si_Location { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	30/06/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/03/2024  | 1.1       | S. Nieswiec  | Added to new baseline, block needs uptade after munich is finished
	*)
	
	REGION 1 - Read fifo status
	    
	    "FC_Fifo"(ic_Mode := 'S',
	              qUDT_Status => #ss_Status.FIFOStatus,
	              qx_Error => #ss_Status.FIFOError,
	              qx_Warning => #ss_Status.FIFOWarning,
	              iqv_Data := #si_GIN,
	              iqUDT_FifoHeader := #iq_UDT_FifoHeader_LostGin,
	              iqv_DataBuffer := #iqs_FifoData_LostGin);
	END_REGION
	
	REGION 2 - Read lost GIN
	    
	    IF (NOT #iq_UDT_FifoHeader_LostGin.Status.Empty                             // FIFO not empty 
	        AND NOT #ss_Status.FIFOError)                                          // No FIFO error 
	    THEN
	        
	        // Mode 'R' - Read FIFO record
	        "FC_Fifo"(ic_Mode := 'R',
	                  qUDT_Status => #ss_Status.FIFOStatus,
	                  qx_Error => #ss_Status.FIFOError,
	                  qx_Warning => #ss_Status.FIFOWarning,
	                  iqv_Data := #si_GIN,
	                  iqUDT_FifoHeader := #iq_UDT_FifoHeader_LostGin,
	                  iqv_DataBuffer := #iqs_FifoData_LostGin);
	        
	        //Location
	        IF "DB_GIN".GIN[#si_GIN].DHL.ParcelLocation.Current = 0 THEN
	            
	            #si_Location := "DB_GIN".GIN[#si_GIN].DHL.ParcelLocation.Last;
	        ELSE
	            
	            #si_Location := "DB_GIN".GIN[#si_GIN].DHL.ParcelLocation.Current;
	            
	        END_IF;
	        
	        //Sort Result message - parcel lost
	        #s_FB_MFC_Sort_SortResult(is_ObjectID := "DB_GIN".GIN[#si_GIN].DHL.ObjectID,
	                                  ii_DischargeLocation := #si_Location,
	                                  ii_Result := 3,
	                                  ii_Reason := 6,
	                                  ii_SourceNode := #ii_SourceNode,
	                                  ii_DestinationNode := #ii_DestinationNode,
	                                  iq_UDT_FifoHeader := #iq_UDT_FifoHeader_MFCMessage,
	                                  iqs_FifoData := #iqs_FifoData_MFCMessage,
	                                  iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	        
	        
	        //Counter only for statistics
	        #sudi_LostCounter += 1;
	        
	        //Reset
	        #si_Location := 0;
	        #si_GIN := 0;
	        
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_Xray_BackBelt"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 109
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_XrayConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_XrayRapiscanConfiguration";   // Xray configuration structure
      i_UDT_InputConveyorConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorConfiguration";   // Input conveyor configuration structure
      ix_Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when function should be active
   END_VAR

   VAR_IN_OUT 
      iqa_XrayConveyorTrackingData : Array[*] of Int;   // Xray conveyor tracking array
      iqa_InputConveyorTrackingData : Array[*] of Int;   // Input conveyor tracking array
      iq_UDT_XrayConveyorInterface : "UDT_ConveyorInterface";   // Xray conveyor interface structure
      iq_UDT_XrayInterface : "UDT_XrayInterface";   // Xray interface structure
   END_VAR

   VAR 
      F_TRIG_ConvRunRvs {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger of Xray conveyor runs in reverse direction signal
      R_TRIG_BackBelt {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of Backbelt signal
      sa_BackbeltDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..20] of Int;   // Backbelt distances
      ss_Counter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Statistics counters
         InputConveyorRunRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Counter how many times the "InputConveyorRunRvs" signal has been activated
         XrayConveyorEnoughSpace { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Counter how many times the "XrayConveyorEnoughSpace" signal has been activated
         InputConveyorNotEnoughSpace { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Counter how many times the "InputConveyorNotEnoughSpace" signal has been activated
         BackbeltActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Counter how many times the "BackbeltActive" signal has been activated
      END_STRUCT;
      si_XrayConveyorDisplacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Xray conveyor displacement when conveyor running reverse
      si_ArraySavePosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 1;   // Save position
      si_XrayConveyorGapDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Xray conveyor gap distance, from conveyor beginning to first parcel
      si_InputConveyorGapDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Input conveyor gap distance, from conveyor beginning to first parcel
      sx_InputConveyorRunRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request command to run reverse input conveyor
   END_VAR

   VAR_TEMP 
      ti_XrayConveyor : Int;   // Loop counter - to check gap between parcel and beginning of the Xray conveyor
      ti_InputConveyor : Int;   // Loop counter - to check gap between parcel and beginning of the input conveyor
      ti_ArrayElements : Int;   // Copy size of the array
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------  
	
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	07/03/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/03/2024  | 1.1       | S. Nieswiec  | Added to new baseline
	02/05/2024  | 1.2       | J.Majer      | Datatype conversions changed from automatic to explicit, to accomodate IEC 61131-3 standard
	*)
	
	REGION 1 - Triggers
	    
	    // Xray conveyor running in reverse direction
	    #F_TRIG_ConvRunRvs(CLK := #iq_UDT_XrayInterface.XrayConveyor.RunRvs);
	    
	    // BackBelt active
	    #R_TRIG_BackBelt(CLK := #iq_UDT_XrayInterface.Backbelt.Active);
	    
	    IF #R_TRIG_BackBelt.Q THEN
	        
	        //Only for statistics
	        #ss_Counter.BackbeltActive += 1;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Function enable
	    
	    //Copy signal to Xray interface
	    #iq_UDT_XrayInterface.Backbelt.Enable := #ix_Enable;
	    
	END_REGION
	
	REGION 3 - Check if is enough space for Backbelt
	    
	    IF #R_TRIG_BackBelt.Q                                  //Rising edge trigger active
	        AND #ix_Enable                                      //Function is enable
	    THEN
	        
	        //Initial variable
	        #si_XrayConveyorGapDistance := 0;
	        #si_InputConveyorGapDistance := 0;
	        
	        //Check the gap between parcel and beginning of the Xray conveyor
	        FOR #ti_XrayConveyor := DINT_TO_INT(#i_UDT_XrayConfiguration.XrayConveyor.Length) TO 0 BY -1
	        DO
	            
	            #si_XrayConveyorGapDistance += 1;
	            
	            
	            IF #iqa_XrayConveyorTrackingData[#ti_XrayConveyor] > 0 THEN
	                
	                //Parcel detected, exit the loop
	                EXIT;
	                
	            END_IF;
	            
	        END_FOR;
	        
	        //Check if there is 
	        IF #si_XrayConveyorGapDistance < #i_UDT_XrayConfiguration.BackBeltDistance THEN
	            
	            //Check the gap between parcel and beginning of the Input conveyor
	            FOR #ti_InputConveyor := DINT_TO_INT(#i_UDT_InputConveyorConfiguration.Common.Length) TO 0 BY -1
	            DO
	                
	                #si_InputConveyorGapDistance += 1;
	                
	                IF #iqa_InputConveyorTrackingData[#ti_InputConveyor] > 0 THEN
	                    
	                    //Parcel detected, exit the loop
	                    EXIT;
	                    
	                END_IF;
	                
	            END_FOR;
	            
	            
	            IF #si_InputConveyorGapDistance > #i_UDT_XrayConfiguration.BackBeltDistance THEN
	                
	                //Run input conveyor in reverse direction if needed
	                #sx_InputConveyorRunRvs := True;
	                
	                //Only for statistics
	                #ss_Counter.InputConveyorRunRvs += 1;
	                
	            ELSE
	                
	                //Only for statistics
	                #ss_Counter.InputConveyorNotEnoughSpace += 1;
	                
	            END_IF;
	            
	        ELSE
	            
	            //Only for statistics
	            #ss_Counter.XrayConveyorEnoughSpace += 1;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Input conveyor control
	    
	    //Control command to run input conveyor in reverse direction
	    #iq_UDT_XrayInterface.InputConveyor.CommandRunRvs := #sx_InputConveyorRunRvs
	    AND #iq_UDT_XrayInterface.XrayConveyor.RunRvs
	    AND #iq_UDT_XrayInterface.Backbelt.Active
	    AND #ix_Enable;
	    
	    //Reset command  
	    IF NOT #ix_Enable
	        OR NOT #iq_UDT_XrayInterface.Backbelt.Active
	    THEN
	        #sx_InputConveyorRunRvs := False;
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Save Backbelt distance 
	    
	    //Logic prepared only for commissioning
	    
	    //Count up value from displacement to static variable
	    IF #iq_UDT_XrayInterface.XrayConveyor.RunRvs THEN
	        #si_XrayConveyorDisplacement += ABS(#iq_UDT_XrayConveyorInterface.Displacement);
	    END_IF;
	    
	    //When reverse direction is switch off then copy data to array
	    IF #F_TRIG_ConvRunRvs.Q THEN
	        //Copy value to array
	        #sa_BackbeltDistance[#si_ArraySavePosition] := #si_XrayConveyorDisplacement;
	        
	        //Switch up save position in array
	        #si_ArraySavePosition += 1;
	        
	        //Reset value in variable
	        #si_XrayConveyorDisplacement := 0;
	    END_IF;
	    
	    // Get size of the array.
	    #ti_ArrayElements := "FC_GetNrOfArrayEl"(#sa_BackbeltDistance);
	    
	    //Reset saving position 
	    IF #ti_ArrayElements > #si_ArraySavePosition THEN
	        
	        #si_ArraySavePosition := 1;
	        
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_Xray_RegistrationInfo"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 111
// END_ATTRIBUTES
   VAR_INPUT 
      ii_GINRangeStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // GIN range start value
      ii_GINRangeEnd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // GIN range end value
   END_VAR

   VAR_IN_OUT 
      iqs_XrayRegistrationInfo : Struct   // Structure from MFC
         ObjectID : String[10];   // ObjectI D
         VID : String[16];   // VID
         PieceID : String[40];   // Piece ID
         RoutingCode : String[2];   // Routing code
      END_STRUCT;
   END_VAR

   VAR 
      ss_Counter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Counterts only for statistics
         SavedData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : ULInt;   // Counter of saved data
         DataNotMerged { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : ULInt;   // Counter of triggers when  data not merged
      END_STRUCT;
      ss_OldObjectID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[10];   // Old Objcet ID
      sx_NewData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // New Object ID
      sx_DataMerged { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Data merged
   END_VAR

   VAR_TEMP 
      ti_Loop_GIN : Int;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	28/04/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/03/2024  | 1.1       | S. Nieswiec  | Added to new baseline
	*)
	
	REGION 1 - New data
	    
	    IF #iqs_XrayRegistrationInfo.ObjectID <> #ss_OldObjectID THEN
	        
	        //Set variable
	        #sx_NewData := TRUE;
	        //Copy value to memory
	        #ss_OldObjectID := #iqs_XrayRegistrationInfo.ObjectID;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Save value in array row
	    
	    IF #sx_NewData THEN
	        
	        FOR #ti_Loop_GIN := #ii_GINRangeStart TO #ii_GINRangeEnd DO
	            
	            IF "DB_GIN".GIN[#ti_Loop_GIN].DHL.ObjectID = #iqs_XrayRegistrationInfo.ObjectID THEN
	                
	                //VID
	                "DB_GIN".GIN[#ti_Loop_GIN].DHL.VID := #iqs_XrayRegistrationInfo.VID;
	                //PieceID
	                "DB_GIN".GIN[#ti_Loop_GIN].DHL.PieceID := #iqs_XrayRegistrationInfo.PieceID;
	                //RoutingCode
	                "DB_GIN".GIN[#ti_Loop_GIN].DHL.Xray.RoutingCode := #iqs_XrayRegistrationInfo.RoutingCode;
	                
	                //Counterts only for statistics
	                #ss_Counter.SavedData += 1;
	                
	                //Data merged
	                #sx_DataMerged := TRUE;
	                
	                //Exit loop
	                EXIT;
	                
	            END_IF;
	            
	        END_FOR;
	        
	        IF NOT #sx_DataMerged THEN
	            
	            //Counterts only for statistics
	            #ss_Counter.DataNotMerged += 1;
	            
	        END_IF;
	        
	        //Reset value 
	        #sx_NewData := FALSE;
	        #sx_DataMerged := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_Xray_SerialCommunication"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 112
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_SerialCommunicationConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_SerialComConfiguration";   // Serial communication configuration
      ix_Trigger { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Diagnostics trigger signal - Connect system memory clock
   END_VAR

   VAR_OUTPUT 
      q_UDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_SerialCommunicationStatus";   // Status structure
   END_VAR

   VAR_IN_OUT 
      iq_UDT_XrayInterface : "UDT_XrayInterface";   // Xray interface structure
   END_VAR

   VAR 
      Signal_Get {InstructionName := 'Signal_Get'; LibVersion := '4.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Signal_Get;   // Signal_get block
      ss_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Status structure
         NDR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
         DTR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         DSR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         RTS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         CTS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         DCD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         RING { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      END_STRUCT;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	16/03/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/03/2024  | 1.1       | S. Nieswiec  | Added to new baseline
	*)
	
	REGION 1 - P2P diagnostics function
	    
	    #Signal_Get(REQ := #ix_Trigger,
	                "PORT" := #i_UDT_SerialCommunicationConfiguration."Port",
	                NDR => #ss_Status.NDR,
	                ERROR => #ss_Status.Error,
	                STATUS => #ss_Status.Status,
	                DTR => #ss_Status.DTR,
	                DSR => #ss_Status.DSR,
	                RTS => #ss_Status.RTS,
	                CTS => #ss_Status.CTS,
	                DCD => #ss_Status.DCD,
	                RING => #ss_Status.RING);
	    
	END_REGION
	
	REGION 2 - Status structure
	    
	    //Output structure
	    #q_UDT_Status.Connected := #ss_Status.DSR AND #ss_Status.CTS;
	    
	    #q_UDT_Status.CommunicationFault := #ss_Status.Error
	    OR NOT #ss_Status.DSR
	    OR NOT #ss_Status.CTS;
	    
	    //In/Out structure
	    #iq_UDT_XrayInterface.Communication.Connceted := #ss_Status.DSR AND #ss_Status.CTS;
	    
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_XbeltExit_Interface"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 2.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 108
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_Sorter_Downstream { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "Sorter_DownStream_Advanced";   // Downstream Sorter input
      i_UDT_Outfeed2StatesStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_Outfeed2StatesStatus";   // Outfeed2States
      i_UDT_AssociatedConveyorInterface { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorInterface";   // Conveyor Interface
      ix_ConfigHorizontalOutfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when this block is used for horizontal outfeed , FALSE for spiral
      ix_HorOutfeed_PECBoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // sensor PEC begin of section
      ix_HorOutfeed_PECJam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // sensor PEC jam
   END_VAR

   VAR_OUTPUT 
      q_UDT_Downstream_Sorter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "DownStream_Sorter_Basic";   // Downstream Sorter output
      q_UDT_XBeltExitStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_XBeltExitStatus";   // XBelt exit status
      q_UDT_XBeltExitInterface { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_XbeltExitInterface";   // XBelt exit interface
   END_VAR

   VAR_IN_OUT 
      iq_UDT_ChuteExternalHandshake : "UDT_ConveyorHandshake";   // Chute handshake
   END_VAR

   VAR 
      s_UDT_Downstream_Sorter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "DownStream_Sorter_Basic";   // static Downstream Sorter status
      s_UDT_XBeltExitStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_XBeltExitStatus";   // static X-Belt exit status
      s_UDT_XBeltExitInterface { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_XbeltExitInterface";   // static X-Belt exit interface
      sa_ExchangeObjectID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..1] of DInt;   // static exchange object ID
   END_VAR

   VAR CONSTANT 
      c_MaximumLength : DInt := 5000;   // Maximum lenght
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------    
	   
	Version history:
	Date        | Version   | Author                    | Remark
	----------------------------------------------------------------------------------------
	 30/03/2023 | 0.1       | R.Golonka                 | First release TIA 17.0 | DHL Munich 
	 18/08/2023 | 2.0       | Stefanos Theocharis       | align with Parma UDT 
	 06/09/2023 | 2.1       | M.Diebel                  | Reset energy save when NewObjectID is created
	 13/03/2024 | 2.2      | S. Nieswiec                | Added to new baseline
	 
	 *)
	
	REGION 1 - Chute status move
	    
	    #s_UDT_Downstream_Sorter.Full := #i_UDT_Outfeed2StatesStatus.Specific.ChuteFull;// Downstream sorter status full update
	    
	    #s_UDT_Downstream_Sorter.HalfFull := #i_UDT_Outfeed2StatesStatus.Specific.ChuteHalfFull;   // Downstream sorter status half-full update
	    
	END_REGION
	
	REGION 2 - Send ready to recevie to crossbelt
	    
	    // Set ready to recevie to Xbelt (when Chute is RTR then XBelt can discharge)
	    #s_UDT_Downstream_Sorter.ReadyToReceive := #iq_UDT_ChuteExternalHandshake.RTR AND (#i_UDT_AssociatedConveyorInterface.VFDatSpeed OR NOT #ix_ConfigHorizontalOutfeed);
	    
	END_REGION
	
	REGION 3 - Downstream Sorter 
	    
	    // Downstream sorter functionality when horizontal outfeed mode is active 
	    IF #ix_ConfigHorizontalOutfeed THEN
	        #s_UDT_Downstream_Sorter.Running := #i_UDT_AssociatedConveyorInterface.RunFwd AND NOT #i_UDT_AssociatedConveyorInterface.ManualModeActive;
	        
	    ELSE
	        #s_UDT_Downstream_Sorter.Running := #iq_UDT_ChuteExternalHandshake.RTR; // Downstream sorter functionality when spiral mode is active 
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Package update
	    
	    // Move the current ID to position 0 
	    #sa_ExchangeObjectID[0] := #i_UDT_Sorter_Downstream.DischargedObjectID;
	    
	    // When the ID is different with previous ID do:
	    IF #sa_ExchangeObjectID[0] <> #sa_ExchangeObjectID[1] THEN
	        // Update new object
	        #s_UDT_XBeltExitInterface.NewObjectID := TRUE;
	        // Update obejct ID
	        #s_UDT_XBeltExitInterface.ObjectID := #i_UDT_Sorter_Downstream.DischargedObjectID;
	        // Update product lenght 
	        #s_UDT_XBeltExitInterface.ProductLength := DINT_TO_INT(#i_UDT_Sorter_Downstream.DischargedPackageLength MOD #c_MaximumLength);
	        // Setting actual value to previous one 
	        #sa_ExchangeObjectID[1] := #sa_ExchangeObjectID[0];
	    ELSE
	        #s_UDT_XBeltExitInterface.NewObjectID := FALSE;
	    END_IF;
	    
	    #iq_UDT_ChuteExternalHandshake.RTS := #s_UDT_XBeltExitInterface.NewObjectID;    // Conveyor ready to send if parcel diverted 
	    #iq_UDT_ChuteExternalHandshake.ResetEnergySave := #s_UDT_XBeltExitInterface.NewObjectID;
	END_REGION
	
	REGION 5 - Output update
	    
	    #q_UDT_Downstream_Sorter := #s_UDT_Downstream_Sorter;    // Move UDT Downstream Sorter to output
	    
	    #q_UDT_XBeltExitInterface := #s_UDT_XBeltExitInterface;    // Move Xbelt Exit interface
	    
	END_REGION
	
	REGION 6 - Status
	    
	    #s_UDT_XBeltExitStatus.ChuteDisabled := #i_UDT_Sorter_Downstream.Basic.ChuteDisabled;   // Status HMI upadate chute disabled
	    
	    #s_UDT_XBeltExitStatus.ChuteJam := #i_UDT_Sorter_Downstream.Basic.ChuteJam;   // Status HMI upadate chute jammed
	    
	    #s_UDT_XBeltExitStatus.ChuteSensorIncongruence := #i_UDT_Sorter_Downstream.Basic.ChuteSensorIncongruence;    // Status HMI update chute sensor incongrunce
	    
	    #q_UDT_XBeltExitStatus := #s_UDT_XBeltExitStatus;  // Move status static to output 
	    
	END_REGION
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_VFD_MultiControl_Universal_Full"
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'KBA-PM'
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 106
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_VFDConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VFD_MultiControl_Configuration";   //   VFD configuration structure
      i_UDT_VFDInputs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VFD_MultiControl_Universal_Full";   //   VFD inputs structure
      ii_MotorNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Motor number that is connected to the Multicontrol module [1,2,3 or 4]
      ix_PowerOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when External Power OK
      ix_SafetyOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when Safety OK
      ix_SimulationModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when Simulation mode active
   END_VAR

   VAR_OUTPUT 
      q_UDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdStatus";   //   HMI status structure
      qsi_UDT_VFDSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : SInt;   //   VFD speed setpoint
   END_VAR

   VAR_IN_OUT 
      iq_UDT_ConveyorInterface : "UDT_ConveyorInterface";   //   Conveyor interface structure
      iq_UDT_VFDStatistics : "UDT_VfdStatistics";   //   Statistics structure
   END_VAR

   VAR 
      s_FB_TimerOnOffDelayCheckSupply { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //  "TimerOnOffDelay" - to delay time for VFD supply contactor
      s_FB_TimerOnOffDelay_ProfinetNotOnlineMasking { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //   "TimerOnOffDelay" - to delay time for profinet not online masking
      s_FB_TimerOnOffDelay_ProfinetSlaveErrorMasking { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //   "TimerOnOffDelay" - to delay time for profinet error masking
      s_FB_TimerOnOffDelay_Instance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //   "TimerOnOffDelay" - to delay time for Instance
      s_FB_TimerOnOffDelay_SafetyOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //   "TimerOnOffDelay" - to delay time for safety
      s_FB_TimerOnOffDelay_RunCommand { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //   "TimerOnOffDelay" - to delay time for run command motor
      s_R_TRIG_RunForward {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge of Run forward signal
      s_R_TRIG_RunReverse {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge of Run reverse
      s_R_TRIG_PNSlaveNotOnline {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge for trigger Profinet slave not online statistics
      s_R_TRIG_PNSlaveError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge for trigger Profinet slave error statistics
      s_R_TRIG_InternalError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge for trigger Internal VFD Error statistics
      s_R_TRIG_Running {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge for starting of the running signal
      s_R_TRIG_Instance {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Raising edge for Instance
      s_R_TRIG_NewPNSlaveError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   New profinet slave error trigger
      s_R_TRIG_NewPNSlaveNotOnline {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   New profinet slave not online trigger
      s_UDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatus";   //   HMI status structure
      s_UDT_PNDevice { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PNDevice";   //   PN device info structure
      ss_VFDGeoStruct {InstructionName := 'GEOADDR'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : GEOADDR;   //   Geo structure indicate to telegram
      ss_RDREC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //   Read error code record structure
         Valid { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      Read operation is done
         Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      Read operation is in progress
         Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      Read operation has an error
         Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DWord;   //      Read operation status
         Lenght { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   //      Lenght of the read record
      END_STRUCT;
      ss_WRREC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //   Write record structure
         Acceleration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //      Acceleration
            REQ { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      Requirement
            Index { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //      Index
            Done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      Operation is done
            Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      Write operation is in progress
            Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      Write operation has an error
            Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DWord;   //      Write operation status
            Data { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   //      Data to write
         END_STRUCT;
         Deceleration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //      Deceleration
            REQ { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      Requirement
            Index { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //      Index
            Done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      Operation is done
            Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      Write operation is in progress
            Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      Write operation has an error
            Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DWord;   //      Write operation status
            Data { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   //      Data to write
         END_STRUCT;
      END_STRUCT;
      s_RDREC_ErrorCode {InstructionName := 'RDREC'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : RDREC;   //   Read error code record instruction
      s_WRREC_ACC {InstructionName := 'WRREC'; LibVersion := '1.1'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : WRREC;   //   Write acceleration record inctruction
      s_WRREC_DEC {InstructionName := 'WRREC'; LibVersion := '1.1'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : WRREC;   //   Write deceleration record instruction
      shw_VFD_Telegram { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   //   Free telegram's HW_ID
      sr_MaximumSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   //   Maximum speed [mm/s]
      sr_SpeedsetpointCorrected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   //  Speedsetpoint corrected with factor
      sw_ErrorCode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   //   VFD error code
      si_RequiredSpeedSetpoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Required speed setpoint
      si_AccelerationSetpoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Acceleration setpoint value
      si_DecelerationSetpoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Deceleration setpoint value
      si_AccelerationOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Old acceleration value
      si_DecelerationOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Old deceleration value
      si_ActualSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Actual speed in [mm/s]
      si_Log2GeoReturn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Log2Geo function return
      si_Geo2LogReturn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Geo2Log function return
      sx_PNSlaveErrorCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Profinet slave error counter
      sx_PNSlaveNotOnlineCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Profinet slave not online counter
      ssi_MotorSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : SInt;   //   Motor speed value
      sx_ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Commissioning: configuration error
      sx_PNDeviceHealthy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Profinet device is online and error free
      sx_PowerOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Communication, safety and power are available
      sx_VFD_Available { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Hardware of VFD is ok
      sx_ErrorActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Block has an error
      sx_InvalidMotorNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Invalid motor error
      sx_MotorError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Motor error
      sx_EnableOperation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Enable operation signal
      sx_RunVFDForward { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Start VFD forward
      sx_RunVFDReverse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Start VFD backward
      sx_AccelerationDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Acceleration is written
      sx_DecelerationDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Deceleration is written
      sx_SpeedSetpointReached { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Motor is running at requested speed
      sx_ErrorDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Error code is read
      sx_SafetyOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Safety ok
      sx_MaskingReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Masking reset
      sx_PNSlaveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Profinet slave error
      sx_PNSlaveNotOnline { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Profinet slave not online
      s_R_TRIG_PNSlaveNotOnline_Acyclic {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
   END_VAR

   VAR CONSTANT 
      ci_VFDArea : UInt := 1;   //   Area ID of IO Profinet devices
      ci_SubmoduleHWType : UInt := 5;   //   Submodule HW_type number
      ci_TelegramSlot : UInt := 2;   //   Free Siemens telegram slot
      ci_TelegramSubslot : UInt := 1;   //   Free Siemens telegram subslot
      cdi_ErrorCodeIndex : DInt := 17154;   //   Error code index
      cdi_AccelerationIndex : DInt := 18200;   //   Acceleration index
      cdi_DecelerationIndex : DInt := 18204;   //   Deceleration index
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------      
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	08/11/2019  | 3.0       | A. Nowak      | Initial version
	18/03/2020  | 3.1       | K.Pokorski    | Adapting reviews
	10/06/2021  | 3.2       | L.Klar        | Region 9.1 - #ssi_MotorSpeed = 0 condition commented
	17/11/2021  | 3.3       | P.Gryszczyk   | Region 2 - RunCommand timer changed conditions 
	18/02/2021  | 3.4       | P.Gryszczyk   | Region 4 - PNNotOnline and PNSlaveError masking, sending reset to system
	24/05/2023  | 3.5       | S.Nikodem     | Update to DHL Munich specification
	04/07/2023  | 3.7       | P.Gryszczyk   | Changed the PNSlaveNotOnline to R_TRIG for the acyclic writing logic
	13/03/2024  | 4.1       | S. Nieswiec   | Added to new baseline
	*)
	
	REGION 1 - Get Device Profinet number
	    
	    // Getting information about Profinet Device.
	    "FC_GetDevicePN"(is_PNDeviceName := #i_UDT_VFDConfiguration.VFDPNDeviceName,
	                     ix_SimulationModeActive := #ix_SimulationModeActive,
	                     iqUDT_PND := #s_UDT_PNDevice);
	    
	END_REGION
	
	REGION 2 - Motor number validation
	    
	    // Check the motor number and copy the it's error status and speed.
	    CASE (#ii_MotorNumber)
	    OF
	        1:
	            // Delay
	            #s_FB_TimerOnOffDelay_RunCommand(iudi_OnDelayTime := 1500,
	                                             ix_SignalToDelay :=
	                                             (#sx_RunVFDForward
	                                             OR #sx_RunVFDReverse)
	                                             AND #i_UDT_VFDInputs.CurrentMotor1 < #i_UDT_VFDConfiguration.MinimumCurrentWhenRunninng);
	            
	            #ssi_MotorSpeed := #i_UDT_VFDInputs.SpeedMotor1;
	            
	            IF (#s_FB_TimerOnOffDelay_RunCommand.qx_DelayedSignal AND #sx_EnableOperation) OR #i_UDT_VFDInputs.ErrorMotor1
	            THEN
	                
	                #sx_MotorError := TRUE;
	                
	            END_IF;
	        2:
	            #s_FB_TimerOnOffDelay_RunCommand(iudi_OnDelayTime := 1500,
	                                             ix_SignalToDelay :=
	                                             (#sx_RunVFDForward
	                                             OR #sx_RunVFDReverse)
	                                             AND #i_UDT_VFDInputs.CurrentMotor2 < #i_UDT_VFDConfiguration.MinimumCurrentWhenRunninng);
	            
	            #ssi_MotorSpeed := #i_UDT_VFDInputs.SpeedMotor2;
	            
	            IF (#s_FB_TimerOnOffDelay_RunCommand.qx_DelayedSignal AND #sx_EnableOperation) OR #i_UDT_VFDInputs.ErrorMotor2
	                
	            THEN
	                
	                #sx_MotorError := TRUE;
	                
	            END_IF;
	        3:
	            #s_FB_TimerOnOffDelay_RunCommand(iudi_OnDelayTime := 1500,
	                                             ix_SignalToDelay :=
	                                             (#sx_RunVFDForward
	                                             OR #sx_RunVFDReverse)
	                                             AND #i_UDT_VFDInputs.CurrentMotor3 < #i_UDT_VFDConfiguration.MinimumCurrentWhenRunninng);
	            
	            #ssi_MotorSpeed := #i_UDT_VFDInputs.SpeedMotor3;
	            
	            IF (#s_FB_TimerOnOffDelay_RunCommand.qx_DelayedSignal AND #sx_EnableOperation) OR #i_UDT_VFDInputs.ErrorMotor3
	            THEN
	                
	                #sx_MotorError := TRUE;
	                
	            END_IF;
	        4:
	            #s_FB_TimerOnOffDelay_RunCommand(iudi_OnDelayTime := 1500,
	                                             ix_SignalToDelay :=
	                                             (#sx_RunVFDForward
	                                             OR #sx_RunVFDReverse)
	                                             AND #i_UDT_VFDInputs.CurrentMotor4 < #i_UDT_VFDConfiguration.MinimumCurrentWhenRunninng);
	            
	            #ssi_MotorSpeed := #i_UDT_VFDInputs.SpeedMotor4;
	            
	            IF (#s_FB_TimerOnOffDelay_RunCommand.qx_DelayedSignal AND #sx_EnableOperation) OR #i_UDT_VFDInputs.ErrorMotor4
	            THEN
	                
	                #sx_MotorError := TRUE;
	                
	            END_IF;
	            
	        ELSE
	            #sx_InvalidMotorNumber := TRUE;
	    END_CASE;
	    
	END_REGION
	
	REGION 3 - Reset errors
	    
	    // Reset the errors on the command from the conveyor interface.
	    // 
	    #s_R_TRIG_Instance(CLK := #ix_SafetyOK,
	                       Q => #sx_SafetyOK);
	    
	    #s_FB_TimerOnOffDelay_Instance(iudi_OffDelayTime := 10000,
	                                   ix_SignalToDelay := #sx_SafetyOK,
	                                   qx_DelayedSignal => #sx_MaskingReset);
	    
	    
	    IF #iq_UDT_ConveyorInterface.InternalErrorReset THEN
	        #s_UDT_HMIStatus.PNSlaveNotonline := FALSE;
	        #s_UDT_HMIStatus.PNSlaveError := FALSE;
	        #s_UDT_HMIStatus.InternalError := FALSE;
	        #sx_InvalidMotorNumber := FALSE;
	        #sx_MotorError := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Hardware check
	    
	    // Hardware will be available only after the delay, so the device has time for the initialization.
	    #s_FB_TimerOnOffDelayCheckSupply(iudi_OnDelayTime := 2000,
	                                     ix_SignalToDelay := #ix_PowerOK,
	                                     qx_DelayedSignal => #sx_PowerOk);
	    
	    #s_FB_TimerOnOffDelay_ProfinetNotOnlineMasking(iudi_OnDelayTime := #i_UDT_VFDConfiguration.TimePNErrorMasking,
	                                                   iudi_OffDelayTime := 0,
	                                                   ix_SignalToDelay := #sx_PNSlaveNotOnline,
	                                                   qx_DelayedSignal => #s_UDT_HMIStatus.PNSlaveNotonline);
	    
	    #s_FB_TimerOnOffDelay_ProfinetSlaveErrorMasking(iudi_OnDelayTime := #i_UDT_VFDConfiguration.TimePNErrorMasking,
	                                                    iudi_OffDelayTime := 0,
	                                                    ix_SignalToDelay := #sx_PNSlaveError,
	                                                    qx_DelayedSignal => #s_UDT_HMIStatus.PNSlaveError);
	    
	    #s_R_TRIG_NewPNSlaveNotOnline(CLK := #sx_PNSlaveNotOnline);
	    #s_R_TRIG_NewPNSlaveError(CLK := #sx_PNSlaveError);
	    // Check if PN device is online.
	    IF NOT "DB_ProfinetDiagnostic".ProfinetNetworks[#s_UDT_PNDevice.PNNetworknumber].DeviceStatus[#s_UDT_PNDevice.PNDeviceNumber].DeviceState.Exist
	        AND NOT #ix_SimulationModeActive
	        AND #sx_PowerOk
	    THEN
	        #sx_PNSlaveNotOnline := TRUE;
	    ELSE
	        #sx_PNSlaveNotOnline := FALSE;
	    END_IF;
	    
	    IF #s_R_TRIG_NewPNSlaveNotOnline.Q THEN
	        #sx_PNSlaveNotOnlineCount += 1;
	    END_IF;
	    
	    // Check if PN device has an error.
	    IF "DB_ProfinetDiagnostic".ProfinetNetworks[#s_UDT_PNDevice.PNNetworknumber].DeviceStatus[#s_UDT_PNDevice.PNDeviceNumber].DeviceState.Error
	        AND NOT #ix_SimulationModeActive
	        AND #sx_PowerOk
	    THEN
	        #sx_PNSlaveError := TRUE;
	    ELSE
	        #sx_PNSlaveError := FALSE;
	    END_IF;
	    
	    IF #s_R_TRIG_NewPNSlaveError.Q THEN
	        #sx_PNSlaveErrorCount += 1;
	    END_IF;
	    
	    // Set bit when PN device is healthy (online and no error).
	    #sx_PNDeviceHealthy :=
	    NOT #s_UDT_HMIStatus.PNSlaveNotonline
	    AND NOT #s_UDT_HMIStatus.PNSlaveError
	    AND #s_UDT_PNDevice.PNDeviceFound
	    AND #sx_PowerOk;
	    
	    // Set VFD available bit when all conditions are met.
	    #sx_VFD_Available :=
	    (NOT #sx_MotorError
	    AND #sx_PowerOk
	    AND #sx_PNDeviceHealthy)
	    OR #ix_SimulationModeActive;
	    
	END_REGION
	
	REGION 5 - Extract telegram's HW_ID
	    
	    // Extract telegram's HW_ID 
	    #si_Log2GeoReturn := LOG2GEO(LADDR := "DB_ProfinetDiagnostic".ProfinetNetworks[#s_UDT_PNDevice.PNNetworknumber].DeviceStatus[#s_UDT_PNDevice.PNDeviceNumber].DeviceState.HW_ID, GEOADDR := #ss_VFDGeoStruct);
	    #ss_VFDGeoStruct.AREA := #ci_VFDArea;
	    #ss_VFDGeoStruct.HWTYPE := #ci_SubmoduleHWType;
	    #ss_VFDGeoStruct.STATION := INT_TO_UINT(#s_UDT_PNDevice.PNDeviceNumber);
	    #ss_VFDGeoStruct.SLOT := #ci_TelegramSlot;
	    #ss_VFDGeoStruct.SUBSLOT := #ci_TelegramSubslot;
	    
	    #si_Geo2LogReturn := GEO2LOG(GEOADDR := #ss_VFDGeoStruct, LADDR => #shw_VFD_Telegram);
	    
	END_REGION
	
	REGION 6 - Check errors 
	    
	    #s_FB_TimerOnOffDelay_SafetyOK(iudi_OnDelayTime := 10000,
	                                   ix_SignalToDelay := #ix_SafetyOK);
	    
	    // Check if the motor has an error.
	    IF #s_FB_TimerOnOffDelay_SafetyOK.qx_DelayedSignal  //#ix_SafetyOK
	    THEN
	        #s_UDT_HMIStatus.InternalError := #sx_MotorError;
	        
	    END_IF;
	    // Create trigger on error.
	    #s_R_TRIG_InternalError(CLK := #s_UDT_HMIStatus.InternalError);
	    
	    // If the internal error occured, reset the error code read done signal.
	    IF #s_R_TRIG_InternalError.Q
	    THEN
	        #sx_ErrorDone := FALSE;
	    END_IF;
	    
	    // If there is an internal error, read the error code from the Interroll VFD. Otherwise, reset it.
	    IF NOT #s_UDT_HMIStatus.InternalError
	    THEN
	        #s_UDT_HMIStatus.ErrorCode := 0;
	    ELSE
	        // Read the error code from the multicontrol.
	        #s_RDREC_ErrorCode(REQ := ((NOT #sx_ErrorDone OR "mx_FirstScan") AND NOT #s_UDT_HMIStatus.PNSlaveNotonline),
	                           ID := #shw_VFD_Telegram,
	                           INDEX := #cdi_ErrorCodeIndex,
	                           MLEN := 0,
	                           VALID => #ss_RDREC.Valid,
	                           BUSY => #ss_RDREC.Busy,
	                           ERROR => #ss_RDREC.Error,
	                           STATUS => #ss_RDREC.Status,
	                           LEN => #ss_RDREC.Lenght,
	                           RECORD := #sw_ErrorCode);
	        
	        // IF error code is read, set the error code read signal and write it to the structure.
	        IF #s_RDREC_ErrorCode.VALID
	        THEN
	            #sx_ErrorDone := TRUE;
	            #s_UDT_HMIStatus.ErrorCode := WORD_TO_INT(SWAP_WORD(IN := #sw_ErrorCode));
	        END_IF;
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Check if configuration is ok for commissioning purposes
	    
	    // Validate the VFD configuration and motor number.
	    IF #i_UDT_VFDConfiguration.MaximumSpeed > 0.0
	        AND #i_UDT_VFDConfiguration.VFDRampUpTime > 0
	        AND #i_UDT_VFDConfiguration.VFDRampDownTime > 0
	        AND NOT #sx_InvalidMotorNumber
	    THEN
	        #sx_ConfigurationError := FALSE;
	    ELSE
	        #sx_ConfigurationError := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 8 - Handle speed
	    
	    // Write max speed to static.
	    #sr_MaximumSpeed := #i_UDT_VFDConfiguration.MaximumSpeed;
	    
	    // Use correction factor to calculate setpint for diaginal use
	    #sr_SpeedsetpointCorrected := INT_TO_REAL(#iq_UDT_ConveyorInterface.SpeedSetpoint) * #i_UDT_VFDConfiguration.CorrectionFactor;
	    
	    // Actual speed setpoint
	    #si_RequiredSpeedSetpoint := REAL_TO_INT((#sr_SpeedsetpointCorrected * 100.0) / (#sr_MaximumSpeed));
	    
	    // Speed setpoint saturation in case when the speed setpoint is higher than the max speed.
	    IF #si_RequiredSpeedSetpoint > 100
	    THEN
	        #si_RequiredSpeedSetpoint := 100;
	        #iq_UDT_ConveyorInterface.ConfigurationError := TRUE;
	    ELSIF #si_RequiredSpeedSetpoint < -100
	    THEN
	        #si_RequiredSpeedSetpoint := -100;
	        #iq_UDT_ConveyorInterface.ConfigurationError := TRUE;
	    END_IF;
	END_REGION
	
	REGION 9 - Prepare output data VFD
	    
	    REGION 9.1 - Set speed setpoint in forward and reverse direction 
	        // Get rising edge of Run forward and reverse signal.
	        #s_R_TRIG_RunForward(CLK := #iq_UDT_ConveyorInterface.RunFwd);
	        #s_R_TRIG_RunReverse(CLK := #iq_UDT_ConveyorInterface.RunRvs);
	        
	        // When rising edge of the forward or reverse signal is received, the drive has to stop to be able to make the switch.
	        IF #s_R_TRIG_RunForward.Q
	            OR #s_R_TRIG_RunReverse.Q
	        THEN
	            #qsi_UDT_VFDSpeed := 0;
	        END_IF;
	        
	        // If motor stopped and Run forward is requested and forward direction is interlock, set run forward signal and reset run reverse signal.
	        IF //#ssi_MotorSpeed = 0 and
	            #iq_UDT_ConveyorInterface.RunFwd
	            AND #i_UDT_VFDConfiguration.InterlockFwd
	        THEN
	            #sx_RunVFDForward := TRUE;
	            #sx_RunVFDReverse := FALSE;
	        END_IF;
	        
	        // If motor stopped and Run reverse is requested and reverse direction is interlock, set run reverse signal and reset run forward signal.
	        IF // #ssi_MotorSpeed = 0 AND
	            #iq_UDT_ConveyorInterface.RunRvs
	            AND #i_UDT_VFDConfiguration.InterlockRvs
	        THEN
	            #sx_RunVFDReverse := TRUE;
	            #sx_RunVFDForward := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 9.2 - Stopping
	        
	        // Stop the VFD if one of the following conditions is met.
	        IF (NOT #iq_UDT_ConveyorInterface.RunRvs AND NOT #iq_UDT_ConveyorInterface.RunFwd)
	            OR (#iq_UDT_ConveyorInterface.RunRvs AND #iq_UDT_ConveyorInterface.RunFwd)
	            OR (#sx_RunVFDReverse AND NOT #i_UDT_VFDConfiguration.InterlockRvs)
	            OR (#sx_RunVFDForward AND NOT #i_UDT_VFDConfiguration.InterlockFwd)
	            OR ((#s_R_TRIG_RunForward.Q AND #ssi_MotorSpeed < 0)
	            OR (#s_R_TRIG_RunReverse.Q AND #ssi_MotorSpeed > 0))
	        THEN
	            #sx_RunVFDReverse := FALSE;
	            #sx_RunVFDForward := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 9.3 - Check for enable operation signal
	        
	        // Operation is enable when VFD is available and there is one of the run commands.
	        #sx_EnableOperation :=
	        #sx_VFD_Available
	        AND (#sx_RunVFDForward OR #sx_RunVFDReverse)
	        AND NOT #sx_ConfigurationError;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 10 - Write outputs to VFD  
	    
	    REGION 10.1 - Write speed setpoint to drive
	        
	        // The conveyor stopped and may now run in forward direction.
	        IF ((#sx_RunVFDForward AND NOT #i_UDT_VFDConfiguration.DirectionReversal)
	            OR (#sx_RunVFDReverse AND #i_UDT_VFDConfiguration.DirectionReversal))
	            AND #sx_EnableOperation
	        THEN
	            #qsi_UDT_VFDSpeed := INT_TO_SINT(#si_RequiredSpeedSetpoint);
	        END_IF;
	        
	        // The conveyor stopped and may now run in reverse direction.
	        IF ((#sx_RunVFDReverse AND NOT #i_UDT_VFDConfiguration.DirectionReversal)
	            OR (#sx_RunVFDForward AND #i_UDT_VFDConfiguration.DirectionReversal))
	            AND #sx_EnableOperation
	        THEN
	            #qsi_UDT_VFDSpeed := - INT_TO_SINT(#si_RequiredSpeedSetpoint);
	        END_IF;
	        
	        // Clear speed setpoint when run isn't request.
	        IF (NOT #sx_RunVFDForward
	            AND NOT #sx_RunVFDReverse)
	            OR NOT #sx_EnableOperation
	        THEN
	            #qsi_UDT_VFDSpeed := 0;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 10.2 - Calculate acceleration and deceleration values
	        
	        // Recalculating Acceleration ramp - deviding maximum configured speed by Ramp up time and devide it by 1000.
	        #si_AccelerationSetpoint := REAL_TO_INT(#sr_MaximumSpeed / (UDINT_TO_REAL(#i_UDT_VFDConfiguration.VFDRampUpTime) / 1000.0));
	        
	        // Recalculating Deceleration ramp - deviding maximum configured speed by Ramp down time and devide it by 1000.
	        #si_DecelerationSetpoint := REAL_TO_INT(#sr_MaximumSpeed / (UDINT_TO_REAL(#i_UDT_VFDConfiguration.VFDRampDownTime) / 1000.0));
	        
	    END_REGION
	    
	    REGION 10.3 - Write acceleration to drive
	        
	        #s_R_TRIG_PNSlaveNotOnline_Acyclic(CLK := NOT #s_UDT_HMIStatus.PNSlaveNotonline);
	        
	        // Acceleration write operation is done.
	        IF #sx_AccelerationDone
	        THEN
	            // There is new acceleration value or device is offline.
	            IF #si_AccelerationSetpoint <> #si_AccelerationOld
	                OR #s_R_TRIG_PNSlaveNotOnline_Acyclic.Q
	            THEN
	                // Reset the accleration operation done signal.
	                #sx_AccelerationDone := FALSE;
	            END_IF;
	        END_IF;
	        
	        // The acceleration operation isn't done or there is first scan and device is online.
	        IF (NOT #sx_AccelerationDone OR "mx_FirstScan")
	            AND NOT #s_UDT_HMIStatus.PNSlaveNotonline
	        THEN
	            // There isn't an invalid motor number error and acceleration isn't equal to 0.
	            IF NOT #sx_InvalidMotorNumber
	                AND #si_AccelerationSetpoint > 0
	            THEN
	                // Calculate the index of the acceleration.
	                #ss_WRREC.Acceleration.Index := #cdi_AccelerationIndex + #ii_MotorNumber;
	                // Prepare the data.
	                #ss_WRREC.Acceleration.Data := SWAP(INT_TO_WORD(#si_AccelerationSetpoint));
	                // Set operation is required.
	                #ss_WRREC.Acceleration.REQ := TRUE;
	                
	                // Send acceleration to the device.
	                #s_WRREC_ACC(REQ := #ss_WRREC.Acceleration.REQ,
	                             ID := #shw_VFD_Telegram,
	                             INDEX := #ss_WRREC.Acceleration.Index,
	                             LEN := 0,
	                             DONE => #ss_WRREC.Acceleration.Done,
	                             BUSY => #ss_WRREC.Acceleration.Busy,
	                             ERROR => #ss_WRREC.Acceleration.Error,
	                             STATUS => #ss_WRREC.Acceleration.Status,
	                             RECORD := #ss_WRREC.Acceleration.Data);
	                
	                // Send operation is done.
	                IF #ss_WRREC.Acceleration.Done
	                THEN
	                    // Reset operation is required bit.
	                    #ss_WRREC.Acceleration.REQ := FALSE;
	                    // Set the operation is done signal.
	                    #sx_AccelerationDone := TRUE;
	                    // Write acceleration value into the old one.
	                    #si_AccelerationOld := #si_AccelerationSetpoint;
	                END_IF;
	            END_IF;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 10.4 - Write deceleration to drive
	        
	        // Deceleration write operation is done.
	        IF #sx_DecelerationDone
	        THEN
	            // There is new deceleration value or device is offline.
	            IF #si_DecelerationSetpoint <> #si_DecelerationOld
	                OR #s_R_TRIG_PNSlaveNotOnline_Acyclic.Q
	            THEN
	                // Reset the deceleration operation done signal.
	                #sx_DecelerationDone := FALSE;
	            END_IF;
	        END_IF;
	        
	        // The deceleration operation isn't done or there is first scan and device is online.
	        IF (NOT #sx_DecelerationDone OR "mx_FirstScan")
	            AND NOT #s_UDT_HMIStatus.PNSlaveNotonline
	        THEN
	            // There isn't an invalid motor number error and deceleration isn't equal to 0.
	            IF NOT #sx_InvalidMotorNumber
	                AND #si_DecelerationSetpoint > 0
	            THEN
	                // Calculate the index of the deceleration.
	                #ss_WRREC.Deceleration.Index := #cdi_DecelerationIndex + #ii_MotorNumber;
	                // Prepare the data.
	                #ss_WRREC.Deceleration.Data := SWAP(INT_TO_WORD(#si_DecelerationSetpoint));
	                // Set operation is required.
	                #ss_WRREC.Deceleration.REQ := TRUE;
	                
	                // Send deceleration to the device.
	                #s_WRREC_DEC(REQ := #ss_WRREC.Deceleration.REQ,
	                             ID := #shw_VFD_Telegram,
	                             INDEX := #ss_WRREC.Deceleration.Index,
	                             LEN := 0,
	                             DONE => #ss_WRREC.Deceleration.Done,
	                             BUSY => #ss_WRREC.Deceleration.Busy,
	                             ERROR => #ss_WRREC.Deceleration.Error,
	                             STATUS => #ss_WRREC.Deceleration.Status,
	                             RECORD := #ss_WRREC.Deceleration.Data);
	                
	                // Send operation is done.
	                IF #ss_WRREC.Deceleration.Done
	                THEN
	                    // Reset operation is required bit.
	                    #ss_WRREC.Deceleration.REQ := FALSE;
	                    // Set the operation is done signal.
	                    #sx_DecelerationDone := TRUE;
	                    // Write deceleration value into the old one.
	                    #si_DecelerationOld := #si_DecelerationSetpoint;
	                END_IF;
	            END_IF;
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 11 - Copy signals to interface DB and to status output UDT
	    
	    // Create collective error.
	    #sx_ErrorActive :=
	    #s_UDT_HMIStatus.PNSlaveNotonline
	    OR #s_UDT_HMIStatus.PNSlaveError
	    OR #s_UDT_HMIStatus.InternalError
	    OR #sx_ConfigurationError;
	    
	    // Motor is giving direct signal on start, move setpoint to actual speed.                                                                                    
	    IF #ssi_MotorSpeed <> 0
	    THEN
	        #si_ActualSpeed := #iq_UDT_ConveyorInterface.SpeedSetpoint;
	        #sx_SpeedSetpointReached := TRUE;
	    ELSE
	        #si_ActualSpeed := 0;
	        #sx_SpeedSetpointReached := FALSE;
	    END_IF;
	    
	    // Write interface bits.
	    #iq_UDT_ConveyorInterface.VFDRunning :=
	    #sx_VFD_Available
	    AND #iq_UDT_ConveyorInterface.ActualSpeed <> 0;
	    
	    // Speed setpoint is reached.
	    #iq_UDT_ConveyorInterface.VFDatSpeed :=
	    #sx_SpeedSetpointReached
	    AND #sx_VFD_Available;
	    
	    // Set the internal VFD error bit if any fault is active.
	    #iq_UDT_ConveyorInterface.InternalErrorVFD := #sx_ErrorActive;
	    // Copy the speed value to the output.
	    #iq_UDT_ConveyorInterface.ActualSpeed := #si_ActualSpeed;
	    
	    // Copy error status to output.
	    #q_UDT_HMIStatus := #s_UDT_HMIStatus;
	    
	END_REGION
	
	REGION 12 - Statistics
	    
	    // Create trigger on error and create statistics for profinet slave not online.
	    #s_R_TRIG_PNSlaveNotOnline(CLK := #s_UDT_HMIStatus.PNSlaveNotonline);
	    
	    IF #iq_UDT_ConveyorInterface.ResetStatistics
	        OR #s_UDT_HMIStatus.PNSlaveNotonline
	    THEN
	        "FC_Statistics"(ix_Reset := #iq_UDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #s_UDT_HMIStatus.PNSlaveNotonline,
	                        ix_RTrigActivate := #s_R_TRIG_PNSlaveNotOnline.Q,
	                        iqUDT_Statistics := #iq_UDT_VFDStatistics.PNSlaveNotOnline);
	    END_IF;
	    
	    // Create trigger on error and create statistics for profinet slave error.
	    #s_R_TRIG_PNSlaveError(CLK := #s_UDT_HMIStatus.PNSlaveError);
	    
	    IF #iq_UDT_ConveyorInterface.ResetStatistics
	        OR #s_UDT_HMIStatus.PNSlaveError
	    THEN
	        "FC_Statistics"(ix_Reset := #iq_UDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #s_UDT_HMIStatus.PNSlaveError,
	                        ix_RTrigActivate := #s_R_TRIG_PNSlaveError.Q,
	                        iqUDT_Statistics := #iq_UDT_VFDStatistics.PNSlaveError);
	    END_IF;
	    
	    IF #iq_UDT_ConveyorInterface.ResetStatistics
	        OR #s_UDT_HMIStatus.InternalError
	    THEN
	        "FC_Statistics"(ix_Reset := #iq_UDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #s_UDT_HMIStatus.InternalError,
	                        ix_RTrigActivate := #s_R_TRIG_InternalError.Q,
	                        iqUDT_Statistics := #iq_UDT_VFDStatistics.VFDInternalError);
	    END_IF;
	    
	    // Create trigger on running signal and create statistics for running status.
	    #s_R_TRIG_Running(CLK := #iq_UDT_ConveyorInterface.VFDRunning);
	    
	    IF #iq_UDT_ConveyorInterface.ResetStatistics
	        OR #iq_UDT_ConveyorInterface.VFDRunning
	    THEN
	        "FC_Statistics"(ix_Reset := #iq_UDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #iq_UDT_ConveyorInterface.VFDRunning,
	                        ix_RTrigActivate := #s_R_TRIG_Running.Q,
	                        iqUDT_Statistics := #iq_UDT_VFDStatistics.Running);
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_Xray_SerialCommunication_Send"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 113
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_SerialCommunicationConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_SerialComConfiguration";   // Serial communication configuration
      is_ActualTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Actual date and time in String
      ix_EnableSend { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Enable send
   END_VAR

   VAR_OUTPUT 
      q_UDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_SerialCommunicationSendStatus";   // Status structure
   END_VAR

   VAR_IN_OUT 
      iq_UDT_XrayInterface : "UDT_XrayInterface";   // Xray interface structure
   END_VAR

   VAR 
      s_Send_P2P {InstructionName := 'Send_P2P'; LibVersion := '4.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Send_P2P;   // PtP send standard function
      s_UDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_SerialCommunicationSendStatus";   // Status structure
      ss_MessageBuffer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Message stucture
         PieceID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[40];   // Piece ID
         VID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[16];   // VID
         RoutingCode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[2];   // Routing Code
      END_STRUCT;
      ss_Counter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Counterts only for statistics
         SendMessage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Counter of send message requests
         MessageSent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Counter of correct sent messages
         WrongMessageLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Counter of a prepared messages with wrong length
         MessageNotSent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Counter of not sent messages
      END_STRUCT;
      ss_Message { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Prepared message
      si_OldGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Old GIN number
      si_GIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // GIN number
      sx_SendMessage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE - when message prepared correctly
   END_VAR

   VAR_TEMP 
      ti_MessageLength : Int;   // Message length
   END_VAR

   VAR CONSTANT 
      cs_SOT : String := 'ABC';   // Message constans - SOT
      cs_EOT : String := 'XYZ';   // Message constans - EOT
      cc_Underscore : Char := '_';   // Message constans - underscore
      cc_CR : Char := '$R';   // Message constans - EOT
      cc_LF : Char := '$L';   // Message constans - EOT
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	27/04/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/03/2024  | 1.1       | S. Nieswiec  | Added to new baseline
	*)
	
	REGION 1- Copy GIN
	    
	    IF #iq_UDT_XrayInterface.Communication.SendMessage.GIN <> #si_GIN THEN
	        
	        #si_GIN := #iq_UDT_XrayInterface.Communication.SendMessage.GIN;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Prepare message
	    
	    IF #iq_UDT_XrayInterface.Communication.SendMessage.SendTrigger
	        //AND (#si_GIN <> #si_OldGIN)             //Comment only for tests 
	        AND #ix_EnableSend
	    THEN
	        
	        //Reset Erorr
	        #s_UDT_Status.WrongMessageLength := False;
	        
	        //Reset send message command
	        #sx_SendMessage := False;
	        
	        //Check if previous message was sent
	        IF NOT "DB_GIN".GIN[#si_OldGIN].DHL.Xray.BagIDMessage.Sent THEN
	            
	            "DB_GIN".GIN[#si_OldGIN].DHL.Xray.BagIDMessage.NotSent := TRUE;
	            
	            //Only for statistics
	            #ss_Counter.MessageNotSent += 1;
	            
	        END_IF;
	        
	        REGION 2.1 - Copy Object ID
	            
	            //Piece ID
	            #ss_MessageBuffer.PieceID := "DB_GIN".GIN[#si_GIN].DHL.PieceID;
	            
	        END_REGION
	        
	        REGION 2.2 - VID
	            
	            //Copy VID
	            #ss_MessageBuffer.VID := "DB_GIN".GIN[#si_GIN].DHL.VID;
	            
	        END_REGION
	        
	        //Copy Routing Code
	        #ss_MessageBuffer.RoutingCode := "DB_GIN".GIN[#si_GIN].DHL.Xray.RoutingCode;
	        
	        //Fill up the space to have 2 digits
	        #ti_MessageLength := LEN(#ss_MessageBuffer.RoutingCode);
	        
	        IF #ti_MessageLength = 1 THEN
	            #ss_MessageBuffer.RoutingCode := CONCAT(IN1 := '0', IN2 := #ss_MessageBuffer.RoutingCode);
	        ELSIF #ti_MessageLength = 0 THEN
	            #ss_MessageBuffer.RoutingCode := CONCAT(IN1 := '00', IN2 := #ss_MessageBuffer.RoutingCode);
	        END_IF;
	        
	        //Copy data from message buffer structure to String 
	        //Reset variable
	        #ss_Message := '';
	        
	        #ss_Message := CONCAT(IN1 := #cs_SOT,                        //Add SOT [ABC]
	                              IN2 := #ss_MessageBuffer.PieceID,      //Add Piece ID
	                              IN3 := #cc_Underscore,                 //Add Underscore
	                              IN4 := #ss_MessageBuffer.VID,          //Add VID
	                              IN5 := #ss_MessageBuffer.RoutingCode,  //Add Routing Code
	                              IN6 := #cs_EOT,                        //Add EOT [XYZ]
	                              IN7 := #cc_CR,                         //Add EOT [CR]
	                              IN8 := #cc_LF);                        //Add EOT [LF]
	        
	        //Check message length
	        #ti_MessageLength := LEN(#ss_Message);
	        
	        IF #ti_MessageLength = #i_UDT_SerialCommunicationConfiguration.SendMessageLength THEN
	            
	            //Set varaible message is ready to send
	            #sx_SendMessage := True;
	            
	            //Save information message is prepared to send
	            "DB_GIN".GIN[#si_GIN].DHL.Xray.BagIDMessage.MessagePrepared := True;
	            
	            //Only for statistics
	            #ss_Counter.SendMessage += 1;
	            
	        ELSE
	            
	            //Set variable the message has wrong structure
	            #s_UDT_Status.WrongMessageLength := True;
	            
	            //Save information message has wrong stucture
	            "DB_GIN".GIN[#si_GIN].DHL.Xray.BagIDMessage.WrongMessageStructure := True;
	            
	            //Only for statisctics
	            #ss_Counter.WrongMessageLength += 1;
	            
	        END_IF;
	        
	        //Copy GIN
	        #si_OldGIN := #si_GIN;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Send message
	    
	    #s_Send_P2P(REQ := #sx_SendMessage
	                AND NOT #s_UDT_Status.WrongMessageLength,
	                "PORT" := #i_UDT_SerialCommunicationConfiguration."Port",
	                BUFFER := #ss_Message,
	                LENGTH := #i_UDT_SerialCommunicationConfiguration.SendMessageLength,
	                DONE => #s_UDT_Status.Done,
	                ERROR => #s_UDT_Status.Error,
	                STATUS => #s_UDT_Status.Status);
	    
	    IF #sx_SendMessage AND #s_UDT_Status.Done THEN
	        
	        //Reset varaible
	        #sx_SendMessage := False;
	        
	        //Set 
	        "DB_GIN".GIN[#si_GIN].DHL.Xray.BagIDMessage.Sent := True;
	        
	        //Set Time
	        "DB_GIN".GIN[#si_GIN].DHL.Xray.BagIDMessage.SentTime := #is_ActualTime;
	        
	        //Only for statistics
	        #ss_Counter.MessageSent += 1;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Status
	    
	    //Copy to output structure
	    #q_UDT_Status := #s_UDT_Status;
	    
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_VFD_MultiControl_IO_Mode"
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'KBA-PM'
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 105
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_VFDConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VFD_MultiControl_Configuration";   //   VFD configuration structure
      i_UDT_VFDInputs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VFD_MultiControl_IOMode";   //   VFD inputs structure
      ii_MotorNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Motor number that is connected to the Multicontrol module [1,2,3 or 4]
      ix_PowerOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when External Power OK
      ix_SafetyOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when Safety OK
      ix_SimulationModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   TRUE when Simulation mode active
   END_VAR

   VAR_OUTPUT 
      q_UDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_VfdStatus";   //   HMI status structure
      qsi_UDT_VFDSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : SInt;   //   VFD speed setpoint
   END_VAR

   VAR_IN_OUT 
      iq_UDT_ConveyorInterface : "UDT_ConveyorInterface";   //   Conveyor interface structure
      iq_UDT_VFDStatistics : "UDT_VfdStatistics";   //   Statistics structure
   END_VAR

   VAR 
      s_FB_TimerOnOffDelayCheckSupply { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //  "TimerOnOffDelay" - to delay time for VFD supply contactor
      s_FB_TimerOnOffDelay_SafetyOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //   "TimerOnOffDelay" - to delay time for safety
      s_FB_TimerOnOffDelay_RunCommand { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   //   "TimerOnOffDelay" - to delay time for run command motor
      s_FB_TimerOnOffDelay_PNOnline { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      s_R_TRIG_RunForward {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge of Run forward signal
      s_R_TRIG_RunReverse {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge of Run reverse
      s_R_TRIG_PNSlaveNotOnline {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge for trigger Profinet slave not online statistics
      s_R_TRIG_PNSlaveError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge for trigger Profinet slave error statistics
      s_R_TRIG_InternalError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge for trigger Internal VFD Error statistics
      s_R_TRIG_Running {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   //   Rising edge for starting of the running signal
      s_UDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_VfdStatus";   //   HMI status structure
      s_UDT_PNDevice { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_PNDevice";   //   PN device info structure
      ss_PNPortsStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..8] of Bool;   //   TRUE when specific port has an error
      ss_VFDGeoStruct {InstructionName := 'GEOADDR'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : GEOADDR;   //   Geo structure indicate to telegram
      ss_RDREC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //   Read error code record structure
         Valid { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      Read operation is done
         Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      Read operation is in progress
         Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      Read operation has an error
         Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DWord;   //      Read operation status
         Lenght { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   //      Lenght of the read record
      END_STRUCT;
      ss_WRREC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //   Write record structure
         Acceleration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //      Acceleration
            REQ { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      Requirement
            Index { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //      Index
            Done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      Operation is done
            Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      Write operation is in progress
            Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      Write operation has an error
            Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DWord;   //      Write operation status
            Data { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   //      Data to write
         END_STRUCT;
         Deceleration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   //      Deceleration
            REQ { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      Requirement
            Index { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   //      Index
            Done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      Operation is done
            Busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      Write operation is in progress
            Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //      Write operation has an error
            Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DWord;   //      Write operation status
            Data { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   //      Data to write
         END_STRUCT;
      END_STRUCT;
      s_WRREC_ACC {InstructionName := 'WRREC'; LibVersion := '1.1'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : WRREC;   //   Write acceleration record inctruction
      s_WRREC_DEC {InstructionName := 'WRREC'; LibVersion := '1.1'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : WRREC;   //   Write deceleration record instruction
      shw_VFD_Telegram { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;   //   Free telegram's HW_ID
      sr_MaximumSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   //   Maximum speed [mm/s]
      sr_SpeedsetpointCorrected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   //  Speedsetpoint corrected with factor
      si_RequiredSpeedSetpoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Required speed setpoint
      si_AccelerationSetpoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Acceleration setpoint value
      si_DecelerationSetpoint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Deceleration setpoint value
      si_AccelerationOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Old acceleration value
      si_DecelerationOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Old deceleration value
      si_ActualSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Actual speed in [mm/s]
      si_Log2GeoReturn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Log2Geo function return
      si_Geo2LogReturn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   //   Geo2Log function return
      ssi_MotorSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : SInt;   //   Motor speed value
      sx_ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Commissioning: configuration error
      sx_PNDeviceHealthy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Profinet device is online and error free
      sx_PowerOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Communication, safety and power are available
      sx_VFD_Available { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Hardware of VFD is ok
      sx_ErrorActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Block has an error
      sx_InvalidMotorNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Invalid motor error
      sx_MotorError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Motor error
      sx_EnableOperation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Enable operation signal
      sx_RunVFDForward { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Start VFD forward
      sx_RunVFDReverse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Start VFD backward
      sx_AccelerationDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Acceleration is written
      sx_DecelerationDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Deceleration is written
      sx_SpeedSetpointReached { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Motor is running at requested speed
      sx_PNSlaveError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Profinet slave error
      sx_PNSlaveNotOnline { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //   Profinet slave not online
      s_R_TRIG_PNSlaveNotOnline_Acyclic {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
   END_VAR

   VAR CONSTANT 
      ci_VFDArea : UInt := 1;   //   Area ID of IO Profinet devices
      ci_SubmoduleHWType : UInt := 5;   //   Submodule HW_type number
      ci_TelegramSlot : UInt := 2;   //   Free Siemens telegram slot
      ci_TelegramSubslot : UInt := 1;   //   Free Siemens telegram subslot
      cdi_ErrorCodeIndex : DInt := 17154;   //   Error code index
      cdi_AccelerationIndex : DInt := 18200;   //   Acceleration index
      cdi_DecelerationIndex : DInt := 18204;   //   Deceleration index
      ci_NumberOfProfinetPorts : Int := 2;
   END_VAR


BEGIN
	REGION Header
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------      
	                                                                                  
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	08/11/2019  | 3.0       | A. Nowak      | Initial version
	18/03/2020  | 3.1       | K.Pokorski    | Adapting reviews
	10/06/2021  | 3.2       | L.Klar        | Region 9.1 - #ssi_MotorSpeed = 0 condition commented
	17/11/2021  | 3.3       | P.Gryszczyk   | Region 2 - RunCommand timer changed conditions 
	18/02/2021  | 3.4       | P.Gryszczyk   | Region 4 - PNNotOnline and PNSlaveError masking, sending reset to system
	24/05/2023  | 3.5       | S.Nikodem     | Update to DHL Munich specification
	07/06/2023  | 3.6       | R.Golonka     | Update to new UDT_VFD_Multicontrol_IOMode, Hardware IO Mode module changed
	04/07/2023  | 3.7       | P.Gryszczyk   | Changed the PNSlaveNotOnline to R_TRIG for the acyclic writing logic
	08/08/2023  | 3.8       | R.Golonka     | Adjust alarm the device, Added profinet slave warning
	30/08/2023  | 4.0       | S.Theocharis  | Mask pn error when not online is set
	13/03/2024  | 4.1       | S. Nieswiec   | Added to new baseline
	*)
	END_REGION
	
	REGION 1 - Get Device Profinet number
	    
	    // Getting information about Profinet device
	    "FC_GetDevicePN"(is_PNDeviceName := #i_UDT_VFDConfiguration.VFDPNDeviceName,
	                     ix_SimulationModeActive := #ix_SimulationModeActive,
	                     iqUDT_PND := #s_UDT_PNDevice);
	    
	    // Getting information about port status of device
	    "FC_GetPNPortStatus"(ii_NumberOfPorts := #ci_NumberOfProfinetPorts,
	                         iUDT_DevicePNInfo := #s_UDT_PNDevice,
	                         qa_PortFault => #ss_PNPortsStatus);
	    
	END_REGION
	
	REGION 2 - Motor number validation
	    
	    // Check the motor number and copy the it's error status and speed.
	    CASE (#ii_MotorNumber)
	    OF
	        1:
	            // Delay
	            #s_FB_TimerOnOffDelay_RunCommand(iudi_OnDelayTime := 1500,
	                                             ix_SignalToDelay := #sx_RunVFDForward OR #sx_RunVFDReverse);
	            
	            #ssi_MotorSpeed := #i_UDT_VFDInputs.SpeedMotor1;
	            
	            #sx_MotorError := #i_UDT_VFDInputs.ErrorMotor1;
	            
	        2:
	            #s_FB_TimerOnOffDelay_RunCommand(iudi_OnDelayTime := 1500,
	                                             ix_SignalToDelay := #sx_RunVFDForward OR #sx_RunVFDReverse);
	            
	            #ssi_MotorSpeed := #i_UDT_VFDInputs.SpeedMotor2;
	            
	            #sx_MotorError := #i_UDT_VFDInputs.ErrorMotor2;
	        3:
	            #s_FB_TimerOnOffDelay_RunCommand(iudi_OnDelayTime := 1500,
	                                             ix_SignalToDelay := #sx_RunVFDForward OR #sx_RunVFDReverse);
	            
	            #ssi_MotorSpeed := #i_UDT_VFDInputs.SpeedMotor3;
	            
	            #sx_MotorError := #i_UDT_VFDInputs.ErrorMotor3;
	        4:
	            #s_FB_TimerOnOffDelay_RunCommand(iudi_OnDelayTime := 1500,
	                                             ix_SignalToDelay := #sx_RunVFDForward OR #sx_RunVFDReverse);
	            
	            #ssi_MotorSpeed := #i_UDT_VFDInputs.SpeedMotor4;
	            
	            #sx_MotorError := #i_UDT_VFDInputs.ErrorMotor4;
	            
	        ELSE
	            #sx_InvalidMotorNumber := TRUE;
	    END_CASE;
	    
	END_REGION
	
	REGION 3 - Reset errors
	    
	    // Reset the errors on the command from the conveyor interface.
	    IF #iq_UDT_ConveyorInterface.InternalErrorReset OR (NOT #iq_UDT_ConveyorInterface.HardwareOk AND #s_UDT_HMIStatus.PNSlaveNotonline) THEN
	        #s_UDT_HMIStatus.PNSlaveNotonline := FALSE;
	        #s_UDT_HMIStatus.PNSlaveError := FALSE;
	        #s_UDT_HMIStatus.InternalError := FALSE;
	        #s_UDT_HMIStatus.PNSlaveWarning := FALSE;
	        #sx_PNSlaveError := FALSE;
	        #sx_PNSlaveNotOnline := FALSE;
	        #sx_InvalidMotorNumber := FALSE;
	        #sx_MotorError := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Hardware check
	    
	    // Hardware will be available only after the delay, so the device has time for the initialization.
	    #s_FB_TimerOnOffDelayCheckSupply(iudi_OnDelayTime := 2000,
	                                     ix_SignalToDelay := #ix_PowerOK,
	                                     qx_DelayedSignal => #sx_PowerOk);
	    
	    IF NOT "DB_ProfinetDiagnostic".ProfinetNetworks[#s_UDT_PNDevice.PNNetworknumber].DeviceStatus[#s_UDT_PNDevice.PNDeviceNumber].DeviceState.Exist
	        AND NOT #ix_SimulationModeActive
	        AND #sx_PowerOk
	        AND #iq_UDT_ConveyorInterface.HardwareOk
	    THEN
	        #sx_PNSlaveNotOnline := True;
	    END_IF;
	    
	    // Chceck if PN ports are healthy
	    IF #ss_PNPortsStatus[1] XOR #ss_PNPortsStatus[2] THEN
	        #s_UDT_HMIStatus.PNSlaveWarning := TRUE;
	    END_IF;
	    
	    // Check if PN device has an error 
	    IF "DB_ProfinetDiagnostic".ProfinetNetworks[#s_UDT_PNDevice.PNNetworknumber].DeviceStatus[#s_UDT_PNDevice.PNDeviceNumber].DeviceState.Error
	        AND NOT #ix_SimulationModeActive
	        AND #sx_PowerOk
	        AND NOT #s_UDT_HMIStatus.PNSlaveWarning
	        AND #iq_UDT_ConveyorInterface.HardwareOk
	        AND NOT #sx_PNSlaveNotOnline
	    THEN
	        #sx_PNSlaveError := TRUE;
	    END_IF;
	    
	    // Set bit when PN device is healthy (online and no error)
	    #sx_PNDeviceHealthy :=
	    NOT #s_UDT_HMIStatus.PNSlaveNotonline
	    AND NOT #s_UDT_HMIStatus.PNSlaveError
	    AND #s_UDT_PNDevice.PNDeviceFound
	    AND #sx_PowerOk;
	    
	    // Set VFD available bit when all conditions are met.
	    #sx_VFD_Available :=
	    (NOT #sx_MotorError
	    AND #sx_PowerOk
	    AND #sx_PNDeviceHealthy)
	    OR #ix_SimulationModeActive;
	    
	END_REGION
	
	REGION 5 - Extract telegram's HW_ID
	    
	    // Extract telegram's HW_ID //Do we need this in every scan?
	    #si_Log2GeoReturn := LOG2GEO(LADDR := "DB_ProfinetDiagnostic".ProfinetNetworks[#s_UDT_PNDevice.PNNetworknumber].DeviceStatus[#s_UDT_PNDevice.PNDeviceNumber].DeviceState.HW_ID, GEOADDR := #ss_VFDGeoStruct);
	    #ss_VFDGeoStruct.AREA := #ci_VFDArea;
	    #ss_VFDGeoStruct.HWTYPE := #ci_SubmoduleHWType;
	    #ss_VFDGeoStruct.STATION := INT_TO_UINT(#s_UDT_PNDevice.PNDeviceNumber);
	    #ss_VFDGeoStruct.SLOT := #ci_TelegramSlot;
	    #ss_VFDGeoStruct.SUBSLOT := #ci_TelegramSubslot;
	    
	    #si_Geo2LogReturn := GEO2LOG(GEOADDR := #ss_VFDGeoStruct, LADDR => #shw_VFD_Telegram);
	    
	END_REGION
	
	REGION 6 - Check errors 
	    
	    #s_FB_TimerOnOffDelay_SafetyOK(iudi_OnDelayTime := 10000,
	                                   ix_SignalToDelay := #ix_SafetyOK);
	    
	    #s_FB_TimerOnOffDelay_PNOnline(iudi_OnDelayTime := 4000,
	                                   ix_SignalToDelay := "DB_ProfinetDiagnostic".ProfinetNetworks[#s_UDT_PNDevice.PNNetworknumber].DeviceStatus[#s_UDT_PNDevice.PNDeviceNumber].DeviceState.Exist);
	    
	    
	    // Check if the motor has an error.
	    IF #sx_MotorError
	        /// OR(#i_UDT_VFDInputs.Error = 3)) // Remvoved the global error to focus on the individual roller
	        AND #s_FB_TimerOnOffDelay_SafetyOK.qx_DelayedSignal
	        AND #s_FB_TimerOnOffDelay_PNOnline.qx_DelayedSignal
	        AND #sx_PowerOk
	    THEN
	        #s_UDT_HMIStatus.InternalError := TRUE;
	    END_IF;
	    
	    #s_R_TRIG_InternalError(CLK := #s_UDT_HMIStatus.InternalError);
	    
	    // If there is an internal error, read the error code from the Interroll VFD. Otherwise, reset it.
	    IF #s_R_TRIG_InternalError.Q THEN
	        #s_UDT_HMIStatus.ErrorCode := #i_UDT_VFDInputs.LastError;
	    END_IF;
	    
	    //Reset Error code 
	    IF NOT #s_UDT_HMIStatus.InternalError THEN
	        #s_UDT_HMIStatus.ErrorCode := 0;
	    END_IF;
	    
	END_REGION
	
	REGION 7 - Check if configuration is ok for commissioning purposes
	    
	    // Validate the VFD configuration and motor number.
	    IF #i_UDT_VFDConfiguration.MaximumSpeed > 0.0
	        AND #i_UDT_VFDConfiguration.VFDRampUpTime > 0
	        AND #i_UDT_VFDConfiguration.VFDRampDownTime > 0
	        AND NOT #sx_InvalidMotorNumber
	    THEN
	        #sx_ConfigurationError := FALSE;
	    ELSE
	        #sx_ConfigurationError := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 8 - Handle speed
	    
	    // Write max speed to static.
	    #sr_MaximumSpeed := #i_UDT_VFDConfiguration.MaximumSpeed;
	    
	    // Use correction factor to calculate setpint for diaginal use
	    #sr_SpeedsetpointCorrected := INT_TO_REAL(#iq_UDT_ConveyorInterface.SpeedSetpoint) * #i_UDT_VFDConfiguration.CorrectionFactor;
	    
	    // Actual speed setpoint
	    #si_RequiredSpeedSetpoint := REAL_TO_INT((#sr_SpeedsetpointCorrected * 100.0) / (#sr_MaximumSpeed));
	    
	    // Speed setpoint saturation in case when the speed setpoint is higher than the max speed.
	    IF #si_RequiredSpeedSetpoint > 100
	    THEN
	        #si_RequiredSpeedSetpoint := 100;
	        #iq_UDT_ConveyorInterface.ConfigurationError := TRUE;
	    ELSIF #si_RequiredSpeedSetpoint < -100
	    THEN
	        #si_RequiredSpeedSetpoint := -100;
	        #iq_UDT_ConveyorInterface.ConfigurationError := TRUE;
	    END_IF;
	END_REGION
	
	REGION 9 - Prepare output data VFD
	    
	    REGION 9.1 - Set speed setpoint in forward and reverse direction 
	        // Get rising edge of Run forward and reverse signal.
	        #s_R_TRIG_RunForward(CLK := #iq_UDT_ConveyorInterface.RunFwd);
	        #s_R_TRIG_RunReverse(CLK := #iq_UDT_ConveyorInterface.RunRvs);
	        
	        // When rising edge of the forward or reverse signal is received, the drive has to stop to be able to make the switch.
	        IF #s_R_TRIG_RunForward.Q
	            OR #s_R_TRIG_RunReverse.Q
	        THEN
	            #qsi_UDT_VFDSpeed := 0;
	        END_IF;
	        
	        // If motor stopped and Run forward is requested and forward direction is interlock, set run forward signal and reset run reverse signal.
	        IF //#ssi_MotorSpeed = 0 and
	            #iq_UDT_ConveyorInterface.RunFwd
	            AND #i_UDT_VFDConfiguration.InterlockFwd
	        THEN
	            #sx_RunVFDForward := TRUE;
	            #sx_RunVFDReverse := FALSE;
	        END_IF;
	        
	        // If motor stopped and Run reverse is requested and reverse direction is interlock, set run reverse signal and reset run forward signal.
	        IF // #ssi_MotorSpeed = 0 AND
	            #iq_UDT_ConveyorInterface.RunRvs
	            AND #i_UDT_VFDConfiguration.InterlockRvs
	        THEN
	            #sx_RunVFDReverse := TRUE;
	            #sx_RunVFDForward := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 9.2 - Stopping
	        
	        // Stop the VFD if one of the following conditions is met.
	        IF (NOT #iq_UDT_ConveyorInterface.RunRvs AND NOT #iq_UDT_ConveyorInterface.RunFwd)
	            OR (#iq_UDT_ConveyorInterface.RunRvs AND #iq_UDT_ConveyorInterface.RunFwd)
	            OR (#sx_RunVFDReverse AND NOT #i_UDT_VFDConfiguration.InterlockRvs)
	            OR (#sx_RunVFDForward AND NOT #i_UDT_VFDConfiguration.InterlockFwd)
	            OR ((#s_R_TRIG_RunForward.Q AND #ssi_MotorSpeed < 0)
	            OR (#s_R_TRIG_RunReverse.Q AND #ssi_MotorSpeed > 0))
	        THEN
	            #sx_RunVFDReverse := FALSE;
	            #sx_RunVFDForward := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 9.3 - Check for enable operation signal
	        
	        // Operation is enable when VFD is available and there is one of the run commands.
	        #sx_EnableOperation :=
	        #sx_VFD_Available
	        AND (#sx_RunVFDForward OR #sx_RunVFDReverse)
	        AND NOT #sx_ConfigurationError;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 10 - Write outputs to VFD  
	    
	    REGION 10.1 - Write speed setpoint to drive
	        
	        // The conveyor stopped and may now run in forward direction.
	        IF ((#sx_RunVFDForward AND NOT #i_UDT_VFDConfiguration.DirectionReversal)
	            OR (#sx_RunVFDReverse AND #i_UDT_VFDConfiguration.DirectionReversal))
	            AND #sx_EnableOperation
	        THEN
	            #qsi_UDT_VFDSpeed := INT_TO_SINT(#si_RequiredSpeedSetpoint);
	        END_IF;
	        
	        // The conveyor stopped and may now run in reverse direction.
	        IF ((#sx_RunVFDReverse AND NOT #i_UDT_VFDConfiguration.DirectionReversal)
	            OR (#sx_RunVFDForward AND #i_UDT_VFDConfiguration.DirectionReversal))
	            AND #sx_EnableOperation
	        THEN
	            #qsi_UDT_VFDSpeed := - INT_TO_SINT(#si_RequiredSpeedSetpoint);
	        END_IF;
	        
	        // Clear speed setpoint when run isn't request.
	        IF (NOT #sx_RunVFDForward
	            AND NOT #sx_RunVFDReverse)
	            OR NOT #sx_EnableOperation
	        THEN
	            #qsi_UDT_VFDSpeed := 0;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 10.2 - Calculate acceleration and deceleration values
	        
	        // Recalculating Acceleration ramp - deviding maximum configured speed by Ramp up time and devide it by 1000.
	        #si_AccelerationSetpoint := REAL_TO_INT(#sr_MaximumSpeed / (UDINT_TO_REAL(#i_UDT_VFDConfiguration.VFDRampUpTime) / 1000.0));
	        
	        // Recalculating Deceleration ramp - deviding maximum configured speed by Ramp down time and devide it by 1000.
	        #si_DecelerationSetpoint := REAL_TO_INT(#sr_MaximumSpeed / (UDINT_TO_REAL(#i_UDT_VFDConfiguration.VFDRampDownTime) / 1000.0));
	        
	    END_REGION
	    
	    REGION 10.3 - Write acceleration to drive
	        
	        #s_R_TRIG_PNSlaveNotOnline_Acyclic(CLK := NOT #s_UDT_HMIStatus.PNSlaveNotonline);
	        
	        
	        // Acceleration write operation is done.
	        IF #sx_AccelerationDone
	        THEN
	            // There is new acceleration value or device is offline.
	            IF #si_AccelerationSetpoint <> #si_AccelerationOld
	                OR #s_R_TRIG_PNSlaveNotOnline_Acyclic.Q
	            THEN
	                // Reset the accleration operation done signal.
	                #sx_AccelerationDone := FALSE;
	            END_IF;
	        END_IF;
	        
	        // The acceleration operation isn't done or there is first scan and device is online.
	        IF (NOT #sx_AccelerationDone OR "mx_FirstScan")
	            AND NOT #s_UDT_HMIStatus.PNSlaveNotonline
	        THEN
	            
	            // There isn't an invalid motor number error and acceleration isn't equal to 0.
	            IF NOT #sx_InvalidMotorNumber
	                AND #si_AccelerationSetpoint > 0
	            THEN
	                // Calculate the index of the acceleration.
	                #ss_WRREC.Acceleration.Index := #cdi_AccelerationIndex + #ii_MotorNumber;
	                // Prepare the data.
	                #ss_WRREC.Acceleration.Data := SWAP(INT_TO_WORD(#si_AccelerationSetpoint));
	                // Set operation is required.
	                #ss_WRREC.Acceleration.REQ := TRUE;
	                
	                // Send acceleration to the device.
	                #s_WRREC_ACC(REQ := #ss_WRREC.Acceleration.REQ,
	                             ID := #shw_VFD_Telegram,
	                             INDEX := #ss_WRREC.Acceleration.Index,
	                             LEN := 0,
	                             DONE => #ss_WRREC.Acceleration.Done,
	                             BUSY => #ss_WRREC.Acceleration.Busy,
	                             ERROR => #ss_WRREC.Acceleration.Error,
	                             STATUS => #ss_WRREC.Acceleration.Status,
	                             RECORD := #ss_WRREC.Acceleration.Data);
	                
	                // Send operation is done.
	                IF #ss_WRREC.Acceleration.Done
	                THEN
	                    // Reset operation is required bit.
	                    #ss_WRREC.Acceleration.REQ := FALSE;
	                    // Set the operation is done signal.
	                    #sx_AccelerationDone := TRUE;
	                    // Write acceleration value into the old one.
	                    #si_AccelerationOld := #si_AccelerationSetpoint;
	                END_IF;
	            END_IF;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 10.4 - Write deceleration to drive
	        
	        // Deceleration write operation is done.
	        IF #sx_DecelerationDone
	        THEN
	            // There is new deceleration value or device is offline.
	            IF #si_DecelerationSetpoint <> #si_DecelerationOld
	                OR #s_R_TRIG_PNSlaveNotOnline_Acyclic.Q
	            THEN
	                // Reset the deceleration operation done signal.
	                #sx_DecelerationDone := FALSE;
	            END_IF;
	        END_IF;
	        
	        // The deceleration operation isn't done or there is first scan and device is online.
	        IF (NOT #sx_DecelerationDone OR "mx_FirstScan")
	            AND NOT #s_UDT_HMIStatus.PNSlaveNotonline
	        THEN
	            // There isn't an invalid motor number error and deceleration isn't equal to 0.
	            IF NOT #sx_InvalidMotorNumber
	                AND #si_DecelerationSetpoint > 0
	            THEN
	                // Calculate the index of the deceleration.
	                #ss_WRREC.Deceleration.Index := #cdi_DecelerationIndex + #ii_MotorNumber;
	                // Prepare the data.
	                #ss_WRREC.Deceleration.Data := SWAP(INT_TO_WORD(#si_DecelerationSetpoint));
	                // Set operation is required.
	                #ss_WRREC.Deceleration.REQ := TRUE;
	                
	                // Send deceleration to the device.
	                #s_WRREC_DEC(REQ := #ss_WRREC.Deceleration.REQ,
	                             ID := #shw_VFD_Telegram,
	                             INDEX := #ss_WRREC.Deceleration.Index,
	                             LEN := 0,
	                             DONE => #ss_WRREC.Deceleration.Done,
	                             BUSY => #ss_WRREC.Deceleration.Busy,
	                             ERROR => #ss_WRREC.Deceleration.Error,
	                             STATUS => #ss_WRREC.Deceleration.Status,
	                             RECORD := #ss_WRREC.Deceleration.Data);
	                
	                // Send operation is done.
	                IF #ss_WRREC.Deceleration.Done
	                THEN
	                    // Reset operation is required bit.
	                    #ss_WRREC.Deceleration.REQ := FALSE;
	                    // Set the operation is done signal.
	                    #sx_DecelerationDone := TRUE;
	                    // Write deceleration value into the old one.
	                    #si_DecelerationOld := #si_DecelerationSetpoint;
	                END_IF;
	            END_IF;
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 11 - Copy signals to interface DB and to status output UDT
	    
	    // Create collective error.
	    #sx_ErrorActive :=
	    #s_UDT_HMIStatus.PNSlaveNotonline
	    OR #s_UDT_HMIStatus.PNSlaveError
	    OR #s_UDT_HMIStatus.InternalError
	    OR #sx_ConfigurationError;
	    
	    // Motor is giving direct signal on start, move setpoint to actual speed.                                                                                    
	    IF #ssi_MotorSpeed > 0
	    THEN
	        #si_ActualSpeed := #iq_UDT_ConveyorInterface.SpeedSetpoint;
	        #sx_SpeedSetpointReached := TRUE;
	    ELSIF #ssi_MotorSpeed < 0
	    THEN
	        #si_ActualSpeed := (-1) * #iq_UDT_ConveyorInterface.SpeedSetpoint;
	        #sx_SpeedSetpointReached := TRUE;
	    ELSE
	        #si_ActualSpeed := 0;
	        #sx_SpeedSetpointReached := FALSE;
	    END_IF;
	    
	    //For direction reversal negate the actual speed 
	    IF #i_UDT_VFDConfiguration.DirectionReversal THEN
	        #si_ActualSpeed := (-1) * #si_ActualSpeed;
	    END_IF;
	    
	    
	    // Write interface bits.
	    #iq_UDT_ConveyorInterface.VFDRunning :=
	    #sx_VFD_Available
	    AND #iq_UDT_ConveyorInterface.ActualSpeed <> 0;
	    
	    // Speed setpoint is reached.
	    #iq_UDT_ConveyorInterface.VFDatSpeed :=
	    #sx_SpeedSetpointReached
	    AND #sx_VFD_Available;
	    
	    // Set the internal VFD error bit if any fault is active.
	    #iq_UDT_ConveyorInterface.InternalErrorVFD := #sx_ErrorActive;
	    // Copy the speed value to the output.
	    
	    #iq_UDT_ConveyorInterface.ActualSpeed := #si_ActualSpeed;
	    
	    //Copy error PN slave not online status to HMI status
	    #s_UDT_HMIStatus.PNSlaveNotonline := #sx_PNSlaveNotOnline;
	    //Copy error PN slave status to HMI status 
	    #s_UDT_HMIStatus.PNSlaveError := #sx_PNSlaveError;
	    
	    // Copy error status to output.
	    #q_UDT_HMIStatus := #s_UDT_HMIStatus;
	    
	END_REGION
	
	REGION 12 - Statistics
	    
	    // Create trigger on error and create statistics for profinet slave not online.
	    #s_R_TRIG_PNSlaveNotOnline(CLK := #s_UDT_HMIStatus.PNSlaveNotonline);
	    
	    IF #iq_UDT_ConveyorInterface.ResetStatistics
	        OR #s_UDT_HMIStatus.PNSlaveNotonline
	    THEN
	        "FC_Statistics"(ix_Reset := #iq_UDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #s_UDT_HMIStatus.PNSlaveNotonline,
	                        ix_RTrigActivate := #s_R_TRIG_PNSlaveNotOnline.Q,
	                        iqUDT_Statistics := #iq_UDT_VFDStatistics.PNSlaveNotOnline);
	    END_IF;
	    
	    // Create trigger on error and create statistics for profinet slave error.
	    #s_R_TRIG_PNSlaveError(CLK := #s_UDT_HMIStatus.PNSlaveError);
	    
	    IF #iq_UDT_ConveyorInterface.ResetStatistics
	        OR #s_UDT_HMIStatus.PNSlaveError
	    THEN
	        "FC_Statistics"(ix_Reset := #iq_UDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #s_UDT_HMIStatus.PNSlaveError,
	                        ix_RTrigActivate := #s_R_TRIG_PNSlaveError.Q,
	                        iqUDT_Statistics := #iq_UDT_VFDStatistics.PNSlaveError);
	    END_IF;
	    
	    IF #iq_UDT_ConveyorInterface.ResetStatistics
	        OR #s_UDT_HMIStatus.InternalError
	    THEN
	        "FC_Statistics"(ix_Reset := #iq_UDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #s_UDT_HMIStatus.InternalError,
	                        ix_RTrigActivate := #s_R_TRIG_InternalError.Q,
	                        iqUDT_Statistics := #iq_UDT_VFDStatistics.VFDInternalError);
	    END_IF;
	    
	    // Create trigger on running signal and create statistics for running status.
	    #s_R_TRIG_Running(CLK := #iq_UDT_ConveyorInterface.VFDRunning);
	    
	    IF #iq_UDT_ConveyorInterface.ResetStatistics
	        OR #iq_UDT_ConveyorInterface.VFDRunning
	    THEN
	        "FC_Statistics"(ix_Reset := #iq_UDT_ConveyorInterface.ResetStatistics,
	                        ix_Activate := #iq_UDT_ConveyorInterface.VFDRunning,
	                        ix_RTrigActivate := #s_R_TRIG_Running.Q,
	                        iqUDT_Statistics := #iq_UDT_VFDStatistics.Running);
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_TrackingMonitor"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 104
// END_ATTRIBUTES
   VAR_INPUT 
      ix_Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // One Shot or Constant TRUE to exectue
      ii_StartPointer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ii_EndPointer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      i_UDT_ConveyorCommonConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorCommonConfiguration";   // Conveyor common configuration
   END_VAR

   VAR_OUTPUT 
      qx_ErrorCode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      q_Overview { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_TrackingOverview";
   END_VAR

   VAR_IN_OUT 
      iq_Object : Array[*] of "UDT_TrackingMonitor";
      iq_Tracking : Array[*] of Int;
   END_VAR

   VAR 
      sdi_TotalConvLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      si_StartPointer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_EndPointer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_NextObject { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_FirstObject { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      si_LengthOfMonitoringArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;
      si_PreviousID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
   END_VAR

   VAR_TEMP 
      ti_index : Int;
      ret_val : Int;
      t_udt_TrackingMonitor : "UDT_TrackingMonitor";
      ti_fill : Int;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|                              FORTNA Europe                                           |
	|                              Netherlands                                             |
	|                                                                                      |     
	----------------------------------------------------------------------------------------
	                                                                                  
	Version history:
	Date        | Version   | Author            | Remark
	----------------------------------------------------------------------------------------
	05/05/2023  | 0.1       | S. Theocharis     | first release
	13/03/2024  | 1.1       | S. Nieswiec       | Added to new baseline
	*)
	
	REGION 1 Check Condition to execute
	    
	    IF NOT #ix_Enable THEN
	        RETURN;
	    END_IF;
	    
	END_REGION
	
	REGION 2 Initialize variables
	    
	    //Clear value
	    #ti_fill := 0;
	    
	    //Reset Error
	    #qx_ErrorCode := 0;
	    
	    //Clear UDT
	    #t_udt_TrackingMonitor.Data := 0;
	    #t_udt_TrackingMonitor.Position := 0;
	    
	    // Check the conveyor length 
	    #sdi_TotalConvLength := (#i_UDT_ConveyorCommonConfiguration.Length + #i_UDT_ConveyorCommonConfiguration.LengthCorrection) / 10;
	    
	    
	    //Define start of  search window
	    IF #ii_StartPointer > 0 THEN
	        #si_StartPointer := #ii_StartPointer;
	    ELSE
	        #si_StartPointer := 0;
	    END_IF;
	    
	    //Define end of search window 
	    IF (#ii_EndPointer > 0) AND (#ii_EndPointer > #si_StartPointer) THEN
	        #si_EndPointer := #ii_EndPointer;
	    ELSE
	        #si_EndPointer := DINT_TO_INT(#sdi_TotalConvLength);
	    END_IF;
	    
	    
	    //Verifiy pointers 
	    IF #si_EndPointer <= #si_StartPointer THEN
	        #qx_ErrorCode := 2;
	        RETURN; //exit block
	    END_IF;
	    
	    
	    //Check length of monitoring array
	    #si_LengthOfMonitoringArray := INT_TO_UINT("FC_GetNrOfArrayEl"(#iq_Object));
	    #si_NextObject := DINT_TO_INT(LOWER_BOUND(ARR := #iq_Object, DIM := 1));
	    #si_FirstObject := #si_NextObject;
	    //make dynamic the length of the tracking monitor DB 
	    //clear tracking monitor 
	    #ret_val := MOVE_BLK_VARIANT(SRC := #t_udt_TrackingMonitor, COUNT := #si_LengthOfMonitoringArray, SRC_INDEX := 0, DEST_INDEX := #si_NextObject, DEST => #iq_Object);
	    
	END_REGION
	
	REGION 3 Reb-build tracking monitor 
	    (* do we distinguish parcel from window? *)
	    
	    FOR #ti_index := #si_StartPointer TO #si_EndPointer BY 1 DO
	        
	        IF #iq_Tracking[#ti_index] <> 0
	            AND #iq_Tracking[#ti_index] <> #si_PreviousID  //in case we have multiple entires with the same GIN or Data 
	        THEN
	            #iq_Object[#si_NextObject].Data := #iq_Tracking[#ti_index];  //Copy Data to onbect ID
	            #iq_Object[#si_NextObject].Position := #ti_index;
	            #iq_Object[#si_NextObject].DataLength := 1;
	            
	            #si_NextObject += 1; //increment for next cycle 
	            
	            //Overflow handling 
	            IF #si_NextObject >= #si_LengthOfMonitoringArray THEN
	                #qx_ErrorCode := 1;  // 1 = more then 30 objects detected
	                #si_NextObject := DINT_TO_INT(LOWER_BOUND(ARR := #iq_Object, DIM := 1));
	                EXIT;
	            END_IF;
	            
	            
	        ELSIF (#iq_Tracking[#ti_index] = #si_PreviousID)
	            AND #si_PreviousID <> 0
	        THEN
	            
	            //Increment Data lentgh 
	            #iq_Object[#si_NextObject - 1].DataLength += 1;
	            
	        END_IF;
	        
	        //save ID for next loop 
	        #si_PreviousID := #iq_Tracking[#ti_index];
	        
	    END_FOR;
	    
	    //Clear empty positions
	    FOR #ti_index := #si_NextObject TO DINT_TO_INT(UPPER_BOUND(ARR := #iq_Object, DIM := 1)) BY 1 DO
	        #iq_Object[#ti_index].Data := 0;
	        #iq_Object[#ti_index].Position := 0;
	        #iq_Object[#ti_index].DataLength := 0;
	    END_FOR;
	    
	    
	    
	END_REGION
	
	REGION Tracking overwiev
	    
	    //Count lenght from all detected parcel
	    FOR #ti_index := 1 TO #si_NextObject BY 1 DO
	        
	        #ti_fill := #ti_fill + #iq_Object[#ti_index].DataLength;
	        
	    END_FOR;
	    
	    //Rewwrite dates on output
	    #q_Overview.TotalObject := #si_NextObject - 1;
	    #q_Overview.FillingRate := REAL_TO_INT((INT_TO_REAL(#ti_fill) / (INT_TO_REAL(#si_EndPointer - #ii_StartPointer))) * 100.0);
	    
	    
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_CheckParcelData"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 239
// END_ATTRIBUTES
   VAR_INPUT 
      ii_GIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // GIN number
      ii_XrayLocation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // X-ray location
      ii_SourceNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // ID Source Node
      ii_DestinationNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // ID Destination Node
      is_ActualTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;   // Actual date annd time in String
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqa_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Message number
   END_VAR

   VAR 
      FB_MFC_Sort_COY_ReceiveResult_Instance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MFC_Sort_COY_ReceiveResult";
      PieceID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[40];
   END_VAR

   VAR_TEMP 
      ts_String : String;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	05/10/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	12/03/2024  | 1.1       | S. Nieswiec  | Added to new Baseline
	*)
	
	REGION Check Piece ID
	    
	    IF #ii_GIN > 0 THEN
	        
	        IF "DB_GIN".GIN[#ii_GIN].DHL.PieceID = '' THEN
	            
	            //Generation Piece ID
	            //Constant
	            #PieceID[1] := '0';
	            #PieceID[2] := '0';
	            #PieceID[3] := '0';
	            #PieceID[4] := '0';
	            #PieceID[5] := '0';
	            #PieceID[6] := '0';
	            #PieceID[7] := '0';
	            #PieceID[8] := '_';
	            #PieceID[9] := 'L';
	            #PieceID[10] := 'O';
	            #PieceID[11] := 'S';
	            #PieceID[12] := 'T';
	            #PieceID[13] := '_';
	            #PieceID[14] := 'X';
	            #PieceID[15] := 'R';
	            #PieceID[16] := 'A';
	            #PieceID[17] := 'Y';
	            #PieceID[18] := '_';
	            
	            //XrayLocation
	            #ts_String := DELETE(IN := DINT_TO_STRING(#ii_XrayLocation), L := 1, P := 1);
	            #PieceID[19] := #ts_String[1];
	            #PieceID[20] := #ts_String[2];
	            #PieceID[21] := #ts_String[3];
	            
	            //Constant
	            #PieceID[22] := '_';
	            
	            //Year
	            #PieceID[23] := #is_ActualTime[1];
	            #PieceID[24] := #is_ActualTime[2];
	            #PieceID[25] := #is_ActualTime[3];
	            #PieceID[26] := #is_ActualTime[4];
	            
	            //Month
	            #PieceID[27] := #is_ActualTime[6];
	            #PieceID[28] := #is_ActualTime[7];
	            
	            //Day
	            #PieceID[29] := #is_ActualTime[9];
	            #PieceID[30] := #is_ActualTime[10];
	            
	            //Constant
	            #PieceID[31] := '_';
	            
	            //Time
	            #PieceID[32] := #is_ActualTime[12];
	            #PieceID[33] := #is_ActualTime[13];
	            #PieceID[34] := #is_ActualTime[14];
	            #PieceID[35] := #is_ActualTime[15];
	            
	            //Constant
	            #PieceID[36] := '_';
	            
	            //GIN
	            #ts_String := DELETE(IN := DINT_TO_STRING(#ii_GIN), L := 1, P := 1);
	            
	            IF (#ii_GIN > 0) AND (#ii_GIN <= 9) THEN
	                #PieceID[37] := '0';
	                #PieceID[38] := '0';
	                #PieceID[39] := '0';
	                #PieceID[40] := #ts_String[1];
	            ELSIF (#ii_GIN >= 10) AND (#ii_GIN <= 99) THEN
	                #PieceID[37] := '0';
	                #PieceID[38] := '0';
	                #PieceID[39] := #ts_String[1];
	                #PieceID[40] := #ts_String[2];
	            ELSIF (#ii_GIN >= 100) AND (#ii_GIN <= 999) THEN
	                #PieceID[37] := '0';
	                #PieceID[38] := #ts_String[1];
	                #PieceID[39] := #ts_String[2];
	                #PieceID[40] := #ts_String[3];
	            ELSIF (#ii_GIN >= 1000) AND (#ii_GIN <= 9999) THEN
	                #PieceID[37] := #ts_String[1];
	                #PieceID[38] := #ts_String[2];
	                #PieceID[39] := #ts_String[3];
	                #PieceID[40] := #ts_String[4];
	            END_IF;
	            
	            //Save data in DB GIN
	            "DB_GIN".GIN[#ii_GIN].DHL.PieceID := #PieceID;
	            "DB_GIN".GIN[#ii_GIN].DHL.VID := '000000000000000';
	            
	            IF "DB_GIN".GIN[#ii_GIN].DHL.ObjectID = '' THEN
	                "DB_GIN".GIN[#ii_GIN].DHL.ObjectID := '0000000000';
	            END_IF;
	            
	            //Generate a message to MFC
	            #FB_MFC_Sort_COY_ReceiveResult_Instance(is_VID := "DB_GIN".GIN[#ii_GIN].DHL.VID,
	                                                    is_PieceID := "DB_GIN".GIN[#ii_GIN].DHL.PieceID,
	                                                    is_Group := "DB_GIN".GIN[#ii_GIN].DHL.Xray.Group,
	                                                    is_Level := "DB_GIN".GIN[#ii_GIN].DHL.Xray.Level,
	                                                    is_Result := "DB_GIN".GIN[#ii_GIN].DHL.Xray.Result,
	                                                    ii_SourceNode := #ii_SourceNode,
	                                                    ii_DestinationNode := #ii_DestinationNode,
	                                                    iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                                                    iqa_FifoData := #iqa_FifoData,
	                                                    iqi_MessageSequenceNumber := #iqi_MessageSequenceNumber);
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION Parcel lost
	    
	    //Check if parcel is lost in the tracking
	    //If there is, generate a message to MFC
	    
	    IF #ii_GIN > 0 THEN
	        
	        IF "DB_GIN".GIN[#ii_GIN].General.Lost THEN
	            
	            //FORTNA internal exception results: L = Parcel lost
	            "DB_GIN".GIN[#ii_GIN].DHL.Xray.Result := 'L';
	            
	            #FB_MFC_Sort_COY_ReceiveResult_Instance(is_VID := "DB_GIN".GIN[#ii_GIN].DHL.VID,
	                                                    is_PieceID := "DB_GIN".GIN[#ii_GIN].DHL.PieceID,
	                                                    is_Group := "DB_GIN".GIN[#ii_GIN].DHL.Xray.Group,
	                                                    is_Level := "DB_GIN".GIN[#ii_GIN].DHL.Xray.Level,
	                                                    is_Result := "DB_GIN".GIN[#ii_GIN].DHL.Xray.Result,
	                                                    ii_SourceNode := #ii_SourceNode,
	                                                    ii_DestinationNode := #ii_DestinationNode,
	                                                    iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                                                    iqa_FifoData := #iqa_FifoData,
	                                                    iqi_MessageSequenceNumber := #iqi_MessageSequenceNumber);
	            
	            //Save info in DB_GIN
	            "DB_GIN".GIN[#ii_GIN].DHL.MFCMessage.Sent.XrayResult := True;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_MergeGINandObjectID"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 240
// END_ATTRIBUTES
   VAR_INPUT 
      is_Configuration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Configuration
         SearchWindowStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Start of the search window in conveyor tracking
         SearchWindowEnd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // End of the search window in conveyor tracking
      END_STRUCT;
      iid_ReceivedObjectID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Received ObjectID form sorter
      ia_ConveyorTracking { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..2501] of Int;   // ConveyorTracking
      ii_XrayLocation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // X-ray location
      ii_SourceNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // ID Source Node
      ii_DestinationNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // ID Destination Node
   END_VAR

   VAR_IN_OUT 
      iq_UDT_FifoHeader : "UDT_FifoHeader";   // FIFO header
      iqa_FifoData : Array[*] of "UDT_MessageV2";   // FIFO data buffer
      iqi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Message number
   END_VAR

   VAR 
      sid_ObjectID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Saved Object ID
      sx_NewObjectID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      FB_MFC_Sort_COY_RegInfo_Instance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MFC_Sort_COY_RegInfo";
   END_VAR

   VAR_TEMP 
      ti_Loop : Int;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	05/10/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/03/2024  | 1.1       | S. Nieswiec  | Added to new Baseline
	*)
	
	REGION Save ObjectID
	    
	    IF #iid_ReceivedObjectID <> #sid_ObjectID THEN
	        
	        //New data
	        #sx_NewObjectID := True;
	        
	        //Copy data to memory 
	        #sid_ObjectID := #iid_ReceivedObjectID;
	        
	    END_IF;
	    
	END_REGION
	
	REGION Merge data
	    
	    IF #sx_NewObjectID THEN
	        
	        FOR #ti_Loop := #is_Configuration.SearchWindowStart TO #is_Configuration.SearchWindowEnd DO
	            
	            IF #ia_ConveyorTracking[#ti_Loop] <> 0
	                AND ("DB_GIN".GIN[#ia_ConveyorTracking[#ti_Loop]].DHL.ObjectID = '')
	            THEN
	                
	                //Combine data, save Object ID in DB GIN
	                "DB_GIN".GIN[#ia_ConveyorTracking[#ti_Loop]].DHL.ObjectID := DELETE(IN := DINT_TO_STRING(#sid_ObjectID), L := 1, P := 1);
	                
	                //Data combined
	                #sx_NewObjectID := FALSE;
	                
	                //Send a message to the MFC requesting information on the parcel
	                #FB_MFC_Sort_COY_RegInfo_Instance(is_ObjectID := "DB_GIN".GIN[#ia_ConveyorTracking[#ti_Loop]].DHL.ObjectID,
	                                                  ii_XrayLocation := #ii_XrayLocation,
	                                                  ii_SourceNode := #ii_SourceNode,
	                                                  ii_DestinationNode := #ii_DestinationNode,
	                                                  iq_UDT_FifoHeader := #iq_UDT_FifoHeader,
	                                                  iqa_FifoData := #iqa_FifoData,
	                                                  iqi_MessageSequenceNumber := #iqi_MessageSequenceNumber);
	                
	                //Save information in DB GIN
	                "DB_GIN".GIN[#ia_ConveyorTracking[#ti_Loop]].DHL.MFCMessage.Sent.ParcelRegInfo := True;
	                
	                //Exit loop
	                EXIT;
	                
	            END_IF;
	            
	        END_FOR;
	        
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_SpecialHandlingArea"
TITLE = PLC0020 - DHL Munich
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'R. Golonka'
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 103
// END_ATTRIBUTES
//Block for special handling area
   VAR_INPUT 
      i_UDT_ConveyorHandshakeUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorHandshake";
      iudi_DelayTransferTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Additional transfer time
      ix_KneeButton { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Input knee button conveyor 3
      ix_MannedButton { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Check in button to inform system about manned system
      ix_PEC_DownstreamEoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Downstream sensor end of section signal
      ix_PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sensor end of section signal
      ix_PEC_UpsteamEoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Upstream sensor end of section signal
      ix_LastStation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Last station
   END_VAR

   VAR_OUTPUT 
      q_UDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_SHAStatus";   // SHA status
      qx_SygnalingLamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // White lamp demmand
      qx_PushButtonLamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Push button lamp
      qx_ExternalDieback_1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External die back signal output
      qx_ExternalDieback_2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External die back signal output
      qx_ExternalDieback_3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External die back signal output
      qx_ExternalDiebackUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External die back signal output
   END_VAR

   VAR_IN_OUT 
      iq_UDT_SHAInterfaceUp : "UDT_SHA_StationInterface";   // SHA interface
      iq_UDT_SHAInterface : "UDT_SHA_StationInterface";   // SHA interface
      iq_UDT_DownstreamConveyorHandshake : "UDT_ConveyorHandshake";   // Conveyor interface
      iq_UDT_ConveyorHandshake : "UDT_ConveyorHandshake";   // Conveyor interface
      iq_UDT_UpstreamConveyorHandshake : "UDT_ConveyorHandshake";   // Conveyor interface
   END_VAR

   VAR 
      FB_TimerOnOffDelay_TransferInprogres { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Additional timer time
      s_UDT_SHAInterface { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_SHA_StationInterface";   // Special handling area inteface
      s_UDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_SHAStatus";   // SHA status
      R_TRIG_KneeButton {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge knee button signal
      R_TRIG_MannedButton {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge manned button signal
      R_TRIG_TIPUp {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      R_TRIG_TIPDown {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      R_TRIG_TIP {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      "#R_TRIG_RTSUp" {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      sx_SygnalingLamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // White lamp demmand
      sx_PushButtonLamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Push button lamp
      sx_ExternalDieback_1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External dieback signal
      sx_ExternalDieback_2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External dieback signal
      sx_ExternalDieback_3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External dieback signal
      sx_ProductIsLocked { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Product is locked to the station
      sx_StationManned { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Station is occupied
      sx_DownstreamConveyorOccupied { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Downstream conveyor is occupied
      sx_MiddleConveyorOccupied { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Middle conveyor is occupied
      sx_UpstreamConveyorOccupied { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Upsteram conveyor is occupied
      si_NumberOfParcel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Number of parcel
      sx_ParcelTransfer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Transfer in one section is in progress
      sx_ExternalDiebackUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Die back to previous station
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	06/10/2023  | 1.0       | R. Golonka   | Release TIA 17 | DHL Munich 2023
	13/03/2024  | 1.1       | S. Nieswiec  | Added to new baseline, block needs uptade after munich is finished
	*)
	
	REGION 1.0 - Inicialization
	    // Inicialization
	    
	    #R_TRIG_KneeButton(CLK := #ix_KneeButton);
	    #R_TRIG_MannedButton(CLK := #ix_MannedButton);
	    #R_TRIG_TIPUp(CLK := #iq_UDT_UpstreamConveyorHandshake.TIP);
	    #R_TRIG_TIPDown(CLK := #iq_UDT_DownstreamConveyorHandshake.TIP);
	    #R_TRIG_TIP(CLK := #iq_UDT_ConveyorHandshake.TIP);
	    #"#R_TRIG_RTSUp"(CLK := #iq_UDT_ConveyorHandshake.RTS);
	    
	END_REGION
	
	REGION 2.0 - Station manned
	    
	    // Station in occupied (operator is working)
	    IF #R_TRIG_MannedButton.Q AND #iq_UDT_SHAInterfaceUp.Manned THEN
	        
	        #sx_StationManned := NOT #sx_StationManned;
	        #sx_PushButtonLamp := NOT #sx_PushButtonLamp;
	        
	    ELSIF (#iq_UDT_SHAInterfaceUp.Manned = false) THEN
	        
	        #sx_StationManned := FALSE;
	        #sx_PushButtonLamp := FALSE;
	        
	    ELSIF #ix_LastStation THEN
	        
	        #sx_StationManned := #ix_LastStation;
	        #sx_PushButtonLamp := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3.0 - Product locked and unlocked 
	    
	    // Product is locked in to the station
	    IF #R_TRIG_KneeButton.Q AND #sx_StationManned AND NOT #ix_PEC_DownstreamEoS THEN
	        
	        #sx_ProductIsLocked := NOT #sx_ProductIsLocked;
	        #sx_SygnalingLamp := NOT #sx_SygnalingLamp;
	    ELSIF #R_TRIG_KneeButton.Q AND #sx_StationManned THEN
	        #sx_ProductIsLocked := false;
	        #sx_SygnalingLamp := false;
	    END_IF;
	    
	END_REGION
	
	REGION 4.0 - Parcel in station 
	    
	    // Downstream station is occupied 
	    #sx_DownstreamConveyorOccupied := NOT #ix_PEC_DownstreamEoS;
	    #sx_MiddleConveyorOccupied := NOT #ix_PEC_EoS;
	    #sx_UpstreamConveyorOccupied := NOT #ix_PEC_UpsteamEoS;
	    
	    IF (#sx_DownstreamConveyorOccupied OR #sx_ProductIsLocked) THEN
	        #si_NumberOfParcel := 1;
	    END_IF;
	    
	    IF (#sx_MiddleConveyorOccupied AND (#sx_DownstreamConveyorOccupied OR #sx_ProductIsLocked)) THEN
	        #si_NumberOfParcel := 2;
	    END_IF;
	    
	    IF (#sx_UpstreamConveyorOccupied AND #sx_MiddleConveyorOccupied AND (#sx_DownstreamConveyorOccupied OR #sx_ProductIsLocked)) THEN
	        #si_NumberOfParcel := 3;
	    END_IF;
	    
	    IF NOT #sx_UpstreamConveyorOccupied AND NOT #sx_MiddleConveyorOccupied AND NOT #sx_DownstreamConveyorOccupied THEN
	        #si_NumberOfParcel := 0;
	    END_IF;
	    
	END_REGION
	
	REGION 5.0 - External dieback
	    
	    IF #sx_StationManned
	        AND (#si_NumberOfParcel >= 3)
	        AND (#iq_UDT_SHAInterfaceUp.NumberOfParcel >= #si_NumberOfParcel)
	        AND #s_UDT_SHAInterface.Conveyor[2].Occupied
	        AND #s_UDT_SHAInterface.Conveyor[1].Occupied
	        
	        OR #iq_UDT_SHAInterfaceUp.Conveyor[1].Locked
	        OR #sx_ProductIsLocked
	    THEN
	        #sx_ExternalDieback_1 := TRUE;
	    ELSE
	        #sx_ExternalDieback_1 := FALSE;
	    END_IF;
	    
	    IF #sx_StationManned
	        AND (#si_NumberOfParcel >= 2)
	        AND (#iq_UDT_SHAInterfaceUp.NumberOfParcel >= #si_NumberOfParcel)
	        AND #s_UDT_SHAInterface.Conveyor[1].Occupied
	        
	        OR #iq_UDT_SHAInterfaceUp.Conveyor[1].Locked
	        OR #sx_ProductIsLocked
	    THEN
	        #sx_ExternalDieback_2 := TRUE;
	    ELSE
	        #sx_ExternalDieback_2 := FALSE;
	    END_IF;
	    
	    IF #sx_StationManned
	        AND (#si_NumberOfParcel >= 1)
	        AND (#iq_UDT_SHAInterfaceUp.NumberOfParcel >= #si_NumberOfParcel)
	        AND NOT #ix_PEC_DownstreamEoS
	        AND #iq_UDT_SHAInterfaceUp.Conveyor[1].Occupied
	        //AND #iq_UDT_SHAInterfaceUp.NumberOfParcel <> 0
	        OR #iq_UDT_SHAInterfaceUp.Conveyor[1].Locked
	        OR #sx_ProductIsLocked
	    THEN
	        #sx_ExternalDieback_3 := TRUE;
	    ELSIF #sx_StationManned AND (NOT #ix_PEC_DownstreamEoS AND #ix_LastStation) THEN
	        #sx_ExternalDieback_3 := TRUE;
	    ELSE
	        #sx_ExternalDieback_3 := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 8.0 - Reset RTR 
	    
	    // Set RTR to run conveyor
	    
	    IF NOT #sx_DownstreamConveyorOccupied AND #ix_KneeButton AND #sx_StationManned THEN
	        #iq_UDT_DownstreamConveyorHandshake.RTR := true;
	    END_IF;
	    
	    IF NOT #sx_MiddleConveyorOccupied AND #ix_KneeButton AND #sx_StationManned THEN
	        #iq_UDT_ConveyorHandshake.RTR := true;
	    END_IF;
	    
	    IF NOT #sx_UpstreamConveyorOccupied AND #ix_KneeButton AND #sx_StationManned THEN
	        #iq_UDT_UpstreamConveyorHandshake.RTR := true;
	    END_IF;
	    
	END_REGION
	
	REGION 7.0 - Hold for previous station when station is in transfer
	    
	    #sx_ParcelTransfer := (#R_TRIG_KneeButton.Q)
	    OR (#R_TRIG_TIPDown.Q)
	    OR (#R_TRIG_TIP.Q)
	    OR (#R_TRIG_TIPUp.Q);
	    
	    #FB_TimerOnOffDelay_TransferInprogres(iudi_OffDelayTime := #iudi_DelayTransferTime,
	                                          ix_SignalToDelay := #sx_ParcelTransfer,
	                                          ix_Enable := TRUE,
	                                          qx_DelayedSignal => #sx_ExternalDiebackUp);
	    
	END_REGION
	
	REGION 8.0 - Update Interface
	    
	    #s_UDT_SHAInterface.Manned := #sx_StationManned;
	    #s_UDT_SHAInterface.NumberOfParcel := #si_NumberOfParcel;
	    #s_UDT_SHAInterface.TransferInProgres := #sx_ParcelTransfer;
	    #s_UDT_SHAInterface.Conveyor[1].Empty := NOT #sx_DownstreamConveyorOccupied;
	    #s_UDT_SHAInterface.Conveyor[1].Locked := #sx_ProductIsLocked;
	    #s_UDT_SHAInterface.Conveyor[1].Occupied := #sx_DownstreamConveyorOccupied;
	    #s_UDT_SHAInterface.Conveyor[2].Empty := NOT #sx_MiddleConveyorOccupied;
	    #s_UDT_SHAInterface.Conveyor[2].Locked := FALSE;
	    #s_UDT_SHAInterface.Conveyor[2].Occupied := #sx_MiddleConveyorOccupied;
	    #s_UDT_SHAInterface.Conveyor[3].Empty := NOT #sx_UpstreamConveyorOccupied;
	    #s_UDT_SHAInterface.Conveyor[3].Locked := FALSE;
	    #s_UDT_SHAInterface.Conveyor[3].Occupied := #sx_UpstreamConveyorOccupied;
	    
	END_REGION
	
	REGION 9.0 - Status
	    
	    // Status half full 
	    #s_UDT_HMIStatus.Specific.HalfFull := #sx_StationManned AND (#s_UDT_SHAInterface.NumberOfParcel >= 3);
	    // Status full 
	    #s_UDT_HMIStatus.Specific.Full := #sx_StationManned AND (#iq_UDT_SHAInterfaceUp.NumberOfParcel >= 3) AND (#s_UDT_SHAInterface.NumberOfParcel >= 3) AND #i_UDT_ConveyorHandshakeUp.RTS;
	    
	    // HMI status initialization
	    #s_UDT_HMIStatus.Status := 0;
	    
	    // Copy HMI status to output
	    #q_UDT_HMIStatus := #s_UDT_HMIStatus;
	    
	END_REGION
	
	REGION 10.0 - Output 
	    
	    // Output write
	    #qx_ExternalDieback_1 := #sx_ExternalDieback_1;
	    #qx_ExternalDieback_2 := #sx_ExternalDieback_2;
	    #qx_ExternalDieback_3 := #sx_ExternalDieback_3;
	    #qx_ExternalDiebackUp := #sx_ExternalDiebackUp AND #i_UDT_ConveyorHandshakeUp.RTS;
	    #qx_SygnalingLamp := #sx_SygnalingLamp;
	    #qx_PushButtonLamp := #sx_PushButtonLamp;
	    #iq_UDT_SHAInterface := #s_UDT_SHAInterface;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_SNCY_InfeedControlPanel"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 102
// END_ATTRIBUTES
   VAR_INPUT 
      ix_InfeedButton { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Signal from infeed push button
      ix_OutfeedButton { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Signal from outfeed push button
      i_UDT_ExitConveyorStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   // Common status from outfeed exit conveyor
      ix_InfeedModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - when infeed mode is active
      ix_OutfeedModeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - when outfeed mode is active
   END_VAR

   VAR_OUTPUT 
      qx_InfeedLamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Lamp for Infeed status
      qx_OutfeedLamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Lamp for Outfeed status
      qx_ConveyorHold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor hold command for associated conveyor
   END_VAR

   VAR 
      R_TRIG_ToogleInfeedButton {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger infeed button
      R_TRIG_ToogleOutfeedButton {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger outfeed button
      R_TRIG_Modeline {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger mode line
      sx_SectionHold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             Fortna Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |
	|                                                                                      |     
	----------------------------------------------------------------------------------------
	                        
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	18/10/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/03/2024  | 1.1       | S. Nieswiec  | Added to new baseline, block needs uptade after munich is finished
	*)
	
	REGION Buttons
	    
	    //Infeed
	    IF #ix_InfeedModeActive THEN
	        
	        #R_TRIG_ToogleInfeedButton(CLK := (#ix_InfeedButton));
	        
	        IF #R_TRIG_ToogleInfeedButton.Q THEN
	            
	            #sx_SectionHold := NOT #sx_SectionHold;
	            
	        END_IF;
	        
	    END_IF;
	    
	    //Outfeed
	    IF #ix_OutfeedModeActive THEN
	        
	        #R_TRIG_ToogleOutfeedButton(CLK := (#ix_OutfeedButton));
	        
	        IF #R_TRIG_ToogleOutfeedButton.Q THEN
	            
	            #sx_SectionHold := NOT #sx_SectionHold;
	            
	        END_IF;
	        
	    END_IF;
	    
	END_REGION
	
	REGION Lamps
	    
	    //Infeed
	    IF #ix_InfeedModeActive THEN
	        
	        IF #sx_SectionHold THEN
	            #qx_InfeedLamp := "DB_Memory".Clock_1Hz;
	        ELSE
	            #qx_InfeedLamp := TRUE;
	        END_IF;
	        
	    ELSE
	        #qx_InfeedLamp := False;
	    END_IF;
	    
	    //Outfeed
	    IF #ix_OutfeedModeActive THEN
	        
	        IF #sx_SectionHold THEN
	            #qx_OutfeedLamp := "DB_Memory".Clock_1Hz;
	        ELSE
	            #qx_OutfeedLamp := TRUE;
	        END_IF;
	        
	    ELSE
	        #qx_OutfeedLamp := False;
	    END_IF;
	    
	END_REGION
	
	REGION Conveyor hold command
	    
	    #qx_ConveyorHold := #sx_SectionHold;
	    
	END_REGION
	
	REGION Reset
	    
	    //Reset when mode line is changed
	    #R_TRIG_Modeline(CLK := #ix_InfeedModeActive OR #ix_OutfeedModeActive);
	    
	    IF #R_TRIG_Modeline.Q THEN
	        // Statement section IF
	        ;
	    END_IF;
	    
	    
	END_REGION
	
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_SNCY_ArmDiverter"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 241
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_DiverterArmConfig { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ArmDiverterConfiguration";   // Diverter arm configuration
      ix_SafetyOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when safety is ok
      ix_24vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 24VDC is healthy
      ix_400vOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when 400VAC is healthy
      ix_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when  hardware is Ok
      ix_PRX_Home { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Proxy sensor home position
      ix_PRX_Divert { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Proxy sensor divert position
      ix_LS_Home { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Limit switch home position
      ix_LS_Divert { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Limit switch divert position
      ix_PRX_BRK_Home { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Brake sensor divert
      ix_PRX_BRK_Divert { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Brake sensor home
      ix_PEC_Exit { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when PEC Exit is not blocked
      ii_SourceNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 0;   // Source Node
      ii_DestinationNode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 0;   // Destination Node
   END_VAR

   VAR_OUTPUT 
      q_UDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ArmDiverterStatus";   // HMI status structure
      q_UDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   // Common status structure
      qx_VerticalConveyorHold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command stop Vertical conveyor
      qx_AssociatedConveyorHold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command stop Associated conveyor
   END_VAR

   VAR_IN_OUT 
      iq_UDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
      iq_UDT_AssociatedConveyorInterface : "UDT_ConveyorInterface";   // Sorter main conveyor interface
      iq_UDT_VerticalConveyorInterface : "UDT_ConveyorInterface";   // Arm vertical conveyor interafce
      iq_UDT_ArmConveyorInterface : "UDT_ConveyorInterface";   // Arm conveyor interface
      iq_UDT_AssociatedConveyorHandshake : "UDT_ConveyorHandshake";   // Handshake structure
      iq_UDT_ExitConveyorHandshake : "UDT_ConveyorHandshake";   // Exit conveyor handshake structure
      iqa_AssociatedTrackingData : Array[*] of Int;   // Tracking data from sorter conveyor
      iqa_OutfeedsStatus : Array[*] of "UDT_OutfeedStatus";   // Structure with outfeeds status
      iq_UDT_ArmDiverterCommand : "UDT_ArmDiverterCommand";   // Arm Diverter command structure
      iq_UDT_FifoHeader_MFCMessage : "UDT_FifoHeader";   // MFC Message FIFO header
      iqs_FifoData_MFCMessage : Array[*] of "UDT_MessageV2";   // MFC Message FIFO data buffer
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // MFC Message Message number
   END_VAR

   VAR 
      FB_MFC_Sort_SortResult_HigherPriorityAvailable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MFC_Sort_SortResult";   // Function to MFC message generation
      FB_MFC_Sort_SortResult { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MFC_Sort_SortResult";   // Function to MFC message generation
      FB_MFC_Sort_SortResult_Instance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MFC_Sort_SortResult";   // Function to MFC message generation
      s_FB_PRX_HomeFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Filtering proxy sensor home position signal
      s_FB_PRX_DivertFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Filtering proxy sensor divert position signal
      s_FB_LS_HomeFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Filtering limit switch home position signal
      s_FB_LS_DivertFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Filtering limit switch divert position signal
      s_FB_BRK_PRX_HomeFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Filtering proxy sensor home position signal
      s_FB_BRK_PRX_DivertFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Filtering proxy sensor divert position signal
      s_FB_TimeoutError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Movement timeout error
      s_FB_Jog_Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Filtering lower jam photo eye signal
      s_FB_DivertTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Divert time
      s_FB_InhibitTimeFilter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Filtering inhibit stop
      s_UDT_CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Common status structure
      s_UDT_CommonStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Auxiliary status structure
      s_UDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ArmDiverterStatus";   // HMI status structure
      R_TRIG_ManualJogHome {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger manual jog mode command
      R_TRIG_ManualJogDivert {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger manual jog mode command
      R_TRIG_PRX_Home {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger
      R_TRIG_PRX_Divert {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger
      R_TRIG_LS_Home {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger
      R_TRIG_LS_Divert {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger
      F_TRIG_PRX_Home {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger
      F_TRIG_PRX_Divert {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger
      F_TRIG_LS_Home {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger
      F_TRIG_LS_Divert {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger
      F_TRIG_BRK_PRX_Home {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger
      R_TRIG_BRK_PRX_Home {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger
      F_TRIG_BRK_PRX_Divert {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger
      R_TRIG_BRK_PRX_Divert {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger
      R_TRIG_ExitSensor {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of exit sensor
      F_TRIG_ArmConveyorLowSpeed {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger
      R_TRIG_ParcelLocation {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger
      ss_Counter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Counters for statistics
         ParcelDetected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // New package was detected
         ParcelInWindow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Another parcel is within the range of arm movement. The parcel cannot be sorted.
         SortParcelCommand { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;
         SortResultMessage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;
         LoopExit { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;
      END_STRUCT;
      ss_SortStrategy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Sort Strategy
         HigherPriorityAvailable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         ObjectID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[10];
      END_STRUCT;
      ss_SortedObjectID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[10];   // Stored value of the last Object ID
      si_GINSort { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 1;   // GIN code
      si_OutfeedsNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Number of connected outfeeds
      si_SortParcelEndPositon { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Sort parcel end positon
      si_DecisionPointGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Decision point GIN
      si_DecisionPointGINDistance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Decision point GIN distance
      si_LocationGIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Location GIN
      sx_AutoArmDivert { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Command arm should turn to "Divert position", command generated in auto mode
      sx_AutoArmHome { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Command arm should turn to "Home position", command generated in auto mode
      sx_Ready { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Ready to operate in Automatic mode
      sx_NewParcel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - new parcel was detected
      sx_ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - the configuration error occured
      sx_ArmDiverterLowSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Arm diverter low speed
      sx_Disabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - if the functionality is disabled
      sx_PiorityDestinationNOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - when Previous destination unavailable
      sx_ActualArmPositionHome { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - if the arm is set in the Home position
      sx_ActualArmPositionOnWay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - if the arm is set in the way on position
      sx_ActualArmPositionDivert { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - if the arm is set in the Extended position
      sx_MoveToHomePosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command in automatic mode - Move to home position
      sx_MoveToDivertPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command in automatic mode - Move to divert position
      sx_ManualToHomePosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command in manual mode - Move to home position
      sx_ManualToDivertPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command in manual mode - Move to divert position
      sx_JogToHomePosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command in jog mode - Move to home position
      sx_JogToDivertPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command in jog mode - Move to divert position
      sx_PRX_HomeFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Proxy sensor home position filtered
      sx_PRX_DivertFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Proxy sensor divert position filtered
      sx_LS_HomeFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Limit switch home position filtered
      sx_LS_DivertFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Limit switch divert position filtered
      sx_PRX_BRK_HomeFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Brake sensor home filtered
      sx_PRX_BRK_DivertFiltered { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Brake sensor divert filtered
      sx_SwitchEnable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Switching conditions
      sx_ParcelSorted { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parcel in area
      sx_LimitSwitchHomeReached { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Limit switch home reached
      sx_LimitSwitchDivertReached { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Limit switch divert reached
      sx_PositionHomeReached { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Position home reached
      sx_PositionDivertReached { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Position divert reached
      sx_ParcelInWindow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parcel in window
      sx_GenerationMessage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Generation MFC message
   END_VAR

   VAR_TEMP 
      ti_LoopOutfeeds : Int;   // Loop counter
      ti_LoopDestination : Int;   // Loop counter
      ti_LoopDestinationNearest : Int;   // Loop counter
      ti_LoopParcelFreeArea : Int;   // Loop counter
      ti_LoopParcel : Int;   // Loop counter
      ti_LoopResult : Int;   // Loop counter
      tx_MovementCommandActive : Bool;   // Movement command active
   END_VAR

   VAR CONSTANT 
      ci_DestinationNumberMin : Int := 350;   // Minimum number of available destination
      ci_DestinationNumberMax : Int := 356;   // Maximum number of available destination
      ci_OutfeedNumberMax : Int := 6;   // Maximum number of Outfeeds
      cs_SortStrategyNearest : String := '2';   // Value of sort strategy nearest
      cs_SortStrategyHighestPriority : String := '1';   // Value of sort strategy highest priority
      cudi_InhibitTimeFilterTimeOFF : UDInt := 1500;   // Time to stop
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	06/06/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	10/08/2023  | 1.1       | S. Nikodem   | Sort Strategy 
	17/10/2023  | 1.2       | S. Nikodem   | Added brake sensors and local reset
	13/03/2024  | 1.3       | S. Nieswiec  | Added to new baseline, block needs uptade after munich is finished
	
	*)
	
	REGION 1 - Triggers / Filters
	    
	    //Triggers
	    //Proxy sensor home position
	    //Rising edge trigger
	    #R_TRIG_PRX_Home(CLK := #sx_PRX_HomeFiltered);
	    //Falling edge trigger
	    #F_TRIG_PRX_Home(CLK := #sx_PRX_HomeFiltered);
	    
	    //Proxy sensor divert position
	    //Rising edge trigger
	    #R_TRIG_PRX_Divert(CLK := #sx_PRX_DivertFiltered);
	    //Falling edge trigger
	    #F_TRIG_PRX_Divert(CLK := #sx_PRX_DivertFiltered);
	    
	    //Limit switch home position
	    //Rising edge trigger
	    #R_TRIG_LS_Home(CLK := #sx_LS_HomeFiltered);
	    //Falling edge trigger
	    #F_TRIG_LS_Home(CLK := #sx_LS_HomeFiltered);
	    
	    //Limit switch divert position
	    //Rising edge trigger
	    #R_TRIG_LS_Divert(CLK := #sx_LS_DivertFiltered);
	    //Falling edge trigger
	    #F_TRIG_LS_Divert(CLK := #sx_LS_DivertFiltered);
	    
	    //Brake sensor home position
	    //Rising edge trigger
	    #R_TRIG_BRK_PRX_Home(CLK := #sx_PRX_BRK_HomeFiltered);
	    //Falling edge trigger
	    #F_TRIG_BRK_PRX_Home(CLK := #sx_PRX_BRK_HomeFiltered);
	    
	    //Brake sensor divert position
	    //Rising edge trigger
	    #R_TRIG_BRK_PRX_Divert(CLK := #sx_PRX_BRK_DivertFiltered);
	    //Falling edge trigger
	    #F_TRIG_BRK_PRX_Divert(CLK := #sx_PRX_BRK_DivertFiltered);
	    
	    //Exit sensor
	    #R_TRIG_ExitSensor(CLK := #ix_PEC_Exit);
	    
	    //On/off Filters
	    //Proxy sensor home position
	    #s_FB_PRX_HomeFiltered(iudi_OnDelayTime := #i_UDT_DiverterArmConfig.Sensor.PRX_HomeTimeOnDelay,
	                           iudi_OffDelayTime := #i_UDT_DiverterArmConfig.Sensor.PRX_HomeTimeOffDelay,
	                           ix_SignalToDelay := #ix_PRX_Home,
	                           ix_Enable := TRUE,
	                           qx_DelayedSignal => #sx_PRX_HomeFiltered);
	    
	    //Proxy sensor divert position
	    #s_FB_PRX_DivertFiltered(iudi_OnDelayTime := #i_UDT_DiverterArmConfig.Sensor.PRX_DivertTimeOnDelay,
	                             iudi_OffDelayTime := #i_UDT_DiverterArmConfig.Sensor.PRX_DivertTimeOffDelay,
	                             ix_SignalToDelay := #ix_PRX_Divert,
	                             ix_Enable := TRUE,
	                             qx_DelayedSignal => #sx_PRX_DivertFiltered);
	    
	    //Limit switch home position
	    #s_FB_LS_HomeFiltered(iudi_OnDelayTime := #i_UDT_DiverterArmConfig.Sensor.LS_HomeTimeOnDelay,
	                          iudi_OffDelayTime := #i_UDT_DiverterArmConfig.Sensor.LS_HomeTimeOffDelay,
	                          ix_SignalToDelay := #ix_LS_Home,
	                          ix_Enable := TRUE,
	                          qx_DelayedSignal => #sx_LS_HomeFiltered);
	    
	    //Limit switch divert position
	    #s_FB_LS_DivertFiltered(iudi_OnDelayTime := #i_UDT_DiverterArmConfig.Sensor.LS_DivertTimeOnDelay,
	                            iudi_OffDelayTime := #i_UDT_DiverterArmConfig.Sensor.LS_DivertTimeOffDelay,
	                            ix_SignalToDelay := #ix_LS_Divert,
	                            ix_Enable := TRUE,
	                            qx_DelayedSignal => #sx_LS_DivertFiltered);
	    
	    //Brake sensor home
	    #s_FB_BRK_PRX_HomeFiltered(iudi_OnDelayTime := #i_UDT_DiverterArmConfig.Sensor.PRX_BRK_HomeTimeOnDelay,
	                               iudi_OffDelayTime := #i_UDT_DiverterArmConfig.Sensor.PRX_BRK_HomeTimeOffDelay,
	                               ix_SignalToDelay := #ix_PRX_BRK_Home,
	                               ix_Enable := TRUE,
	                               qx_DelayedSignal => #sx_PRX_BRK_HomeFiltered);
	    
	    //Brake sensor divert 
	    #s_FB_BRK_PRX_DivertFiltered(iudi_OnDelayTime := #i_UDT_DiverterArmConfig.Sensor.PRX_BRK_DivertTimeOnDelay,
	                                 iudi_OffDelayTime := #i_UDT_DiverterArmConfig.Sensor.PRX_BRK_DivertTimeOffDelay,
	                                 ix_SignalToDelay := #ix_PRX_BRK_Divert,
	                                 ix_Enable := TRUE,
	                                 qx_DelayedSignal => #sx_PRX_BRK_DivertFiltered);
	    
	END_REGION
	
	REGION 2 - Configuration check
	    
	    // Get size of the array.
	    #si_OutfeedsNumber := "FC_GetNrOfArrayEl"(#iqa_OutfeedsStatus);
	    
	    // Check configuration
	    #sx_ConfigurationError := (#i_UDT_DiverterArmConfig.VerticalConveyorMode <= 0)
	    OR (#i_UDT_DiverterArmConfig.VerticalConveyorMode > 2)
	    OR (#i_UDT_DiverterArmConfig.ArmDiverterSpeedSetpointLow <= 0)
	    OR (#i_UDT_DiverterArmConfig.ArmDiverterSpeedSetpointNominal <= 0)
	    OR (#i_UDT_DiverterArmConfig.DecisionPoint <= 0)
	    OR (#i_UDT_DiverterArmConfig.ParcelFreeWindowStart <= 0)
	    OR (#i_UDT_DiverterArmConfig.ParcelFreeWindowEnd <= 0)
	    OR (#i_UDT_DiverterArmConfig.DataTransferPoint <= 0)
	    OR (#i_UDT_DiverterArmConfig.MaximumMovementTime <= 0)
	    OR (#i_UDT_DiverterArmConfig.DischargeLocationID < #ci_DestinationNumberMin)
	    OR (#i_UDT_DiverterArmConfig.DischargeLocationID > #ci_DestinationNumberMax)
	    OR (#i_UDT_DiverterArmConfig.OutfeedsNumber <= 0)
	    OR (#i_UDT_DiverterArmConfig.OutfeedsNumber > #ci_OutfeedNumberMax)
	    OR (#si_OutfeedsNumber > #ci_OutfeedNumberMax);
	    
	END_REGION
	
	REGION 3 - Parcel location 
	    
	    //Save GIN number 
	    IF #si_LocationGIN <> #iqa_AssociatedTrackingData[#i_UDT_DiverterArmConfig.DecisionPoint]
	        AND NOT (#iqa_AssociatedTrackingData[#i_UDT_DiverterArmConfig.DecisionPoint] = 0)
	    THEN
	        
	        #si_LocationGIN := #iqa_AssociatedTrackingData[#i_UDT_DiverterArmConfig.DecisionPoint];
	        
	    END_IF;
	    
	    IF #iqa_AssociatedTrackingData[#i_UDT_DiverterArmConfig.DecisionPoint] <> 0 THEN
	        //Copy current parcel location to DB_GIN
	        "DB_GIN".GIN[#iqa_AssociatedTrackingData[#i_UDT_DiverterArmConfig.DecisionPoint]].DHL.ParcelLocation.Current := #i_UDT_DiverterArmConfig.DischargeLocationID;
	    END_IF;
	    
	    //Check when the package leaving the "decision point"
	    #R_TRIG_ParcelLocation(CLK := #iqa_AssociatedTrackingData[#i_UDT_DiverterArmConfig.DecisionPoint] = 0);
	    
	    IF #R_TRIG_ParcelLocation.Q AND #si_LocationGIN > 0 THEN
	        
	        //Reset value
	        "DB_GIN".GIN[#si_LocationGIN].DHL.ParcelLocation.Current := 0;
	        //Save last position 
	        "DB_GIN".GIN[#si_LocationGIN].DHL.ParcelLocation.Last := #i_UDT_DiverterArmConfig.DischargeLocationID;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 2 - Decision Point
	    
	    IF NOT #sx_ConfigurationError
	        AND NOT #sx_Disabled
	        AND #iqa_AssociatedTrackingData[#i_UDT_DiverterArmConfig.DecisionPoint] > 0
	    THEN
	        
	        
	        IF #si_DecisionPointGIN <> #iqa_AssociatedTrackingData[#i_UDT_DiverterArmConfig.DecisionPoint] THEN
	            #si_DecisionPointGIN := #iqa_AssociatedTrackingData[#i_UDT_DiverterArmConfig.DecisionPoint];
	            //Reset
	            #si_DecisionPointGINDistance := 0;
	        ELSIF #si_DecisionPointGIN = #iqa_AssociatedTrackingData[#i_UDT_DiverterArmConfig.DecisionPoint] THEN
	            //Count up distance 
	            #si_DecisionPointGINDistance += #iq_UDT_AssociatedConveyorInterface.Displacement;
	        END_IF;
	        
	        
	        //New parcel
	        IF ("DB_GIN".GIN[#iqa_AssociatedTrackingData[#i_UDT_DiverterArmConfig.DecisionPoint]].DHL.ObjectID <> #ss_SortedObjectID)
	            AND #si_DecisionPointGINDistance < #i_UDT_DiverterArmConfig.DecisionParcelWindow
	            AND #sx_ActualArmPositionHome
	        THEN
	            
	            //Check the area where the arm moves to ensure there isn't a package there
	            FOR #ti_LoopParcelFreeArea := #i_UDT_DiverterArmConfig.ParcelFreeWindowStart TO #i_UDT_DiverterArmConfig.ParcelFreeWindowEnd DO
	                
	                //Area occupied by another parcel
	                IF #iqa_AssociatedTrackingData[#ti_LoopParcelFreeArea] > 0
	                    AND NOT (#iqa_AssociatedTrackingData[#ti_LoopParcelFreeArea] = #iqa_AssociatedTrackingData[#i_UDT_DiverterArmConfig.DecisionPoint])
	                THEN
	                    
	                    //Another parcel is within the range of arm movement. The parcel cannot be sorted. 
	                    #sx_ParcelInWindow := TRUE;
	                    
	                    //Counter only for statistics
	                    #ss_Counter.ParcelDetected += 1;
	                    
	                END_IF;
	                
	            END_FOR;
	            
	            //Check window after sort parcel
	            IF #i_UDT_DiverterArmConfig.ParcelFreeWindow > 0 THEN
	                
	                //Find end of parcel in tracking 
	                FOR #ti_LoopParcelFreeArea := 0 TO DINT_TO_INT(#i_UDT_DiverterArmConfig.AssociatedConveyorLength) DO
	                    
	                    IF #iqa_AssociatedTrackingData[#ti_LoopParcelFreeArea] = #iqa_AssociatedTrackingData[#i_UDT_DiverterArmConfig.DecisionPoint]
	                        AND #si_SortParcelEndPositon < #ti_LoopParcelFreeArea
	                    THEN
	                        
	                        #si_SortParcelEndPositon := #ti_LoopParcelFreeArea;
	                        
	                    END_IF;
	                    
	                END_FOR;
	                
	                //Check if from sort parcel to the next parcel is enough place
	                FOR #ti_LoopParcel := #si_SortParcelEndPositon TO #si_SortParcelEndPositon + #i_UDT_DiverterArmConfig.ParcelFreeWindow DO
	                    
	                    IF #iqa_AssociatedTrackingData[#ti_LoopParcel] <> 0
	                        AND NOT (#iqa_AssociatedTrackingData[#ti_LoopParcel] = #iqa_AssociatedTrackingData[#i_UDT_DiverterArmConfig.DecisionPoint])
	                    THEN
	                        
	                        //Another parcel is within the range of arm movement. The parcel cannot be sorted. 
	                        #sx_ParcelInWindow := TRUE;
	                        
	                        //Counter only for statistics
	                        #ss_Counter.ParcelDetected += 1;
	                        
	                    END_IF;
	                    
	                END_FOR;
	                
	                //Reset 
	                #si_SortParcelEndPositon := 0;
	                
	            END_IF;
	            
	            IF NOT #sx_ParcelInWindow THEN
	                
	                //A new parcel is found check the destination
	                #sx_NewParcel := True;
	                //Copy Object ID to static memory
	                #ss_SortedObjectID := "DB_GIN".GIN[#iqa_AssociatedTrackingData[#i_UDT_DiverterArmConfig.DecisionPoint]].DHL.ObjectID;
	                #si_GINSort := #iqa_AssociatedTrackingData[#i_UDT_DiverterArmConfig.DecisionPoint];
	                //Counter only for statistics
	                #ss_Counter.ParcelDetected += 1;
	                
	            END_IF;
	            
	            // Reset
	            #sx_ParcelInWindow := False;
	            
	        END_IF;
	        
	        REGION 2.1 - Sort Strategy - Sequence - Highest priority available
	            //Add sort strategy - highest priority
	            //
	            //Add generation points 
	            
	            IF "DB_GIN".GIN[#si_GINSort].DHL.SortStrategy = #cs_SortStrategyHighestPriority AND #sx_NewParcel THEN
	                
	                //Check if the destination matches the parcel.
	                FOR #ti_LoopDestination := 1 TO 6 DO
	                    
	                    IF "DB_GIN".GIN[#si_GINSort].DHL.Destination[#ti_LoopDestination].ID = #i_UDT_DiverterArmConfig.DischargeLocationID THEN
	                        
	                        //The point is on the list of destinations
	                        #sx_GenerationMessage := TRUE;
	                        
	                    END_IF;
	                    
	                END_FOR;
	                
	                IF #sx_GenerationMessage THEN
	                    
	                    //A loop to search the destination structure for the parcel.
	                    FOR #ti_LoopDestination := 1 TO 6 DO
	                        
	                        //A loop to search the Outfeeds status structure
	                        FOR #ti_LoopOutfeeds := 1 TO 5 DO
	                            
	                            //Check destination
	                            IF ("DB_GIN".GIN[#si_GINSort].DHL.Destination[#ti_LoopDestination].ID = #iqa_OutfeedsStatus[#ti_LoopOutfeeds].ID)
	                            THEN
	                                
	                                IF ("DB_GIN".GIN[#si_GINSort].DHL.Destination[#ti_LoopDestination].ID = #i_UDT_DiverterArmConfig.DischargeLocationID)
	                                THEN
	                                    
	                                    //Check if the package can be sorted
	                                    IF (NOT #iqa_OutfeedsStatus[#ti_LoopOutfeeds].NotAvailable)
	                                        AND (NOT #iqa_OutfeedsStatus[#ti_LoopOutfeeds].Full)
	                                        AND (NOT #iqa_OutfeedsStatus[#ti_LoopOutfeeds].Disable)
	                                    THEN
	                                        
	                                        //Variable trigger - this parcel should be sorted.
	                                        #sx_AutoArmDivert := TRUE;
	                                        #sx_AutoArmHome := FALSE;
	                                        
	                                        //Set
	                                        "DB_GIN".GIN[#si_GINSort].DHL.Destination[#ti_LoopDestination].SortCommandActive := True;
	                                        
	                                        //Counter only for statistics
	                                        #ss_Counter.SortParcelCommand += 1;
	                                        
	                                        //Exit loop
	                                        EXIT;
	                                        
	                                        //Generation a message why the parcel has not been sorted
	                                    ELSIF (#iqa_OutfeedsStatus[#ti_LoopOutfeeds].NotAvailable)
	                                        OR (#iqa_OutfeedsStatus[#ti_LoopOutfeeds].Full)
	                                        OR (#iqa_OutfeedsStatus[#ti_LoopOutfeeds].Disable)
	                                    THEN
	                                        
	                                        //Generate a message to MFC why the parcel has not been sorted
	                                        IF #iqa_OutfeedsStatus[#ti_LoopOutfeeds].NotAvailable
	                                            OR #iqa_OutfeedsStatus[#ti_LoopOutfeeds].Disable
	                                        THEN
	                                            
	                                            #FB_MFC_Sort_SortResult(is_ObjectID := "DB_GIN".GIN[#si_GINSort].DHL.ObjectID,
	                                                                    ii_DischargeLocation := #iqa_OutfeedsStatus[#ti_LoopOutfeeds].ID,
	                                                                    ii_Result := 2,
	                                                                    ii_Reason := 3,
	                                                                    ii_SourceNode := #ii_SourceNode,
	                                                                    ii_DestinationNode := #ii_DestinationNode,
	                                                                    iq_UDT_FifoHeader := #iq_UDT_FifoHeader_MFCMessage,
	                                                                    iqs_FifoData := #iqs_FifoData_MFCMessage,
	                                                                    iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	                                            
	                                            //Save data in DB_GIN
	                                            "DB_GIN".GIN[#si_GINSort].DHL.Destination[#ti_LoopDestination].Rejected := True;
	                                            "DB_GIN".GIN[#si_GINSort].DHL.Destination[#ti_LoopDestination].Reason := 3;
	                                            
	                                            //Counter only for statistics
	                                            #ss_Counter.SortResultMessage += 1;
	                                            
	                                        END_IF;
	                                        
	                                        //Generate a message to MFC why the parcel has not been sorted
	                                        IF #iqa_OutfeedsStatus[#ti_LoopOutfeeds].Full THEN
	                                            
	                                            #FB_MFC_Sort_SortResult(is_ObjectID := "DB_GIN".GIN[#si_GINSort].DHL.ObjectID,
	                                                                    ii_DischargeLocation := #iqa_OutfeedsStatus[#ti_LoopOutfeeds].ID,
	                                                                    ii_Result := 2,
	                                                                    ii_Reason := 2,
	                                                                    ii_SourceNode := #ii_SourceNode,
	                                                                    ii_DestinationNode := #ii_DestinationNode,
	                                                                    iq_UDT_FifoHeader := #iq_UDT_FifoHeader_MFCMessage,
	                                                                    iqs_FifoData := #iqs_FifoData_MFCMessage,
	                                                                    iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	                                            
	                                            //Save data in DB_GIN
	                                            "DB_GIN".GIN[#si_GINSort].DHL.Destination[#ti_LoopDestination].Rejected := True;
	                                            "DB_GIN".GIN[#si_GINSort].DHL.Destination[#ti_LoopDestination].Reason := 2;
	                                            
	                                            //Counter only for statistics
	                                            #ss_Counter.SortResultMessage += 1;
	                                            
	                                        END_IF;
	                                        
	                                        
	                                    END_IF;
	                                    
	                                    //Generation a message why the parcel has not been sorted
	                                ELSIF (#iqa_OutfeedsStatus[#ti_LoopOutfeeds].NotAvailable)
	                                    OR (#iqa_OutfeedsStatus[#ti_LoopOutfeeds].Full)
	                                    OR (#iqa_OutfeedsStatus[#ti_LoopOutfeeds].Disable)
	                                THEN
	                                    
	                                    //Generate a message to MFC why the parcel has not been sorted
	                                    IF #iqa_OutfeedsStatus[#ti_LoopOutfeeds].NotAvailable
	                                        OR #iqa_OutfeedsStatus[#ti_LoopOutfeeds].Disable
	                                    THEN
	                                        
	                                        #FB_MFC_Sort_SortResult(is_ObjectID := "DB_GIN".GIN[#si_GINSort].DHL.ObjectID,
	                                                                ii_DischargeLocation := #iqa_OutfeedsStatus[#ti_LoopOutfeeds].ID,
	                                                                ii_Result := 2,
	                                                                ii_Reason := 3,
	                                                                ii_SourceNode := #ii_SourceNode,
	                                                                ii_DestinationNode := #ii_DestinationNode,
	                                                                iq_UDT_FifoHeader := #iq_UDT_FifoHeader_MFCMessage,
	                                                                iqs_FifoData := #iqs_FifoData_MFCMessage,
	                                                                iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	                                        
	                                        
	                                        //Save data in DB_GIN
	                                        "DB_GIN".GIN[#si_GINSort].DHL.Destination[#ti_LoopDestination].Rejected := True;
	                                        "DB_GIN".GIN[#si_GINSort].DHL.Destination[#ti_LoopDestination].Reason := 3;
	                                        
	                                        //Counter only for statistics
	                                        #ss_Counter.SortResultMessage += 1;
	                                        
	                                    END_IF;
	                                    
	                                    //Generate a message to MFC why the parcel has not been sorted
	                                    IF #iqa_OutfeedsStatus[#ti_LoopOutfeeds].Full THEN
	                                        
	                                        #FB_MFC_Sort_SortResult(is_ObjectID := "DB_GIN".GIN[#si_GINSort].DHL.ObjectID,
	                                                                ii_DischargeLocation := #iqa_OutfeedsStatus[#ti_LoopOutfeeds].ID,
	                                                                ii_Result := 2,
	                                                                ii_Reason := 2,
	                                                                ii_SourceNode := #ii_SourceNode,
	                                                                ii_DestinationNode := #ii_DestinationNode,
	                                                                iq_UDT_FifoHeader := #iq_UDT_FifoHeader_MFCMessage,
	                                                                iqs_FifoData := #iqs_FifoData_MFCMessage,
	                                                                iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	                                        
	                                        
	                                        //Save data in DB_GIN
	                                        "DB_GIN".GIN[#si_GINSort].DHL.Destination[#ti_LoopDestination].Rejected := True;
	                                        "DB_GIN".GIN[#si_GINSort].DHL.Destination[#ti_LoopDestination].Reason := 2;
	                                        
	                                        //Counter only for statistics
	                                        #ss_Counter.SortResultMessage += 1;
	                                        
	                                    END_IF;
	                                    
	                                    
	                                    // Check if the 'HigherPriority' destination is available 
	                                ELSIF (NOT #iqa_OutfeedsStatus[#ti_LoopOutfeeds].NotAvailable)
	                                    AND (NOT #iqa_OutfeedsStatus[#ti_LoopOutfeeds].Full)
	                                    AND (NOT #iqa_OutfeedsStatus[#ti_LoopOutfeeds].Disable)
	                                    AND ("DB_GIN".GIN[#si_GINSort].DHL.Destination[#ti_LoopDestination].ID < #i_UDT_DiverterArmConfig.DischargeLocationID)
	                                THEN
	                                    
	                                    //Set variable 'HigherPriorityAvailable'
	                                    #ss_SortStrategy.HigherPriorityAvailable := TRUE;
	                                    #ss_SortStrategy.ObjectID := "DB_GIN".GIN[#si_GINSort].DHL.ObjectID;
	                                    
	                                    //Exit loop
	                                    EXIT;
	                                    
	                                END_IF;
	                                
	                            END_IF;
	                            
	                        END_FOR;
	                        
	                        //Check if the package can be sorted or higher piority destination available
	                        //Release the loop
	                        IF #sx_AutoArmDivert
	                            OR #ss_SortStrategy.HigherPriorityAvailable
	                        THEN
	                            
	                            //Counter only for statistics
	                            #ss_Counter.LoopExit += 1;
	                            
	                            EXIT;
	                            
	                        END_IF;
	                        
	                    END_FOR;
	                    
	                    //  Generation message - Higher priority available
	                    IF #ss_SortStrategy.HigherPriorityAvailable THEN
	                        
	                        #FB_MFC_Sort_SortResult_HigherPriorityAvailable(is_ObjectID := #ss_SortStrategy.ObjectID,
	                                                                        ii_DischargeLocation := #i_UDT_DiverterArmConfig.DischargeLocationID,
	                                                                        ii_Result := 2,
	                                                                        ii_Reason := 7,
	                                                                        ii_SourceNode := #ii_SourceNode,
	                                                                        ii_DestinationNode := #ii_DestinationNode,
	                                                                        iq_UDT_FifoHeader := #iq_UDT_FifoHeader_MFCMessage,
	                                                                        iqs_FifoData := #iqs_FifoData_MFCMessage,
	                                                                        iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	                        
	                        
	                        //Save data in DB_GIN
	                        "DB_GIN".GIN[#si_GINSort].DHL.Destination[#ti_LoopDestination].Rejected := True;
	                        "DB_GIN".GIN[#si_GINSort].DHL.Destination[#ti_LoopDestination].Reason := 7;
	                        
	                        //Reset
	                        #ss_SortStrategy.HigherPriorityAvailable := False;
	                        #ss_SortStrategy.ObjectID := '';
	                        
	                        //Counter only for statistics
	                        #ss_Counter.SortResultMessage += 1;
	                        
	                    END_IF;
	                    
	                END_IF;
	                
	                //Reset
	                #sx_GenerationMessage := False;
	                
	                //Reset value
	                #sx_NewParcel := False;
	                
	            END_IF;
	            
	        END_REGION
	        
	        REGION 2.2 - Sort Strategy - OrderOfProximity - Nearest
	            
	            IF "DB_GIN".GIN[#si_GINSort].DHL.SortStrategy = #cs_SortStrategyNearest AND #sx_NewParcel THEN
	                
	                //Destination
	                FOR #ti_LoopDestinationNearest := 0 TO #ci_OutfeedNumberMax DO
	                    
	                    IF "DB_GIN".GIN[#si_GINSort].General.Destination[#ti_LoopDestinationNearest] = #i_UDT_DiverterArmConfig.DischargeLocationID
	                        AND NOT #iqa_OutfeedsStatus[#i_UDT_DiverterArmConfig.OutfeedsNumber].NotAvailable
	                        AND NOT #iqa_OutfeedsStatus[#i_UDT_DiverterArmConfig.OutfeedsNumber].Full
	                        AND NOT #iqa_OutfeedsStatus[#i_UDT_DiverterArmConfig.OutfeedsNumber].Disable
	                        AND #iq_UDT_ExitConveyorHandshake.RTR
	                        
	                    THEN
	                        
	                        //Variable trigger - this parcel should be sorted.
	                        #sx_AutoArmDivert := TRUE;
	                        #sx_AutoArmHome := FALSE;
	                        
	                        
	                        //Message to MFC generation and copy data to DB_GIN
	                        
	                        //Exit the loop
	                        EXIT;
	                        
	                    END_IF;
	                    
	                END_FOR;
	                
	                //Reset value
	                #sx_NewParcel := False;
	                
	            END_IF;
	            
	        END_REGION
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Diverter arm handling
	    
	    REGION 3.1 - Movement conditions
	        
	        //Conditions to set bit sx_Ready to operate in automatic mode
	        #sx_Ready := #ix_SafetyOk                                               // Safety signalling 
	        AND #ix_24vOk                                                           // 24V
	        AND #ix_400vOk                                                          // 400V
	        AND #ix_HardwareOk                                                      // PNPN device 
	        AND NOT #iq_UDT_ArmConveyorInterface.ConfigurationError;                // No configuration error      
	        
	        //Share HardwareOK signal over interface
	        #iq_UDT_ArmConveyorInterface.HardwareOk := #ix_HardwareOk;
	        
	        ///Conditions from other items 
	        #sx_SwitchEnable := NOT #s_UDT_CommonStatus.Error;                       // Error present
	        
	        //Command to stop Associated conveyor
	        #qx_AssociatedConveyorHold := (#iq_UDT_VerticalConveyorInterface.InternalErrorVFD AND NOT #sx_ActualArmPositionHome)              // Vertical conveyor
	        OR (#sx_ActualArmPositionDivert AND (NOT #iq_UDT_ExitConveyorHandshake.RTR));                                                     // Exit conveyor redy to receive parcels
	        
	    END_REGION
	    
	    REGION 3.2 -Sensor
	        
	        //Sensors reached
	        // Limit switch home position
	        //Set
	        IF NOT #sx_LS_HomeFiltered AND #iq_UDT_ArmConveyorInterface.RunFwd THEN
	            #sx_LimitSwitchHomeReached := True;
	        END_IF;
	        //Reset
	        IF (#iq_UDT_ArmConveyorInterface.RunRvs AND #R_TRIG_LS_Home.Q)
	            OR (NOT #iq_UDT_ArmConveyorInterface.VFDRunning AND #R_TRIG_LS_Home.Q)
	        THEN
	            #sx_LimitSwitchHomeReached := False;
	        END_IF;
	        
	        //Limit switch divert position
	        IF NOT #sx_LS_DivertFiltered AND #iq_UDT_ArmConveyorInterface.RunRvs THEN
	            #sx_LimitSwitchDivertReached := True;
	        END_IF;
	        //Reset
	        IF (#iq_UDT_ArmConveyorInterface.RunFwd AND #R_TRIG_LS_Divert.Q)
	            OR (NOT #iq_UDT_ArmConveyorInterface.VFDRunning AND #R_TRIG_LS_Divert.Q)
	        THEN
	            #sx_LimitSwitchDivertReached := False;
	        END_IF;
	        
	        // Home position
	        //Set
	        IF NOT #sx_PRX_HomeFiltered AND #iq_UDT_ArmConveyorInterface.RunFwd THEN
	            #sx_PositionHomeReached := True;
	        END_IF;
	        //Reset
	        IF (#iq_UDT_ArmConveyorInterface.RunRvs AND #R_TRIG_PRX_Home.Q)
	            OR (NOT #iq_UDT_ArmConveyorInterface.VFDRunning AND #R_TRIG_PRX_Home.Q)
	        THEN
	            #sx_PositionHomeReached := False;
	        END_IF;
	        
	        //Divert position
	        IF NOT #sx_PRX_DivertFiltered AND #iq_UDT_ArmConveyorInterface.RunRvs THEN
	            #sx_PositionDivertReached := True;
	        END_IF;
	        //Reset
	        IF (#iq_UDT_ArmConveyorInterface.RunFwd AND #R_TRIG_PRX_Divert.Q)
	            OR (NOT #iq_UDT_ArmConveyorInterface.VFDRunning AND #R_TRIG_PRX_Divert.Q)
	        THEN
	            #sx_PositionDivertReached := False;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 3.3 - Automatic movement conditions
	        
	        //Home position
	        #sx_MoveToHomePosition := #sx_Ready                  //Conditions for movement
	        AND #sx_SwitchEnable                                 //
	        AND #iq_UDT_EquipmentControl.Command.AutomaticOn     //
	        AND NOT #iq_UDT_ArmDiverterCommand.ManualMode        //
	        AND #sx_PRX_HomeFiltered                             //
	        AND NOT #sx_PositionHomeReached                      //
	        AND #sx_AutoArmHome                                  //Arm return signal to Home position
	        AND NOT #sx_AutoArmDivert                            //
	        AND (NOT #iq_UDT_EquipmentControl.Command.StopRequest OR #sx_MoveToHomePosition);
	        
	        //Divert position
	        #sx_MoveToDivertPosition := #sx_Ready                //Conditions for movement
	        AND #sx_SwitchEnable                                 //
	        AND #iq_UDT_EquipmentControl.Command.AutomaticOn     //
	        AND NOT #iq_UDT_ArmDiverterCommand.ManualMode        //
	        AND #sx_PRX_DivertFiltered                           //
	        AND NOT #sx_PositionDivertReached                    //
	        AND NOT #sx_AutoArmHome                              //
	        AND #sx_AutoArmDivert                                //Sort conditions active
	        AND (NOT #iq_UDT_EquipmentControl.Command.StopRequest OR #sx_MoveToDivertPosition);
	        
	        //Reset automatic control command when manual mode
	        IF #iq_UDT_ArmDiverterCommand.ManualMode THEN
	            #sx_AutoArmHome := False;
	            #sx_AutoArmDivert := False;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 3.4 - Manual mode
	        
	        //Home position
	        IF
	            #sx_PRX_HomeFiltered                                   //The position sensor doesn't detect the arm
	            AND #iq_UDT_ArmDiverterCommand.ManualMode              //Manual mode active
	            AND #iq_UDT_ArmDiverterCommand.ManualHomePosition      //Go to home position active   
	        THEN
	            #sx_ManualToHomePosition := TRUE;
	        END_IF;
	        
	        //Reset
	        IF (NOT #iq_UDT_ArmDiverterCommand.ManualMode)
	            OR #s_UDT_CommonStatus.Error
	            OR (NOT #sx_PRX_HomeFiltered)
	            OR #sx_LimitSwitchHomeReached
	            OR #sx_PositionHomeReached
	        THEN
	            #sx_ManualToHomePosition := FALSE;
	        END_IF;
	        
	        //Divert direction
	        IF #sx_PRX_DivertFiltered                                      //The position sensor doesn't detect the arm
	            AND #iq_UDT_ArmDiverterCommand.ManualMode                  //Manual mode active
	            AND #iq_UDT_ArmDiverterCommand.ManualDivertPosition        //Go to divert position active 
	        THEN
	            #sx_ManualToDivertPosition := TRUE;
	        END_IF;
	        
	        //Reset
	        IF (NOT #iq_UDT_ArmDiverterCommand.ManualMode)
	            OR #s_UDT_CommonStatus.Error
	            OR (NOT #sx_PRX_DivertFiltered)
	            OR #sx_LimitSwitchDivertReached
	            OR #sx_PositionDivertReached
	        THEN
	            #sx_ManualToDivertPosition := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 3.5 - Jog Mode
	        
	        //Home direction
	        #sx_JogToHomePosition :=
	        #sx_LS_HomeFiltered                                         //The limit switch doesn't detect the arm
	        AND #sx_PRX_HomeFiltered
	        AND NOT #sx_LimitSwitchHomeReached
	        AND NOT #sx_PositionHomeReached
	        AND #iq_UDT_ArmDiverterCommand.ManualMode                   //Manual mode active
	        AND #iq_UDT_ArmDiverterCommand.JogHomePosition              //Jog to home position active
	        AND NOT #iq_UDT_ArmDiverterCommand.JogDivertPosition;       //
	        
	        //Divert direction
	        #sx_JogToDivertPosition :=
	        #sx_LS_DivertFiltered                                      //The limit switch doesn't detect the arm
	        AND #sx_PRX_DivertFiltered
	        AND NOT #sx_LimitSwitchDivertReached
	        AND NOT #sx_PositionDivertReached
	        AND #iq_UDT_ArmDiverterCommand.ManualMode                  //Manual mode active
	        AND #iq_UDT_ArmDiverterCommand.JogDivertPosition           //Jog to divert position active
	        AND (NOT #iq_UDT_ArmDiverterCommand.JogHomePosition);
	        
	        // Detecting rising edge on manual jog Home      
	        #R_TRIG_ManualJogHome(CLK := #sx_JogToHomePosition);
	        
	        // Detecting rising edge on manual jog Divert         
	        #R_TRIG_ManualJogDivert(CLK := #sx_JogToDivertPosition);
	        
	        IF #iq_UDT_ArmDiverterCommand.ManualMode                                        // Conditions to run in manual mode
	            AND (#R_TRIG_ManualJogHome.Q                                                  // Trigger to start VSU run in manual jog mode UP
	            OR #R_TRIG_ManualJogDivert.Q)                                                 // Trigger to start VSU run in manual jog mode Down
	            AND NOT #s_FB_Jog_Enable.qx_DelayedSignal
	        THEN
	            
	            #iq_UDT_EquipmentControl.Request.SignalingRequest := TRUE;                  // Request signaling TO control block before VSU runs in manual mode
	            
	        END_IF;
	        
	        // Time to start without start warning while jogging
	        #s_FB_Jog_Enable(iudi_OffDelayTime := #i_UDT_DiverterArmConfig.JogNoHornTime,
	                         ix_SignalToDelay := #sx_JogToDivertPosition OR #sx_JogToHomePosition);
	        
	    END_REGION
	    
	    REGION 3.6 - Arm conveyor - Low speed 
	        
	        //Set
	        IF (#sx_MoveToHomePosition AND #R_TRIG_BRK_PRX_Home.Q)
	            OR (#sx_MoveToDivertPosition AND #R_TRIG_BRK_PRX_Divert.Q)
	            OR (#sx_ManualToHomePosition AND #R_TRIG_BRK_PRX_Home.Q)
	            OR (#sx_ManualToDivertPosition AND #R_TRIG_BRK_PRX_Divert.Q)
	        THEN
	            #sx_ArmDiverterLowSpeed := TRUE;
	        END_IF;
	        
	        //Trigger
	        #F_TRIG_ArmConveyorLowSpeed(CLK := #sx_MoveToHomePosition OR #sx_MoveToDivertPosition OR #sx_ManualToHomePosition OR #sx_ManualToDivertPosition);
	        
	        //Reset
	        IF #F_TRIG_ArmConveyorLowSpeed.Q
	        THEN
	            #sx_ArmDiverterLowSpeed := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 3.7 - Copy command to VFD Interface 
	        
	        //Vertical speed handling
	        IF #sx_ArmDiverterLowSpeed OR #sx_JogToHomePosition OR #sx_JogToDivertPosition THEN
	            #iq_UDT_ArmConveyorInterface.SpeedSetpoint := #i_UDT_DiverterArmConfig.ArmDiverterSpeedSetpointLow;
	        ELSE
	            #iq_UDT_ArmConveyorInterface.SpeedSetpoint := #i_UDT_DiverterArmConfig.ArmDiverterSpeedSetpointNominal;
	        END_IF;
	        
	        //Directions
	        #iq_UDT_ArmConveyorInterface.RunFwd := #sx_MoveToHomePosition       //Automatic mode
	        OR #sx_ManualToHomePosition                                         //Manual mode      
	        OR #sx_JogToHomePosition;                                           //Jog mode
	        
	        #iq_UDT_ArmConveyorInterface.RunRvs := #sx_MoveToDivertPosition     //Automatic mode
	        OR #sx_ManualToDivertPosition                                       //Manual mode
	        OR #sx_JogToDivertPosition;                                         //Jog mode
	        
	    END_REGION
	    
	    REGION 3.8 - Return conditions 
	        
	        IF #sx_ActualArmPositionDivert THEN
	            #sx_AutoArmDivert := FALSE;
	        END_IF;
	        
	        //Check that the package has been sorted correctly 
	        IF #sx_ActualArmPositionDivert
	        THEN
	            
	            //Return conditions 
	            IF #R_TRIG_ExitSensor.Q
	            THEN
	                
	                #sx_AutoArmHome := TRUE;
	                
	                //Save information in "DB_GIN"
	                FOR #ti_LoopResult := 1 TO 6 DO
	                    
	                    IF "DB_GIN".GIN[#si_GINSort].DHL.Destination[#ti_LoopResult].ID = #i_UDT_DiverterArmConfig.DischargeLocationID THEN
	                        "DB_GIN".GIN[#si_GINSort].DHL.Destination[#ti_LoopResult].ParcelSorted := True;
	                    END_IF;
	                    
	                END_FOR;
	                
	                ///Generation message to MFC
	                #FB_MFC_Sort_SortResult(is_ObjectID := #ss_SortedObjectID,
	                                        ii_DischargeLocation := #i_UDT_DiverterArmConfig.DischargeLocationID,
	                                        ii_Result := 1,
	                                        ii_Reason := 1,
	                                        ii_SourceNode := #ii_SourceNode,
	                                        ii_DestinationNode := #ii_DestinationNode,
	                                        iq_UDT_FifoHeader := #iq_UDT_FifoHeader_MFCMessage,
	                                        iqs_FifoData := #iqs_FifoData_MFCMessage,
	                                        iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	                
	            END_IF;
	            
	            // Reset value
	            #sx_ParcelSorted := False;
	            
	        END_IF;
	        
	        //Reset variable return when arm is at home position
	        IF NOT #sx_PRX_HomeFiltered THEN
	            #sx_AutoArmHome := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 3.9 - Arm movement check, positons check
	        
	        //Position Home
	        #sx_ActualArmPositionHome := (NOT #sx_PRX_HomeFiltered) AND #ix_HardwareOk;
	        
	        //On way
	        #sx_ActualArmPositionOnWay := #sx_LS_HomeFiltered AND #sx_LS_DivertFiltered AND #sx_PRX_HomeFiltered AND #sx_PRX_DivertFiltered AND #iq_UDT_ArmConveyorInterface.VFDRunning;
	        
	        //Position Divert 
	        #sx_ActualArmPositionDivert := (NOT #sx_PRX_DivertFiltered) AND #ix_HardwareOk;
	        
	    END_REGION
	    
	    REGION 3.10 - Vertical conveyor
	        
	        CASE #i_UDT_DiverterArmConfig.VerticalConveyorMode OF
	                
	            1:  //[1]Continuous operation if the main conveyor is running
	                #qx_VerticalConveyorHold := NOT #iq_UDT_AssociatedConveyorInterface.VFDRunning;
	                
	            2:  //[2]Operation if the main conveyor is running and  arm is not in Home position
	                #qx_VerticalConveyorHold := NOT #iq_UDT_AssociatedConveyorInterface.VFDRunning
	                OR NOT #sx_PRX_HomeFiltered;
	                
	        END_CASE;
	        
	    END_REGION
	    
	    REGION 3.11 - Errors & inhibit stop
	        
	        // Reset signal is sent to the interface Arm (VFD block)
	        #iq_UDT_ArmConveyorInterface.InternalErrorReset := #iq_UDT_EquipmentControl.Command.Reset;
	        #iq_UDT_ArmConveyorInterface.ResetStatistics := #iq_UDT_EquipmentControl.Command.ResetData;
	        
	        //Error
	        #s_UDT_CommonStatus.Error := #iq_UDT_ArmConveyorInterface.InternalErrorVFD               // Internal VFD error status
	        OR #iq_UDT_ArmConveyorInterface.Disconnected                                            // Isolator switch error status
	        OR #s_UDT_HMIStatus.Specific.LimitDivertError
	        OR #s_UDT_HMIStatus.Specific.LimitHomeError
	        OR #s_UDT_HMIStatus.Specific.PXDivertError
	        OR #s_UDT_HMIStatus.Specific.PXHomeError
	        OR #s_UDT_HMIStatus.Specific.ReferencError
	        OR #s_UDT_HMIStatus.Specific.TimeoutError;
	        
	        //Warning
	        #s_UDT_CommonStatus.Warning := #iq_UDT_ArmConveyorInterface.InternalWarningVFD;        //Internal Warning VFD added
	        
	        //Movement timeout error
	        #s_FB_TimeoutError(iudi_OnDelayTime := #i_UDT_DiverterArmConfig.MaximumMovementTime,
	                           ix_SignalToDelay := ((#sx_MoveToHomePosition AND #sx_PRX_HomeFiltered) OR (#sx_MoveToDivertPosition AND #sx_PRX_DivertFiltered)));
	        
	        IF #s_FB_TimeoutError.qx_DelayedSignal THEN
	            #s_UDT_HMIStatus.Specific.TimeoutError := True;
	        END_IF;
	        
	        //Reference error - The arm does not move and any of the sensors detect it
	        IF NOT #iq_UDT_ArmConveyorInterface.VFDRunning
	            AND #sx_LS_HomeFiltered
	            AND #sx_LS_DivertFiltered
	            AND #sx_PRX_HomeFiltered
	            AND #sx_PRX_DivertFiltered
	        THEN
	            #s_UDT_HMIStatus.Specific.ReferencError := True;
	        END_IF;
	        
	        //Sensor errors
	        //Movement command active
	        #s_FB_InhibitTimeFilter(iudi_OffDelayTime := #cudi_InhibitTimeFilterTimeOFF,
	                                ix_SignalToDelay := (#iq_UDT_ArmConveyorInterface.RunRvs
	                                OR #iq_UDT_ArmConveyorInterface.RunFwd
	                                OR #iq_UDT_ArmConveyorInterface.ActualSpeed <> 0),
	                                ix_Enable := TRUE,
	                                qx_DelayedSignal => #tx_MovementCommandActive);
	        
	        // #tx_MovementCommandActive := (#iq_UDT_ArmConveyorInterface.RunRvs
	        // OR #iq_UDT_ArmConveyorInterface.RunFwd
	        // OR #iq_UDT_ArmConveyorInterface.ActualSpeed <> 0);
	        //  //OR #s_FB_DivertTime.qx_DelayedSignal
	        
	        //Movement command active,copy value to EquipmentControl structure
	        #iq_UDT_EquipmentControl.Request.InhibitStop := #iq_UDT_EquipmentControl.Request.InhibitStop OR #tx_MovementCommandActive;
	        
	        // Limit swich sensor error
	        IF NOT #tx_MovementCommandActive AND (#R_TRIG_LS_Home.Q OR #F_TRIG_LS_Home.Q) THEN
	            #s_UDT_HMIStatus.Specific.LimitHomeError := True;
	        END_IF;
	        //Limit swich sensor error
	        IF NOT #tx_MovementCommandActive AND (#R_TRIG_LS_Divert.Q OR #F_TRIG_LS_Divert.Q) THEN
	            #s_UDT_HMIStatus.Specific.LimitDivertError := True;
	        END_IF;
	        //Proxy sensor error
	        IF NOT #tx_MovementCommandActive AND (#R_TRIG_LS_Home.Q OR #F_TRIG_LS_Home.Q) THEN
	            #s_UDT_HMIStatus.Specific.PXHomeError := True;
	        END_IF;
	        //Proxy sensor error
	        IF NOT #tx_MovementCommandActive AND (#R_TRIG_LS_Divert.Q OR #F_TRIG_LS_Divert.Q) THEN
	            #s_UDT_HMIStatus.Specific.PXDivertError := True;
	        END_IF;
	        
	        //Divert Time
	        #s_FB_DivertTime(iudi_OnDelayTime := #i_UDT_DiverterArmConfig.MaximumParcelDivertTime,
	                         ix_SignalToDelay := (#sx_AutoArmDivert AND NOT #sx_ActualArmPositionHome)
	                         OR (#sx_ActualArmPositionDivert AND #iq_UDT_AssociatedConveyorInterface.VFDRunning));
	        
	        IF #s_FB_DivertTime.qx_DelayedSignal THEN
	            #s_UDT_HMIStatus.Specific.ParcelDivertError := TRUE;
	        END_IF;
	        
	        //Reset Errors
	        IF #iq_UDT_ArmDiverterCommand.Reset THEN
	            //Arm movement timed out
	            IF #s_UDT_HMIStatus.Specific.TimeoutError THEN
	                #s_UDT_HMIStatus.Specific.TimeoutError := FALSE;
	            END_IF;
	            //Limit swich sensor error
	            IF #s_UDT_HMIStatus.Specific.LimitHomeError THEN
	                #s_UDT_HMIStatus.Specific.LimitHomeError := FALSE;
	            END_IF;
	            //Limit swich sensor error
	            IF #s_UDT_HMIStatus.Specific.LimitDivertError THEN
	                #s_UDT_HMIStatus.Specific.LimitDivertError := FALSE;
	            END_IF;
	            //Proxy sensor error
	            IF #s_UDT_HMIStatus.Specific.PXHomeError THEN
	                #s_UDT_HMIStatus.Specific.PXHomeError := FALSE;
	            END_IF;
	            //Proxy sensor error
	            IF #s_UDT_HMIStatus.Specific.PXDivertError THEN
	                #s_UDT_HMIStatus.Specific.PXDivertError := FALSE;
	            END_IF;
	            //Referencing error
	            IF #s_UDT_HMIStatus.Specific.ReferencError
	                AND #iq_UDT_ArmDiverterCommand.ManualMode
	                AND NOT #sx_PRX_HomeFiltered
	            THEN
	                #s_UDT_HMIStatus.Specific.ReferencError := FALSE;
	            END_IF;
	            //Parcel divert error
	            IF #s_UDT_HMIStatus.Specific.ParcelDivertError THEN
	                #s_UDT_HMIStatus.Specific.ParcelDivertError := False;
	            END_IF;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 3.12 - Status
	        
	        //Write outfeed status
	        #iqa_OutfeedsStatus[#i_UDT_DiverterArmConfig.OutfeedsNumber].NotAvailable := (NOT #sx_Ready)
	        OR (NOT #sx_SwitchEnable); // to add more conditions
	        
	        //Arm at home position
	        #s_UDT_HMIStatus.Specific.AtHomePosition := #sx_ActualArmPositionHome;
	        //Arm at divert position
	        #s_UDT_HMIStatus.Specific.AtDivertPosition := #sx_ActualArmPositionDivert;
	        
	        // HMI status update
	        IF #s_UDT_CommonStatusOld <> #s_UDT_CommonStatus
	        THEN
	            // HMI status initialization
	            #s_UDT_HMIStatus.Status := 0;
	            
	            // Energy save
	            IF #s_UDT_CommonStatus.EnergySave
	            THEN
	                #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".EnergySave;
	            END_IF;
	            
	            // Running
	            IF #s_UDT_CommonStatus.Running
	            THEN
	                #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Running;
	            END_IF;
	            
	            // Stopped
	            IF #s_UDT_CommonStatus.Stopped
	            THEN
	                #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Stopped;
	            END_IF;
	            
	            // Dieback
	            IF #s_UDT_CommonStatus.Dieback
	            THEN
	                #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Dieback;
	            END_IF;
	            
	            // Halted
	            IF #s_UDT_CommonStatus.Halted
	            THEN
	                #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Halted;
	            END_IF;
	            
	            // Manual
	            IF #s_UDT_CommonStatus.Manual
	            THEN
	                #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Manual;
	            END_IF;
	            
	            // Running in manual mode
	            IF #s_UDT_CommonStatus.ManualRun
	            THEN
	                #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".ManualRun;
	            END_IF;
	            
	            //Error
	            IF #s_UDT_CommonStatus.Error THEN
	                #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Error;
	            END_IF;
	            
	            // Safety stop
	            IF (#s_UDT_CommonStatus.SafetyStop)
	            THEN
	                #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".SafetyStop;
	            END_IF;
	            
	            #s_UDT_CommonStatusOld := #s_UDT_CommonStatus;              // Copy status to memory
	            #q_UDT_Status := #s_UDT_CommonStatus;                       // Copy status to output
	            
	        END_IF;
	        
	        // Copy HMI status to output
	        #q_UDT_HMIStatus := #s_UDT_HMIStatus;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 4 - Tracking data handling
	    
	    IF #sx_ActualArmPositionDivert THEN
	        
	        //To test on site 
	        //Copy handshakes
	        //Upstream to downstream
	        #iq_UDT_ExitConveyorHandshake.GIN := #iqa_AssociatedTrackingData[#i_UDT_DiverterArmConfig.DataTransferPoint];
	        #iqa_AssociatedTrackingData[#i_UDT_DiverterArmConfig.DataTransferPoint] := 0;
	        //#iq_UDT_HandShakeConveyorExtended.NrOfPosToShift := #iq_UDT_HandShakeSorterConveyor.NrOfPosToShift;
	        
	        
	        #iq_UDT_ExitConveyorHandshake.RTS := #iq_UDT_AssociatedConveyorHandshake.RTS;
	        #iq_UDT_ExitConveyorHandshake.TIP := #iq_UDT_AssociatedConveyorHandshake.TIP;
	        #iq_UDT_ExitConveyorHandshake.ResetEnergySave := #iq_UDT_AssociatedConveyorHandshake.ResetEnergySave;
	        // Downstream to upstream
	        #iq_UDT_AssociatedConveyorHandshake.RTR := #iq_UDT_ExitConveyorHandshake.RTR;
	        #iq_UDT_AssociatedConveyorHandshake.DownstreamDisplacement := #iq_UDT_ExitConveyorHandshake.DownstreamDisplacement;
	        #iq_UDT_AssociatedConveyorHandshake.CascadeStartUp := #iq_UDT_ExitConveyorHandshake.CascadeStartUp;
	        
	        // Clear GIN if there is no RTR 
	        IF NOT #iq_UDT_ExitConveyorHandshake.RTR
	        THEN
	            
	            #iq_UDT_ExitConveyorHandshake.GIN := 0;
	            #iq_UDT_ExitConveyorHandshake.NrOfPosToShift := 0;
	            
	        END_IF;
	        
	    END_IF;
	    
	    //Arm diverter is not at the position, clear Handshake 
	    //To test on site 
	    IF NOT #sx_ActualArmPositionHome
	        AND NOT #sx_ActualArmPositionDivert
	    THEN
	        
	        // Reset Handshake extended position downstream
	        #iq_UDT_ExitConveyorHandshake.GIN := 0;
	        #iq_UDT_ExitConveyorHandshake.NrOfPosToShift := 0;
	        #iq_UDT_ExitConveyorHandshake.RTS := FALSE;
	        #iq_UDT_ExitConveyorHandshake.TIP := FALSE;
	        #iq_UDT_ExitConveyorHandshake.DownstreamDisplacement := 0;
	        #iq_UDT_ExitConveyorHandshake.ResetEnergySave := FALSE;
	        
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_SecurityCage"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 101
// END_ATTRIBUTES
   VAR_INPUT 
      ix_StartStopButton { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start stop push button
      ix_DirectionButton { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Direction push button
   END_VAR

   VAR_OUTPUT 
      q_UDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_SecurityCageStatus";   // Status
      qx_StartStopButtonLamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start stop lamp button
      qx_DirectionButtonLamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Direction lamp button
      qx_ReverseDirection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Signal to the system to change line direction
   END_VAR

   VAR_IN_OUT 
      iq_UDT_SystemControlCommand : "UDT_SystemControlCommand";   // HMI system control structure
      iq_UDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
   END_VAR

   VAR 
      R_TRIG_StartStopButton {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of start stop button
      R_TRIG_DirectionButton {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of direction button
      sx_StartStopButtonLamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start stop lamp button
      sx_DirectionButtonLamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Direction lamp button
      sx_Infeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;   // Infeed mode
      sx_Outfeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Outfeed mode
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             Fortna Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |
	|                                                                                      |     
	----------------------------------------------------------------------------------------
	                                                               
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	23/11/2022  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/03/2024  | 1.1       | S. Nieswiec  | Added to new Baseline
	*)
	
	REGION 1 - Triggers
	    
	    #R_TRIG_StartStopButton(CLK := #ix_StartStopButton);
	    #R_TRIG_DirectionButton(CLK := #ix_DirectionButton);
	    
	END_REGION
	
	REGION 2 - Start Stop System
	    
	    //If system is running then stop the system
	    IF #iq_UDT_EquipmentControl.Command.AutomaticOn AND #R_TRIG_StartStopButton.Q THEN
	        
	        #iq_UDT_SystemControlCommand.Stop := True;
	        
	    END_IF;
	    
	    //If system is stopped then start the system
	    IF NOT #iq_UDT_EquipmentControl.Command.AutomaticOn AND #R_TRIG_StartStopButton.Q THEN
	        
	        #iq_UDT_SystemControlCommand.Start := True;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Mode
	    
	    //Select mode
	    // The mode can be only changed when the line is stopped
	    
	    IF NOT #iq_UDT_EquipmentControl.Command.AutomaticOn AND #R_TRIG_DirectionButton.Q THEN
	        
	        #sx_Infeed := NOT #sx_Infeed;
	        #sx_Outfeed := NOT #sx_Outfeed;
	        
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Lamp operation
	    
	    //When the selected direction is infeed (from ground floor to security cage) the button will be solid on
	    //When the selected direction is outfeed (from the security cage to ground floor) THEN the button will be flashing at 1Hz.
	    #sx_DirectionButtonLamp := #sx_Infeed OR (#sx_Outfeed AND "mx_Clock_1Hz");
	    
	    
	    //When system is running then lamp will be solid on.
	    #sx_StartStopButtonLamp := #iq_UDT_EquipmentControl.Command.AutomaticOn;
	    
	END_REGION
	
	REGION 5 - Status
	    
	    #q_UDT_Status.InfeedMode := #sx_Infeed;
	    #q_UDT_Status.OutfeedMode := #sx_Outfeed;
	    
	END_REGION
	
	REGION 6 - Write outputs
	    #qx_ReverseDirection := #sx_Outfeed;
	    #qx_StartStopButtonLamp := #sx_StartStopButtonLamp;
	    #qx_DirectionButtonLamp := #sx_DirectionButtonLamp;
	    
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_RetractableRoller"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 100
// END_ATTRIBUTES
   VAR_INPUT 
      ix_RollerError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Error from roller
      ix_RollerAtHome { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Roller at home position
      ix_Button { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Switching on/off the magnet
      ix_DirectionConfig { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Change the direction
   END_VAR

   VAR_OUTPUT 
      qx_RollerCW { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Forward direction
      qx_RollerCCW { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Revers direction
      qx_RollerRun { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Run Roller
      qx_Magnet { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // On/Off Magnet
      qx_ConveyorInDieBack { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Active DieBack mode
      q_UDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_RetractrableRoller_Status";   // HMI status structure
   END_VAR

   VAR_IN_OUT 
      iq_UDT_ConveyorInterface : "UDT_ConveyorInterface";   // Interface structure
   END_VAR

   VAR 
      s_UDT_HMI_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_RetractrableRoller_Status";   // RetractrableRoller structure
      sx_RollerRun { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Roller is active
      sx_RollerCW { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Roller is in forward mode
      sx_RollerCCW { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Roller is in revers mode
      sx_Magnet { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Magnet is active
      sx_ConveyorInDieBack { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Dieback mode active
      s_UDT_CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Common status structure
      s_UDT_CommonStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Common status structure
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	05/05/2023  | 1.0       | M. Diebel   | Release TIA 17 | DHL Munich 2023
	13/03/2024  | 1.1       | S. Nieswiec  | Added to new Baseline
	*)
	
	REGION 1 - Magnet handling
	    
	    //Keep true the magnet output when the Proxy detects roller and the button is not pressed  
	    #sx_Magnet := #ix_RollerAtHome AND NOT #ix_Button;
	    
	END_REGION
	
	REGION 2 - Roller handling
	    
	    // Run rollers 
	    #sx_RollerRun := #ix_RollerAtHome AND (#iq_UDT_ConveyorInterface.RunFwd OR #iq_UDT_ConveyorInterface.RunRvs);
	    
	    // Roller direction
	    IF NOT #ix_DirectionConfig
	    THEN
	        
	        // Run rollers in forward mode
	        #sx_RollerCW := #ix_RollerAtHome AND #iq_UDT_ConveyorInterface.RunFwd AND NOT #iq_UDT_ConveyorInterface.RunRvs;
	        
	        // Run rollers in revers mode
	        #sx_RollerCCW := #ix_RollerAtHome AND #iq_UDT_ConveyorInterface.RunRvs AND NOT #iq_UDT_ConveyorInterface.RunFwd;
	        
	    ELSE
	        
	        // Run rollers in forward mode
	        #sx_RollerCW := #ix_RollerAtHome AND #iq_UDT_ConveyorInterface.RunRvs AND NOT #iq_UDT_ConveyorInterface.RunFwd;
	        
	        // Run rollers in revers mode
	        #sx_RollerCCW := #ix_RollerAtHome AND #iq_UDT_ConveyorInterface.RunFwd AND NOT #iq_UDT_ConveyorInterface.RunRvs;
	        
	    END_IF;
	    
	    // DieBack mode for Conveyor when roller is not at home position
	    #sx_ConveyorInDieBack := NOT #ix_RollerAtHome;
	    
	    // Rollers is not in home position
	    #s_UDT_HMI_Status.Specific.NoHomePosition := NOT #ix_RollerAtHome;
	    
	    // Roller reports an error
	    #s_UDT_HMI_Status.Specific.RollerError := #ix_RollerError;
	    
	END_REGION
	
	REGION 3 - Status 
	    
	    //Error
	    #s_UDT_CommonStatus.Error := #s_UDT_HMI_Status.Specific.NoHomePosition;
	    
	    //Running
	    #s_UDT_CommonStatus.Running := #sx_RollerRun AND NOT #s_UDT_HMI_Status.Specific.NoHomePosition;
	    
	    //Stopped
	    #s_UDT_CommonStatus.Stopped := NOT #sx_RollerRun AND NOT #s_UDT_HMI_Status.Specific.NoHomePosition;
	    
	    IF #s_UDT_CommonStatusOld <> #s_UDT_CommonStatus
	    THEN
	        // HMI status initialization
	        #s_UDT_HMI_Status.Status := 0;
	        
	        IF #s_UDT_CommonStatus.Error
	        THEN
	            #s_UDT_HMI_Status.Status := "DB_HMIStatusConfiguration".Error;
	        END_IF;
	        
	        IF #s_UDT_CommonStatus.Running
	        THEN
	            #s_UDT_HMI_Status.Status := "DB_HMIStatusConfiguration".Running;
	        END_IF;
	        
	        IF #s_UDT_CommonStatus.Stopped
	        THEN
	            #s_UDT_HMI_Status.Status := "DB_HMIStatusConfiguration".Stopped;
	        END_IF;
	        
	        #s_UDT_CommonStatusOld := #s_UDT_CommonStatus;
	        
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Update outputs
	    
	    #q_UDT_HMIStatus := #s_UDT_HMI_Status;
	    #qx_RollerCW := #sx_RollerCW;
	    #qx_RollerCCW := #sx_RollerCCW;
	    #qx_RollerRun := #sx_RollerRun;
	    #qx_Magnet := #sx_Magnet;
	    #qx_ConveyorInDieBack := #sx_ConveyorInDieBack;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_Outfeed2States"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 2.0
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 99
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_ChuteConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_Outfeed2StatesConfiguration";   // Chute Configuration structure
      i_UDT_AssociatedConveyorStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   // Conveyor status
      ix_CapacityControlActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Chute capacity control is full
      ix_Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when chute funcktion is enable
      ix_ConditionFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when Chute Full contidion is not blocked
      ix_ConditionHalfFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when Chute Half Full condition is not blocked
      ix_Disabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when chute is disabled
      ix_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when chute hardware is Ok
      iudi_DelayHardwareOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Time to delay for hardware ok signal
   END_VAR

   VAR_OUTPUT 
      qx_Lamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Output Chute Lamp half full/ full
      q_UDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_Outfeed2StatesStatus";   // HMI chute status structure
      q_UDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   // Common chute status structure
   END_VAR

   VAR_IN_OUT 
      iq_UDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
      iq_ChuteExternalHandshake : "UDT_ConveyorHandshake";   // Upstream handshake structure
      iq_UDT_ConveyorHandshake : "UDT_ConveyorHandshake";
      iq_UDT_Statistics : "UDT_Outfeed2StatesStatistics";   // Statistics structure
   END_VAR

   VAR 
      s_UDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_Outfeed2StatesStatus";   // HMI status structure
      s_UDT_CommonStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Common status structure
      s_UDT_CommonStatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Auxiliary status structure
      s_FB_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer on/off delay for hardware ok signal
      s_FB_ChuteHalfFullDetectionDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer on/off delay for chute half  full detection
      s_FB_ChuteFullDetectionDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Timer on/off delay for chute full detection
      s_R_TRIG_HalfFull {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger on chute half full signal
      s_R_TRIG_Disabled {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger on chute disabled signal
      s_R_TRIG_ChuteFull {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger on chute full signal
      s_F_TRIG_UpdateStatus {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger on status change
      sx_Full { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Full status
      sx_HalfFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Half full status
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------   
	                                                            
	Version history:
	Date        | Version   | Author            | Remark
	----------------------------------------------------------------------------------------
	 01/03/2023 | 1.0       | R. Golonka        | Release V17 | DHL Munich   
	 05/09/2023 | 1.1       | S.Theocharis      | remove the reset of restart required
	 05/09/2023 | 1.2       | M.Diebel          | Initilization, s_UDT_CommonStatus.Stopped set on true
	 06/09/2023 | 1.3       | M.Diebel          | Rewrite reset energy save from external handshake to conveyor handshake 
	 12/09/2023 | 2.0       | M.Diebel          | Set status "stopped" when chute is disable
	 13/03/2024 | 2.1       | S. Nieswiec       | Added to new Baseline
	 
	 
	 *)
	
	
	REGION 1 - Inicialization 
	    //Reset HMI status and Common status and exit
	    IF NOT #ix_Enable THEN
	        #s_UDT_HMIStatus.Specific.ChuteFull := 0;
	        #s_UDT_HMIStatus.Specific.ChuteHalfFull := 0;
	        #s_UDT_HMIStatus.Specific.ChuteDisabled := 0;
	        #s_UDT_CommonStatus.SafetyStop := 0;
	        #s_UDT_CommonStatus.AutoON := 0;
	        #s_UDT_CommonStatus.Stopped := TRUE;
	        #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Stopped;
	        #q_UDT_HMIStatus := #s_UDT_HMIStatus;
	        #q_UDT_Status := #s_UDT_CommonStatus;
	        #iq_UDT_EquipmentControl.Report := #s_UDT_CommonStatus;
	        #qx_Lamp := 0;
	        #iq_UDT_ConveyorHandshake.RTS := 0;
	        #iq_ChuteExternalHandshake.RTR := 0;
	        
	        RETURN;
	    END_IF;
	END_REGION
	
	REGION 2 - Timers
	    
	    // Chute full detection timer 
	    #s_FB_ChuteFullDetectionDelay(iudi_OnDelayTime := #i_UDT_ChuteConfiguration.FullDetectionTime,
	                                  iudi_OffDelayTime := #i_UDT_ChuteConfiguration.FullReleaseTime,
	                                  ix_SignalToDelay := NOT #ix_ConditionFull,
	                                  qx_DelayedSignal => #sx_Full);
	    
	    // Chute half full detection timer
	    #s_FB_ChuteHalfFullDetectionDelay(iudi_OnDelayTime := #i_UDT_ChuteConfiguration.HalfFullDetectionTime,
	                                      iudi_OffDelayTime := #i_UDT_ChuteConfiguration.HalfFullReleaseTime,
	                                      ix_SignalToDelay := NOT #ix_ConditionHalfFull,
	                                      qx_DelayedSignal => #sx_HalfFull);
	    
	    // Hardware ok signal delay
	    #s_FB_HardwareOk(iudi_OnDelayTime := #iudi_DelayHardwareOK,
	                     ix_SignalToDelay := #ix_HardwareOk);
	    
	    
	END_REGION
	
	REGION 3 - Stop upstream conveyor 
	    
	    // Stop upstream conveyor when chute is full or disabled
	    #iq_ChuteExternalHandshake.RTR := NOT #sx_Full AND NOT #ix_CapacityControlActive AND NOT #ix_Disabled AND #s_FB_HardwareOk.qx_DelayedSignal AND #iq_UDT_EquipmentControl.Report.AutoON;
	    
	END_REGION
	
	REGION 4 - Start next conveyor
	    
	    // Start conveyor when upstream conveyor is running
	    #iq_UDT_ConveyorHandshake.RTS := #iq_ChuteExternalHandshake.RTR;
	    #iq_UDT_ConveyorHandshake.ResetEnergySave := #iq_ChuteExternalHandshake.ResetEnergySave;
	END_REGION
	
	
	REGION 5 - Update output
	    
	    // Update the outputs
	    #qx_Lamp := (#sx_Full OR (#sx_HalfFull AND "DB_Memory".Clock_1Hz));
	    
	END_REGION
	
	REGION 6 - Status
	    
	    // Update chute full specific status
	    #s_UDT_HMIStatus.Specific.ChuteFull := #sx_Full AND #s_FB_HardwareOk.qx_DelayedSignal;
	    
	    // Update chute half full specific status
	    #s_UDT_HMIStatus.Specific.ChuteHalfFull := #sx_HalfFull AND #s_FB_HardwareOk.qx_DelayedSignal;
	    
	    //Update chute disabled specific status
	    #s_UDT_HMIStatus.Specific.ChuteDisabled := #ix_Disabled AND #s_FB_HardwareOk.qx_DelayedSignal;
	    
	    
	    // Update common safety stop
	    #s_UDT_CommonStatus.SafetyStop := #i_UDT_AssociatedConveyorStatus.SafetyStop;
	    
	    // Update common automatic on 
	    #s_UDT_CommonStatus.AutoON := #i_UDT_AssociatedConveyorStatus.AutoON;
	    
	    // Update common stopped
	    #s_UDT_CommonStatus.Stopped := #i_UDT_AssociatedConveyorStatus.Stopped;
	    
	    
	    // Update HMI status number for chute disabled
	    IF #s_UDT_HMIStatus.Specific.ChuteDisabled AND NOT #s_UDT_CommonStatus.SafetyStop
	    THEN
	        #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".DisableByManagement;
	    END_IF;
	    
	    // Update HMI status number for chute half full
	    IF #s_UDT_HMIStatus.Specific.ChuteHalfFull AND NOT #s_UDT_CommonStatus.SafetyStop
	    THEN
	        #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".ChuteHalfFull;
	    END_IF;
	    
	    // Update HMI status number for chute full
	    IF #s_UDT_HMIStatus.Specific.ChuteFull AND NOT #s_UDT_CommonStatus.SafetyStop
	    THEN
	        #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".ChuteFull;
	    END_IF;
	    
	    
	    // Collecting F_TRIG on chute full, chute half full or chute disabled status to update common status 
	    #s_F_TRIG_UpdateStatus(CLK := #s_UDT_HMIStatus.Specific.ChuteFull
	                           OR #s_UDT_HMIStatus.Specific.ChuteDisabled
	                           OR #s_UDT_HMIStatus.Specific.ChuteHalfFull);
	    
	    // HMI status number calculation
	    IF #s_UDT_CommonStatusOld <> #s_UDT_CommonStatus OR #s_F_TRIG_UpdateStatus.Q
	    THEN
	        
	        // Update auto on status number
	        IF #s_UDT_CommonStatus.AutoON
	        THEN
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".AutoON;
	            
	        END_IF;
	        
	        IF #s_UDT_CommonStatus.Stopped
	        THEN
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Stopped;
	            
	        END_IF;
	        
	        IF #s_UDT_CommonStatus.SafetyStop
	        THEN
	            #s_UDT_HMIStatus.Status := "DB_HMIStatusConfiguration".SafetyStop;
	            
	        END_IF;
	        
	        // Copy common status structure to the old common status structure
	        #s_UDT_CommonStatusOld := #s_UDT_CommonStatus;
	        #q_UDT_Status := #s_UDT_CommonStatus;
	        
	    END_IF;
	    
	    #q_UDT_HMIStatus := #s_UDT_HMIStatus;
	    
	END_REGION
	
	REGION 7 - Statistics
	    
	    // Chute full R_TRIG for statistics purpose
	    #s_R_TRIG_ChuteFull(CLK := #s_UDT_HMIStatus.Specific.ChuteFull);
	    
	    // Chute full statistics
	    IF #s_UDT_HMIStatus.Specific.ChuteFull
	        OR #iq_UDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iq_UDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #s_UDT_HMIStatus.Specific.ChuteFull,
	                        ix_RTrigActivate := #s_R_TRIG_ChuteFull.Q,
	                        iqUDT_Statistics := #iq_UDT_Statistics.ChuteFull);
	        
	    END_IF;
	    
	    // Chute disabled R_TRIG for statistics purpose 
	    #s_R_TRIG_Disabled(CLK := #s_UDT_HMIStatus.Specific.ChuteDisabled);
	    
	    // Chute disabled statistics
	    IF #s_UDT_HMIStatus.Specific.ChuteDisabled
	        OR #iq_UDT_EquipmentControl.Command.ResetData
	    THEN
	        "FC_Statistics"(ix_Reset := #iq_UDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #s_UDT_HMIStatus.Specific.ChuteDisabled,
	                        ix_RTrigActivate := #s_R_TRIG_Disabled.Q,
	                        iqUDT_Statistics := #iq_UDT_Statistics.ChuteDisabled);
	        
	    END_IF;
	    
	    // Chute half full R_TRIG for statistics purpose
	    #s_R_TRIG_HalfFull(CLK := #s_UDT_HMIStatus.Specific.ChuteHalfFull);
	    
	    // Chute half full statistics
	    IF #s_UDT_HMIStatus.Specific.ChuteHalfFull
	        OR #iq_UDT_EquipmentControl.Command.ResetData
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iq_UDT_EquipmentControl.Command.ResetData,
	                        ix_Activate := #s_UDT_HMIStatus.Specific.ChuteHalfFull,
	                        ix_RTrigActivate := #s_R_TRIG_HalfFull.Q,
	                        iqUDT_Statistics := #iq_UDT_Statistics.ChuteHalfFull);
	        
	    END_IF;
	    
	END_REGION
	
	REGION 8 - Equipment Report
	    
	    "FC_EquipmentReport"(iUDT_Status := #s_UDT_CommonStatus,
	                         iqUDT_Control := #iq_UDT_EquipmentControl);
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_InchingBulkV2"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 97
// END_ATTRIBUTES
   VAR_INPUT 
      ix_PECUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PEC Sum signal from upstream conveyor
      ix_LongParcelDetection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Long parcel detection PEC's
      ix_InchingActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // If TRUE inching is activate
      ix_InchingLineHealthy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ix_ClearCommand { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command to clear full status
      ix_DownstreamFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE if downstream conveyors are full
      ii_OnDelayGap { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Distance to conveyor release [mm]
      ii_InchingGap { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Inching distance [mm]
      ii_Displacement_Upstream { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Upstream conveyor displacement
      ii_Displacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Inching conveyor displacement
      iudt_ConveyorInterface { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ConveyorInterface";
   END_VAR

   VAR_OUTPUT 
      qx_ExternalRequestHold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External output to request conveyor hold
      qx_Full { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Inching conveyor is full status
   END_VAR

   VAR 
      s_FB_TimerOnOffDelay_LongParcelDetection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      F_TRIG_PECEoSUp {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger PEC EoS
      si_ActualInchingGap { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Distance to request hold
      si_ActualOnGap { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Distance to conveyor release
      sx_StartRelease { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor release
      sx_ConveyorFull { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      s_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_InchingStatus";
      s_StatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_InchingStatus";
      sx_InchingActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2019             MHS                                                     |
	|  All Rights Rese9ved         Larenweg 90                                             |
	|                              5234 KC 's-Hertogenbosch,                               |
	|                              Netherlands                                             |
	|                                                                                      |     
	----------------------------------------------------------------------------------------
	                                                                                      
	Version history:
	Date        | Version   | Author        | Remark
	----------------------------------------------------------------------------------------
	01/04/2021 | 1.0       | M.Kocot      | first release TIA 16
	08/04/2021 | 1.1       | H.Rutkwoski  | Added status full
	14/08/2021 | 1.2       | M. Jager     | Reset sx_full when inching is not active 
	26/07/2023 | 1.3       | S.Nikodem    | Absolut displacement value
	13/09/2023 | 1.4       | M.Diebel     | Activate inching if PEC is clear
	14/09/2023 | 1.5       | M.Diebel     | Hold line when downstream conveyors are full
	06/02/2024 | 1.6       | L.Klar       | Long parcel detection 
	13/03/2024 | 1.7       | S. Nieswiec  | Changed name to V2
	*)
	
	REGION 1 - Triggers
	    
	    // Falling edge trigger PEC EoS.
	    #F_TRIG_PECEoSUp(CLK := #ix_PECUp);
	    
	END_REGION
	
	REGION 2 - TTimers
	    
	    #s_FB_TimerOnOffDelay_LongParcelDetection(iudi_OffDelayTime := 100,
	                                              ix_SignalToDelay := #ix_LongParcelDetection);
	    
	END_REGION
	
	REGION 3 - Inching
	    // Statement section REGION
	    
	    //Activate inching if PEC is clear
	    #sx_InchingActive := #ix_InchingActive AND (#sx_InchingActive OR #ix_PECUp);
	    
	    
	    
	    IF ((#F_TRIG_PECEoSUp.Q OR NOT #s_FB_TimerOnOffDelay_LongParcelDetection.qx_DelayedSignal) AND #sx_InchingActive)
	        // OR( RisingeEdge of Ix_InchigActive AND NOT IX_PECup )    
	    THEN
	        #si_ActualOnGap := DINT_TO_INT(#ii_OnDelayGap / 10);
	        #si_ActualInchingGap := DINT_TO_INT(#ii_InchingGap / 10);
	        
	    END_IF;
	    
	    IF #si_ActualOnGap > 0 THEN
	        
	        #si_ActualOnGap := #si_ActualOnGap - ABS(#ii_Displacement_Upstream);
	        
	    END_IF;
	    
	    IF #ix_PECUp AND #si_ActualInchingGap > 0 THEN
	        #si_ActualInchingGap := #si_ActualInchingGap - ABS(#ii_Displacement);
	    END_IF;
	    
	    IF #si_ActualOnGap <= 0
	        //  OR #sx_StartRelease
	    THEN
	        #sx_StartRelease := TRUE;
	    END_IF;
	    
	    IF (#si_ActualInchingGap <= 0)
	    THEN
	        #sx_StartRelease := FALSE;
	    END_IF;
	    
	    #qx_ExternalRequestHold := (((NOT #sx_StartRelease OR NOT #ix_InchingLineHealthy) OR #ix_DownstreamFull) AND #sx_InchingActive);
	    
	END_REGION
	
	REGION 4 - Internal status - conveyor full
	    
	    // Set conveyor status to full when:
	    IF #sx_InchingActive                     // inching is active 
	        AND #ix_DownstreamFull               // downstream is full
	        AND NOT #ix_ClearCommand             // there is no clear command active
	    THEN
	        #sx_ConveyorFull := TRUE;
	    END_IF;
	    
	    // Set conveyor status to NOT full when:
	    IF (#sx_InchingActive                   // Inching is active
	        AND #ix_ClearCommand                // clear command is active
	        AND NOT #ix_DownstreamFull)         // downstream is NOT full)             
	        OR NOT #sx_InchingActive            // OR Inching isnt active
	    THEN
	        #sx_ConveyorFull := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Status
	    
	    // Convsyor is full status
	    #s_Status.Full := #sx_ConveyorFull;
	    
	    #s_Status.Active := #sx_InchingActive;
	    
	    // Status update on change.
	    IF #s_StatusOld <> #s_Status
	    THEN
	        #qx_Full := #s_Status.Full;
	        #s_StatusOld := #s_Status;
	    END_IF;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_SNCY_Infeed"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 242
// END_ATTRIBUTES
   VAR_INPUT 
      ix_KneeButton { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Signal from knee button
      ix_ResetButton { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Signal from reset button
      ix_PEC_EoS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sensor at end of conveyor
      i_UDT_PECUpdateConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_PECUpdateConfiguration";   // PEC update configuration
      idtl_ActualTime {InstructionName := 'DTL'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DTL;   // Actual date and time in DTL
   END_VAR

   VAR_OUTPUT 
      qx_ConveyorHold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Hold command for conveyor
      qx_WhiteLamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // White signal lamp
      qx_BlueLamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Blue signal lamp
   END_VAR

   VAR_IN_OUT 
      iqa_TrackingData : Array[*] of Int;   // Conveyor tracking data
      iq_UDT_FifoHeaderMFCMessage : "UDT_FifoHeader";   // FIFO header of generated messages
      iqs_FifoDataMFCMessage : Array[*] of "UDT_MessageV2";   // FIFO data Buffer of generated messages
      iqdi_MessageSequenceNumber { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // MFC Sort - Message number
      iqs_MFCNewObjectID : String;   // New Object ID number received from MFC
      is_MFCRejectObjectID : String;   // Number received from MFC with the order to reject the package (ObjectID)
   END_VAR

   VAR 
      s_FB_MFC_Sort_VIDResponse_ASCII { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_MFC_Sort_VIDResponse_ASCII";   // VID message generator
      F_TRIG_PEC_EoS {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Rising edge for photo eye
      sx_WaitForObjectID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Parcel is in position, wait for information from MFC
      sx_WaitForDestination { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Parcel is in position, wait for information from MFC
      sx_WaitForParcel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - Information from MFC received , wait for parcel
      sx_ParcelReject { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True - The parcel is rejected by the MFC system
   END_VAR

   VAR_TEMP 
      tudi_MFCRejectObjectID : UDInt;   // MFC Reject Object ID
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	28/06/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	13/09/2023  | 1.1       | S. Nikodem   | Update interface
	13/03/2024  | 1.2       | S. Nieswiec  | Added to new baseline, block needs uptade after munich is finished
	*)
	
	REGION 1 - Triggers
	    
	    // Rising edge - Parcel detected
	    #F_TRIG_PEC_EoS(CLK := #ix_PEC_EoS);
	    
	END_REGION
	
	REGION 2 - Buttons
	    
	    //Knee button
	    IF #ix_KneeButton AND #ix_PEC_EoS THEN
	        
	        #sx_WaitForParcel := True;
	        
	    END_IF;
	    
	    //Reset button
	    //Reset after removing the package.
	    IF #ix_ResetButton AND #ix_PEC_EoS AND #sx_ParcelReject THEN
	        #sx_ParcelReject := False;
	    END_IF;
	    
	END_REGION
	
	REGION 3 - Data
	    
	    REGION 3.1 - Object ID
	        
	        IF (#iqa_TrackingData[#i_UDT_PECUpdateConfiguration.Distance] > 0) THEN
	            
	            //Match GIN with Object ID
	            IF NOT #ix_PEC_EoS                                                          // Parcel on the sensor 
	                AND NOT "DB_GIN".GIN[#iqa_TrackingData[#i_UDT_PECUpdateConfiguration.Distance]].DHL.MFCMessage.Received.TemporaryParcelIdentifier  //The message for this GIN has not yet been received.
	                AND NOT (#iqs_MFCNewObjectID = '0')                                             // New Object ID
	            THEN
	                
	                //Copy data from MFC
	                "DB_GIN".GIN[#iqa_TrackingData[#i_UDT_PECUpdateConfiguration.Distance]].DHL.ObjectID := #iqs_MFCNewObjectID;
	                
	                //Temporary Parcel Identifier message with Object ID received
	                "DB_GIN".GIN[#iqa_TrackingData[#i_UDT_PECUpdateConfiguration.Distance]].DHL.MFCMessage.Received.TemporaryParcelIdentifier := True;
	                "DB_GIN".GIN[#iqa_TrackingData[#i_UDT_PECUpdateConfiguration.Distance]].General.Identification.GoodRead := True;
	                
	                // Generate VID 
	                #s_FB_MFC_Sort_VIDResponse_ASCII(is_ObjectID := #iqs_MFCNewObjectID,
	                                                 i_ActualTimeDTL := #idtl_ActualTime,
	                                                 iq_UDT_FifoHeader := #iq_UDT_FifoHeaderMFCMessage,
	                                                 iqs_FifoData := #iqs_FifoDataMFCMessage,
	                                                 iqdi_MessageSequenceNumber := #iqdi_MessageSequenceNumber);
	                
	                //VID Response message generated
	                "DB_GIN".GIN[#iqa_TrackingData[#i_UDT_PECUpdateConfiguration.Distance]].DHL.MFCMessage.Sent.VIDResponse := True;
	                
	                //Reset data in DB_MFC
	                #iqs_MFCNewObjectID := '0';
	                
	                //Reset value
	                #sx_WaitForObjectID := False;
	                
	            END_IF;
	            
	        END_IF;
	        
	        
	    END_REGION
	    
	    REGION 3.2 -Destination 
	        
	        IF (#iqa_TrackingData[#i_UDT_PECUpdateConfiguration.Distance] > 0) THEN
	            
	            IF NOT #ix_PEC_EoS                                                              // Parcel on the sensor 
	                AND NOT #sx_WaitForObjectID                                                 // Object ID received
	                AND "DB_GIN".GIN[#iqa_TrackingData[#i_UDT_PECUpdateConfiguration.Distance]].DHL.MFCMessage.Received.Destination                    //The message for this GIN has been received.
	            THEN
	                
	                //Reset value
	                #sx_WaitForDestination := False;
	                
	            END_IF;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 3.3 - Parcel Reject
	        
	        #tudi_MFCRejectObjectID := STRING_TO_UDINT(#is_MFCRejectObjectID);
	        
	        IF (#iqa_TrackingData[#i_UDT_PECUpdateConfiguration.Distance] > 0) THEN
	            
	            IF NOT #ix_PEC_EoS                                                          // Parcel on the sensor 
	                AND NOT #sx_WaitForObjectID                                             // Object ID received
	                AND #tudi_MFCRejectObjectID > 0                       // New destination message from MFC reveived
	                AND ("DB_GIN".GIN[#iqa_TrackingData[#i_UDT_PECUpdateConfiguration.Distance]].DHL.ObjectID = #is_MFCRejectObjectID)
	                AND NOT "DB_GIN".GIN[#iqa_TrackingData[#i_UDT_PECUpdateConfiguration.Distance]].DHL.MFCMessage.Received.RejectParcel //The message for this GIN has not yet been received.
	            THEN
	                
	                //Reject parcel received
	                "DB_GIN".GIN[#iqa_TrackingData[#i_UDT_PECUpdateConfiguration.Distance]].DHL.MFCMessage.Received.RejectParcel := True;
	                
	                //Reset data in DB_MFC
	                #is_MFCRejectObjectID := '0';
	                
	                //Reset value
	                #sx_WaitForDestination := False;
	                
	                //Set value
	                #sx_ParcelReject := True;
	                
	            END_IF;
	            
	        END_IF;
	        
	    END_REGION
	    
	    //Hold conveyor if parcel is detected
	    IF #F_TRIG_PEC_EoS.Q THEN
	        #sx_WaitForObjectID := True;
	        #sx_WaitForDestination := True;
	        #sx_WaitForParcel := FALSE;
	    END_IF;
	    
	    //Data received wait for parcel 
	    IF NOT (#iqs_MFCNewObjectID = '0') THEN
	        #sx_WaitForParcel := True;
	    END_IF;
	    
	    //Hold
	    #qx_ConveyorHold := NOT #sx_WaitForParcel AND (#sx_WaitForDestination OR #sx_ParcelReject);
	    
	END_REGION
	
	REGION 4 - Lamp handling
	    
	    //White lamp 
	    //1 hz - Parcel on the sensor, waiting for data from MFC
	    //On - Waiting for a package
	    #qx_WhiteLamp := NOT #sx_ParcelReject AND (NOT #ix_PEC_EoS OR (#sx_WaitForObjectID AND "DB_Memory".Clock_1Hz));
	    
	    //Blue lamp
	    //1 hz - Parcel reject
	    #qx_BlueLamp := #sx_ParcelReject AND "DB_Memory".Clock_1Hz;
	    
	END_REGION
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_EuchnerLockV2"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 96
// END_ATTRIBUTES
   VAR_INPUT 
      ix_ButtonReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset button
      ix_ButtonRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request open button
      ix_IdCardAccessGranted { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Feedback from DHL- ID card ok - access granted
      ix_DoorClosed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Feedback from lock - door is closed
      ix_BoltTongueClosed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Feedback from lock - bolt tongue closed
      ix_SafelyLoced { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Feedback from lock - Safely locked
      ix_InternalErrorReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Internal error reset command from system control
      ix_LockFault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Lock has an internal fault
      ix_SystemStopped { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Feedback from system - System is stopped
      ix_SafetyLockOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Safety lock status OK
      ix_SafetyLockAckReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Safety lock need acknowledgement
      ii_NumberOfLEDs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Number of programmable LEDs on lock
   END_VAR

   VAR_OUTPUT 
      qx_StopSystem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Signal to stop the system
      qx_ResetButtonLed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset button lamp
      qx_RequestButtonLed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request button lamp
      qx_FaultReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset internal lock fault
      qx_SafetyReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Safety reset command after authorization
      qx_ReleaseLock { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Signal to safety logic to release lock
      q_UDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EuchnerLockStatusV2";   // Status structure
   END_VAR

   VAR 
      s_R_TRIG_RequestButton {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger from reqest button
      s_F_TRIG_BoltTongueClosed {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger from bolt tongue
      s_F_TRIG_ReleaseLock {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger from release lock
      s_FB_TimerOnOffDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Function block to generate on signal delay - emergency request button
      s_FB_TimerOnOffDelay_ResetDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";
      sx_Request { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request to open the door
      sx_ReqMissingAccessRights { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Button access request triggered without permission from DHL
      sx_ResetMissingAccessRights { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Button Reset triggered without permission from DHL
      sx_DoorOpenedWithoutReq { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Doors were opened without request and permission
   END_VAR

   VAR CONSTANT 
      c_Time : UDInt := 10000;
   END_VAR


BEGIN
	
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |
	---------------------------------------------------------------------------------------- 
	                                                                                  
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	11/03/2022  | 0.1       | S.Nikodem    | first release MHS TIA 15.1
	24/08/2022  | 0.2       | K. Pokorski  | Change to Lock with key switch and only one LED
	11/10/2023  | 0.3       | M.Diebel     | first release Fortna TIA 17
	30/01/2024  | 0.4       | A. Bunzel    | Add logic for ID cards from DHL
	13/03/2024  | 0.5       | S. Nieswiec  | Changed name to V2
	*)
	
	REGION 1 - Request open
	    
	    //Button
	    //Rising edge trigger 
	    #s_R_TRIG_RequestButton(CLK := #ix_ButtonRequest);
	    
	    // Flip-flop
	    IF #s_R_TRIG_RequestButton.Q AND #ix_IdCardAccessGranted THEN
	        
	        IF #sx_Request THEN
	            #sx_Request := FALSE;
	        ELSE
	            #sx_Request := TRUE;
	        END_IF;
	        
	    END_IF;
	    
	    // Reset Flip-Flop
	    IF NOT #ix_BoltTongueClosed THEN
	        #sx_Request := FALSE;
	    END_IF;
	    
	    //Stop system
	    #qx_StopSystem := #sx_Request;
	    
	    //If system is stopped and is safe then open lock
	    #qx_ReleaseLock := (#sx_Request AND #ix_SystemStopped);
	    
	END_REGION
	
	REGION 2 - Lamp controlling 
	    
	    
	    CASE #ii_NumberOfLEDs OF
	        1:
	            //2.5Hz blinking during fault
	            IF #ix_LockFault THEN
	                #qx_ResetButtonLed := "mx_Clock_2.5Hz";
	                //2.5Hz blinking when ACK required
	            ELSIF #ix_SafetyLockAckReq THEN
	                #qx_ResetButtonLed := "mx_Clock_2.5Hz";
	                //1.0Hz blinking during open request
	            ELSIF #sx_Request AND NOT #ix_SystemStopped THEN
	                #qx_ResetButtonLed := "mx_Clock_1Hz";
	                // Solid when system stopped after request
	            ELSIF #sx_Request THEN
	                #qx_ResetButtonLed := TRUE;
	                // Solid when doors open 
	            ELSIF (NOT #ix_SafelyLoced AND NOT #ix_BoltTongueClosed) THEN
	                #qx_ResetButtonLed := TRUE;
	                // Turn off when gate closed and acknowledged 
	            ELSE
	                #qx_ResetButtonLed := FALSE;
	            END_IF;
	            
	        2:
	            // Reset button LED - Blue
	            // Lamp active - Reset access is granted and reset request is active
	            // Lamp flashing - Error doors where opened without request
	            IF #sx_DoorOpenedWithoutReq AND NOT #ix_BoltTongueClosed THEN
	                #qx_ResetButtonLed := "mx_Clock_0.625Hz";
	            ELSIF #ix_IdCardAccessGranted AND #ix_SafetyLockAckReq THEN
	                #qx_ResetButtonLed := TRUE;
	            ELSE
	                #qx_ResetButtonLed := FALSE;
	            END_IF;
	            
	            // Request button LED - White
	            // Lamp active - System is stopped and safety 
	            // Lamp flashing 0.62Hz - Error doors where opened without request
	            // Lamp flashing 1HZ - Request is active, system still not save.
	            // Lamp flashing 2.5Hz - Access rights are granted, and it is possible to make entry request. 
	            IF #sx_DoorOpenedWithoutReq AND NOT #ix_BoltTongueClosed THEN
	                #qx_RequestButtonLed := "mx_Clock_0.625Hz";
	            ELSIF (#sx_Request AND #ix_SystemStopped) OR NOT #ix_SafetyLockOK THEN
	                #qx_RequestButtonLed := TRUE;
	            ELSIF #sx_Request THEN
	                #qx_RequestButtonLed := "mx_Clock_1Hz";
	            ELSIF #ix_IdCardAccessGranted THEN
	                #qx_RequestButtonLed := "mx_Clock_2.5Hz";
	            ELSE
	                #qx_RequestButtonLed := FALSE;
	            END_IF;
	    END_CASE;
	    
	END_REGION
	
	REGION 3 - Fault
	    
	    //Triggers 
	    #s_F_TRIG_BoltTongueClosed(CLK := #ix_BoltTongueClosed);
	    #s_F_TRIG_ReleaseLock(CLK := #qx_ReleaseLock);
	    
	    // Alarm from unauthorized open request 
	    IF #ix_ButtonRequest AND NOT #ix_IdCardAccessGranted THEN
	        
	        #sx_ReqMissingAccessRights := TRUE;
	        
	    END_IF;
	    
	    // Alarm when Doors are opened from inside (red door handle) without request
	    IF NOT #qx_ReleaseLock AND NOT #s_F_TRIG_ReleaseLock.Q AND #s_F_TRIG_BoltTongueClosed.Q THEN
	        #sx_DoorOpenedWithoutReq := TRUE;
	    END_IF;
	    
	    // Alarm from unauthorized reset request
	    IF NOT #ix_IdCardAccessGranted AND #ix_ButtonReset THEN
	        #sx_ResetMissingAccessRights := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION 4 - Falut reset
	    
	    // reset alarm from unauthorized open request 
	    IF #ix_InternalErrorReset AND #sx_ReqMissingAccessRights THEN
	        #sx_ReqMissingAccessRights := FALSE;
	    END_IF;
	    
	    // reset alarm when Doors are opened from inside (red door handle) without request
	    IF #ix_InternalErrorReset AND #sx_DoorOpenedWithoutReq THEN
	        #sx_DoorOpenedWithoutReq := FALSE;
	    END_IF;
	    
	    // reset alarm from unauthorized reset request
	    IF #ix_InternalErrorReset AND #sx_ResetMissingAccessRights THEN
	        #sx_ResetMissingAccessRights := FALSE;
	    END_IF;
	    
	    // extended reset signal for door lock when error exist
	    #s_FB_TimerOnOffDelay_ResetDelay(iudi_OnDelayTime := 0,
	                                     iudi_OffDelayTime := 3500,
	                                     ix_SignalToDelay := (#ix_LockFault) AND (#ix_IdCardAccessGranted) AND (#ix_ButtonReset));
	    
	    
	    // Set reset signal
	    #qx_FaultReset := #s_FB_TimerOnOffDelay_ResetDelay.qx_DelayedSignal;
	    
	END_REGION
	REGION 5 - Reset safety command
	    // Command for safety reset 
	    #qx_SafetyReset := #ix_IdCardAccessGranted AND #ix_SafetyLockAckReq AND #ix_ButtonReset;
	    
	END_REGION
	REGION 6 - Status
	    
	    // Copy status
	    #q_UDT_Status.LockFault := #ix_LockFault;
	    #q_UDT_Status.DoorClosed := #ix_DoorClosed;
	    #q_UDT_Status.DoorOpened := NOT #ix_DoorClosed;
	    #q_UDT_Status.ReqMissingAccessRights := #sx_ReqMissingAccessRights;
	    #q_UDT_Status.DoorOpenedWithoutReq := #sx_DoorOpenedWithoutReq;
	    #q_UDT_Status.ResetMissingAccessRights := #sx_ResetMissingAccessRights;
	    #q_UDT_Status.BoltTongueClosed := #ix_BoltTongueClosed;
	    #q_UDT_Status.Safelylocked := #ix_SafelyLoced;
	    #q_UDT_Status.SafetyLockAckReq := #ix_SafetyLockAckReq;
	    
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_EncoderValue"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 95
// END_ATTRIBUTES
   VAR_INPUT 
      i_UDT_EncoderConfiguration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EncoderConfigurationV2";   // Encoder configuration structure
      id_EncoderValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Encoder value
      ix_EncoderDirection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True if encoder rotates forward, False if encoder rotates reverse
      ix_ConveyorRunningFwd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True when the conveyor is running in the forward direction
      ix_ConveyorRunningRvs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True when the conveyor is running in the reverse direction
   END_VAR

   VAR_OUTPUT 
      q_UDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_EncoderStatusV2";   // Encoder status structure
      qi_ActualSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Calculated speed [mm/sec]
      qi_Displacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Calculated displacement [cm]
   END_VAR

   VAR_IN_OUT 
      iq_UDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
      iq_UDT_Statistics : "UDT_EncoderStatisticsV2";   // Statistics structure
   END_VAR

   VAR 
      s_FB_SamplingTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Error detection timer
      s_FB_RunningFeedbackError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Error detection timer
      R_TRIG_RunningFeedbackError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of running feedback error
      R_TRIG_InvalidValue {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of invalid value
      R_TRIG_NoDirection {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger of no direction command
      s_UDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_EncoderStatusV2";   // Encoder status structure
      sa_EncoderData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..10] of DInt;   // Encoder data in array
      sa_SpeedData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..20] of Struct   // Encoder sampled distance and time in array
         Distance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Distance [mm]
         "Time" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Time [sec]
      END_STRUCT;
      slr_FormDisplacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Conveyor displacement [cm]
      slr_Correction { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Correction [cm]
      sdi_Value { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Value from encoder card
      sdi_OldValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Old value from encoder card
      sdi_Delta { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Encoder value per cycle
      si_StatusMoveBLKVariant { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Move BLK status
      si_SampleDisplacement { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Travel the distance for one sample
      si_ActualSpeed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Actual speed [mm/sec]
      sx_InvalidValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Invalid encoder value
   END_VAR

   VAR_TEMP 
      ti_TotalTime : UDInt;   // Total sampled time
      ti_TotalDistance : DInt;   // Total sampled distance
      ti_Displacement : Int;   // Conveyor displacement [cm]
      ti_ArraySize : Int;   // Array size
      ti_LoopActulaSpeed : Int;   // Loop counter
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------   
	
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	29/03/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	12/03/2024  | 1.1       | S. Nieswiec  | Updated for new baseline
	*)
	
	REGION 1 - Triggers
	    
	    //Conveyor is not running
	    #R_TRIG_NoDirection(CLK := NOT #ix_ConveyorRunningFwd AND NOT #ix_ConveyorRunningRvs);
	    
	    //Invalid value error
	    #R_TRIG_InvalidValue(CLK := #s_UDT_Status.InvalidValue);
	    
	END_REGION
	
	REGION 1 - Displacement 
	    
	    //Check if encoder value is in range
	    IF #id_EncoderValue > #i_UDT_EncoderConfiguration.EncoderMaxValue THEN
	        
	        //Set fault 
	        #sx_InvalidValue := TRUE;
	        
	    ELSE
	        
	        //Copy encoder value
	        #sdi_Value := #id_EncoderValue;
	        
	        //Reset fault
	        #sx_InvalidValue := FALSE;
	        
	    END_IF;
	    
	    REGION 1.1 - Encoder data
	        
	        IF (#sdi_OldValue <> #sdi_Value)
	            AND NOT #s_UDT_Status.InvalidValue
	        THEN
	            
	            //Check array size
	            #ti_ArraySize := "FC_GetNrOfArrayEl"(iv_Array := #sa_EncoderData);
	            
	            // Switch data in the array
	            #si_StatusMoveBLKVariant := MOVE_BLK_VARIANT(SRC := #sa_EncoderData, COUNT := INT_TO_UINT(#ti_ArraySize - 1), SRC_INDEX := 0, DEST_INDEX := 1, DEST => #sa_EncoderData);
	            
	            //Save data in array 
	            #sa_EncoderData[1] := #sdi_Value;
	            
	            //Conveyor is running in the forward direction
	            IF #ix_EncoderDirection THEN
	                
	                IF #sa_EncoderData[1] < #sa_EncoderData[2] THEN
	                    
	                    //Rollover
	                    #sdi_Delta := #i_UDT_EncoderConfiguration.EncoderMaxValue - #sa_EncoderData[2] + #sa_EncoderData[1];
	                    
	                ELSE
	                    
	                    #sdi_Delta := #sa_EncoderData[1] - #sa_EncoderData[2];
	                    
	                END_IF;
	                
	            END_IF;
	            
	            //Conveyor is running in the reverse direction
	            IF #ix_EncoderDirection THEN
	                
	                IF #sa_EncoderData[1] > #sa_EncoderData[2] THEN
	                    
	                    //Rollover
	                    #sdi_Delta := #i_UDT_EncoderConfiguration.EncoderMaxValue - #sa_EncoderData[1] + #sa_EncoderData[2];
	                    
	                ELSE
	                    
	                    #sdi_Delta := #sa_EncoderData[2] - #sa_EncoderData[1];
	                    
	                END_IF;
	                
	            END_IF;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 1.2 - mm per encoder incremental
	        
	        //Count up value in mm , 
	        // Displacement is calculated using actual conveyor speed and the previous PLC cycle scan time
	        #slr_FormDisplacement := DINT_TO_LREAL(#sdi_Delta) * #i_UDT_EncoderConfiguration.mmPerIncrement / 10.0;
	        
	        //Accumulate the rest of the calculated value
	        #slr_Correction := FRAC(#slr_FormDisplacement) + #slr_Correction;
	        
	        // The actual displacement is a sum of complete parts of the displacement and correction variables
	        #ti_Displacement := DINT_TO_INT(TRUNC(#slr_FormDisplacement) + TRUNC(#slr_Correction));
	        
	        // Correction incrementation or decremantation if it exceeds 1 or -1 in case of negative speed
	        IF (#slr_Correction >= 1)
	        THEN
	            
	            #slr_Correction -= 1;
	            
	        ELSIF (#slr_Correction <= -1)
	        THEN
	            
	            #slr_Correction += 1;
	            
	        END_IF;
	        
	        //Reset delta value
	        #sdi_Delta := 0;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 2- Actual speed
	    
	    //Check array size
	    #ti_ArraySize := "FC_GetNrOfArrayEl"(iv_Array := #sa_SpeedData);
	    
	    //Sampling time
	    #s_FB_SamplingTime(iudi_OnDelayTime := #i_UDT_EncoderConfiguration.SamplingTime,
	                       ix_SignalToDelay := (#ix_ConveyorRunningFwd OR #ix_ConveyorRunningRvs) AND NOT #s_FB_SamplingTime.qx_DelayedSignal);
	    
	    //Save displacemnt only when conveyor is running 
	    IF #ix_ConveyorRunningFwd OR #ix_ConveyorRunningRvs THEN
	        #si_SampleDisplacement += #ti_Displacement;
	    END_IF;
	    
	    //Saving data every sampling time
	    IF #s_FB_SamplingTime.qx_DelayedSignal THEN
	        
	        // Switch data in the array
	        #si_StatusMoveBLKVariant := MOVE_BLK_VARIANT(SRC := #sa_SpeedData, COUNT := INT_TO_UINT(#ti_ArraySize - 1), SRC_INDEX := 0, DEST_INDEX := 1, DEST => #sa_SpeedData);
	        
	        //Copy data to array
	        //Save distance value in mm
	        #sa_SpeedData[1].Distance := #si_SampleDisplacement;
	        //Save time value in ms
	        #sa_SpeedData[1]."Time" := (LREAL_TO_UDINT(#s_FB_SamplingTime.qlr_ActualTime));
	        
	        //Reset varaible
	        #si_SampleDisplacement := 0;
	        
	    END_IF;
	    
	    //Calculate the speed according to the data in the array
	    FOR #ti_LoopActulaSpeed := 1 TO #ti_ArraySize DO
	        
	        //[mm]
	        #ti_TotalDistance += ABS(#sa_SpeedData[#ti_LoopActulaSpeed].Distance);
	        //[sec]
	        #ti_TotalTime += #sa_SpeedData[#ti_LoopActulaSpeed]."Time";
	        
	        //Reset data in array
	        IF #R_TRIG_NoDirection.Q THEN
	            
	            #sa_SpeedData[#ti_LoopActulaSpeed].Distance := 0;
	            #sa_SpeedData[#ti_LoopActulaSpeed]."Time" := 0;
	            
	        END_IF;
	        
	    END_FOR;
	    
	    //Actual speed in mm/sec
	    #si_ActualSpeed := DINT_TO_INT((#ti_TotalDistance / (UDINT_TO_DINT(#ti_TotalTime) / 1000)));
	    
	END_REGION
	
	REGION 3 - Error
	    
	    REGION 3.1 - Running feedback error
	        
	        //Timer
	        #s_FB_RunningFeedbackError(iudi_OnDelayTime := #i_UDT_EncoderConfiguration.ErrorFilter,
	                                   ix_SignalToDelay := (#ix_ConveyorRunningFwd OR #ix_ConveyorRunningRvs) AND (#sdi_OldValue = #sdi_Value));
	        
	        //Save last encoder value
	        #sdi_OldValue := #sdi_Value;
	        
	        //Trigger from error signal
	        #R_TRIG_RunningFeedbackError(CLK := #s_FB_RunningFeedbackError.qx_DelayedSignal);
	        
	        //Set running feedback error
	        IF #R_TRIG_RunningFeedbackError.Q THEN
	            #s_UDT_Status.RunningFeedbackError := True;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 3.2 - Invalid Value error
	        
	        //Set invalid value error
	        IF #sx_InvalidValue THEN
	            #s_UDT_Status.InvalidValue := True;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 3.3 - Reset
	        
	        //Reset error
	        IF #iq_UDT_EquipmentControl.Command.Reset THEN
	            #s_UDT_Status.RunningFeedbackError := False;
	            #s_UDT_Status.InvalidValue := False;
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 4 - Statistics
	    
	    // Running feedback error statistics
	    IF #s_UDT_Status.RunningFeedbackError
	        OR #iq_UDT_EquipmentControl.Command.ResetData                                         // Reset statistics
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iq_UDT_EquipmentControl.Command.ResetData,               // Reset statistics input
	                        ix_Activate := #s_UDT_Status.RunningFeedbackError,                    // Activate statistics functions input
	                        ix_RTrigActivate := #R_TRIG_RunningFeedbackError.Q,                   // Statistics active trigger
	                        iqUDT_Statistics := #iq_UDT_Statistics.RunningFeedbackError);        // Statistics values output
	        
	    END_IF;
	    
	    // Invalid Value statistics
	    IF #s_UDT_Status.InvalidValue
	        OR #iq_UDT_EquipmentControl.Command.ResetData                                         // Reset statistics
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iq_UDT_EquipmentControl.Command.ResetData,               // Reset statistics input
	                        ix_Activate := #s_UDT_Status.InvalidValue,                            // Activate statistics functions input
	                        ix_RTrigActivate := #R_TRIG_InvalidValue.Q,                           // Statistics active trigger
	                        iqUDT_Statistics := #iq_UDT_Statistics.InvalidValue);                // Statistics values output
	        
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Outputs
	    
	    //Check motor direction
	    IF #ix_ConveyorRunningFwd THEN
	        
	        //Actual speed
	        #qi_ActualSpeed := #si_ActualSpeed;
	        //Displacement
	        #qi_Displacement := #ti_Displacement;
	        
	    ELSIF #ix_ConveyorRunningRvs THEN
	        
	        //Actual speed
	        #qi_ActualSpeed := #si_ActualSpeed * -1;
	        //Displacement
	        #qi_Displacement := #ti_Displacement * -1;
	        
	    ELSE
	        
	        //Actual speed
	        #qi_ActualSpeed := 0;
	        //Displacement
	        #qi_Displacement := 0;
	        
	    END_IF;
	    
	    //Copy value to output
	    //Status
	    #q_UDT_Status := #s_UDT_Status;
	    
	    
	END_REGION
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_ABSwitch"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// ATTRIBUTES
// AUTO_NUMBER = True
// BLOCK_NUMBER = 87
// END_ATTRIBUTES
   VAR_INPUT 
      iUDT_ABSwitchConfig { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ABSwitchConfiguration";   // AB Switch Configuration structure
      ix_SafetyOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when Safety Circuit of the Conveyor is healthy
      ix_PRXUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when upper position sensor is not covered
      ix_PRXDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when lower position sensor is not covered
      ix_PRXBrkUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when sensor to slow down the speed is not covered
      ix_PRXBrkDwn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when sensor to slow down the speed is not covered
      ix_LSUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when upper limit sensor is not covered
      ix_LSDwn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when lower limit sensor is not covered
      ix_PECFreUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when nothing is within the range of the motion sensor
      ix_PECFreDwn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when nothing is within the range of the motion sensor
      ix_SSMan { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when on Local Controll Panel switch [1] Manual; [0] Automatic
      ix_PBDwn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when Local Control Panel switch Down is on
      ix_PBUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when Local Control Panel switch Up is on
      ix_PBRst { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when Local Control Panel reset is on
      ix_HardwareOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when hardware is Ok
      ii_Mode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Mode - [1] Upper position [2] Lower position
      ix_ChangeModeSignal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // TRUE when change mode command active
   END_VAR

   VAR_OUTPUT 
      qUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_ABSwitchStatus";   // HMI status structure
      qUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "UDT_CommonStatus";   // Common status structure
      qx_ExternalHold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // External hold for AB Switch belt
   END_VAR

   VAR_IN_OUT 
      iqUDT_EquipmentControl : "UDT_EquipmentControl";   // Equipment control structure
      iqUDT_ABSwitchInterface : "UDT_ConveyorInterface";   // Interface AB Switch motor
      iqUDT_Statistics : "UDT_ABSwitchStatistics";   // Statistics structure
   END_VAR

   VAR 
      sUDT_HMIStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_ABSwitchStatus";   // HMI status structure
      sUDT_StatusOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Common status structure
      sUDT_Status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "UDT_CommonStatus";   // Common status structure
      Jog_Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Filtering lower jam photo eye signal
      SwitchingTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_TimerOnOffDelay";   // Switching time
      R_TRIG_ManualMode {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger manual mode
      R_TRIG_ManualJogUp {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger manual jog mode command
      R_TRIG_ManualJogDown {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger manual jog mode command
      R_TRIG_DownTime {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger VSU is stopped
      R_TRIG_Error {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger for Error
      R_TRIG_UPSwA_Error {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger for Upper switch area error
      R_TRIG_LowSwA_Error {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger for Lower switch area error
      R_TRIG_UpTime {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger AB switch is running automatic
      R_TRIG_RestartFromError {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // Rising edge trigger Restart from error
      F_TRIG_PECBrakeUp {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger for PEC brake up
      F_TRIG_PECBrakeDown {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger for PEC brake down
      F_TRIG_PECUp {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger for PEC up position
      F_TRIG_PECDown {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger for PEC down position
      R_TRIG_PreStartSemiAutomaticUp {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger for Pre start semi automatic up signal
      R_TRIG_PreStartSemiAutomaticDown {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;   // Falling edge trigger for Pre start semi automatic down signal
      ss_ABSwitch_Interface { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // VSU interface static structure
         Positioning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         SemiAutomatic { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Manual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         RunEnabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      END_STRUCT;
      sx_StartReceived { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start command received from system
      sx_Ready { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Conveyor Ready to operate in Automatic mode
      sx_SemiAutomatic { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Running in semi automatic
      sx_PreStartManual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Pre conditions to run conveyor in manual mode
      sx_Stopping { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stopping is active, first reach position
      sx_SwitchEnable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Switching conditions
      sx_UpRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request upper outfeed position for actual parcel
      sx_DownRequest { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request lower outfeed position for actual parcel
      sx_ActualPositionUP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Actual position is up
      sx_ActualPositionDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Actual position is down
      sx_CombinedJogUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Combined signal of jogging buttons
      sx_CombinedJogDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Combined signal of jogging buttons
      sx_RestartFromError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // After an error has occurred the action to be done before resuming normal operation
      sx_Jog { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Off delayed signal Jogging was activated
      sx_ConfigurationError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Commissioning: configuration of parameters is wrong
      sx_JogUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // AB Switch in manual mode - jog up
      sx_JogDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // AB Switch in manual mode - jog down
      sx_ABSwitchSlowSpeedUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Slow down the speed when AB Switch is going up
      sx_ABSwitchSlowSpeedDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Slow down the speed when AB Switch is going down
      sx_UpperPositionReached { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // AB Switch is in upper position
      sx_LowerPositionReached { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // AB Switch is in lower position
      sx_PreStartSemiAutomaticUp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Pre conditions to run conveyor in semi automatic up mode
      sx_PreStartSemiAutomaticDown { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Pre conditions to run conveyor in semi automatic down  mode
   END_VAR

   VAR_TEMP 
      ti_ActiveSensor : Int;   // Active sensor counter
   END_VAR

   VAR CONSTANT 
      ci_UpperPosition : Int := 1;   // Upper position number
      ci_LowerPosition : Int := 2;   // Lower position number
   END_VAR


BEGIN
	(*
	----------------------------------------------------------------------------------------
	|                                                                                      |
	|  Copyright  2023             FORTNA Europe BV                                        |
	|  All Rights Reserved         Netherlands                                             |
	|                                                                                      |  
	----------------------------------------------------------------------------------------                                           
	Version history:
	Date        | Version   | Author       | Remark
	----------------------------------------------------------------------------------------
	19/05/2023  | 1.0       | S. Nikodem   | Release TIA 17 | DHL Munich 2023
	19/12/2023  | 1.1       | S. Nikodem   | On site update
	09/02/2024  | 1.2       | P.Gryszczyk  | Gap Down sensor invert
	02/03/2024  | 1.3       | P.Gryszczyk  | HMI Lower Upper Position invert
	12/03/2024  | 1.4       | S. Nieswiec  | Addjusting to naming standard
	*)
	
	REGION 1 - Initial
	    
	    REGION 1.1 - Triggers
	        
	        // Detecting rising edge on manual mode Or from Equipment Control
	        #R_TRIG_ManualMode(CLK := #sUDT_Status.Manual);
	        
	        // Rising edge trigger running        
	        #R_TRIG_UpTime(CLK := #sx_SemiAutomatic AND #sx_Ready);
	        
	        // Detecting rising edge AB switch stopped        
	        #R_TRIG_DownTime(CLK := #sx_SemiAutomatic AND NOT #sx_Ready);
	        
	        // Detecting rising edge on AB switch error
	        #R_TRIG_Error(CLK := #sUDT_Status.Error);
	        
	        // Detecting rising edge on start of the restart from error sequence
	        #R_TRIG_RestartFromError(CLK := #sx_RestartFromError);
	        
	    END_REGION
	    
	    REGION 1.2 - Filters
	        
	        // Time to start without start warning while jogging
	        #Jog_Enable(iudi_OffDelayTime := #iUDT_ABSwitchConfig.JogNoHornTime,
	                    ix_SignalToDelay := #sx_Jog);
	        
	    END_REGION
	    
	    REGION 1.3 - Switching conditions
	        
	        #sx_SwitchEnable := NOT #iqUDT_ABSwitchInterface.VFDRunning;
	        
	    END_REGION
	    
	    REGION 1.4 - Positioning
	        
	        // To add manual mode
	        
	        #ss_ABSwitch_Interface.Positioning := #iqUDT_ABSwitchInterface.ActualSpeed <> 0
	        AND #sx_SemiAutomatic
	        AND NOT #iqUDT_ABSwitchInterface.InternalErrorVFD;
	        
	    END_REGION
	    
	    REGION 1.5 - Position
	        
	        #sx_ActualPositionUP := NOT #ss_ABSwitch_Interface.Positioning                              // The positioning is not active 
	        AND NOT #ix_PRXUp;                                                          // And the position sensor signals
	        
	        #sx_ActualPositionDown := NOT #ss_ABSwitch_Interface.Positioning                            // The positioning is not active                                                      
	        AND NOT #ix_PRXDown;                                                        // And the position sensor signals
	        
	    END_REGION
	    
	END_REGION
	
	REGION 2 - Errors
	    
	    REGION 2.1 - Reset errors
	        
	        //Global reset
	        IF #iqUDT_EquipmentControl.Command.Reset                                       // Reset
	        THEN
	            // Switch area
	            IF #sUDT_HMIStatus.Specific.UpperSwitchAreaError                            // Upper jam error is active 
	                AND #ix_PECFreUp                                                       // Upper jam sensor is free
	            THEN
	                
	                #sUDT_HMIStatus.Specific.UpperSwitchAreaError := FALSE;                 // reset error
	                
	            END_IF;
	            
	            IF #sUDT_HMIStatus.Specific.LowerSwitchAreaError                            // lower jam error is active 
	                AND #ix_PECFreDwn                                                     // Lower jam sensor is free
	            THEN
	                
	                #sUDT_HMIStatus.Specific.LowerSwitchAreaError := FALSE;                 // reset error
	                
	            END_IF;
	            
	        END_IF;
	        
	        //Local reset
	        IF #ix_PBRst THEN
	            
	            // Switch area
	            IF #sUDT_HMIStatus.Specific.UpperSwitchAreaError                            // Upper jam error is active 
	                AND #ix_PECFreUp                                                       // Upper jam sensor is free
	            THEN
	                
	                #sUDT_HMIStatus.Specific.UpperSwitchAreaError := FALSE;                 // reset error
	                
	            END_IF;
	            
	            IF #sUDT_HMIStatus.Specific.LowerSwitchAreaError                            // lower jam error is active 
	                AND #ix_PECFreDwn                                                     // Lower jam sensor is free
	            THEN
	                
	                #sUDT_HMIStatus.Specific.LowerSwitchAreaError := FALSE;                 // reset error
	                
	            END_IF;
	            
	            #sUDT_HMIStatus.Specific.SwitchingTimerError := False;
	            #sUDT_HMIStatus.Specific.LimitSensorLowerPosition := False;
	            #sUDT_HMIStatus.Specific.LimitSensorUpperPosition := False;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 2.2 - Set errors
	        
	        // Upper Jam sensor blocked in movement
	        IF NOT #ix_PECFreUp AND #ss_ABSwitch_Interface.Positioning
	            
	        THEN
	            #sUDT_HMIStatus.Specific.UpperSwitchAreaError := TRUE;                      // Set error upper jam sensor
	        END_IF;
	        
	        // Lower Jam sensor blocked in movement
	        IF NOT #ix_PECFreDwn AND #ss_ABSwitch_Interface.Positioning
	        THEN
	            #sUDT_HMIStatus.Specific.LowerSwitchAreaError := TRUE;                      // Set error lower jam sensor
	        END_IF;
	        
	        //Configuration error
	        #sx_ConfigurationError := (#iUDT_ABSwitchConfig.BrakingSpeedSetpoint > #iUDT_ABSwitchConfig.NominalSpeedSetPoint)
	        OR #iUDT_ABSwitchConfig.NominalSpeedSetPoint = 0
	        OR #iUDT_ABSwitchConfig.BrakingSpeedSetpoint = 0
	        OR #iUDT_ABSwitchConfig.ManualModeSpeed = 0
	        OR #iUDT_ABSwitchConfig.SwitchingTime = 0
	        OR #iUDT_ABSwitchConfig.JogNoHornTime = 0
	        OR (#iUDT_ABSwitchConfig.BrakingSpeedSetpoint > 500);
	        
	        //Switching Time
	        #SwitchingTime(iudi_OnDelayTime := #iUDT_ABSwitchConfig.SwitchingTime,
	                       iudi_OffDelayTime := 0,
	                       ix_SignalToDelay := #sx_SemiAutomatic AND NOT #iqUDT_EquipmentControl.Request.SignalingRequest AND (#sx_UpRequest AND #ix_PRXUp) OR (#sx_DownRequest AND #ix_PRXDown));
	        
	        IF #SwitchingTime.qx_DelayedSignal THEN
	            #sUDT_HMIStatus.Specific.SwitchingTimerError := True;
	        END_IF;
	        
	        // Reference error - set error when more like one position sensor is active
	        #ti_ActiveSensor := 0;
	        
	        //Position sensor up
	        IF NOT #ix_PRXUp THEN
	            #ti_ActiveSensor += 1;
	        END_IF;
	        
	        //Position sensor down
	        IF NOT #ix_PRXDown THEN
	            #ti_ActiveSensor += 1;
	        END_IF;
	        
	        //Brake sensor up
	        IF NOT #ix_PRXBrkUp THEN
	            #ti_ActiveSensor += 1;
	        END_IF;
	        
	        //Brak sensor down
	        IF NOT #ix_PRXBrkDwn THEN
	            #ti_ActiveSensor += 1;
	        END_IF;
	        
	        //Limit switch up
	        IF NOT #ix_LSUp THEN
	            #ti_ActiveSensor += 1;
	        END_IF;
	        
	        //Limit switch down
	        IF NOT #ix_LSDwn THEN
	            #ti_ActiveSensor += 1;
	        END_IF;
	        
	        IF #ti_ActiveSensor >= 2 THEN
	            #sUDT_HMIStatus.Specific.ReferenceError := True;
	        ELSE
	            #sUDT_HMIStatus.Specific.ReferenceError := False;
	        END_IF;
	        
	        //Limit switch active
	        IF NOT #ix_LSUp THEN
	            
	            #sUDT_HMIStatus.Specific.LimitSensorUpperPosition := True;
	            
	        END_IF;
	        
	        IF NOT #ix_LSDwn THEN
	            
	            #sUDT_HMIStatus.Specific.LimitSensorLowerPosition := True;
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 2.3 - Common Error
	        
	        #sUDT_Status.Error :=
	        #iqUDT_ABSwitchInterface.InternalErrorTracking                                 // or the AB switch conveyor detected an error in tracking 
	        OR #iqUDT_ABSwitchInterface.InternalErrorVFD                                   // or there are errors in the VFD
	        OR NOT #ix_HardwareOk                                                               // or an internal error in the RIO panel occured
	        OR #sUDT_HMIStatus.Specific.UpperSwitchAreaError                                // or Upper jam PEC detected WHILE going Up
	        OR #sUDT_HMIStatus.Specific.LowerSwitchAreaError;                                // or Lower jam PEC detected while going Down
	        
	    END_REGION
	    
	END_REGION
	
	REGION 3 - Check conditions to set Equipment ready
	    
	    //Conditions to set bit sx_Ready to operate 
	    #sx_Ready := NOT #sUDT_Status.Error                                                // Error not present
	    AND #ix_SafetyOk                                                                  // Safety signalling OK
	    AND NOT #sUDT_HMIStatus.Specific.LimitSensorUpperPosition
	    AND NOT #sUDT_HMIStatus.Specific.LimitSensorLowerPosition;
	    
	    
	END_REGION
	
	REGION 4 - Stop Equipment
	    
	    IF (#ix_SSMan                                                        // Manual mode is active
	        AND #sx_SemiAutomatic                                                       // AB switch is in semi-automatic mode
	        OR (NOT #iqUDT_EquipmentControl.Command.AutomaticOn                        // AB switch stops if the bit AutomaticOn from control block is false
	        AND NOT #ix_SSMan)                                               // Manual mode active bit
	        OR (NOT #sx_Ready                                                           // Bit AB switch ready to run in automatic mode
	        AND NOT #ix_SSMan)                                               // Manual mode active
	        OR #ix_SSMan                                                      // LCP is not set to automatic
	        OR NOT #ix_SafetyOk)                                                        // Safety is not ok
	    THEN                                                                            // Order to stop 
	        #sx_Stopping := TRUE;                                                       // stopping is activated
	        #sx_SemiAutomatic := FALSE;                                                 // switch of automatic activ
	        #sx_StartReceived := FALSE;                                                 // Start command received from system 
	        
	    END_IF;
	    
	    IF (#sx_Stopping                                                                 // stopping is activated
	        AND NOT #ss_ABSwitch_Interface.Positioning)                                       // The positioning device is not active positioning 
	        OR NOT #sx_Ready                                                             // AB switch is not ready to run
	    THEN
	        #sx_Stopping := FALSE;                                                       // stopping is activated
	    END_IF;
	    
	END_REGION
	
	REGION 5 - Start Semi-automatic mode 
	    
	    REGION 5.1 - Start 
	        
	        // if start (OS) is received from system, this is memorised until started in cascade 
	        IF #iqUDT_EquipmentControl.Command.Start                                       // Start from system
	            AND #sx_Ready                                                               // Equipment has no errors
	        THEN
	            #sx_StartReceived := TRUE;                                                  // Start command received from system 
	        END_IF;
	        
	        IF #sx_StartReceived                                                            // Start command received from system
	            AND NOT #ix_SSMan                                                         // and the LCP is set to auto
	        THEN
	            #sx_SemiAutomatic := TRUE;                                                  // Automatic activated
	            #sx_StartReceived := FALSE;                                                 // Start command received from system
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 6 - Manual mode 
	    
	    REGION 6.1 - Jog signals
	        
	        #sx_CombinedJogUp := #ix_SSMan                                                          // box in manual
	        AND #ix_PBUp;                                                                // If selected jog in positive direction 
	        
	        #sx_CombinedJogDown := #ix_SSMan                                                           // box in manual
	        AND #ix_PBDwn;                                                               // If selected jog in negative direction 
	        
	        // Detecting rising edge on manual jog Up           
	        #R_TRIG_ManualJogUp(CLK := #sx_CombinedJogUp);
	        
	        // Detecting rising edge on manual jog Down          
	        #R_TRIG_ManualJogDown(CLK := #sx_CombinedJogDown);
	        
	    END_REGION
	    
	    REGION 6.2 - Manual PreStart up or down
	        
	        // Pre start conditions to run in manual mode
	        #sx_PreStartManual := #ix_SSMan                                      // Manual mode active bit
	        AND #ix_SafetyOk                                                                // Safety healthy bit
	        AND NOT #iqUDT_ABSwitchInterface.InternalErrorVFD;                             // Profinet comunication or PN_DEvice not ok 
	        
	        
	        IF #sx_PreStartManual                                                           // Pre start conditions to run in manual mode
	            AND (#R_TRIG_ManualJogUp.Q                                                  // Trigger to start AB switch run in manual jog mode UP
	            OR #R_TRIG_ManualJogDown.Q)                                                 // Trigger to start AB switch run in manual jog mode Down
	            AND NOT #Jog_Enable.qx_DelayedSignal
	        THEN
	            
	            #iqUDT_EquipmentControl.Request.SignalingRequest := TRUE;                  // Request signaling TO control block before AB switch runs in manual mode
	            
	        END_IF;
	        
	    END_REGION
	    
	    REGION 6.3 - Jog mode Up / Down
	        
	        IF #sx_PreStartManual                                                           // IF in manual jog mode 
	            AND (NOT #iqUDT_EquipmentControl.Request.SignalingRequest                  // Signaling request done
	            OR #Jog_Enable.qx_DelayedSignal)
	            AND #sx_CombinedJogUp                                                       // If selected jog in positive direction 
	            AND NOT #sx_CombinedJogDown                                                 // And not selected jog in negative direction
	        THEN
	            
	            #sx_JogUp := TRUE;                                                          // set jog positive 
	            #sx_JogDown := FALSE;                                                       // reset jog negative 
	            #sx_Jog := true;
	            
	        ELSIF
	            #sx_PreStartManual                                                          // IF in manual jog mode 
	            AND (NOT #iqUDT_EquipmentControl.Request.SignalingRequest                  // Signaling request done
	            OR #Jog_Enable.qx_DelayedSignal)
	            AND NOT #sx_CombinedJogUp                                                   // If selected jog in positive direction 
	            AND #sx_CombinedJogDown                                                     // and there is command to jog in negative direction 
	        THEN
	            
	            #sx_JogUp := FALSE;                                                         // reset jog positive 
	            #sx_JogDown := TRUE;                                                        // set jog negative 
	            #sx_Jog := true;
	            
	        ELSIF
	            NOT #sx_PreStartManual                                                      // If not in manual mode 
	            OR (#sx_PreStartManual                                                      // or in manual mode
	            AND (#sx_CombinedJogUp                                                      // and jog positive is off 
	            AND #sx_CombinedJogDown)                                                    // AND jog negative is off 
	            OR (NOT #sx_CombinedJogUp                                                   // or jog positive is on 
	            AND NOT #sx_CombinedJogDown))                                               // and jog negative is on 
	        THEN
	            
	            #sx_JogUp := FALSE;                                                         // reset jog positive 
	            #sx_JogDown := FALSE;                                                       // reset jog negative 
	            #sx_Jog := False;
	        END_IF;
	    END_REGION
	    
	END_REGION
	
	REGION 7 - Automatic mode
	    
	    REGION 7.1 - Semi automatic
	        
	        IF #sx_SemiAutomatic                                                            // Not running Semi-Automatic
	            AND (#ii_Mode = #ci_UpperPosition
	            AND #ix_ChangeModeSignal)
	        THEN
	            
	            #sx_PreStartSemiAutomaticUp := TRUE;
	            
	            #sx_DownRequest := FALSE;                                                   // Reset down command
	            #sx_UpRequest := TRUE;                                                      // Set up command
	        END_IF;
	        
	        IF #sx_SemiAutomatic                                                            // Not running Semi-Automatic
	            AND (#ii_Mode = #ci_LowerPosition
	            AND #ix_ChangeModeSignal)
	            
	        THEN
	            
	            #sx_PreStartSemiAutomaticDown := TRUE;
	            
	            #sx_DownRequest := TRUE;                                                    // Reset down command
	            #sx_UpRequest := FALSE;                                                     // Set up command
	        END_IF;
	        
	        #R_TRIG_PreStartSemiAutomaticUp(CLK := #sx_PreStartSemiAutomaticUp);
	        #R_TRIG_PreStartSemiAutomaticDown(CLK := #sx_PreStartSemiAutomaticDown);
	        
	        //Set Signaling Request 
	        IF #R_TRIG_PreStartSemiAutomaticUp.Q OR #R_TRIG_PreStartSemiAutomaticDown.Q THEN
	            #iqUDT_EquipmentControl.Request.SignalingRequest := TRUE;
	        END_IF;
	        
	        IF #sx_SemiAutomatic
	            AND (NOT #ix_PRXUp
	            AND #sx_UpRequest)
	            OR #sUDT_HMIStatus.Specific.SwitchingTimerError
	        THEN
	            #sx_UpRequest := false;
	            #sx_PreStartSemiAutomaticUp := false;
	        END_IF;
	        
	        IF #sx_SemiAutomatic
	            AND (NOT #ix_PRXDown
	            AND #sx_DownRequest)
	            OR #sUDT_HMIStatus.Specific.SwitchingTimerError
	        THEN
	            #sx_DownRequest := false;
	            #sx_PreStartSemiAutomaticDown := false;
	        END_IF;
	        
	    END_REGION
	    
	    REGION 7.2 - Start/Stop AB switch conveyor directly
	        
	        // Start
	        IF #iqUDT_EquipmentControl.Command.Start                                       // Start from system
	            AND #sx_Ready                                                               // Equipment has no errors
	        THEN
	            #qx_ExternalHold := FALSE;                                           // External stop signal
	        END_IF;
	        
	        // Stop 
	        IF #sUDT_HMIStatus.Specific.UpperSwitchAreaError                                // Blockage of switching area
	            OR #sUDT_HMIStatus.Specific.LowerSwitchAreaError
	            OR NOT #sx_SemiAutomatic                                                    // The AB switch is not (semi-)automatic active
	        THEN
	            #qx_ExternalHold := TRUE;                                            // External stop signal
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION 8 - Write interface DB signals
	    
	    REGION 8.1 - Signal interface
	        
	        #iqUDT_ABSwitchInterface.InternalErrorReset := #iqUDT_EquipmentControl.Command.Reset;      // Write Reset signal to the VFD interface
	        #iqUDT_ABSwitchInterface.ResetStatistics := #iqUDT_EquipmentControl.Command.ResetData;     // Write Reset data signal to the VFD interface
	        
	    END_REGION
	    
	    REGION 8.1 - Mode selection 
	        
	        #ss_ABSwitch_Interface.SemiAutomatic :=
	        (#sx_SemiAutomatic                                                               // Automatic started
	        OR #sx_Stopping);                                                                // stopping is activated Go to default position
	        
	        #ss_ABSwitch_Interface.Manual :=
	        #ix_SSMan                                                             // Manual mode is started
	        AND (#sx_CombinedJogUp                                                           // IF selected jog in positive direction 
	        OR #sx_CombinedJogDown);
	        
	    END_REGION
	    
	    REGION 8.2 - Run enable
	        
	        #ss_ABSwitch_Interface.RunEnabled :=                                                  // Enable the positioning device to run
	        NOT #iqUDT_ABSwitchInterface.InternalErrorVFD                               // or there are errors in the VFD
	        AND NOT #sx_ConfigurationError                                                   // configuration is wrong
	        AND #ix_HardwareOk                                                        // or an internal error in the RIO panel occured                             
	        AND (#ss_ABSwitch_Interface.SemiAutomatic                                             // AB switch is in semi-automatic mode
	        OR (#ss_ABSwitch_Interface.Manual                                                     // manual mode is active
	        AND (#sx_CombinedJogUp                                                           // If selected jog in positive direction 
	        OR #sx_CombinedJogDown)));                                                       // If selected jog in negative direction 
	        
	    END_REGION
	    
	END_REGION
	
	REGION 9 - Positions reached
	    
	    // triggers of PEC's down/up
	    #F_TRIG_PECUp(CLK := #ix_PRXUp);
	    #F_TRIG_PECDown(CLK := #ix_PRXDown);
	    
	    // when the upper photo eye to stop the AB switch is covered it means the position is reached
	    IF #F_TRIG_PECUp.Q THEN
	        #sx_UpperPositionReached := true;
	    ELSIF #sx_DownRequest OR #ix_SSMan THEN
	        #sx_UpperPositionReached := false;
	    END_IF;
	    
	    // when the lower photo eye to stop the AB switch is covered it means the position is reached
	    IF #F_TRIG_PECDown.Q THEN
	        #sx_LowerPositionReached := true;
	    ELSIF #sx_UpRequest OR #ix_SSMan THEN
	        #sx_LowerPositionReached := false;
	    END_IF;
	    
	END_REGION
	
	REGION 10 - Run up/down
	    
	    // Conditions to run AB switch down 
	    #iqUDT_ABSwitchInterface.RunRvs := ((#sx_DownRequest AND #sx_SemiAutomatic)
	    OR #sx_JogDown)
	    AND NOT #sx_LowerPositionReached
	    AND #ss_ABSwitch_Interface.RunEnabled
	    AND #ix_PRXDown
	    AND NOT #sUDT_HMIStatus.Specific.LimitSensorLowerPosition;
	    
	    // Conditions to run AB switch upwards
	    #iqUDT_ABSwitchInterface.RunFwd := ((#sx_UpRequest AND #sx_SemiAutomatic)
	    OR #sx_JogUp)
	    AND NOT #sx_UpperPositionReached
	    AND #ss_ABSwitch_Interface.RunEnabled
	    AND #ix_PRXUp
	    AND NOT #sUDT_HMIStatus.Specific.LimitSensorUpperPosition;
	    
	END_REGION
	
	REGION 11 - AB switch speed reduction
	    
	    #F_TRIG_PECBrakeUp(CLK := #ix_PRXBrkUp);
	    
	    #F_TRIG_PECBrakeDown(CLK := #ix_PRXBrkDwn);
	    
	    IF #F_TRIG_PECBrakeUp.Q
	        AND #iqUDT_ABSwitchInterface.RunFwd
	    THEN
	        #sx_ABSwitchSlowSpeedUp := TRUE;
	    END_IF;
	    
	    IF #F_TRIG_PECBrakeDown.Q
	        AND #iqUDT_ABSwitchInterface.RunRvs
	    THEN
	        #sx_ABSwitchSlowSpeedDown := TRUE;
	    END_IF;
	    
	    IF ((#ss_ABSwitch_Interface.Positioning
	        AND #iqUDT_ABSwitchInterface.RunFwd
	        AND #sx_ABSwitchSlowSpeedUp
	        AND #ix_PRXUp)
	        OR
	        (#ss_ABSwitch_Interface.Positioning
	        AND #iqUDT_ABSwitchInterface.RunRvs
	        AND #sx_ABSwitchSlowSpeedDown
	        AND #ix_PRXDown))
	    THEN
	        #iqUDT_ABSwitchInterface.SpeedSetpoint := #iUDT_ABSwitchConfig.BrakingSpeedSetpoint;
	    ELSE
	        #iqUDT_ABSwitchInterface.SpeedSetpoint := #iUDT_ABSwitchConfig.NominalSpeedSetPoint;
	        #sx_ABSwitchSlowSpeedUp := FALSE;
	        #sx_ABSwitchSlowSpeedDown := FALSE;
	    END_IF;
	    
	    IF #ss_ABSwitch_Interface.Manual THEN
	        #iqUDT_ABSwitchInterface.SpeedSetpoint := #iUDT_ABSwitchConfig.ManualModeSpeed;
	    END_IF;
	    
	END_REGION
	
	REGION 12 - Statistics
	    
	    // Down Time
	    IF #sx_SemiAutomatic                                                                 // Automatic active
	        AND NOT #sx_Ready                                                                // Conveyor not ready
	        OR #iqUDT_EquipmentControl.Command.ResetData                                    // Reset statistics
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,              // Or reset statistics from control
	                        ix_Activate := #sx_SemiAutomatic AND NOT #sx_Ready,                     // AB switch is stopped 
	                        ix_RTrigActivate := #R_TRIG_DownTime.Q,                                      // AB switch is stopped triger 
	                        iqUDT_Statistics := #iqUDT_Statistics.DownTime);                            // AB switch is stopped statistics 
	    END_IF;
	    
	    // Up time
	    IF #sx_SemiAutomatic                                // Automatic active
	        AND #sx_Ready                                   // Ready active
	        OR #iqUDT_EquipmentControl.Command.ResetData   // Reset statistics
	    THEN
	        "FC_Statistics"(ix_Reset := #iqUDT_EquipmentControl.Command.ResetData,        // OR reset statistics from control
	                        ix_Activate := #sx_SemiAutomatic AND #sx_Ready,                   // AB switch is running 
	                        ix_RTrigActivate := #R_TRIG_UpTime.Q,                                  // AB switch running trigger 
	                        iqUDT_Statistics := #iqUDT_Statistics.UpTime);                        // AB switch running statistics
	        
	    END_IF;
	    
	    // Upper switch area error
	    #R_TRIG_UPSwA_Error(CLK := #sUDT_HMIStatus.Specific.UpperSwitchAreaError);               // Oneshot trigger error occurred
	    
	    IF #iqUDT_ABSwitchInterface.ResetStatistics OR                                         // IF there is signal TO reset statistics from AB switch interface 
	        #iqUDT_EquipmentControl.Command.ResetData OR                                        // Or there is signal to reset statistics from equipment control structure 
	        #sUDT_HMIStatus.Specific.UpperSwitchAreaError                                        // Or an upper switch area error occurred 
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_ABSwitchInterface.ResetStatistics OR                 // Reset statistics from HMI
	                        #iqUDT_EquipmentControl.Command.ResetData,                                       // Or reset statistics from control
	                        ix_Activate := #sUDT_HMIStatus.Specific.UpperSwitchAreaError,               // Upper switch area error occurred
	                        ix_RTrigActivate := #R_TRIG_UPSwA_Error.Q,                                       // Error trigger 
	                        iqUDT_Statistics := #iqUDT_Statistics.UpperSwitchArea_Error);                   // Statistics of AB switch errors 
	        
	    END_IF;
	    
	    // Lower switch area error
	    #R_TRIG_LowSwA_Error(CLK := #sUDT_HMIStatus.Specific.LowerSwitchAreaError);              // Oneshot trigger error occurred
	    
	    IF #iqUDT_ABSwitchInterface.ResetStatistics OR                                          // IF there is signal TO reset statistics from AB switch interface 
	        #iqUDT_EquipmentControl.Command.ResetData OR                                        // Or there is signal to reset statistics from equipment control structure 
	        #sUDT_HMIStatus.Specific.LowerSwitchAreaError                                        // Or an upper switch area error occurred 
	    THEN
	        
	        "FC_Statistics"(ix_Reset := #iqUDT_ABSwitchInterface.ResetStatistics OR                 // Reset statistics from HMI
	                        #iqUDT_EquipmentControl.Command.ResetData,                                       // Or reset statistics from control
	                        ix_Activate := #sUDT_HMIStatus.Specific.LowerSwitchAreaError,               // Upper switch area error occurred
	                        ix_RTrigActivate := #R_TRIG_LowSwA_Error.Q,                                      // Error trigger 
	                        iqUDT_Statistics := #iqUDT_Statistics.LowerSwitchArea_Error);                   // Statistics of AB switch errors 
	        
	    END_IF;
	    
	END_REGION
	
	REGION 13 - Status 
	    
	    #sUDT_Status.Stopped := #sx_Ready AND NOT #sx_SemiAutomatic AND NOT #sx_Stopping;      // stopped
	    #sUDT_Status.AutoON := #sx_SemiAutomatic OR #sx_Stopping;                              // Auto On
	    #sUDT_Status.Halted := FALSE;                                                          // Halted
	    #sUDT_Status.Dieback := FALSE;                                                         // Die back
	    #sUDT_Status.Running := (#sx_UpRequest OR #sx_DownRequest) AND #sx_SemiAutomatic;      // Running
	    #sUDT_Status.ManualRun := #ix_SSMan AND #sUDT_Status.Running;              // Manual run
	    #sUDT_Status.Manual := #ix_SSMan;                                           // Manual
	    #sUDT_Status.EnergySave := FALSE;                                                      // Energy save active
	    #sUDT_Status.SafetyStop := NOT #ix_SafetyOk;                                           // Safety not ok
	    
	    IF #sUDT_StatusOld <> #sUDT_Status                                            // update on change
	    THEN
	        
	        // Set status to status number
	        #sUDT_HMIStatus.Status := 0;                                               // Initialise status number              
	        
	        IF #sUDT_Status.Running                                                    // Running
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Running;
	            
	        END_IF;
	        
	        IF #sUDT_Status.Stopped                                                    // Stopped
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Stopped;
	            
	        END_IF;
	        
	        IF #sUDT_Status.Dieback                                                    // Dieback
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Dieback;
	            
	        END_IF;
	        
	        IF #sUDT_Status.ManualRun                                                  // Manual run
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".ManualRun;
	            
	        END_IF;
	        
	        IF #sUDT_Status.Manual                                                     // Manual
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Manual;
	            
	        END_IF;
	        
	        IF #iqUDT_ABSwitchInterface.InternalWarningVFD                                  // The VFD has an internal warning
	            OR NOT #ix_HardwareOk                                                         // The RIO panel has an internal warning    
	            
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Warning;
	            
	        END_IF;
	        
	        IF #sUDT_HMIStatus.Specific.UpperSwitchAreaError                           // Upper limit switch error
	            OR #sUDT_HMIStatus.Specific.LowerSwitchAreaError                       // Lower limit switch error
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".VFDError;
	            
	        END_IF;
	        
	        IF #iqUDT_ABSwitchInterface.InternalErrorVFD                                // The VFD has an internal error
	            OR NOT #ix_HardwareOk                                                    // The RIO panel has an internal error
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".Error;
	            
	        END_IF;
	        
	        
	        IF #sUDT_Status.SafetyStop                                                 // Safety stop
	        THEN
	            
	            #sUDT_HMIStatus.Status := "DB_HMIStatusConfiguration".SafetyStop;
	            
	        END_IF;
	        
	        // Copy status to output
	        #sUDT_StatusOld := #sUDT_Status;                                          // Copy status TO memory
	        #qUDT_Status := #sUDT_Status;                                             // Copy status to output
	        
	    END_IF;
	    
	    //   Specific status
	    #sUDT_HMIStatus.Specific.UpperPosition := #sx_ActualPositionUP;
	    #sUDT_HMIStatus.Specific.LowerPosition := #sx_ActualPositionDown;
	    
	    #qUDT_HMIStatus := #sUDT_HMIStatus;
	    
	END_REGION
	
	REGION 14 - Report to control block
	    
	    "FC_EquipmentReport"(iUDT_Status := #sUDT_Status,
	                         iqUDT_Control := #iqUDT_EquipmentControl);
	    
	END_REGION
	
	REGION 15 - Internal errors and warnings reset
	    
	    #iqUDT_ABSwitchInterface.InternalErrorPEC := FALSE;
	    #iqUDT_ABSwitchInterface.InternalWarningTracking := FALSE;
	    #iqUDT_ABSwitchInterface.InternalErrorTracking := FALSE;
	    #iqUDT_ABSwitchInterface.InternalWarningVFD := FALSE;
	    #iqUDT_ABSwitchInterface.InternalErrorVFD := FALSE;
	    #iqUDT_ABSwitchInterface.Disconnected := FALSE;
	    
	END_REGION
	
END_FUNCTION_BLOCK

